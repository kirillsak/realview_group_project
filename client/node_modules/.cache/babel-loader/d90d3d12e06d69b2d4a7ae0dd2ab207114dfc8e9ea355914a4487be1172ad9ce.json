{"ast":null,"code":"import { DataBuffer } from \"./dataBuffer.js\";\n/**\n * Class used to store data that will be store in GPU memory\n */\nexport class Buffer {\n  /**\n   * Constructor\n   * @param engine the engine\n   * @param data the data to use for this buffer\n   * @param updatable whether the data is updatable\n   * @param stride the stride (optional)\n   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n   * @param instanced whether the buffer is instanced (optional)\n   * @param useBytes set to true if the stride in in bytes (optional)\n   * @param divisor sets an optional divisor for instances (1 by default)\n   */\n  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor) {\n    this._isAlreadyOwned = false;\n    if (engine.getScene) {\n      // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\n      this._engine = engine.getScene().getEngine();\n    } else {\n      this._engine = engine;\n    }\n    this._updatable = updatable;\n    this._instanced = instanced;\n    this._divisor = divisor || 1;\n    if (data instanceof DataBuffer) {\n      this._data = null;\n      this._buffer = data;\n    } else {\n      this._data = data;\n      this._buffer = null;\n    }\n    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\n    if (!postponeInternalCreation) {\n      // by default\n      this.create();\n    }\n  }\n  /**\n   * Create a new VertexBuffer based on the current buffer\n   * @param kind defines the vertex buffer kind (position, normal, etc.)\n   * @param offset defines offset in the buffer (0 by default)\n   * @param size defines the size in floats of attributes (position is 3 for instance)\n   * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\n   * @param instanced defines if the vertex buffer contains indexed data\n   * @param useBytes defines if the offset and stride are in bytes     *\n   * @param divisor sets an optional divisor for instances (1 by default)\n   * @returns the new vertex buffer\n   */\n  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {\n    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\n    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;\n    // a lot of these parameters are ignored as they are overridden by the buffer\n    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === undefined ? this._instanced : instanced, byteOffset, size, undefined, undefined, true, this._divisor || divisor);\n  }\n  // Properties\n  /**\n   * Gets a boolean indicating if the Buffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n  isUpdatable() {\n    return this._updatable;\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n  getData() {\n    return this._data;\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n  getStrideSize() {\n    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\n  }\n  // Methods\n  /**\n   * Store data into the buffer. Creates the buffer if not used already.\n   * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\n   * @param data defines the data to store\n   */\n  create(data = null) {\n    if (!data && this._buffer) {\n      return; // nothing to do\n    }\n\n    data = data || this._data;\n    if (!data) {\n      return;\n    }\n    if (!this._buffer) {\n      // create buffer\n      if (this._updatable) {\n        this._buffer = this._engine.createDynamicVertexBuffer(data);\n        this._data = data;\n      } else {\n        this._buffer = this._engine.createVertexBuffer(data);\n      }\n    } else if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data);\n      this._data = data;\n    }\n  }\n  /** @internal */\n  _rebuild() {\n    this._buffer = null;\n    this.create(this._data);\n  }\n  /**\n   * Update current buffer data\n   * @param data defines the data to store\n   */\n  update(data) {\n    this.create(data);\n  }\n  /**\n   * Updates the data directly.\n   * @param data the new data\n   * @param offset the new offset\n   * @param vertexCount the vertex count (optional)\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateDirectly(data, offset, vertexCount, useBytes = false) {\n    if (!this._buffer) {\n      return;\n    }\n    if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : undefined);\n      if (offset === 0 && vertexCount === undefined) {\n        // Keep the data if we easily can\n        this._data = data;\n      } else {\n        this._data = null;\n      }\n    }\n  }\n  /** @internal */\n  _increaseReferences() {\n    if (!this._buffer) {\n      return;\n    }\n    if (!this._isAlreadyOwned) {\n      this._isAlreadyOwned = true;\n      return;\n    }\n    this._buffer.references++;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    if (!this._buffer) {\n      return;\n    }\n    if (this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n      this._data = null;\n    }\n  }\n}\n/**\n * Specialized buffer used to store vertex data\n */\nexport class VertexBuffer {\n  /**\n   * Constructor\n   * @param engine the engine\n   * @param data the data to use for this vertex buffer\n   * @param kind the vertex buffer kind\n   * @param updatable whether the data is updatable\n   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n   * @param stride the stride (optional)\n   * @param instanced whether the buffer is instanced (optional)\n   * @param offset the offset of the data (optional)\n   * @param size the number of components (optional)\n   * @param type the type of the component (optional)\n   * @param normalized whether the data contains normalized data (optional)\n   * @param useBytes set to true if stride and offset are in bytes (optional)\n   * @param divisor defines the instance divisor to use (1 by default)\n   * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\n   */\n  constructor(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {\n    if (data instanceof Buffer) {\n      this._buffer = data;\n      this._ownsBuffer = takeBufferOwnership;\n    } else {\n      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);\n      this._ownsBuffer = true;\n    }\n    this.uniqueId = VertexBuffer._Counter++;\n    this._kind = kind;\n    if (type == undefined) {\n      const vertexData = this.getData();\n      this.type = VertexBuffer.FLOAT;\n      if (vertexData instanceof Int8Array) {\n        this.type = VertexBuffer.BYTE;\n      } else if (vertexData instanceof Uint8Array) {\n        this.type = VertexBuffer.UNSIGNED_BYTE;\n      } else if (vertexData instanceof Int16Array) {\n        this.type = VertexBuffer.SHORT;\n      } else if (vertexData instanceof Uint16Array) {\n        this.type = VertexBuffer.UNSIGNED_SHORT;\n      } else if (vertexData instanceof Int32Array) {\n        this.type = VertexBuffer.INT;\n      } else if (vertexData instanceof Uint32Array) {\n        this.type = VertexBuffer.UNSIGNED_INT;\n      }\n    } else {\n      this.type = type;\n    }\n    const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n    if (useBytes) {\n      this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\n      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = offset || 0;\n    } else {\n      this._size = size || stride || VertexBuffer.DeduceStride(kind);\n      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = (offset || 0) * typeByteLength;\n    }\n    this.normalized = normalized;\n    this._instanced = instanced !== undefined ? instanced : false;\n    this._instanceDivisor = instanced ? divisor : 0;\n    this._computeHashCode();\n  }\n  /**\n   * Gets or sets the instance divisor when in instanced mode\n   */\n  get instanceDivisor() {\n    return this._instanceDivisor;\n  }\n  set instanceDivisor(value) {\n    const isInstanced = value != 0;\n    this._instanceDivisor = value;\n    if (isInstanced !== this._instanced) {\n      this._instanced = isInstanced;\n      this._computeHashCode();\n    }\n  }\n  _computeHashCode() {\n    // note: cast to any because the property is declared readonly\n    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + ( /* keep 5 bits free */\n    this.byteStride << 12);\n  }\n  /** @internal */\n  _rebuild() {\n    if (!this._buffer) {\n      return;\n    }\n    this._buffer._rebuild();\n  }\n  /**\n   * Returns the kind of the VertexBuffer (string)\n   * @returns a string\n   */\n  getKind() {\n    return this._kind;\n  }\n  // Properties\n  /**\n   * Gets a boolean indicating if the VertexBuffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n  isUpdatable() {\n    return this._buffer.isUpdatable();\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n  getData() {\n    return this._buffer.getData();\n  }\n  /**\n   * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param totalVertices number of vertices in the buffer to take into account\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  getFloatData(totalVertices, forceCopy) {\n    const data = this.getData();\n    if (!data) {\n      return null;\n    }\n    const tightlyPackedByteStride = this.getSize() * VertexBuffer.GetTypeByteLength(this.type);\n    const count = totalVertices * this.getSize();\n    if (this.type !== VertexBuffer.FLOAT || this.byteStride !== tightlyPackedByteStride) {\n      const copy = new Float32Array(count);\n      this.forEach(count, (value, index) => copy[index] = value);\n      return copy;\n    }\n    if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {\n      if (data instanceof Array) {\n        const offset = this.byteOffset / 4;\n        return data.slice(offset, offset + count);\n      } else if (data instanceof ArrayBuffer) {\n        return new Float32Array(data, this.byteOffset, count);\n      } else {\n        let offset = data.byteOffset + this.byteOffset;\n        if (forceCopy) {\n          const result = new Float32Array(count);\n          const source = new Float32Array(data.buffer, offset, count);\n          result.set(source);\n          return result;\n        }\n        // Protect against bad data\n        const remainder = offset % 4;\n        if (remainder) {\n          offset = Math.max(0, offset - remainder);\n        }\n        return new Float32Array(data.buffer, offset, count);\n      }\n    }\n    if (forceCopy) {\n      return data.slice();\n    }\n    return data;\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n  getBuffer() {\n    return this._buffer.getBuffer();\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n  getStrideSize() {\n    return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the offset as a multiple of the type byte length.\n   * @returns the offset in bytes\n   * @deprecated Please use byteOffset instead.\n   */\n  getOffset() {\n    return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the number of components or the byte size per vertex attribute\n   * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\n   * @returns the number of components\n   */\n  getSize(sizeInBytes = false) {\n    return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\n  }\n  /**\n   * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\n   * @returns true if this buffer is instanced\n   */\n  getIsInstanced() {\n    return this._instanced;\n  }\n  /**\n   * Returns the instancing divisor, zero for non-instanced (integer).\n   * @returns a number\n   */\n  getInstanceDivisor() {\n    return this._instanceDivisor;\n  }\n  // Methods\n  /**\n   * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\n   * @param data defines the data to store\n   */\n  create(data) {\n    this._buffer.create(data);\n  }\n  /**\n   * Updates the underlying buffer according to the passed numeric array or Float32Array.\n   * This function will create a new buffer if the current one is not updatable\n   * @param data defines the data to store\n   */\n  update(data) {\n    this._buffer.update(data);\n  }\n  /**\n   * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n   * Returns the directly updated WebGLBuffer.\n   * @param data the new data\n   * @param offset the new offset\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateDirectly(data, offset, useBytes = false) {\n    this._buffer.updateDirectly(data, offset, undefined, useBytes);\n  }\n  /**\n   * Disposes the VertexBuffer and the underlying WebGLBuffer.\n   */\n  dispose() {\n    if (this._ownsBuffer) {\n      this._buffer.dispose();\n    }\n  }\n  /**\n   * Enumerates each value of this vertex buffer as numbers.\n   * @param count the number of values to enumerate\n   * @param callback the callback function called for each value\n   */\n  forEach(count, callback) {\n    VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\n  }\n  /**\n   * Deduces the stride given a kind.\n   * @param kind The kind string to deduce\n   * @returns The deduced stride\n   */\n  static DeduceStride(kind) {\n    switch (kind) {\n      case VertexBuffer.UVKind:\n      case VertexBuffer.UV2Kind:\n      case VertexBuffer.UV3Kind:\n      case VertexBuffer.UV4Kind:\n      case VertexBuffer.UV5Kind:\n      case VertexBuffer.UV6Kind:\n        return 2;\n      case VertexBuffer.NormalKind:\n      case VertexBuffer.PositionKind:\n        return 3;\n      case VertexBuffer.ColorKind:\n      case VertexBuffer.MatricesIndicesKind:\n      case VertexBuffer.MatricesIndicesExtraKind:\n      case VertexBuffer.MatricesWeightsKind:\n      case VertexBuffer.MatricesWeightsExtraKind:\n      case VertexBuffer.TangentKind:\n        return 4;\n      default:\n        throw new Error(\"Invalid kind '\" + kind + \"'\");\n    }\n  }\n  /**\n   * Gets the byte length of the given type.\n   * @param type the type\n   * @returns the number of bytes\n   */\n  static GetTypeByteLength(type) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n      case VertexBuffer.UNSIGNED_BYTE:\n        return 1;\n      case VertexBuffer.SHORT:\n      case VertexBuffer.UNSIGNED_SHORT:\n        return 2;\n      case VertexBuffer.INT:\n      case VertexBuffer.UNSIGNED_INT:\n      case VertexBuffer.FLOAT:\n        return 4;\n      default:\n        throw new Error(`Invalid type '${type}'`);\n    }\n  }\n  /**\n   * Enumerates each value of the given parameters as numbers.\n   * @param data the data to enumerate\n   * @param byteOffset the byte offset of the data\n   * @param byteStride the byte stride of the data\n   * @param componentCount the number of components per element\n   * @param componentType the type of the component\n   * @param count the number of values to enumerate\n   * @param normalized whether the data is normalized\n   * @param callback the callback function called for each value\n   */\n  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {\n    if (data instanceof Array) {\n      let offset = byteOffset / 4;\n      const stride = byteStride / 4;\n      for (let index = 0; index < count; index += componentCount) {\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          callback(data[offset + componentIndex], index + componentIndex);\n        }\n        offset += stride;\n      }\n    } else {\n      const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\n      const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\n      for (let index = 0; index < count; index += componentCount) {\n        let componentByteOffset = byteOffset;\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\n          callback(value, index + componentIndex);\n          componentByteOffset += componentByteLength;\n        }\n        byteOffset += byteStride;\n      }\n    }\n  }\n  static _GetFloatValue(dataView, type, byteOffset, normalized) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n        {\n          let value = dataView.getInt8(byteOffset);\n          if (normalized) {\n            value = Math.max(value / 127, -1);\n          }\n          return value;\n        }\n      case VertexBuffer.UNSIGNED_BYTE:\n        {\n          let value = dataView.getUint8(byteOffset);\n          if (normalized) {\n            value = value / 255;\n          }\n          return value;\n        }\n      case VertexBuffer.SHORT:\n        {\n          let value = dataView.getInt16(byteOffset, true);\n          if (normalized) {\n            value = Math.max(value / 32767, -1);\n          }\n          return value;\n        }\n      case VertexBuffer.UNSIGNED_SHORT:\n        {\n          let value = dataView.getUint16(byteOffset, true);\n          if (normalized) {\n            value = value / 65535;\n          }\n          return value;\n        }\n      case VertexBuffer.INT:\n        {\n          return dataView.getInt32(byteOffset, true);\n        }\n      case VertexBuffer.UNSIGNED_INT:\n        {\n          return dataView.getUint32(byteOffset, true);\n        }\n      case VertexBuffer.FLOAT:\n        {\n          return dataView.getFloat32(byteOffset, true);\n        }\n      default:\n        {\n          throw new Error(`Invalid component type ${type}`);\n        }\n    }\n  }\n}\nVertexBuffer._Counter = 0;\n/**\n * The byte type.\n */\nVertexBuffer.BYTE = 5120;\n/**\n * The unsigned byte type.\n */\nVertexBuffer.UNSIGNED_BYTE = 5121;\n/**\n * The short type.\n */\nVertexBuffer.SHORT = 5122;\n/**\n * The unsigned short type.\n */\nVertexBuffer.UNSIGNED_SHORT = 5123;\n/**\n * The integer type.\n */\nVertexBuffer.INT = 5124;\n/**\n * The unsigned integer type.\n */\nVertexBuffer.UNSIGNED_INT = 5125;\n/**\n * The float type.\n */\nVertexBuffer.FLOAT = 5126;\n// Enums\n/**\n * Positions\n */\nVertexBuffer.PositionKind = \"position\";\n/**\n * Normals\n */\nVertexBuffer.NormalKind = \"normal\";\n/**\n * Tangents\n */\nVertexBuffer.TangentKind = \"tangent\";\n/**\n * Texture coordinates\n */\nVertexBuffer.UVKind = \"uv\";\n/**\n * Texture coordinates 2\n */\nVertexBuffer.UV2Kind = \"uv2\";\n/**\n * Texture coordinates 3\n */\nVertexBuffer.UV3Kind = \"uv3\";\n/**\n * Texture coordinates 4\n */\nVertexBuffer.UV4Kind = \"uv4\";\n/**\n * Texture coordinates 5\n */\nVertexBuffer.UV5Kind = \"uv5\";\n/**\n * Texture coordinates 6\n */\nVertexBuffer.UV6Kind = \"uv6\";\n/**\n * Colors\n */\nVertexBuffer.ColorKind = \"color\";\n/**\n * Instance Colors\n */\nVertexBuffer.ColorInstanceKind = \"instanceColor\";\n/**\n * Matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesKind = \"matricesIndices\";\n/**\n * Matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsKind = \"matricesWeights\";\n/**\n * Additional matrix indices (for bones)\n */\nVertexBuffer.MatricesIndicesExtraKind = \"matricesIndicesExtra\";\n/**\n * Additional matrix weights (for bones)\n */\nVertexBuffer.MatricesWeightsExtraKind = \"matricesWeightsExtra\";","map":{"version":3,"mappings":"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","names":["DataBuffer","Buffer","constructor","engine","data","updatable","stride","postponeInternalCreation","instanced","useBytes","divisor","getScene","_engine","getEngine","_updatable","_instanced","_divisor","_data","_buffer","byteStride","Float32Array","BYTES_PER_ELEMENT","create","createVertexBuffer","kind","offset","size","byteOffset","VertexBuffer","undefined","isUpdatable","getData","getBuffer","getStrideSize","createDynamicVertexBuffer","updateDynamicVertexBuffer","_rebuild","update","updateDirectly","vertexCount","_increaseReferences","_isAlreadyOwned","references","dispose","_releaseBuffer","type","normalized","takeBufferOwnership","_ownsBuffer","uniqueId","_Counter","_kind","vertexData","FLOAT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","INT","Uint32Array","UNSIGNED_INT","typeByteLength","GetTypeByteLength","_size","DeduceStride","_instanceDivisor","_computeHashCode","instanceDivisor","value","isInstanced","hashCode","getKind","getFloatData","totalVertices","forceCopy","tightlyPackedByteStride","getSize","count","copy","forEach","index","Array","length","slice","ArrayBuffer","result","source","buffer","set","remainder","Math","max","getOffset","sizeInBytes","getIsInstanced","getInstanceDivisor","callback","ForEach","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","NormalKind","PositionKind","ColorKind","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","TangentKind","Error","componentCount","componentType","componentIndex","dataView","DataView","byteLength","componentByteLength","componentByteOffset","_GetFloatValue","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32"],"sourceRoot":"","sources":["../../../../lts/core/generated/Buffers/buffer.ts"],"sourcesContent":["import type { Nullable, DataArray, FloatArray } from \"../types\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { DataBuffer } from \"./dataBuffer\";\r\n\r\n/**\r\n * Class used to store data that will be store in GPU memory\r\n */\r\nexport class Buffer {\r\n    private _engine: ThinEngine;\r\n    private _buffer: Nullable<DataBuffer>;\r\n    /** @internal */\r\n    public _data: Nullable<DataArray>;\r\n    private _updatable: boolean;\r\n    private _instanced: boolean;\r\n    private _divisor: number;\r\n    private _isAlreadyOwned = false;\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this buffer\r\n     * @param updatable whether the data is updatable\r\n     * @param stride the stride (optional)\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param useBytes set to true if the stride in in bytes (optional)\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     */\r\n    constructor(\r\n        engine: any,\r\n        data: DataArray | DataBuffer,\r\n        updatable: boolean,\r\n        stride = 0,\r\n        postponeInternalCreation = false,\r\n        instanced = false,\r\n        useBytes = false,\r\n        divisor?: number\r\n    ) {\r\n        if (engine.getScene) {\r\n            // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\r\n            this._engine = engine.getScene().getEngine();\r\n        } else {\r\n            this._engine = engine;\r\n        }\r\n\r\n        this._updatable = updatable;\r\n        this._instanced = instanced;\r\n        this._divisor = divisor || 1;\r\n\r\n        if (data instanceof DataBuffer) {\r\n            this._data = null;\r\n            this._buffer = data;\r\n        } else {\r\n            this._data = data;\r\n            this._buffer = null;\r\n        }\r\n\r\n        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n        if (!postponeInternalCreation) {\r\n            // by default\r\n            this.create();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new VertexBuffer based on the current buffer\r\n     * @param kind defines the vertex buffer kind (position, normal, etc.)\r\n     * @param offset defines offset in the buffer (0 by default)\r\n     * @param size defines the size in floats of attributes (position is 3 for instance)\r\n     * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\r\n     * @param instanced defines if the vertex buffer contains indexed data\r\n     * @param useBytes defines if the offset and stride are in bytes     *\r\n     * @param divisor sets an optional divisor for instances (1 by default)\r\n     * @returns the new vertex buffer\r\n     */\r\n    public createVertexBuffer(kind: string, offset: number, size: number, stride?: number, instanced?: boolean, useBytes = false, divisor?: number): VertexBuffer {\r\n        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\r\n        const byteStride = stride ? (useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT) : this.byteStride;\r\n\r\n        // a lot of these parameters are ignored as they are overridden by the buffer\r\n        return new VertexBuffer(\r\n            this._engine,\r\n            this,\r\n            kind,\r\n            this._updatable,\r\n            true,\r\n            byteStride,\r\n            instanced === undefined ? this._instanced : instanced,\r\n            byteOffset,\r\n            size,\r\n            undefined,\r\n            undefined,\r\n            true,\r\n            this._divisor || divisor\r\n        );\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the Buffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._updatable;\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._data;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. Creates the buffer if not used already.\r\n     * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data: Nullable<DataArray> = null): void {\r\n        if (!data && this._buffer) {\r\n            return; // nothing to do\r\n        }\r\n\r\n        data = data || this._data;\r\n\r\n        if (!data) {\r\n            return;\r\n        }\r\n\r\n        if (!this._buffer) {\r\n            // create buffer\r\n            if (this._updatable) {\r\n                this._buffer = this._engine.createDynamicVertexBuffer(data);\r\n                this._data = data;\r\n            } else {\r\n                this._buffer = this._engine.createVertexBuffer(data);\r\n            }\r\n        } else if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(this._buffer, data);\r\n            this._data = data;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this._buffer = null;\r\n        this.create(this._data);\r\n    }\r\n\r\n    /**\r\n     * Update current buffer data\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the data directly.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param vertexCount the vertex count (optional)\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, vertexCount?: number, useBytes: boolean = false): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (this._updatable) {\r\n            // update buffer\r\n            this._engine.updateDynamicVertexBuffer(\r\n                this._buffer,\r\n                data,\r\n                useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT,\r\n                vertexCount ? vertexCount * this.byteStride : undefined\r\n            );\r\n            if (offset === 0 && vertexCount === undefined) {\r\n                // Keep the data if we easily can\r\n                this._data = data;\r\n            } else {\r\n                this._data = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _increaseReferences() {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._isAlreadyOwned) {\r\n            this._isAlreadyOwned = true;\r\n            return;\r\n        }\r\n\r\n        this._buffer.references++;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n        if (this._engine._releaseBuffer(this._buffer)) {\r\n            this._buffer = null;\r\n            this._data = null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Specialized buffer used to store vertex data\r\n */\r\nexport class VertexBuffer {\r\n    private static _Counter = 0;\r\n\r\n    /** @internal */\r\n    public _buffer: Buffer;\r\n    /** @internal */\r\n    public _validOffsetRange: boolean; // used internally by the engine\r\n    private _kind: string;\r\n    private _size: number;\r\n    private _ownsBuffer: boolean;\r\n    private _instanced: boolean;\r\n    private _instanceDivisor: number;\r\n\r\n    /**\r\n     * The byte type.\r\n     */\r\n    public static readonly BYTE = 5120;\r\n\r\n    /**\r\n     * The unsigned byte type.\r\n     */\r\n    public static readonly UNSIGNED_BYTE = 5121;\r\n\r\n    /**\r\n     * The short type.\r\n     */\r\n    public static readonly SHORT = 5122;\r\n\r\n    /**\r\n     * The unsigned short type.\r\n     */\r\n    public static readonly UNSIGNED_SHORT = 5123;\r\n\r\n    /**\r\n     * The integer type.\r\n     */\r\n    public static readonly INT = 5124;\r\n\r\n    /**\r\n     * The unsigned integer type.\r\n     */\r\n    public static readonly UNSIGNED_INT = 5125;\r\n\r\n    /**\r\n     * The float type.\r\n     */\r\n    public static readonly FLOAT = 5126;\r\n\r\n    /**\r\n     * Gets or sets the instance divisor when in instanced mode\r\n     */\r\n    public get instanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    public set instanceDivisor(value: number) {\r\n        const isInstanced = value != 0;\r\n        this._instanceDivisor = value;\r\n\r\n        if (isInstanced !== this._instanced) {\r\n            this._instanced = isInstanced;\r\n            this._computeHashCode();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte stride.\r\n     */\r\n    public readonly byteStride: number;\r\n\r\n    /**\r\n     * Gets the byte offset.\r\n     */\r\n    public readonly byteOffset: number;\r\n\r\n    /**\r\n     * Gets whether integer data values should be normalized into a certain range when being casted to a float.\r\n     */\r\n    public readonly normalized: boolean;\r\n\r\n    /**\r\n     * Gets the data type of each component in the array.\r\n     */\r\n    public readonly type: number;\r\n\r\n    /**\r\n     * Gets the unique id of this vertex buffer\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * Gets a hash code representing the format (type, normalized, size, instanced, stride) of this buffer\r\n     * All buffers with the same format will have the same hash code\r\n     */\r\n    public readonly hashCode: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param engine the engine\r\n     * @param data the data to use for this vertex buffer\r\n     * @param kind the vertex buffer kind\r\n     * @param updatable whether the data is updatable\r\n     * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\r\n     * @param stride the stride (optional)\r\n     * @param instanced whether the buffer is instanced (optional)\r\n     * @param offset the offset of the data (optional)\r\n     * @param size the number of components (optional)\r\n     * @param type the type of the component (optional)\r\n     * @param normalized whether the data contains normalized data (optional)\r\n     * @param useBytes set to true if stride and offset are in bytes (optional)\r\n     * @param divisor defines the instance divisor to use (1 by default)\r\n     * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\r\n     */\r\n    constructor(\r\n        engine: any,\r\n        data: DataArray | Buffer | DataBuffer,\r\n        kind: string,\r\n        updatable: boolean,\r\n        postponeInternalCreation?: boolean,\r\n        stride?: number,\r\n        instanced?: boolean,\r\n        offset?: number,\r\n        size?: number,\r\n        type?: number,\r\n        normalized = false,\r\n        useBytes = false,\r\n        divisor = 1,\r\n        takeBufferOwnership = false\r\n    ) {\r\n        if (data instanceof Buffer) {\r\n            this._buffer = data;\r\n            this._ownsBuffer = takeBufferOwnership;\r\n        } else {\r\n            this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);\r\n            this._ownsBuffer = true;\r\n        }\r\n\r\n        this.uniqueId = VertexBuffer._Counter++;\r\n        this._kind = kind;\r\n\r\n        if (type == undefined) {\r\n            const vertexData = this.getData();\r\n            this.type = VertexBuffer.FLOAT;\r\n            if (vertexData instanceof Int8Array) {\r\n                this.type = VertexBuffer.BYTE;\r\n            } else if (vertexData instanceof Uint8Array) {\r\n                this.type = VertexBuffer.UNSIGNED_BYTE;\r\n            } else if (vertexData instanceof Int16Array) {\r\n                this.type = VertexBuffer.SHORT;\r\n            } else if (vertexData instanceof Uint16Array) {\r\n                this.type = VertexBuffer.UNSIGNED_SHORT;\r\n            } else if (vertexData instanceof Int32Array) {\r\n                this.type = VertexBuffer.INT;\r\n            } else if (vertexData instanceof Uint32Array) {\r\n                this.type = VertexBuffer.UNSIGNED_INT;\r\n            }\r\n        } else {\r\n            this.type = type;\r\n        }\r\n\r\n        const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\r\n\r\n        if (useBytes) {\r\n            this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\r\n            this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = offset || 0;\r\n        } else {\r\n            this._size = size || stride || VertexBuffer.DeduceStride(kind);\r\n            this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\r\n            this.byteOffset = (offset || 0) * typeByteLength;\r\n        }\r\n\r\n        this.normalized = normalized;\r\n\r\n        this._instanced = instanced !== undefined ? instanced : false;\r\n        this._instanceDivisor = instanced ? divisor : 0;\r\n\r\n        this._computeHashCode();\r\n    }\r\n\r\n    private _computeHashCode(): void {\r\n        // note: cast to any because the property is declared readonly\r\n        (this.hashCode as any) =\r\n            ((this.type - 5120) << 0) +\r\n            ((this.normalized ? 1 : 0) << 3) +\r\n            (this._size << 4) +\r\n            ((this._instanced ? 1 : 0) << 6) +\r\n            /* keep 5 bits free */\r\n            (this.byteStride << 12);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (!this._buffer) {\r\n            return;\r\n        }\r\n\r\n        this._buffer._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Returns the kind of the VertexBuffer (string)\r\n     * @returns a string\r\n     */\r\n    public getKind(): string {\r\n        return this._kind;\r\n    }\r\n\r\n    // Properties\r\n\r\n    /**\r\n     * Gets a boolean indicating if the VertexBuffer is updatable?\r\n     * @returns true if the buffer is updatable\r\n     */\r\n    public isUpdatable(): boolean {\r\n        return this._buffer.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data\r\n     * @returns a DataArray or null\r\n     */\r\n    public getData(): Nullable<DataArray> {\r\n        return this._buffer.getData();\r\n    }\r\n\r\n    /**\r\n     * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param totalVertices number of vertices in the buffer to take into account\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getFloatData(totalVertices: number, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const data = this.getData();\r\n        if (!data) {\r\n            return null;\r\n        }\r\n\r\n        const tightlyPackedByteStride = this.getSize() * VertexBuffer.GetTypeByteLength(this.type);\r\n        const count = totalVertices * this.getSize();\r\n\r\n        if (this.type !== VertexBuffer.FLOAT || this.byteStride !== tightlyPackedByteStride) {\r\n            const copy = new Float32Array(count);\r\n            this.forEach(count, (value, index) => (copy[index] = value));\r\n            return copy;\r\n        }\r\n\r\n        if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {\r\n            if (data instanceof Array) {\r\n                const offset = this.byteOffset / 4;\r\n                return data.slice(offset, offset + count);\r\n            } else if (data instanceof ArrayBuffer) {\r\n                return new Float32Array(data, this.byteOffset, count);\r\n            } else {\r\n                let offset = data.byteOffset + this.byteOffset;\r\n                if (forceCopy) {\r\n                    const result = new Float32Array(count);\r\n                    const source = new Float32Array(data.buffer, offset, count);\r\n\r\n                    result.set(source);\r\n\r\n                    return result;\r\n                }\r\n\r\n                // Protect against bad data\r\n                const remainder = offset % 4;\r\n\r\n                if (remainder) {\r\n                    offset = Math.max(0, offset - remainder);\r\n                }\r\n\r\n                return new Float32Array(data.buffer, offset, count);\r\n            }\r\n        }\r\n\r\n        if (forceCopy) {\r\n            return data.slice();\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Gets underlying native buffer\r\n     * @returns underlying native buffer\r\n     */\r\n    public getBuffer(): Nullable<DataBuffer> {\r\n        return this._buffer.getBuffer();\r\n    }\r\n\r\n    /**\r\n     * Gets the stride in float32 units (i.e. byte stride / 4).\r\n     * May not be an integer if the byte stride is not divisible by 4.\r\n     * @returns the stride in float32 units\r\n     * @deprecated Please use byteStride instead.\r\n     */\r\n    public getStrideSize(): number {\r\n        return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the offset as a multiple of the type byte length.\r\n     * @returns the offset in bytes\r\n     * @deprecated Please use byteOffset instead.\r\n     */\r\n    public getOffset(): number {\r\n        return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of components or the byte size per vertex attribute\r\n     * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\r\n     * @returns the number of components\r\n     */\r\n    public getSize(sizeInBytes = false): number {\r\n        return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\r\n     * @returns true if this buffer is instanced\r\n     */\r\n    public getIsInstanced(): boolean {\r\n        return this._instanced;\r\n    }\r\n\r\n    /**\r\n     * Returns the instancing divisor, zero for non-instanced (integer).\r\n     * @returns a number\r\n     */\r\n    public getInstanceDivisor(): number {\r\n        return this._instanceDivisor;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\r\n     * @param data defines the data to store\r\n     */\r\n    public create(data?: DataArray): void {\r\n        this._buffer.create(data);\r\n    }\r\n\r\n    /**\r\n     * Updates the underlying buffer according to the passed numeric array or Float32Array.\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param data defines the data to store\r\n     */\r\n    public update(data: DataArray): void {\r\n        this._buffer.update(data);\r\n    }\r\n\r\n    /**\r\n     * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\r\n     * Returns the directly updated WebGLBuffer.\r\n     * @param data the new data\r\n     * @param offset the new offset\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateDirectly(data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        this._buffer.updateDirectly(data, offset, undefined, useBytes);\r\n    }\r\n\r\n    /**\r\n     * Disposes the VertexBuffer and the underlying WebGLBuffer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._ownsBuffer) {\r\n            this._buffer.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of this vertex buffer as numbers.\r\n     * @param count the number of values to enumerate\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public forEach(count: number, callback: (value: number, index: number) => void): void {\r\n        VertexBuffer.ForEach(this._buffer.getData()!, this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\r\n    }\r\n\r\n    // Enums\r\n    /**\r\n     * Positions\r\n     */\r\n    public static readonly PositionKind = \"position\";\r\n    /**\r\n     * Normals\r\n     */\r\n    public static readonly NormalKind = \"normal\";\r\n    /**\r\n     * Tangents\r\n     */\r\n    public static readonly TangentKind = \"tangent\";\r\n    /**\r\n     * Texture coordinates\r\n     */\r\n    public static readonly UVKind = \"uv\";\r\n    /**\r\n     * Texture coordinates 2\r\n     */\r\n    public static readonly UV2Kind = \"uv2\";\r\n    /**\r\n     * Texture coordinates 3\r\n     */\r\n    public static readonly UV3Kind = \"uv3\";\r\n    /**\r\n     * Texture coordinates 4\r\n     */\r\n    public static readonly UV4Kind = \"uv4\";\r\n    /**\r\n     * Texture coordinates 5\r\n     */\r\n    public static readonly UV5Kind = \"uv5\";\r\n    /**\r\n     * Texture coordinates 6\r\n     */\r\n    public static readonly UV6Kind = \"uv6\";\r\n    /**\r\n     * Colors\r\n     */\r\n    public static readonly ColorKind = \"color\";\r\n    /**\r\n     * Instance Colors\r\n     */\r\n    public static readonly ColorInstanceKind = \"instanceColor\";\r\n    /**\r\n     * Matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesKind = \"matricesIndices\";\r\n    /**\r\n     * Matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsKind = \"matricesWeights\";\r\n    /**\r\n     * Additional matrix indices (for bones)\r\n     */\r\n    public static readonly MatricesIndicesExtraKind = \"matricesIndicesExtra\";\r\n    /**\r\n     * Additional matrix weights (for bones)\r\n     */\r\n    public static readonly MatricesWeightsExtraKind = \"matricesWeightsExtra\";\r\n\r\n    /**\r\n     * Deduces the stride given a kind.\r\n     * @param kind The kind string to deduce\r\n     * @returns The deduced stride\r\n     */\r\n    public static DeduceStride(kind: string): number {\r\n        switch (kind) {\r\n            case VertexBuffer.UVKind:\r\n            case VertexBuffer.UV2Kind:\r\n            case VertexBuffer.UV3Kind:\r\n            case VertexBuffer.UV4Kind:\r\n            case VertexBuffer.UV5Kind:\r\n            case VertexBuffer.UV6Kind:\r\n                return 2;\r\n            case VertexBuffer.NormalKind:\r\n            case VertexBuffer.PositionKind:\r\n                return 3;\r\n            case VertexBuffer.ColorKind:\r\n            case VertexBuffer.MatricesIndicesKind:\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n            case VertexBuffer.MatricesWeightsKind:\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n            case VertexBuffer.TangentKind:\r\n                return 4;\r\n            default:\r\n                throw new Error(\"Invalid kind '\" + kind + \"'\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the byte length of the given type.\r\n     * @param type the type\r\n     * @returns the number of bytes\r\n     */\r\n    public static GetTypeByteLength(type: number): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                return 1;\r\n            case VertexBuffer.SHORT:\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                return 2;\r\n            case VertexBuffer.INT:\r\n            case VertexBuffer.UNSIGNED_INT:\r\n            case VertexBuffer.FLOAT:\r\n                return 4;\r\n            default:\r\n                throw new Error(`Invalid type '${type}'`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enumerates each value of the given parameters as numbers.\r\n     * @param data the data to enumerate\r\n     * @param byteOffset the byte offset of the data\r\n     * @param byteStride the byte stride of the data\r\n     * @param componentCount the number of components per element\r\n     * @param componentType the type of the component\r\n     * @param count the number of values to enumerate\r\n     * @param normalized whether the data is normalized\r\n     * @param callback the callback function called for each value\r\n     */\r\n    public static ForEach(\r\n        data: DataArray,\r\n        byteOffset: number,\r\n        byteStride: number,\r\n        componentCount: number,\r\n        componentType: number,\r\n        count: number,\r\n        normalized: boolean,\r\n        callback: (value: number, index: number) => void\r\n    ): void {\r\n        if (data instanceof Array) {\r\n            let offset = byteOffset / 4;\r\n            const stride = byteStride / 4;\r\n            for (let index = 0; index < count; index += componentCount) {\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    callback(data[offset + componentIndex], index + componentIndex);\r\n                }\r\n                offset += stride;\r\n            }\r\n        } else {\r\n            const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n            const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\r\n            for (let index = 0; index < count; index += componentCount) {\r\n                let componentByteOffset = byteOffset;\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\r\n                    callback(value, index + componentIndex);\r\n                    componentByteOffset += componentByteLength;\r\n                }\r\n                byteOffset += byteStride;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetFloatValue(dataView: DataView, type: number, byteOffset: number, normalized: boolean): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE: {\r\n                let value = dataView.getInt8(byteOffset);\r\n                if (normalized) {\r\n                    value = Math.max(value / 127, -1);\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.UNSIGNED_BYTE: {\r\n                let value = dataView.getUint8(byteOffset);\r\n                if (normalized) {\r\n                    value = value / 255;\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.SHORT: {\r\n                let value = dataView.getInt16(byteOffset, true);\r\n                if (normalized) {\r\n                    value = Math.max(value / 32767, -1);\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.UNSIGNED_SHORT: {\r\n                let value = dataView.getUint16(byteOffset, true);\r\n                if (normalized) {\r\n                    value = value / 65535;\r\n                }\r\n                return value;\r\n            }\r\n            case VertexBuffer.INT: {\r\n                return dataView.getInt32(byteOffset, true);\r\n            }\r\n            case VertexBuffer.UNSIGNED_INT: {\r\n                return dataView.getUint32(byteOffset, true);\r\n            }\r\n            case VertexBuffer.FLOAT: {\r\n                return dataView.getFloat32(byteOffset, true);\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid component type ${type}`);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}