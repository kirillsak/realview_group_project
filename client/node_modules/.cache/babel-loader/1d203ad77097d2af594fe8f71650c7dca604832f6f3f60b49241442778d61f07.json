{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Quaternion, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { PhysicsImpostor } from \"../Physics/v1/physicsImpostor.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateCapsule } from \"../Meshes/Builders/capsuleBuilder.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\n/**\n * Used to show the physics impostor around the specific mesh\n */\nexport class PhysicsViewer {\n  /**\n   * Creates a new PhysicsViewer\n   * @param scene defines the hosting scene\n   */\n  constructor(scene) {\n    /** @internal */\n    this._impostors = [];\n    /** @internal */\n    this._meshes = [];\n    /** @internal */\n    this._bodies = [];\n    /** @internal */\n    this._bodyMeshes = [];\n    /** @internal */\n    this._numMeshes = 0;\n    /** @internal */\n    this._numBodies = 0;\n    this._debugMeshMeshes = new Array();\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n    const physicEngine = this._scene.getPhysicsEngine();\n    if (physicEngine) {\n      this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();\n    }\n    this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\n    this._utilityLayer.pickUtilitySceneFirst = false;\n    this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\n  }\n  /**\n   * Updates the debug meshes of the physics engine.\n   *\n   * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.\n   * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.\n   * This ensures that the debug meshes are up to date with the physics engine.\n   */\n  _updateDebugMeshes() {\n    const plugin = this._physicsEnginePlugin;\n    if ((plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 1) {\n      this._updateDebugMeshesV1();\n    } else {\n      this._updateDebugMeshesV2();\n    }\n  }\n  /**\n   * Updates the debug meshes of the physics engine.\n   *\n   * This method is useful for synchronizing the debug meshes with the physics impostors.\n   * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.\n   * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.\n   */\n  _updateDebugMeshesV1() {\n    const plugin = this._physicsEnginePlugin;\n    for (let i = 0; i < this._numMeshes; i++) {\n      const impostor = this._impostors[i];\n      if (!impostor) {\n        continue;\n      }\n      if (impostor.isDisposed) {\n        this.hideImpostor(this._impostors[i--]);\n      } else {\n        if (impostor.type === PhysicsImpostor.MeshImpostor) {\n          continue;\n        }\n        const mesh = this._meshes[i];\n        if (mesh && plugin) {\n          plugin.syncMeshWithImpostor(mesh, impostor);\n        }\n      }\n    }\n  }\n  /**\n   * Updates the debug meshes of the physics engine for V2 plugin.\n   *\n   * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.\n   * It iterates through the bodies array and updates the debug meshes with the current transform of each body.\n   * This ensures that the debug meshes accurately reflect the current state of the physics engine.\n   */\n  _updateDebugMeshesV2() {\n    const plugin = this._physicsEnginePlugin;\n    for (let i = 0; i < this._numBodies; i++) {\n      const body = this._bodies[i];\n      const transform = this._bodyMeshes[i];\n      if (body && transform) {\n        plugin.syncTransform(body, transform);\n      }\n    }\n  }\n  /**\n   * Renders a specified physic impostor\n   * @param impostor defines the impostor to render\n   * @param targetMesh defines the mesh represented by the impostor\n   * @returns the new debug mesh used to render the impostor\n   */\n  showImpostor(impostor, targetMesh) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numMeshes; i++) {\n      if (this._impostors[i] == impostor) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugMesh(impostor, targetMesh);\n    if (debugMesh) {\n      this._impostors[this._numMeshes] = impostor;\n      this._meshes[this._numMeshes] = debugMesh;\n      if (this._numMeshes === 0) {\n        this._renderFunction = this._updateDebugMeshes.bind(this);\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n      this._numMeshes++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Shows a debug mesh for a given physics body.\n   * @param body The physics body to show.\n   * @returns The debug mesh, or null if the body is already shown.\n   *\n   * This function is useful for visualizing the physics body in the scene.\n   * It creates a debug mesh for the given body and adds it to the scene.\n   * It also registers a before render function to update the debug mesh position and rotation.\n   */\n  showBody(body) {\n    if (!this._scene) {\n      return null;\n    }\n    for (let i = 0; i < this._numBodies; i++) {\n      if (this._bodies[i] == body) {\n        return null;\n      }\n    }\n    const debugMesh = this._getDebugBodyMesh(body);\n    if (debugMesh) {\n      this._bodies[this._numBodies] = body;\n      this._bodyMeshes[this._numBodies] = debugMesh;\n      if (this._numBodies === 0) {\n        this._renderFunction = this._updateDebugMeshes.bind(this);\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n      this._numBodies++;\n    }\n    return debugMesh;\n  }\n  /**\n   * Hides an impostor from the scene.\n   * @param impostor - The impostor to hide.\n   *\n   * This method is useful for hiding an impostor from the scene. It removes the\n   * impostor from the utility layer scene, disposes the mesh, and removes the\n   * impostor from the list of impostors. If the impostor is the last one in the\n   * list, it also unregisters the render function.\n   */\n  hideImpostor(impostor) {\n    if (!impostor || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numMeshes; i++) {\n      if (this._impostors[i] == impostor) {\n        const mesh = this._meshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        const index = this._debugMeshMeshes.indexOf(mesh);\n        if (index > -1) {\n          this._debugMeshMeshes.splice(index, 1);\n        }\n        this._numMeshes--;\n        if (this._numMeshes > 0) {\n          this._meshes[i] = this._meshes[this._numMeshes];\n          this._impostors[i] = this._impostors[this._numMeshes];\n          this._meshes[this._numMeshes] = null;\n          this._impostors[this._numMeshes] = null;\n        } else {\n          this._meshes[0] = null;\n          this._impostors[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numMeshes === 0) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n    }\n  }\n  /**\n   * Hides a body from the physics engine.\n   * @param body - The body to hide.\n   *\n   * This function is useful for hiding a body from the physics engine.\n   * It removes the body from the utility layer scene and disposes the mesh associated with it.\n   * It also unregisters the render function if the number of bodies is 0.\n   * This is useful for hiding a body from the physics engine without deleting it.\n   */\n  hideBody(body) {\n    if (!body || !this._scene || !this._utilityLayer) {\n      return;\n    }\n    let removed = false;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    for (let i = 0; i < this._numBodies; i++) {\n      if (this._bodies[i] === body) {\n        const mesh = this._bodyMeshes[i];\n        if (!mesh) {\n          continue;\n        }\n        utilityLayerScene.removeMesh(mesh);\n        mesh.dispose();\n        this._numBodies--;\n        if (this._numBodies > 0) {\n          this._bodyMeshes[i] = this._meshes[this._numBodies];\n          this._bodies[i] = this._bodies[this._numBodies];\n          this._bodyMeshes[this._numBodies] = null;\n          this._bodies[this._numBodies] = null;\n        } else {\n          this._bodyMeshes[0] = null;\n          this._bodies[0] = null;\n        }\n        removed = true;\n        break;\n      }\n    }\n    if (removed && this._numBodies === 0) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n    }\n  }\n  _getDebugMaterial(scene) {\n    if (!this._debugMaterial) {\n      this._debugMaterial = new StandardMaterial(\"\", scene);\n      this._debugMaterial.wireframe = true;\n      this._debugMaterial.emissiveColor = Color3.White();\n      this._debugMaterial.disableLighting = true;\n    }\n    return this._debugMaterial;\n  }\n  _getDebugBoxMesh(scene) {\n    if (!this._debugBoxMesh) {\n      this._debugBoxMesh = CreateBox(\"physicsBodyBoxViewMesh\", {\n        size: 1\n      }, scene);\n      this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugBoxMesh.material = this._getDebugMaterial(scene);\n      this._debugBoxMesh.setEnabled(false);\n    }\n    return this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\n  }\n  _getDebugSphereMesh(scene) {\n    if (!this._debugSphereMesh) {\n      this._debugSphereMesh = CreateSphere(\"physicsBodySphereViewMesh\", {\n        diameter: 1\n      }, scene);\n      this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugSphereMesh.material = this._getDebugMaterial(scene);\n      this._debugSphereMesh.setEnabled(false);\n    }\n    return this._debugSphereMesh.createInstance(\"physicsBodySphereViewInstance\");\n  }\n  _getDebugCapsuleMesh(scene) {\n    if (!this._debugCapsuleMesh) {\n      this._debugCapsuleMesh = CreateCapsule(\"physicsBodyCapsuleViewMesh\", {\n        height: 1\n      }, scene);\n      this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugCapsuleMesh.material = this._getDebugMaterial(scene);\n      this._debugCapsuleMesh.setEnabled(false);\n    }\n    return this._debugCapsuleMesh.createInstance(\"physicsBodyCapsuleViewInstance\");\n  }\n  _getDebugCylinderMesh(scene) {\n    if (!this._debugCylinderMesh) {\n      this._debugCylinderMesh = CreateCylinder(\"physicsBodyCylinderViewMesh\", {\n        diameterTop: 1,\n        diameterBottom: 1,\n        height: 1\n      }, scene);\n      this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();\n      this._debugCylinderMesh.material = this._getDebugMaterial(scene);\n      this._debugCylinderMesh.setEnabled(false);\n    }\n    return this._debugCylinderMesh.createInstance(\"physicsBodyCylinderViewInstance\");\n  }\n  _getDebugMeshMesh(mesh, scene) {\n    const wireframeOver = new Mesh(mesh.name, scene, null, mesh);\n    wireframeOver.setParent(mesh);\n    wireframeOver.position = Vector3.Zero();\n    wireframeOver.material = this._getDebugMaterial(scene);\n    this._debugMeshMeshes.push(wireframeOver);\n    return wireframeOver;\n  }\n  _getDebugMesh(impostor, targetMesh) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    // Only create child impostor debug meshes when evaluating the parent\n    if (targetMesh && targetMesh.parent && targetMesh.parent.physicsImpostor) {\n      return null;\n    }\n    let mesh = null;\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    if (!impostor.physicsBody) {\n      Logger.Warn(\"Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.\");\n      return null;\n    }\n    switch (impostor.type) {\n      case PhysicsImpostor.BoxImpostor:\n        mesh = this._getDebugBoxMesh(utilityLayerScene);\n        impostor.getBoxSizeToRef(mesh.scaling);\n        break;\n      case PhysicsImpostor.SphereImpostor:\n        {\n          mesh = this._getDebugSphereMesh(utilityLayerScene);\n          const radius = impostor.getRadius();\n          mesh.scaling.x = radius * 2;\n          mesh.scaling.y = radius * 2;\n          mesh.scaling.z = radius * 2;\n          break;\n        }\n      case PhysicsImpostor.CapsuleImpostor:\n        {\n          mesh = this._getDebugCapsuleMesh(utilityLayerScene);\n          const bi = impostor.object.getBoundingInfo();\n          mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;\n          mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n          mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;\n          break;\n        }\n      case PhysicsImpostor.MeshImpostor:\n        if (targetMesh) {\n          mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);\n        }\n        break;\n      case PhysicsImpostor.NoImpostor:\n        if (targetMesh) {\n          // Handle compound impostors\n          const childMeshes = targetMesh.getChildMeshes().filter(c => {\n            return c.physicsImpostor ? 1 : 0;\n          });\n          childMeshes.forEach(m => {\n            if (m.physicsImpostor && m.getClassName() === \"Mesh\") {\n              const boundingInfo = m.getBoundingInfo();\n              const min = boundingInfo.boundingBox.minimum;\n              const max = boundingInfo.boundingBox.maximum;\n              switch (m.physicsImpostor.type) {\n                case PhysicsImpostor.BoxImpostor:\n                  mesh = this._getDebugBoxMesh(utilityLayerScene);\n                  mesh.position.copyFrom(min);\n                  mesh.position.addInPlace(max);\n                  mesh.position.scaleInPlace(0.5);\n                  break;\n                case PhysicsImpostor.SphereImpostor:\n                  mesh = this._getDebugSphereMesh(utilityLayerScene);\n                  break;\n                case PhysicsImpostor.CylinderImpostor:\n                  mesh = this._getDebugCylinderMesh(utilityLayerScene);\n                  break;\n                default:\n                  mesh = null;\n                  break;\n              }\n              if (mesh) {\n                mesh.scaling.x = max.x - min.x;\n                mesh.scaling.y = max.y - min.y;\n                mesh.scaling.z = max.z - min.z;\n                mesh.parent = m;\n              }\n            }\n          });\n        } else {\n          Logger.Warn(\"No target mesh parameter provided for NoImpostor. Skipping.\");\n        }\n        mesh = null;\n        break;\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          mesh = this._getDebugCylinderMesh(utilityLayerScene);\n          const bi = impostor.object.getBoundingInfo();\n          mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;\n          mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\n          mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;\n          break;\n        }\n    }\n    return mesh;\n  }\n  /**\n   * Creates a debug mesh for a given physics body\n   * @param body The physics body to create the debug mesh for\n   * @returns The created debug mesh or null if the utility layer is not available\n   *\n   * This code is useful for creating a debug mesh for a given physics body.\n   * It creates a Mesh object with a VertexData object containing the positions and indices\n   * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.\n   * This allows for visualizing the physics body in the scene.\n   */\n  _getDebugBodyMesh(body) {\n    if (!this._utilityLayer) {\n      return null;\n    }\n    const utilityLayerScene = this._utilityLayer.utilityLayerScene;\n    const mesh = new Mesh(\"custom\", utilityLayerScene);\n    const vertexData = new VertexData();\n    const geometry = body.getGeometry();\n    vertexData.positions = geometry.positions;\n    vertexData.indices = geometry.indices;\n    vertexData.applyToMesh(mesh);\n    mesh.material = this._getDebugMaterial(utilityLayerScene);\n    return mesh;\n  }\n  /**\n   * Clean up physics debug display\n   */\n  dispose() {\n    // impostors\n    for (let index = 0; index < this._numMeshes; index++) {\n      this.hideImpostor(this._impostors[0]);\n    }\n    // bodies\n    for (let index = 0; index < this._numBodies; index++) {\n      this.hideBody(this._bodies[0]);\n    }\n    if (this._debugBoxMesh) {\n      this._debugBoxMesh.dispose();\n    }\n    if (this._debugSphereMesh) {\n      this._debugSphereMesh.dispose();\n    }\n    if (this._debugCylinderMesh) {\n      this._debugCylinderMesh.dispose();\n    }\n    if (this._debugMaterial) {\n      this._debugMaterial.dispose();\n    }\n    this._impostors.length = 0;\n    this._scene = null;\n    this._physicsEnginePlugin = null;\n    if (this._utilityLayer) {\n      this._utilityLayer.dispose();\n      this._utilityLayer = null;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Mesh","CreateBox","CreateSphere","Quaternion","Vector3","Color3","EngineStore","StandardMaterial","PhysicsImpostor","UtilityLayerRenderer","CreateCylinder","CreateCapsule","Logger","VertexData","PhysicsViewer","constructor","scene","Array","_scene","LastCreatedScene","physicEngine","getPhysicsEngine","_physicsEnginePlugin","getPhysicsPlugin","_utilityLayer","pickUtilitySceneFirst","utilityLayerScene","autoClearDepthAndStencil","_updateDebugMeshes","plugin","getPluginVersion","_updateDebugMeshesV1","_updateDebugMeshesV2","i","_numMeshes","impostor","_impostors","isDisposed","hideImpostor","type","MeshImpostor","mesh","_meshes","syncMeshWithImpostor","_numBodies","body","_bodies","transform","_bodyMeshes","syncTransform","showImpostor","targetMesh","debugMesh","_getDebugMesh","_renderFunction","bind","registerBeforeRender","showBody","_getDebugBodyMesh","removed","removeMesh","dispose","index","_debugMeshMeshes","indexOf","splice","unregisterBeforeRender","hideBody","_getDebugMaterial","_debugMaterial","wireframe","emissiveColor","White","disableLighting","_getDebugBoxMesh","_debugBoxMesh","size","rotationQuaternion","Identity","material","setEnabled","createInstance","_getDebugSphereMesh","_debugSphereMesh","diameter","_getDebugCapsuleMesh","_debugCapsuleMesh","height","_getDebugCylinderMesh","_debugCylinderMesh","diameterTop","diameterBottom","_getDebugMeshMesh","wireframeOver","name","setParent","position","Zero","push","parent","physicsImpostor","physicsBody","Warn","BoxImpostor","getBoxSizeToRef","scaling","SphereImpostor","radius","getRadius","x","y","z","CapsuleImpostor","bi","object","getBoundingInfo","boundingBox","maximum","minimum","NoImpostor","childMeshes","getChildMeshes","filter","c","forEach","m","getClassName","boundingInfo","min","max","copyFrom","addInPlace","scaleInPlace","CylinderImpostor","vertexData","geometry","getGeometry","positions","indices","applyToMesh","length"],"sourceRoot":"","sources":["../../../../lts/core/generated/Debug/physicsViewer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { IPhysicsEnginePlugin as IPhysicsEnginePluginV1 } from \"../Physics/v1/IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2 } from \"../Physics/v2/IPhysicsEnginePlugin\";\r\nimport { PhysicsImpostor } from \"../Physics/v1/physicsImpostor\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport type { ICreateCapsuleOptions } from \"../Meshes/Builders/capsuleBuilder\";\r\nimport { CreateCapsule } from \"../Meshes/Builders/capsuleBuilder\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { PhysicsBody } from \"../Physics/v2/physicsBody\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\n\r\n/**\r\n * Used to show the physics impostor around the specific mesh\r\n */\r\nexport class PhysicsViewer {\r\n    /** @internal */\r\n    protected _impostors: Array<Nullable<PhysicsImpostor>> = [];\r\n    /** @internal */\r\n    protected _meshes: Array<Nullable<AbstractMesh>> = [];\r\n    /** @internal */\r\n    protected _bodies: Array<Nullable<PhysicsBody>> = [];\r\n    /** @internal */\r\n    protected _bodyMeshes: Array<Nullable<AbstractMesh>> = [];\r\n    /** @internal */\r\n    protected _scene: Nullable<Scene>;\r\n    /** @internal */\r\n    protected _numMeshes = 0;\r\n    /** @internal */\r\n    protected _numBodies = 0;\r\n    /** @internal */\r\n    protected _physicsEnginePlugin: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2 | null;\r\n    private _renderFunction: () => void;\r\n    private _utilityLayer: Nullable<UtilityLayerRenderer>;\r\n\r\n    private _debugBoxMesh: Mesh;\r\n    private _debugSphereMesh: Mesh;\r\n    private _debugCapsuleMesh: Mesh;\r\n    private _debugCylinderMesh: Mesh;\r\n    private _debugMaterial: StandardMaterial;\r\n    private _debugMeshMeshes = new Array<Mesh>();\r\n\r\n    /**\r\n     * Creates a new PhysicsViewer\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        const physicEngine = this._scene.getPhysicsEngine();\r\n\r\n        if (physicEngine) {\r\n            this._physicsEnginePlugin = physicEngine.getPhysicsPlugin();\r\n        }\r\n\r\n        this._utilityLayer = new UtilityLayerRenderer(this._scene, false);\r\n        this._utilityLayer.pickUtilitySceneFirst = false;\r\n        this._utilityLayer.utilityLayerScene.autoClearDepthAndStencil = true;\r\n    }\r\n\r\n    /**\r\n     * Updates the debug meshes of the physics engine.\r\n     *\r\n     * This code is useful for synchronizing the debug meshes of the physics engine with the physics impostor and mesh.\r\n     * It checks if the impostor is disposed and if the plugin version is 1, then it syncs the mesh with the impostor.\r\n     * This ensures that the debug meshes are up to date with the physics engine.\r\n     */\r\n    protected _updateDebugMeshes(): void {\r\n        const plugin = this._physicsEnginePlugin;\r\n\r\n        if (plugin?.getPluginVersion() === 1) {\r\n            this._updateDebugMeshesV1();\r\n        } else {\r\n            this._updateDebugMeshesV2();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the debug meshes of the physics engine.\r\n     *\r\n     * This method is useful for synchronizing the debug meshes with the physics impostors.\r\n     * It iterates through the impostors and meshes, and if the plugin version is 1, it syncs the mesh with the impostor.\r\n     * This ensures that the debug meshes accurately reflect the physics impostors, which is important for debugging the physics engine.\r\n     */\r\n    protected _updateDebugMeshesV1(): void {\r\n        const plugin = this._physicsEnginePlugin as IPhysicsEnginePluginV1;\r\n        for (let i = 0; i < this._numMeshes; i++) {\r\n            const impostor = this._impostors[i];\r\n\r\n            if (!impostor) {\r\n                continue;\r\n            }\r\n\r\n            if (impostor.isDisposed) {\r\n                this.hideImpostor(this._impostors[i--]);\r\n            } else {\r\n                if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n                    continue;\r\n                }\r\n                const mesh = this._meshes[i];\r\n\r\n                if (mesh && plugin) {\r\n                    plugin.syncMeshWithImpostor(mesh, impostor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the debug meshes of the physics engine for V2 plugin.\r\n     *\r\n     * This method is useful for synchronizing the debug meshes of the physics engine with the current state of the bodies.\r\n     * It iterates through the bodies array and updates the debug meshes with the current transform of each body.\r\n     * This ensures that the debug meshes accurately reflect the current state of the physics engine.\r\n     */\r\n    protected _updateDebugMeshesV2(): void {\r\n        const plugin = this._physicsEnginePlugin as IPhysicsEnginePluginV2;\r\n        for (let i = 0; i < this._numBodies; i++) {\r\n            const body = this._bodies[i];\r\n            const transform = this._bodyMeshes[i];\r\n            if (body && transform) {\r\n                plugin.syncTransform(body, transform);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders a specified physic impostor\r\n     * @param impostor defines the impostor to render\r\n     * @param targetMesh defines the mesh represented by the impostor\r\n     * @returns the new debug mesh used to render the impostor\r\n     */\r\n    public showImpostor(impostor: PhysicsImpostor, targetMesh?: Mesh): Nullable<AbstractMesh> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._numMeshes; i++) {\r\n            if (this._impostors[i] == impostor) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const debugMesh = this._getDebugMesh(impostor, targetMesh);\r\n\r\n        if (debugMesh) {\r\n            this._impostors[this._numMeshes] = impostor;\r\n            this._meshes[this._numMeshes] = debugMesh;\r\n\r\n            if (this._numMeshes === 0) {\r\n                this._renderFunction = this._updateDebugMeshes.bind(this);\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n\r\n            this._numMeshes++;\r\n        }\r\n\r\n        return debugMesh;\r\n    }\r\n\r\n    /**\r\n     * Shows a debug mesh for a given physics body.\r\n     * @param body The physics body to show.\r\n     * @returns The debug mesh, or null if the body is already shown.\r\n     *\r\n     * This function is useful for visualizing the physics body in the scene.\r\n     * It creates a debug mesh for the given body and adds it to the scene.\r\n     * It also registers a before render function to update the debug mesh position and rotation.\r\n     */\r\n    public showBody(body: PhysicsBody): Nullable<AbstractMesh> {\r\n        if (!this._scene) {\r\n            return null;\r\n        }\r\n\r\n        for (let i = 0; i < this._numBodies; i++) {\r\n            if (this._bodies[i] == body) {\r\n                return null;\r\n            }\r\n        }\r\n\r\n        const debugMesh = this._getDebugBodyMesh(body);\r\n\r\n        if (debugMesh) {\r\n            this._bodies[this._numBodies] = body;\r\n            this._bodyMeshes[this._numBodies] = debugMesh;\r\n\r\n            if (this._numBodies === 0) {\r\n                this._renderFunction = this._updateDebugMeshes.bind(this);\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n\r\n            this._numBodies++;\r\n        }\r\n\r\n        return debugMesh;\r\n    }\r\n\r\n    /**\r\n     * Hides an impostor from the scene.\r\n     * @param impostor - The impostor to hide.\r\n     *\r\n     * This method is useful for hiding an impostor from the scene. It removes the\r\n     * impostor from the utility layer scene, disposes the mesh, and removes the\r\n     * impostor from the list of impostors. If the impostor is the last one in the\r\n     * list, it also unregisters the render function.\r\n     */\r\n    public hideImpostor(impostor: Nullable<PhysicsImpostor>) {\r\n        if (!impostor || !this._scene || !this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        let removed = false;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        for (let i = 0; i < this._numMeshes; i++) {\r\n            if (this._impostors[i] == impostor) {\r\n                const mesh = this._meshes[i];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                utilityLayerScene.removeMesh(mesh);\r\n                mesh.dispose();\r\n\r\n                const index = this._debugMeshMeshes.indexOf(mesh as Mesh);\r\n                if (index > -1) {\r\n                    this._debugMeshMeshes.splice(index, 1);\r\n                }\r\n\r\n                this._numMeshes--;\r\n                if (this._numMeshes > 0) {\r\n                    this._meshes[i] = this._meshes[this._numMeshes];\r\n                    this._impostors[i] = this._impostors[this._numMeshes];\r\n                    this._meshes[this._numMeshes] = null;\r\n                    this._impostors[this._numMeshes] = null;\r\n                } else {\r\n                    this._meshes[0] = null;\r\n                    this._impostors[0] = null;\r\n                }\r\n                removed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (removed && this._numMeshes === 0) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides a body from the physics engine.\r\n     * @param body - The body to hide.\r\n     *\r\n     * This function is useful for hiding a body from the physics engine.\r\n     * It removes the body from the utility layer scene and disposes the mesh associated with it.\r\n     * It also unregisters the render function if the number of bodies is 0.\r\n     * This is useful for hiding a body from the physics engine without deleting it.\r\n     */\r\n    public hideBody(body: Nullable<PhysicsBody>) {\r\n        if (!body || !this._scene || !this._utilityLayer) {\r\n            return;\r\n        }\r\n\r\n        let removed = false;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        for (let i = 0; i < this._numBodies; i++) {\r\n            if (this._bodies[i] === body) {\r\n                const mesh = this._bodyMeshes[i];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                utilityLayerScene.removeMesh(mesh);\r\n                mesh.dispose();\r\n\r\n                this._numBodies--;\r\n                if (this._numBodies > 0) {\r\n                    this._bodyMeshes[i] = this._meshes[this._numBodies];\r\n                    this._bodies[i] = this._bodies[this._numBodies];\r\n                    this._bodyMeshes[this._numBodies] = null;\r\n                    this._bodies[this._numBodies] = null;\r\n                } else {\r\n                    this._bodyMeshes[0] = null;\r\n                    this._bodies[0] = null;\r\n                }\r\n                removed = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (removed && this._numBodies === 0) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n        }\r\n    }\r\n\r\n    private _getDebugMaterial(scene: Scene): Material {\r\n        if (!this._debugMaterial) {\r\n            this._debugMaterial = new StandardMaterial(\"\", scene);\r\n            this._debugMaterial.wireframe = true;\r\n            this._debugMaterial.emissiveColor = Color3.White();\r\n            this._debugMaterial.disableLighting = true;\r\n        }\r\n\r\n        return this._debugMaterial;\r\n    }\r\n\r\n    private _getDebugBoxMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugBoxMesh) {\r\n            this._debugBoxMesh = CreateBox(\"physicsBodyBoxViewMesh\", { size: 1 }, scene);\r\n            this._debugBoxMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugBoxMesh.material = this._getDebugMaterial(scene);\r\n            this._debugBoxMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugBoxMesh.createInstance(\"physicsBodyBoxViewInstance\");\r\n    }\r\n\r\n    private _getDebugSphereMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugSphereMesh) {\r\n            this._debugSphereMesh = CreateSphere(\"physicsBodySphereViewMesh\", { diameter: 1 }, scene);\r\n            this._debugSphereMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugSphereMesh.material = this._getDebugMaterial(scene);\r\n            this._debugSphereMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugSphereMesh.createInstance(\"physicsBodySphereViewInstance\");\r\n    }\r\n\r\n    private _getDebugCapsuleMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugCapsuleMesh) {\r\n            this._debugCapsuleMesh = CreateCapsule(\"physicsBodyCapsuleViewMesh\", { height: 1 } as ICreateCapsuleOptions, scene);\r\n            this._debugCapsuleMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugCapsuleMesh.material = this._getDebugMaterial(scene);\r\n            this._debugCapsuleMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugCapsuleMesh.createInstance(\"physicsBodyCapsuleViewInstance\");\r\n    }\r\n\r\n    private _getDebugCylinderMesh(scene: Scene): AbstractMesh {\r\n        if (!this._debugCylinderMesh) {\r\n            this._debugCylinderMesh = CreateCylinder(\"physicsBodyCylinderViewMesh\", { diameterTop: 1, diameterBottom: 1, height: 1 }, scene);\r\n            this._debugCylinderMesh.rotationQuaternion = Quaternion.Identity();\r\n            this._debugCylinderMesh.material = this._getDebugMaterial(scene);\r\n            this._debugCylinderMesh.setEnabled(false);\r\n        }\r\n\r\n        return this._debugCylinderMesh.createInstance(\"physicsBodyCylinderViewInstance\");\r\n    }\r\n\r\n    private _getDebugMeshMesh(mesh: Mesh, scene: Scene): AbstractMesh {\r\n        const wireframeOver = new Mesh(mesh.name, scene, null, mesh);\r\n        wireframeOver.setParent(mesh);\r\n        wireframeOver.position = Vector3.Zero();\r\n        wireframeOver.material = this._getDebugMaterial(scene);\r\n\r\n        this._debugMeshMeshes.push(wireframeOver);\r\n\r\n        return wireframeOver;\r\n    }\r\n\r\n    private _getDebugMesh(impostor: PhysicsImpostor, targetMesh?: Mesh): Nullable<AbstractMesh> {\r\n        if (!this._utilityLayer) {\r\n            return null;\r\n        }\r\n\r\n        // Only create child impostor debug meshes when evaluating the parent\r\n        if (targetMesh && targetMesh.parent && (targetMesh.parent as Mesh).physicsImpostor) {\r\n            return null;\r\n        }\r\n\r\n        let mesh: Nullable<AbstractMesh> = null;\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n        if (!impostor.physicsBody) {\r\n            Logger.Warn(\"Unable to get physicsBody of impostor. It might be initialized later by its parent's impostor.\");\r\n            return null;\r\n        }\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.BoxImpostor:\r\n                mesh = this._getDebugBoxMesh(utilityLayerScene);\r\n                impostor.getBoxSizeToRef(mesh.scaling);\r\n                break;\r\n            case PhysicsImpostor.SphereImpostor: {\r\n                mesh = this._getDebugSphereMesh(utilityLayerScene);\r\n                const radius = impostor.getRadius();\r\n                mesh.scaling.x = radius * 2;\r\n                mesh.scaling.y = radius * 2;\r\n                mesh.scaling.z = radius * 2;\r\n                break;\r\n            }\r\n            case PhysicsImpostor.CapsuleImpostor: {\r\n                mesh = this._getDebugCapsuleMesh(utilityLayerScene);\r\n                const bi = impostor.object.getBoundingInfo();\r\n                mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * 2 * impostor.object.scaling.x;\r\n                mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\r\n                mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * 2 * impostor.object.scaling.z;\r\n                break;\r\n            }\r\n            case PhysicsImpostor.MeshImpostor:\r\n                if (targetMesh) {\r\n                    mesh = this._getDebugMeshMesh(targetMesh, utilityLayerScene);\r\n                }\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                if (targetMesh) {\r\n                    // Handle compound impostors\r\n                    const childMeshes = targetMesh.getChildMeshes().filter((c) => {\r\n                        return c.physicsImpostor ? 1 : 0;\r\n                    });\r\n                    childMeshes.forEach((m) => {\r\n                        if (m.physicsImpostor && m.getClassName() === \"Mesh\") {\r\n                            const boundingInfo = m.getBoundingInfo();\r\n                            const min = boundingInfo.boundingBox.minimum;\r\n                            const max = boundingInfo.boundingBox.maximum;\r\n                            switch (m.physicsImpostor.type) {\r\n                                case PhysicsImpostor.BoxImpostor:\r\n                                    mesh = this._getDebugBoxMesh(utilityLayerScene);\r\n                                    mesh.position.copyFrom(min);\r\n                                    mesh.position.addInPlace(max);\r\n                                    mesh.position.scaleInPlace(0.5);\r\n                                    break;\r\n                                case PhysicsImpostor.SphereImpostor:\r\n                                    mesh = this._getDebugSphereMesh(utilityLayerScene);\r\n                                    break;\r\n                                case PhysicsImpostor.CylinderImpostor:\r\n                                    mesh = this._getDebugCylinderMesh(utilityLayerScene);\r\n                                    break;\r\n                                default:\r\n                                    mesh = null;\r\n                                    break;\r\n                            }\r\n                            if (mesh) {\r\n                                mesh.scaling.x = max.x - min.x;\r\n                                mesh.scaling.y = max.y - min.y;\r\n                                mesh.scaling.z = max.z - min.z;\r\n                                mesh.parent = m;\r\n                            }\r\n                        }\r\n                    });\r\n                } else {\r\n                    Logger.Warn(\"No target mesh parameter provided for NoImpostor. Skipping.\");\r\n                }\r\n                mesh = null;\r\n                break;\r\n            case PhysicsImpostor.CylinderImpostor: {\r\n                mesh = this._getDebugCylinderMesh(utilityLayerScene);\r\n                const bi = impostor.object.getBoundingInfo();\r\n                mesh.scaling.x = (bi.boundingBox.maximum.x - bi.boundingBox.minimum.x) * impostor.object.scaling.x;\r\n                mesh.scaling.y = (bi.boundingBox.maximum.y - bi.boundingBox.minimum.y) * impostor.object.scaling.y;\r\n                mesh.scaling.z = (bi.boundingBox.maximum.z - bi.boundingBox.minimum.z) * impostor.object.scaling.z;\r\n                break;\r\n            }\r\n        }\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a debug mesh for a given physics body\r\n     * @param body The physics body to create the debug mesh for\r\n     * @returns The created debug mesh or null if the utility layer is not available\r\n     *\r\n     * This code is useful for creating a debug mesh for a given physics body.\r\n     * It creates a Mesh object with a VertexData object containing the positions and indices\r\n     * of the geometry of the body. The mesh is then assigned a debug material from the utility layer scene.\r\n     * This allows for visualizing the physics body in the scene.\r\n     */\r\n    private _getDebugBodyMesh(body: PhysicsBody): Nullable<AbstractMesh> {\r\n        if (!this._utilityLayer) {\r\n            return null;\r\n        }\r\n\r\n        const utilityLayerScene = this._utilityLayer.utilityLayerScene;\r\n\r\n        const mesh = new Mesh(\"custom\", utilityLayerScene);\r\n        const vertexData = new VertexData();\r\n        const geometry = body.getGeometry() as any;\r\n        vertexData.positions = geometry.positions;\r\n        vertexData.indices = geometry.indices;\r\n        vertexData.applyToMesh(mesh);\r\n        mesh.material = this._getDebugMaterial(utilityLayerScene);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Clean up physics debug display\r\n     */\r\n    public dispose() {\r\n        // impostors\r\n        for (let index = 0; index < this._numMeshes; index++) {\r\n            this.hideImpostor(this._impostors[0]);\r\n        }\r\n        // bodies\r\n        for (let index = 0; index < this._numBodies; index++) {\r\n            this.hideBody(this._bodies[0]);\r\n        }\r\n\r\n        if (this._debugBoxMesh) {\r\n            this._debugBoxMesh.dispose();\r\n        }\r\n        if (this._debugSphereMesh) {\r\n            this._debugSphereMesh.dispose();\r\n        }\r\n        if (this._debugCylinderMesh) {\r\n            this._debugCylinderMesh.dispose();\r\n        }\r\n        if (this._debugMaterial) {\r\n            this._debugMaterial.dispose();\r\n        }\r\n\r\n        this._impostors.length = 0;\r\n        this._scene = null;\r\n        this._physicsEnginePlugin = null;\r\n\r\n        if (this._utilityLayer) {\r\n            this._utilityLayer.dispose();\r\n            this._utilityLayer = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}