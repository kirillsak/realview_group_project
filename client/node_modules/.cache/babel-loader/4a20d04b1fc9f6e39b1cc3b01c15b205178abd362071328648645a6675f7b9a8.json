{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\n/**\n * The WebXR Eye Tracking feature grabs eye data from the device and provides it in an easy-access format.\n * Currently only enabled for BabylonNative applications.\n */\nexport class WebXREyeTracking extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the XR eye tracking feature.\n   * @param _xrSessionManager An instance of WebXRSessionManager.\n   */\n  constructor(_xrSessionManager) {\n    super(_xrSessionManager);\n    /**\n     * This observable will notify registered observers when eye tracking starts\n     */\n    this.onEyeTrackingStartedObservable = new Observable();\n    /**\n     * This observable will notify registered observers when eye tracking ends\n     */\n    this.onEyeTrackingEndedObservable = new Observable();\n    /**\n     * This observable will notify registered observers on each frame that has valid tracking\n     */\n    this.onEyeTrackingFrameUpdateObservable = new Observable();\n    this._eyeTrackingStartListener = event => {\n      this._latestEyeSpace = event.gazeSpace;\n      this._gazeRay = new Ray(Vector3.Zero(), Vector3.Forward());\n      this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay);\n    };\n    this._eyeTrackingEndListener = () => {\n      this._latestEyeSpace = null;\n      this._gazeRay = null;\n      this.onEyeTrackingEndedObservable.notifyObservers();\n    };\n    this.xrNativeFeatureName = \"eye-tracking\";\n    if (this._xrSessionManager.session) {\n      this._init();\n    } else {\n      this._xrSessionManager.onXRSessionInit.addOnce(() => {\n        this._init();\n      });\n    }\n  }\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n  dispose() {\n    super.dispose();\n    this._xrSessionManager.session.removeEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\n    this._xrSessionManager.session.removeEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\n    this.onEyeTrackingStartedObservable.clear();\n    this.onEyeTrackingEndedObservable.clear();\n    this.onEyeTrackingFrameUpdateObservable.clear();\n  }\n  /**\n   * Returns whether the gaze data is valid or not\n   * @returns true if the data is valid\n   */\n  get isEyeGazeValid() {\n    return !!this._gazeRay;\n  }\n  /**\n   * Get a reference to the gaze ray. This data is valid while eye tracking persists, and will be set to null when gaze data is no longer available\n   * @returns a reference to the gaze ray if it exists and is valid, returns null otherwise.\n   */\n  getEyeGaze() {\n    return this._gazeRay;\n  }\n  _onXRFrame(frame) {\n    if (!this.attached || !frame) {\n      return;\n    }\n    if (this._latestEyeSpace && this._gazeRay) {\n      const pose = frame.getPose(this._latestEyeSpace, this._xrSessionManager.referenceSpace);\n      if (pose) {\n        this._gazeRay.origin.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\n        const quat = pose.transform.orientation;\n        TmpVectors.Quaternion[0].set(quat.x, quat.y, quat.z, quat.w);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          this._gazeRay.origin.z *= -1;\n          TmpVectors.Quaternion[0].z *= -1;\n          TmpVectors.Quaternion[0].w *= -1;\n          Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\n        } else {\n          Vector3.RightHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\n        }\n        this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay);\n      }\n    }\n  }\n  _init() {\n    // Only supported by BabylonNative\n    if (this._xrSessionManager.isNative) {\n      this._xrSessionManager.session.addEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\n      this._xrSessionManager.session.addEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXREyeTracking.Name = WebXRFeatureName.EYE_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXREyeTracking.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXREyeTracking.Name, xrSessionManager => {\n  return () => new WebXREyeTracking(xrSessionManager);\n}, WebXREyeTracking.Version, false);","map":{"version":3,"mappings":"AAAA,SAASA,oBAAoB,EAAEC,gBAAgB,QAAQ,4BAA0B;AACjF,SAASC,oBAAoB,QAAQ,2BAAyB;AAE9D,SAASC,UAAU,QAAQ,0BAAwB;AACnD,SAASC,OAAO,EAAEC,UAAU,QAAQ,4BAA0B;AAC9D,SAASC,GAAG,QAAQ,sBAAoB;AAGxC;;;;AAIA,OAAM,MAAOC,gBAAiB,SAAQL,oBAAoB;EA4BtD;;;;EAIAM,YAAYC,iBAAsC;IAC9C,KAAK,CAACA,iBAAiB,CAAC;IAlB5B;;;IAGgB,mCAA8B,GAAoB,IAAIN,UAAU,EAAE;IAClF;;;IAGgB,iCAA4B,GAAqB,IAAIA,UAAU,EAAE;IACjF;;;IAGgB,uCAAkC,GAAoB,IAAIA,UAAU,EAAE;IA2E9E,8BAAyB,GAAIO,KAA+B,IAAI;MACpE,IAAI,CAACC,eAAe,GAAGD,KAAK,CAACE,SAAS;MACtC,IAAI,CAACC,QAAQ,GAAG,IAAIP,GAAG,CAACF,OAAO,CAACU,IAAI,EAAE,EAAEV,OAAO,CAACW,OAAO,EAAE,CAAC;MAC1D,IAAI,CAACC,8BAA8B,CAACC,eAAe,CAAC,IAAI,CAACJ,QAAQ,CAAC;IACtE,CAAC;IAEO,4BAAuB,GAAG,MAAK;MACnC,IAAI,CAACF,eAAe,GAAG,IAAI;MAC3B,IAAI,CAACE,QAAQ,GAAG,IAAI;MACpB,IAAI,CAACK,4BAA4B,CAACD,eAAe,EAAE;IACvD,CAAC;IA7EG,IAAI,CAACE,mBAAmB,GAAG,cAAc;IACzC,IAAI,IAAI,CAACV,iBAAiB,CAACW,OAAO,EAAE;MAChC,IAAI,CAACC,KAAK,EAAE;KACf,MAAM;MACH,IAAI,CAACZ,iBAAiB,CAACa,eAAe,CAACC,OAAO,CAAC,MAAK;QAChD,IAAI,CAACF,KAAK,EAAE;MAChB,CAAC,CAAC;;EAEV;EAEA;;;EAGOG,OAAO;IACV,KAAK,CAACA,OAAO,EAAE;IAEf,IAAI,CAACf,iBAAiB,CAACW,OAAO,CAACK,mBAAmB,CAAC,kBAAkB,EAAE,IAAI,CAACC,yBAAyB,CAAC;IACtG,IAAI,CAACjB,iBAAiB,CAACW,OAAO,CAACK,mBAAmB,CAAC,gBAAgB,EAAE,IAAI,CAACE,uBAAuB,CAAC;IAElG,IAAI,CAACX,8BAA8B,CAACY,KAAK,EAAE;IAC3C,IAAI,CAACV,4BAA4B,CAACU,KAAK,EAAE;IACzC,IAAI,CAACC,kCAAkC,CAACD,KAAK,EAAE;EACnD;EAEA;;;;EAIA,IAAWE,cAAc;IACrB,OAAO,CAAC,CAAC,IAAI,CAACjB,QAAQ;EAC1B;EAEA;;;;EAIOkB,UAAU;IACb,OAAO,IAAI,CAAClB,QAAQ;EACxB;EAEUmB,UAAU,CAACC,KAAc;IAC/B,IAAI,CAAC,IAAI,CAACC,QAAQ,IAAI,CAACD,KAAK,EAAE;MAC1B;;IAGJ,IAAI,IAAI,CAACtB,eAAe,IAAI,IAAI,CAACE,QAAQ,EAAE;MACvC,MAAMsB,IAAI,GAAGF,KAAK,CAACG,OAAO,CAAC,IAAI,CAACzB,eAAe,EAAE,IAAI,CAACF,iBAAiB,CAAC4B,cAAc,CAAC;MACvF,IAAIF,IAAI,EAAE;QACN,IAAI,CAACtB,QAAQ,CAACyB,MAAM,CAACC,GAAG,CAACJ,IAAI,CAACK,SAAS,CAACC,QAAQ,CAACC,CAAC,EAAEP,IAAI,CAACK,SAAS,CAACC,QAAQ,CAACE,CAAC,EAAER,IAAI,CAACK,SAAS,CAACC,QAAQ,CAACG,CAAC,CAAC;QACzG,MAAMC,IAAI,GAAGV,IAAI,CAACK,SAAS,CAACM,WAAW;QACvCzC,UAAU,CAAC0C,UAAU,CAAC,CAAC,CAAC,CAACR,GAAG,CAACM,IAAI,CAACH,CAAC,EAAEG,IAAI,CAACF,CAAC,EAAEE,IAAI,CAACD,CAAC,EAAEC,IAAI,CAACG,CAAC,CAAC;QAE5D,IAAI,CAAC,IAAI,CAACvC,iBAAiB,CAACwC,KAAK,CAACC,oBAAoB,EAAE;UACpD,IAAI,CAACrC,QAAQ,CAACyB,MAAM,CAACM,CAAC,IAAI,CAAC,CAAC;UAC5BvC,UAAU,CAAC0C,UAAU,CAAC,CAAC,CAAC,CAACH,CAAC,IAAI,CAAC,CAAC;UAChCvC,UAAU,CAAC0C,UAAU,CAAC,CAAC,CAAC,CAACC,CAAC,IAAI,CAAC,CAAC;UAEhC5C,OAAO,CAAC+C,yBAAyB,CAACC,uBAAuB,CAAC/C,UAAU,CAAC0C,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAAClC,QAAQ,CAACwC,SAAS,CAAC;SAC/G,MAAM;UACHjD,OAAO,CAACkD,0BAA0B,CAACF,uBAAuB,CAAC/C,UAAU,CAAC0C,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAAClC,QAAQ,CAACwC,SAAS,CAAC;;QAGjH,IAAI,CAACxB,kCAAkC,CAACZ,eAAe,CAAC,IAAI,CAACJ,QAAQ,CAAC;;;EAGlF;EAcQQ,KAAK;IACT;IACA,IAAI,IAAI,CAACZ,iBAAiB,CAAC8C,QAAQ,EAAE;MACjC,IAAI,CAAC9C,iBAAiB,CAACW,OAAO,CAACoC,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAAC9B,yBAAyB,CAAC;MACnG,IAAI,CAACjB,iBAAiB,CAACW,OAAO,CAACoC,gBAAgB,CAAC,gBAAgB,EAAE,IAAI,CAAC7B,uBAAuB,CAAC;;EAEvG;;AAnHA;;;AAGuBpB,qBAAI,GAAGN,gBAAgB,CAACwD,YAAY;AAC3D;;;;;AAKuBlD,wBAAO,GAAG,CAAC;AA6GtCP,oBAAoB,CAAC0D,eAAe,CAChCnD,gBAAgB,CAACoD,IAAI,EACpBC,gBAAgB,IAAI;EACjB,OAAO,MAAM,IAAIrD,gBAAgB,CAACqD,gBAAgB,CAAC;AACvD,CAAC,EACDrD,gBAAgB,CAACsD,OAAO,EACxB,KAAK,CACR","names":["WebXRFeaturesManager","WebXRFeatureName","WebXRAbstractFeature","Observable","Vector3","TmpVectors","Ray","WebXREyeTracking","constructor","_xrSessionManager","event","_latestEyeSpace","gazeSpace","_gazeRay","Zero","Forward","onEyeTrackingStartedObservable","notifyObservers","onEyeTrackingEndedObservable","xrNativeFeatureName","session","_init","onXRSessionInit","addOnce","dispose","removeEventListener","_eyeTrackingStartListener","_eyeTrackingEndListener","clear","onEyeTrackingFrameUpdateObservable","isEyeGazeValid","getEyeGaze","_onXRFrame","frame","attached","pose","getPose","referenceSpace","origin","set","transform","position","x","y","z","quat","orientation","Quaternion","w","scene","useRightHandedSystem","LeftHandedForwardReadOnly","rotateByQuaternionToRef","direction","RightHandedForwardReadOnly","isNative","addEventListener","EYE_TRACKING","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXREyeTracking.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * The WebXR Eye Tracking feature grabs eye data from the device and provides it in an easy-access format.\r\n * Currently only enabled for BabylonNative applications.\r\n */\r\nexport class WebXREyeTracking extends WebXRAbstractFeature {\r\n    private _latestEyeSpace: Nullable<XRSpace>;\r\n    private _gazeRay: Nullable<Ray>;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.EYE_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This observable will notify registered observers when eye tracking starts\r\n     */\r\n    public readonly onEyeTrackingStartedObservable: Observable<Ray> = new Observable();\r\n    /**\r\n     * This observable will notify registered observers when eye tracking ends\r\n     */\r\n    public readonly onEyeTrackingEndedObservable: Observable<void> = new Observable();\r\n    /**\r\n     * This observable will notify registered observers on each frame that has valid tracking\r\n     */\r\n    public readonly onEyeTrackingFrameUpdateObservable: Observable<Ray> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the XR eye tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"eye-tracking\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._xrSessionManager.session.removeEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\r\n        this._xrSessionManager.session.removeEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\r\n\r\n        this.onEyeTrackingStartedObservable.clear();\r\n        this.onEyeTrackingEndedObservable.clear();\r\n        this.onEyeTrackingFrameUpdateObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Returns whether the gaze data is valid or not\r\n     * @returns true if the data is valid\r\n     */\r\n    public get isEyeGazeValid(): boolean {\r\n        return !!this._gazeRay;\r\n    }\r\n\r\n    /**\r\n     * Get a reference to the gaze ray. This data is valid while eye tracking persists, and will be set to null when gaze data is no longer available\r\n     * @returns a reference to the gaze ray if it exists and is valid, returns null otherwise.\r\n     */\r\n    public getEyeGaze(): Nullable<Ray> {\r\n        return this._gazeRay;\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        if (this._latestEyeSpace && this._gazeRay) {\r\n            const pose = frame.getPose(this._latestEyeSpace, this._xrSessionManager.referenceSpace);\r\n            if (pose) {\r\n                this._gazeRay.origin.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);\r\n                const quat = pose.transform.orientation;\r\n                TmpVectors.Quaternion[0].set(quat.x, quat.y, quat.z, quat.w);\r\n\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    this._gazeRay.origin.z *= -1;\r\n                    TmpVectors.Quaternion[0].z *= -1;\r\n                    TmpVectors.Quaternion[0].w *= -1;\r\n\r\n                    Vector3.LeftHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\r\n                } else {\r\n                    Vector3.RightHandedForwardReadOnly.rotateByQuaternionToRef(TmpVectors.Quaternion[0], this._gazeRay.direction);\r\n                }\r\n\r\n                this.onEyeTrackingFrameUpdateObservable.notifyObservers(this._gazeRay);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _eyeTrackingStartListener = (event: XREyeTrackingSourceEvent) => {\r\n        this._latestEyeSpace = event.gazeSpace;\r\n        this._gazeRay = new Ray(Vector3.Zero(), Vector3.Forward());\r\n        this.onEyeTrackingStartedObservable.notifyObservers(this._gazeRay);\r\n    };\r\n\r\n    private _eyeTrackingEndListener = () => {\r\n        this._latestEyeSpace = null;\r\n        this._gazeRay = null;\r\n        this.onEyeTrackingEndedObservable.notifyObservers();\r\n    };\r\n\r\n    private _init() {\r\n        // Only supported by BabylonNative\r\n        if (this._xrSessionManager.isNative) {\r\n            this._xrSessionManager.session.addEventListener(\"eyetrackingstart\", this._eyeTrackingStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"eyetrackingend\", this._eyeTrackingEndListener);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXREyeTracking.Name,\r\n    (xrSessionManager) => {\r\n        return () => new WebXREyeTracking(xrSessionManager);\r\n    },\r\n    WebXREyeTracking.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}