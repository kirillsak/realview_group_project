{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\n/**\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n * in order to better appreciate the issue one might have.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\n */\nexport class RayHelper {\n  /**\n   * Instantiate a new ray helper.\n   * As raycast might be hard to debug, the RayHelper can help rendering the different rays\n   * in order to better appreciate the issue one might have.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\n   * @param ray Defines the ray we are currently tryin to visualize\n   */\n  constructor(ray) {\n    this.ray = ray;\n  }\n  /**\n   * Helper function to create a colored helper in a scene in one line.\n   * @param ray Defines the ray we are currently tryin to visualize\n   * @param scene Defines the scene the ray is used in\n   * @param color Defines the color we want to see the ray in\n   * @returns The newly created ray helper.\n   */\n  static CreateAndShow(ray, scene, color) {\n    const helper = new RayHelper(ray);\n    helper.show(scene, color);\n    return helper;\n  }\n  /**\n   * Shows the ray we are willing to debug.\n   * @param scene Defines the scene the ray needs to be rendered in\n   * @param color Defines the color the ray needs to be rendered in\n   */\n  show(scene, color) {\n    if (!this._renderFunction && this.ray) {\n      const ray = this.ray;\n      this._renderFunction = this._render.bind(this);\n      this._scene = scene;\n      this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\n      this._renderLine = CreateLines(\"ray\", {\n        points: this._renderPoints,\n        updatable: true\n      }, scene);\n      this._renderLine.isPickable = false;\n      if (this._renderFunction) {\n        this._scene.registerBeforeRender(this._renderFunction);\n      }\n    }\n    if (color && this._renderLine) {\n      this._renderLine.color.copyFrom(color);\n    }\n  }\n  /**\n   * Hides the ray we are debugging.\n   */\n  hide() {\n    if (this._renderFunction && this._scene) {\n      this._scene.unregisterBeforeRender(this._renderFunction);\n      this._scene = null;\n      this._renderFunction = null;\n      if (this._renderLine) {\n        this._renderLine.dispose();\n        this._renderLine = null;\n      }\n      this._renderPoints = [];\n    }\n  }\n  _render() {\n    var _a;\n    const ray = this.ray;\n    if (!ray) {\n      return;\n    }\n    const point = this._renderPoints[1];\n    const len = Math.min(ray.length, 1000000);\n    point.copyFrom(ray.direction);\n    point.scaleInPlace(len);\n    point.addInPlace(ray.origin);\n    this._renderPoints[0].copyFrom(ray.origin);\n    CreateLines(\"ray\", {\n      points: this._renderPoints,\n      updatable: true,\n      instance: this._renderLine\n    }, this._scene);\n    (_a = this._renderLine) === null || _a === void 0 ? void 0 : _a.refreshBoundingInfo();\n  }\n  /**\n   * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\n   * @param mesh Defines the mesh we want the helper attached to\n   * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\n   * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\n   * @param length Defines the length of the ray\n   */\n  attachToMesh(mesh, meshSpaceDirection, meshSpaceOrigin, length) {\n    this._attachedToMesh = mesh;\n    const ray = this.ray;\n    if (!ray) {\n      return;\n    }\n    if (!ray.direction) {\n      ray.direction = Vector3.Zero();\n    }\n    if (!ray.origin) {\n      ray.origin = Vector3.Zero();\n    }\n    if (length) {\n      ray.length = length;\n    }\n    if (!meshSpaceOrigin) {\n      meshSpaceOrigin = Vector3.Zero();\n    }\n    if (!meshSpaceDirection) {\n      // -1 so that this will work with Mesh.lookAt\n      meshSpaceDirection = new Vector3(0, 0, -1);\n    }\n    if (!this._scene) {\n      this._scene = mesh.getScene();\n    }\n    if (!this._meshSpaceDirection) {\n      this._meshSpaceDirection = meshSpaceDirection.clone();\n      this._meshSpaceOrigin = meshSpaceOrigin.clone();\n    } else {\n      this._meshSpaceDirection.copyFrom(meshSpaceDirection);\n      this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\n    }\n    if (!this._onAfterRenderObserver) {\n      this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());\n      this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());\n    }\n    // force world matrix computation before the first ray helper computation\n    this._attachedToMesh.computeWorldMatrix(true);\n    this._updateToMesh();\n  }\n  /**\n   * Detach the ray helper from the mesh it has previously been attached to.\n   */\n  detachFromMesh() {\n    if (this._attachedToMesh && this._scene) {\n      if (this._onAfterRenderObserver) {\n        this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\n        this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\n      }\n      this._attachedToMesh = null;\n      this._onAfterRenderObserver = null;\n      this._onAfterStepObserver = null;\n      this._scene = null;\n    }\n  }\n  _updateToMesh() {\n    const ray = this.ray;\n    if (!this._attachedToMesh || !ray) {\n      return;\n    }\n    if (this._attachedToMesh.isDisposed()) {\n      this.detachFromMesh();\n      return;\n    }\n    this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\n    Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\n  }\n  /**\n   * Dispose the helper and release its associated resources.\n   */\n  dispose() {\n    this.hide();\n    this.detachFromMesh();\n    this.ray = null;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","CreateLines","RayHelper","constructor","ray","CreateAndShow","scene","color","helper","show","_renderFunction","_render","bind","_scene","_renderPoints","origin","add","direction","scale","length","_renderLine","points","updatable","isPickable","registerBeforeRender","copyFrom","hide","unregisterBeforeRender","dispose","point","len","Math","min","scaleInPlace","addInPlace","instance","refreshBoundingInfo","attachToMesh","mesh","meshSpaceDirection","meshSpaceOrigin","_attachedToMesh","Zero","getScene","_meshSpaceDirection","clone","_meshSpaceOrigin","_onAfterRenderObserver","onBeforeRenderObservable","_updateToMesh","_onAfterStepObserver","onAfterStepObservable","computeWorldMatrix","detachFromMesh","remove","isDisposed","getDirectionToRef","TransformCoordinatesToRef","getWorldMatrix"],"sourceRoot":"","sources":["../../../../lts/core/generated/Debug/rayHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Ray } from \"../Culling/ray\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\n\r\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\n/**\r\n * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n * in order to better appreciate the issue one might have.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\r\n */\r\nexport class RayHelper {\r\n    /**\r\n     * Defines the ray we are currently tryin to visualize.\r\n     */\r\n    public ray: Nullable<Ray>;\r\n\r\n    private _renderPoints: Vector3[];\r\n    private _renderLine: Nullable<LinesMesh>;\r\n    private _renderFunction: Nullable<() => void>;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Scene>>;\r\n    private _onAfterStepObserver: Nullable<Observer<Scene>>;\r\n    private _attachedToMesh: Nullable<AbstractMesh>;\r\n    private _meshSpaceDirection: Vector3;\r\n    private _meshSpaceOrigin: Vector3;\r\n\r\n    /**\r\n     * Helper function to create a colored helper in a scene in one line.\r\n     * @param ray Defines the ray we are currently tryin to visualize\r\n     * @param scene Defines the scene the ray is used in\r\n     * @param color Defines the color we want to see the ray in\r\n     * @returns The newly created ray helper.\r\n     */\r\n    public static CreateAndShow(ray: Ray, scene: Scene, color: Color3): RayHelper {\r\n        const helper = new RayHelper(ray);\r\n\r\n        helper.show(scene, color);\r\n\r\n        return helper;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new ray helper.\r\n     * As raycast might be hard to debug, the RayHelper can help rendering the different rays\r\n     * in order to better appreciate the issue one might have.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/picking_collisions#debugging\r\n     * @param ray Defines the ray we are currently tryin to visualize\r\n     */\r\n    constructor(ray: Ray) {\r\n        this.ray = ray;\r\n    }\r\n\r\n    /**\r\n     * Shows the ray we are willing to debug.\r\n     * @param scene Defines the scene the ray needs to be rendered in\r\n     * @param color Defines the color the ray needs to be rendered in\r\n     */\r\n    public show(scene: Scene, color?: Color3): void {\r\n        if (!this._renderFunction && this.ray) {\r\n            const ray = this.ray;\r\n\r\n            this._renderFunction = this._render.bind(this);\r\n            this._scene = scene;\r\n            this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\r\n            this._renderLine = CreateLines(\"ray\", { points: this._renderPoints, updatable: true }, scene);\r\n            this._renderLine.isPickable = false;\r\n\r\n            if (this._renderFunction) {\r\n                this._scene.registerBeforeRender(this._renderFunction);\r\n            }\r\n        }\r\n\r\n        if (color && this._renderLine) {\r\n            this._renderLine.color.copyFrom(color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hides the ray we are debugging.\r\n     */\r\n    public hide(): void {\r\n        if (this._renderFunction && this._scene) {\r\n            this._scene.unregisterBeforeRender(this._renderFunction);\r\n            this._scene = null;\r\n            this._renderFunction = null;\r\n            if (this._renderLine) {\r\n                this._renderLine.dispose();\r\n                this._renderLine = null;\r\n            }\r\n\r\n            this._renderPoints = [];\r\n        }\r\n    }\r\n\r\n    private _render(): void {\r\n        const ray = this.ray;\r\n\r\n        if (!ray) {\r\n            return;\r\n        }\r\n\r\n        const point = this._renderPoints[1];\r\n        const len = Math.min(ray.length, 1000000);\r\n\r\n        point.copyFrom(ray.direction);\r\n        point.scaleInPlace(len);\r\n        point.addInPlace(ray.origin);\r\n\r\n        this._renderPoints[0].copyFrom(ray.origin);\r\n\r\n        CreateLines(\"ray\", { points: this._renderPoints, updatable: true, instance: this._renderLine }, this._scene);\r\n\r\n        this._renderLine?.refreshBoundingInfo();\r\n    }\r\n\r\n    /**\r\n     * Attach a ray helper to a mesh so that we can easily see its orientation for instance or information like its normals.\r\n     * @param mesh Defines the mesh we want the helper attached to\r\n     * @param meshSpaceDirection Defines the direction of the Ray in mesh space (local space of the mesh node)\r\n     * @param meshSpaceOrigin Defines the origin of the Ray in mesh space (local space of the mesh node)\r\n     * @param length Defines the length of the ray\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, meshSpaceDirection?: Vector3, meshSpaceOrigin?: Vector3, length?: number): void {\r\n        this._attachedToMesh = mesh;\r\n\r\n        const ray = this.ray;\r\n\r\n        if (!ray) {\r\n            return;\r\n        }\r\n\r\n        if (!ray.direction) {\r\n            ray.direction = Vector3.Zero();\r\n        }\r\n\r\n        if (!ray.origin) {\r\n            ray.origin = Vector3.Zero();\r\n        }\r\n\r\n        if (length) {\r\n            ray.length = length;\r\n        }\r\n\r\n        if (!meshSpaceOrigin) {\r\n            meshSpaceOrigin = Vector3.Zero();\r\n        }\r\n\r\n        if (!meshSpaceDirection) {\r\n            // -1 so that this will work with Mesh.lookAt\r\n            meshSpaceDirection = new Vector3(0, 0, -1);\r\n        }\r\n\r\n        if (!this._scene) {\r\n            this._scene = mesh.getScene();\r\n        }\r\n\r\n        if (!this._meshSpaceDirection) {\r\n            this._meshSpaceDirection = meshSpaceDirection.clone();\r\n            this._meshSpaceOrigin = meshSpaceOrigin.clone();\r\n        } else {\r\n            this._meshSpaceDirection.copyFrom(meshSpaceDirection);\r\n            this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\r\n        }\r\n\r\n        if (!this._onAfterRenderObserver) {\r\n            this._onAfterRenderObserver = this._scene.onBeforeRenderObservable.add(() => this._updateToMesh());\r\n            this._onAfterStepObserver = this._scene.onAfterStepObservable.add(() => this._updateToMesh());\r\n        }\r\n\r\n        // force world matrix computation before the first ray helper computation\r\n        this._attachedToMesh.computeWorldMatrix(true);\r\n\r\n        this._updateToMesh();\r\n    }\r\n\r\n    /**\r\n     * Detach the ray helper from the mesh it has previously been attached to.\r\n     */\r\n    public detachFromMesh(): void {\r\n        if (this._attachedToMesh && this._scene) {\r\n            if (this._onAfterRenderObserver) {\r\n                this._scene.onBeforeRenderObservable.remove(this._onAfterRenderObserver);\r\n                this._scene.onAfterStepObservable.remove(this._onAfterStepObserver);\r\n            }\r\n            this._attachedToMesh = null;\r\n            this._onAfterRenderObserver = null;\r\n            this._onAfterStepObserver = null;\r\n            this._scene = null;\r\n        }\r\n    }\r\n\r\n    private _updateToMesh(): void {\r\n        const ray = this.ray;\r\n\r\n        if (!this._attachedToMesh || !ray) {\r\n            return;\r\n        }\r\n\r\n        if (this._attachedToMesh.isDisposed()) {\r\n            this.detachFromMesh();\r\n            return;\r\n        }\r\n\r\n        this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\r\n        Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\r\n    }\r\n\r\n    /**\r\n     * Dispose the helper and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        this.hide();\r\n        this.detachFromMesh();\r\n        this.ray = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}