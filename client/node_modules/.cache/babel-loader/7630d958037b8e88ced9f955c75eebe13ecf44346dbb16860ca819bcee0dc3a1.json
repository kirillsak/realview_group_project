{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { AsyncLoop } from \"../Misc/tools.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to specify simplification options\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\n */\nexport class SimplificationSettings {\n  /**\n   * Creates a SimplificationSettings\n   * @param quality expected quality\n   * @param distance distance when this optimized version should be used\n   * @param optimizeMesh already optimized mesh\n   */\n  constructor( /** expected quality */\n  quality, /** distance when this optimized version should be used */\n  distance, /** already optimized mesh  */\n  optimizeMesh) {\n    this.quality = quality;\n    this.distance = distance;\n    this.optimizeMesh = optimizeMesh;\n  }\n}\n/**\n * Queue used to order the simplification tasks\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\n */\nexport class SimplificationQueue {\n  /**\n   * Creates a new queue\n   */\n  constructor() {\n    this.running = false;\n    this._simplificationArray = [];\n  }\n  /**\n   * Adds a new simplification task\n   * @param task defines a task to add\n   */\n  addTask(task) {\n    this._simplificationArray.push(task);\n  }\n  /**\n   * Execute next task\n   */\n  executeNext() {\n    const task = this._simplificationArray.pop();\n    if (task) {\n      this.running = true;\n      this.runSimplification(task);\n    } else {\n      this.running = false;\n    }\n  }\n  /**\n   * Execute a simplification task\n   * @param task defines the task to run\n   */\n  runSimplification(task) {\n    if (task.parallelProcessing) {\n      //parallel simplifier\n      task.settings.forEach(setting => {\n        const simplifier = this._getSimplifier(task);\n        simplifier.simplify(setting, newMesh => {\n          if (setting.distance !== undefined) {\n            task.mesh.addLODLevel(setting.distance, newMesh);\n          }\n          newMesh.isVisible = true;\n          //check if it is the last\n          if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {\n            //all done, run the success callback.\n            task.successCallback();\n          }\n          this.executeNext();\n        });\n      });\n    } else {\n      //single simplifier.\n      const simplifier = this._getSimplifier(task);\n      const runDecimation = (setting, callback) => {\n        simplifier.simplify(setting, newMesh => {\n          if (setting.distance !== undefined) {\n            task.mesh.addLODLevel(setting.distance, newMesh);\n          }\n          newMesh.isVisible = true;\n          //run the next quality level\n          callback();\n        });\n      };\n      AsyncLoop.Run(task.settings.length, loop => {\n        runDecimation(task.settings[loop.index], () => {\n          loop.executeNext();\n        });\n      }, () => {\n        //execution ended, run the success callback.\n        if (task.successCallback) {\n          task.successCallback();\n        }\n        this.executeNext();\n      });\n    }\n  }\n  _getSimplifier(task) {\n    switch (task.simplificationType) {\n      case SimplificationType.QUADRATIC:\n      default:\n        return new QuadraticErrorSimplification(task.mesh);\n    }\n  }\n}\n/**\n * The implemented types of simplification\n * At the moment only Quadratic Error Decimation is implemented\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\n */\nexport var SimplificationType;\n(function (SimplificationType) {\n  /** Quadratic error decimation */\n  SimplificationType[SimplificationType[\"QUADRATIC\"] = 0] = \"QUADRATIC\";\n})(SimplificationType || (SimplificationType = {}));\nclass DecimationTriangle {\n  constructor(_vertices) {\n    this._vertices = _vertices;\n    this.error = new Array(4);\n    this.deleted = false;\n    this.isDirty = false;\n    this.deletePending = false;\n    this.borderFactor = 0;\n  }\n}\nclass DecimationVertex {\n  constructor(position, id) {\n    this.position = position;\n    this.id = id;\n    this.isBorder = true;\n    this.q = new QuadraticMatrix();\n    this.triangleCount = 0;\n    this.triangleStart = 0;\n    this.originalOffsets = [];\n  }\n  updatePosition(newPosition) {\n    this.position.copyFrom(newPosition);\n  }\n}\nclass QuadraticMatrix {\n  constructor(data) {\n    this.data = new Array(10);\n    for (let i = 0; i < 10; ++i) {\n      if (data && data[i]) {\n        this.data[i] = data[i];\n      } else {\n        this.data[i] = 0;\n      }\n    }\n  }\n  det(a11, a12, a13, a21, a22, a23, a31, a32, a33) {\n    const det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] + this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] - this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];\n    return det;\n  }\n  addInPlace(matrix) {\n    for (let i = 0; i < 10; ++i) {\n      this.data[i] += matrix.data[i];\n    }\n  }\n  addArrayInPlace(data) {\n    for (let i = 0; i < 10; ++i) {\n      this.data[i] += data[i];\n    }\n  }\n  add(matrix) {\n    const m = new QuadraticMatrix();\n    for (let i = 0; i < 10; ++i) {\n      m.data[i] = this.data[i] + matrix.data[i];\n    }\n    return m;\n  }\n  static FromData(a, b, c, d) {\n    return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));\n  }\n  //returning an array to avoid garbage collection\n  static DataFromNumbers(a, b, c, d) {\n    return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];\n  }\n}\nclass Reference {\n  constructor(vertexId, triangleId) {\n    this.vertexId = vertexId;\n    this.triangleId = triangleId;\n  }\n}\n/**\n * An implementation of the Quadratic Error simplification algorithm.\n * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf\n * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS\n * @author RaananW\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\n */\nexport class QuadraticErrorSimplification {\n  /**\n   * Creates a new QuadraticErrorSimplification\n   * @param _mesh defines the target mesh\n   */\n  constructor(_mesh) {\n    this._mesh = _mesh;\n    /** Gets or sets the number pf sync iterations */\n    this.syncIterations = 5000;\n    this.aggressiveness = 7;\n    this.decimationIterations = 100;\n    this.boundingBoxEpsilon = Epsilon;\n  }\n  /**\n   * Simplification of a given mesh according to the given settings.\n   * Since this requires computation, it is assumed that the function runs async.\n   * @param settings The settings of the simplification, including quality and distance\n   * @param successCallback A callback that will be called after the mesh was simplified.\n   */\n  simplify(settings, successCallback) {\n    this._initDecimatedMesh();\n    //iterating through the submeshes array, one after the other.\n    AsyncLoop.Run(this._mesh.subMeshes.length, loop => {\n      this._initWithMesh(loop.index, () => {\n        this._runDecimation(settings, loop.index, () => {\n          loop.executeNext();\n        });\n      }, settings.optimizeMesh);\n    }, () => {\n      setTimeout(() => {\n        successCallback(this._reconstructedMesh);\n      }, 0);\n    });\n  }\n  _runDecimation(settings, submeshIndex, successCallback) {\n    const targetCount = ~~(this._triangles.length * settings.quality);\n    let deletedTriangles = 0;\n    const triangleCount = this._triangles.length;\n    const iterationFunction = (iteration, callback) => {\n      setTimeout(() => {\n        if (iteration % 5 === 0) {\n          this._updateMesh(iteration === 0);\n        }\n        for (let i = 0; i < this._triangles.length; ++i) {\n          this._triangles[i].isDirty = false;\n        }\n        const threshold = 0.000000001 * Math.pow(iteration + 3, this.aggressiveness);\n        const trianglesIterator = i => {\n          const tIdx = ~~((this._triangles.length / 2 + i) % this._triangles.length);\n          const t = this._triangles[tIdx];\n          if (!t) {\n            return;\n          }\n          if (t.error[3] > threshold || t.deleted || t.isDirty) {\n            return;\n          }\n          for (let j = 0; j < 3; ++j) {\n            if (t.error[j] < threshold) {\n              const deleted0 = [];\n              const deleted1 = [];\n              const v0 = t._vertices[j];\n              const v1 = t._vertices[(j + 1) % 3];\n              if (v0.isBorder || v1.isBorder) {\n                continue;\n              }\n              const p = Vector3.Zero();\n              // var n = Vector3.Zero();\n              // var uv = Vector2.Zero();\n              // var color = new Color4(0, 0, 0, 1);\n              this._calculateError(v0, v1, p);\n              const delTr = new Array();\n              if (this._isFlipped(v0, v1, p, deleted0, delTr)) {\n                continue;\n              }\n              if (this._isFlipped(v1, v0, p, deleted1, delTr)) {\n                continue;\n              }\n              if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {\n                continue;\n              }\n              const uniqueArray = new Array();\n              delTr.forEach(deletedT => {\n                if (uniqueArray.indexOf(deletedT) === -1) {\n                  deletedT.deletePending = true;\n                  uniqueArray.push(deletedT);\n                }\n              });\n              if (uniqueArray.length % 2 !== 0) {\n                continue;\n              }\n              v0.q = v1.q.add(v0.q);\n              v0.updatePosition(p);\n              const tStart = this._references.length;\n              deletedTriangles = this._updateTriangles(v0, v0, deleted0, deletedTriangles);\n              deletedTriangles = this._updateTriangles(v0, v1, deleted1, deletedTriangles);\n              const tCount = this._references.length - tStart;\n              if (tCount <= v0.triangleCount) {\n                if (tCount) {\n                  for (let c = 0; c < tCount; c++) {\n                    this._references[v0.triangleStart + c] = this._references[tStart + c];\n                  }\n                }\n              } else {\n                v0.triangleStart = tStart;\n              }\n              v0.triangleCount = tCount;\n              break;\n            }\n          }\n        };\n        AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, trianglesIterator, callback, () => {\n          return triangleCount - deletedTriangles <= targetCount;\n        });\n      }, 0);\n    };\n    AsyncLoop.Run(this.decimationIterations, loop => {\n      if (triangleCount - deletedTriangles <= targetCount) {\n        loop.breakLoop();\n      } else {\n        iterationFunction(loop.index, () => {\n          loop.executeNext();\n        });\n      }\n    }, () => {\n      setTimeout(() => {\n        //reconstruct this part of the mesh\n        this._reconstructMesh(submeshIndex);\n        successCallback();\n      }, 0);\n    });\n  }\n  _initWithMesh(submeshIndex, callback, optimizeMesh) {\n    this._vertices = [];\n    this._triangles = [];\n    const positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);\n    const indices = this._mesh.getIndices();\n    const submesh = this._mesh.subMeshes[submeshIndex];\n    const findInVertices = positionToSearch => {\n      if (optimizeMesh) {\n        for (let ii = 0; ii < this._vertices.length; ++ii) {\n          if (this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 0.0001)) {\n            return this._vertices[ii];\n          }\n        }\n      }\n      return null;\n    };\n    const vertexReferences = [];\n    const vertexInit = i => {\n      if (!positionData) {\n        return;\n      }\n      const offset = i + submesh.verticesStart;\n      const position = Vector3.FromArray(positionData, offset * 3);\n      const vertex = findInVertices(position) || new DecimationVertex(position, this._vertices.length);\n      vertex.originalOffsets.push(offset);\n      if (vertex.id === this._vertices.length) {\n        this._vertices.push(vertex);\n      }\n      vertexReferences.push(vertex.id);\n    };\n    //var totalVertices = mesh.getTotalVertices();\n    const totalVertices = submesh.verticesCount;\n    AsyncLoop.SyncAsyncForLoop(totalVertices, this.syncIterations / 4 >> 0, vertexInit, () => {\n      const indicesInit = i => {\n        if (!indices) {\n          return;\n        }\n        const offset = submesh.indexStart / 3 + i;\n        const pos = offset * 3;\n        const i0 = indices[pos + 0];\n        const i1 = indices[pos + 1];\n        const i2 = indices[pos + 2];\n        const v0 = this._vertices[vertexReferences[i0 - submesh.verticesStart]];\n        const v1 = this._vertices[vertexReferences[i1 - submesh.verticesStart]];\n        const v2 = this._vertices[vertexReferences[i2 - submesh.verticesStart]];\n        const triangle = new DecimationTriangle([v0, v1, v2]);\n        triangle.originalOffset = pos;\n        this._triangles.push(triangle);\n      };\n      AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, this.syncIterations, indicesInit, () => {\n        this._init(callback);\n      });\n    });\n  }\n  _init(callback) {\n    const triangleInit1 = i => {\n      const t = this._triangles[i];\n      t.normal = Vector3.Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();\n      for (let j = 0; j < 3; j++) {\n        t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t._vertices[0].position)));\n      }\n    };\n    AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, () => {\n      const triangleInit2 = i => {\n        const t = this._triangles[i];\n        for (let j = 0; j < 3; ++j) {\n          t.error[j] = this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);\n        }\n        t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n      };\n      AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit2, () => {\n        callback();\n      });\n    });\n  }\n  _reconstructMesh(submeshIndex) {\n    const newTriangles = [];\n    let i;\n    for (i = 0; i < this._vertices.length; ++i) {\n      this._vertices[i].triangleCount = 0;\n    }\n    let t;\n    let j;\n    for (i = 0; i < this._triangles.length; ++i) {\n      if (!this._triangles[i].deleted) {\n        t = this._triangles[i];\n        for (j = 0; j < 3; ++j) {\n          t._vertices[j].triangleCount = 1;\n        }\n        newTriangles.push(t);\n      }\n    }\n    const newPositionData = this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || [];\n    const newNormalData = this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || [];\n    const newUVsData = this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || [];\n    const newColorsData = this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || [];\n    const normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);\n    const uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);\n    const colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);\n    let vertexCount = 0;\n    for (i = 0; i < this._vertices.length; ++i) {\n      const vertex = this._vertices[i];\n      vertex.id = vertexCount;\n      if (vertex.triangleCount) {\n        vertex.originalOffsets.forEach(originalOffset => {\n          newPositionData.push(vertex.position.x);\n          newPositionData.push(vertex.position.y);\n          newPositionData.push(vertex.position.z);\n          if (normalData && normalData.length) {\n            newNormalData.push(normalData[originalOffset * 3]);\n            newNormalData.push(normalData[originalOffset * 3 + 1]);\n            newNormalData.push(normalData[originalOffset * 3 + 2]);\n          }\n          if (uvs && uvs.length) {\n            newUVsData.push(uvs[originalOffset * 2]);\n            newUVsData.push(uvs[originalOffset * 2 + 1]);\n          }\n          if (colorsData && colorsData.length) {\n            newColorsData.push(colorsData[originalOffset * 4]);\n            newColorsData.push(colorsData[originalOffset * 4 + 1]);\n            newColorsData.push(colorsData[originalOffset * 4 + 2]);\n            newColorsData.push(colorsData[originalOffset * 4 + 3]);\n          }\n          ++vertexCount;\n        });\n      }\n    }\n    const startingIndex = this._reconstructedMesh.getTotalIndices();\n    const startingVertex = this._reconstructedMesh.getTotalVertices();\n    const submeshesArray = this._reconstructedMesh.subMeshes;\n    this._reconstructedMesh.subMeshes = [];\n    const newIndicesArray = this._reconstructedMesh.getIndices(); //[];\n    const originalIndices = this._mesh.getIndices();\n    for (i = 0; i < newTriangles.length; ++i) {\n      t = newTriangles[i]; //now get the new referencing point for each vertex\n      [0, 1, 2].forEach(idx => {\n        const id = originalIndices[t.originalOffset + idx];\n        let offset = t._vertices[idx].originalOffsets.indexOf(id);\n        if (offset < 0) {\n          offset = 0;\n        }\n        newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);\n      });\n    }\n    //overwriting the old vertex buffers and indices.\n    this._reconstructedMesh.setIndices(newIndicesArray);\n    this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);\n    if (newNormalData.length > 0) {\n      this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);\n    }\n    if (newUVsData.length > 0) {\n      this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);\n    }\n    if (newColorsData.length > 0) {\n      this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);\n    }\n    //create submesh\n    const originalSubmesh = this._mesh.subMeshes[submeshIndex];\n    if (submeshIndex > 0) {\n      this._reconstructedMesh.subMeshes = [];\n      submeshesArray.forEach(submesh => {\n        SubMesh.AddToMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount, /* 0, newPositionData.length/3, */submesh.indexStart, submesh.indexCount, submesh.getMesh());\n      });\n      SubMesh.AddToMesh(originalSubmesh.materialIndex, startingVertex, vertexCount, /* 0, newPositionData.length / 3, */startingIndex, newTriangles.length * 3, this._reconstructedMesh);\n    }\n  }\n  _initDecimatedMesh() {\n    this._reconstructedMesh = new Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene());\n    this._reconstructedMesh.material = this._mesh.material;\n    this._reconstructedMesh.parent = this._mesh.parent;\n    this._reconstructedMesh.isVisible = false;\n    this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\n  }\n  _isFlipped(vertex1, vertex2, point, deletedArray, delTr) {\n    for (let i = 0; i < vertex1.triangleCount; ++i) {\n      const t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];\n      if (t.deleted) {\n        continue;\n      }\n      const s = this._references[vertex1.triangleStart + i].vertexId;\n      const v1 = t._vertices[(s + 1) % 3];\n      const v2 = t._vertices[(s + 2) % 3];\n      if (v1 === vertex2 || v2 === vertex2) {\n        deletedArray[i] = true;\n        delTr.push(t);\n        continue;\n      }\n      let d1 = v1.position.subtract(point);\n      d1 = d1.normalize();\n      let d2 = v2.position.subtract(point);\n      d2 = d2.normalize();\n      if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {\n        return true;\n      }\n      const normal = Vector3.Cross(d1, d2).normalize();\n      deletedArray[i] = false;\n      if (Vector3.Dot(normal, t.normal) < 0.2) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateTriangles(origVertex, vertex, deletedArray, deletedTriangles) {\n    let newDeleted = deletedTriangles;\n    for (let i = 0; i < vertex.triangleCount; ++i) {\n      const ref = this._references[vertex.triangleStart + i];\n      const t = this._triangles[ref.triangleId];\n      if (t.deleted) {\n        continue;\n      }\n      if (deletedArray[i] && t.deletePending) {\n        t.deleted = true;\n        newDeleted++;\n        continue;\n      }\n      t._vertices[ref.vertexId] = origVertex;\n      t.isDirty = true;\n      t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;\n      t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;\n      t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;\n      t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n      this._references.push(ref);\n    }\n    return newDeleted;\n  }\n  _identifyBorder() {\n    for (let i = 0; i < this._vertices.length; ++i) {\n      const vCount = [];\n      const vId = [];\n      const v = this._vertices[i];\n      let j;\n      for (j = 0; j < v.triangleCount; ++j) {\n        const triangle = this._triangles[this._references[v.triangleStart + j].triangleId];\n        for (let ii = 0; ii < 3; ii++) {\n          let ofs = 0;\n          const vv = triangle._vertices[ii];\n          while (ofs < vCount.length) {\n            if (vId[ofs] === vv.id) {\n              break;\n            }\n            ++ofs;\n          }\n          if (ofs === vCount.length) {\n            vCount.push(1);\n            vId.push(vv.id);\n          } else {\n            vCount[ofs]++;\n          }\n        }\n      }\n      for (j = 0; j < vCount.length; ++j) {\n        if (vCount[j] === 1) {\n          this._vertices[vId[j]].isBorder = true;\n        } else {\n          this._vertices[vId[j]].isBorder = false;\n        }\n      }\n    }\n  }\n  _updateMesh(identifyBorders = false) {\n    let i;\n    if (!identifyBorders) {\n      const newTrianglesVector = [];\n      for (i = 0; i < this._triangles.length; ++i) {\n        if (!this._triangles[i].deleted) {\n          newTrianglesVector.push(this._triangles[i]);\n        }\n      }\n      this._triangles = newTrianglesVector;\n    }\n    for (i = 0; i < this._vertices.length; ++i) {\n      this._vertices[i].triangleCount = 0;\n      this._vertices[i].triangleStart = 0;\n    }\n    let t;\n    let j;\n    let v;\n    for (i = 0; i < this._triangles.length; ++i) {\n      t = this._triangles[i];\n      for (j = 0; j < 3; ++j) {\n        v = t._vertices[j];\n        v.triangleCount++;\n      }\n    }\n    let tStart = 0;\n    for (i = 0; i < this._vertices.length; ++i) {\n      this._vertices[i].triangleStart = tStart;\n      tStart += this._vertices[i].triangleCount;\n      this._vertices[i].triangleCount = 0;\n    }\n    const newReferences = new Array(this._triangles.length * 3);\n    for (i = 0; i < this._triangles.length; ++i) {\n      t = this._triangles[i];\n      for (j = 0; j < 3; ++j) {\n        v = t._vertices[j];\n        newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);\n        v.triangleCount++;\n      }\n    }\n    this._references = newReferences;\n    if (identifyBorders) {\n      this._identifyBorder();\n    }\n  }\n  _vertexError(q, point) {\n    const x = point.x;\n    const y = point.y;\n    const z = point.z;\n    return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];\n  }\n  _calculateError(vertex1, vertex2, pointResult) {\n    const q = vertex1.q.add(vertex2.q);\n    const border = vertex1.isBorder && vertex2.isBorder;\n    let error = 0;\n    const qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\n    if (qDet !== 0 && !border) {\n      if (!pointResult) {\n        pointResult = Vector3.Zero();\n      }\n      pointResult.x = -1 / qDet * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);\n      pointResult.y = 1 / qDet * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);\n      pointResult.z = -1 / qDet * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);\n      error = this._vertexError(q, pointResult);\n    } else {\n      const p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));\n      //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();\n      const error1 = this._vertexError(q, vertex1.position);\n      const error2 = this._vertexError(q, vertex2.position);\n      const error3 = this._vertexError(q, p3);\n      error = Math.min(error1, error2, error3);\n      if (error === error1) {\n        if (pointResult) {\n          pointResult.copyFrom(vertex1.position);\n        }\n      } else if (error === error2) {\n        if (pointResult) {\n          pointResult.copyFrom(vertex2.position);\n        }\n      } else {\n        if (pointResult) {\n          pointResult.copyFrom(p3);\n        }\n      }\n    }\n    return error;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","VertexBuffer","SubMesh","Mesh","AsyncLoop","Epsilon","SimplificationSettings","constructor","quality","distance","optimizeMesh","SimplificationQueue","running","_simplificationArray","addTask","task","push","executeNext","pop","runSimplification","parallelProcessing","settings","forEach","setting","simplifier","_getSimplifier","simplify","newMesh","undefined","mesh","addLODLevel","isVisible","length","successCallback","runDecimation","callback","Run","loop","index","simplificationType","SimplificationType","QUADRATIC","QuadraticErrorSimplification","DecimationTriangle","_vertices","error","Array","deleted","isDirty","deletePending","borderFactor","DecimationVertex","position","id","isBorder","q","QuadraticMatrix","triangleCount","triangleStart","originalOffsets","updatePosition","newPosition","copyFrom","data","i","det","a11","a12","a13","a21","a22","a23","a31","a32","a33","addInPlace","matrix","addArrayInPlace","add","m","FromData","a","b","c","d","DataFromNumbers","Reference","vertexId","triangleId","_mesh","aggressiveness","decimationIterations","boundingBoxEpsilon","_initDecimatedMesh","subMeshes","_initWithMesh","_runDecimation","setTimeout","_reconstructedMesh","submeshIndex","targetCount","_triangles","deletedTriangles","iterationFunction","iteration","_updateMesh","threshold","Math","pow","trianglesIterator","tIdx","t","j","deleted0","deleted1","v0","v1","p","Zero","_calculateError","delTr","_isFlipped","indexOf","uniqueArray","deletedT","tStart","_references","_updateTriangles","tCount","SyncAsyncForLoop","syncIterations","breakLoop","_reconstructMesh","positionData","getVerticesData","PositionKind","indices","getIndices","submesh","findInVertices","positionToSearch","ii","equalsWithEpsilon","vertexReferences","vertexInit","offset","verticesStart","FromArray","vertex","totalVertices","verticesCount","indicesInit","indexStart","pos","i0","i1","i2","v2","triangle","originalOffset","indexCount","_init","triangleInit1","normal","Cross","subtract","normalize","x","y","z","Dot","triangleInit2","min","newTriangles","newPositionData","newNormalData","NormalKind","newUVsData","UVKind","newColorsData","ColorKind","normalData","uvs","colorsData","vertexCount","startingIndex","getTotalIndices","startingVertex","getTotalVertices","submeshesArray","newIndicesArray","originalIndices","idx","setIndices","setVerticesData","originalSubmesh","AddToMesh","materialIndex","getMesh","name","getScene","material","parent","renderingGroupId","vertex1","vertex2","point","deletedArray","s","d1","d2","abs","origVertex","newDeleted","ref","_identifyBorder","vCount","vId","v","ofs","vv","identifyBorders","newTrianglesVector","newReferences","_vertexError","pointResult","border","qDet","p3","divide","error1","error2","error3"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/meshSimplification.ts"],"sourcesContent":["import type { IndicesArray } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { AsyncLoop } from \"../Misc/tools\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\n/**\r\n * A simplifier interface for future simplification implementations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport interface ISimplifier {\r\n    /**\r\n     * Simplification of a given mesh according to the given settings.\r\n     * Since this requires computation, it is assumed that the function runs async.\r\n     * @param settings The settings of the simplification, including quality and distance\r\n     * @param successCallback A callback that will be called after the mesh was simplified.\r\n     * @param errorCallback in case of an error, this callback will be called. optional.\r\n     */\r\n    simplify(settings: ISimplificationSettings, successCallback: (simplifiedMeshes: Mesh) => void, errorCallback?: () => void): void;\r\n}\r\n\r\n/**\r\n * Expected simplification settings.\r\n * Quality should be between 0 and 1 (1 being 100%, 0 being 0%)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport interface ISimplificationSettings {\r\n    /**\r\n     * Gets or sets the expected quality\r\n     */\r\n    quality: number;\r\n    /**\r\n     * Gets or sets the distance when this optimized version should be used\r\n     */\r\n    distance: number;\r\n    /**\r\n     * Gets an already optimized mesh\r\n     */\r\n    optimizeMesh?: boolean;\r\n}\r\n\r\n/**\r\n * Class used to specify simplification options\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport class SimplificationSettings implements ISimplificationSettings {\r\n    /**\r\n     * Creates a SimplificationSettings\r\n     * @param quality expected quality\r\n     * @param distance distance when this optimized version should be used\r\n     * @param optimizeMesh already optimized mesh\r\n     */\r\n    constructor(\r\n        /** expected quality */\r\n        public quality: number,\r\n        /** distance when this optimized version should be used */\r\n        public distance: number,\r\n        /** already optimized mesh  */\r\n        public optimizeMesh?: boolean\r\n    ) {}\r\n}\r\n\r\n/**\r\n * Interface used to define a simplification task\r\n */\r\nexport interface ISimplificationTask {\r\n    /**\r\n     * Array of settings\r\n     */\r\n    settings: Array<ISimplificationSettings>;\r\n    /**\r\n     * Simplification type\r\n     */\r\n    simplificationType: SimplificationType;\r\n    /**\r\n     * Mesh to simplify\r\n     */\r\n    mesh: Mesh;\r\n    /**\r\n     * Callback called on success\r\n     */\r\n    successCallback?: () => void;\r\n    /**\r\n     * Defines if parallel processing can be used\r\n     */\r\n    parallelProcessing: boolean;\r\n}\r\n\r\n/**\r\n * Queue used to order the simplification tasks\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport class SimplificationQueue {\r\n    private _simplificationArray: Array<ISimplificationTask>;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the process is still running\r\n     */\r\n    public running: boolean;\r\n\r\n    /**\r\n     * Creates a new queue\r\n     */\r\n    constructor() {\r\n        this.running = false;\r\n        this._simplificationArray = [];\r\n    }\r\n\r\n    /**\r\n     * Adds a new simplification task\r\n     * @param task defines a task to add\r\n     */\r\n    public addTask(task: ISimplificationTask) {\r\n        this._simplificationArray.push(task);\r\n    }\r\n\r\n    /**\r\n     * Execute next task\r\n     */\r\n    public executeNext() {\r\n        const task = this._simplificationArray.pop();\r\n        if (task) {\r\n            this.running = true;\r\n            this.runSimplification(task);\r\n        } else {\r\n            this.running = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a simplification task\r\n     * @param task defines the task to run\r\n     */\r\n    public runSimplification(task: ISimplificationTask) {\r\n        if (task.parallelProcessing) {\r\n            //parallel simplifier\r\n            task.settings.forEach((setting) => {\r\n                const simplifier = this._getSimplifier(task);\r\n                simplifier.simplify(setting, (newMesh) => {\r\n                    if (setting.distance !== undefined) {\r\n                        task.mesh.addLODLevel(setting.distance, newMesh);\r\n                    }\r\n                    newMesh.isVisible = true;\r\n                    //check if it is the last\r\n                    if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {\r\n                        //all done, run the success callback.\r\n                        task.successCallback();\r\n                    }\r\n                    this.executeNext();\r\n                });\r\n            });\r\n        } else {\r\n            //single simplifier.\r\n            const simplifier = this._getSimplifier(task);\r\n\r\n            const runDecimation = (setting: ISimplificationSettings, callback: () => void) => {\r\n                simplifier.simplify(setting, (newMesh) => {\r\n                    if (setting.distance !== undefined) {\r\n                        task.mesh.addLODLevel(setting.distance, newMesh);\r\n                    }\r\n                    newMesh.isVisible = true;\r\n                    //run the next quality level\r\n                    callback();\r\n                });\r\n            };\r\n\r\n            AsyncLoop.Run(\r\n                task.settings.length,\r\n                (loop: AsyncLoop) => {\r\n                    runDecimation(task.settings[loop.index], () => {\r\n                        loop.executeNext();\r\n                    });\r\n                },\r\n                () => {\r\n                    //execution ended, run the success callback.\r\n                    if (task.successCallback) {\r\n                        task.successCallback();\r\n                    }\r\n                    this.executeNext();\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    private _getSimplifier(task: ISimplificationTask): ISimplifier {\r\n        switch (task.simplificationType) {\r\n            case SimplificationType.QUADRATIC:\r\n            default:\r\n                return new QuadraticErrorSimplification(task.mesh);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The implemented types of simplification\r\n * At the moment only Quadratic Error Decimation is implemented\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport enum SimplificationType {\r\n    /** Quadratic error decimation */\r\n    QUADRATIC,\r\n}\r\n\r\nclass DecimationTriangle {\r\n    public normal: Vector3;\r\n    public error: Array<number>;\r\n    public deleted: boolean;\r\n    public isDirty: boolean;\r\n    public borderFactor: number;\r\n    public deletePending: boolean;\r\n\r\n    public originalOffset: number;\r\n\r\n    constructor(public _vertices: Array<DecimationVertex>) {\r\n        this.error = new Array<number>(4);\r\n        this.deleted = false;\r\n        this.isDirty = false;\r\n        this.deletePending = false;\r\n        this.borderFactor = 0;\r\n    }\r\n}\r\n\r\nclass DecimationVertex {\r\n    public q: QuadraticMatrix;\r\n    public isBorder: boolean;\r\n\r\n    public triangleStart: number;\r\n    public triangleCount: number;\r\n\r\n    public originalOffsets: Array<number>;\r\n\r\n    constructor(public position: Vector3, public id: number) {\r\n        this.isBorder = true;\r\n        this.q = new QuadraticMatrix();\r\n        this.triangleCount = 0;\r\n        this.triangleStart = 0;\r\n        this.originalOffsets = [];\r\n    }\r\n\r\n    public updatePosition(newPosition: Vector3) {\r\n        this.position.copyFrom(newPosition);\r\n    }\r\n}\r\n\r\nclass QuadraticMatrix {\r\n    public data: Array<number>;\r\n\r\n    constructor(data?: Array<number>) {\r\n        this.data = new Array(10);\r\n        for (let i = 0; i < 10; ++i) {\r\n            if (data && data[i]) {\r\n                this.data[i] = data[i];\r\n            } else {\r\n                this.data[i] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    public det(a11: number, a12: number, a13: number, a21: number, a22: number, a23: number, a31: number, a32: number, a33: number): number {\r\n        const det =\r\n            this.data[a11] * this.data[a22] * this.data[a33] +\r\n            this.data[a13] * this.data[a21] * this.data[a32] +\r\n            this.data[a12] * this.data[a23] * this.data[a31] -\r\n            this.data[a13] * this.data[a22] * this.data[a31] -\r\n            this.data[a11] * this.data[a23] * this.data[a32] -\r\n            this.data[a12] * this.data[a21] * this.data[a33];\r\n        return det;\r\n    }\r\n\r\n    public addInPlace(matrix: QuadraticMatrix) {\r\n        for (let i = 0; i < 10; ++i) {\r\n            this.data[i] += matrix.data[i];\r\n        }\r\n    }\r\n\r\n    public addArrayInPlace(data: Array<number>) {\r\n        for (let i = 0; i < 10; ++i) {\r\n            this.data[i] += data[i];\r\n        }\r\n    }\r\n\r\n    public add(matrix: QuadraticMatrix): QuadraticMatrix {\r\n        const m = new QuadraticMatrix();\r\n        for (let i = 0; i < 10; ++i) {\r\n            m.data[i] = this.data[i] + matrix.data[i];\r\n        }\r\n        return m;\r\n    }\r\n\r\n    public static FromData(a: number, b: number, c: number, d: number): QuadraticMatrix {\r\n        return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));\r\n    }\r\n\r\n    //returning an array to avoid garbage collection\r\n    public static DataFromNumbers(a: number, b: number, c: number, d: number) {\r\n        return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];\r\n    }\r\n}\r\n\r\nclass Reference {\r\n    constructor(public vertexId: number, public triangleId: number) {}\r\n}\r\n\r\n/**\r\n * An implementation of the Quadratic Error simplification algorithm.\r\n * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf\r\n * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS\r\n * @author RaananW\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/simplifyingMeshes\r\n */\r\nexport class QuadraticErrorSimplification implements ISimplifier {\r\n    private _triangles: Array<DecimationTriangle>;\r\n    private _vertices: Array<DecimationVertex>;\r\n    private _references: Array<Reference>;\r\n\r\n    private _reconstructedMesh: Mesh;\r\n\r\n    /** Gets or sets the number pf sync iterations */\r\n    public syncIterations = 5000;\r\n\r\n    /** Gets or sets the aggressiveness of the simplifier */\r\n    public aggressiveness: number;\r\n\r\n    /** Gets or sets the number of allowed iterations for decimation */\r\n    public decimationIterations: number;\r\n\r\n    /** Gets or sets the espilon to use for bounding box computation */\r\n    public boundingBoxEpsilon: number;\r\n\r\n    /**\r\n     * Creates a new QuadraticErrorSimplification\r\n     * @param _mesh defines the target mesh\r\n     */\r\n    constructor(private _mesh: Mesh) {\r\n        this.aggressiveness = 7;\r\n        this.decimationIterations = 100;\r\n        this.boundingBoxEpsilon = Epsilon;\r\n    }\r\n\r\n    /**\r\n     * Simplification of a given mesh according to the given settings.\r\n     * Since this requires computation, it is assumed that the function runs async.\r\n     * @param settings The settings of the simplification, including quality and distance\r\n     * @param successCallback A callback that will be called after the mesh was simplified.\r\n     */\r\n    public simplify(settings: ISimplificationSettings, successCallback: (simplifiedMesh: Mesh) => void) {\r\n        this._initDecimatedMesh();\r\n        //iterating through the submeshes array, one after the other.\r\n        AsyncLoop.Run(\r\n            this._mesh.subMeshes.length,\r\n            (loop: AsyncLoop) => {\r\n                this._initWithMesh(\r\n                    loop.index,\r\n                    () => {\r\n                        this._runDecimation(settings, loop.index, () => {\r\n                            loop.executeNext();\r\n                        });\r\n                    },\r\n                    settings.optimizeMesh\r\n                );\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    successCallback(this._reconstructedMesh);\r\n                }, 0);\r\n            }\r\n        );\r\n    }\r\n\r\n    private _runDecimation(settings: ISimplificationSettings, submeshIndex: number, successCallback: () => void) {\r\n        const targetCount = ~~(this._triangles.length * settings.quality);\r\n        let deletedTriangles = 0;\r\n\r\n        const triangleCount = this._triangles.length;\r\n\r\n        const iterationFunction = (iteration: number, callback: () => void) => {\r\n            setTimeout(() => {\r\n                if (iteration % 5 === 0) {\r\n                    this._updateMesh(iteration === 0);\r\n                }\r\n\r\n                for (let i = 0; i < this._triangles.length; ++i) {\r\n                    this._triangles[i].isDirty = false;\r\n                }\r\n\r\n                const threshold = 0.000000001 * Math.pow(iteration + 3, this.aggressiveness);\r\n\r\n                const trianglesIterator = (i: number) => {\r\n                    const tIdx = ~~((this._triangles.length / 2 + i) % this._triangles.length);\r\n                    const t = this._triangles[tIdx];\r\n                    if (!t) {\r\n                        return;\r\n                    }\r\n                    if (t.error[3] > threshold || t.deleted || t.isDirty) {\r\n                        return;\r\n                    }\r\n                    for (let j = 0; j < 3; ++j) {\r\n                        if (t.error[j] < threshold) {\r\n                            const deleted0: Array<boolean> = [];\r\n                            const deleted1: Array<boolean> = [];\r\n\r\n                            const v0 = t._vertices[j];\r\n                            const v1 = t._vertices[(j + 1) % 3];\r\n\r\n                            if (v0.isBorder || v1.isBorder) {\r\n                                continue;\r\n                            }\r\n\r\n                            const p = Vector3.Zero();\r\n                            // var n = Vector3.Zero();\r\n                            // var uv = Vector2.Zero();\r\n                            // var color = new Color4(0, 0, 0, 1);\r\n\r\n                            this._calculateError(v0, v1, p);\r\n\r\n                            const delTr = new Array<DecimationTriangle>();\r\n\r\n                            if (this._isFlipped(v0, v1, p, deleted0, delTr)) {\r\n                                continue;\r\n                            }\r\n                            if (this._isFlipped(v1, v0, p, deleted1, delTr)) {\r\n                                continue;\r\n                            }\r\n\r\n                            if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0) {\r\n                                continue;\r\n                            }\r\n\r\n                            const uniqueArray = new Array<DecimationTriangle>();\r\n                            delTr.forEach((deletedT) => {\r\n                                if (uniqueArray.indexOf(deletedT) === -1) {\r\n                                    deletedT.deletePending = true;\r\n                                    uniqueArray.push(deletedT);\r\n                                }\r\n                            });\r\n\r\n                            if (uniqueArray.length % 2 !== 0) {\r\n                                continue;\r\n                            }\r\n\r\n                            v0.q = v1.q.add(v0.q);\r\n\r\n                            v0.updatePosition(p);\r\n\r\n                            const tStart = this._references.length;\r\n\r\n                            deletedTriangles = this._updateTriangles(v0, v0, deleted0, deletedTriangles);\r\n                            deletedTriangles = this._updateTriangles(v0, v1, deleted1, deletedTriangles);\r\n\r\n                            const tCount = this._references.length - tStart;\r\n\r\n                            if (tCount <= v0.triangleCount) {\r\n                                if (tCount) {\r\n                                    for (let c = 0; c < tCount; c++) {\r\n                                        this._references[v0.triangleStart + c] = this._references[tStart + c];\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                v0.triangleStart = tStart;\r\n                            }\r\n\r\n                            v0.triangleCount = tCount;\r\n                            break;\r\n                        }\r\n                    }\r\n                };\r\n                AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, trianglesIterator, callback, () => {\r\n                    return triangleCount - deletedTriangles <= targetCount;\r\n                });\r\n            }, 0);\r\n        };\r\n\r\n        AsyncLoop.Run(\r\n            this.decimationIterations,\r\n            (loop: AsyncLoop) => {\r\n                if (triangleCount - deletedTriangles <= targetCount) {\r\n                    loop.breakLoop();\r\n                } else {\r\n                    iterationFunction(loop.index, () => {\r\n                        loop.executeNext();\r\n                    });\r\n                }\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    //reconstruct this part of the mesh\r\n                    this._reconstructMesh(submeshIndex);\r\n                    successCallback();\r\n                }, 0);\r\n            }\r\n        );\r\n    }\r\n\r\n    private _initWithMesh(submeshIndex: number, callback: Function, optimizeMesh?: boolean) {\r\n        this._vertices = [];\r\n        this._triangles = [];\r\n\r\n        const positionData = this._mesh.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        const indices = this._mesh.getIndices();\r\n        const submesh = this._mesh.subMeshes[submeshIndex];\r\n\r\n        const findInVertices = (positionToSearch: Vector3) => {\r\n            if (optimizeMesh) {\r\n                for (let ii = 0; ii < this._vertices.length; ++ii) {\r\n                    if (this._vertices[ii].position.equalsWithEpsilon(positionToSearch, 0.0001)) {\r\n                        return this._vertices[ii];\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n\r\n        const vertexReferences: Array<number> = [];\r\n\r\n        const vertexInit = (i: number) => {\r\n            if (!positionData) {\r\n                return;\r\n            }\r\n\r\n            const offset = i + submesh.verticesStart;\r\n            const position = Vector3.FromArray(positionData, offset * 3);\r\n\r\n            const vertex = findInVertices(position) || new DecimationVertex(position, this._vertices.length);\r\n            vertex.originalOffsets.push(offset);\r\n            if (vertex.id === this._vertices.length) {\r\n                this._vertices.push(vertex);\r\n            }\r\n            vertexReferences.push(vertex.id);\r\n        };\r\n        //var totalVertices = mesh.getTotalVertices();\r\n        const totalVertices = submesh.verticesCount;\r\n        AsyncLoop.SyncAsyncForLoop(totalVertices, (this.syncIterations / 4) >> 0, vertexInit, () => {\r\n            const indicesInit = (i: number) => {\r\n                if (!indices) {\r\n                    return;\r\n                }\r\n\r\n                const offset = submesh.indexStart / 3 + i;\r\n                const pos = offset * 3;\r\n                const i0 = indices[pos + 0];\r\n                const i1 = indices[pos + 1];\r\n                const i2 = indices[pos + 2];\r\n                const v0: DecimationVertex = this._vertices[vertexReferences[i0 - submesh.verticesStart]];\r\n                const v1: DecimationVertex = this._vertices[vertexReferences[i1 - submesh.verticesStart]];\r\n                const v2: DecimationVertex = this._vertices[vertexReferences[i2 - submesh.verticesStart]];\r\n                const triangle = new DecimationTriangle([v0, v1, v2]);\r\n                triangle.originalOffset = pos;\r\n                this._triangles.push(triangle);\r\n            };\r\n            AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, this.syncIterations, indicesInit, () => {\r\n                this._init(callback);\r\n            });\r\n        });\r\n    }\r\n\r\n    private _init(callback: Function) {\r\n        const triangleInit1 = (i: number) => {\r\n            const t = this._triangles[i];\r\n            t.normal = Vector3.Cross(t._vertices[1].position.subtract(t._vertices[0].position), t._vertices[2].position.subtract(t._vertices[0].position)).normalize();\r\n            for (let j = 0; j < 3; j++) {\r\n                t._vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -Vector3.Dot(t.normal, t._vertices[0].position)));\r\n            }\r\n        };\r\n        AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit1, () => {\r\n            const triangleInit2 = (i: number) => {\r\n                const t = this._triangles[i];\r\n                for (let j = 0; j < 3; ++j) {\r\n                    t.error[j] = this._calculateError(t._vertices[j], t._vertices[(j + 1) % 3]);\r\n                }\r\n                t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\r\n            };\r\n            AsyncLoop.SyncAsyncForLoop(this._triangles.length, this.syncIterations, triangleInit2, () => {\r\n                callback();\r\n            });\r\n        });\r\n    }\r\n\r\n    private _reconstructMesh(submeshIndex: number) {\r\n        const newTriangles: Array<DecimationTriangle> = [];\r\n        let i: number;\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            this._vertices[i].triangleCount = 0;\r\n        }\r\n        let t: DecimationTriangle;\r\n        let j: number;\r\n        for (i = 0; i < this._triangles.length; ++i) {\r\n            if (!this._triangles[i].deleted) {\r\n                t = this._triangles[i];\r\n                for (j = 0; j < 3; ++j) {\r\n                    t._vertices[j].triangleCount = 1;\r\n                }\r\n                newTriangles.push(t);\r\n            }\r\n        }\r\n\r\n        const newPositionData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.PositionKind) || []);\r\n        const newNormalData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.NormalKind) || []);\r\n        const newUVsData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.UVKind) || []);\r\n        const newColorsData = <number[]>(this._reconstructedMesh.getVerticesData(VertexBuffer.ColorKind) || []);\r\n\r\n        const normalData = this._mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const uvs = this._mesh.getVerticesData(VertexBuffer.UVKind);\r\n        const colorsData = this._mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        let vertexCount = 0;\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            const vertex = this._vertices[i];\r\n            vertex.id = vertexCount;\r\n            if (vertex.triangleCount) {\r\n                vertex.originalOffsets.forEach((originalOffset) => {\r\n                    newPositionData.push(vertex.position.x);\r\n                    newPositionData.push(vertex.position.y);\r\n                    newPositionData.push(vertex.position.z);\r\n\r\n                    if (normalData && normalData.length) {\r\n                        newNormalData.push(normalData[originalOffset * 3]);\r\n                        newNormalData.push(normalData[originalOffset * 3 + 1]);\r\n                        newNormalData.push(normalData[originalOffset * 3 + 2]);\r\n                    }\r\n                    if (uvs && uvs.length) {\r\n                        newUVsData.push(uvs[originalOffset * 2]);\r\n                        newUVsData.push(uvs[originalOffset * 2 + 1]);\r\n                    }\r\n                    if (colorsData && colorsData.length) {\r\n                        newColorsData.push(colorsData[originalOffset * 4]);\r\n                        newColorsData.push(colorsData[originalOffset * 4 + 1]);\r\n                        newColorsData.push(colorsData[originalOffset * 4 + 2]);\r\n                        newColorsData.push(colorsData[originalOffset * 4 + 3]);\r\n                    }\r\n                    ++vertexCount;\r\n                });\r\n            }\r\n        }\r\n\r\n        const startingIndex = this._reconstructedMesh.getTotalIndices();\r\n        const startingVertex = this._reconstructedMesh.getTotalVertices();\r\n\r\n        const submeshesArray = this._reconstructedMesh.subMeshes;\r\n        this._reconstructedMesh.subMeshes = [];\r\n\r\n        const newIndicesArray: number[] = <number[]>this._reconstructedMesh.getIndices(); //[];\r\n        const originalIndices = <IndicesArray>this._mesh.getIndices();\r\n        for (i = 0; i < newTriangles.length; ++i) {\r\n            t = newTriangles[i]; //now get the new referencing point for each vertex\r\n            [0, 1, 2].forEach((idx) => {\r\n                const id = originalIndices[t.originalOffset + idx];\r\n                let offset = t._vertices[idx].originalOffsets.indexOf(id);\r\n                if (offset < 0) {\r\n                    offset = 0;\r\n                }\r\n                newIndicesArray.push(t._vertices[idx].id + offset + startingVertex);\r\n            });\r\n        }\r\n\r\n        //overwriting the old vertex buffers and indices.\r\n\r\n        this._reconstructedMesh.setIndices(newIndicesArray);\r\n        this._reconstructedMesh.setVerticesData(VertexBuffer.PositionKind, newPositionData);\r\n        if (newNormalData.length > 0) {\r\n            this._reconstructedMesh.setVerticesData(VertexBuffer.NormalKind, newNormalData);\r\n        }\r\n        if (newUVsData.length > 0) {\r\n            this._reconstructedMesh.setVerticesData(VertexBuffer.UVKind, newUVsData);\r\n        }\r\n        if (newColorsData.length > 0) {\r\n            this._reconstructedMesh.setVerticesData(VertexBuffer.ColorKind, newColorsData);\r\n        }\r\n\r\n        //create submesh\r\n        const originalSubmesh = this._mesh.subMeshes[submeshIndex];\r\n        if (submeshIndex > 0) {\r\n            this._reconstructedMesh.subMeshes = [];\r\n            submeshesArray.forEach((submesh) => {\r\n                SubMesh.AddToMesh(\r\n                    submesh.materialIndex,\r\n                    submesh.verticesStart,\r\n                    submesh.verticesCount,\r\n                    /* 0, newPositionData.length/3, */ submesh.indexStart,\r\n                    submesh.indexCount,\r\n                    submesh.getMesh()\r\n                );\r\n            });\r\n            SubMesh.AddToMesh(\r\n                originalSubmesh.materialIndex,\r\n                startingVertex,\r\n                vertexCount,\r\n                /* 0, newPositionData.length / 3, */ startingIndex,\r\n                newTriangles.length * 3,\r\n                this._reconstructedMesh\r\n            );\r\n        }\r\n    }\r\n\r\n    private _initDecimatedMesh() {\r\n        this._reconstructedMesh = new Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene());\r\n        this._reconstructedMesh.material = this._mesh.material;\r\n        this._reconstructedMesh.parent = this._mesh.parent;\r\n        this._reconstructedMesh.isVisible = false;\r\n        this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\r\n    }\r\n\r\n    private _isFlipped(vertex1: DecimationVertex, vertex2: DecimationVertex, point: Vector3, deletedArray: Array<boolean>, delTr: Array<DecimationTriangle>): boolean {\r\n        for (let i = 0; i < vertex1.triangleCount; ++i) {\r\n            const t = this._triangles[this._references[vertex1.triangleStart + i].triangleId];\r\n            if (t.deleted) {\r\n                continue;\r\n            }\r\n\r\n            const s = this._references[vertex1.triangleStart + i].vertexId;\r\n\r\n            const v1 = t._vertices[(s + 1) % 3];\r\n            const v2 = t._vertices[(s + 2) % 3];\r\n\r\n            if (v1 === vertex2 || v2 === vertex2) {\r\n                deletedArray[i] = true;\r\n                delTr.push(t);\r\n                continue;\r\n            }\r\n\r\n            let d1 = v1.position.subtract(point);\r\n            d1 = d1.normalize();\r\n            let d2 = v2.position.subtract(point);\r\n            d2 = d2.normalize();\r\n            if (Math.abs(Vector3.Dot(d1, d2)) > 0.999) {\r\n                return true;\r\n            }\r\n            const normal = Vector3.Cross(d1, d2).normalize();\r\n            deletedArray[i] = false;\r\n            if (Vector3.Dot(normal, t.normal) < 0.2) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _updateTriangles(origVertex: DecimationVertex, vertex: DecimationVertex, deletedArray: Array<boolean>, deletedTriangles: number): number {\r\n        let newDeleted = deletedTriangles;\r\n        for (let i = 0; i < vertex.triangleCount; ++i) {\r\n            const ref = this._references[vertex.triangleStart + i];\r\n            const t = this._triangles[ref.triangleId];\r\n            if (t.deleted) {\r\n                continue;\r\n            }\r\n            if (deletedArray[i] && t.deletePending) {\r\n                t.deleted = true;\r\n                newDeleted++;\r\n                continue;\r\n            }\r\n            t._vertices[ref.vertexId] = origVertex;\r\n            t.isDirty = true;\r\n            t.error[0] = this._calculateError(t._vertices[0], t._vertices[1]) + t.borderFactor / 2;\r\n            t.error[1] = this._calculateError(t._vertices[1], t._vertices[2]) + t.borderFactor / 2;\r\n            t.error[2] = this._calculateError(t._vertices[2], t._vertices[0]) + t.borderFactor / 2;\r\n            t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\r\n            this._references.push(ref);\r\n        }\r\n        return newDeleted;\r\n    }\r\n\r\n    private _identifyBorder() {\r\n        for (let i = 0; i < this._vertices.length; ++i) {\r\n            const vCount: Array<number> = [];\r\n            const vId: Array<number> = [];\r\n            const v = this._vertices[i];\r\n            let j: number;\r\n            for (j = 0; j < v.triangleCount; ++j) {\r\n                const triangle = this._triangles[this._references[v.triangleStart + j].triangleId];\r\n                for (let ii = 0; ii < 3; ii++) {\r\n                    let ofs = 0;\r\n                    const vv = triangle._vertices[ii];\r\n                    while (ofs < vCount.length) {\r\n                        if (vId[ofs] === vv.id) {\r\n                            break;\r\n                        }\r\n                        ++ofs;\r\n                    }\r\n                    if (ofs === vCount.length) {\r\n                        vCount.push(1);\r\n                        vId.push(vv.id);\r\n                    } else {\r\n                        vCount[ofs]++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (j = 0; j < vCount.length; ++j) {\r\n                if (vCount[j] === 1) {\r\n                    this._vertices[vId[j]].isBorder = true;\r\n                } else {\r\n                    this._vertices[vId[j]].isBorder = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateMesh(identifyBorders: boolean = false) {\r\n        let i: number;\r\n        if (!identifyBorders) {\r\n            const newTrianglesVector: Array<DecimationTriangle> = [];\r\n            for (i = 0; i < this._triangles.length; ++i) {\r\n                if (!this._triangles[i].deleted) {\r\n                    newTrianglesVector.push(this._triangles[i]);\r\n                }\r\n            }\r\n            this._triangles = newTrianglesVector;\r\n        }\r\n\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            this._vertices[i].triangleCount = 0;\r\n            this._vertices[i].triangleStart = 0;\r\n        }\r\n        let t: DecimationTriangle;\r\n        let j: number;\r\n        let v: DecimationVertex;\r\n        for (i = 0; i < this._triangles.length; ++i) {\r\n            t = this._triangles[i];\r\n            for (j = 0; j < 3; ++j) {\r\n                v = t._vertices[j];\r\n                v.triangleCount++;\r\n            }\r\n        }\r\n\r\n        let tStart = 0;\r\n\r\n        for (i = 0; i < this._vertices.length; ++i) {\r\n            this._vertices[i].triangleStart = tStart;\r\n            tStart += this._vertices[i].triangleCount;\r\n            this._vertices[i].triangleCount = 0;\r\n        }\r\n\r\n        const newReferences: Array<Reference> = new Array(this._triangles.length * 3);\r\n        for (i = 0; i < this._triangles.length; ++i) {\r\n            t = this._triangles[i];\r\n            for (j = 0; j < 3; ++j) {\r\n                v = t._vertices[j];\r\n                newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);\r\n                v.triangleCount++;\r\n            }\r\n        }\r\n        this._references = newReferences;\r\n\r\n        if (identifyBorders) {\r\n            this._identifyBorder();\r\n        }\r\n    }\r\n\r\n    private _vertexError(q: QuadraticMatrix, point: Vector3): number {\r\n        const x = point.x;\r\n        const y = point.y;\r\n        const z = point.z;\r\n        return (\r\n            q.data[0] * x * x +\r\n            2 * q.data[1] * x * y +\r\n            2 * q.data[2] * x * z +\r\n            2 * q.data[3] * x +\r\n            q.data[4] * y * y +\r\n            2 * q.data[5] * y * z +\r\n            2 * q.data[6] * y +\r\n            q.data[7] * z * z +\r\n            2 * q.data[8] * z +\r\n            q.data[9]\r\n        );\r\n    }\r\n\r\n    private _calculateError(vertex1: DecimationVertex, vertex2: DecimationVertex, pointResult?: Vector3): number {\r\n        const q = vertex1.q.add(vertex2.q);\r\n        const border = vertex1.isBorder && vertex2.isBorder;\r\n        let error: number = 0;\r\n        const qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\r\n\r\n        if (qDet !== 0 && !border) {\r\n            if (!pointResult) {\r\n                pointResult = Vector3.Zero();\r\n            }\r\n            pointResult.x = (-1 / qDet) * q.det(1, 2, 3, 4, 5, 6, 5, 7, 8);\r\n            pointResult.y = (1 / qDet) * q.det(0, 2, 3, 1, 5, 6, 2, 7, 8);\r\n            pointResult.z = (-1 / qDet) * q.det(0, 1, 3, 1, 4, 6, 2, 5, 8);\r\n            error = this._vertexError(q, pointResult);\r\n        } else {\r\n            const p3 = vertex1.position.add(vertex2.position).divide(new Vector3(2, 2, 2));\r\n            //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();\r\n            const error1 = this._vertexError(q, vertex1.position);\r\n            const error2 = this._vertexError(q, vertex2.position);\r\n            const error3 = this._vertexError(q, p3);\r\n            error = Math.min(error1, error2, error3);\r\n            if (error === error1) {\r\n                if (pointResult) {\r\n                    pointResult.copyFrom(vertex1.position);\r\n                }\r\n            } else if (error === error2) {\r\n                if (pointResult) {\r\n                    pointResult.copyFrom(vertex2.position);\r\n                }\r\n            } else {\r\n                if (pointResult) {\r\n                    pointResult.copyFrom(p3);\r\n                }\r\n            }\r\n        }\r\n        return error;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}