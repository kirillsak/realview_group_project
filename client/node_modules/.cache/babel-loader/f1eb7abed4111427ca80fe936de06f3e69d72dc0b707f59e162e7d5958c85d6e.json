{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine.js\";\n/** @internal */\nexport var ComputeBindingType;\n(function (ComputeBindingType) {\n  ComputeBindingType[ComputeBindingType[\"Texture\"] = 0] = \"Texture\";\n  ComputeBindingType[ComputeBindingType[\"StorageTexture\"] = 1] = \"StorageTexture\";\n  ComputeBindingType[ComputeBindingType[\"UniformBuffer\"] = 2] = \"UniformBuffer\";\n  ComputeBindingType[ComputeBindingType[\"StorageBuffer\"] = 3] = \"StorageBuffer\";\n  ComputeBindingType[ComputeBindingType[\"TextureWithoutSampler\"] = 4] = \"TextureWithoutSampler\";\n  ComputeBindingType[ComputeBindingType[\"Sampler\"] = 5] = \"Sampler\";\n})(ComputeBindingType || (ComputeBindingType = {}));\nThinEngine.prototype.createComputeEffect = function (baseName, options) {\n  throw new Error(\"createComputeEffect: This engine does not support compute shaders!\");\n};\nThinEngine.prototype.createComputePipelineContext = function () {\n  throw new Error(\"createComputePipelineContext: This engine does not support compute shaders!\");\n};\nThinEngine.prototype.createComputeContext = function () {\n  return undefined;\n};\nThinEngine.prototype.computeDispatch = function (effect, context, bindings, x, y, z, bindingsMapping) {\n  throw new Error(\"computeDispatch: This engine does not support compute shaders!\");\n};\nThinEngine.prototype.areAllComputeEffectsReady = function () {\n  return true;\n};\nThinEngine.prototype.releaseComputeEffects = function () {};\nThinEngine.prototype._prepareComputePipelineContext = function (pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {};\nThinEngine.prototype._rebuildComputeEffects = function () {};\nThinEngine.prototype._executeWhenComputeStateIsCompiled = function (pipelineContext, action) {\n  action();\n};\nThinEngine.prototype._releaseComputeEffect = function (effect) {};\nThinEngine.prototype._deleteComputePipelineContext = function (pipelineContext) {};","map":{"version":3,"mappings":"AAIA,SAASA,UAAU,QAAQ,6BAA2B;AAetD;AACA,WAAYC,kBAOX;AAPD,WAAYA,kBAAkB;EAC1BA,iEAAW;EACXA,+EAAkB;EAClBA,6EAAiB;EACjBA,6EAAiB;EACjBA,6FAAyB;EACzBA,iEAAW;AACf,CAAC,EAPWA,kBAAkB,KAAlBA,kBAAkB;AAwF9BD,UAAU,CAACE,SAAS,CAACC,mBAAmB,GAAG,UAAUC,QAAa,EAAEC,OAAsC;EACtG,MAAM,IAAIC,KAAK,CAAC,oEAAoE,CAAC;AACzF,CAAC;AAEDN,UAAU,CAACE,SAAS,CAACK,4BAA4B,GAAG;EAChD,MAAM,IAAID,KAAK,CAAC,6EAA6E,CAAC;AAClG,CAAC;AAEDN,UAAU,CAACE,SAAS,CAACM,oBAAoB,GAAG;EACxC,OAAOC,SAAS;AACpB,CAAC;AAEDT,UAAU,CAACE,SAAS,CAACQ,eAAe,GAAG,UACnCC,MAAqB,EACrBC,OAAwB,EACxBC,QAA4B,EAC5BC,CAAS,EACTC,CAAU,EACVC,CAAU,EACVC,eAAuC;EAEvC,MAAM,IAAIX,KAAK,CAAC,gEAAgE,CAAC;AACrF,CAAC;AAEDN,UAAU,CAACE,SAAS,CAACgB,yBAAyB,GAAG;EAC7C,OAAO,IAAI;AACf,CAAC;AAEDlB,UAAU,CAACE,SAAS,CAACiB,qBAAqB,GAAG,aAAmB,CAAC;AAEjEnB,UAAU,CAACE,SAAS,CAACkB,8BAA8B,GAAG,UAClDC,eAAwC,EACxCC,iBAAyB,EACzBC,oBAA4B,EAC5BC,OAAyB,EACzBC,UAAkB,GACb,CAAC;AAEVzB,UAAU,CAACE,SAAS,CAACwB,sBAAsB,GAAG,aAAmB,CAAC;AAElE1B,UAAU,CAACE,SAAS,CAACyB,kCAAkC,GAAG,UAAUN,eAAwC,EAAEO,MAAkB;EAC5HA,MAAM,EAAE;AACZ,CAAC;AAED5B,UAAU,CAACE,SAAS,CAAC2B,qBAAqB,GAAG,UAAUlB,MAAqB,GAAS,CAAC;AAEtFX,UAAU,CAACE,SAAS,CAAC4B,6BAA6B,GAAG,UAAUT,eAAwC,GAAS,CAAC","names":["ThinEngine","ComputeBindingType","prototype","createComputeEffect","baseName","options","Error","createComputePipelineContext","createComputeContext","undefined","computeDispatch","effect","context","bindings","x","y","z","bindingsMapping","areAllComputeEffectsReady","releaseComputeEffects","_prepareComputePipelineContext","pipelineContext","computeSourceCode","rawComputeSourceCode","defines","entryPoint","_rebuildComputeEffects","_executeWhenComputeStateIsCompiled","action","_releaseComputeEffect","_deleteComputePipelineContext"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.computeShader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../Compute/IComputePipelineContext\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Type used to locate a resource in a compute shader.\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingLocation = { group: number; binding: number };\r\n\r\n/**\r\n * Type used to lookup a resource and retrieve its binding location\r\n * TODO: remove this when browsers support reflection for wgsl shaders\r\n */\r\nexport type ComputeBindingMapping = { [key: string]: ComputeBindingLocation };\r\n\r\n/** @internal */\r\nexport enum ComputeBindingType {\r\n    Texture = 0,\r\n    StorageTexture = 1,\r\n    UniformBuffer = 2,\r\n    StorageBuffer = 3,\r\n    TextureWithoutSampler = 4,\r\n    Sampler = 5,\r\n}\r\n\r\n/** @internal */\r\nexport type ComputeBindingList = { [key: string]: { type: ComputeBindingType; object: any; indexInGroupEntries?: number } };\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a new compute effect\r\n         * @param baseName Name of the effect\r\n         * @param options Options used to create the effect\r\n         * @returns The new compute effect\r\n         */\r\n        createComputeEffect(baseName: any, options: IComputeEffectCreationOptions): ComputeEffect;\r\n\r\n        /**\r\n         * Creates a new compute pipeline context\r\n         * @returns the new pipeline\r\n         */\r\n        createComputePipelineContext(): IComputePipelineContext;\r\n\r\n        /**\r\n         * Creates a new compute context\r\n         * @returns the new context\r\n         */\r\n        createComputeContext(): IComputeContext | undefined;\r\n\r\n        /**\r\n         * Dispatches a compute shader\r\n         * @param effect The compute effect\r\n         * @param context The compute context\r\n         * @param bindings The list of resources to bind to the shader\r\n         * @param x The number of workgroups to execute on the X dimension\r\n         * @param y The number of workgroups to execute on the Y dimension\r\n         * @param z The number of workgroups to execute on the Z dimension\r\n         * @param bindingsMapping list of bindings mapping (key is property name, value is binding location)\r\n         */\r\n        computeDispatch(\r\n            effect: ComputeEffect,\r\n            context: IComputeContext,\r\n            bindings: ComputeBindingList,\r\n            x: number,\r\n            y?: number,\r\n            z?: number,\r\n            bindingsMapping?: ComputeBindingMapping\r\n        ): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if all created compute effects are ready\r\n         * @returns true if all effects are ready\r\n         */\r\n        areAllComputeEffectsReady(): boolean;\r\n\r\n        /**\r\n         * Forces the engine to release all cached compute effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled\r\n         */\r\n        releaseComputeEffects(): void;\r\n\r\n        /** @internal */\r\n        _prepareComputePipelineContext(\r\n            pipelineContext: IComputePipelineContext,\r\n            computeSourceCode: string,\r\n            rawComputeSourceCode: string,\r\n            defines: Nullable<string>,\r\n            entryPoint: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _rebuildComputeEffects(): void;\r\n\r\n        /** @internal */\r\n        _executeWhenComputeStateIsCompiled(pipelineContext: IComputePipelineContext, action: () => void): void;\r\n\r\n        /** @internal */\r\n        _releaseComputeEffect(effect: ComputeEffect): void;\r\n\r\n        /** @internal */\r\n        _deleteComputePipelineContext(pipelineContext: IComputePipelineContext): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    throw new Error(\"createComputeEffect: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    throw new Error(\"createComputePipelineContext: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return undefined;\r\n};\r\n\r\nThinEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    throw new Error(\"computeDispatch: This engine does not support compute shaders!\");\r\n};\r\n\r\nThinEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    return true;\r\n};\r\n\r\nThinEngine.prototype.releaseComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {};\r\n\r\nThinEngine.prototype._rebuildComputeEffects = function (): void {};\r\n\r\nThinEngine.prototype._executeWhenComputeStateIsCompiled = function (pipelineContext: IComputePipelineContext, action: () => void): void {\r\n    action();\r\n};\r\n\r\nThinEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {};\r\n\r\nThinEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}