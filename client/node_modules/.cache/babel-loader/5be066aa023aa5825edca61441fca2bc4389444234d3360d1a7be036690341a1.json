{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { GPUParticleSystem } from \"./gpuParticleSystem.js\";\nimport { ParticleSystemSet } from \"./particleSystemSet.js\";\nimport { ParticleSystem } from \"./particleSystem.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n\n/**\n * This class is made for on one-liner static method to help creating particle system set.\n */\nexport class ParticleHelper {\n  /**\n   * Create a default particle system that you can tweak\n   * @param emitter defines the emitter to use\n   * @param capacity defines the system capacity (default is 500 particles)\n   * @param scene defines the hosting scene\n   * @param useGPU defines if a GPUParticleSystem must be created (default is false)\n   * @returns the new Particle system\n   */\n  static CreateDefault(emitter, capacity = 500, scene, useGPU = false) {\n    let system;\n    if (useGPU) {\n      system = new GPUParticleSystem(\"default system\", {\n        capacity: capacity\n      }, scene);\n    } else {\n      system = new ParticleSystem(\"default system\", capacity, scene);\n    }\n    system.emitter = emitter;\n    system.particleTexture = new Texture(\"https://assets.babylonjs.com/textures/flare.png\", system.getScene());\n    system.createConeEmitter(0.1, Math.PI / 4);\n    // Particle color\n    system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\n    system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\n    // Particle Size\n    system.minSize = 0.1;\n    system.maxSize = 0.1;\n    // Emission speed\n    system.minEmitPower = 2;\n    system.maxEmitPower = 2;\n    // Update speed\n    system.updateSpeed = 1 / 60;\n    system.emitRate = 30;\n    return system;\n  }\n  /**\n   * This is the main static method (one-liner) of this helper to create different particle systems\n   * @param type This string represents the type to the particle system to create\n   * @param scene The scene where the particle system should live\n   * @param gpu If the system will use gpu\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the ParticleSystemSet created\n   */\n  static CreateAsync(type, scene, gpu = false, capacity) {\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n    const token = {};\n    scene.addPendingData(token);\n    return new Promise((resolve, reject) => {\n      if (gpu && !GPUParticleSystem.IsSupported) {\n        scene.removePendingData(token);\n        return reject(\"Particle system with GPU is not supported.\");\n      }\n      Tools.LoadFile(`${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`, data => {\n        scene.removePendingData(token);\n        const newData = JSON.parse(data.toString());\n        return resolve(ParticleSystemSet.Parse(newData, scene, gpu, capacity));\n      }, undefined, undefined, undefined, () => {\n        scene.removePendingData(token);\n        return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);\n      });\n    });\n  }\n  /**\n   * Static function used to export a particle system to a ParticleSystemSet variable.\n   * Please note that the emitter shape is not exported\n   * @param systems defines the particle systems to export\n   * @returns the created particle system set\n   */\n  static ExportSet(systems) {\n    const set = new ParticleSystemSet();\n    for (const system of systems) {\n      set.systems.push(system);\n    }\n    return set;\n  }\n  /**\n   * Creates a particle system from a snippet saved in a remote file\n   * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param gpu If the system will use gpu\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a promise that will resolve to the new particle system\n   */\n  static ParseFromFileAsync(name, url, scene, gpu = false, rootUrl = \"\", capacity) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            let output;\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            }\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the particle system\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a particle system from a snippet saved by the particle system editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param gpu If the system will use gpu\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns a promise that will resolve to the new particle system\n   */\n  static ParseFromSnippetAsync(snippetId, scene, gpu = false, rootUrl = \"\", capacity) {\n    if (snippetId === \"_BLANK\") {\n      const system = this.CreateDefault(null);\n      system.start();\n      return Promise.resolve(system);\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.particleSystem);\n            let output;\n            if (gpu) {\n              output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            } else {\n              output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\n            }\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/**\n * Gets or sets base Assets URL\n */\nParticleHelper.BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\n/** Define the Url to load snippets */\nParticleHelper.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a particle system from a snippet saved by the particle system editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param gpu If the system will use gpu\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n * @returns a promise that will resolve to the new particle system\n */\nParticleHelper.CreateFromSnippetAsync = ParticleHelper.ParseFromSnippetAsync;","map":{"version":3,"mappings":"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","names":["Tools","Color4","Texture","EngineStore","GPUParticleSystem","ParticleSystemSet","ParticleSystem","WebRequest","ParticleHelper","CreateDefault","emitter","capacity","scene","useGPU","system","particleTexture","getScene","createConeEmitter","Math","PI","color1","color2","colorDead","minSize","maxSize","minEmitPower","maxEmitPower","updateSpeed","emitRate","CreateAsync","type","gpu","LastCreatedScene","token","addPendingData","Promise","resolve","reject","IsSupported","removePendingData","LoadFile","BaseAssetsUrl","data","newData","JSON","parse","toString","Parse","undefined","ExportSet","systems","set","push","ParseFromFileAsync","name","url","rootUrl","request","addEventListener","readyState","status","serializationObject","responseText","output","open","send","ParseFromSnippetAsync","snippetId","start","snippet","jsonPayload","particleSystem","SnippetUrl","replace"],"sourceRoot":"","sources":["../../../../lts/core/generated/Particles/particleHelper.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { GPUParticleSystem } from \"./gpuParticleSystem\";\r\nimport { ParticleSystemSet } from \"./particleSystemSet\";\r\nimport { ParticleSystem } from \"./particleSystem\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\n/**\r\n * This class is made for on one-liner static method to help creating particle system set.\r\n */\r\nexport class ParticleHelper {\r\n    /**\r\n     * Gets or sets base Assets URL\r\n     */\r\n    public static BaseAssetsUrl = ParticleSystemSet.BaseAssetsUrl;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /**\r\n     * Create a default particle system that you can tweak\r\n     * @param emitter defines the emitter to use\r\n     * @param capacity defines the system capacity (default is 500 particles)\r\n     * @param scene defines the hosting scene\r\n     * @param useGPU defines if a GPUParticleSystem must be created (default is false)\r\n     * @returns the new Particle system\r\n     */\r\n    public static CreateDefault(emitter: Nullable<AbstractMesh | Vector3>, capacity = 500, scene?: Scene, useGPU = false): IParticleSystem {\r\n        let system: IParticleSystem;\r\n\r\n        if (useGPU) {\r\n            system = new GPUParticleSystem(\"default system\", { capacity: capacity }, scene!);\r\n        } else {\r\n            system = new ParticleSystem(\"default system\", capacity, scene!);\r\n        }\r\n\r\n        system.emitter = emitter;\r\n        system.particleTexture = new Texture(\"https://assets.babylonjs.com/textures/flare.png\", system.getScene());\r\n        system.createConeEmitter(0.1, Math.PI / 4);\r\n\r\n        // Particle color\r\n        system.color1 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        system.color2 = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        system.colorDead = new Color4(1.0, 1.0, 1.0, 0.0);\r\n\r\n        // Particle Size\r\n        system.minSize = 0.1;\r\n        system.maxSize = 0.1;\r\n\r\n        // Emission speed\r\n        system.minEmitPower = 2;\r\n        system.maxEmitPower = 2;\r\n\r\n        // Update speed\r\n        system.updateSpeed = 1 / 60;\r\n\r\n        system.emitRate = 30;\r\n\r\n        return system;\r\n    }\r\n\r\n    /**\r\n     * This is the main static method (one-liner) of this helper to create different particle systems\r\n     * @param type This string represents the type to the particle system to create\r\n     * @param scene The scene where the particle system should live\r\n     * @param gpu If the system will use gpu\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the ParticleSystemSet created\r\n     */\r\n    public static CreateAsync(type: string, scene: Nullable<Scene>, gpu: boolean = false, capacity?: number): Promise<ParticleSystemSet> {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        const token = {};\r\n\r\n        scene!.addPendingData(token);\r\n\r\n        return new Promise((resolve, reject) => {\r\n            if (gpu && !GPUParticleSystem.IsSupported) {\r\n                scene!.removePendingData(token);\r\n                return reject(\"Particle system with GPU is not supported.\");\r\n            }\r\n\r\n            Tools.LoadFile(\r\n                `${ParticleHelper.BaseAssetsUrl}/systems/${type}.json`,\r\n                (data) => {\r\n                    scene!.removePendingData(token);\r\n                    const newData = JSON.parse(data.toString());\r\n                    return resolve(ParticleSystemSet.Parse(newData, scene!, gpu, capacity));\r\n                },\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    scene!.removePendingData(token);\r\n                    return reject(`An error occurred with the creation of your particle system. Check if your type '${type}' exists.`);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Static function used to export a particle system to a ParticleSystemSet variable.\r\n     * Please note that the emitter shape is not exported\r\n     * @param systems defines the particle systems to export\r\n     * @returns the created particle system set\r\n     */\r\n    public static ExportSet(systems: IParticleSystem[]): ParticleSystemSet {\r\n        const set = new ParticleSystemSet();\r\n\r\n        for (const system of systems) {\r\n            set.systems.push(system);\r\n        }\r\n\r\n        return set;\r\n    }\r\n\r\n    /**\r\n     * Creates a particle system from a snippet saved in a remote file\r\n     * @param name defines the name of the particle system to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param gpu If the system will use gpu\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a promise that will resolve to the new particle system\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\", capacity?: number): Promise<IParticleSystem> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        let output: IParticleSystem;\r\n\r\n                        if (gpu) {\r\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        } else {\r\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        }\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the particle system\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a particle system from a snippet saved by the particle system editor\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param gpu If the system will use gpu\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a promise that will resolve to the new particle system\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, gpu: boolean = false, rootUrl: string = \"\", capacity?: number): Promise<IParticleSystem> {\r\n        if (snippetId === \"_BLANK\") {\r\n            const system = this.CreateDefault(null);\r\n            system.start();\r\n            return Promise.resolve(system);\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.particleSystem);\r\n                        let output: IParticleSystem;\r\n\r\n                        if (gpu) {\r\n                            output = GPUParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        } else {\r\n                            output = ParticleSystem.Parse(serializationObject, scene, rootUrl, false, capacity);\r\n                        }\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a particle system from a snippet saved by the particle system editor\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param gpu If the system will use gpu\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns a promise that will resolve to the new particle system\r\n     */\r\n    public static CreateFromSnippetAsync = ParticleHelper.ParseFromSnippetAsync;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}