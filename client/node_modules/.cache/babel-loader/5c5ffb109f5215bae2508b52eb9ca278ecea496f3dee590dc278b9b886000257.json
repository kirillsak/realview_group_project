{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator.js\";\nimport { SceneComponentConstants } from \"../../sceneComponent.js\";\nimport { AbstractScene } from \"../../abstractScene.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData, scene) => {\n  // Shadows\n  if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\n    for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n      const parsedShadowGenerator = parsedData.shadowGenerators[index];\n      if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\n        CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\n      } else {\n        ShadowGenerator.Parse(parsedShadowGenerator, scene);\n      }\n      // SG would be available on their associated lights\n    }\n  }\n});\n/**\n * Defines the shadow generator component responsible to manage any shadow generators\n * in a given scene.\n */\nexport class ShadowGeneratorSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_SHADOWGENERATOR;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing To Do Here.\n  }\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    // Shadows\n    serializationObject.shadowGenerators = [];\n    const lights = this.scene.lights;\n    for (const light of lights) {\n      const shadowGenerators = light.getShadowGenerators();\n      if (shadowGenerators) {\n        const iterator = shadowGenerators.values();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n          const shadowGenerator = key.value;\n          serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n        }\n      }\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  addFromContainer(container) {\n    // Nothing To Do Here. (directly attached to a light)\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removeFromContainer(container, dispose) {\n    // Nothing To Do Here. (directly attached to a light)\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  dispose() {\n    // Nothing To Do Here.\n  }\n  _gatherRenderTargets(renderTargets) {\n    // Shadows\n    const scene = this.scene;\n    if (this.scene.shadowsEnabled) {\n      for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\n        const light = scene.lights[lightIndex];\n        const shadowGenerators = light.getShadowGenerators();\n        if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\n          const iterator = shadowGenerators.values();\n          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n            const shadowGenerator = key.value;\n            const shadowMap = shadowGenerator.getShadowMap();\n            if (scene.textures.indexOf(shadowMap) !== -1) {\n              renderTargets.push(shadowMap);\n            }\n          }\n        }\n      }\n    }\n  }\n}\nShadowGenerator._SceneComponentInitialization = scene => {\n  let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\n  if (!component) {\n    component = new ShadowGeneratorSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"mappings":"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","names":["ShadowGenerator","CascadedShadowGenerator","SceneComponentConstants","AbstractScene","AddParser","NAME_SHADOWGENERATOR","parsedData","scene","shadowGenerators","undefined","index","cache","length","parsedShadowGenerator","className","CLASSNAME","Parse","ShadowGeneratorSceneComponent","constructor","register","_gatherRenderTargetsStage","registerStep","STEP_GATHERRENDERTARGETS_SHADOWGENERATOR","_gatherRenderTargets","rebuild","serialize","serializationObject","lights","light","getShadowGenerators","iterator","values","key","next","done","shadowGenerator","value","push","addFromContainer","container","removeFromContainer","dispose","renderTargets","shadowsEnabled","lightIndex","isEnabled","shadowEnabled","shadowMap","getShadowMap","textures","indexOf","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Lights/Shadows/shadowGeneratorSceneComponent.ts"],"sourcesContent":["import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport { CascadedShadowGenerator } from \"./cascadedShadowGenerator\";\r\nimport type { ISceneSerializableComponent } from \"../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\nimport { AbstractScene } from \"../../abstractScene\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SHADOWGENERATOR, (parsedData: any, scene: Scene) => {\r\n    // Shadows\r\n    if (parsedData.shadowGenerators !== undefined && parsedData.shadowGenerators !== null) {\r\n        for (let index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\r\n            const parsedShadowGenerator = parsedData.shadowGenerators[index];\r\n            if (parsedShadowGenerator.className === CascadedShadowGenerator.CLASSNAME) {\r\n                CascadedShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            } else {\r\n                ShadowGenerator.Parse(parsedShadowGenerator, scene);\r\n            }\r\n            // SG would be available on their associated lights\r\n        }\r\n    }\r\n});\r\n\r\n/**\r\n * Defines the shadow generator component responsible to manage any shadow generators\r\n * in a given scene.\r\n */\r\nexport class ShadowGeneratorSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_SHADOWGENERATOR;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._gatherRenderTargetsStage.registerStep(SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Shadows\r\n        serializationObject.shadowGenerators = [];\r\n        const lights = this.scene.lights;\r\n        for (const light of lights) {\r\n            const shadowGenerators = light.getShadowGenerators();\r\n            if (shadowGenerators) {\r\n                const iterator = shadowGenerators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const shadowGenerator = key.value;\r\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public addFromContainer(container: AbstractScene): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        // Nothing To Do Here. (directly attached to a light)\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing To Do Here.\r\n    }\r\n\r\n    private _gatherRenderTargets(renderTargets: SmartArrayNoDuplicate<RenderTargetTexture>): void {\r\n        // Shadows\r\n        const scene = this.scene;\r\n        if (this.scene.shadowsEnabled) {\r\n            for (let lightIndex = 0; lightIndex < scene.lights.length; lightIndex++) {\r\n                const light = scene.lights[lightIndex];\r\n                const shadowGenerators = light.getShadowGenerators();\r\n\r\n                if (light.isEnabled() && light.shadowEnabled && shadowGenerators) {\r\n                    const iterator = shadowGenerators.values();\r\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                        const shadowGenerator = key.value;\r\n                        const shadowMap = <RenderTargetTexture>shadowGenerator.getShadowMap();\r\n                        if (scene.textures.indexOf(shadowMap) !== -1) {\r\n                            renderTargets.push(shadowMap);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nShadowGenerator._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SHADOWGENERATOR);\r\n    if (!component) {\r\n        component = new ShadowGeneratorSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}