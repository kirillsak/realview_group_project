{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * A module that will enable pointer selection for motion controllers of XR Input Sources\n */\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\n  /**\n   * constructs a new background remover module\n   * @param _xrSessionManager the session manager for this module\n   * @param _options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      const {\n        laserPointer,\n        selectionMesh\n      } = this._generateNewMeshPair(xrController.pointer);\n      // get two new meshes\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        laserPointer,\n        selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n      if (this._attachedController) {\n        if (!this._options.enablePointerSelectionOnAllControllers && this._options.preferredHandedness && xrController.inputSource.handedness === this._options.preferredHandedness) {\n          this._attachedController = xrController.uniqueId;\n        }\n      } else {\n        if (!this._options.enablePointerSelectionOnAllControllers) {\n          this._attachedController = xrController.uniqueId;\n        }\n      }\n      switch (xrController.inputSource.targetRayMode) {\n        case \"tracked-pointer\":\n          return this._attachTrackedPointerRayMode(xrController);\n        case \"gaze\":\n          return this._attachGazeMode(xrController);\n        case \"screen\":\n          return this._attachScreenRayMode(xrController);\n      }\n    };\n    this._controllers = {};\n    this._tmpVectorForPickCompare = new Vector3();\n    /**\n     * Disable lighting on the laser pointer (so it will always be visible)\n     */\n    this.disablePointerLighting = true;\n    /**\n     * Disable lighting on the selection mesh (so it will always be visible)\n     */\n    this.disableSelectionMeshLighting = true;\n    /**\n     * Should the laser pointer be displayed\n     */\n    this.displayLaserPointer = true;\n    /**\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\n     */\n    this.displaySelectionMesh = true;\n    /**\n     * This color will be set to the laser pointer when selection is triggered\n     */\n    this.laserPointerPickedColor = new Color3(0.9, 0.9, 0.9);\n    /**\n     * Default color of the laser pointer\n     */\n    this.laserPointerDefaultColor = new Color3(0.7, 0.7, 0.7);\n    /**\n     * default color of the selection ring\n     */\n    this.selectionMeshDefaultColor = new Color3(0.8, 0.8, 0.8);\n    /**\n     * This color will be applied to the selection ring when selection is triggered\n     */\n    this.selectionMeshPickedColor = new Color3(0.3, 0.3, 1.0);\n    this._identityMatrix = Matrix.Identity();\n    this._screenCoordinatesRef = Vector3.Zero();\n    this._viewportRef = new Viewport(0, 0, 0, 0);\n    this._scene = this._xrSessionManager.scene;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    this._scene.constantlyUpdateMeshUnderPointer = true;\n    if (this._options.gazeCamera) {\n      const webXRCamera = this._options.gazeCamera;\n      const {\n        laserPointer,\n        selectionMesh\n      } = this._generateNewMeshPair(webXRCamera);\n      this._controllers[\"camera\"] = {\n        webXRCamera,\n        laserPointer,\n        selectionMesh,\n        meshUnderPointer: null,\n        pick: null,\n        tmpRay: new Ray(new Vector3(), new Vector3()),\n        disabledByNearInteraction: false,\n        id: WebXRControllerPointerSelection._IdCounter++\n      };\n      this._attachGazeMode();\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    return true;\n  }\n  /**\n   * Will get the mesh under a specific pointer.\n   * `scene.meshUnderPointer` will only return one mesh - either left or right.\n   * @param controllerId the controllerId to check\n   * @returns The mesh under pointer or null if no mesh is under the pointer\n   */\n  getMeshUnderPointer(controllerId) {\n    if (this._controllers[controllerId]) {\n      return this._controllers[controllerId].meshUnderPointer;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Get the xr controller that correlates to the pointer id in the pointer event\n   *\n   * @param id the pointer id to search for\n   * @returns the controller that correlates to this id or null if not found\n   */\n  getXRControllerByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].xrController || null;\n      }\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  _getPointerSelectionDisabledByPointerId(id) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        return this._controllers[keys[i]].disabledByNearInteraction;\n      }\n    }\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _setPointerSelectionDisabledByPointerId(id, state) {\n    const keys = Object.keys(this._controllers);\n    for (let i = 0; i < keys.length; ++i) {\n      if (this._controllers[keys[i]].id === id) {\n        this._controllers[keys[i]].disabledByNearInteraction = state;\n        return;\n      }\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    Object.keys(this._controllers).forEach(id => {\n      // only do this for the selected pointer\n      const controllerData = this._controllers[id];\n      if (!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController || controllerData.disabledByNearInteraction) {\n        controllerData.selectionMesh.isVisible = false;\n        controllerData.laserPointer.isVisible = false;\n        controllerData.pick = null;\n        return;\n      }\n      controllerData.laserPointer.isVisible = this.displayLaserPointer;\n      let controllerGlobalPosition;\n      // Every frame check collisions/input\n      if (controllerData.xrController) {\n        controllerGlobalPosition = controllerData.xrController.pointer.position;\n        controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\n      } else if (controllerData.webXRCamera) {\n        controllerGlobalPosition = controllerData.webXRCamera.position;\n        controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\n      } else {\n        return;\n      }\n      if (this._options.maxPointerDistance) {\n        controllerData.tmpRay.length = this._options.maxPointerDistance;\n      }\n      // update pointerX and pointerY of the scene. Only if the flag is set to true!\n      if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\n        const scene = this._xrSessionManager.scene;\n        const camera = this._options.xrInput.xrCamera;\n        if (camera) {\n          camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\n          Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\n          // stay safe\n          if (typeof this._screenCoordinatesRef.x === \"number\" && typeof this._screenCoordinatesRef.y === \"number\" && !isNaN(this._screenCoordinatesRef.x) && !isNaN(this._screenCoordinatesRef.y)) {\n            scene.pointerX = this._screenCoordinatesRef.x;\n            scene.pointerY = this._screenCoordinatesRef.y;\n            controllerData.screenCoordinates = {\n              x: this._screenCoordinatesRef.x,\n              y: this._screenCoordinatesRef.y\n            };\n          }\n        }\n      }\n      let utilityScenePick = null;\n      if (this._utilityLayerScene) {\n        utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\n      }\n      const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\n      if (!utilityScenePick || !utilityScenePick.hit) {\n        // No hit in utility scene\n        controllerData.pick = originalScenePick;\n      } else if (!originalScenePick || !originalScenePick.hit) {\n        // No hit in original scene\n        controllerData.pick = utilityScenePick;\n      } else if (utilityScenePick.distance < originalScenePick.distance) {\n        // Hit is closer in utility scene\n        controllerData.pick = utilityScenePick;\n      } else {\n        // Hit is closer in original scene\n        controllerData.pick = originalScenePick;\n      }\n      if (controllerData.pick && controllerData.xrController) {\n        controllerData.pick.aimTransform = controllerData.xrController.pointer;\n        controllerData.pick.gripTransform = controllerData.xrController.grip || null;\n      }\n      const pick = controllerData.pick;\n      if (pick && pick.pickedPoint && pick.hit) {\n        // Update laser state\n        this._updatePointerDistance(controllerData.laserPointer, pick.distance);\n        // Update cursor state\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\n        controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\n        // To avoid z-fighting\n        const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\n        const deltaFighting = 0.001;\n        controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\n        if (pickNormal) {\n          const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          const axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\n          controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\n        }\n        controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\n        controllerData.meshUnderPointer = pick.pickedMesh;\n      } else {\n        controllerData.selectionMesh.isVisible = false;\n        this._updatePointerDistance(controllerData.laserPointer, 1);\n        controllerData.meshUnderPointer = null;\n      }\n    });\n  }\n  get _utilityLayerScene() {\n    return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\n  }\n  _attachGazeMode(xrController) {\n    const controllerData = this._controllers[xrController && xrController.uniqueId || \"camera\"];\n    // attached when touched, detaches when raised\n    const timeToSelect = this._options.timeToSelect || 3000;\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\n    let oldPick = new PickingInfo();\n    const discMesh = CreateTorus(\"selection\", {\n      diameter: 0.0035 * 15,\n      thickness: 0.0025 * 6,\n      tessellation: 20\n    }, sceneToRenderTo);\n    discMesh.isVisible = false;\n    discMesh.isPickable = false;\n    discMesh.parent = controllerData.selectionMesh;\n    let timer = 0;\n    let downTriggered = false;\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (!controllerData.pick) {\n        return;\n      }\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      controllerData.laserPointer.material.alpha = 0;\n      discMesh.isVisible = false;\n      if (controllerData.pick.hit) {\n        if (!this._pickingMoved(oldPick, controllerData.pick)) {\n          if (timer > timeToSelect / 10) {\n            discMesh.isVisible = true;\n          }\n          timer += this._scene.getEngine().getDeltaTime();\n          if (timer >= timeToSelect) {\n            this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n            // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\n            downTriggered = true;\n            // pointer up right after down, if disable on touch out\n            if (this._options.disablePointerUpOnTouchOut) {\n              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n            discMesh.isVisible = false;\n          } else {\n            const scaleFactor = 1 - timer / timeToSelect;\n            discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\n          }\n        } else {\n          if (downTriggered) {\n            if (!this._options.disablePointerUpOnTouchOut) {\n              this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n            }\n          }\n          downTriggered = false;\n          timer = 0;\n        }\n      } else {\n        downTriggered = false;\n        timer = 0;\n      }\n      this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      oldPick = controllerData.pick;\n    });\n    if (this._options.renderingGroupId !== undefined) {\n      discMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n    if (xrController) {\n      xrController.onDisposeObservable.addOnce(() => {\n        if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.finalPointerUpTriggered = true;\n        }\n        discMesh.dispose();\n      });\n    }\n  }\n  _attachScreenRayMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    let downTriggered = false;\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      if (!controllerData.pick || this._options.disablePointerUpOnTouchOut && downTriggered) {\n        return;\n      }\n      if (!downTriggered) {\n        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n        controllerData.pointerDownTriggered = true;\n        downTriggered = true;\n        if (this._options.disablePointerUpOnTouchOut) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n        }\n      } else {\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    xrController.onDisposeObservable.addOnce(() => {\n      this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n      this._xrSessionManager.runInXRFrame(() => {\n        if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.finalPointerUpTriggered = true;\n        }\n      });\n    });\n  }\n  _attachTrackedPointerRayMode(xrController) {\n    const controllerData = this._controllers[xrController.uniqueId];\n    if (this._options.forceGazeMode) {\n      return this._attachGazeMode(xrController);\n    }\n    const pointerEventInit = {\n      pointerId: controllerData.id,\n      pointerType: \"xr\"\n    };\n    controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\n      controllerData.laserPointer.material.disableLighting = this.disablePointerLighting;\n      controllerData.selectionMesh.material.disableLighting = this.disableSelectionMeshLighting;\n      if (controllerData.pick) {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\n      }\n    });\n    if (xrController.inputSource.gamepad) {\n      const init = motionController => {\n        if (this._options.overrideButtonId) {\n          controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\n        }\n        if (!controllerData.selectionComponent) {\n          controllerData.selectionComponent = motionController.getMainComponent();\n        }\n        controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add(component => {\n          if (component.changes.pressed) {\n            const pressed = component.changes.pressed.current;\n            if (controllerData.pick) {\n              if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n                if (pressed) {\n                  this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n                  controllerData.pointerDownTriggered = true;\n                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n                  controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n                } else {\n                  this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n                  controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n                  controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n                }\n              }\n            } else {\n              if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\n                this._attachedController = xrController.uniqueId;\n              }\n            }\n          }\n        });\n      };\n      if (xrController.motionController) {\n        init(xrController.motionController);\n      } else {\n        xrController.onMotionControllerInitObservable.add(init);\n      }\n    } else {\n      // use the select and squeeze events\n      const selectStartListener = event => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\n          controllerData.pointerDownTriggered = true;\n          controllerData.selectionMesh.material.emissiveColor = this.selectionMeshPickedColor;\n          controllerData.laserPointer.material.emissiveColor = this.laserPointerPickedColor;\n        }\n      };\n      const selectEndListener = event => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\n          this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\n          controllerData.selectionMesh.material.emissiveColor = this.selectionMeshDefaultColor;\n          controllerData.laserPointer.material.emissiveColor = this.laserPointerDefaultColor;\n        }\n      };\n      controllerData.eventListeners = {\n        selectend: selectEndListener,\n        selectstart: selectStartListener\n      };\n      this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\n      this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\n    }\n  }\n  _convertNormalToDirectionOfRay(normal, ray) {\n    if (normal) {\n      const angle = Math.acos(Vector3.Dot(normal, ray.direction));\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n    return normal;\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.selectionComponent) {\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    if (controllerData.onFrameObserver) {\n      this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\n    }\n    if (controllerData.eventListeners) {\n      Object.keys(controllerData.eventListeners).forEach(eventName => {\n        const func = controllerData.eventListeners && controllerData.eventListeners[eventName];\n        if (func) {\n          // For future reference - this is an issue in the WebXR typings.\n          this._xrSessionManager.session.removeEventListener(eventName, func);\n        }\n      });\n    }\n    if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\n      // Stay safe and fire a pointerup, in case it wasn't already triggered\n      const pointerEventInit = {\n        pointerId: controllerData.id,\n        pointerType: \"xr\"\n      };\n      this._xrSessionManager.runInXRFrame(() => {\n        this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\n        this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\n        controllerData.finalPointerUpTriggered = true;\n      });\n    }\n    this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\n      try {\n        controllerData.selectionMesh.dispose();\n        controllerData.laserPointer.dispose();\n        // remove from the map\n        delete this._controllers[xrControllerUniqueId];\n        if (this._attachedController === xrControllerUniqueId) {\n          // check for other controllers\n          const keys = Object.keys(this._controllers);\n          if (keys.length) {\n            this._attachedController = keys[0];\n          } else {\n            this._attachedController = \"\";\n          }\n        }\n      } catch (e) {\n        Tools.Warn(\"controller already detached.\");\n      }\n    });\n  }\n  _generateNewMeshPair(meshParent) {\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\n    const laserPointer = this._options.customLasterPointerMeshGenerator ? this._options.customLasterPointerMeshGenerator() : CreateCylinder(\"laserPointer\", {\n      height: 1,\n      diameterTop: 0.0002,\n      diameterBottom: 0.004,\n      tessellation: 20,\n      subdivisions: 1\n    }, sceneToRenderTo);\n    laserPointer.parent = meshParent;\n    const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\n    laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\n    laserPointerMaterial.alpha = 0.7;\n    laserPointer.material = laserPointerMaterial;\n    laserPointer.rotation.x = Math.PI / 2;\n    this._updatePointerDistance(laserPointer, 1);\n    laserPointer.isPickable = false;\n    laserPointer.isVisible = false;\n    // Create a gaze tracker for the  XR controller\n    const selectionMesh = this._options.customSelectionMeshGenerator ? this._options.customSelectionMeshGenerator() : CreateTorus(\"gazeTracker\", {\n      diameter: 0.0035 * 3,\n      thickness: 0.0025 * 3,\n      tessellation: 20\n    }, sceneToRenderTo);\n    selectionMesh.bakeCurrentTransformIntoVertices();\n    selectionMesh.isPickable = false;\n    selectionMesh.isVisible = false;\n    const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\n    targetMat.specularColor = Color3.Black();\n    targetMat.emissiveColor = this.selectionMeshDefaultColor;\n    targetMat.backFaceCulling = false;\n    selectionMesh.material = targetMat;\n    if (this._options.renderingGroupId !== undefined) {\n      laserPointer.renderingGroupId = this._options.renderingGroupId;\n      selectionMesh.renderingGroupId = this._options.renderingGroupId;\n    }\n    return {\n      laserPointer,\n      selectionMesh\n    };\n  }\n  _pickingMoved(oldPick, newPick) {\n    var _a;\n    if (!oldPick.hit || !newPick.hit) {\n      return true;\n    }\n    if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\n      return true;\n    }\n    if (oldPick.pickedMesh !== newPick.pickedMesh) {\n      return true;\n    }\n    (_a = oldPick.pickedPoint) === null || _a === void 0 ? void 0 : _a.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\n    this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\n    const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\n    const length = this._tmpVectorForPickCompare.length();\n    if (length > delta) {\n      return true;\n    }\n    return false;\n  }\n  _updatePointerDistance(_laserPointer, distance = 100) {\n    _laserPointer.scaling.y = distance;\n    // a bit of distance from the controller\n    if (this._scene.useRightHandedSystem) {\n      distance *= -1;\n    }\n    _laserPointer.position.z = distance / 2 + 0.05;\n  }\n  _augmentPointerInit(pointerEventInit, id, screenCoordinates) {\n    pointerEventInit.pointerId = id;\n    pointerEventInit.pointerType = \"xr\";\n    if (screenCoordinates) {\n      pointerEventInit.screenX = screenCoordinates.x;\n      pointerEventInit.screenY = screenCoordinates.y;\n    }\n  }\n  /** @internal */\n  get lasterPointerDefaultColor() {\n    // here due to a typo\n    return this.laserPointerDefaultColor;\n  }\n}\nWebXRControllerPointerSelection._IdCounter = 200;\n/**\n * The module's name\n */\nWebXRControllerPointerSelection.Name = WebXRFeatureName.POINTER_SELECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRControllerPointerSelection.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPointerSelection.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerPointerSelection(xrSessionManager, options);\n}, WebXRControllerPointerSelection.Version, true);","map":{"version":3,"mappings":"AAAA,SAASA,oBAAoB,EAAEC,gBAAgB,QAAQ,4BAA0B;AASjF,SAASC,MAAM,EAAEC,OAAO,QAAQ,4BAA0B;AAC1D,SAASC,MAAM,QAAQ,2BAAyB;AAChD,SAASC,IAAI,QAAQ,0BAAwB;AAC7C,SAASC,gBAAgB,QAAQ,qCAAmC;AACpE,SAASC,cAAc,QAAQ,0CAAwC;AACvE,SAASC,WAAW,QAAQ,uCAAqC;AACjE,SAASC,GAAG,QAAQ,sBAAoB;AACxC,SAASC,WAAW,QAAQ,iCAA+B;AAC3D,SAASC,oBAAoB,QAAQ,2BAAyB;AAC9D,SAASC,oBAAoB,QAAQ,yCAAuC;AAI5E,SAASC,QAAQ,QAAQ,8BAA4B;AAErD,SAASC,KAAK,QAAQ,qBAAmB;AAmGzC;;;AAGA,OAAM,MAAOC,+BAAgC,SAAQJ,oBAAoB;EA2HrE;;;;;EAKAK,YAAYC,iBAAsC,EAAmBC,QAAiD;IAClH,KAAK,CAACD,iBAAiB,CAAC;IADyC,aAAQ,GAARC,QAAQ;IA7HrE,sBAAiB,GAAIC,YAA8B,IAAI;MAC3D,IAAI,IAAI,CAACC,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC,EAAE;QAC1C;QACA;;MAGJ,MAAM;QAAEC,YAAY;QAAEC;MAAa,CAAE,GAAG,IAAI,CAACC,oBAAoB,CAACL,YAAY,CAACM,OAAO,CAAC;MAEvF;MACA,IAAI,CAACL,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC,GAAG;QACvCF,YAAY;QACZG,YAAY;QACZC,aAAa;QACbG,gBAAgB,EAAE,IAAI;QACtBC,IAAI,EAAE,IAAI;QACVC,MAAM,EAAE,IAAInB,GAAG,CAAC,IAAIN,OAAO,EAAE,EAAE,IAAIA,OAAO,EAAE,CAAC;QAC7C0B,yBAAyB,EAAE,KAAK;QAChCC,EAAE,EAAEf,+BAA+B,CAACgB,UAAU;OACjD;MAED,IAAI,IAAI,CAACC,mBAAmB,EAAE;QAC1B,IACI,CAAC,IAAI,CAACd,QAAQ,CAACe,sCAAsC,IACrD,IAAI,CAACf,QAAQ,CAACgB,mBAAmB,IACjCf,YAAY,CAACgB,WAAW,CAACC,UAAU,KAAK,IAAI,CAAClB,QAAQ,CAACgB,mBAAmB,EAC3E;UACE,IAAI,CAACF,mBAAmB,GAAGb,YAAY,CAACE,QAAQ;;OAEvD,MAAM;QACH,IAAI,CAAC,IAAI,CAACH,QAAQ,CAACe,sCAAsC,EAAE;UACvD,IAAI,CAACD,mBAAmB,GAAGb,YAAY,CAACE,QAAQ;;;MAIxD,QAAQF,YAAY,CAACgB,WAAW,CAACE,aAAa;QAC1C,KAAK,iBAAiB;UAClB,OAAO,IAAI,CAACC,4BAA4B,CAACnB,YAAY,CAAC;QAC1D,KAAK,MAAM;UACP,OAAO,IAAI,CAACoB,eAAe,CAACpB,YAAY,CAAC;QAC7C,KAAK,QAAQ;UACT,OAAO,IAAI,CAACqB,oBAAoB,CAACrB,YAAY,CAAC;MAAC;IAE3D,CAAC;IAEO,iBAAY,GAoBhB,EAAE;IAEE,6BAAwB,GAAG,IAAIhB,OAAO,EAAE;IAehD;;;IAGO,2BAAsB,GAAY,IAAI;IAC7C;;;IAGO,iCAA4B,GAAY,IAAI;IACnD;;;IAGO,wBAAmB,GAAY,IAAI;IAC1C;;;IAGO,yBAAoB,GAAY,IAAI;IAC3C;;;IAGO,4BAAuB,GAAW,IAAIC,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAClE;;;IAGO,6BAAwB,GAAW,IAAIA,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IACnE;;;IAGO,8BAAyB,GAAW,IAAIA,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IACpE;;;IAGO,6BAAwB,GAAW,IAAIA,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAwI3D,oBAAe,GAAGF,MAAM,CAACuC,QAAQ,EAAE;IACnC,0BAAqB,GAAGtC,OAAO,CAACuC,IAAI,EAAE;IACtC,iBAAY,GAAG,IAAI7B,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IA3H3C,IAAI,CAAC8B,MAAM,GAAG,IAAI,CAAC1B,iBAAiB,CAAC2B,KAAK;EAC9C;EAEA;;;;;;EAMOC,MAAM;IACT,IAAI,CAAC,KAAK,CAACA,MAAM,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhB,IAAI,CAAC3B,QAAQ,CAAC4B,OAAO,CAACC,WAAW,CAACC,OAAO,CAAC,IAAI,CAACC,iBAAiB,CAAC;IACjE,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAAChC,QAAQ,CAAC4B,OAAO,CAACK,2BAA2B,EAAE,IAAI,CAACF,iBAAiB,CAAC;IACrG,IAAI,CAACC,qBAAqB,CAAC,IAAI,CAAChC,QAAQ,CAAC4B,OAAO,CAACM,6BAA6B,EAAGC,UAAU,IAAI;MAC3F;MACA,IAAI,CAACC,iBAAiB,CAACD,UAAU,CAAChC,QAAQ,CAAC;IAC/C,CAAC,CAAC;IAEF,IAAI,CAACsB,MAAM,CAACY,gCAAgC,GAAG,IAAI;IAEnD,IAAI,IAAI,CAACrC,QAAQ,CAACsC,UAAU,EAAE;MAC1B,MAAMC,WAAW,GAAG,IAAI,CAACvC,QAAQ,CAACsC,UAAU;MAE5C,MAAM;QAAElC,YAAY;QAAEC;MAAa,CAAE,GAAG,IAAI,CAACC,oBAAoB,CAACiC,WAAW,CAAC;MAE9E,IAAI,CAACrC,YAAY,CAAC,QAAQ,CAAC,GAAG;QAC1BqC,WAAW;QACXnC,YAAY;QACZC,aAAa;QACbG,gBAAgB,EAAE,IAAI;QACtBC,IAAI,EAAE,IAAI;QACVC,MAAM,EAAE,IAAInB,GAAG,CAAC,IAAIN,OAAO,EAAE,EAAE,IAAIA,OAAO,EAAE,CAAC;QAC7C0B,yBAAyB,EAAE,KAAK;QAChCC,EAAE,EAAEf,+BAA+B,CAACgB,UAAU;OACjD;MACD,IAAI,CAACQ,eAAe,EAAE;;IAG1B,OAAO,IAAI;EACf;EAEA;;;;;;EAMOmB,MAAM;IACT,IAAI,CAAC,KAAK,CAACA,MAAM,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhBC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxC,YAAY,CAAC,CAAC4B,OAAO,CAAEa,YAAY,IAAI;MACpD,IAAI,CAACP,iBAAiB,CAACO,YAAY,CAAC;IACxC,CAAC,CAAC;IAEF,OAAO,IAAI;EACf;EAEA;;;;;;EAMOC,mBAAmB,CAACD,YAAoB;IAC3C,IAAI,IAAI,CAACzC,YAAY,CAACyC,YAAY,CAAC,EAAE;MACjC,OAAO,IAAI,CAACzC,YAAY,CAACyC,YAAY,CAAC,CAACnC,gBAAgB;KAC1D,MAAM;MACH,OAAO,IAAI;;EAEnB;EAEA;;;;;;EAMOqC,0BAA0B,CAACjC,EAAU;IACxC,MAAM8B,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxC,YAAY,CAAC;IAE3C,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;MAClC,IAAI,IAAI,CAAC5C,YAAY,CAACwC,IAAI,CAACI,CAAC,CAAC,CAAC,CAAClC,EAAE,KAAKA,EAAE,EAAE;QACtC,OAAO,IAAI,CAACV,YAAY,CAACwC,IAAI,CAACI,CAAC,CAAC,CAAC,CAAC7C,YAAY,IAAI,IAAI;;;IAG9D,OAAO,IAAI;EACf;EAEA;;;EAGO+C,uCAAuC,CAACpC,EAAU;IACrD,MAAM8B,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxC,YAAY,CAAC;IAE3C,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;MAClC,IAAI,IAAI,CAAC5C,YAAY,CAACwC,IAAI,CAACI,CAAC,CAAC,CAAC,CAAClC,EAAE,KAAKA,EAAE,EAAE;QACtC,OAAO,IAAI,CAACV,YAAY,CAACwC,IAAI,CAACI,CAAC,CAAC,CAAC,CAACnC,yBAAyB;;;IAGnE,OAAO,IAAI;EACf;EAEA;;;EAGOsC,uCAAuC,CAACrC,EAAU,EAAEsC,KAAc;IACrE,MAAMR,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxC,YAAY,CAAC;IAE3C,KAAK,IAAI4C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;MAClC,IAAI,IAAI,CAAC5C,YAAY,CAACwC,IAAI,CAACI,CAAC,CAAC,CAAC,CAAClC,EAAE,KAAKA,EAAE,EAAE;QACtC,IAAI,CAACV,YAAY,CAACwC,IAAI,CAACI,CAAC,CAAC,CAAC,CAACnC,yBAAyB,GAAGuC,KAAK;QAC5D;;;EAGZ;EAMUC,UAAU,CAACC,QAAiB;IAClCX,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxC,YAAY,CAAC,CAAC4B,OAAO,CAAElB,EAAE,IAAI;MAC1C;MACA,MAAMyC,cAAc,GAAG,IAAI,CAACnD,YAAY,CAACU,EAAE,CAAC;MAC5C,IAAK,CAAC,IAAI,CAACZ,QAAQ,CAACe,sCAAsC,IAAIH,EAAE,KAAK,IAAI,CAACE,mBAAmB,IAAKuC,cAAc,CAAC1C,yBAAyB,EAAE;QACxI0C,cAAc,CAAChD,aAAa,CAACiD,SAAS,GAAG,KAAK;QAC9CD,cAAc,CAACjD,YAAY,CAACkD,SAAS,GAAG,KAAK;QAC7CD,cAAc,CAAC5C,IAAI,GAAG,IAAI;QAC1B;;MAGJ4C,cAAc,CAACjD,YAAY,CAACkD,SAAS,GAAG,IAAI,CAACC,mBAAmB;MAEhE,IAAIC,wBAAiC;MAErC;MACA,IAAIH,cAAc,CAACpD,YAAY,EAAE;QAC7BuD,wBAAwB,GAAGH,cAAc,CAACpD,YAAY,CAACM,OAAO,CAACkD,QAAQ;QACvEJ,cAAc,CAACpD,YAAY,CAACyD,uBAAuB,CAACL,cAAc,CAAC3C,MAAM,CAAC;OAC7E,MAAM,IAAI2C,cAAc,CAACd,WAAW,EAAE;QACnCiB,wBAAwB,GAAGH,cAAc,CAACd,WAAW,CAACkB,QAAQ;QAC9DJ,cAAc,CAACd,WAAW,CAACoB,kBAAkB,CAACN,cAAc,CAAC3C,MAAM,CAAC;OACvE,MAAM;QACH;;MAGJ,IAAI,IAAI,CAACV,QAAQ,CAAC4D,kBAAkB,EAAE;QAClCP,cAAc,CAAC3C,MAAM,CAACqC,MAAM,GAAG,IAAI,CAAC/C,QAAQ,CAAC4D,kBAAkB;;MAEnE;MACA,IAAI,CAAC,IAAI,CAAC5D,QAAQ,CAAC6D,+BAA+B,IAAIL,wBAAwB,EAAE;QAC5E,MAAM9B,KAAK,GAAG,IAAI,CAAC3B,iBAAiB,CAAC2B,KAAK;QAC1C,MAAMoC,MAAM,GAAG,IAAI,CAAC9D,QAAQ,CAAC4B,OAAO,CAACmC,QAAQ;QAC7C,IAAID,MAAM,EAAE;UACRA,MAAM,CAACE,QAAQ,CAACC,aAAa,CAACvC,KAAK,CAACwC,SAAS,EAAE,CAACC,cAAc,EAAE,EAAEzC,KAAK,CAACwC,SAAS,EAAE,CAACE,eAAe,EAAE,EAAE,IAAI,CAACC,YAAY,CAAC;UACzHpF,OAAO,CAACqF,YAAY,CAACd,wBAAwB,EAAE,IAAI,CAACe,eAAe,EAAE7C,KAAK,CAAC8C,kBAAkB,EAAE,EAAE,IAAI,CAACH,YAAY,EAAE,IAAI,CAACI,qBAAqB,CAAC;UAC/I;UACA,IACI,OAAO,IAAI,CAACA,qBAAqB,CAACC,CAAC,KAAK,QAAQ,IAChD,OAAO,IAAI,CAACD,qBAAqB,CAACE,CAAC,KAAK,QAAQ,IAChD,CAACC,KAAK,CAAC,IAAI,CAACH,qBAAqB,CAACC,CAAC,CAAC,IACpC,CAACE,KAAK,CAAC,IAAI,CAACH,qBAAqB,CAACE,CAAC,CAAC,EACtC;YACEjD,KAAK,CAACmD,QAAQ,GAAG,IAAI,CAACJ,qBAAqB,CAACC,CAAC;YAC7ChD,KAAK,CAACoD,QAAQ,GAAG,IAAI,CAACL,qBAAqB,CAACE,CAAC;YAE7CtB,cAAc,CAAC0B,iBAAiB,GAAG;cAC/BL,CAAC,EAAE,IAAI,CAACD,qBAAqB,CAACC,CAAC;cAC/BC,CAAC,EAAE,IAAI,CAACF,qBAAqB,CAACE;aACjC;;;;MAKb,IAAIK,gBAAgB,GAAG,IAAI;MAC3B,IAAI,IAAI,CAACC,kBAAkB,EAAE;QACzBD,gBAAgB,GAAG,IAAI,CAACC,kBAAkB,CAACC,WAAW,CAAC7B,cAAc,CAAC3C,MAAM,EAAE,IAAI,CAACuE,kBAAkB,CAACE,oBAAoB,IAAI,IAAI,CAACC,qBAAqB,CAAC;;MAG7J,MAAMC,iBAAiB,GAAG,IAAI,CAAC5D,MAAM,CAACyD,WAAW,CAAC7B,cAAc,CAAC3C,MAAM,EAAE,IAAI,CAACe,MAAM,CAAC0D,oBAAoB,IAAI,IAAI,CAACC,qBAAqB,CAAC;MACxI,IAAI,CAACJ,gBAAgB,IAAI,CAACA,gBAAgB,CAACM,GAAG,EAAE;QAC5C;QACAjC,cAAc,CAAC5C,IAAI,GAAG4E,iBAAiB;OAC1C,MAAM,IAAI,CAACA,iBAAiB,IAAI,CAACA,iBAAiB,CAACC,GAAG,EAAE;QACrD;QACAjC,cAAc,CAAC5C,IAAI,GAAGuE,gBAAgB;OACzC,MAAM,IAAIA,gBAAgB,CAACO,QAAQ,GAAGF,iBAAiB,CAACE,QAAQ,EAAE;QAC/D;QACAlC,cAAc,CAAC5C,IAAI,GAAGuE,gBAAgB;OACzC,MAAM;QACH;QACA3B,cAAc,CAAC5C,IAAI,GAAG4E,iBAAiB;;MAG3C,IAAIhC,cAAc,CAAC5C,IAAI,IAAI4C,cAAc,CAACpD,YAAY,EAAE;QACpDoD,cAAc,CAAC5C,IAAI,CAAC+E,YAAY,GAAGnC,cAAc,CAACpD,YAAY,CAACM,OAAO;QACtE8C,cAAc,CAAC5C,IAAI,CAACgF,aAAa,GAAGpC,cAAc,CAACpD,YAAY,CAACyF,IAAI,IAAI,IAAI;;MAGhF,MAAMjF,IAAI,GAAG4C,cAAc,CAAC5C,IAAI;MAEhC,IAAIA,IAAI,IAAIA,IAAI,CAACkF,WAAW,IAAIlF,IAAI,CAAC6E,GAAG,EAAE;QACtC;QACA,IAAI,CAACM,sBAAsB,CAACvC,cAAc,CAACjD,YAAY,EAAEK,IAAI,CAAC8E,QAAQ,CAAC;QAEvE;QACAlC,cAAc,CAAChD,aAAa,CAACoD,QAAQ,CAACoC,QAAQ,CAACpF,IAAI,CAACkF,WAAW,CAAC;QAChEtC,cAAc,CAAChD,aAAa,CAACyF,OAAO,CAACpB,CAAC,GAAGqB,IAAI,CAACC,IAAI,CAACvF,IAAI,CAAC8E,QAAQ,CAAC;QACjElC,cAAc,CAAChD,aAAa,CAACyF,OAAO,CAACnB,CAAC,GAAGoB,IAAI,CAACC,IAAI,CAACvF,IAAI,CAAC8E,QAAQ,CAAC;QACjElC,cAAc,CAAChD,aAAa,CAACyF,OAAO,CAACG,CAAC,GAAGF,IAAI,CAACC,IAAI,CAACvF,IAAI,CAAC8E,QAAQ,CAAC;QAEjE;QACA,MAAMW,UAAU,GAAG,IAAI,CAACC,8BAA8B,CAAC1F,IAAI,CAAC2F,SAAS,CAAC,IAAI,CAAC,EAAE/C,cAAc,CAAC3C,MAAM,CAAC;QACnG,MAAM2F,aAAa,GAAG,KAAK;QAC3BhD,cAAc,CAAChD,aAAa,CAACoD,QAAQ,CAACoC,QAAQ,CAACpF,IAAI,CAACkF,WAAW,CAAC;QAChE,IAAIO,UAAU,EAAE;UACZ,MAAMI,KAAK,GAAGrH,OAAO,CAACsH,KAAK,CAACpH,IAAI,CAACqH,CAAC,EAAEN,UAAU,CAAC;UAC/C,MAAMO,KAAK,GAAGxH,OAAO,CAACsH,KAAK,CAACL,UAAU,EAAEI,KAAK,CAAC;UAC9CrH,OAAO,CAACyH,qBAAqB,CAACD,KAAK,EAAEP,UAAU,EAAEI,KAAK,EAAEjD,cAAc,CAAChD,aAAa,CAACsG,QAAQ,CAAC;UAC9FtD,cAAc,CAAChD,aAAa,CAACoD,QAAQ,CAACmD,UAAU,CAACV,UAAU,CAACW,KAAK,CAACR,aAAa,CAAC,CAAC;;QAErFhD,cAAc,CAAChD,aAAa,CAACiD,SAAS,GAAG,IAAI,IAAI,IAAI,CAACwD,oBAAoB;QAC1EzD,cAAc,CAAC7C,gBAAgB,GAAGC,IAAI,CAACsG,UAAU;OACpD,MAAM;QACH1D,cAAc,CAAChD,aAAa,CAACiD,SAAS,GAAG,KAAK;QAC9C,IAAI,CAACsC,sBAAsB,CAACvC,cAAc,CAACjD,YAAY,EAAE,CAAC,CAAC;QAC3DiD,cAAc,CAAC7C,gBAAgB,GAAG,IAAI;;IAE9C,CAAC,CAAC;EACN;EAEA,IAAYyE,kBAAkB;IAC1B,OAAO,IAAI,CAACjF,QAAQ,CAACgH,uBAAuB,IAAItH,oBAAoB,CAACuH,mBAAmB,CAACC,iBAAiB;EAC9G;EAEQ7F,eAAe,CAACpB,YAA+B;IACnD,MAAMoD,cAAc,GAAG,IAAI,CAACnD,YAAY,CAAED,YAAY,IAAIA,YAAY,CAACE,QAAQ,IAAK,QAAQ,CAAC;IAC7F;IACA,MAAMgH,YAAY,GAAG,IAAI,CAACnH,QAAQ,CAACmH,YAAY,IAAI,IAAI;IACvD,MAAMC,eAAe,GAAG,IAAI,CAACpH,QAAQ,CAACqH,eAAe,GAAG,IAAI,CAACpC,kBAAkB,GAAG,IAAI,CAACxD,MAAM;IAC7F,IAAI6F,OAAO,GAAG,IAAI9H,WAAW,EAAE;IAC/B,MAAM+H,QAAQ,GAAGjI,WAAW,CACxB,WAAW,EACX;MACIkI,QAAQ,EAAE,MAAM,GAAG,EAAE;MACrBC,SAAS,EAAE,MAAM,GAAG,CAAC;MACrBC,YAAY,EAAE;KACjB,EACDN,eAAe,CAClB;IACDG,QAAQ,CAACjE,SAAS,GAAG,KAAK;IAC1BiE,QAAQ,CAACI,UAAU,GAAG,KAAK;IAC3BJ,QAAQ,CAACK,MAAM,GAAGvE,cAAc,CAAChD,aAAa;IAC9C,IAAIwH,KAAK,GAAG,CAAC;IACb,IAAIC,aAAa,GAAG,KAAK;IACzB,MAAMC,gBAAgB,GAAqB;MACvCC,SAAS,EAAE3E,cAAc,CAACzC,EAAE;MAC5BqH,WAAW,EAAE;KAChB;IACD5E,cAAc,CAAC6E,eAAe,GAAG,IAAI,CAACnI,iBAAiB,CAACoI,mBAAmB,CAACC,GAAG,CAAC,MAAK;MACjF,IAAI,CAAC/E,cAAc,CAAC5C,IAAI,EAAE;QACtB;;MAEJ,IAAI,CAAC4H,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;MAC/F1B,cAAc,CAACjD,YAAY,CAACkI,QAAS,CAACC,KAAK,GAAG,CAAC;MAC/ChB,QAAQ,CAACjE,SAAS,GAAG,KAAK;MAC1B,IAAID,cAAc,CAAC5C,IAAI,CAAC6E,GAAG,EAAE;QACzB,IAAI,CAAC,IAAI,CAACkD,aAAa,CAAClB,OAAO,EAAEjE,cAAc,CAAC5C,IAAI,CAAC,EAAE;UACnD,IAAIoH,KAAK,GAAGV,YAAY,GAAG,EAAE,EAAE;YAC3BI,QAAQ,CAACjE,SAAS,GAAG,IAAI;;UAG7BuE,KAAK,IAAI,IAAI,CAACpG,MAAM,CAACyC,SAAS,EAAE,CAACuE,YAAY,EAAE;UAC/C,IAAIZ,KAAK,IAAIV,YAAY,EAAE;YACvB,IAAI,CAAC1F,MAAM,CAACiH,mBAAmB,CAACrF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;YACtE;YACAD,aAAa,GAAG,IAAI;YACpB;YACA,IAAI,IAAI,CAAC9H,QAAQ,CAAC2I,0BAA0B,EAAE;cAC1C,IAAI,CAAClH,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;;YAExER,QAAQ,CAACjE,SAAS,GAAG,KAAK;WAC7B,MAAM;YACH,MAAMuF,WAAW,GAAG,CAAC,GAAGhB,KAAK,GAAGV,YAAY;YAC5CI,QAAQ,CAACzB,OAAO,CAACgD,GAAG,CAACD,WAAW,EAAEA,WAAW,EAAEA,WAAW,CAAC;;SAElE,MAAM;UACH,IAAIf,aAAa,EAAE;YACf,IAAI,CAAC,IAAI,CAAC9H,QAAQ,CAAC2I,0BAA0B,EAAE;cAC3C,IAAI,CAAClH,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;;;UAG5ED,aAAa,GAAG,KAAK;UACrBD,KAAK,GAAG,CAAC;;OAEhB,MAAM;QACHC,aAAa,GAAG,KAAK;QACrBD,KAAK,GAAG,CAAC;;MAGb,IAAI,CAACpG,MAAM,CAACsH,mBAAmB,CAAC1F,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;MAEtET,OAAO,GAAGjE,cAAc,CAAC5C,IAAI;IACjC,CAAC,CAAC;IAEF,IAAI,IAAI,CAACT,QAAQ,CAACgJ,gBAAgB,KAAKC,SAAS,EAAE;MAC9C1B,QAAQ,CAACyB,gBAAgB,GAAG,IAAI,CAAChJ,QAAQ,CAACgJ,gBAAgB;;IAE9D,IAAI/I,YAAY,EAAE;MACdA,YAAY,CAACiJ,mBAAmB,CAACC,OAAO,CAAC,MAAK;QAC1C,IAAI9F,cAAc,CAAC5C,IAAI,IAAI,CAAC,IAAI,CAACT,QAAQ,CAAC2I,0BAA0B,IAAIb,aAAa,EAAE;UACnF,IAAI,CAACrG,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;UACpE1E,cAAc,CAAC+F,uBAAuB,GAAG,IAAI;;QAEjD7B,QAAQ,CAAC8B,OAAO,EAAE;MACtB,CAAC,CAAC;;EAEV;EAEQ/H,oBAAoB,CAACrB,YAA8B;IACvD,MAAMoD,cAAc,GAAG,IAAI,CAACnD,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC;IAC/D,IAAI2H,aAAa,GAAG,KAAK;IACzB,MAAMC,gBAAgB,GAAqB;MACvCC,SAAS,EAAE3E,cAAc,CAACzC,EAAE;MAC5BqH,WAAW,EAAE;KAChB;IACD5E,cAAc,CAAC6E,eAAe,GAAG,IAAI,CAACnI,iBAAiB,CAACoI,mBAAmB,CAACC,GAAG,CAAC,MAAK;MACjF,IAAI,CAACC,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;MAC/F,IAAI,CAAC1B,cAAc,CAAC5C,IAAI,IAAK,IAAI,CAACT,QAAQ,CAAC2I,0BAA0B,IAAIb,aAAc,EAAE;QACrF;;MAEJ,IAAI,CAACA,aAAa,EAAE;QAChB,IAAI,CAACrG,MAAM,CAACiH,mBAAmB,CAACrF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;QACtE1E,cAAc,CAACiG,oBAAoB,GAAG,IAAI;QAC1CxB,aAAa,GAAG,IAAI;QACpB,IAAI,IAAI,CAAC9H,QAAQ,CAAC2I,0BAA0B,EAAE;UAC1C,IAAI,CAAClH,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;;OAE3E,MAAM;QACH,IAAI,CAACtG,MAAM,CAACsH,mBAAmB,CAAC1F,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;;IAE9E,CAAC,CAAC;IACF9H,YAAY,CAACiJ,mBAAmB,CAACC,OAAO,CAAC,MAAK;MAC1C,IAAI,CAACd,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;MAC/F,IAAI,CAAChF,iBAAiB,CAACwJ,YAAY,CAAC,MAAK;QACrC,IAAIlG,cAAc,CAAC5C,IAAI,IAAI,CAAC4C,cAAc,CAAC+F,uBAAuB,IAAItB,aAAa,IAAI,CAAC,IAAI,CAAC9H,QAAQ,CAAC2I,0BAA0B,EAAE;UAC9H,IAAI,CAAClH,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;UACpE1E,cAAc,CAAC+F,uBAAuB,GAAG,IAAI;;MAErD,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEQhI,4BAA4B,CAACnB,YAA8B;IAC/D,MAAMoD,cAAc,GAAG,IAAI,CAACnD,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC;IAC/D,IAAI,IAAI,CAACH,QAAQ,CAACwJ,aAAa,EAAE;MAC7B,OAAO,IAAI,CAACnI,eAAe,CAACpB,YAAY,CAAC;;IAE7C,MAAM8H,gBAAgB,GAAqB;MACvCC,SAAS,EAAE3E,cAAc,CAACzC,EAAE;MAC5BqH,WAAW,EAAE;KAChB;IACD5E,cAAc,CAAC6E,eAAe,GAAG,IAAI,CAACnI,iBAAiB,CAACoI,mBAAmB,CAACC,GAAG,CAAC,MAAK;MAC9D/E,cAAc,CAACjD,YAAY,CAACkI,QAAS,CAACmB,eAAe,GAAG,IAAI,CAACC,sBAAsB;MACnFrG,cAAc,CAAChD,aAAa,CAACiI,QAAS,CAACmB,eAAe,GAAG,IAAI,CAACE,4BAA4B;MAE7G,IAAItG,cAAc,CAAC5C,IAAI,EAAE;QACrB,IAAI,CAAC4H,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;QAC/F,IAAI,CAACtD,MAAM,CAACsH,mBAAmB,CAAC1F,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;;IAE9E,CAAC,CAAC;IACF,IAAI9H,YAAY,CAACgB,WAAW,CAAC2I,OAAO,EAAE;MAClC,MAAMC,IAAI,GAAIC,gBAA+C,IAAI;QAC7D,IAAI,IAAI,CAAC9J,QAAQ,CAAC+J,gBAAgB,EAAE;UAChC1G,cAAc,CAAC2G,kBAAkB,GAAGF,gBAAgB,CAACG,YAAY,CAAC,IAAI,CAACjK,QAAQ,CAAC+J,gBAAgB,CAAC;;QAErG,IAAI,CAAC1G,cAAc,CAAC2G,kBAAkB,EAAE;UACpC3G,cAAc,CAAC2G,kBAAkB,GAAGF,gBAAgB,CAACI,gBAAgB,EAAE;;QAG3E7G,cAAc,CAAC8G,uBAAuB,GAAG9G,cAAc,CAAC2G,kBAAkB,CAACI,8BAA8B,CAAChC,GAAG,CAAEiC,SAAS,IAAI;UACxH,IAAIA,SAAS,CAACC,OAAO,CAACC,OAAO,EAAE;YAC3B,MAAMA,OAAO,GAAGF,SAAS,CAACC,OAAO,CAACC,OAAO,CAACC,OAAO;YACjD,IAAInH,cAAc,CAAC5C,IAAI,EAAE;cACrB,IAAI,IAAI,CAACT,QAAQ,CAACe,sCAAsC,IAAId,YAAY,CAACE,QAAQ,KAAK,IAAI,CAACW,mBAAmB,EAAE;gBAC5G,IAAI,CAACuH,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;gBAC/F,IAAIwF,OAAO,EAAE;kBACT,IAAI,CAAC9I,MAAM,CAACiH,mBAAmB,CAACrF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;kBACtE1E,cAAc,CAACiG,oBAAoB,GAAG,IAAI;kBACvBjG,cAAc,CAAChD,aAAa,CAACiI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACC,wBAAwB;kBACpFrH,cAAc,CAACjD,YAAY,CAACkI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACE,uBAAuB;iBACxG,MAAM;kBACH,IAAI,CAAClJ,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;kBACjD1E,cAAc,CAAChD,aAAa,CAACiI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACG,yBAAyB;kBACrFvH,cAAc,CAACjD,YAAY,CAACkI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACI,wBAAwB;;;aAGjH,MAAM;cACH,IAAIN,OAAO,IAAI,CAAC,IAAI,CAACvK,QAAQ,CAACe,sCAAsC,IAAI,CAAC,IAAI,CAACf,QAAQ,CAAC8K,oBAAoB,EAAE;gBACzG,IAAI,CAAChK,mBAAmB,GAAGb,YAAY,CAACE,QAAQ;;;;QAIhE,CAAC,CAAC;MACN,CAAC;MACD,IAAIF,YAAY,CAAC6J,gBAAgB,EAAE;QAC/BD,IAAI,CAAC5J,YAAY,CAAC6J,gBAAgB,CAAC;OACtC,MAAM;QACH7J,YAAY,CAAC8K,gCAAgC,CAAC3C,GAAG,CAACyB,IAAI,CAAC;;KAE9D,MAAM;MACH;MACA,MAAMmB,mBAAmB,GAAIC,KAAyB,IAAI;QACtD,IAAI,CAAC5C,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;QAC/F,IAAI1B,cAAc,CAACpD,YAAY,IAAIgL,KAAK,CAAChK,WAAW,KAAKoC,cAAc,CAACpD,YAAY,CAACgB,WAAW,IAAIoC,cAAc,CAAC5C,IAAI,EAAE;UACrH,IAAI,CAACgB,MAAM,CAACiH,mBAAmB,CAACrF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;UACtE1E,cAAc,CAACiG,oBAAoB,GAAG,IAAI;UACvBjG,cAAc,CAAChD,aAAa,CAACiI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACC,wBAAwB;UACpFrH,cAAc,CAACjD,YAAY,CAACkI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACE,uBAAuB;;MAE7G,CAAC;MAED,MAAMO,iBAAiB,GAAID,KAAyB,IAAI;QACpD,IAAI,CAAC5C,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;QAC/F,IAAI1B,cAAc,CAACpD,YAAY,IAAIgL,KAAK,CAAChK,WAAW,KAAKoC,cAAc,CAACpD,YAAY,CAACgB,WAAW,IAAIoC,cAAc,CAAC5C,IAAI,EAAE;UACrH,IAAI,CAACgB,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,EAAEsH,gBAAgB,CAAC;UACjD1E,cAAc,CAAChD,aAAa,CAACiI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACG,yBAAyB;UACrFvH,cAAc,CAACjD,YAAY,CAACkI,QAAS,CAACmC,aAAa,GAAG,IAAI,CAACI,wBAAwB;;MAE9G,CAAC;MAEDxH,cAAc,CAAC8H,cAAc,GAAG;QAC5BC,SAAS,EAAEF,iBAAiB;QAC5BG,WAAW,EAAEL;OAChB;MAED,IAAI,CAACjL,iBAAiB,CAACuL,OAAO,CAACC,gBAAgB,CAAC,aAAa,EAAEP,mBAAmB,CAAC;MACnF,IAAI,CAACjL,iBAAiB,CAACuL,OAAO,CAACC,gBAAgB,CAAC,WAAW,EAAEL,iBAAiB,CAAC;;EAEvF;EAEQ/E,8BAA8B,CAACqF,MAAyB,EAAEC,GAAQ;IACtE,IAAID,MAAM,EAAE;MACR,MAAME,KAAK,GAAG3F,IAAI,CAAC4F,IAAI,CAAC1M,OAAO,CAAC2M,GAAG,CAACJ,MAAM,EAAEC,GAAG,CAACI,SAAS,CAAC,CAAC;MAC3D,IAAIH,KAAK,GAAG3F,IAAI,CAAC+F,EAAE,GAAG,CAAC,EAAE;QACrBN,MAAM,CAACO,YAAY,CAAC,CAAC,CAAC,CAAC;;;IAG/B,OAAOP,MAAM;EACjB;EAEQpJ,iBAAiB,CAAC4J,oBAA4B;IAClD,MAAM3I,cAAc,GAAG,IAAI,CAACnD,YAAY,CAAC8L,oBAAoB,CAAC;IAC9D,IAAI,CAAC3I,cAAc,EAAE;MACjB;;IAEJ,IAAIA,cAAc,CAAC2G,kBAAkB,EAAE;MACnC,IAAI3G,cAAc,CAAC8G,uBAAuB,EAAE;QACxC9G,cAAc,CAAC2G,kBAAkB,CAACI,8BAA8B,CAAC6B,MAAM,CAAC5I,cAAc,CAAC8G,uBAAuB,CAAC;;;IAGvH,IAAI9G,cAAc,CAAC6E,eAAe,EAAE;MAChC,IAAI,CAACnI,iBAAiB,CAACoI,mBAAmB,CAAC8D,MAAM,CAAC5I,cAAc,CAAC6E,eAAe,CAAC;;IAErF,IAAI7E,cAAc,CAAC8H,cAAc,EAAE;MAC/B1I,MAAM,CAACC,IAAI,CAACW,cAAc,CAAC8H,cAAc,CAAC,CAACrJ,OAAO,CAAEoK,SAAiB,IAAI;QACrE,MAAMC,IAAI,GAAG9I,cAAc,CAAC8H,cAAc,IAAI9H,cAAc,CAAC8H,cAAc,CAACe,SAAwB,CAAC;QACrG,IAAIC,IAAI,EAAE;UACN;UACA,IAAI,CAACpM,iBAAiB,CAACuL,OAAO,CAACc,mBAAmB,CAACF,SAAwB,EAAEC,IAAW,CAAC;;MAEjG,CAAC,CAAC;;IAGN,IAAI,CAAC9I,cAAc,CAAC+F,uBAAuB,IAAI/F,cAAc,CAACiG,oBAAoB,EAAE;MAChF;MACA,MAAMvB,gBAAgB,GAAqB;QACvCC,SAAS,EAAE3E,cAAc,CAACzC,EAAE;QAC5BqH,WAAW,EAAE;OAChB;MACD,IAAI,CAAClI,iBAAiB,CAACwJ,YAAY,CAAC,MAAK;QACrC,IAAI,CAAClB,mBAAmB,CAACN,gBAAgB,EAAE1E,cAAc,CAACzC,EAAE,EAAEyC,cAAc,CAAC0B,iBAAiB,CAAC;QAC/F,IAAI,CAACtD,MAAM,CAACmH,iBAAiB,CAACvF,cAAc,CAAC5C,IAAI,IAAI,IAAIjB,WAAW,EAAE,EAAEuI,gBAAgB,CAAC;QACzF1E,cAAc,CAAC+F,uBAAuB,GAAG,IAAI;MACjD,CAAC,CAAC;;IAEN,IAAI,CAACrJ,iBAAiB,CAAC2B,KAAK,CAAC2K,wBAAwB,CAAClD,OAAO,CAAC,MAAK;MAC/D,IAAI;QACA9F,cAAc,CAAChD,aAAa,CAACgJ,OAAO,EAAE;QACtChG,cAAc,CAACjD,YAAY,CAACiJ,OAAO,EAAE;QACrC;QACA,OAAO,IAAI,CAACnJ,YAAY,CAAC8L,oBAAoB,CAAC;QAC9C,IAAI,IAAI,CAAClL,mBAAmB,KAAKkL,oBAAoB,EAAE;UACnD;UACA,MAAMtJ,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxC,YAAY,CAAC;UAC3C,IAAIwC,IAAI,CAACK,MAAM,EAAE;YACb,IAAI,CAACjC,mBAAmB,GAAG4B,IAAI,CAAC,CAAC,CAAC;WACrC,MAAM;YACH,IAAI,CAAC5B,mBAAmB,GAAG,EAAE;;;OAGxC,CAAC,OAAOwL,CAAC,EAAE;QACR1M,KAAK,CAAC2M,IAAI,CAAC,8BAA8B,CAAC;;IAElD,CAAC,CAAC;EACN;EAEQjM,oBAAoB,CAACkM,UAAgB;IACzC,MAAMpF,eAAe,GAAG,IAAI,CAACpH,QAAQ,CAACqH,eAAe,GAAG,IAAI,CAACrH,QAAQ,CAACgH,uBAAuB,IAAItH,oBAAoB,CAACuH,mBAAmB,CAACC,iBAAiB,GAAG,IAAI,CAACzF,MAAM;IACzK,MAAMrB,YAAY,GAAG,IAAI,CAACJ,QAAQ,CAACyM,gCAAgC,GAC7D,IAAI,CAACzM,QAAQ,CAACyM,gCAAgC,EAAE,GAChDpN,cAAc,CACV,cAAc,EACd;MACIqN,MAAM,EAAE,CAAC;MACTC,WAAW,EAAE,MAAM;MACnBC,cAAc,EAAE,KAAK;MACrBlF,YAAY,EAAE,EAAE;MAChBmF,YAAY,EAAE;KACjB,EACDzF,eAAe,CAClB;IACPhH,YAAY,CAACwH,MAAM,GAAG4E,UAAU;IAChC,MAAMM,oBAAoB,GAAG,IAAI1N,gBAAgB,CAAC,iBAAiB,EAAEgI,eAAe,CAAC;IACrF0F,oBAAoB,CAACrC,aAAa,GAAG,IAAI,CAACI,wBAAwB;IAClEiC,oBAAoB,CAACvE,KAAK,GAAG,GAAG;IAChCnI,YAAY,CAACkI,QAAQ,GAAGwE,oBAAoB;IAC5C1M,YAAY,CAACuG,QAAQ,CAACjC,CAAC,GAAGqB,IAAI,CAAC+F,EAAE,GAAG,CAAC;IACrC,IAAI,CAAClG,sBAAsB,CAACxF,YAAY,EAAE,CAAC,CAAC;IAC5CA,YAAY,CAACuH,UAAU,GAAG,KAAK;IAC/BvH,YAAY,CAACkD,SAAS,GAAG,KAAK;IAE9B;IACA,MAAMjD,aAAa,GAAG,IAAI,CAACL,QAAQ,CAAC+M,4BAA4B,GAC1D,IAAI,CAAC/M,QAAQ,CAAC+M,4BAA4B,EAAE,GAC5CzN,WAAW,CACP,aAAa,EACb;MACIkI,QAAQ,EAAE,MAAM,GAAG,CAAC;MACpBC,SAAS,EAAE,MAAM,GAAG,CAAC;MACrBC,YAAY,EAAE;KACjB,EACDN,eAAe,CAClB;IACP/G,aAAa,CAAC2M,gCAAgC,EAAE;IAChD3M,aAAa,CAACsH,UAAU,GAAG,KAAK;IAChCtH,aAAa,CAACiD,SAAS,GAAG,KAAK;IAC/B,MAAM2J,SAAS,GAAG,IAAI7N,gBAAgB,CAAC,WAAW,EAAEgI,eAAe,CAAC;IACpE6F,SAAS,CAACC,aAAa,GAAGhO,MAAM,CAACiO,KAAK,EAAE;IACxCF,SAAS,CAACxC,aAAa,GAAG,IAAI,CAACG,yBAAyB;IACxDqC,SAAS,CAACG,eAAe,GAAG,KAAK;IACjC/M,aAAa,CAACiI,QAAQ,GAAG2E,SAAS;IAElC,IAAI,IAAI,CAACjN,QAAQ,CAACgJ,gBAAgB,KAAKC,SAAS,EAAE;MAC9C7I,YAAY,CAAC4I,gBAAgB,GAAG,IAAI,CAAChJ,QAAQ,CAACgJ,gBAAgB;MAC9D3I,aAAa,CAAC2I,gBAAgB,GAAG,IAAI,CAAChJ,QAAQ,CAACgJ,gBAAgB;;IAGnE,OAAO;MACH5I,YAAY;MACZC;KACH;EACL;EAEQmI,aAAa,CAAClB,OAAoB,EAAE+F,OAAoB;;IAC5D,IAAI,CAAC/F,OAAO,CAAChC,GAAG,IAAI,CAAC+H,OAAO,CAAC/H,GAAG,EAAE;MAC9B,OAAO,IAAI;;IAEf,IAAI,CAACgC,OAAO,CAACP,UAAU,IAAI,CAACO,OAAO,CAAC3B,WAAW,IAAI,CAAC0H,OAAO,CAACtG,UAAU,IAAI,CAACsG,OAAO,CAAC1H,WAAW,EAAE;MAC5F,OAAO,IAAI;;IAEf,IAAI2B,OAAO,CAACP,UAAU,KAAKsG,OAAO,CAACtG,UAAU,EAAE;MAC3C,OAAO,IAAI;;IAEf,aAAO,CAACpB,WAAW,0CAAE2H,aAAa,CAACD,OAAO,CAAC1H,WAAW,EAAE,IAAI,CAAC4H,wBAAwB,CAAC;IACtF,IAAI,CAACA,wBAAwB,CAACzE,GAAG,CAAC/C,IAAI,CAACyH,GAAG,CAAC,IAAI,CAACD,wBAAwB,CAAC7I,CAAC,CAAC,EAAEqB,IAAI,CAACyH,GAAG,CAAC,IAAI,CAACD,wBAAwB,CAAC5I,CAAC,CAAC,EAAEoB,IAAI,CAACyH,GAAG,CAAC,IAAI,CAACD,wBAAwB,CAACtH,CAAC,CAAC,CAAC;IAClK,MAAMwH,KAAK,GAAG,CAAC,IAAI,CAACzN,QAAQ,CAAC0N,0BAA0B,IAAI,CAAC,IAAI,IAAI,GAAGL,OAAO,CAAC9H,QAAQ;IACvF,MAAMxC,MAAM,GAAG,IAAI,CAACwK,wBAAwB,CAACxK,MAAM,EAAE;IACrD,IAAIA,MAAM,GAAG0K,KAAK,EAAE;MAChB,OAAO,IAAI;;IAEf,OAAO,KAAK;EAChB;EAEQ7H,sBAAsB,CAAC+H,aAA2B,EAAEpI,WAAmB,GAAG;IAC9EoI,aAAa,CAAC7H,OAAO,CAACnB,CAAC,GAAGY,QAAQ;IAClC;IACA,IAAI,IAAI,CAAC9D,MAAM,CAACmM,oBAAoB,EAAE;MAClCrI,QAAQ,IAAI,CAAC,CAAC;;IAElBoI,aAAa,CAAClK,QAAQ,CAACwC,CAAC,GAAGV,QAAQ,GAAG,CAAC,GAAG,IAAI;EAClD;EAEQ8C,mBAAmB,CAACN,gBAAkC,EAAEnH,EAAU,EAAEmE,iBAA4C;IACpHgD,gBAAgB,CAACC,SAAS,GAAGpH,EAAE;IAC/BmH,gBAAgB,CAACE,WAAW,GAAG,IAAI;IACnC,IAAIlD,iBAAiB,EAAE;MACnBgD,gBAAgB,CAAC8F,OAAO,GAAG9I,iBAAiB,CAACL,CAAC;MAC9CqD,gBAAgB,CAAC+F,OAAO,GAAG/I,iBAAiB,CAACJ,CAAC;;EAEtD;EAEA;EACA,IAAWoJ,yBAAyB;IAChC;IACA,OAAO,IAAI,CAAClD,wBAAwB;EACxC;;AApuBehL,0CAAU,GAAG,GAAG;AAwE/B;;;AAGuBA,oCAAI,GAAGd,gBAAgB,CAACiP,iBAAiB;AAChE;;;;;AAKuBnO,uCAAO,GAAG,CAAC;AAspBtC;AACAf,oBAAoB,CAACmP,eAAe,CAChCpO,+BAA+B,CAACqO,IAAI,EACpC,CAACC,gBAAgB,EAAEC,OAAO,KAAI;EAC1B,OAAO,MAAM,IAAIvO,+BAA+B,CAACsO,gBAAgB,EAAEC,OAAO,CAAC;AAC/E,CAAC,EACDvO,+BAA+B,CAACwO,OAAO,EACvC,IAAI,CACP","names":["WebXRFeaturesManager","WebXRFeatureName","Matrix","Vector3","Color3","Axis","StandardMaterial","CreateCylinder","CreateTorus","Ray","PickingInfo","WebXRAbstractFeature","UtilityLayerRenderer","Viewport","Tools","WebXRControllerPointerSelection","constructor","_xrSessionManager","_options","xrController","_controllers","uniqueId","laserPointer","selectionMesh","_generateNewMeshPair","pointer","meshUnderPointer","pick","tmpRay","disabledByNearInteraction","id","_IdCounter","_attachedController","enablePointerSelectionOnAllControllers","preferredHandedness","inputSource","handedness","targetRayMode","_attachTrackedPointerRayMode","_attachGazeMode","_attachScreenRayMode","Identity","Zero","_scene","scene","attach","xrInput","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","constantlyUpdateMeshUnderPointer","gazeCamera","webXRCamera","detach","Object","keys","controllerId","getMeshUnderPointer","getXRControllerByPointerId","i","length","_getPointerSelectionDisabledByPointerId","_setPointerSelectionDisabledByPointerId","state","_onXRFrame","_xrFrame","controllerData","isVisible","displayLaserPointer","controllerGlobalPosition","position","getWorldPointerRayToRef","getForwardRayToRef","maxPointerDistance","disableScenePointerVectorUpdate","camera","xrCamera","viewport","toGlobalToRef","getEngine","getRenderWidth","getRenderHeight","_viewportRef","ProjectToRef","_identityMatrix","getTransformMatrix","_screenCoordinatesRef","x","y","isNaN","pointerX","pointerY","screenCoordinates","utilityScenePick","_utilityLayerScene","pickWithRay","pointerMovePredicate","raySelectionPredicate","originalScenePick","hit","distance","aimTransform","gripTransform","grip","pickedPoint","_updatePointerDistance","copyFrom","scaling","Math","sqrt","z","pickNormal","_convertNormalToDirectionOfRay","getNormal","deltaFighting","axis1","Cross","Y","axis2","RotationFromAxisToRef","rotation","addInPlace","scale","displaySelectionMesh","pickedMesh","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","timeToSelect","sceneToRenderTo","useUtilityLayer","oldPick","discMesh","diameter","thickness","tessellation","isPickable","parent","timer","downTriggered","pointerEventInit","pointerId","pointerType","onFrameObserver","onXRFrameObservable","add","_augmentPointerInit","material","alpha","_pickingMoved","getDeltaTime","simulatePointerDown","disablePointerUpOnTouchOut","simulatePointerUp","scaleFactor","set","simulatePointerMove","renderingGroupId","undefined","onDisposeObservable","addOnce","finalPointerUpTriggered","dispose","pointerDownTriggered","runInXRFrame","forceGazeMode","disableLighting","disablePointerLighting","disableSelectionMeshLighting","gamepad","init","motionController","overrideButtonId","selectionComponent","getComponent","getMainComponent","onButtonChangedObserver","onButtonStateChangedObservable","component","changes","pressed","current","emissiveColor","selectionMeshPickedColor","laserPointerPickedColor","selectionMeshDefaultColor","laserPointerDefaultColor","disableSwitchOnClick","onMotionControllerInitObservable","selectStartListener","event","selectEndListener","eventListeners","selectend","selectstart","session","addEventListener","normal","ray","angle","acos","Dot","direction","PI","scaleInPlace","xrControllerUniqueId","remove","eventName","func","removeEventListener","onBeforeRenderObservable","e","Warn","meshParent","customLasterPointerMeshGenerator","height","diameterTop","diameterBottom","subdivisions","laserPointerMaterial","customSelectionMeshGenerator","bakeCurrentTransformIntoVertices","targetMat","specularColor","Black","backFaceCulling","newPick","subtractToRef","_tmpVectorForPickCompare","abs","delta","gazeModePointerMovedFactor","_laserPointer","useRightHandedSystem","screenX","screenY","lasterPointerDefaultColor","POINTER_SELECTION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRControllerPointerSelection.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport type { WebXRAbstractMotionController } from \"../motionController/webXRAbstractMotionController\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport type { Node } from \"../../node\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the pointer selection module\r\n */\r\nexport interface IWebXRControllerPointerSelectionOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Disable the pointer up event when the xr controller in screen and gaze mode is disposed (meaning - when the user removed the finger from the screen)\r\n     * If not disabled, the last picked point will be used to execute a pointer up event\r\n     * If disabled, pointer up event will be triggered right after the pointer down event.\r\n     * Used in screen and gaze target ray mode only\r\n     */\r\n    disablePointerUpOnTouchOut: boolean;\r\n    /**\r\n     * For gaze mode for tracked-pointer / controllers (time to select instead of button press)\r\n     */\r\n    forceGazeMode: boolean;\r\n    /**\r\n     * Factor to be applied to the pointer-moved function in the gaze mode. How sensitive should the gaze mode be when checking if the pointer moved\r\n     * to start a new countdown to the pointer down event.\r\n     * Defaults to 1.\r\n     */\r\n    gazeModePointerMovedFactor?: number;\r\n    /**\r\n     * Different button type to use instead of the main component\r\n     */\r\n    overrideButtonId?: string;\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * The amount of time in milliseconds it takes between pick found something to a pointer down event.\r\n     * Used in gaze modes. Tracked pointer uses the trigger, screen uses touch events\r\n     * 3000 means 3 seconds between pointing at something and selecting it\r\n     */\r\n    timeToSelect?: number;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Optional WebXR camera to be used for gaze selection\r\n     */\r\n    gazeCamera?: WebXRCamera;\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Should the scene pointerX and pointerY update be disabled\r\n     * This is required for fullscreen AR GUI, but might slow down other experiences.\r\n     * Disable in VR, if not needed.\r\n     * The first rig camera (left eye) will be used to calculate the projection\r\n     */\r\n    disableScenePointerVectorUpdate: boolean;\r\n\r\n    /**\r\n     * Enable pointer selection on all controllers instead of switching between them\r\n     */\r\n    enablePointerSelectionOnAllControllers?: boolean;\r\n\r\n    /**\r\n     * The preferred hand to give the pointer selection to. This will be prioritized when the controller initialize.\r\n     * If switch is enabled, it will still allow the user to switch between the different controllers\r\n     */\r\n    preferredHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * Disable switching the pointer selection from one controller to the other.\r\n     * If the preferred hand is set it will be fixed on this hand, and if not it will be fixed on the first controller added to the scene\r\n     */\r\n    disableSwitchOnClick?: boolean;\r\n\r\n    /**\r\n     * The maximum distance of the pointer selection feature. Defaults to 100.\r\n     */\r\n    maxPointerDistance?: number;\r\n\r\n    /**\r\n     * A function that will be called when a new selection mesh is generated.\r\n     * This function should return a mesh that will be used as the selection mesh.\r\n     * The default is a torus with a 0.01 diameter and 0.0075 thickness .\r\n     */\r\n    customSelectionMeshGenerator?: () => Mesh;\r\n\r\n    /**\r\n     * A function that will be called when a new laser pointer mesh is generated.\r\n     * This function should return a mesh that will be used as the laser pointer mesh.\r\n     * The height (y) of the mesh must be 1.\r\n     */\r\n    customLasterPointerMeshGenerator?: () => AbstractMesh;\r\n}\r\n\r\n/**\r\n * A module that will enable pointer selection for motion controllers of XR Input Sources\r\n */\r\nexport class WebXRControllerPointerSelection extends WebXRAbstractFeature {\r\n    private static _IdCounter = 200;\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n\r\n        const { laserPointer, selectionMesh } = this._generateNewMeshPair(xrController.pointer);\r\n\r\n        // get two new meshes\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            laserPointer,\r\n            selectionMesh,\r\n            meshUnderPointer: null,\r\n            pick: null,\r\n            tmpRay: new Ray(new Vector3(), new Vector3()),\r\n            disabledByNearInteraction: false,\r\n            id: WebXRControllerPointerSelection._IdCounter++,\r\n        };\r\n\r\n        if (this._attachedController) {\r\n            if (\r\n                !this._options.enablePointerSelectionOnAllControllers &&\r\n                this._options.preferredHandedness &&\r\n                xrController.inputSource.handedness === this._options.preferredHandedness\r\n            ) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        } else {\r\n            if (!this._options.enablePointerSelectionOnAllControllers) {\r\n                this._attachedController = xrController.uniqueId;\r\n            }\r\n        }\r\n\r\n        switch (xrController.inputSource.targetRayMode) {\r\n            case \"tracked-pointer\":\r\n                return this._attachTrackedPointerRayMode(xrController);\r\n            case \"gaze\":\r\n                return this._attachGazeMode(xrController);\r\n            case \"screen\":\r\n                return this._attachScreenRayMode(xrController);\r\n        }\r\n    };\r\n\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController?: WebXRInputSource;\r\n            webXRCamera?: WebXRCamera;\r\n            selectionComponent?: WebXRControllerComponent;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n            onFrameObserver?: Nullable<Observer<XRFrame>>;\r\n            laserPointer: AbstractMesh;\r\n            selectionMesh: AbstractMesh;\r\n            meshUnderPointer: Nullable<AbstractMesh>;\r\n            pick: Nullable<PickingInfo>;\r\n            id: number;\r\n            tmpRay: Ray;\r\n            disabledByNearInteraction: boolean;\r\n            // event support\r\n            eventListeners?: { [event in XREventType]?: (event: XRInputSourceEvent) => void };\r\n            screenCoordinates?: { x: number; y: number };\r\n            pointerDownTriggered?: boolean;\r\n            finalPointerUpTriggered?: boolean;\r\n        };\r\n    } = {};\r\n    private _scene: Scene;\r\n    private _tmpVectorForPickCompare = new Vector3();\r\n\r\n    private _attachedController: string;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.POINTER_SELECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Disable lighting on the laser pointer (so it will always be visible)\r\n     */\r\n    public disablePointerLighting: boolean = true;\r\n    /**\r\n     * Disable lighting on the selection mesh (so it will always be visible)\r\n     */\r\n    public disableSelectionMeshLighting: boolean = true;\r\n    /**\r\n     * Should the laser pointer be displayed\r\n     */\r\n    public displayLaserPointer: boolean = true;\r\n    /**\r\n     * Should the selection mesh be displayed (The ring at the end of the laser pointer)\r\n     */\r\n    public displaySelectionMesh: boolean = true;\r\n    /**\r\n     * This color will be set to the laser pointer when selection is triggered\r\n     */\r\n    public laserPointerPickedColor: Color3 = new Color3(0.9, 0.9, 0.9);\r\n    /**\r\n     * Default color of the laser pointer\r\n     */\r\n    public laserPointerDefaultColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    /**\r\n     * default color of the selection ring\r\n     */\r\n    public selectionMeshDefaultColor: Color3 = new Color3(0.8, 0.8, 0.8);\r\n    /**\r\n     * This color will be applied to the selection ring when selection is triggered\r\n     */\r\n    public selectionMeshPickedColor: Color3 = new Color3(0.3, 0.3, 1.0);\r\n\r\n    /**\r\n     * Optional filter to be used for ray selection.  This predicate shares behavior with\r\n     * scene.pointerMovePredicate which takes priority if it is also assigned.\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * constructs a new background remover module\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param _options read-only options to be used in this module\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPointerSelectionOptions) {\r\n        super(_xrSessionManager);\r\n        this._scene = this._xrSessionManager.scene;\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        this._scene.constantlyUpdateMeshUnderPointer = true;\r\n\r\n        if (this._options.gazeCamera) {\r\n            const webXRCamera = this._options.gazeCamera;\r\n\r\n            const { laserPointer, selectionMesh } = this._generateNewMeshPair(webXRCamera);\r\n\r\n            this._controllers[\"camera\"] = {\r\n                webXRCamera,\r\n                laserPointer,\r\n                selectionMesh,\r\n                meshUnderPointer: null,\r\n                pick: null,\r\n                tmpRay: new Ray(new Vector3(), new Vector3()),\r\n                disabledByNearInteraction: false,\r\n                id: WebXRControllerPointerSelection._IdCounter++,\r\n            };\r\n            this._attachGazeMode();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Will get the mesh under a specific pointer.\r\n     * `scene.meshUnderPointer` will only return one mesh - either left or right.\r\n     * @param controllerId the controllerId to check\r\n     * @returns The mesh under pointer or null if no mesh is under the pointer\r\n     */\r\n    public getMeshUnderPointer(controllerId: string): Nullable<AbstractMesh> {\r\n        if (this._controllers[controllerId]) {\r\n            return this._controllers[controllerId].meshUnderPointer;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the xr controller that correlates to the pointer id in the pointer event\r\n     *\r\n     * @param id the pointer id to search for\r\n     * @returns the controller that correlates to this id or null if not found\r\n     */\r\n    public getXRControllerByPointerId(id: number): Nullable<WebXRInputSource> {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].xrController || null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getPointerSelectionDisabledByPointerId(id: number): boolean {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                return this._controllers[keys[i]].disabledByNearInteraction;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setPointerSelectionDisabledByPointerId(id: number, state: boolean) {\r\n        const keys = Object.keys(this._controllers);\r\n\r\n        for (let i = 0; i < keys.length; ++i) {\r\n            if (this._controllers[keys[i]].id === id) {\r\n                this._controllers[keys[i]].disabledByNearInteraction = state;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _identityMatrix = Matrix.Identity();\r\n    private _screenCoordinatesRef = Vector3.Zero();\r\n    private _viewportRef = new Viewport(0, 0, 0, 0);\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        Object.keys(this._controllers).forEach((id) => {\r\n            // only do this for the selected pointer\r\n            const controllerData = this._controllers[id];\r\n            if ((!this._options.enablePointerSelectionOnAllControllers && id !== this._attachedController) || controllerData.disabledByNearInteraction) {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                controllerData.laserPointer.isVisible = false;\r\n                controllerData.pick = null;\r\n                return;\r\n            }\r\n\r\n            controllerData.laserPointer.isVisible = this.displayLaserPointer;\r\n\r\n            let controllerGlobalPosition: Vector3;\r\n\r\n            // Every frame check collisions/input\r\n            if (controllerData.xrController) {\r\n                controllerGlobalPosition = controllerData.xrController.pointer.position;\r\n                controllerData.xrController.getWorldPointerRayToRef(controllerData.tmpRay);\r\n            } else if (controllerData.webXRCamera) {\r\n                controllerGlobalPosition = controllerData.webXRCamera.position;\r\n                controllerData.webXRCamera.getForwardRayToRef(controllerData.tmpRay);\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            if (this._options.maxPointerDistance) {\r\n                controllerData.tmpRay.length = this._options.maxPointerDistance;\r\n            }\r\n            // update pointerX and pointerY of the scene. Only if the flag is set to true!\r\n            if (!this._options.disableScenePointerVectorUpdate && controllerGlobalPosition) {\r\n                const scene = this._xrSessionManager.scene;\r\n                const camera = this._options.xrInput.xrCamera;\r\n                if (camera) {\r\n                    camera.viewport.toGlobalToRef(scene.getEngine().getRenderWidth(), scene.getEngine().getRenderHeight(), this._viewportRef);\r\n                    Vector3.ProjectToRef(controllerGlobalPosition, this._identityMatrix, scene.getTransformMatrix(), this._viewportRef, this._screenCoordinatesRef);\r\n                    // stay safe\r\n                    if (\r\n                        typeof this._screenCoordinatesRef.x === \"number\" &&\r\n                        typeof this._screenCoordinatesRef.y === \"number\" &&\r\n                        !isNaN(this._screenCoordinatesRef.x) &&\r\n                        !isNaN(this._screenCoordinatesRef.y)\r\n                    ) {\r\n                        scene.pointerX = this._screenCoordinatesRef.x;\r\n                        scene.pointerY = this._screenCoordinatesRef.y;\r\n\r\n                        controllerData.screenCoordinates = {\r\n                            x: this._screenCoordinatesRef.x,\r\n                            y: this._screenCoordinatesRef.y,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            let utilityScenePick = null;\r\n            if (this._utilityLayerScene) {\r\n                utilityScenePick = this._utilityLayerScene.pickWithRay(controllerData.tmpRay, this._utilityLayerScene.pointerMovePredicate || this.raySelectionPredicate);\r\n            }\r\n\r\n            const originalScenePick = this._scene.pickWithRay(controllerData.tmpRay, this._scene.pointerMovePredicate || this.raySelectionPredicate);\r\n            if (!utilityScenePick || !utilityScenePick.hit) {\r\n                // No hit in utility scene\r\n                controllerData.pick = originalScenePick;\r\n            } else if (!originalScenePick || !originalScenePick.hit) {\r\n                // No hit in original scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else if (utilityScenePick.distance < originalScenePick.distance) {\r\n                // Hit is closer in utility scene\r\n                controllerData.pick = utilityScenePick;\r\n            } else {\r\n                // Hit is closer in original scene\r\n                controllerData.pick = originalScenePick;\r\n            }\r\n\r\n            if (controllerData.pick && controllerData.xrController) {\r\n                controllerData.pick.aimTransform = controllerData.xrController.pointer;\r\n                controllerData.pick.gripTransform = controllerData.xrController.grip || null;\r\n            }\r\n\r\n            const pick = controllerData.pick;\r\n\r\n            if (pick && pick.pickedPoint && pick.hit) {\r\n                // Update laser state\r\n                this._updatePointerDistance(controllerData.laserPointer, pick.distance);\r\n\r\n                // Update cursor state\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                controllerData.selectionMesh.scaling.x = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.y = Math.sqrt(pick.distance);\r\n                controllerData.selectionMesh.scaling.z = Math.sqrt(pick.distance);\r\n\r\n                // To avoid z-fighting\r\n                const pickNormal = this._convertNormalToDirectionOfRay(pick.getNormal(true), controllerData.tmpRay);\r\n                const deltaFighting = 0.001;\r\n                controllerData.selectionMesh.position.copyFrom(pick.pickedPoint);\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, controllerData.selectionMesh.rotation);\r\n                    controllerData.selectionMesh.position.addInPlace(pickNormal.scale(deltaFighting));\r\n                }\r\n                controllerData.selectionMesh.isVisible = true && this.displaySelectionMesh;\r\n                controllerData.meshUnderPointer = pick.pickedMesh;\r\n            } else {\r\n                controllerData.selectionMesh.isVisible = false;\r\n                this._updatePointerDistance(controllerData.laserPointer, 1);\r\n                controllerData.meshUnderPointer = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    private get _utilityLayerScene() {\r\n        return this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene;\r\n    }\r\n\r\n    private _attachGazeMode(xrController?: WebXRInputSource) {\r\n        const controllerData = this._controllers[(xrController && xrController.uniqueId) || \"camera\"];\r\n        // attached when touched, detaches when raised\r\n        const timeToSelect = this._options.timeToSelect || 3000;\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._utilityLayerScene : this._scene;\r\n        let oldPick = new PickingInfo();\r\n        const discMesh = CreateTorus(\r\n            \"selection\",\r\n            {\r\n                diameter: 0.0035 * 15,\r\n                thickness: 0.0025 * 6,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        discMesh.isVisible = false;\r\n        discMesh.isPickable = false;\r\n        discMesh.parent = controllerData.selectionMesh;\r\n        let timer = 0;\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            if (!controllerData.pick) {\r\n                return;\r\n            }\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            controllerData.laserPointer.material!.alpha = 0;\r\n            discMesh.isVisible = false;\r\n            if (controllerData.pick.hit) {\r\n                if (!this._pickingMoved(oldPick, controllerData.pick)) {\r\n                    if (timer > timeToSelect / 10) {\r\n                        discMesh.isVisible = true;\r\n                    }\r\n\r\n                    timer += this._scene.getEngine().getDeltaTime();\r\n                    if (timer >= timeToSelect) {\r\n                        this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                        // this pointerdown event is not setting the controllerData.pointerDownTriggered to avoid a pointerUp event when this feature is detached\r\n                        downTriggered = true;\r\n                        // pointer up right after down, if disable on touch out\r\n                        if (this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                        discMesh.isVisible = false;\r\n                    } else {\r\n                        const scaleFactor = 1 - timer / timeToSelect;\r\n                        discMesh.scaling.set(scaleFactor, scaleFactor, scaleFactor);\r\n                    }\r\n                } else {\r\n                    if (downTriggered) {\r\n                        if (!this._options.disablePointerUpOnTouchOut) {\r\n                            this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                        }\r\n                    }\r\n                    downTriggered = false;\r\n                    timer = 0;\r\n                }\r\n            } else {\r\n                downTriggered = false;\r\n                timer = 0;\r\n            }\r\n\r\n            this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n\r\n            oldPick = controllerData.pick;\r\n        });\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            discMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n        if (xrController) {\r\n            xrController.onDisposeObservable.addOnce(() => {\r\n                if (controllerData.pick && !this._options.disablePointerUpOnTouchOut && downTriggered) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n                discMesh.dispose();\r\n            });\r\n        }\r\n    }\r\n\r\n    private _attachScreenRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        let downTriggered = false;\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            if (!controllerData.pick || (this._options.disablePointerUpOnTouchOut && downTriggered)) {\r\n                return;\r\n            }\r\n            if (!downTriggered) {\r\n                this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                controllerData.pointerDownTriggered = true;\r\n                downTriggered = true;\r\n                if (this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                }\r\n            } else {\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        xrController.onDisposeObservable.addOnce(() => {\r\n            this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                if (controllerData.pick && !controllerData.finalPointerUpTriggered && downTriggered && !this._options.disablePointerUpOnTouchOut) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    controllerData.finalPointerUpTriggered = true;\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private _attachTrackedPointerRayMode(xrController: WebXRInputSource) {\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        if (this._options.forceGazeMode) {\r\n            return this._attachGazeMode(xrController);\r\n        }\r\n        const pointerEventInit: PointerEventInit = {\r\n            pointerId: controllerData.id,\r\n            pointerType: \"xr\",\r\n        };\r\n        controllerData.onFrameObserver = this._xrSessionManager.onXRFrameObservable.add(() => {\r\n            (<StandardMaterial>controllerData.laserPointer.material).disableLighting = this.disablePointerLighting;\r\n            (<StandardMaterial>controllerData.selectionMesh.material).disableLighting = this.disableSelectionMeshLighting;\r\n\r\n            if (controllerData.pick) {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerMove(controllerData.pick, pointerEventInit);\r\n            }\r\n        });\r\n        if (xrController.inputSource.gamepad) {\r\n            const init = (motionController: WebXRAbstractMotionController) => {\r\n                if (this._options.overrideButtonId) {\r\n                    controllerData.selectionComponent = motionController.getComponent(this._options.overrideButtonId);\r\n                }\r\n                if (!controllerData.selectionComponent) {\r\n                    controllerData.selectionComponent = motionController.getMainComponent();\r\n                }\r\n\r\n                controllerData.onButtonChangedObserver = controllerData.selectionComponent.onButtonStateChangedObservable.add((component) => {\r\n                    if (component.changes.pressed) {\r\n                        const pressed = component.changes.pressed.current;\r\n                        if (controllerData.pick) {\r\n                            if (this._options.enablePointerSelectionOnAllControllers || xrController.uniqueId === this._attachedController) {\r\n                                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                                if (pressed) {\r\n                                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                                    controllerData.pointerDownTriggered = true;\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                                } else {\r\n                                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (pressed && !this._options.enablePointerSelectionOnAllControllers && !this._options.disableSwitchOnClick) {\r\n                                this._attachedController = xrController.uniqueId;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            };\r\n            if (xrController.motionController) {\r\n                init(xrController.motionController);\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.add(init);\r\n            }\r\n        } else {\r\n            // use the select and squeeze events\r\n            const selectStartListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerDown(controllerData.pick, pointerEventInit);\r\n                    controllerData.pointerDownTriggered = true;\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshPickedColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerPickedColor;\r\n                }\r\n            };\r\n\r\n            const selectEndListener = (event: XRInputSourceEvent) => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                if (controllerData.xrController && event.inputSource === controllerData.xrController.inputSource && controllerData.pick) {\r\n                    this._scene.simulatePointerUp(controllerData.pick, pointerEventInit);\r\n                    (<StandardMaterial>controllerData.selectionMesh.material).emissiveColor = this.selectionMeshDefaultColor;\r\n                    (<StandardMaterial>controllerData.laserPointer.material).emissiveColor = this.laserPointerDefaultColor;\r\n                }\r\n            };\r\n\r\n            controllerData.eventListeners = {\r\n                selectend: selectEndListener,\r\n                selectstart: selectStartListener,\r\n            };\r\n\r\n            this._xrSessionManager.session.addEventListener(\"selectstart\", selectStartListener);\r\n            this._xrSessionManager.session.addEventListener(\"selectend\", selectEndListener);\r\n        }\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.selectionComponent) {\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.selectionComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        if (controllerData.onFrameObserver) {\r\n            this._xrSessionManager.onXRFrameObservable.remove(controllerData.onFrameObserver);\r\n        }\r\n        if (controllerData.eventListeners) {\r\n            Object.keys(controllerData.eventListeners).forEach((eventName: string) => {\r\n                const func = controllerData.eventListeners && controllerData.eventListeners[eventName as XREventType];\r\n                if (func) {\r\n                    // For future reference - this is an issue in the WebXR typings.\r\n                    this._xrSessionManager.session.removeEventListener(eventName as XREventType, func as any);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!controllerData.finalPointerUpTriggered && controllerData.pointerDownTriggered) {\r\n            // Stay safe and fire a pointerup, in case it wasn't already triggered\r\n            const pointerEventInit: PointerEventInit = {\r\n                pointerId: controllerData.id,\r\n                pointerType: \"xr\",\r\n            };\r\n            this._xrSessionManager.runInXRFrame(() => {\r\n                this._augmentPointerInit(pointerEventInit, controllerData.id, controllerData.screenCoordinates);\r\n                this._scene.simulatePointerUp(controllerData.pick || new PickingInfo(), pointerEventInit);\r\n                controllerData.finalPointerUpTriggered = true;\r\n            });\r\n        }\r\n        this._xrSessionManager.scene.onBeforeRenderObservable.addOnce(() => {\r\n            try {\r\n                controllerData.selectionMesh.dispose();\r\n                controllerData.laserPointer.dispose();\r\n                // remove from the map\r\n                delete this._controllers[xrControllerUniqueId];\r\n                if (this._attachedController === xrControllerUniqueId) {\r\n                    // check for other controllers\r\n                    const keys = Object.keys(this._controllers);\r\n                    if (keys.length) {\r\n                        this._attachedController = keys[0];\r\n                    } else {\r\n                        this._attachedController = \"\";\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Tools.Warn(\"controller already detached.\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _generateNewMeshPair(meshParent: Node) {\r\n        const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._scene;\r\n        const laserPointer = this._options.customLasterPointerMeshGenerator\r\n            ? this._options.customLasterPointerMeshGenerator()\r\n            : CreateCylinder(\r\n                  \"laserPointer\",\r\n                  {\r\n                      height: 1,\r\n                      diameterTop: 0.0002,\r\n                      diameterBottom: 0.004,\r\n                      tessellation: 20,\r\n                      subdivisions: 1,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        laserPointer.parent = meshParent;\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", sceneToRenderTo);\r\n        laserPointerMaterial.emissiveColor = this.laserPointerDefaultColor;\r\n        laserPointerMaterial.alpha = 0.7;\r\n        laserPointer.material = laserPointerMaterial;\r\n        laserPointer.rotation.x = Math.PI / 2;\r\n        this._updatePointerDistance(laserPointer, 1);\r\n        laserPointer.isPickable = false;\r\n        laserPointer.isVisible = false;\r\n\r\n        // Create a gaze tracker for the  XR controller\r\n        const selectionMesh = this._options.customSelectionMeshGenerator\r\n            ? this._options.customSelectionMeshGenerator()\r\n            : CreateTorus(\r\n                  \"gazeTracker\",\r\n                  {\r\n                      diameter: 0.0035 * 3,\r\n                      thickness: 0.0025 * 3,\r\n                      tessellation: 20,\r\n                  },\r\n                  sceneToRenderTo\r\n              );\r\n        selectionMesh.bakeCurrentTransformIntoVertices();\r\n        selectionMesh.isPickable = false;\r\n        selectionMesh.isVisible = false;\r\n        const targetMat = new StandardMaterial(\"targetMat\", sceneToRenderTo);\r\n        targetMat.specularColor = Color3.Black();\r\n        targetMat.emissiveColor = this.selectionMeshDefaultColor;\r\n        targetMat.backFaceCulling = false;\r\n        selectionMesh.material = targetMat;\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            laserPointer.renderingGroupId = this._options.renderingGroupId;\r\n            selectionMesh.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        return {\r\n            laserPointer,\r\n            selectionMesh,\r\n        };\r\n    }\r\n\r\n    private _pickingMoved(oldPick: PickingInfo, newPick: PickingInfo) {\r\n        if (!oldPick.hit || !newPick.hit) {\r\n            return true;\r\n        }\r\n        if (!oldPick.pickedMesh || !oldPick.pickedPoint || !newPick.pickedMesh || !newPick.pickedPoint) {\r\n            return true;\r\n        }\r\n        if (oldPick.pickedMesh !== newPick.pickedMesh) {\r\n            return true;\r\n        }\r\n        oldPick.pickedPoint?.subtractToRef(newPick.pickedPoint, this._tmpVectorForPickCompare);\r\n        this._tmpVectorForPickCompare.set(Math.abs(this._tmpVectorForPickCompare.x), Math.abs(this._tmpVectorForPickCompare.y), Math.abs(this._tmpVectorForPickCompare.z));\r\n        const delta = (this._options.gazeModePointerMovedFactor || 1) * 0.01 * newPick.distance;\r\n        const length = this._tmpVectorForPickCompare.length();\r\n        if (length > delta) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updatePointerDistance(_laserPointer: AbstractMesh, distance: number = 100) {\r\n        _laserPointer.scaling.y = distance;\r\n        // a bit of distance from the controller\r\n        if (this._scene.useRightHandedSystem) {\r\n            distance *= -1;\r\n        }\r\n        _laserPointer.position.z = distance / 2 + 0.05;\r\n    }\r\n\r\n    private _augmentPointerInit(pointerEventInit: PointerEventInit, id: number, screenCoordinates?: { x: number; y: number }): void {\r\n        pointerEventInit.pointerId = id;\r\n        pointerEventInit.pointerType = \"xr\";\r\n        if (screenCoordinates) {\r\n            pointerEventInit.screenX = screenCoordinates.x;\r\n            pointerEventInit.screenY = screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get lasterPointerDefaultColor(): Color3 {\r\n        // here due to a typo\r\n        return this.laserPointerDefaultColor;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPointerSelection.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPointerSelection(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPointerSelection.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}