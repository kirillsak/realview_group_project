{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/glowMapGeneration.fragment.js\";\nimport \"../Shaders/glowMapGeneration.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EffectFallbacks } from \"../Materials/effectFallbacks.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * The effect layer Helps adding post process effect blended with the main pass.\n *\n * This can be for instance use to generate glow or highlight effects on the scene.\n *\n * The effect layer class can not be used directly and is intented to inherited from to be\n * customized per effects.\n */\nexport class EffectLayer {\n  /**\n   * Instantiates a new effect Layer and references it in the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   */\n  constructor( /** The Friendly of the effect in the scene */\n  name, scene) {\n    this._vertexBuffers = {};\n    this._maxSize = 0;\n    this._mainTextureDesiredSize = {\n      width: 0,\n      height: 0\n    };\n    this._shouldRender = true;\n    this._postProcesses = [];\n    this._textures = [];\n    this._emissiveTextureAndColor = {\n      texture: null,\n      color: new Color4()\n    };\n    /**\n     * The clear color of the texture used to generate the glow map.\n     */\n    this.neutralColor = new Color4();\n    /**\n     * Specifies whether the highlight layer is enabled or not.\n     */\n    this.isEnabled = true;\n    /**\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\n     */\n    this.disableBoundingBoxesFromEffectLayer = false;\n    /**\n     * An event triggered when the effect layer has been disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\n     */\n    this.onBeforeRenderMainTextureObservable = new Observable();\n    /**\n     * An event triggered when the generated texture is being merged in the scene.\n     */\n    this.onBeforeComposeObservable = new Observable();\n    /**\n     * An event triggered when the mesh is rendered into the effect render target.\n     */\n    this.onBeforeRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered after the mesh has been rendered into the effect render target.\n     */\n    this.onAfterRenderMeshToEffect = new Observable();\n    /**\n     * An event triggered when the generated texture has been merged in the scene.\n     */\n    this.onAfterComposeObservable = new Observable();\n    /**\n     * An event triggered when the effect layer changes its size.\n     */\n    this.onSizeChangedObservable = new Observable();\n    this._materialForRendering = {};\n    this.name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    EffectLayer._SceneComponentInitialization(this._scene);\n    this._engine = this._scene.getEngine();\n    this._maxSize = this._engine.getCaps().maxTextureSize;\n    this._scene.effectLayers.push(this);\n    this._mergeDrawWrapper = [];\n    // Generate Buffers\n    this._generateIndexBuffer();\n    this._generateVertexBuffer();\n  }\n  /**\n   * Gets the camera attached to the layer.\n   */\n  get camera() {\n    return this._effectLayerOptions.camera;\n  }\n  /**\n   * Gets the rendering group id the layer should render in.\n   */\n  get renderingGroupId() {\n    return this._effectLayerOptions.renderingGroupId;\n  }\n  set renderingGroupId(renderingGroupId) {\n    this._effectLayerOptions.renderingGroupId = renderingGroupId;\n  }\n  /**\n   * Gets the main texture where the effect is rendered\n   */\n  get mainTexture() {\n    return this._mainTexture;\n  }\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes in the layer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\n   */\n  setMaterialForRendering(mesh, material) {\n    this._mainTexture.setMaterialForRendering(mesh, material);\n    if (Array.isArray(mesh)) {\n      for (let i = 0; i < mesh.length; ++i) {\n        const currentMesh = mesh[i];\n        if (!material) {\n          delete this._materialForRendering[currentMesh.uniqueId];\n        } else {\n          this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\n        }\n      }\n    } else {\n      if (!material) {\n        delete this._materialForRendering[mesh.uniqueId];\n      } else {\n        this._materialForRendering[mesh.uniqueId] = [mesh, material];\n      }\n    }\n  }\n  /**\n   * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\n   * @returns Number of times a mesh must be rendered in the layer\n   */\n  _numInternalDraws() {\n    return 1;\n  }\n  /**\n   * Initializes the effect layer with the required options.\n   * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\n   */\n  _init(options) {\n    // Adapt options\n    this._effectLayerOptions = {\n      mainTextureRatio: 0.5,\n      alphaBlendingMode: 2,\n      camera: null,\n      renderingGroupId: -1,\n      mainTextureType: 0,\n      ...options\n    };\n    this._setMainTextureSize();\n    this._createMainTexture();\n    this._createTextureAndPostProcesses();\n  }\n  /**\n   * Generates the index buffer of the full screen quad blending to the main canvas.\n   */\n  _generateIndexBuffer() {\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  }\n  /**\n   * Generates the vertex buffer of the full screen quad blending to the main canvas.\n   */\n  _generateVertexBuffer() {\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n  }\n  /**\n   * Sets the main texture desired size which is the closest power of two\n   * of the engine canvas size.\n   */\n  _setMainTextureSize() {\n    if (this._effectLayerOptions.mainTextureFixedSize) {\n      this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\n      this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\n    } else {\n      this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\n      this._mainTextureDesiredSize.width = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize) : this._mainTextureDesiredSize.width;\n      this._mainTextureDesiredSize.height = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize) : this._mainTextureDesiredSize.height;\n    }\n    this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\n    this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\n  }\n  /**\n   * Creates the main texture for the effect layer.\n   */\n  _createMainTexture() {\n    this._mainTexture = new RenderTargetTexture(\"EffectLayerMainRTT\", {\n      width: this._mainTextureDesiredSize.width,\n      height: this._mainTextureDesiredSize.height\n    }, this._scene, false, true, this._effectLayerOptions.mainTextureType);\n    this._mainTexture.activeCamera = this._effectLayerOptions.camera;\n    this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._mainTexture.anisotropicFilteringLevel = 1;\n    this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._mainTexture.renderParticles = false;\n    this._mainTexture.renderList = null;\n    this._mainTexture.ignoreCameraViewport = true;\n    for (const id in this._materialForRendering) {\n      const [mesh, material] = this._materialForRendering[id];\n      this._mainTexture.setMaterialForRendering(mesh, material);\n    }\n    this._mainTexture.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n          this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n          if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    // Custom render function\n    this._mainTexture.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      this.onBeforeRenderMainTextureObservable.notifyObservers(this);\n      let index;\n      const engine = this._scene.getEngine();\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          this._renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        this._renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        this._renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      const previousAlphaMode = engine.getAlphaMode();\n      for (index = 0; index < transparentSubMeshes.length; index++) {\n        this._renderSubMesh(transparentSubMeshes.data[index], true);\n      }\n      engine.setAlphaMode(previousAlphaMode);\n    };\n    this._mainTexture.onClearObservable.add(engine => {\n      engine.clear(this.neutralColor, true, true, true);\n    });\n    // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\n    if (this._scene.getBoundingBoxRenderer) {\n      const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\n      this._mainTexture.onBeforeBindObservable.add(() => {\n        this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\n      });\n      this._mainTexture.onAfterUnbindObservable.add(() => {\n        this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\n      });\n    }\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _addCustomEffectDefines(defines) {\n    // Nothing to add by default.\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @param emissiveTexture the associated emissive texture used to generate the glow\n   * @returns true if ready otherwise, false\n   */\n  _isReady(subMesh, useInstances, emissiveTexture) {\n    var _a;\n    const engine = this._scene.getEngine();\n    const mesh = subMesh.getMesh();\n    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const material = subMesh.getMaterial();\n    if (!material) {\n      return false;\n    }\n    if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\n      return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    let uv1 = false;\n    let uv2 = false;\n    // Diffuse\n    if (material) {\n      const needAlphaTest = material.needAlphaTesting();\n      const diffuseTexture = material.getAlphaTestTexture();\n      const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n      if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n        defines.push(\"#define DIFFUSE\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\n          defines.push(\"#define DIFFUSEUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define DIFFUSEUV1\");\n          uv1 = true;\n        }\n        if (needAlphaTest) {\n          defines.push(\"#define ALPHATEST\");\n          defines.push(\"#define ALPHATESTVALUE 0.4\");\n        }\n        if (!diffuseTexture.gammaSpace) {\n          defines.push(\"#define DIFFUSE_ISLINEAR\");\n        }\n      }\n      const opacityTexture = material.opacityTexture;\n      if (opacityTexture) {\n        defines.push(\"#define OPACITY\");\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\n          defines.push(\"#define OPACITYUV2\");\n          uv2 = true;\n        } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n          defines.push(\"#define OPACITYUV1\");\n          uv1 = true;\n        }\n      }\n    }\n    // Emissive\n    if (emissiveTexture) {\n      defines.push(\"#define EMISSIVE\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\n        defines.push(\"#define EMISSIVEUV2\");\n        uv2 = true;\n      } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        defines.push(\"#define EMISSIVEUV1\");\n        uv1 = true;\n      }\n      if (!emissiveTexture.gammaSpace) {\n        defines.push(\"#define EMISSIVE_ISLINEAR\");\n      }\n    }\n    // Vertex\n    if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\n      attribs.push(VertexBuffer.ColorKind);\n      defines.push(\"#define VERTEXALPHA\");\n    }\n    if (uv1) {\n      attribs.push(VertexBuffer.UVKind);\n      defines.push(\"#define UV1\");\n    }\n    if (uv2) {\n      attribs.push(VertexBuffer.UV2Kind);\n      defines.push(\"#define UV2\");\n    }\n    // Bones\n    const fallbacks = new EffectFallbacks();\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      const skeleton = mesh.skeleton;\n      if (skeleton && skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      } else {\n        defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n      }\n      if (mesh.numBoneInfluencers > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const manager = mesh.morphTargetManager;\n    let morphInfluencers = 0;\n    if (manager) {\n      if (manager.numInfluencers > 0) {\n        defines.push(\"#define MORPHTARGETS\");\n        morphInfluencers = manager.numInfluencers;\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\n        if (manager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // ClipPlanes\n    prepareDefinesForClipPlanes(material, this._scene, defines);\n    this._addCustomEffectDefines(defines);\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"viewProjection\", \"glowColor\", \"morphTargetInfluences\", \"boneTextureWidth\", \"diffuseMatrix\", \"emissiveMatrix\", \"opacityMatrix\", \"opacityIntensity\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(this._engine.createEffect(\"glowMapGeneration\", attribs, uniforms, [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"], join, fallbacks, undefined, undefined, {\n        maxSimultaneousMorphTargets: morphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\n   */\n  render() {\n    for (let i = 0; i < this._postProcesses.length; i++) {\n      if (!this._postProcesses[i].isReady()) {\n        return;\n      }\n    }\n    const engine = this._scene.getEngine();\n    const numDraws = this._numInternalDraws();\n    // Check\n    let isReady = true;\n    for (let i = 0; i < numDraws; ++i) {\n      let currentEffect = this._mergeDrawWrapper[i];\n      if (!currentEffect) {\n        currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\n        currentEffect.setEffect(this._createMergeEffect());\n      }\n      isReady = isReady && currentEffect.effect.isReady();\n    }\n    if (!isReady) {\n      return;\n    }\n    this.onBeforeComposeObservable.notifyObservers(this);\n    const previousAlphaMode = engine.getAlphaMode();\n    for (let i = 0; i < numDraws; ++i) {\n      const currentEffect = this._mergeDrawWrapper[i];\n      // Render\n      engine.enableEffect(currentEffect);\n      engine.setState(false);\n      // VBOs\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect);\n      // Go Blend.\n      engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\n      // Blends the map on the main canvas.\n      this._internalRender(currentEffect.effect, i);\n    }\n    // Restore Alpha\n    engine.setAlphaMode(previousAlphaMode);\n    this.onAfterComposeObservable.notifyObservers(this);\n    // Handle size changes.\n    const size = this._mainTexture.getSize();\n    this._setMainTextureSize();\n    if ((size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) && this._mainTextureDesiredSize.width !== 0 && this._mainTextureDesiredSize.height !== 0) {\n      // Recreate RTT and post processes on size change.\n      this.onSizeChangedObservable.notifyObservers(this);\n      this._disposeTextureAndPostProcesses();\n      this._createMainTexture();\n      this._createTextureAndPostProcesses();\n    }\n  }\n  /**\n   * Determine if a given mesh will be used in the current effect.\n   * @param mesh mesh to test\n   * @returns true if the mesh will be used\n   */\n  hasMesh(mesh) {\n    if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Returns true if the layer contains information to display, otherwise false.\n   * @returns true if the glow layer should be rendered\n   */\n  shouldRender() {\n    return this.isEnabled && this._shouldRender;\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _shouldRenderMesh(mesh) {\n    return true;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    return !material.needAlphaBlendingForMesh(mesh);\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderEmissiveTextureForMesh() {\n    return true;\n  }\n  /**\n   * Renders the submesh passed in parameter to the generation map.\n   * @param subMesh\n   * @param enableAlphaMode\n   */\n  _renderSubMesh(subMesh, enableAlphaMode = false) {\n    var _a, _b;\n    if (!this.shouldRender()) {\n      return;\n    }\n    const material = subMesh.getMaterial();\n    const ownerMesh = subMesh.getMesh();\n    const replacementMesh = subMesh.getReplacementMesh();\n    const renderingMesh = subMesh.getRenderingMesh();\n    const effectiveMesh = subMesh.getEffectiveMesh();\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n    if (!material) {\n      return;\n    }\n    // Do not block in blend mode.\n    if (!this._canRenderMesh(renderingMesh, material)) {\n      return;\n    }\n    // Culling\n    let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n    const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n    if (mainDeterminant < 0) {\n      sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    }\n    const reverse = sideOrientation === Material.ClockWiseSideOrientation;\n    engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\n    // Managing instances\n    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n    if (batch.mustReturn) {\n      return;\n    }\n    // Early Exit per mesh\n    if (!this._shouldRenderMesh(renderingMesh)) {\n      return;\n    }\n    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\n    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n    this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n    if (this._useMeshMaterial(renderingMesh)) {\n      renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\n    } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n      const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n      let drawWrapper = subMesh._getDrawWrapper();\n      if (!drawWrapper && renderingMaterial) {\n        drawWrapper = renderingMaterial._getDrawWrapper();\n      }\n      if (!drawWrapper) {\n        return;\n      }\n      const effect = drawWrapper.effect;\n      engine.enableEffect(drawWrapper);\n      if (!hardwareInstancedRendering) {\n        const fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : material.fillMode;\n        renderingMesh._bind(subMesh, effect, fillMode);\n      }\n      if (!renderingMaterial) {\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        effect.setFloat4(\"glowColor\", this._emissiveTextureAndColor.color.r, this._emissiveTextureAndColor.color.g, this._emissiveTextureAndColor.color.b, this._emissiveTextureAndColor.color.a);\n      } else {\n        renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n      }\n      if (!renderingMaterial) {\n        const needAlphaTest = material.needAlphaTesting();\n        const diffuseTexture = material.getAlphaTestTexture();\n        const needAlphaBlendFromDiffuse = diffuseTexture && diffuseTexture.hasAlpha && (material.useAlphaFromDiffuseTexture || material._useAlphaFromAlbedoTexture);\n        if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\n          effect.setTexture(\"diffuseSampler\", diffuseTexture);\n          const textureMatrix = diffuseTexture.getTextureMatrix();\n          if (textureMatrix) {\n            effect.setMatrix(\"diffuseMatrix\", textureMatrix);\n          }\n        }\n        const opacityTexture = material.opacityTexture;\n        if (opacityTexture) {\n          effect.setTexture(\"opacitySampler\", opacityTexture);\n          effect.setFloat(\"opacityIntensity\", opacityTexture.level);\n          const textureMatrix = opacityTexture.getTextureMatrix();\n          if (textureMatrix) {\n            effect.setMatrix(\"opacityMatrix\", textureMatrix);\n          }\n        }\n        // Glow emissive only\n        if (this._emissiveTextureAndColor.texture) {\n          effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\n          effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\n        }\n        // Bones\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n          const skeleton = renderingMesh.skeleton;\n          if (skeleton.isUsingTextureForMatrices) {\n            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n            if (!boneTexture) {\n              return;\n            }\n            effect.setTexture(\"boneSampler\", boneTexture);\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n          } else {\n            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n        // Morph targets\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n          renderingMesh.morphTargetManager._bind(effect);\n        }\n        // Alpha mode\n        if (enableAlphaMode) {\n          engine.setAlphaMode(material.alphaMode);\n        }\n        // Clip planes\n        bindClipPlane(effect, material, scene);\n      }\n      // Draw\n      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n    } else {\n      // Need to reset refresh rate of the main map\n      this._mainTexture.resetRefreshCounter();\n    }\n    this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n  }\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _useMeshMaterial(mesh) {\n    return false;\n  }\n  /**\n   * Rebuild the required buffers.\n   * @internal Internal use only.\n   */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._generateIndexBuffer();\n  }\n  /**\n   * Dispose only the render target textures and post process.\n   */\n  _disposeTextureAndPostProcesses() {\n    this._mainTexture.dispose();\n    for (let i = 0; i < this._postProcesses.length; i++) {\n      if (this._postProcesses[i]) {\n        this._postProcesses[i].dispose();\n      }\n    }\n    this._postProcesses = [];\n    for (let i = 0; i < this._textures.length; i++) {\n      if (this._textures[i]) {\n        this._textures[i].dispose();\n      }\n    }\n    this._textures = [];\n  }\n  /**\n   * Dispose the highlight layer and free resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    for (const drawWrapper of this._mergeDrawWrapper) {\n      drawWrapper.dispose();\n    }\n    this._mergeDrawWrapper = [];\n    // Clean textures and post processes\n    this._disposeTextureAndPostProcesses();\n    // Remove from scene\n    const index = this._scene.effectLayers.indexOf(this, 0);\n    if (index > -1) {\n      this._scene.effectLayers.splice(index, 1);\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onBeforeRenderMainTextureObservable.clear();\n    this.onBeforeComposeObservable.clear();\n    this.onBeforeRenderMeshToEffect.clear();\n    this.onAfterRenderMeshToEffect.clear();\n    this.onAfterComposeObservable.clear();\n    this.onSizeChangedObservable.clear();\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"EffectLayer\";\n  }\n  /**\n   * Creates an effect layer from parsed effect layer data\n   * @param parsedEffectLayer defines effect layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the effect layer information\n   * @returns a parsed effect Layer\n   */\n  static Parse(parsedEffectLayer, scene, rootUrl) {\n    const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\n    return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\n  }\n}\n/**\n * @internal\n */\nEffectLayer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"EffectLayerSceneComponent\");\n};\n__decorate([serialize()], EffectLayer.prototype, \"name\", void 0);\n__decorate([serializeAsColor4()], EffectLayer.prototype, \"neutralColor\", void 0);\n__decorate([serialize()], EffectLayer.prototype, \"isEnabled\", void 0);\n__decorate([serializeAsCameraReference()], EffectLayer.prototype, \"camera\", null);\n__decorate([serialize()], EffectLayer.prototype, \"renderingGroupId\", null);\n__decorate([serialize()], EffectLayer.prototype, \"disableBoundingBoxesFromEffectLayer\", void 0);","map":{"version":3,"mappings":";;AAAA,SAASA,SAAS,EAAEC,iBAAiB,EAAEC,0BAA0B,QAAQ,uBAAqB;AAC9F,SAASC,KAAK,QAAQ,kBAAgB;AAEtC,SAASC,UAAU,QAAQ,uBAAqB;AAKhD,SAASC,MAAM,QAAQ,wBAAsB;AAC7C,SAASC,MAAM,QAAQ,sBAAoB;AAC3C,SAASC,WAAW,QAAQ,2BAAyB;AACrD,SAASC,YAAY,QAAQ,sBAAoB;AAMjD,SAASC,OAAO,QAAQ,kCAAgC;AACxD,SAASC,mBAAmB,QAAQ,8CAA4C;AAEhF,SAASC,QAAQ,QAAQ,0BAAwB;AACjD,SAASC,cAAc,QAAQ,gCAA8B;AAG7D,OAAO,0CAAwC;AAC/C,OAAO,wCAAsC;AAC7C,SAASC,WAAW,QAAQ,qBAAmB;AAE/C,SAASC,eAAe,QAAQ,iCAA+B;AAC/D,SAASC,WAAW,QAAQ,6BAA2B;AACvD,SAASC,oBAAoB,EAAEC,aAAa,EAAEC,2BAA2B,QAAQ,yCAAuC;AAuCxH;;;;;;;;AAQA,OAAM,MAAgBC,WAAW;EAuI7B;;;;;EAKAC,aACI;EACAC,IAAY,EACZC,KAAa;IA9IT,mBAAc,GAA8C,EAAE;IAO5D,aAAQ,GAAW,CAAC;IACpB,4BAAuB,GAAU;MAAEC,KAAK,EAAE,CAAC;MAAEC,MAAM,EAAE;IAAC,CAAE;IAExD,kBAAa,GAAG,IAAI;IACpB,mBAAc,GAAkB,EAAE;IAClC,cAAS,GAAkB,EAAE;IAC7B,6BAAwB,GAAsD;MAAEC,OAAO,EAAE,IAAI;MAAEC,KAAK,EAAE,IAAIrB,MAAM;IAAE,CAAE;IAQ9H;;;IAIO,iBAAY,GAAW,IAAIA,MAAM,EAAE;IAE1C;;;IAIO,cAAS,GAAY,IAAI;IAqBhC;;;IAIO,wCAAmC,GAAG,KAAK;IAElD;;;IAGO,wBAAmB,GAAG,IAAID,UAAU,EAAe;IAE1D;;;IAGO,wCAAmC,GAAG,IAAIA,UAAU,EAAe;IAE1E;;;IAGO,8BAAyB,GAAG,IAAIA,UAAU,EAAe;IAEhE;;;IAGO,+BAA0B,GAAG,IAAIA,UAAU,EAAgB;IAElE;;;IAGO,8BAAyB,GAAG,IAAIA,UAAU,EAAgB;IAEjE;;;IAGO,6BAAwB,GAAG,IAAIA,UAAU,EAAe;IAE/D;;;IAGO,4BAAuB,GAAG,IAAIA,UAAU,EAAe;IAgBtD,0BAAqB,GAA+C,EAAE;IAqC1E,IAAI,CAACiB,IAAI,GAAGA,IAAI;IAEhB,IAAI,CAACM,MAAM,GAAGL,KAAK,IAAWf,WAAW,CAACqB,gBAAgB;IAC1DT,WAAW,CAACU,6BAA6B,CAAC,IAAI,CAACF,MAAM,CAAC;IAEtD,IAAI,CAACG,OAAO,GAAG,IAAI,CAACH,MAAM,CAACI,SAAS,EAAE;IACtC,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACF,OAAO,CAACG,OAAO,EAAE,CAACC,cAAc;IACrD,IAAI,CAACP,MAAM,CAACQ,YAAY,CAACC,IAAI,CAAC,IAAI,CAAC;IAEnC,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAE3B;IACA,IAAI,CAACC,oBAAoB,EAAE;IAC3B,IAAI,CAACC,qBAAqB,EAAE;EAChC;EA7HA;;;EAIA,IAAWC,MAAM;IACb,OAAO,IAAI,CAACC,mBAAmB,CAACD,MAAM;EAC1C;EAEA;;;EAIA,IAAWE,gBAAgB;IACvB,OAAO,IAAI,CAACD,mBAAmB,CAACC,gBAAgB;EACpD;EACA,IAAWA,gBAAgB,CAACA,gBAAwB;IAChD,IAAI,CAACD,mBAAmB,CAACC,gBAAgB,GAAGA,gBAAgB;EAChE;EA2CA;;;EAGA,IAAWC,WAAW;IAClB,OAAO,IAAI,CAACC,YAAY;EAC5B;EAWA;;;;;EAKOC,uBAAuB,CAACC,IAAmC,EAAEC,QAAmB;IACnF,IAAI,CAACH,YAAY,CAACC,uBAAuB,CAACC,IAAI,EAAEC,QAAQ,CAAC;IACzD,IAAIC,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,EAAE;MACrB,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACK,MAAM,EAAE,EAAED,CAAC,EAAE;QAClC,MAAME,WAAW,GAAGN,IAAI,CAACI,CAAC,CAAC;QAC3B,IAAI,CAACH,QAAQ,EAAE;UACX,OAAO,IAAI,CAACM,qBAAqB,CAACD,WAAW,CAACE,QAAQ,CAAC;SAC1D,MAAM;UACH,IAAI,CAACD,qBAAqB,CAACD,WAAW,CAACE,QAAQ,CAAC,GAAG,CAACF,WAAW,EAAEL,QAAQ,CAAC;;;KAGrF,MAAM;MACH,IAAI,CAACA,QAAQ,EAAE;QACX,OAAO,IAAI,CAACM,qBAAqB,CAACP,IAAI,CAACQ,QAAQ,CAAC;OACnD,MAAM;QACH,IAAI,CAACD,qBAAqB,CAACP,IAAI,CAACQ,QAAQ,CAAC,GAAG,CAACR,IAAI,EAAEC,QAAQ,CAAC;;;EAGxE;EAqFA;;;;EAIUQ,iBAAiB;IACvB,OAAO,CAAC;EACZ;EAEA;;;;EAIUC,KAAK,CAACC,OAAqC;IACjD;IACA,IAAI,CAAChB,mBAAmB,GAAG;MACvBiB,gBAAgB,EAAE,GAAG;MACrBC,iBAAiB,EAAE;MACnBnB,MAAM,EAAE,IAAI;MACZE,gBAAgB,EAAE,CAAC,CAAC;MACpBkB,eAAe,EAAE;MACjB,GAAGH;KACN;IAED,IAAI,CAACI,mBAAmB,EAAE;IAC1B,IAAI,CAACC,kBAAkB,EAAE;IACzB,IAAI,CAACC,8BAA8B,EAAE;EACzC;EAEA;;;EAGQzB,oBAAoB;IACxB;IACA,MAAM0B,OAAO,GAAG,EAAE;IAClBA,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;IACf4B,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;IACf4B,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;IAEf4B,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;IACf4B,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;IACf4B,OAAO,CAAC5B,IAAI,CAAC,CAAC,CAAC;IAEf,IAAI,CAAC6B,YAAY,GAAG,IAAI,CAACnC,OAAO,CAACoC,iBAAiB,CAACF,OAAO,CAAC;EAC/D;EAEA;;;EAGQzB,qBAAqB;IACzB;IACA,MAAM4B,QAAQ,GAAG,EAAE;IACnBA,QAAQ,CAAC/B,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;IACnB+B,QAAQ,CAAC/B,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IACpB+B,QAAQ,CAAC/B,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACrB+B,QAAQ,CAAC/B,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAEpB,MAAMgC,YAAY,GAAG,IAAI5D,YAAY,CAAC,IAAI,CAACsB,OAAO,EAAEqC,QAAQ,EAAE3D,YAAY,CAAC6D,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC;IACzG,IAAI,CAACC,cAAc,CAAC9D,YAAY,CAAC6D,YAAY,CAAC,GAAGD,YAAY;EACjE;EAEA;;;;EAIQP,mBAAmB;IACvB,IAAI,IAAI,CAACpB,mBAAmB,CAAC8B,oBAAoB,EAAE;MAC/C,IAAI,CAACC,uBAAuB,CAACjD,KAAK,GAAG,IAAI,CAACkB,mBAAmB,CAAC8B,oBAAoB;MAClF,IAAI,CAACC,uBAAuB,CAAChD,MAAM,GAAG,IAAI,CAACiB,mBAAmB,CAAC8B,oBAAoB;KACtF,MAAM;MACH,IAAI,CAACC,uBAAuB,CAACjD,KAAK,GAAG,IAAI,CAACO,OAAO,CAAC2C,cAAc,EAAE,GAAG,IAAI,CAAChC,mBAAmB,CAACiB,gBAAgB;MAC9G,IAAI,CAACc,uBAAuB,CAAChD,MAAM,GAAG,IAAI,CAACM,OAAO,CAAC4C,eAAe,EAAE,GAAG,IAAI,CAACjC,mBAAmB,CAACiB,gBAAgB;MAEhH,IAAI,CAACc,uBAAuB,CAACjD,KAAK,GAAG,IAAI,CAACO,OAAO,CAAC6C,eAAe,GAC3DrE,MAAM,CAACsE,gBAAgB,CAAC,IAAI,CAACJ,uBAAuB,CAACjD,KAAK,EAAE,IAAI,CAACS,QAAQ,CAAC,GAC1E,IAAI,CAACwC,uBAAuB,CAACjD,KAAK;MACxC,IAAI,CAACiD,uBAAuB,CAAChD,MAAM,GAAG,IAAI,CAACM,OAAO,CAAC6C,eAAe,GAC5DrE,MAAM,CAACsE,gBAAgB,CAAC,IAAI,CAACJ,uBAAuB,CAAChD,MAAM,EAAE,IAAI,CAACQ,QAAQ,CAAC,GAC3E,IAAI,CAACwC,uBAAuB,CAAChD,MAAM;;IAG7C,IAAI,CAACgD,uBAAuB,CAACjD,KAAK,GAAGsD,IAAI,CAACC,KAAK,CAAC,IAAI,CAACN,uBAAuB,CAACjD,KAAK,CAAC;IACnF,IAAI,CAACiD,uBAAuB,CAAChD,MAAM,GAAGqD,IAAI,CAACC,KAAK,CAAC,IAAI,CAACN,uBAAuB,CAAChD,MAAM,CAAC;EACzF;EAEA;;;EAGUsC,kBAAkB;IACxB,IAAI,CAAClB,YAAY,GAAG,IAAIlC,mBAAmB,CACvC,oBAAoB,EACpB;MACIa,KAAK,EAAE,IAAI,CAACiD,uBAAuB,CAACjD,KAAK;MACzCC,MAAM,EAAE,IAAI,CAACgD,uBAAuB,CAAChD;KACxC,EACD,IAAI,CAACG,MAAM,EACX,KAAK,EACL,IAAI,EACJ,IAAI,CAACc,mBAAmB,CAACmB,eAAe,CAC3C;IACD,IAAI,CAAChB,YAAY,CAACmC,YAAY,GAAG,IAAI,CAACtC,mBAAmB,CAACD,MAAM;IAChE,IAAI,CAACI,YAAY,CAACoC,KAAK,GAAGvE,OAAO,CAACwE,iBAAiB;IACnD,IAAI,CAACrC,YAAY,CAACsC,KAAK,GAAGzE,OAAO,CAACwE,iBAAiB;IACnD,IAAI,CAACrC,YAAY,CAACuC,yBAAyB,GAAG,CAAC;IAC/C,IAAI,CAACvC,YAAY,CAACwC,kBAAkB,CAAC3E,OAAO,CAAC4E,qBAAqB,CAAC;IACnE,IAAI,CAACzC,YAAY,CAAC0C,eAAe,GAAG,KAAK;IACzC,IAAI,CAAC1C,YAAY,CAAC2C,UAAU,GAAG,IAAI;IACnC,IAAI,CAAC3C,YAAY,CAAC4C,oBAAoB,GAAG,IAAI;IAE7C,KAAK,MAAMC,EAAE,IAAI,IAAI,CAACpC,qBAAqB,EAAE;MACzC,MAAM,CAACP,IAAI,EAAEC,QAAQ,CAAC,GAAG,IAAI,CAACM,qBAAqB,CAACoC,EAAE,CAAC;MACvD,IAAI,CAAC7C,YAAY,CAACC,uBAAuB,CAACC,IAAI,EAAEC,QAAQ,CAAC;;IAG7D,IAAI,CAACH,YAAY,CAAC8C,qBAAqB,GAAG,CAAC5C,IAAkB,EAAE6C,WAAmB,EAAEC,OAAiB,KAAI;MACrG,IAAI,CAACA,OAAO,IAAID,WAAW,KAAK,CAAC,KAAK7C,IAAI,CAAC+C,SAAS,EAAE;QAClD,KAAK,IAAI3C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAAC+C,SAAS,CAAC1C,MAAM,EAAE,EAAED,CAAC,EAAE;UAC5C,MAAM4C,OAAO,GAAGhD,IAAI,CAAC+C,SAAS,CAAC3C,CAAC,CAAC;UACjC,MAAMH,QAAQ,GAAG+C,OAAO,CAACC,WAAW,EAAE;UACtC,MAAMC,aAAa,GAAGF,OAAO,CAACG,gBAAgB,EAAE;UAEhD,IAAI,CAAClD,QAAQ,EAAE;YACX;;UAGJ,MAAMmD,KAAK,GAAGF,aAAa,CAACG,uBAAuB,CAACL,OAAO,CAACM,GAAG,EAAE,CAAC,CAACN,OAAO,CAACO,kBAAkB,EAAE,CAAC;UAChG,MAAMC,0BAA0B,GAAGJ,KAAK,CAACI,0BAA0B,CAACR,OAAO,CAACM,GAAG,CAAC,IAAIJ,aAAa,CAACO,gBAAgB;UAElH,IAAI,CAACC,2BAA2B,CAACR,aAAa,EAAEF,OAAO,EAAE/C,QAAQ,CAAC;UAElE,IAAI,CAAC,IAAI,CAAC0D,QAAQ,CAACX,OAAO,EAAEQ,0BAA0B,EAAE,IAAI,CAACI,wBAAwB,CAACjF,OAAO,CAAC,EAAE;YAC5F,OAAO,KAAK;;;;MAKxB,OAAO,IAAI;IACf,CAAC;IAED;IACA,IAAI,CAACmB,YAAY,CAAC+D,oBAAoB,GAAG,CACrCC,eAAoC,EACpCC,kBAAuC,EACvCC,oBAAyC,EACzCC,kBAAuC,KACjC;MACN,IAAI,CAACC,mCAAmC,CAACC,eAAe,CAAC,IAAI,CAAC;MAE9D,IAAIC,KAAa;MAEjB,MAAMC,MAAM,GAAG,IAAI,CAACxF,MAAM,CAACI,SAAS,EAAE;MAEtC,IAAIgF,kBAAkB,CAAC5D,MAAM,EAAE;QAC3BgE,MAAM,CAACC,aAAa,CAAC,KAAK,CAAC;QAC3B,KAAKF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,kBAAkB,CAAC5D,MAAM,EAAE+D,KAAK,EAAE,EAAE;UACxD,IAAI,CAACG,cAAc,CAACN,kBAAkB,CAACO,IAAI,CAACJ,KAAK,CAAC,CAAC;;QAEvDC,MAAM,CAACC,aAAa,CAAC,IAAI,CAAC;;MAG9B,KAAKF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,eAAe,CAACzD,MAAM,EAAE+D,KAAK,EAAE,EAAE;QACrD,IAAI,CAACG,cAAc,CAACT,eAAe,CAACU,IAAI,CAACJ,KAAK,CAAC,CAAC;;MAGpD,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGL,kBAAkB,CAAC1D,MAAM,EAAE+D,KAAK,EAAE,EAAE;QACxD,IAAI,CAACG,cAAc,CAACR,kBAAkB,CAACS,IAAI,CAACJ,KAAK,CAAC,CAAC;;MAGvD,MAAMK,iBAAiB,GAAGJ,MAAM,CAACK,YAAY,EAAE;MAE/C,KAAKN,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGJ,oBAAoB,CAAC3D,MAAM,EAAE+D,KAAK,EAAE,EAAE;QAC1D,IAAI,CAACG,cAAc,CAACP,oBAAoB,CAACQ,IAAI,CAACJ,KAAK,CAAC,EAAE,IAAI,CAAC;;MAG/DC,MAAM,CAACM,YAAY,CAACF,iBAAiB,CAAC;IAC1C,CAAC;IAED,IAAI,CAAC3E,YAAY,CAAC8E,iBAAiB,CAACC,GAAG,CAAER,MAAc,IAAI;MACvDA,MAAM,CAACS,KAAK,CAAC,IAAI,CAACC,YAAY,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACrD,CAAC,CAAC;IAEF;IACA,IAAI,IAAI,CAAClG,MAAM,CAACmG,sBAAsB,EAAE;MACpC,MAAMC,0BAA0B,GAAG,IAAI,CAACpG,MAAM,CAACmG,sBAAsB,EAAE,CAACE,OAAO;MAE/E,IAAI,CAACpF,YAAY,CAACqF,sBAAsB,CAACN,GAAG,CAAC,MAAK;QAC9C,IAAI,CAAChG,MAAM,CAACmG,sBAAsB,EAAE,CAACE,OAAO,GAAG,CAAC,IAAI,CAACE,mCAAmC,IAAIH,0BAA0B;MAC1H,CAAC,CAAC;MAEF,IAAI,CAACnF,YAAY,CAACuF,uBAAuB,CAACR,GAAG,CAAC,MAAK;QAC/C,IAAI,CAAChG,MAAM,CAACmG,sBAAsB,EAAE,CAACE,OAAO,GAAGD,0BAA0B;MAC7E,CAAC,CAAC;;EAEV;EAEA;;;;EAIA;EACUK,uBAAuB,CAACC,OAAiB;IAC/C;EAAA;EAGJ;;;;;;;EAOU5B,QAAQ,CAACX,OAAgB,EAAEwC,YAAqB,EAAEC,eAAsC;;IAC9F,MAAMpB,MAAM,GAAG,IAAI,CAACxF,MAAM,CAACI,SAAS,EAAE;IACtC,MAAMe,IAAI,GAAGgD,OAAO,CAAC0C,OAAO,EAAE;IAE9B,MAAMC,iBAAiB,GAAG,UAAI,CAACC,6BAA6B,CAACC,sBAAsB,0CAAGxB,MAAM,CAACyB,mBAAmB,CAAC;IAEjH,IAAIH,iBAAiB,EAAE;MACnB,OAAOA,iBAAiB,CAACI,iBAAiB,CAAC/F,IAAI,EAAEgD,OAAO,EAAEwC,YAAY,CAAC;;IAG3E,MAAMvF,QAAQ,GAAG+C,OAAO,CAACC,WAAW,EAAE;IAEtC,IAAI,CAAChD,QAAQ,EAAE;MACX,OAAO,KAAK;;IAGhB,IAAI,IAAI,CAAC+F,gBAAgB,CAAChD,OAAO,CAACG,gBAAgB,EAAE,CAAC,EAAE;MACnD,OAAOlD,QAAQ,CAAC8F,iBAAiB,CAAC/C,OAAO,CAAC0C,OAAO,EAAE,EAAE1C,OAAO,EAAEwC,YAAY,CAAC;;IAG/E,MAAMD,OAAO,GAAa,EAAE;IAE5B,MAAMU,OAAO,GAAG,CAACvI,YAAY,CAAC6D,YAAY,CAAC;IAE3C,IAAI2E,GAAG,GAAG,KAAK;IACf,IAAIC,GAAG,GAAG,KAAK;IAEf;IACA,IAAIlG,QAAQ,EAAE;MACV,MAAMmG,aAAa,GAAGnG,QAAQ,CAACoG,gBAAgB,EAAE;MAEjD,MAAMC,cAAc,GAAGrG,QAAQ,CAACsG,mBAAmB,EAAE;MACrD,MAAMC,yBAAyB,GAC3BF,cAAc,IAAIA,cAAc,CAACG,QAAQ,KAAMxG,QAAgB,CAACyG,0BAA0B,IAAKzG,QAAgB,CAAC0G,0BAA0B,CAAC;MAE/I,IAAIL,cAAc,KAAKF,aAAa,IAAII,yBAAyB,CAAC,EAAE;QAChEjB,OAAO,CAACjG,IAAI,CAAC,iBAAiB,CAAC;QAC/B,IAAIU,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACmJ,OAAO,CAAC,IAAIP,cAAc,CAACQ,gBAAgB,KAAK,CAAC,EAAE;UAC3FvB,OAAO,CAACjG,IAAI,CAAC,oBAAoB,CAAC;UAClC6G,GAAG,GAAG,IAAI;SACb,MAAM,IAAInG,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACqJ,MAAM,CAAC,EAAE;UACxDxB,OAAO,CAACjG,IAAI,CAAC,oBAAoB,CAAC;UAClC4G,GAAG,GAAG,IAAI;;QAGd,IAAIE,aAAa,EAAE;UACfb,OAAO,CAACjG,IAAI,CAAC,mBAAmB,CAAC;UACjCiG,OAAO,CAACjG,IAAI,CAAC,4BAA4B,CAAC;;QAE9C,IAAI,CAACgH,cAAc,CAACU,UAAU,EAAE;UAC5BzB,OAAO,CAACjG,IAAI,CAAC,0BAA0B,CAAC;;;MAIhD,MAAM2H,cAAc,GAAIhH,QAAgB,CAACgH,cAAc;MACvD,IAAIA,cAAc,EAAE;QAChB1B,OAAO,CAACjG,IAAI,CAAC,iBAAiB,CAAC;QAC/B,IAAIU,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACmJ,OAAO,CAAC,IAAII,cAAc,CAACH,gBAAgB,KAAK,CAAC,EAAE;UAC3FvB,OAAO,CAACjG,IAAI,CAAC,oBAAoB,CAAC;UAClC6G,GAAG,GAAG,IAAI;SACb,MAAM,IAAInG,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACqJ,MAAM,CAAC,EAAE;UACxDxB,OAAO,CAACjG,IAAI,CAAC,oBAAoB,CAAC;UAClC4G,GAAG,GAAG,IAAI;;;;IAKtB;IACA,IAAIT,eAAe,EAAE;MACjBF,OAAO,CAACjG,IAAI,CAAC,kBAAkB,CAAC;MAChC,IAAIU,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACmJ,OAAO,CAAC,IAAIpB,eAAe,CAACqB,gBAAgB,KAAK,CAAC,EAAE;QAC5FvB,OAAO,CAACjG,IAAI,CAAC,qBAAqB,CAAC;QACnC6G,GAAG,GAAG,IAAI;OACb,MAAM,IAAInG,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACqJ,MAAM,CAAC,EAAE;QACxDxB,OAAO,CAACjG,IAAI,CAAC,qBAAqB,CAAC;QACnC4G,GAAG,GAAG,IAAI;;MAEd,IAAI,CAACT,eAAe,CAACuB,UAAU,EAAE;QAC7BzB,OAAO,CAACjG,IAAI,CAAC,2BAA2B,CAAC;;;IAIjD;IACA,IAAIU,IAAI,CAACkH,eAAe,IAAIlH,IAAI,CAAC4G,qBAAqB,CAAClJ,YAAY,CAACyJ,SAAS,CAAC,IAAInH,IAAI,CAACoH,cAAc,IAAInH,QAAQ,CAACoH,gBAAgB,KAAKxJ,QAAQ,CAACyJ,eAAe,EAAE;MAC7JrB,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACyJ,SAAS,CAAC;MACpC5B,OAAO,CAACjG,IAAI,CAAC,qBAAqB,CAAC;;IAGvC,IAAI4G,GAAG,EAAE;MACLD,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACqJ,MAAM,CAAC;MACjCxB,OAAO,CAACjG,IAAI,CAAC,aAAa,CAAC;;IAE/B,IAAI6G,GAAG,EAAE;MACLF,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACmJ,OAAO,CAAC;MAClCtB,OAAO,CAACjG,IAAI,CAAC,aAAa,CAAC;;IAG/B;IACA,MAAMiI,SAAS,GAAG,IAAIvJ,eAAe,EAAE;IACvC,IAAIgC,IAAI,CAACwH,QAAQ,IAAIxH,IAAI,CAACyH,wBAAwB,EAAE;MAChDxB,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACgK,mBAAmB,CAAC;MAC9CzB,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACiK,mBAAmB,CAAC;MAC9C,IAAI3H,IAAI,CAAC4H,kBAAkB,GAAG,CAAC,EAAE;QAC7B3B,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACmK,wBAAwB,CAAC;QACnD5B,OAAO,CAAC3G,IAAI,CAAC5B,YAAY,CAACoK,wBAAwB,CAAC;;MAGvDvC,OAAO,CAACjG,IAAI,CAAC,+BAA+B,GAAGU,IAAI,CAAC4H,kBAAkB,CAAC;MAEvE,MAAMG,QAAQ,GAAG/H,IAAI,CAAC+H,QAAQ;MAC9B,IAAIA,QAAQ,IAAIA,QAAQ,CAACC,yBAAyB,EAAE;QAChDzC,OAAO,CAACjG,IAAI,CAAC,qBAAqB,CAAC;OACtC,MAAM;QACHiG,OAAO,CAACjG,IAAI,CAAC,uBAAuB,IAAIyI,QAAQ,GAAGA,QAAQ,CAACE,KAAK,CAAC5H,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;MAGtF,IAAIL,IAAI,CAAC4H,kBAAkB,GAAG,CAAC,EAAE;QAC7BL,SAAS,CAACW,sBAAsB,CAAC,CAAC,EAAElI,IAAI,CAAC;;KAEhD,MAAM;MACHuF,OAAO,CAACjG,IAAI,CAAC,gCAAgC,CAAC;;IAGlD;IACA,MAAM6I,OAAO,GAAUnI,IAAK,CAACoI,kBAAkB;IAC/C,IAAIC,gBAAgB,GAAG,CAAC;IACxB,IAAIF,OAAO,EAAE;MACT,IAAIA,OAAO,CAACG,cAAc,GAAG,CAAC,EAAE;QAC5B/C,OAAO,CAACjG,IAAI,CAAC,sBAAsB,CAAC;QACpC+I,gBAAgB,GAAGF,OAAO,CAACG,cAAc;QACzC/C,OAAO,CAACjG,IAAI,CAAC,gCAAgC,GAAG+I,gBAAgB,CAAC;QACjE,IAAIF,OAAO,CAACI,wBAAwB,EAAE;UAClChD,OAAO,CAACjG,IAAI,CAAC,8BAA8B,CAAC;;QAEhDxB,cAAc,CAAC0K,2CAA2C,CAACvC,OAAO,EAAEjG,IAAI,EAAEqI,gBAAgB,CAAC;;;IAInG;IACA,IAAI7C,YAAY,EAAE;MACdD,OAAO,CAACjG,IAAI,CAAC,mBAAmB,CAAC;MACjCxB,cAAc,CAAC2K,0BAA0B,CAACxC,OAAO,CAAC;MAClD,IAAIjD,OAAO,CAACG,gBAAgB,EAAE,CAACM,gBAAgB,EAAE;QAC7C8B,OAAO,CAACjG,IAAI,CAAC,wBAAwB,CAAC;;;IAI9C;IACAlB,2BAA2B,CAAC6B,QAAQ,EAAE,IAAI,CAACpB,MAAM,EAAE0G,OAAO,CAAC;IAE3D,IAAI,CAACD,uBAAuB,CAACC,OAAO,CAAC;IAErC;IACA,MAAMmD,WAAW,GAAG1F,OAAO,CAAC2F,eAAe,CAACC,SAAS,EAAE,IAAI,CAAE;IAC7D,MAAMC,aAAa,GAAGH,WAAW,CAACnD,OAAiB;IACnD,MAAMuD,IAAI,GAAGvD,OAAO,CAACuD,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAID,aAAa,KAAKC,IAAI,EAAE;MACxB,MAAMC,QAAQ,GAAG,CACb,OAAO,EACP,QAAQ,EACR,gBAAgB,EAChB,WAAW,EACX,uBAAuB,EACvB,kBAAkB,EAClB,eAAe,EACf,gBAAgB,EAChB,eAAe,EACf,kBAAkB,EAClB,wBAAwB,EACxB,2BAA2B,CAC9B;MAED7K,oBAAoB,CAAC6K,QAAQ,CAAC;MAE9BL,WAAW,CAACM,SAAS,CACjB,IAAI,CAAChK,OAAO,CAACiK,YAAY,CACrB,mBAAmB,EACnBhD,OAAO,EACP8C,QAAQ,EACR,CAAC,gBAAgB,EAAE,iBAAiB,EAAE,gBAAgB,EAAE,aAAa,EAAE,cAAc,CAAC,EACtFD,IAAI,EACJvB,SAAS,EACTqB,SAAS,EACTA,SAAS,EACT;QAAEM,2BAA2B,EAAEb;MAAgB,CAAE,CACpD,EACDS,IAAI,CACP;;IAGL,OAAOJ,WAAW,CAACS,MAAO,CAACC,OAAO,EAAE;EACxC;EAEA;;;EAGOC,MAAM;IACT,KAAK,IAAIjJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACkJ,cAAc,CAACjJ,MAAM,EAAED,CAAC,EAAE,EAAE;MACjD,IAAI,CAAC,IAAI,CAACkJ,cAAc,CAAClJ,CAAC,CAAC,CAACgJ,OAAO,EAAE,EAAE;QACnC;;;IAIR,MAAM/E,MAAM,GAAG,IAAI,CAACxF,MAAM,CAACI,SAAS,EAAE;IACtC,MAAMsK,QAAQ,GAAG,IAAI,CAAC9I,iBAAiB,EAAE;IAEzC;IACA,IAAI2I,OAAO,GAAG,IAAI;IAClB,KAAK,IAAIhJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmJ,QAAQ,EAAE,EAAEnJ,CAAC,EAAE;MAC/B,IAAIoJ,aAAa,GAAG,IAAI,CAACjK,iBAAiB,CAACa,CAAC,CAAC;MAC7C,IAAI,CAACoJ,aAAa,EAAE;QAChBA,aAAa,GAAG,IAAI,CAACjK,iBAAiB,CAACa,CAAC,CAAC,GAAG,IAAInC,WAAW,CAAC,IAAI,CAACe,OAAO,CAAC;QACzEwK,aAAa,CAACR,SAAS,CAAC,IAAI,CAACS,kBAAkB,EAAE,CAAC;;MAEtDL,OAAO,GAAGA,OAAO,IAAII,aAAa,CAACL,MAAO,CAACC,OAAO,EAAE;;IAGxD,IAAI,CAACA,OAAO,EAAE;MACV;;IAGJ,IAAI,CAACM,yBAAyB,CAACvF,eAAe,CAAC,IAAI,CAAC;IAEpD,MAAMM,iBAAiB,GAAGJ,MAAM,CAACK,YAAY,EAAE;IAE/C,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmJ,QAAQ,EAAE,EAAEnJ,CAAC,EAAE;MAC/B,MAAMoJ,aAAa,GAAG,IAAI,CAACjK,iBAAiB,CAACa,CAAC,CAAC;MAE/C;MACAiE,MAAM,CAACsF,YAAY,CAACH,aAAa,CAAC;MAClCnF,MAAM,CAACuF,QAAQ,CAAC,KAAK,CAAC;MAEtB;MACAvF,MAAM,CAACwF,WAAW,CAAC,IAAI,CAACrI,cAAc,EAAE,IAAI,CAACL,YAAY,EAAEqI,aAAa,CAACL,MAAO,CAAC;MAEjF;MACA9E,MAAM,CAACM,YAAY,CAAC,IAAI,CAAChF,mBAAmB,CAACkB,iBAAiB,CAAC;MAE/D;MACA,IAAI,CAACiJ,eAAe,CAACN,aAAa,CAACL,MAAO,EAAE/I,CAAC,CAAC;;IAGlD;IACAiE,MAAM,CAACM,YAAY,CAACF,iBAAiB,CAAC;IAEtC,IAAI,CAACsF,wBAAwB,CAAC5F,eAAe,CAAC,IAAI,CAAC;IAEnD;IACA,MAAM6F,IAAI,GAAG,IAAI,CAAClK,YAAY,CAACmK,OAAO,EAAE;IACxC,IAAI,CAAClJ,mBAAmB,EAAE;IAC1B,IACI,CAACiJ,IAAI,CAACvL,KAAK,KAAK,IAAI,CAACiD,uBAAuB,CAACjD,KAAK,IAAIuL,IAAI,CAACtL,MAAM,KAAK,IAAI,CAACgD,uBAAuB,CAAChD,MAAM,KACzG,IAAI,CAACgD,uBAAuB,CAACjD,KAAK,KAAK,CAAC,IACxC,IAAI,CAACiD,uBAAuB,CAAChD,MAAM,KAAK,CAAC,EAC3C;MACE;MACA,IAAI,CAACwL,uBAAuB,CAAC/F,eAAe,CAAC,IAAI,CAAC;MAClD,IAAI,CAACgG,+BAA+B,EAAE;MACtC,IAAI,CAACnJ,kBAAkB,EAAE;MACzB,IAAI,CAACC,8BAA8B,EAAE;;EAE7C;EAEA;;;;;EAKOmJ,OAAO,CAACpK,IAAkB;IAC7B,IAAI,IAAI,CAACJ,gBAAgB,KAAK,CAAC,CAAC,IAAII,IAAI,CAACJ,gBAAgB,KAAK,IAAI,CAACA,gBAAgB,EAAE;MACjF,OAAO,IAAI;;IAEf,OAAO,KAAK;EAChB;EAEA;;;;EAIOyK,YAAY;IACf,OAAO,IAAI,CAACC,SAAS,IAAI,IAAI,CAACC,aAAa;EAC/C;EAEA;;;;;EAKA;EACUC,iBAAiB,CAACxK,IAAkB;IAC1C,OAAO,IAAI;EACf;EAEA;;;;;;EAMUyK,cAAc,CAACzK,IAAkB,EAAEC,QAAkB;IAC3D,OAAO,CAACA,QAAQ,CAACyK,wBAAwB,CAAC1K,IAAI,CAAC;EACnD;EAEA;;;;EAIU2K,mCAAmC;IACzC,OAAO,IAAI;EACf;EAEA;;;;;EAKUpG,cAAc,CAACvB,OAAgB,EAAE4H,kBAA2B,KAAK;;IACvE,IAAI,CAAC,IAAI,CAACP,YAAY,EAAE,EAAE;MACtB;;IAGJ,MAAMpK,QAAQ,GAAG+C,OAAO,CAACC,WAAW,EAAE;IACtC,MAAM4H,SAAS,GAAG7H,OAAO,CAAC0C,OAAO,EAAE;IACnC,MAAMoF,eAAe,GAAG9H,OAAO,CAACO,kBAAkB,EAAE;IACpD,MAAML,aAAa,GAAGF,OAAO,CAACG,gBAAgB,EAAE;IAChD,MAAM4H,aAAa,GAAG/H,OAAO,CAACgI,gBAAgB,EAAE;IAChD,MAAMxM,KAAK,GAAG,IAAI,CAACK,MAAM;IACzB,MAAMwF,MAAM,GAAG7F,KAAK,CAACS,SAAS,EAAE;IAEhC8L,aAAa,CAACnF,6BAA6B,CAACqF,qBAAqB,GAAG,KAAK;IAEzE,IAAI,CAAChL,QAAQ,EAAE;MACX;;IAGJ;IACA,IAAI,CAAC,IAAI,CAACwK,cAAc,CAACvH,aAAa,EAAEjD,QAAQ,CAAC,EAAE;MAC/C;;IAGJ;IACA,IAAIiL,eAAe,GAAG,mBAAa,CAACC,+BAA+B,mCAAIlL,QAAQ,CAACiL,eAAe;IAC/F,MAAME,eAAe,GAAGL,aAAa,CAACM,0BAA0B,EAAE;IAClE,IAAID,eAAe,GAAG,CAAC,EAAE;MACrBF,eAAe,GAAGA,eAAe,KAAKrN,QAAQ,CAACyN,wBAAwB,GAAGzN,QAAQ,CAAC0N,+BAA+B,GAAG1N,QAAQ,CAACyN,wBAAwB;;IAG1J,MAAME,OAAO,GAAGN,eAAe,KAAKrN,QAAQ,CAACyN,wBAAwB;IACrEjH,MAAM,CAACuF,QAAQ,CAAC3J,QAAQ,CAACwL,eAAe,EAAExL,QAAQ,CAACyL,OAAO,EAAE9C,SAAS,EAAE4C,OAAO,EAAEvL,QAAQ,CAAC0L,aAAa,EAAE/C,SAAS,EAAE3I,QAAQ,CAAC2L,YAAY,CAAC;IAEzI;IACA,MAAMxI,KAAK,GAAGF,aAAa,CAACG,uBAAuB,CAACL,OAAO,CAACM,GAAG,EAAE,CAAC,CAACwH,eAAe,CAAC;IACnF,IAAI1H,KAAK,CAACyI,UAAU,EAAE;MAClB;;IAGJ;IACA,IAAI,CAAC,IAAI,CAACrB,iBAAiB,CAACtH,aAAa,CAAC,EAAE;MACxC;;IAGJ,MAAMM,0BAA0B,GAAGJ,KAAK,CAACI,0BAA0B,CAACR,OAAO,CAACM,GAAG,CAAC,IAAIJ,aAAa,CAACO,gBAAgB;IAElH,IAAI,CAACC,2BAA2B,CAACR,aAAa,EAAEF,OAAO,EAAE/C,QAAQ,CAAC;IAElE,IAAI,CAAC6L,0BAA0B,CAAC3H,eAAe,CAAC0G,SAAS,CAAC;IAE1D,IAAI,IAAI,CAAC7E,gBAAgB,CAAC9C,aAAa,CAAC,EAAE;MACtCA,aAAa,CAACmG,MAAM,CAACrG,OAAO,EAAE4H,eAAe,EAAEE,eAAe,IAAIlC,SAAS,CAAC;KAC/E,MAAM,IAAI,IAAI,CAACjF,QAAQ,CAACX,OAAO,EAAEQ,0BAA0B,EAAE,IAAI,CAACI,wBAAwB,CAACjF,OAAO,CAAC,EAAE;MAClG,MAAMgH,iBAAiB,GAAG,mBAAa,CAACC,6BAA6B,CAACC,sBAAsB,0CAAGxB,MAAM,CAACyB,mBAAmB,CAAC;MAE1H,IAAI4C,WAAW,GAAG1F,OAAO,CAAC2F,eAAe,EAAE;MAC3C,IAAI,CAACD,WAAW,IAAI/C,iBAAiB,EAAE;QACnC+C,WAAW,GAAG/C,iBAAiB,CAACgD,eAAe,EAAE;;MAGrD,IAAI,CAACD,WAAW,EAAE;QACd;;MAGJ,MAAMS,MAAM,GAAGT,WAAW,CAACS,MAAO;MAElC9E,MAAM,CAACsF,YAAY,CAACjB,WAAW,CAAC;MAChC,IAAI,CAAClF,0BAA0B,EAAE;QAC7B,MAAMuI,QAAQ,GAAGvN,KAAK,CAACwN,gBAAgB,GAAGnO,QAAQ,CAACoO,aAAa,GAAGzN,KAAK,CAAC0N,cAAc,GAAGrO,QAAQ,CAACsO,iBAAiB,GAAGlM,QAAQ,CAAC8L,QAAQ;QACxI7I,aAAa,CAACkJ,KAAK,CAACpJ,OAAO,EAAEmG,MAAM,EAAE4C,QAAQ,CAAC;;MAGlD,IAAI,CAACpG,iBAAiB,EAAE;QACpBwD,MAAM,CAACkD,SAAS,CAAC,gBAAgB,EAAE7N,KAAK,CAAC8N,kBAAkB,EAAE,CAAC;QAC9DnD,MAAM,CAACkD,SAAS,CAAC,OAAO,EAAEtB,aAAa,CAACwB,cAAc,EAAE,CAAC;QACzDpD,MAAM,CAACqD,SAAS,CACZ,WAAW,EACX,IAAI,CAAC5I,wBAAwB,CAAChF,KAAK,CAAC6N,CAAC,EACrC,IAAI,CAAC7I,wBAAwB,CAAChF,KAAK,CAAC8N,CAAC,EACrC,IAAI,CAAC9I,wBAAwB,CAAChF,KAAK,CAAC+N,CAAC,EACrC,IAAI,CAAC/I,wBAAwB,CAAChF,KAAK,CAACgO,CAAC,CACxC;OACJ,MAAM;QACHjH,iBAAiB,CAACkH,cAAc,CAAC9B,aAAa,CAACwB,cAAc,EAAE,EAAExB,aAAqB,EAAE/H,OAAO,CAAC;;MAGpG,IAAI,CAAC2C,iBAAiB,EAAE;QACpB,MAAMS,aAAa,GAAGnG,QAAQ,CAACoG,gBAAgB,EAAE;QAEjD,MAAMC,cAAc,GAAGrG,QAAQ,CAACsG,mBAAmB,EAAE;QACrD,MAAMC,yBAAyB,GAC3BF,cAAc,IAAIA,cAAc,CAACG,QAAQ,KAAMxG,QAAgB,CAACyG,0BAA0B,IAAKzG,QAAgB,CAAC0G,0BAA0B,CAAC;QAE/I,IAAIL,cAAc,KAAKF,aAAa,IAAII,yBAAyB,CAAC,EAAE;UAChE2C,MAAM,CAAC2D,UAAU,CAAC,gBAAgB,EAAExG,cAAc,CAAC;UACnD,MAAMyG,aAAa,GAAGzG,cAAc,CAAC0G,gBAAgB,EAAE;UAEvD,IAAID,aAAa,EAAE;YACf5D,MAAM,CAACkD,SAAS,CAAC,eAAe,EAAEU,aAAa,CAAC;;;QAIxD,MAAM9F,cAAc,GAAIhH,QAAgB,CAACgH,cAAc;QACvD,IAAIA,cAAc,EAAE;UAChBkC,MAAM,CAAC2D,UAAU,CAAC,gBAAgB,EAAE7F,cAAc,CAAC;UACnDkC,MAAM,CAAC8D,QAAQ,CAAC,kBAAkB,EAAEhG,cAAc,CAACiG,KAAK,CAAC;UACzD,MAAMH,aAAa,GAAG9F,cAAc,CAAC+F,gBAAgB,EAAE;UACvD,IAAID,aAAa,EAAE;YACf5D,MAAM,CAACkD,SAAS,CAAC,eAAe,EAAEU,aAAa,CAAC;;;QAIxD;QACA,IAAI,IAAI,CAACnJ,wBAAwB,CAACjF,OAAO,EAAE;UACvCwK,MAAM,CAAC2D,UAAU,CAAC,iBAAiB,EAAE,IAAI,CAAClJ,wBAAwB,CAACjF,OAAO,CAAC;UAC3EwK,MAAM,CAACkD,SAAS,CAAC,gBAAgB,EAAE,IAAI,CAACzI,wBAAwB,CAACjF,OAAO,CAACqO,gBAAgB,EAAE,CAAC;;QAGhG;QACA,IAAI9J,aAAa,CAACsE,QAAQ,IAAItE,aAAa,CAACuE,wBAAwB,IAAIvE,aAAa,CAAC6E,QAAQ,EAAE;UAC5F,MAAMA,QAAQ,GAAG7E,aAAa,CAAC6E,QAAQ;UAEvC,IAAIA,QAAQ,CAACC,yBAAyB,EAAE;YACpC,MAAMmF,WAAW,GAAGpF,QAAQ,CAACqF,yBAAyB,CAAClK,aAAa,CAAC;YACrE,IAAI,CAACiK,WAAW,EAAE;cACd;;YAGJhE,MAAM,CAAC2D,UAAU,CAAC,aAAa,EAAEK,WAAW,CAAC;YAC7ChE,MAAM,CAAC8D,QAAQ,CAAC,kBAAkB,EAAE,GAAG,IAAIlF,QAAQ,CAACE,KAAK,CAAC5H,MAAM,GAAG,CAAC,CAAC,CAAC;WACzE,MAAM;YACH8I,MAAM,CAACkE,WAAW,CAAC,QAAQ,EAAEtF,QAAQ,CAACuF,oBAAoB,CAACpK,aAAa,CAAC,CAAC;;;QAIlF;QACApF,cAAc,CAACyP,yBAAyB,CAACrK,aAAa,EAAEiG,MAAM,CAAC;QAC/D,IAAIjG,aAAa,CAACkF,kBAAkB,IAAIlF,aAAa,CAACkF,kBAAkB,CAACG,wBAAwB,EAAE;UAC/FrF,aAAa,CAACkF,kBAAkB,CAACgE,KAAK,CAACjD,MAAM,CAAC;;QAGlD;QACA,IAAIyB,eAAe,EAAE;UACjBvG,MAAM,CAACM,YAAY,CAAC1E,QAAQ,CAACuN,SAAS,CAAC;;QAG3C;QACArP,aAAa,CAACgL,MAAM,EAAElJ,QAAQ,EAAEzB,KAAK,CAAC;;MAG1C;MACA0E,aAAa,CAACuK,iBAAiB,CAAC1C,aAAa,EAAE/H,OAAO,EAAEmG,MAAM,EAAElJ,QAAQ,CAAC8L,QAAQ,EAAE3I,KAAK,EAAEI,0BAA0B,EAAE,CAACkK,UAAU,EAAEC,KAAK,KACpIxE,MAAM,CAACkD,SAAS,CAAC,OAAO,EAAEsB,KAAK,CAAC,CACnC;KACJ,MAAM;MACH;MACA,IAAI,CAAC7N,YAAY,CAAC8N,mBAAmB,EAAE;;IAG3C,IAAI,CAACC,yBAAyB,CAAC1J,eAAe,CAAC0G,SAAS,CAAC;EAC7D;EAEA;;;;EAIA;EACU7E,gBAAgB,CAAChG,IAAkB;IACzC,OAAO,KAAK;EAChB;EAEA;;;;EAIO8N,QAAQ;IACX,MAAMC,EAAE,GAAG,IAAI,CAACvM,cAAc,CAAC9D,YAAY,CAAC6D,YAAY,CAAC;IAEzD,IAAIwM,EAAE,EAAE;MACJA,EAAE,CAACD,QAAQ,EAAE;;IAGjB,IAAI,CAACtO,oBAAoB,EAAE;EAC/B;EAEA;;;EAGQ2K,+BAA+B;IACnC,IAAI,CAACrK,YAAY,CAACkO,OAAO,EAAE;IAE3B,KAAK,IAAI5N,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACkJ,cAAc,CAACjJ,MAAM,EAAED,CAAC,EAAE,EAAE;MACjD,IAAI,IAAI,CAACkJ,cAAc,CAAClJ,CAAC,CAAC,EAAE;QACxB,IAAI,CAACkJ,cAAc,CAAClJ,CAAC,CAAC,CAAC4N,OAAO,EAAE;;;IAGxC,IAAI,CAAC1E,cAAc,GAAG,EAAE;IAExB,KAAK,IAAIlJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC6N,SAAS,CAAC5N,MAAM,EAAED,CAAC,EAAE,EAAE;MAC5C,IAAI,IAAI,CAAC6N,SAAS,CAAC7N,CAAC,CAAC,EAAE;QACnB,IAAI,CAAC6N,SAAS,CAAC7N,CAAC,CAAC,CAAC4N,OAAO,EAAE;;;IAGnC,IAAI,CAACC,SAAS,GAAG,EAAE;EACvB;EAEA;;;EAGOD,OAAO;IACV,MAAM1M,YAAY,GAAG,IAAI,CAACE,cAAc,CAAC9D,YAAY,CAAC6D,YAAY,CAAC;IACnE,IAAID,YAAY,EAAE;MACdA,YAAY,CAAC0M,OAAO,EAAE;MACtB,IAAI,CAACxM,cAAc,CAAC9D,YAAY,CAAC6D,YAAY,CAAC,GAAG,IAAI;;IAGzD,IAAI,IAAI,CAACJ,YAAY,EAAE;MACnB,IAAI,CAACtC,MAAM,CAACI,SAAS,EAAE,CAACiP,cAAc,CAAC,IAAI,CAAC/M,YAAY,CAAC;MACzD,IAAI,CAACA,YAAY,GAAG,IAAI;;IAG5B,KAAK,MAAMuH,WAAW,IAAI,IAAI,CAACnJ,iBAAiB,EAAE;MAC9CmJ,WAAW,CAACsF,OAAO,EAAE;;IAEzB,IAAI,CAACzO,iBAAiB,GAAG,EAAE;IAE3B;IACA,IAAI,CAAC4K,+BAA+B,EAAE;IAEtC;IACA,MAAM/F,KAAK,GAAG,IAAI,CAACvF,MAAM,CAACQ,YAAY,CAAC8O,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;IACvD,IAAI/J,KAAK,GAAG,CAAC,CAAC,EAAE;MACZ,IAAI,CAACvF,MAAM,CAACQ,YAAY,CAAC+O,MAAM,CAAChK,KAAK,EAAE,CAAC,CAAC;;IAG7C;IACA,IAAI,CAACiK,mBAAmB,CAAClK,eAAe,CAAC,IAAI,CAAC;IAE9C,IAAI,CAACkK,mBAAmB,CAACvJ,KAAK,EAAE;IAChC,IAAI,CAACZ,mCAAmC,CAACY,KAAK,EAAE;IAChD,IAAI,CAAC4E,yBAAyB,CAAC5E,KAAK,EAAE;IACtC,IAAI,CAACgH,0BAA0B,CAAChH,KAAK,EAAE;IACvC,IAAI,CAAC+I,yBAAyB,CAAC/I,KAAK,EAAE;IACtC,IAAI,CAACiF,wBAAwB,CAACjF,KAAK,EAAE;IACrC,IAAI,CAACoF,uBAAuB,CAACpF,KAAK,EAAE;EACxC;EAEA;;;;EAIOwJ,YAAY;IACf,OAAO,aAAa;EACxB;EAEA;;;;;;;EAOO,OAAOC,KAAK,CAACC,iBAAsB,EAAEhQ,KAAY,EAAEiQ,OAAe;IACrE,MAAMC,eAAe,GAAGrR,KAAK,CAACsR,WAAW,CAACH,iBAAiB,CAACI,UAAU,CAAC;IAEvE,OAAOF,eAAe,CAACH,KAAK,CAACC,iBAAiB,EAAEhQ,KAAK,EAAEiQ,OAAO,CAAC;EACnE;;AA94BA;;;AAGcpQ,yCAA6B,GAA4BwQ,CAAC,IAAI;EACxE,MAAM9Q,WAAW,CAAC,2BAA2B,CAAC;AAClD,CAAC;AAtFD+Q,YADC5R,SAAS,EAAE,yCACQ;AAMpB4R,YADC3R,iBAAiB,EAAE,iDACuB;AAM3C2R,YADC5R,SAAS,EAAE,8CACqB;AAMjC4R,YADC1R,0BAA0B,EAAE,yCAG5B;AAMD0R,YADC5R,SAAS,EAAE,mDAGX;AASD4R,YADC5R,SAAS,EAAE,wEACuC","names":["serialize","serializeAsColor4","serializeAsCameraReference","Tools","Observable","Color4","Engine","EngineStore","VertexBuffer","Texture","RenderTargetTexture","Material","MaterialHelper","_WarnImport","EffectFallbacks","DrawWrapper","addClipPlaneUniforms","bindClipPlane","prepareDefinesForClipPlanes","EffectLayer","constructor","name","scene","width","height","texture","color","_scene","LastCreatedScene","_SceneComponentInitialization","_engine","getEngine","_maxSize","getCaps","maxTextureSize","effectLayers","push","_mergeDrawWrapper","_generateIndexBuffer","_generateVertexBuffer","camera","_effectLayerOptions","renderingGroupId","mainTexture","_mainTexture","setMaterialForRendering","mesh","material","Array","isArray","i","length","currentMesh","_materialForRendering","uniqueId","_numInternalDraws","_init","options","mainTextureRatio","alphaBlendingMode","mainTextureType","_setMainTextureSize","_createMainTexture","_createTextureAndPostProcesses","indices","_indexBuffer","createIndexBuffer","vertices","vertexBuffer","PositionKind","_vertexBuffers","mainTextureFixedSize","_mainTextureDesiredSize","getRenderWidth","getRenderHeight","needPOTTextures","GetExponentOfTwo","Math","floor","activeCamera","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","updateSamplingMode","BILINEAR_SAMPLINGMODE","renderParticles","renderList","ignoreCameraViewport","id","customIsReadyFunction","refreshRate","preWarm","subMeshes","subMesh","getMaterial","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","hasThinInstances","_setEmissiveTextureAndColor","_isReady","_emissiveTextureAndColor","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","onBeforeRenderMainTextureObservable","notifyObservers","index","engine","setColorWrite","_renderSubMesh","data","previousAlphaMode","getAlphaMode","setAlphaMode","onClearObservable","add","clear","neutralColor","getBoundingBoxRenderer","boundingBoxRendererEnabled","enabled","onBeforeBindObservable","disableBoundingBoxesFromEffectLayer","onAfterUnbindObservable","_addCustomEffectDefines","defines","useInstances","emissiveTexture","getMesh","renderingMaterial","_internalAbstractMeshDataInfo","_materialForRenderPass","currentRenderPassId","isReadyForSubMesh","_useMeshMaterial","attribs","uv1","uv2","needAlphaTest","needAlphaTesting","diffuseTexture","getAlphaTestTexture","needAlphaBlendFromDiffuse","hasAlpha","useAlphaFromDiffuseTexture","_useAlphaFromAlbedoTexture","isVerticesDataPresent","UV2Kind","coordinatesIndex","UVKind","gammaSpace","opacityTexture","useVertexColors","ColorKind","hasVertexAlpha","transparencyMode","MATERIAL_OPAQUE","fallbacks","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","skeleton","isUsingTextureForMatrices","bones","addCPUSkinningFallback","manager","morphTargetManager","morphInfluencers","numInfluencers","isUsingTextureForTargets","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","drawWrapper","_getDrawWrapper","undefined","cachedDefines","join","uniforms","setEffect","createEffect","maxSimultaneousMorphTargets","effect","isReady","render","_postProcesses","numDraws","currentEffect","_createMergeEffect","onBeforeComposeObservable","enableEffect","setState","bindBuffers","_internalRender","onAfterComposeObservable","size","getSize","onSizeChangedObservable","_disposeTextureAndPostProcesses","hasMesh","shouldRender","isEnabled","_shouldRender","_shouldRenderMesh","_canRenderMesh","needAlphaBlendingForMesh","_shouldRenderEmissiveTextureForMesh","enableAlphaMode","ownerMesh","replacementMesh","effectiveMesh","getEffectiveMesh","_isActiveIntermediate","sideOrientation","overrideMaterialSideOrientation","mainDeterminant","_getWorldMatrixDeterminant","ClockWiseSideOrientation","CounterClockWiseSideOrientation","reverse","backFaceCulling","zOffset","cullBackFaces","zOffsetUnits","mustReturn","onBeforeRenderMeshToEffect","fillMode","forcePointsCloud","PointFillMode","forceWireframe","WireFrameFillMode","_bind","setMatrix","getTransformMatrix","getWorldMatrix","setFloat4","r","g","b","a","bindForSubMesh","setTexture","textureMatrix","getTextureMatrix","setFloat","level","boneTexture","getTransformMatrixTexture","setMatrices","getTransformMatrices","BindMorphTargetParameters","alphaMode","_processRendering","isInstance","world","resetRefreshCounter","onAfterRenderMeshToEffect","_rebuild","vb","dispose","_textures","_releaseBuffer","indexOf","splice","onDisposeObservable","getClassName","Parse","parsedEffectLayer","rootUrl","effectLayerType","Instantiate","customType","_","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Layers/effectLayer.ts"],"sourcesContent":["import { serialize, serializeAsColor4, serializeAsCameraReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/glowMapGeneration.fragment\";\r\nimport \"../Shaders/glowMapGeneration.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\n/**\r\n * Effect layer options. This helps customizing the behaviour\r\n * of the effect layer.\r\n */\r\nexport interface IEffectLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure effect stability across devices. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * Alpha blending mode used to apply the blur. Default depends of the implementation. Default: ALPHA_COMBINE\r\n     */\r\n    alphaBlendingMode: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n}\r\n\r\n/**\r\n * The effect layer Helps adding post process effect blended with the main pass.\r\n *\r\n * This can be for instance use to generate glow or highlight effects on the scene.\r\n *\r\n * The effect layer class can not be used directly and is intented to inherited from to be\r\n * customized per effects.\r\n */\r\nexport abstract class EffectLayer {\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _effectLayerOptions: IEffectLayerOptions;\r\n    private _mergeDrawWrapper: DrawWrapper[];\r\n\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _maxSize: number = 0;\r\n    protected _mainTextureDesiredSize: ISize = { width: 0, height: 0 };\r\n    protected _mainTexture: RenderTargetTexture;\r\n    protected _shouldRender = true;\r\n    protected _postProcesses: PostProcess[] = [];\r\n    protected _textures: BaseTexture[] = [];\r\n    protected _emissiveTextureAndColor: { texture: Nullable<BaseTexture>; color: Color4 } = { texture: null, color: new Color4() };\r\n\r\n    /**\r\n     * The name of the layer\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The clear color of the texture used to generate the glow map.\r\n     */\r\n    @serializeAsColor4()\r\n    public neutralColor: Color4 = new Color4();\r\n\r\n    /**\r\n     * Specifies whether the highlight layer is enabled or not.\r\n     */\r\n    @serialize()\r\n    public isEnabled: boolean = true;\r\n\r\n    /**\r\n     * Gets the camera attached to the layer.\r\n     */\r\n    @serializeAsCameraReference()\r\n    public get camera(): Nullable<Camera> {\r\n        return this._effectLayerOptions.camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group id the layer should render in.\r\n     */\r\n    @serialize()\r\n    public get renderingGroupId(): number {\r\n        return this._effectLayerOptions.renderingGroupId;\r\n    }\r\n    public set renderingGroupId(renderingGroupId: number) {\r\n        this._effectLayerOptions.renderingGroupId = renderingGroupId;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the bounding boxes should be rendered normally or if they should undergo the effect of the layer\r\n     */\r\n    @serialize()\r\n    public disableBoundingBoxesFromEffectLayer = false;\r\n\r\n    /**\r\n     * An event triggered when the effect layer has been disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer is about rendering the main texture with the glowy parts.\r\n     */\r\n    public onBeforeRenderMainTextureObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture is being merged in the scene.\r\n     */\r\n    public onBeforeComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the mesh is rendered into the effect render target.\r\n     */\r\n    public onBeforeRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered after the mesh has been rendered into the effect render target.\r\n     */\r\n    public onAfterRenderMeshToEffect = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * An event triggered when the generated texture has been merged in the scene.\r\n     */\r\n    public onAfterComposeObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * An event triggered when the effect layer changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<EffectLayer>();\r\n\r\n    /**\r\n     * Gets the main texture where the effect is rendered\r\n     */\r\n    public get mainTexture() {\r\n        return this._mainTexture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"EffectLayerSceneComponent\");\r\n    };\r\n\r\n    private _materialForRendering: { [id: string]: [AbstractMesh, Material] } = {};\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes in the layer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the layer when rendering the mesh(es). If undefined is passed, the specific material created by the layer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._mainTexture.setMaterialForRendering(mesh, material);\r\n        if (Array.isArray(mesh)) {\r\n            for (let i = 0; i < mesh.length; ++i) {\r\n                const currentMesh = mesh[i];\r\n                if (!material) {\r\n                    delete this._materialForRendering[currentMesh.uniqueId];\r\n                } else {\r\n                    this._materialForRendering[currentMesh.uniqueId] = [currentMesh, material];\r\n                }\r\n            }\r\n        } else {\r\n            if (!material) {\r\n                delete this._materialForRendering[mesh.uniqueId];\r\n            } else {\r\n                this._materialForRendering[mesh.uniqueId] = [mesh, material];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new effect Layer and references it in the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     */\r\n    constructor(\r\n        /** The Friendly of the effect in the scene */\r\n        name: string,\r\n        scene?: Scene\r\n    ) {\r\n        this.name = name;\r\n\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        EffectLayer._SceneComponentInitialization(this._scene);\r\n\r\n        this._engine = this._scene.getEngine();\r\n        this._maxSize = this._engine.getCaps().maxTextureSize;\r\n        this._scene.effectLayers.push(this);\r\n\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Generate Buffers\r\n        this._generateIndexBuffer();\r\n        this._generateVertexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public abstract getEffectName(): string;\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public abstract isReady(subMesh: SubMesh, useInstances: boolean): boolean;\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     * @returns true if the effect requires stencil during the main canvas render pass.\r\n     */\r\n    public abstract needStencil(): boolean;\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect containing the shader used to merge the effect on the  main canvas\r\n     */\r\n    protected abstract _createMergeEffect(): Effect;\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the effect layer.\r\n     */\r\n    protected abstract _createTextureAndPostProcesses(): void;\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderNum Index of the _internalRender call (0 for the first time _internalRender is called, 1 for the second time, etc. _internalRender is called the number of times returned by _numInternalDraws())\r\n     */\r\n    protected abstract _internalRender(effect: Effect, renderIndex: number): void;\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     */\r\n    protected abstract _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void;\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     */\r\n    public abstract _disposeMesh(mesh: Mesh): void;\r\n\r\n    /**\r\n     * Serializes this layer (Glow or Highlight for example)\r\n     * @returns a serialized layer object\r\n     */\r\n    public abstract serialize?(): any;\r\n\r\n    /**\r\n     * Number of times _internalRender will be called. Some effect layers need to render the mesh several times, so they should override this method with the number of times the mesh should be rendered\r\n     * @returns Number of times a mesh must be rendered in the layer\r\n     */\r\n    protected _numInternalDraws(): number {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Initializes the effect layer with the required options.\r\n     * @param options Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)\r\n     */\r\n    protected _init(options: Partial<IEffectLayerOptions>): void {\r\n        // Adapt options\r\n        this._effectLayerOptions = {\r\n            mainTextureRatio: 0.5,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            ...options,\r\n        };\r\n\r\n        this._setMainTextureSize();\r\n        this._createMainTexture();\r\n        this._createTextureAndPostProcesses();\r\n    }\r\n\r\n    /**\r\n     * Generates the index buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Generates the vertex buffer of the full screen quad blending to the main canvas.\r\n     */\r\n    private _generateVertexBuffer(): void {\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(this._engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Sets the main texture desired size which is the closest power of two\r\n     * of the engine canvas size.\r\n     */\r\n    private _setMainTextureSize(): void {\r\n        if (this._effectLayerOptions.mainTextureFixedSize) {\r\n            this._mainTextureDesiredSize.width = this._effectLayerOptions.mainTextureFixedSize;\r\n            this._mainTextureDesiredSize.height = this._effectLayerOptions.mainTextureFixedSize;\r\n        } else {\r\n            this._mainTextureDesiredSize.width = this._engine.getRenderWidth() * this._effectLayerOptions.mainTextureRatio;\r\n            this._mainTextureDesiredSize.height = this._engine.getRenderHeight() * this._effectLayerOptions.mainTextureRatio;\r\n\r\n            this._mainTextureDesiredSize.width = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize)\r\n                : this._mainTextureDesiredSize.width;\r\n            this._mainTextureDesiredSize.height = this._engine.needPOTTextures\r\n                ? Engine.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize)\r\n                : this._mainTextureDesiredSize.height;\r\n        }\r\n\r\n        this._mainTextureDesiredSize.width = Math.floor(this._mainTextureDesiredSize.width);\r\n        this._mainTextureDesiredSize.height = Math.floor(this._mainTextureDesiredSize.height);\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected _createMainTexture(): void {\r\n        this._mainTexture = new RenderTargetTexture(\r\n            \"EffectLayerMainRTT\",\r\n            {\r\n                width: this._mainTextureDesiredSize.width,\r\n                height: this._mainTextureDesiredSize.height,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            this._effectLayerOptions.mainTextureType\r\n        );\r\n        this._mainTexture.activeCamera = this._effectLayerOptions.camera;\r\n        this._mainTexture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._mainTexture.anisotropicFilteringLevel = 1;\r\n        this._mainTexture.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._mainTexture.renderParticles = false;\r\n        this._mainTexture.renderList = null;\r\n        this._mainTexture.ignoreCameraViewport = true;\r\n\r\n        for (const id in this._materialForRendering) {\r\n            const [mesh, material] = this._materialForRendering[id];\r\n            this._mainTexture.setMaterialForRendering(mesh, material);\r\n        }\r\n\r\n        this._mainTexture.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n                    this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        this._mainTexture.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            this.onBeforeRenderMainTextureObservable.notifyObservers(this);\r\n\r\n            let index: number;\r\n\r\n            const engine = this._scene.getEngine();\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    this._renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                this._renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                this._renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            const previousAlphaMode = engine.getAlphaMode();\r\n\r\n            for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                this._renderSubMesh(transparentSubMeshes.data[index], true);\r\n            }\r\n\r\n            engine.setAlphaMode(previousAlphaMode);\r\n        };\r\n\r\n        this._mainTexture.onClearObservable.add((engine: Engine) => {\r\n            engine.clear(this.neutralColor, true, true, true);\r\n        });\r\n\r\n        // Prevent package size in es6 (getBoundingBoxRenderer might not be present)\r\n        if (this._scene.getBoundingBoxRenderer) {\r\n            const boundingBoxRendererEnabled = this._scene.getBoundingBoxRenderer().enabled;\r\n\r\n            this._mainTexture.onBeforeBindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = !this.disableBoundingBoxesFromEffectLayer && boundingBoxRendererEnabled;\r\n            });\r\n\r\n            this._mainTexture.onAfterUnbindObservable.add(() => {\r\n                this._scene.getBoundingBoxRenderer().enabled = boundingBoxRendererEnabled;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        // Nothing to add by default.\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @param emissiveTexture the associated emissive texture used to generate the glow\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    protected _isReady(subMesh: SubMesh, useInstances: boolean, emissiveTexture: Nullable<BaseTexture>): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\r\n            return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\r\n        }\r\n\r\n        const defines: string[] = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        let uv1 = false;\r\n        let uv2 = false;\r\n\r\n        // Diffuse\r\n        if (material) {\r\n            const needAlphaTest = material.needAlphaTesting();\r\n\r\n            const diffuseTexture = material.getAlphaTestTexture();\r\n            const needAlphaBlendFromDiffuse =\r\n                diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n            if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                defines.push(\"#define DIFFUSE\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && diffuseTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define DIFFUSEUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define DIFFUSEUV1\");\r\n                    uv1 = true;\r\n                }\r\n\r\n                if (needAlphaTest) {\r\n                    defines.push(\"#define ALPHATEST\");\r\n                    defines.push(\"#define ALPHATESTVALUE 0.4\");\r\n                }\r\n                if (!diffuseTexture.gammaSpace) {\r\n                    defines.push(\"#define DIFFUSE_ISLINEAR\");\r\n                }\r\n            }\r\n\r\n            const opacityTexture = (material as any).opacityTexture;\r\n            if (opacityTexture) {\r\n                defines.push(\"#define OPACITY\");\r\n                if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && opacityTexture.coordinatesIndex === 1) {\r\n                    defines.push(\"#define OPACITYUV2\");\r\n                    uv2 = true;\r\n                } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                    defines.push(\"#define OPACITYUV1\");\r\n                    uv1 = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Emissive\r\n        if (emissiveTexture) {\r\n            defines.push(\"#define EMISSIVE\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind) && emissiveTexture.coordinatesIndex === 1) {\r\n                defines.push(\"#define EMISSIVEUV2\");\r\n                uv2 = true;\r\n            } else if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                defines.push(\"#define EMISSIVEUV1\");\r\n                uv1 = true;\r\n            }\r\n            if (!emissiveTexture.gammaSpace) {\r\n                defines.push(\"#define EMISSIVE_ISLINEAR\");\r\n            }\r\n        }\r\n\r\n        // Vertex\r\n        if (mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind) && mesh.hasVertexAlpha && material.transparencyMode !== Material.MATERIAL_OPAQUE) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n            defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (uv1) {\r\n            attribs.push(VertexBuffer.UVKind);\r\n            defines.push(\"#define UV1\");\r\n        }\r\n        if (uv2) {\r\n            attribs.push(VertexBuffer.UV2Kind);\r\n            defines.push(\"#define UV2\");\r\n        }\r\n\r\n        // Bones\r\n        const fallbacks = new EffectFallbacks();\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n\r\n            const skeleton = mesh.skeleton;\r\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\r\n            }\r\n\r\n            if (mesh.numBoneInfluencers > 0) {\r\n                fallbacks.addCPUSkinningFallback(0, mesh);\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        let morphInfluencers = 0;\r\n        if (manager) {\r\n            if (manager.numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                morphInfluencers = manager.numInfluencers;\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + morphInfluencers);\r\n                if (manager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, morphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // ClipPlanes\r\n        prepareDefinesForClipPlanes(material, this._scene, defines);\r\n\r\n        this._addCustomEffectDefines(defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines as string;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"glowColor\",\r\n                \"morphTargetInfluences\",\r\n                \"boneTextureWidth\",\r\n                \"diffuseMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"opacityMatrix\",\r\n                \"opacityIntensity\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n            ];\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this._engine.createEffect(\r\n                    \"glowMapGeneration\",\r\n                    attribs,\r\n                    uniforms,\r\n                    [\"diffuseSampler\", \"emissiveSampler\", \"opacitySampler\", \"boneSampler\", \"morphTargets\"],\r\n                    join,\r\n                    fallbacks,\r\n                    undefined,\r\n                    undefined,\r\n                    { maxSimultaneousMorphTargets: morphInfluencers }\r\n                ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\r\n     */\r\n    public render(): void {\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (!this._postProcesses[i].isReady()) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const numDraws = this._numInternalDraws();\r\n\r\n        // Check\r\n        let isReady = true;\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            let currentEffect = this._mergeDrawWrapper[i];\r\n            if (!currentEffect) {\r\n                currentEffect = this._mergeDrawWrapper[i] = new DrawWrapper(this._engine);\r\n                currentEffect.setEffect(this._createMergeEffect());\r\n            }\r\n            isReady = isReady && currentEffect.effect!.isReady();\r\n        }\r\n\r\n        if (!isReady) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeComposeObservable.notifyObservers(this);\r\n\r\n        const previousAlphaMode = engine.getAlphaMode();\r\n\r\n        for (let i = 0; i < numDraws; ++i) {\r\n            const currentEffect = this._mergeDrawWrapper[i];\r\n\r\n            // Render\r\n            engine.enableEffect(currentEffect);\r\n            engine.setState(false);\r\n\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect.effect!);\r\n\r\n            // Go Blend.\r\n            engine.setAlphaMode(this._effectLayerOptions.alphaBlendingMode);\r\n\r\n            // Blends the map on the main canvas.\r\n            this._internalRender(currentEffect.effect!, i);\r\n        }\r\n\r\n        // Restore Alpha\r\n        engine.setAlphaMode(previousAlphaMode);\r\n\r\n        this.onAfterComposeObservable.notifyObservers(this);\r\n\r\n        // Handle size changes.\r\n        const size = this._mainTexture.getSize();\r\n        this._setMainTextureSize();\r\n        if (\r\n            (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) &&\r\n            this._mainTextureDesiredSize.width !== 0 &&\r\n            this._mainTextureDesiredSize.height !== 0\r\n        ) {\r\n            // Recreate RTT and post processes on size change.\r\n            this.onSizeChangedObservable.notifyObservers(this);\r\n            this._disposeTextureAndPostProcesses();\r\n            this._createMainTexture();\r\n            this._createTextureAndPostProcesses();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the current effect.\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be used\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (this.renderingGroupId === -1 || mesh.renderingGroupId === this.renderingGroupId) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the layer contains information to display, otherwise false.\r\n     * @returns true if the glow layer should be rendered\r\n     */\r\n    public shouldRender(): boolean {\r\n        return this.isEnabled && this._shouldRender;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _shouldRenderMesh(mesh: AbstractMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return !material.needAlphaBlendingForMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderEmissiveTextureForMesh(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh passed in parameter to the generation map.\r\n     * @param subMesh\r\n     * @param enableAlphaMode\r\n     */\r\n    protected _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\r\n        if (!this.shouldRender()) {\r\n            return;\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = subMesh.getReplacementMesh();\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = subMesh.getEffectiveMesh();\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n        if (!material) {\r\n            return;\r\n        }\r\n\r\n        // Do not block in blend mode.\r\n        if (!this._canRenderMesh(renderingMesh, material)) {\r\n            return;\r\n        }\r\n\r\n        // Culling\r\n        let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\r\n        if (mainDeterminant < 0) {\r\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        }\r\n\r\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\r\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\r\n\r\n        // Managing instances\r\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\r\n        if (batch.mustReturn) {\r\n            return;\r\n        }\r\n\r\n        // Early Exit per mesh\r\n        if (!this._shouldRenderMesh(renderingMesh)) {\r\n            return;\r\n        }\r\n\r\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances;\r\n\r\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\r\n\r\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\r\n\r\n        if (this._useMeshMaterial(renderingMesh)) {\r\n            renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\r\n        } else if (this._isReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\r\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n            let drawWrapper = subMesh._getDrawWrapper();\r\n            if (!drawWrapper && renderingMaterial) {\r\n                drawWrapper = renderingMaterial._getDrawWrapper();\r\n            }\r\n\r\n            if (!drawWrapper) {\r\n                return;\r\n            }\r\n\r\n            const effect = drawWrapper.effect!;\r\n\r\n            engine.enableEffect(drawWrapper);\r\n            if (!hardwareInstancedRendering) {\r\n                const fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : material.fillMode;\r\n                renderingMesh._bind(subMesh, effect, fillMode);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                effect.setFloat4(\r\n                    \"glowColor\",\r\n                    this._emissiveTextureAndColor.color.r,\r\n                    this._emissiveTextureAndColor.color.g,\r\n                    this._emissiveTextureAndColor.color.b,\r\n                    this._emissiveTextureAndColor.color.a\r\n                );\r\n            } else {\r\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n            }\r\n\r\n            if (!renderingMaterial) {\r\n                const needAlphaTest = material.needAlphaTesting();\r\n\r\n                const diffuseTexture = material.getAlphaTestTexture();\r\n                const needAlphaBlendFromDiffuse =\r\n                    diffuseTexture && diffuseTexture.hasAlpha && ((material as any).useAlphaFromDiffuseTexture || (material as any)._useAlphaFromAlbedoTexture);\r\n\r\n                if (diffuseTexture && (needAlphaTest || needAlphaBlendFromDiffuse)) {\r\n                    effect.setTexture(\"diffuseSampler\", diffuseTexture);\r\n                    const textureMatrix = diffuseTexture.getTextureMatrix();\r\n\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"diffuseMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                const opacityTexture = (material as any).opacityTexture;\r\n                if (opacityTexture) {\r\n                    effect.setTexture(\"opacitySampler\", opacityTexture);\r\n                    effect.setFloat(\"opacityIntensity\", opacityTexture.level);\r\n                    const textureMatrix = opacityTexture.getTextureMatrix();\r\n                    if (textureMatrix) {\r\n                        effect.setMatrix(\"opacityMatrix\", textureMatrix);\r\n                    }\r\n                }\r\n\r\n                // Glow emissive only\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTextureAndColor.texture);\r\n                    effect.setMatrix(\"emissiveMatrix\", this._emissiveTextureAndColor.texture.getTextureMatrix());\r\n                }\r\n\r\n                // Bones\r\n                if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                    const skeleton = renderingMesh.skeleton;\r\n\r\n                    if (skeleton.isUsingTextureForMatrices) {\r\n                        const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                        if (!boneTexture) {\r\n                            return;\r\n                        }\r\n\r\n                        effect.setTexture(\"boneSampler\", boneTexture);\r\n                        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                    } else {\r\n                        effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                // Morph targets\r\n                MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                    renderingMesh.morphTargetManager._bind(effect);\r\n                }\r\n\r\n                // Alpha mode\r\n                if (enableAlphaMode) {\r\n                    engine.setAlphaMode(material.alphaMode);\r\n                }\r\n\r\n                // Clip planes\r\n                bindClipPlane(effect, material, scene);\r\n            }\r\n\r\n            // Draw\r\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                effect.setMatrix(\"world\", world)\r\n            );\r\n        } else {\r\n            // Need to reset refresh rate of the main map\r\n            this._mainTexture.resetRefreshCounter();\r\n        }\r\n\r\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the required buffers.\r\n     * @internal Internal use only.\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._generateIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Dispose only the render target textures and post process.\r\n     */\r\n    private _disposeTextureAndPostProcesses(): void {\r\n        this._mainTexture.dispose();\r\n\r\n        for (let i = 0; i < this._postProcesses.length; i++) {\r\n            if (this._postProcesses[i]) {\r\n                this._postProcesses[i].dispose();\r\n            }\r\n        }\r\n        this._postProcesses = [];\r\n\r\n        for (let i = 0; i < this._textures.length; i++) {\r\n            if (this._textures[i]) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = [];\r\n    }\r\n\r\n    /**\r\n     * Dispose the highlight layer and free resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        for (const drawWrapper of this._mergeDrawWrapper) {\r\n            drawWrapper.dispose();\r\n        }\r\n        this._mergeDrawWrapper = [];\r\n\r\n        // Clean textures and post processes\r\n        this._disposeTextureAndPostProcesses();\r\n\r\n        // Remove from scene\r\n        const index = this._scene.effectLayers.indexOf(this, 0);\r\n        if (index > -1) {\r\n            this._scene.effectLayers.splice(index, 1);\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onBeforeRenderMainTextureObservable.clear();\r\n        this.onBeforeComposeObservable.clear();\r\n        this.onBeforeRenderMeshToEffect.clear();\r\n        this.onAfterRenderMeshToEffect.clear();\r\n        this.onAfterComposeObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"EffectLayer\";\r\n    }\r\n\r\n    /**\r\n     * Creates an effect layer from parsed effect layer data\r\n     * @param parsedEffectLayer defines effect layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the effect layer information\r\n     * @returns a parsed effect Layer\r\n     */\r\n    public static Parse(parsedEffectLayer: any, scene: Scene, rootUrl: string): EffectLayer {\r\n        const effectLayerType = Tools.Instantiate(parsedEffectLayer.customType);\r\n\r\n        return effectLayerType.Parse(parsedEffectLayer, scene, rootUrl);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}