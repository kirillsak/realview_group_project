{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"./observable.js\";\n/**\n * Represent a list of observers registered to multiple Observables object.\n */\nexport class MultiObserver {\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._observers && this._observables) {\n      for (let index = 0; index < this._observers.length; index++) {\n        this._observables[index].remove(this._observers[index]);\n      }\n    }\n    this._observers = null;\n    this._observables = null;\n  }\n  /**\n   * Raise a callback when one of the observable will notify\n   * @param observables defines a list of observables to watch\n   * @param callback defines the callback to call on notification\n   * @param mask defines the mask used to filter notifications\n   * @param scope defines the current scope used to restore the JS context\n   * @returns the new MultiObserver\n   */\n  static Watch(observables, callback, mask = -1, scope = null) {\n    const result = new MultiObserver();\n    result._observers = new Array();\n    result._observables = observables;\n    for (const observable of observables) {\n      const observer = observable.add(callback, mask, false, scope);\n      if (observer) {\n        result._observers.push(observer);\n      }\n    }\n    return result;\n  }\n}\nObservable.prototype.notifyObserversWithPromise = async function (eventData, mask = -1, target, currentTarget, userInfo) {\n  // create an empty promise\n  let p = Promise.resolve(eventData);\n  // no observers? return this promise.\n  if (!this.observers.length) {\n    return p;\n  }\n  const state = this._eventState;\n  state.mask = mask;\n  state.target = target;\n  state.currentTarget = currentTarget;\n  state.skipNextObservers = false;\n  state.userInfo = userInfo;\n  // execute one callback after another (not using Promise.all, the order is important)\n  this.observers.forEach(obs => {\n    if (state.skipNextObservers) {\n      return;\n    }\n    if (obs._willBeUnregistered) {\n      return;\n    }\n    if (obs.mask & mask) {\n      if (obs.scope) {\n        p = p.then(lastReturnedValue => {\n          state.lastReturnValue = lastReturnedValue;\n          return obs.callback.apply(obs.scope, [eventData, state]);\n        });\n      } else {\n        p = p.then(lastReturnedValue => {\n          state.lastReturnValue = lastReturnedValue;\n          return obs.callback(eventData, state);\n        });\n      }\n      if (obs.unregisterOnNextCall) {\n        this._deferUnregister(obs);\n      }\n    }\n  });\n  // return the eventData\n  await p;\n  return eventData;\n};","map":{"version":3,"mappings":";AAEA,SAASA,UAAU,QAAQ,iBAAe;AAE1C;;;AAGA,OAAM,MAAOC,aAAa;EAItB;;;EAGOC,OAAO;IACV,IAAI,IAAI,CAACC,UAAU,IAAI,IAAI,CAACC,YAAY,EAAE;MACtC,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAACF,UAAU,CAACG,MAAM,EAAED,KAAK,EAAE,EAAE;QACzD,IAAI,CAACD,YAAY,CAACC,KAAK,CAAC,CAACE,MAAM,CAAC,IAAI,CAACJ,UAAU,CAACE,KAAK,CAAC,CAAC;;;IAI/D,IAAI,CAACF,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,YAAY,GAAG,IAAI;EAC5B;EAEA;;;;;;;;EAQO,OAAOI,KAAK,CAAIC,WAA4B,EAAEC,QAAwD,EAAEC,OAAe,CAAC,CAAC,EAAEC,QAAa,IAAI;IAC/I,MAAMC,MAAM,GAAG,IAAIZ,aAAa,EAAK;IAErCY,MAAM,CAACV,UAAU,GAAG,IAAIW,KAAK,EAAe;IAC5CD,MAAM,CAACT,YAAY,GAAGK,WAAW;IAEjC,KAAK,MAAMM,UAAU,IAAIN,WAAW,EAAE;MAClC,MAAMO,QAAQ,GAAGD,UAAU,CAACE,GAAG,CAACP,QAAQ,EAAEC,IAAI,EAAE,KAAK,EAAEC,KAAK,CAAC;MAC7D,IAAII,QAAQ,EAAE;QACVH,MAAM,CAACV,UAAU,CAACe,IAAI,CAACF,QAAQ,CAAC;;;IAIxC,OAAOH,MAAM;EACjB;;AAuBJb,UAAU,CAACmB,SAAS,CAACC,0BAA0B,GAAG,gBAAmBC,SAAY,EAAEV,OAAe,CAAC,CAAC,EAAEW,MAAY,EAAEC,aAAmB,EAAEC,QAAc;EACnJ;EACA,IAAIC,CAAC,GAAiBC,OAAO,CAACC,OAAO,CAACN,SAAS,CAAC;EAEhD;EACA,IAAI,CAAC,IAAI,CAACO,SAAS,CAACtB,MAAM,EAAE;IACxB,OAAOmB,CAAC;;EAGZ,MAAMI,KAAK,GAAG,IAAI,CAACC,WAAW;EAC9BD,KAAK,CAAClB,IAAI,GAAGA,IAAI;EACjBkB,KAAK,CAACP,MAAM,GAAGA,MAAM;EACrBO,KAAK,CAACN,aAAa,GAAGA,aAAa;EACnCM,KAAK,CAACE,iBAAiB,GAAG,KAAK;EAC/BF,KAAK,CAACL,QAAQ,GAAGA,QAAQ;EAEzB;EACA,IAAI,CAACI,SAAS,CAACI,OAAO,CAAEC,GAAG,IAAI;IAC3B,IAAIJ,KAAK,CAACE,iBAAiB,EAAE;MACzB;;IAEJ,IAAIE,GAAG,CAACC,mBAAmB,EAAE;MACzB;;IAEJ,IAAID,GAAG,CAACtB,IAAI,GAAGA,IAAI,EAAE;MACjB,IAAIsB,GAAG,CAACrB,KAAK,EAAE;QACXa,CAAC,GAAGA,CAAC,CAACU,IAAI,CAAEC,iBAAiB,IAAI;UAC7BP,KAAK,CAACQ,eAAe,GAAGD,iBAAiB;UACzC,OAAOH,GAAG,CAACvB,QAAQ,CAAC4B,KAAK,CAACL,GAAG,CAACrB,KAAK,EAAE,CAACS,SAAS,EAAEQ,KAAK,CAAC,CAAC;QAC5D,CAAC,CAAC;OACL,MAAM;QACHJ,CAAC,GAAGA,CAAC,CAACU,IAAI,CAAEC,iBAAiB,IAAI;UAC7BP,KAAK,CAACQ,eAAe,GAAGD,iBAAiB;UACzC,OAAOH,GAAG,CAACvB,QAAQ,CAACW,SAAS,EAAEQ,KAAK,CAAC;QACzC,CAAC,CAAC;;MAEN,IAAII,GAAG,CAACM,oBAAoB,EAAE;QAC1B,IAAI,CAACC,gBAAgB,CAACP,GAAG,CAAC;;;EAGtC,CAAC,CAAC;EAEF;EACA,MAAMR,CAAC;EACP,OAAOJ,SAAS;AACpB,CAAC","names":["Observable","MultiObserver","dispose","_observers","_observables","index","length","remove","Watch","observables","callback","mask","scope","result","Array","observable","observer","add","push","prototype","notifyObserversWithPromise","eventData","target","currentTarget","userInfo","p","Promise","resolve","observers","state","_eventState","skipNextObservers","forEach","obs","_willBeUnregistered","then","lastReturnedValue","lastReturnValue","apply","unregisterOnNextCall","_deferUnregister"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/observable.extensions.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Observer, EventState } from \"./observable\";\r\nimport { Observable } from \"./observable\";\r\n\r\n/**\r\n * Represent a list of observers registered to multiple Observables object.\r\n */\r\nexport class MultiObserver<T> {\r\n    private _observers: Nullable<Observer<T>[]>;\r\n    private _observables: Nullable<Observable<T>[]>;\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._observers && this._observables) {\r\n            for (let index = 0; index < this._observers.length; index++) {\r\n                this._observables[index].remove(this._observers[index]);\r\n            }\r\n        }\r\n\r\n        this._observers = null;\r\n        this._observables = null;\r\n    }\r\n\r\n    /**\r\n     * Raise a callback when one of the observable will notify\r\n     * @param observables defines a list of observables to watch\r\n     * @param callback defines the callback to call on notification\r\n     * @param mask defines the mask used to filter notifications\r\n     * @param scope defines the current scope used to restore the JS context\r\n     * @returns the new MultiObserver\r\n     */\r\n    public static Watch<T>(observables: Observable<T>[], callback: (eventData: T, eventState: EventState) => void, mask: number = -1, scope: any = null): MultiObserver<T> {\r\n        const result = new MultiObserver<T>();\r\n\r\n        result._observers = new Array<Observer<T>>();\r\n        result._observables = observables;\r\n\r\n        for (const observable of observables) {\r\n            const observer = observable.add(callback, mask, false, scope);\r\n            if (observer) {\r\n                result._observers.push(observer);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\ndeclare module \"./observable\" {\r\n    export interface Observable<T> {\r\n        /**\r\n         * Calling this will execute each callback, expecting it to be a promise or return a value.\r\n         * If at any point in the chain one function fails, the promise will fail and the execution will not continue.\r\n         * This is useful when a chain of events (sometimes async events) is needed to initialize a certain object\r\n         * and it is crucial that all callbacks will be executed.\r\n         * The order of the callbacks is kept, callbacks are not executed parallel.\r\n         *\r\n         * @param eventData The data to be sent to each callback\r\n         * @param mask is used to filter observers defaults to -1\r\n         * @param target defines the callback target (see EventState)\r\n         * @param currentTarget defines he current object in the bubbling phase\r\n         * @param userInfo defines any user info to send to observers\r\n         * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.\r\n         */\r\n        notifyObserversWithPromise(eventData: T, mask?: number, target?: any, currentTarget?: any, userInfo?: any): Promise<T>;\r\n    }\r\n}\r\n\r\nObservable.prototype.notifyObserversWithPromise = async function <T>(eventData: T, mask: number = -1, target?: any, currentTarget?: any, userInfo?: any): Promise<T> {\r\n    // create an empty promise\r\n    let p: Promise<any> = Promise.resolve(eventData);\r\n\r\n    // no observers? return this promise.\r\n    if (!this.observers.length) {\r\n        return p;\r\n    }\r\n\r\n    const state = this._eventState;\r\n    state.mask = mask;\r\n    state.target = target;\r\n    state.currentTarget = currentTarget;\r\n    state.skipNextObservers = false;\r\n    state.userInfo = userInfo;\r\n\r\n    // execute one callback after another (not using Promise.all, the order is important)\r\n    this.observers.forEach((obs) => {\r\n        if (state.skipNextObservers) {\r\n            return;\r\n        }\r\n        if (obs._willBeUnregistered) {\r\n            return;\r\n        }\r\n        if (obs.mask & mask) {\r\n            if (obs.scope) {\r\n                p = p.then((lastReturnedValue) => {\r\n                    state.lastReturnValue = lastReturnedValue;\r\n                    return obs.callback.apply(obs.scope, [eventData, state]);\r\n                });\r\n            } else {\r\n                p = p.then((lastReturnedValue) => {\r\n                    state.lastReturnValue = lastReturnedValue;\r\n                    return obs.callback(eventData, state);\r\n                });\r\n            }\r\n            if (obs.unregisterOnNextCall) {\r\n                this._deferUnregister(obs);\r\n            }\r\n        }\r\n    });\r\n\r\n    // return the eventData\r\n    await p;\r\n    return eventData;\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}