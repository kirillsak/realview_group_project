{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\n\n/**\n * Wrapper around a render target (either single or multi textures)\n */\nexport class RenderTargetWrapper {\n  /**\n   * Initializes the render target wrapper\n   * @param isMulti true if the wrapper is a multi render target\n   * @param isCube true if the wrapper should render to a cube texture\n   * @param size size of the render target (width/height/layers)\n   * @param engine engine used to create the render target\n   */\n  constructor(isMulti, isCube, size, engine) {\n    this._textures = null;\n    /** @internal */\n    this._samples = 1;\n    /** @internal */\n    this._attachments = null;\n    /** @internal */\n    this._generateStencilBuffer = false;\n    /** @internal */\n    this._generateDepthBuffer = false;\n    /** @internal */\n    this._depthStencilTextureWithStencil = false;\n    this._isMulti = isMulti;\n    this._isCube = isCube;\n    this._size = size;\n    this._engine = engine;\n    this._depthStencilTexture = null;\n  }\n  /**\n   * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\n   */\n  get depthStencilTexture() {\n    return this._depthStencilTexture;\n  }\n  /**\n   * Indicates if the depth/stencil texture has a stencil aspect\n   */\n  get depthStencilTextureWithStencil() {\n    return this._depthStencilTextureWithStencil;\n  }\n  /**\n   * Defines if the render target wrapper is for a cube texture or if false a 2d texture\n   */\n  get isCube() {\n    return this._isCube;\n  }\n  /**\n   * Defines if the render target wrapper is for a single or multi target render wrapper\n   */\n  get isMulti() {\n    return this._isMulti;\n  }\n  /**\n   * Defines if the render target wrapper is for a single or an array of textures\n   */\n  get is2DArray() {\n    return this.layers > 0;\n  }\n  /**\n   * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\n   */\n  get size() {\n    return this.width;\n  }\n  /**\n   * Gets the width of the render target wrapper\n   */\n  get width() {\n    return this._size.width || this._size;\n  }\n  /**\n   * Gets the height of the render target wrapper\n   */\n  get height() {\n    return this._size.height || this._size;\n  }\n  /**\n   * Gets the number of layers of the render target wrapper (only used if is2DArray is true)\n   */\n  get layers() {\n    return this._size.layers || 0;\n  }\n  /**\n   * Gets the render texture. If this is a multi render target, gets the first texture\n   */\n  get texture() {\n    var _a, _b;\n    return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n  }\n  /**\n   * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\n   */\n  get textures() {\n    return this._textures;\n  }\n  /**\n   * Gets the sample count of the render target\n   */\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * Sets the sample count of the render target\n   * @param value sample count\n   * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\n   * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\n   * @returns the sample count that has been set\n   */\n  setSamples(value, initializeBuffers = true, force = false) {\n    if (this.samples === value && !force) {\n      return value;\n    }\n    const result = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);\n    this._samples = value;\n    return result;\n  }\n  /**\n   * Sets the render target texture(s)\n   * @param textures texture(s) to set\n   */\n  setTextures(textures) {\n    if (Array.isArray(textures)) {\n      this._textures = textures;\n    } else if (textures) {\n      this._textures = [textures];\n    } else {\n      this._textures = null;\n    }\n  }\n  /**\n   * Set a texture in the textures array\n   * @param texture the texture to set\n   * @param index the index in the textures array to set\n   * @param disposePrevious If this function should dispose the previous texture\n   */\n  setTexture(texture, index = 0, disposePrevious = true) {\n    if (!this._textures) {\n      this._textures = [];\n    }\n    if (this._textures[index] && disposePrevious) {\n      this._textures[index].dispose();\n    }\n    this._textures[index] = texture;\n  }\n  /**\n   * Creates the depth/stencil texture\n   * @param comparisonFunction Comparison function to use for the texture\n   * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\n   * @param generateStencil true if the stencil aspect should also be created\n   * @param samples sample count to use when creating the texture\n   * @param format format of the depth texture\n   * @returns the depth/stencil created texture\n   */\n  createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14) {\n    var _a;\n    (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._depthStencilTextureWithStencil = generateStencil;\n    this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {\n      bilinearFiltering,\n      comparisonFunction,\n      generateStencil,\n      isCube: this._isCube,\n      samples,\n      depthTextureFormat: format\n    }, this);\n    return this._depthStencilTexture;\n  }\n  /**\n   * Shares the depth buffer of this render target with another render target.\n   * @internal\n   * @param renderTarget Destination renderTarget\n   */\n  _shareDepth(renderTarget) {\n    if (this._depthStencilTexture) {\n      if (renderTarget._depthStencilTexture) {\n        renderTarget._depthStencilTexture.dispose();\n      }\n      renderTarget._depthStencilTexture = this._depthStencilTexture;\n      this._depthStencilTexture.incrementReferences();\n    }\n  }\n  /**\n   * @internal\n   */\n  _swapAndDie(target) {\n    if (this.texture) {\n      this.texture._swapAndDie(target);\n    }\n    this._textures = null;\n    this.dispose(true);\n  }\n  _cloneRenderTargetWrapper() {\n    var _a, _b, _c, _d, _e, _f;\n    let rtw = null;\n    if (this._isMulti) {\n      const textureArray = this.textures;\n      if (textureArray && textureArray.length > 0) {\n        let generateDepthTexture = false;\n        let textureCount = textureArray.length;\n        const lastTextureSource = textureArray[textureArray.length - 1]._source;\n        if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\n          generateDepthTexture = true;\n          textureCount--;\n        }\n        const samplingModes = [];\n        const types = [];\n        for (let i = 0; i < textureCount; ++i) {\n          const texture = textureArray[i];\n          samplingModes.push(texture.samplingMode);\n          types.push(texture.type);\n        }\n        const optionsMRT = {\n          samplingModes,\n          generateMipMaps: textureArray[0].generateMipMaps,\n          generateDepthBuffer: this._generateDepthBuffer,\n          generateStencilBuffer: this._generateStencilBuffer,\n          generateDepthTexture,\n          types,\n          textureCount\n        };\n        const size = {\n          width: this.width,\n          height: this.height\n        };\n        rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\n      }\n    } else {\n      const options = {};\n      options.generateDepthBuffer = this._generateDepthBuffer;\n      options.generateMipMaps = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) !== null && _b !== void 0 ? _b : false;\n      options.generateStencilBuffer = this._generateStencilBuffer;\n      options.samplingMode = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.samplingMode;\n      options.type = (_d = this.texture) === null || _d === void 0 ? void 0 : _d.type;\n      options.format = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.format;\n      if (this.isCube) {\n        rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\n      } else {\n        const size = {\n          width: this.width,\n          height: this.height,\n          layers: this.is2DArray ? (_f = this.texture) === null || _f === void 0 ? void 0 : _f.depth : undefined\n        };\n        rtw = this._engine.createRenderTargetTexture(size, options);\n      }\n      rtw.texture.isReady = true;\n    }\n    return rtw;\n  }\n  _swapRenderTargetWrapper(target) {\n    if (this._textures && target._textures) {\n      for (let i = 0; i < this._textures.length; ++i) {\n        this._textures[i]._swapAndDie(target._textures[i], false);\n        target._textures[i].isReady = true;\n      }\n    }\n    if (this._depthStencilTexture && target._depthStencilTexture) {\n      this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\n      target._depthStencilTexture.isReady = true;\n    }\n    this._textures = null;\n    this._depthStencilTexture = null;\n  }\n  /** @internal */\n  _rebuild() {\n    const rtw = this._cloneRenderTargetWrapper();\n    if (!rtw) {\n      return;\n    }\n    if (this._depthStencilTexture) {\n      const samplingMode = this._depthStencilTexture.samplingMode;\n      const bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;\n      rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\n    }\n    if (this.samples > 1) {\n      rtw.setSamples(this.samples);\n    }\n    rtw._swapRenderTargetWrapper(this);\n    rtw.dispose();\n  }\n  /**\n   * Releases the internal render textures\n   */\n  releaseTextures() {\n    var _a, _b;\n    if (this._textures) {\n      for (let i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {\n        this._textures[i].dispose();\n      }\n    }\n    this._textures = null;\n  }\n  /**\n   * Disposes the whole render target wrapper\n   * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\n   */\n  dispose(disposeOnlyFramebuffers = false) {\n    var _a;\n    if (!disposeOnlyFramebuffers) {\n      (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._depthStencilTexture = null;\n      this.releaseTextures();\n    }\n    this._engine._releaseRenderTargetWrapper(this);\n  }\n}","map":{"version":3,"mappings":"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","names":["InternalTextureSource","RenderTargetWrapper","constructor","isMulti","isCube","size","engine","_isMulti","_isCube","_size","_engine","_depthStencilTexture","depthStencilTexture","depthStencilTextureWithStencil","_depthStencilTextureWithStencil","is2DArray","layers","width","height","texture","_textures","textures","samples","_samples","setSamples","value","initializeBuffers","force","result","updateMultipleRenderTargetTextureSampleCount","updateRenderTargetTextureSampleCount","setTextures","Array","isArray","setTexture","index","disposePrevious","dispose","createDepthStencilTexture","comparisonFunction","bilinearFiltering","generateStencil","format","depthTextureFormat","_shareDepth","renderTarget","incrementReferences","_swapAndDie","target","_cloneRenderTargetWrapper","rtw","textureArray","length","generateDepthTexture","textureCount","lastTextureSource","_source","Depth","DepthStencil","samplingModes","types","i","push","samplingMode","type","optionsMRT","generateMipMaps","generateDepthBuffer","_generateDepthBuffer","generateStencilBuffer","_generateStencilBuffer","createMultipleRenderTarget","options","createRenderTargetCubeTexture","depth","undefined","createRenderTargetTexture","isReady","_swapRenderTargetWrapper","_rebuild","bilinear","_comparisonFunction","releaseTextures","disposeOnlyFramebuffers","_releaseRenderTargetWrapper"],"sourceRoot":"","sources":["../../../../lts/core/generated/Engines/renderTargetWrapper.ts"],"sourcesContent":["import type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { RenderTargetCreationOptions, TextureSize } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Constants } from \"./constants\";\r\nimport type { ThinEngine } from \"./thinEngine\";\r\n\r\n/**\r\n * An interface enforcing the renderTarget accessor to used by render target textures.\r\n */\r\nexport interface IRenderTargetTexture {\r\n    /**\r\n     * Entry point to access the wrapper on a texture.\r\n     */\r\n    renderTarget: Nullable<RenderTargetWrapper>;\r\n}\r\n\r\n/**\r\n * Wrapper around a render target (either single or multi textures)\r\n */\r\nexport class RenderTargetWrapper {\r\n    protected _engine: ThinEngine;\r\n    private _size: TextureSize;\r\n    private _isCube: boolean;\r\n    private _isMulti: boolean;\r\n    private _textures: Nullable<InternalTexture[]> = null;\r\n    /** @internal */\r\n    public _samples = 1;\r\n\r\n    /** @internal */\r\n    public _attachments: Nullable<number[]> = null;\r\n    /** @internal */\r\n    public _generateStencilBuffer: boolean = false;\r\n    /** @internal */\r\n    public _generateDepthBuffer: boolean = false;\r\n\r\n    /** @internal */\r\n    public _depthStencilTexture: Nullable<InternalTexture>;\r\n    /** @internal */\r\n    public _depthStencilTextureWithStencil: boolean = false;\r\n\r\n    /**\r\n     * Gets the depth/stencil texture (if created by a createDepthStencilTexture() call)\r\n     */\r\n    public get depthStencilTexture() {\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the depth/stencil texture has a stencil aspect\r\n     */\r\n    public get depthStencilTextureWithStencil() {\r\n        return this._depthStencilTextureWithStencil;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a cube texture or if false a 2d texture\r\n     */\r\n    public get isCube(): boolean {\r\n        return this._isCube;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or multi target render wrapper\r\n     */\r\n    public get isMulti(): boolean {\r\n        return this._isMulti;\r\n    }\r\n\r\n    /**\r\n     * Defines if the render target wrapper is for a single or an array of textures\r\n     */\r\n    public get is2DArray(): boolean {\r\n        return this.layers > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the size of the render target wrapper (used for cubes, as width=height in this case)\r\n     */\r\n    public get size(): number {\r\n        return this.width;\r\n    }\r\n\r\n    /**\r\n     * Gets the width of the render target wrapper\r\n     */\r\n    public get width(): number {\r\n        return (<{ width: number; height: number }>this._size).width || <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the height of the render target wrapper\r\n     */\r\n    public get height(): number {\r\n        return (<{ width: number; height: number }>this._size).height || <number>this._size;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of layers of the render target wrapper (only used if is2DArray is true)\r\n     */\r\n    public get layers(): number {\r\n        return (<{ width: number; height: number; layers?: number }>this._size).layers || 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the render texture. If this is a multi render target, gets the first texture\r\n     */\r\n    public get texture(): Nullable<InternalTexture> {\r\n        return this._textures?.[0] ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of render textures. If we are not in a multi render target, the list will be null (use the texture getter instead)\r\n     */\r\n    public get textures(): Nullable<InternalTexture[]> {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the sample count of the render target\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * Sets the sample count of the render target\r\n     * @param value sample count\r\n     * @param initializeBuffers If set to true, the engine will make an initializing call to drawBuffers (only used when isMulti=true).\r\n     * @param force true to force calling the update sample count engine function even if the current sample count is equal to value\r\n     * @returns the sample count that has been set\r\n     */\r\n    public setSamples(value: number, initializeBuffers = true, force = false): number {\r\n        if (this.samples === value && !force) {\r\n            return value;\r\n        }\r\n\r\n        const result = this._isMulti\r\n            ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers)\r\n            : this._engine.updateRenderTargetTextureSampleCount(this, value);\r\n        this._samples = value;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Initializes the render target wrapper\r\n     * @param isMulti true if the wrapper is a multi render target\r\n     * @param isCube true if the wrapper should render to a cube texture\r\n     * @param size size of the render target (width/height/layers)\r\n     * @param engine engine used to create the render target\r\n     */\r\n    constructor(isMulti: boolean, isCube: boolean, size: TextureSize, engine: ThinEngine) {\r\n        this._isMulti = isMulti;\r\n        this._isCube = isCube;\r\n        this._size = size;\r\n        this._engine = engine;\r\n        this._depthStencilTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Sets the render target texture(s)\r\n     * @param textures texture(s) to set\r\n     */\r\n    public setTextures(textures: Nullable<InternalTexture> | Nullable<InternalTexture[]>): void {\r\n        if (Array.isArray(textures)) {\r\n            this._textures = textures;\r\n        } else if (textures) {\r\n            this._textures = [textures];\r\n        } else {\r\n            this._textures = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the textures array\r\n     * @param texture the texture to set\r\n     * @param index the index in the textures array to set\r\n     * @param disposePrevious If this function should dispose the previous texture\r\n     */\r\n    public setTexture(texture: InternalTexture, index: number = 0, disposePrevious: boolean = true): void {\r\n        if (!this._textures) {\r\n            this._textures = [];\r\n        }\r\n        if (this._textures[index] && disposePrevious) {\r\n            this._textures[index].dispose();\r\n        }\r\n\r\n        this._textures[index] = texture;\r\n    }\r\n\r\n    /**\r\n     * Creates the depth/stencil texture\r\n     * @param comparisonFunction Comparison function to use for the texture\r\n     * @param bilinearFiltering true if bilinear filtering should be used when sampling the texture\r\n     * @param generateStencil true if the stencil aspect should also be created\r\n     * @param samples sample count to use when creating the texture\r\n     * @param format format of the depth texture\r\n     * @returns the depth/stencil created texture\r\n     */\r\n    public createDepthStencilTexture(\r\n        comparisonFunction: number = 0,\r\n        bilinearFiltering: boolean = true,\r\n        generateStencil: boolean = false,\r\n        samples: number = 1,\r\n        format: number = Constants.TEXTUREFORMAT_DEPTH32_FLOAT\r\n    ): InternalTexture {\r\n        this._depthStencilTexture?.dispose();\r\n\r\n        this._depthStencilTextureWithStencil = generateStencil;\r\n        this._depthStencilTexture = this._engine.createDepthStencilTexture(\r\n            this._size,\r\n            {\r\n                bilinearFiltering,\r\n                comparisonFunction,\r\n                generateStencil,\r\n                isCube: this._isCube,\r\n                samples,\r\n                depthTextureFormat: format,\r\n            },\r\n            this\r\n        );\r\n\r\n        return this._depthStencilTexture;\r\n    }\r\n\r\n    /**\r\n     * Shares the depth buffer of this render target with another render target.\r\n     * @internal\r\n     * @param renderTarget Destination renderTarget\r\n     */\r\n    public _shareDepth(renderTarget: RenderTargetWrapper): void {\r\n        if (this._depthStencilTexture) {\r\n            if (renderTarget._depthStencilTexture) {\r\n                renderTarget._depthStencilTexture.dispose();\r\n            }\r\n\r\n            renderTarget._depthStencilTexture = this._depthStencilTexture;\r\n            this._depthStencilTexture.incrementReferences();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _swapAndDie(target: InternalTexture): void {\r\n        if (this.texture) {\r\n            this.texture._swapAndDie(target);\r\n        }\r\n        this._textures = null;\r\n        this.dispose(true);\r\n    }\r\n\r\n    protected _cloneRenderTargetWrapper(): Nullable<RenderTargetWrapper> {\r\n        let rtw: Nullable<RenderTargetWrapper> = null;\r\n\r\n        if (this._isMulti) {\r\n            const textureArray = this.textures;\r\n            if (textureArray && textureArray.length > 0) {\r\n                let generateDepthTexture = false;\r\n                let textureCount = textureArray.length;\r\n\r\n                const lastTextureSource = textureArray[textureArray.length - 1]._source;\r\n                if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {\r\n                    generateDepthTexture = true;\r\n                    textureCount--;\r\n                }\r\n\r\n                const samplingModes: number[] = [];\r\n                const types: number[] = [];\r\n\r\n                for (let i = 0; i < textureCount; ++i) {\r\n                    const texture = textureArray[i];\r\n\r\n                    samplingModes.push(texture.samplingMode);\r\n                    types.push(texture.type);\r\n                }\r\n\r\n                const optionsMRT = {\r\n                    samplingModes,\r\n                    generateMipMaps: textureArray[0].generateMipMaps,\r\n                    generateDepthBuffer: this._generateDepthBuffer,\r\n                    generateStencilBuffer: this._generateStencilBuffer,\r\n                    generateDepthTexture,\r\n                    types,\r\n                    textureCount,\r\n                };\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                };\r\n\r\n                rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);\r\n            }\r\n        } else {\r\n            const options: RenderTargetCreationOptions = {};\r\n\r\n            options.generateDepthBuffer = this._generateDepthBuffer;\r\n            options.generateMipMaps = this.texture?.generateMipMaps ?? false;\r\n            options.generateStencilBuffer = this._generateStencilBuffer;\r\n            options.samplingMode = this.texture?.samplingMode;\r\n            options.type = this.texture?.type;\r\n            options.format = this.texture?.format;\r\n\r\n            if (this.isCube) {\r\n                rtw = this._engine.createRenderTargetCubeTexture(this.width, options);\r\n            } else {\r\n                const size = {\r\n                    width: this.width,\r\n                    height: this.height,\r\n                    layers: this.is2DArray ? this.texture?.depth : undefined,\r\n                };\r\n\r\n                rtw = this._engine.createRenderTargetTexture(size, options);\r\n            }\r\n            rtw.texture!.isReady = true;\r\n        }\r\n\r\n        return rtw;\r\n    }\r\n\r\n    protected _swapRenderTargetWrapper(target: RenderTargetWrapper): void {\r\n        if (this._textures && target._textures) {\r\n            for (let i = 0; i < this._textures.length; ++i) {\r\n                this._textures[i]._swapAndDie(target._textures[i], false);\r\n                target._textures[i].isReady = true;\r\n            }\r\n        }\r\n        if (this._depthStencilTexture && target._depthStencilTexture) {\r\n            this._depthStencilTexture._swapAndDie(target._depthStencilTexture);\r\n            target._depthStencilTexture.isReady = true;\r\n        }\r\n\r\n        this._textures = null;\r\n        this._depthStencilTexture = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const rtw = this._cloneRenderTargetWrapper();\r\n        if (!rtw) {\r\n            return;\r\n        }\r\n\r\n        if (this._depthStencilTexture) {\r\n            const samplingMode = this._depthStencilTexture.samplingMode;\r\n            const bilinear =\r\n                samplingMode === Constants.TEXTURE_BILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_TRILINEAR_SAMPLINGMODE ||\r\n                samplingMode === Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n            rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);\r\n        }\r\n\r\n        if (this.samples > 1) {\r\n            rtw.setSamples(this.samples);\r\n        }\r\n\r\n        rtw._swapRenderTargetWrapper(this);\r\n        rtw.dispose();\r\n    }\r\n\r\n    /**\r\n     * Releases the internal render textures\r\n     */\r\n    public releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures?.length ?? 0; ++i) {\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n        this._textures = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the whole render target wrapper\r\n     * @param disposeOnlyFramebuffers true if only the frame buffers should be released (used for the WebGL engine). If false, all the textures will also be released\r\n     */\r\n    public dispose(disposeOnlyFramebuffers = false): void {\r\n        if (!disposeOnlyFramebuffers) {\r\n            this._depthStencilTexture?.dispose();\r\n            this._depthStencilTexture = null;\r\n            this.releaseTextures();\r\n        }\r\n\r\n        this._engine._releaseRenderTargetWrapper(this);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}