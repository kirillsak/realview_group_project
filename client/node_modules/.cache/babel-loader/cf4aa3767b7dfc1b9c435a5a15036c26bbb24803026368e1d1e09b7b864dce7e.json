{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SmartArrayNoDuplicate } from \"../../Misc/smartArray.js\";\nimport { OctreeBlock } from \"./octreeBlock.js\";\n/**\n * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n */\nexport class Octree {\n  /**\n   * Creates a octree\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\n   * @param creationFunc function to be used to instantiate the octree\n   * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)\n   * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)\n   */\n  constructor(creationFunc, maxBlockCapacity, /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */\n  maxDepth = 2) {\n    this.maxDepth = maxDepth;\n    /**\n     * Content stored in the octree\n     */\n    this.dynamicContent = new Array();\n    this._maxBlockCapacity = maxBlockCapacity || 64;\n    this._selectionContent = new SmartArrayNoDuplicate(1024);\n    this._creationFunc = creationFunc;\n  }\n  // Methods\n  /**\n   * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters\n   * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n   * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n   * @param entries meshes to be added to the octree blocks\n   */\n  update(worldMin, worldMax, entries) {\n    OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\n  }\n  /**\n   * Adds a mesh to the octree\n   * @param entry Mesh to add to the octree\n   */\n  addMesh(entry) {\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.addEntry(entry);\n    }\n  }\n  /**\n   * Remove an element from the octree\n   * @param entry defines the element to remove\n   */\n  removeMesh(entry) {\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.removeEntry(entry);\n    }\n  }\n  /**\n   * Selects an array of meshes within the frustum\n   * @param frustumPlanes The frustum planes to use which will select all meshes within it\n   * @param allowDuplicate If duplicate objects are allowed in the resulting object array\n   * @returns array of meshes within the frustum\n   */\n  select(frustumPlanes, allowDuplicate) {\n    this._selectionContent.reset();\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.select(frustumPlanes, this._selectionContent, allowDuplicate);\n    }\n    if (allowDuplicate) {\n      this._selectionContent.concat(this.dynamicContent);\n    } else {\n      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n    }\n    return this._selectionContent;\n  }\n  /**\n   * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array\n   * @param sphereCenter defines the bounding sphere center\n   * @param sphereRadius defines the bounding sphere radius\n   * @param allowDuplicate defines if the selection array can contains duplicated entries\n   * @returns an array of objects that intersect the sphere\n   */\n  intersects(sphereCenter, sphereRadius, allowDuplicate) {\n    this._selectionContent.reset();\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\n    }\n    if (allowDuplicate) {\n      this._selectionContent.concat(this.dynamicContent);\n    } else {\n      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n    }\n    return this._selectionContent;\n  }\n  /**\n   * Test if the octree intersect with the given ray and if yes, then add its content to resulting array\n   * @param ray defines the ray to test with\n   * @returns array of intersected objects\n   */\n  intersectsRay(ray) {\n    this._selectionContent.reset();\n    for (let index = 0; index < this.blocks.length; index++) {\n      const block = this.blocks[index];\n      block.intersectsRay(ray, this._selectionContent);\n    }\n    this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n    return this._selectionContent;\n  }\n}\n/**\n * Adds a mesh into the octree block if it intersects the block\n * @param entry\n * @param block\n */\nOctree.CreationFuncForMeshes = (entry, block) => {\n  const boundingInfo = entry.getBoundingInfo();\n  if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n    block.entries.push(entry);\n  }\n};\n/**\n * Adds a submesh into the octree block if it intersects the block\n * @param entry\n * @param block\n */\nOctree.CreationFuncForSubMeshes = (entry, block) => {\n  const boundingInfo = entry.getBoundingInfo();\n  if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n    block.entries.push(entry);\n  }\n};","map":{"version":3,"mappings":"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","names":["SmartArrayNoDuplicate","OctreeBlock","Octree","constructor","creationFunc","maxBlockCapacity","maxDepth","Array","_maxBlockCapacity","_selectionContent","_creationFunc","update","worldMin","worldMax","entries","_CreateBlocks","addMesh","entry","index","blocks","length","block","addEntry","removeMesh","removeEntry","select","frustumPlanes","allowDuplicate","reset","concat","dynamicContent","concatWithNoDuplicate","intersects","sphereCenter","sphereRadius","intersectsRay","ray","boundingInfo","getBoundingInfo","isBlocked","boundingBox","intersectsMinMax","minPoint","maxPoint","push"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Culling/Octrees/octree.ts"],"sourcesContent":["import type { SmartArray } from \"../../Misc/smartArray\";\r\nimport { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { OctreeBlock } from \"./octreeBlock\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\n\r\n/**\r\n * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nexport class Octree<T> {\r\n    /**\r\n     * Blocks within the octree containing objects\r\n     */\r\n    public blocks: Array<OctreeBlock<T>>;\r\n    /**\r\n     * Content stored in the octree\r\n     */\r\n    public dynamicContent = new Array<T>();\r\n\r\n    private _maxBlockCapacity: number;\r\n    private _selectionContent: SmartArrayNoDuplicate<T>;\r\n    private _creationFunc: (entry: T, block: OctreeBlock<T>) => void;\r\n\r\n    /**\r\n     * Creates a octree\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n     * @param creationFunc function to be used to instantiate the octree\r\n     * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)\r\n     * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)\r\n     */\r\n    constructor(\r\n        creationFunc: (entry: T, block: OctreeBlock<T>) => void,\r\n        maxBlockCapacity?: number,\r\n        /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */\r\n        public maxDepth = 2\r\n    ) {\r\n        this._maxBlockCapacity = maxBlockCapacity || 64;\r\n        this._selectionContent = new SmartArrayNoDuplicate<T>(1024);\r\n        this._creationFunc = creationFunc;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters\r\n     * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n     * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n     * @param entries meshes to be added to the octree blocks\r\n     */\r\n    public update(worldMin: Vector3, worldMax: Vector3, entries: T[]): void {\r\n        OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh to the octree\r\n     * @param entry Mesh to add to the octree\r\n     */\r\n    public addMesh(entry: T): void {\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.addEntry(entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an element from the octree\r\n     * @param entry defines the element to remove\r\n     */\r\n    public removeMesh(entry: T): void {\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.removeEntry(entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Selects an array of meshes within the frustum\r\n     * @param frustumPlanes The frustum planes to use which will select all meshes within it\r\n     * @param allowDuplicate If duplicate objects are allowed in the resulting object array\r\n     * @returns array of meshes within the frustum\r\n     */\r\n    public select(frustumPlanes: Plane[], allowDuplicate?: boolean): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.select(frustumPlanes, this._selectionContent, allowDuplicate);\r\n        }\r\n\r\n        if (allowDuplicate) {\r\n            this._selectionContent.concat(this.dynamicContent);\r\n        } else {\r\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n        }\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array\r\n     * @param sphereCenter defines the bounding sphere center\r\n     * @param sphereRadius defines the bounding sphere radius\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     * @returns an array of objects that intersect the sphere\r\n     */\r\n    public intersects(sphereCenter: Vector3, sphereRadius: number, allowDuplicate?: boolean): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\r\n        }\r\n\r\n        if (allowDuplicate) {\r\n            this._selectionContent.concat(this.dynamicContent);\r\n        } else {\r\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n        }\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Test if the octree intersect with the given ray and if yes, then add its content to resulting array\r\n     * @param ray defines the ray to test with\r\n     * @returns array of intersected objects\r\n     */\r\n    public intersectsRay(ray: Ray): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.intersectsRay(ray, this._selectionContent);\r\n        }\r\n\r\n        this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh into the octree block if it intersects the block\r\n     * @param entry\r\n     * @param block\r\n     */\r\n    public static CreationFuncForMeshes = (entry: AbstractMesh, block: OctreeBlock<AbstractMesh>): void => {\r\n        const boundingInfo = entry.getBoundingInfo();\r\n        if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\r\n            block.entries.push(entry);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds a submesh into the octree block if it intersects the block\r\n     * @param entry\r\n     * @param block\r\n     */\r\n    public static CreationFuncForSubMeshes = (entry: SubMesh, block: OctreeBlock<SubMesh>): void => {\r\n        const boundingInfo = entry.getBoundingInfo();\r\n        if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\r\n            block.entries.push(entry);\r\n        }\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}