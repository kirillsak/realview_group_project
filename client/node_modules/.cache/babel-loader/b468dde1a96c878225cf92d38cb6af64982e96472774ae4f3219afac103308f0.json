{"ast":null,"code":"import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { DirectionalLight } from \"../../Lights/directionalLight.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial.js\";\nimport { LightConstants } from \"../../Lights/lightConstants.js\";\n/**\n * Light Estimation Feature\n *\n * @since 5.0.0\n */\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the light estimation feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n  constructor(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._canvasContext = null;\n    this._reflectionCubeMap = null;\n    this._xrLightEstimate = null;\n    this._xrLightProbe = null;\n    this._xrWebGLBinding = null;\n    this._lightDirection = Vector3.Up().negateInPlace();\n    this._lightColor = Color3.White();\n    this._intensity = 1;\n    this._sphericalHarmonics = new SphericalHarmonics();\n    this._cubeMapPollTime = Date.now();\n    this._lightEstimationPollTime = Date.now();\n    /**\n     * ARCore's reflection cube map size is 16x16.\n     * Once other systems support this feature we will need to change this to be dynamic.\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\n     */\n    this._reflectionCubeMapTextureSize = 16;\n    /**\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\n     * Otherwise this can be set with an external directional light source.\n     * This light will be updated whenever the light estimation values change.\n     */\n    this.directionalLight = null;\n    /**\n     * This observable will notify when the reflection cube map is updated.\n     */\n    this.onReflectionCubeMapUpdatedObservable = new Observable();\n    /**\n     * Event Listener for \"reflectionchange\" events.\n     */\n    this._updateReflectionCubeMap = () => {\n      var _a;\n      if (!this._xrLightProbe) {\n        return;\n      }\n      // check poll time, do not update if it has not been long enough\n      if (this.options.cubeMapPollInterval) {\n        const now = Date.now();\n        if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\n          return;\n        }\n        this._cubeMapPollTime = now;\n      }\n      const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\n      if (lp && this._reflectionCubeMap) {\n        if (!this._reflectionCubeMap._texture) {\n          const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\n          internalTexture.isCube = true;\n          internalTexture.invertY = false;\n          internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\n          internalTexture.format = 5;\n          internalTexture.generateMipMaps = true;\n          internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? 2 : 0;\n          internalTexture.samplingMode = 3;\n          internalTexture.width = this._reflectionCubeMapTextureSize;\n          internalTexture.height = this._reflectionCubeMapTextureSize;\n          internalTexture._cachedWrapU = 1;\n          internalTexture._cachedWrapV = 1;\n          internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext());\n          this._reflectionCubeMap._texture = internalTexture;\n        } else {\n          (_a = this._reflectionCubeMap._texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.set(lp);\n          this._reflectionCubeMap._texture.getEngine().resetTextureCache();\n        }\n        this._reflectionCubeMap._texture.isReady = true;\n        this._xrSessionManager.scene.markAllMaterialsAsDirty(1);\n        this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\n      }\n    };\n    this.xrNativeFeatureName = \"light-estimation\";\n    if (this.options.createDirectionalLightSource) {\n      this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\n      this.directionalLight.position = new Vector3(0, 8, 0);\n      // intensity will be set later\n      this.directionalLight.intensity = 0;\n      this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\n    }\n    // https://immersive-web.github.io/lighting-estimation/\n    Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\n  }\n  /**\n   * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\n   * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\n   * when it has been updated.\n   */\n  get reflectionCubeMapTexture() {\n    return this._reflectionCubeMap;\n  }\n  /**\n   * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\n   */\n  get xrLightingEstimate() {\n    if (this._xrLightEstimate) {\n      return {\n        lightColor: this._lightColor,\n        lightDirection: this._lightDirection,\n        lightIntensity: this._intensity,\n        sphericalHarmonics: this._sphericalHarmonics\n      };\n    }\n    return this._xrLightEstimate;\n  }\n  _getCanvasContext() {\n    if (this._canvasContext === null) {\n      this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\n    }\n    return this._canvasContext;\n  }\n  _getXRGLBinding() {\n    if (this._xrWebGLBinding === null) {\n      const context = this._getCanvasContext();\n      this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\n    }\n    return this._xrWebGLBinding;\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    var _a;\n    if (!super.attach()) {\n      return false;\n    }\n    const reflectionFormat = (_a = this.options.reflectionFormat) !== null && _a !== void 0 ? _a : this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\";\n    this.options.reflectionFormat = reflectionFormat;\n    this._xrSessionManager.session.requestLightProbe({\n      reflectionFormat\n    }).then(xrLightProbe => {\n      this._xrLightProbe = xrLightProbe;\n      if (!this.options.disableCubeMapReflection) {\n        if (!this._reflectionCubeMap) {\n          this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\n          this._reflectionCubeMap._isCube = true;\n          this._reflectionCubeMap.coordinatesMode = 3;\n          if (this.options.setSceneEnvironmentTexture) {\n            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\n          }\n        }\n        this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n      }\n    });\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    const detached = super.detach();\n    if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\n      this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\n      this._xrLightProbe = null;\n    }\n    this._canvasContext = null;\n    this._xrLightEstimate = null;\n    // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\n    this._xrWebGLBinding = null;\n    return detached;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onReflectionCubeMapUpdatedObservable.clear();\n    if (this.directionalLight) {\n      this.directionalLight.dispose();\n      this.directionalLight = null;\n    }\n    if (this._reflectionCubeMap !== null) {\n      if (this._reflectionCubeMap._texture) {\n        this._reflectionCubeMap._texture.dispose();\n      }\n      this._reflectionCubeMap.dispose();\n      this._reflectionCubeMap = null;\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    var _a;\n    if (this._xrLightProbe !== null) {\n      if (this.options.lightEstimationPollInterval) {\n        const now = Date.now();\n        if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\n          return;\n        }\n        this._lightEstimationPollTime = now;\n      }\n      this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\n      if (this._xrLightEstimate) {\n        this._intensity = Math.max(1.0, this._xrLightEstimate.primaryLightIntensity.x, this._xrLightEstimate.primaryLightIntensity.y, this._xrLightEstimate.primaryLightIntensity.z);\n        const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\n        // recreate the vector caches, so that the last one provided to the user will persist\n        if (this.options.disableVectorReuse) {\n          this._lightDirection = new Vector3();\n          this._lightColor = new Color3();\n          if (this.directionalLight) {\n            this.directionalLight.direction = this._lightDirection;\n            this.directionalLight.diffuse = this._lightColor;\n          }\n        }\n        this._lightDirection.copyFromFloats(this._xrLightEstimate.primaryLightDirection.x, this._xrLightEstimate.primaryLightDirection.y, this._xrLightEstimate.primaryLightDirection.z * rhsFactor);\n        this._lightColor.copyFromFloats(this._xrLightEstimate.primaryLightIntensity.x / this._intensity, this._xrLightEstimate.primaryLightIntensity.y / this._intensity, this._xrLightEstimate.primaryLightIntensity.z / this._intensity);\n        this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\n        if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\n          this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\n          (_a = this._reflectionCubeMap.sphericalPolynomial) === null || _a === void 0 ? void 0 : _a.updateFromHarmonics(this._sphericalHarmonics);\n        }\n        // direction from instead of direction to\n        this._lightDirection.negateInPlace();\n        // set the values after calculating them\n        if (this.directionalLight) {\n          this.directionalLight.direction.copyFrom(this._lightDirection);\n          this.directionalLight.intensity = Math.min(this._intensity, 1.0);\n          this.directionalLight.diffuse.copyFrom(this._lightColor);\n        }\n      }\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRLightEstimation.Name = WebXRFeatureName.LIGHT_ESTIMATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRLightEstimation.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRLightEstimation.Name, (xrSessionManager, options) => {\n  return () => new WebXRLightEstimation(xrSessionManager, options);\n}, WebXRLightEstimation.Version, false);","map":{"version":3,"mappings":"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","names":["WebGLHardwareTexture","InternalTexture","InternalTextureSource","Observable","Tools","WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","Color3","Vector3","DirectionalLight","BaseTexture","SphericalHarmonics","SphericalPolynomial","LightConstants","WebXRLightEstimation","constructor","_xrSessionManager","options","Up","negateInPlace","White","Date","now","_xrLightProbe","cubeMapPollInterval","_cubeMapPollTime","lp","_getXRGLBinding","getReflectionCubeMap","_reflectionCubeMap","_texture","internalTexture","scene","getEngine","Unknown","isCube","invertY","_useSRGBBuffer","reflectionFormat","format","generateMipMaps","type","samplingMode","width","_reflectionCubeMapTextureSize","height","_cachedWrapU","_cachedWrapV","_hardwareTexture","_getCanvasContext","set","resetTextureCache","isReady","markAllMaterialsAsDirty","onReflectionCubeMapUpdatedObservable","notifyObservers","xrNativeFeatureName","createDirectionalLightSource","directionalLight","_lightDirection","position","intensity","falloffType","FALLOFF_GLTF","Warn","reflectionCubeMapTexture","xrLightingEstimate","_xrLightEstimate","lightColor","_lightColor","lightDirection","lightIntensity","_intensity","sphericalHarmonics","_sphericalHarmonics","_canvasContext","_gl","_xrWebGLBinding","context","XRWebGLBinding","session","attach","preferredReflectionFormat","requestLightProbe","then","xrLightProbe","disableCubeMapReflection","_isCube","coordinatesMode","setSceneEnvironmentTexture","environmentTexture","addEventListener","_updateReflectionCubeMap","detach","detached","removeEventListener","dispose","clear","_onXRFrame","_xrFrame","lightEstimationPollInterval","_lightEstimationPollTime","getLightEstimate","Math","max","primaryLightIntensity","x","y","z","rhsFactor","useRightHandedSystem","disableVectorReuse","direction","diffuse","copyFromFloats","primaryLightDirection","updateFromFloatsArray","sphericalHarmonicsCoefficients","disableSphericalPolynomial","sphericalPolynomial","updateFromHarmonics","copyFrom","min","LIGHT_ESTIMATION","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRLightEstimation.ts"],"sourcesContent":["import { WebGLHardwareTexture } from \"../../Engines/WebGL/webGLHardwareTexture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { DirectionalLight } from \"../../Lights/directionalLight\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { LightConstants } from \"../../Lights/lightConstants\";\r\n\r\n/**\r\n * Options for Light Estimation feature\r\n */\r\nexport interface IWebXRLightEstimationOptions {\r\n    /**\r\n     * Disable the cube map reflection feature. In this case only light direction and color will be updated\r\n     */\r\n    disableCubeMapReflection?: boolean;\r\n    /**\r\n     * Should the scene's env texture be set to the cube map reflection texture\r\n     * Note that this doesn't work is disableCubeMapReflection if set to false\r\n     */\r\n    setSceneEnvironmentTexture?: boolean;\r\n    /**\r\n     * How often should the cubemap update in ms.\r\n     * If not set the cubemap will be updated every time the underlying system updates the environment texture.\r\n     */\r\n    cubeMapPollInterval?: number;\r\n    /**\r\n     * How often should the light estimation properties update in ms.\r\n     * If not set the light estimation properties will be updated on every frame (depending on the underlying system)\r\n     */\r\n    lightEstimationPollInterval?: number;\r\n    /**\r\n     * Should a directional light source be created.\r\n     * If created, this light source will be updated whenever the light estimation values change\r\n     */\r\n    createDirectionalLightSource?: boolean;\r\n    /**\r\n     * Define the format to be used for the light estimation texture.\r\n     */\r\n    reflectionFormat?: XRReflectionFormat;\r\n    /**\r\n     * Should the light estimation's needed vectors be constructed on each frame.\r\n     * Use this when you use those vectors and don't want their values to change outside of the light estimation feature\r\n     */\r\n    disableVectorReuse?: boolean;\r\n\r\n    /**\r\n     * disable applying the spherical polynomial to the cube map texture\r\n     */\r\n    disableSphericalPolynomial?: boolean;\r\n}\r\n\r\n/**\r\n * An interface describing the result of a light estimation\r\n */\r\nexport interface IWebXRLightEstimation {\r\n    /**\r\n     * The intensity of the light source\r\n     */\r\n    lightIntensity: number;\r\n    /**\r\n     * Color of light source\r\n     */\r\n    lightColor: Color3;\r\n    /**\r\n     * The direction from the light source\r\n     */\r\n    lightDirection: Vector3;\r\n    /**\r\n     * Spherical harmonics coefficients of the light source\r\n     */\r\n    sphericalHarmonics: SphericalHarmonics;\r\n}\r\n\r\n/**\r\n * Light Estimation Feature\r\n *\r\n * @since 5.0.0\r\n */\r\nexport class WebXRLightEstimation extends WebXRAbstractFeature {\r\n    private _canvasContext: Nullable<WebGLRenderingContext | WebGL2RenderingContext> = null;\r\n    private _reflectionCubeMap: Nullable<BaseTexture> = null;\r\n    private _xrLightEstimate: Nullable<XRLightEstimate> = null;\r\n    private _xrLightProbe: Nullable<XRLightProbe> = null;\r\n    private _xrWebGLBinding: Nullable<XRWebGLBinding> = null;\r\n    private _lightDirection: Vector3 = Vector3.Up().negateInPlace();\r\n    private _lightColor: Color3 = Color3.White();\r\n    private _intensity: number = 1;\r\n    private _sphericalHarmonics: SphericalHarmonics = new SphericalHarmonics();\r\n    private _cubeMapPollTime = Date.now();\r\n    private _lightEstimationPollTime = Date.now();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.LIGHT_ESTIMATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * ARCore's reflection cube map size is 16x16.\r\n     * Once other systems support this feature we will need to change this to be dynamic.\r\n     * see https://github.com/immersive-web/lighting-estimation/blob/main/lighting-estimation-explainer.md#cube-map-open-questions\r\n     */\r\n    private _reflectionCubeMapTextureSize: number = 16;\r\n\r\n    /**\r\n     * If createDirectionalLightSource is set to true this light source will be created automatically.\r\n     * Otherwise this can be set with an external directional light source.\r\n     * This light will be updated whenever the light estimation values change.\r\n     */\r\n    public directionalLight: Nullable<DirectionalLight> = null;\r\n\r\n    /**\r\n     * This observable will notify when the reflection cube map is updated.\r\n     */\r\n    public onReflectionCubeMapUpdatedObservable: Observable<BaseTexture> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the light estimation feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRLightEstimationOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"light-estimation\";\r\n\r\n        if (this.options.createDirectionalLightSource) {\r\n            this.directionalLight = new DirectionalLight(\"light estimation directional\", this._lightDirection, this._xrSessionManager.scene);\r\n            this.directionalLight.position = new Vector3(0, 8, 0);\r\n            // intensity will be set later\r\n            this.directionalLight.intensity = 0;\r\n            this.directionalLight.falloffType = LightConstants.FALLOFF_GLTF;\r\n        }\r\n\r\n        // https://immersive-web.github.io/lighting-estimation/\r\n        Tools.Warn(\"light-estimation is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * While the estimated cube map is expected to update over time to better reflect the user's environment as they move around those changes are unlikely to happen with every XRFrame.\r\n     * Since creating and processing the cube map is potentially expensive, especially if mip maps are needed, you can listen to the onReflectionCubeMapUpdatedObservable to determine\r\n     * when it has been updated.\r\n     */\r\n    public get reflectionCubeMapTexture(): Nullable<BaseTexture> {\r\n        return this._reflectionCubeMap;\r\n    }\r\n\r\n    /**\r\n     * The most recent light estimate.  Available starting on the first frame where the device provides a light probe.\r\n     */\r\n    public get xrLightingEstimate(): Nullable<IWebXRLightEstimation> {\r\n        if (this._xrLightEstimate) {\r\n            return {\r\n                lightColor: this._lightColor,\r\n                lightDirection: this._lightDirection,\r\n                lightIntensity: this._intensity,\r\n                sphericalHarmonics: this._sphericalHarmonics,\r\n            };\r\n        }\r\n        return this._xrLightEstimate;\r\n    }\r\n\r\n    private _getCanvasContext(): WebGLRenderingContext | WebGL2RenderingContext {\r\n        if (this._canvasContext === null) {\r\n            this._canvasContext = this._xrSessionManager.scene.getEngine()._gl;\r\n        }\r\n        return this._canvasContext;\r\n    }\r\n\r\n    private _getXRGLBinding(): XRWebGLBinding {\r\n        if (this._xrWebGLBinding === null) {\r\n            const context = this._getCanvasContext();\r\n            this._xrWebGLBinding = new XRWebGLBinding(this._xrSessionManager.session, context);\r\n        }\r\n        return this._xrWebGLBinding;\r\n    }\r\n\r\n    /**\r\n     * Event Listener for \"reflectionchange\" events.\r\n     */\r\n    private _updateReflectionCubeMap = (): void => {\r\n        if (!this._xrLightProbe) {\r\n            return;\r\n        }\r\n        // check poll time, do not update if it has not been long enough\r\n        if (this.options.cubeMapPollInterval) {\r\n            const now = Date.now();\r\n            if (now - this._cubeMapPollTime < this.options.cubeMapPollInterval) {\r\n                return;\r\n            }\r\n            this._cubeMapPollTime = now;\r\n        }\r\n        const lp = this._getXRGLBinding().getReflectionCubeMap(this._xrLightProbe);\r\n        if (lp && this._reflectionCubeMap) {\r\n            if (!this._reflectionCubeMap._texture) {\r\n                const internalTexture = new InternalTexture(this._xrSessionManager.scene.getEngine(), InternalTextureSource.Unknown);\r\n                internalTexture.isCube = true;\r\n                internalTexture.invertY = false;\r\n                internalTexture._useSRGBBuffer = this.options.reflectionFormat === \"srgba8\";\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.generateMipMaps = true;\r\n                internalTexture.type = this.options.reflectionFormat !== \"srgba8\" ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n                internalTexture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n                internalTexture.width = this._reflectionCubeMapTextureSize;\r\n                internalTexture.height = this._reflectionCubeMapTextureSize;\r\n                internalTexture._cachedWrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._cachedWrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n                internalTexture._hardwareTexture = new WebGLHardwareTexture(lp, this._getCanvasContext() as WebGLRenderingContext);\r\n                this._reflectionCubeMap._texture = internalTexture;\r\n            } else {\r\n                this._reflectionCubeMap._texture._hardwareTexture?.set(lp);\r\n                this._reflectionCubeMap._texture.getEngine().resetTextureCache();\r\n            }\r\n            this._reflectionCubeMap._texture.isReady = true;\r\n            this._xrSessionManager.scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n\r\n            this.onReflectionCubeMapUpdatedObservable.notifyObservers(this._reflectionCubeMap);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        const reflectionFormat = this.options.reflectionFormat ?? (this._xrSessionManager.session.preferredReflectionFormat || \"srgba8\");\r\n        this.options.reflectionFormat = reflectionFormat;\r\n        this._xrSessionManager.session\r\n            .requestLightProbe({\r\n                reflectionFormat,\r\n            })\r\n            .then((xrLightProbe: XRLightProbe) => {\r\n                this._xrLightProbe = xrLightProbe;\r\n                if (!this.options.disableCubeMapReflection) {\r\n                    if (!this._reflectionCubeMap) {\r\n                        this._reflectionCubeMap = new BaseTexture(this._xrSessionManager.scene);\r\n                        this._reflectionCubeMap._isCube = true;\r\n                        this._reflectionCubeMap.coordinatesMode = Constants.TEXTURE_CUBIC_MODE;\r\n                        if (this.options.setSceneEnvironmentTexture) {\r\n                            this._xrSessionManager.scene.environmentTexture = this._reflectionCubeMap;\r\n                        }\r\n                    }\r\n                    this._xrLightProbe.addEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n                }\r\n            });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        const detached = super.detach();\r\n\r\n        if (this._xrLightProbe !== null && !this.options.disableCubeMapReflection) {\r\n            this._xrLightProbe.removeEventListener(\"reflectionchange\", this._updateReflectionCubeMap);\r\n            this._xrLightProbe = null;\r\n        }\r\n\r\n        this._canvasContext = null;\r\n        this._xrLightEstimate = null;\r\n        // When the session ends (on detach) we must clear our XRWebGLBinging instance, which references the ended session.\r\n        this._xrWebGLBinding = null;\r\n\r\n        return detached;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onReflectionCubeMapUpdatedObservable.clear();\r\n\r\n        if (this.directionalLight) {\r\n            this.directionalLight.dispose();\r\n            this.directionalLight = null;\r\n        }\r\n\r\n        if (this._reflectionCubeMap !== null) {\r\n            if (this._reflectionCubeMap._texture) {\r\n                this._reflectionCubeMap._texture.dispose();\r\n            }\r\n            this._reflectionCubeMap.dispose();\r\n            this._reflectionCubeMap = null;\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        if (this._xrLightProbe !== null) {\r\n            if (this.options.lightEstimationPollInterval) {\r\n                const now = Date.now();\r\n                if (now - this._lightEstimationPollTime < this.options.lightEstimationPollInterval) {\r\n                    return;\r\n                }\r\n                this._lightEstimationPollTime = now;\r\n            }\r\n            this._xrLightEstimate = _xrFrame.getLightEstimate(this._xrLightProbe);\r\n            if (this._xrLightEstimate) {\r\n                this._intensity = Math.max(\r\n                    1.0,\r\n                    this._xrLightEstimate.primaryLightIntensity.x,\r\n                    this._xrLightEstimate.primaryLightIntensity.y,\r\n                    this._xrLightEstimate.primaryLightIntensity.z\r\n                );\r\n\r\n                const rhsFactor = this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0;\r\n\r\n                // recreate the vector caches, so that the last one provided to the user will persist\r\n                if (this.options.disableVectorReuse) {\r\n                    this._lightDirection = new Vector3();\r\n                    this._lightColor = new Color3();\r\n                    if (this.directionalLight) {\r\n                        this.directionalLight.direction = this._lightDirection;\r\n                        this.directionalLight.diffuse = this._lightColor;\r\n                    }\r\n                }\r\n\r\n                this._lightDirection.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightDirection.x,\r\n                    this._xrLightEstimate.primaryLightDirection.y,\r\n                    this._xrLightEstimate.primaryLightDirection.z * rhsFactor\r\n                );\r\n                this._lightColor.copyFromFloats(\r\n                    this._xrLightEstimate.primaryLightIntensity.x / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.y / this._intensity,\r\n                    this._xrLightEstimate.primaryLightIntensity.z / this._intensity\r\n                );\r\n                this._sphericalHarmonics.updateFromFloatsArray(this._xrLightEstimate.sphericalHarmonicsCoefficients);\r\n                if (this._reflectionCubeMap && !this.options.disableSphericalPolynomial) {\r\n                    this._reflectionCubeMap.sphericalPolynomial = this._reflectionCubeMap.sphericalPolynomial || new SphericalPolynomial();\r\n                    this._reflectionCubeMap.sphericalPolynomial?.updateFromHarmonics(this._sphericalHarmonics);\r\n                }\r\n\r\n                // direction from instead of direction to\r\n                this._lightDirection.negateInPlace();\r\n                // set the values after calculating them\r\n                if (this.directionalLight) {\r\n                    this.directionalLight.direction.copyFrom(this._lightDirection);\r\n                    this.directionalLight.intensity = Math.min(this._intensity, 1.0);\r\n                    this.directionalLight.diffuse.copyFrom(this._lightColor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRLightEstimation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRLightEstimation(xrSessionManager, options);\r\n    },\r\n    WebXRLightEstimation.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}