{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"noisePixelShader\";\nconst shader = `uniform float brightness;\nuniform float persistence;\nuniform float timeScale;\nvarying vec2 vUV;\nvec2 hash22(vec2 p)\n{\np=p*mat2(127.1,311.7,269.5,183.3);\np=-1.0+2.0*fract(sin(p)*43758.5453123);\nreturn sin(p*6.283+timeScale);\n}\nfloat interpolationNoise(vec2 p)\n{\nvec2 pi=floor(p);\nvec2 pf=p-pi;\nvec2 w=pf*pf*(3.-2.*pf);\nfloat f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\nfloat f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\nfloat f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\nfloat f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\nfloat xm1=mix(f00,f10,w.x);\nfloat xm2=mix(f01,f11,w.x);\nfloat ym=mix(xm1,xm2,w.y); \nreturn ym;\n}\nfloat perlinNoise2D(float x,float y)\n{\nfloat sum=0.0;\nfloat frequency=0.0;\nfloat amplitude=0.0;\nfor(int i=0; i<OCTAVES; i++)\n{\nfrequency=pow(2.0,float(i));\namplitude=pow(persistence,float(i));\nsum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;\n}\nreturn sum;\n}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\nfloat x=abs(vUV.x);\nfloat y=abs(vUV.y);\nfloat noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);\ngl_FragColor=vec4(noise,noise,noise,1.0);\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const noisePixelShader = {\n  name,\n  shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,2BAAyB;AAErD,MAAMC,IAAI,GAAG,kBAAkB;AAC/B,MAAMC,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6Cd;AACD;AACAF,WAAW,CAACG,YAAY,CAACF,IAAI,CAAC,GAAGC,MAAM;AACvC;AACA,OAAO,MAAME,gBAAgB,GAAG;EAAEH,IAAI;EAAEC;AAAM,CAAE","names":["ShaderStore","name","shader","ShadersStore","noisePixelShader"],"sourceRoot":"","sources":["../../../../lts/core/generated/Shaders/noise.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"noisePixelShader\";\nconst shader = `uniform float brightness;\runiform float persistence;\runiform float timeScale;\rvarying vec2 vUV;\rvec2 hash22(vec2 p)\r{\rp=p*mat2(127.1,311.7,269.5,183.3);\rp=-1.0+2.0*fract(sin(p)*43758.5453123);\rreturn sin(p*6.283+timeScale);\r}\rfloat interpolationNoise(vec2 p)\r{\rvec2 pi=floor(p);\rvec2 pf=p-pi;\rvec2 w=pf*pf*(3.-2.*pf);\rfloat f00=dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\rfloat f01=dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\rfloat f10=dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\rfloat f11=dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\rfloat xm1=mix(f00,f10,w.x);\rfloat xm2=mix(f01,f11,w.x);\rfloat ym=mix(xm1,xm2,w.y); \rreturn ym;\r}\rfloat perlinNoise2D(float x,float y)\r{\rfloat sum=0.0;\rfloat frequency=0.0;\rfloat amplitude=0.0;\rfor(int i=0; i<OCTAVES; i++)\r{\rfrequency=pow(2.0,float(i));\ramplitude=pow(persistence,float(i));\rsum=sum+interpolationNoise(vec2(x*frequency,y*frequency))*amplitude;\r}\rreturn sum;\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\r{\rfloat x=abs(vUV.x);\rfloat y=abs(vUV.y);\rfloat noise=brightness+(1.0-brightness)*perlinNoise2D(x,y);\rgl_FragColor=vec4(noise,noise,noise,1.0);\r}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const noisePixelShader = { name, shader };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}