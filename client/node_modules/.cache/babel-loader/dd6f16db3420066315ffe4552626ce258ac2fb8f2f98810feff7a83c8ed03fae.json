{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Quaternion, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\n/** @internal */\nexport function getVector3(_target, source, offset, scale) {\n  return Vector3.FromArray(source, offset).scaleInPlace(scale);\n}\n/** @internal */\nexport function getQuaternion(_target, source, offset, scale) {\n  return Quaternion.FromArray(source, offset).scaleInPlace(scale);\n}\n/** @internal */\nexport function getWeights(target, source, offset, scale) {\n  const value = new Array(target._numMorphTargets);\n  for (let i = 0; i < value.length; i++) {\n    value[i] = source[offset++] * scale;\n  }\n  return value;\n}\n/** @internal */\nexport class AnimationPropertyInfo {\n  /** @internal */\n  constructor(type, name, getValue, getStride) {\n    this.type = type;\n    this.name = name;\n    this.getValue = getValue;\n    this.getStride = getStride;\n  }\n  _buildAnimation(name, fps, keys) {\n    const babylonAnimation = new Animation(name, this.name, fps, this.type);\n    babylonAnimation.setKeys(keys);\n    return babylonAnimation;\n  }\n}\n/** @internal */\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\n  /** @internal */\n  buildAnimations(target, name, fps, keys, callback) {\n    callback(target._babylonTransformNode, this._buildAnimation(name, fps, keys));\n  }\n}\n/** @internal */\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\n  buildAnimations(target, name, fps, keys, callback) {\n    if (target._numMorphTargets) {\n      for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\n        const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\n        babylonAnimation.setKeys(keys.map(key => ({\n          frame: key.frame,\n          inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\n          value: key.value[targetIndex],\n          outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\n          interpolation: key.interpolation\n        })));\n        if (target._primitiveBabylonMeshes) {\n          for (const babylonMesh of target._primitiveBabylonMeshes) {\n            if (babylonMesh.morphTargetManager) {\n              const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\n              const babylonAnimationClone = babylonAnimation.clone();\n              morphTarget.animations.push(babylonAnimationClone);\n              callback(morphTarget, babylonAnimationClone);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/** @internal */\nexport const nodeAnimationData = {\n  translation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)],\n  rotation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)],\n  scale: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)],\n  weights: [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, target => target._numMorphTargets)]\n};","map":{"version":3,"mappings":"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","names":["Animation","Quaternion","Vector3","getVector3","_target","source","offset","scale","FromArray","scaleInPlace","getQuaternion","getWeights","target","value","Array","_numMorphTargets","i","length","AnimationPropertyInfo","constructor","type","name","getValue","getStride","_buildAnimation","fps","keys","babylonAnimation","setKeys","TransformNodeAnimationPropertyInfo","buildAnimations","callback","_babylonTransformNode","WeightAnimationPropertyInfo","targetIndex","map","key","frame","inTangent","undefined","outTangent","interpolation","_primitiveBabylonMeshes","babylonMesh","morphTargetManager","morphTarget","getTarget","babylonAnimationClone","clone","animations","push","nodeAnimationData","translation","ANIMATIONTYPE_VECTOR3","rotation","ANIMATIONTYPE_QUATERNION","weights","ANIMATIONTYPE_FLOAT"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/glTF/2.0/glTFLoaderAnimation.ts"],"sourcesContent":["import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(public readonly type: number, public readonly name: string, public readonly getValue: GetValueFn, public readonly getStride: (target: any) => number) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void;\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void {\r\n        callback(target._babylonTransformNode!, this._buildAnimation(name, fps, keys));\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[], callback: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void): void {\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    }))\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            callback(morphTarget, babylonAnimationClone);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport const nodeAnimationData = {\r\n    translation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)],\r\n    rotation: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)],\r\n    scale: [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)],\r\n    weights: [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)],\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}