{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\n/**\n * Base class for Camera Pointer Inputs.\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\n * for example usage.\n */\nexport class BaseCameraPointersInput {\n  constructor() {\n    this._currentActiveButton = -1;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    const engine = this.camera.getEngine();\n    const element = engine.getInputElement();\n    let previousPinchSquaredDistance = 0;\n    let previousMultiTouchPanPosition = null;\n    this._pointA = null;\n    this._pointB = null;\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n    this._pointerInput = p => {\n      const evt = p.event;\n      const isTouch = evt.pointerType === \"touch\";\n      if (engine.isInVRExclusivePointerMode) {\n        return;\n      }\n      if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n        return;\n      }\n      const srcElement = evt.target;\n      this._altKey = evt.altKey;\n      this._ctrlKey = evt.ctrlKey;\n      this._metaKey = evt.metaKey;\n      this._shiftKey = evt.shiftKey;\n      this._buttonsPressed = evt.buttons;\n      if (engine.isPointerLock) {\n        const offsetX = evt.movementX;\n        const offsetY = evt.movementY;\n        this.onTouch(null, offsetX, offsetY);\n        this._pointA = null;\n        this._pointB = null;\n      } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\n        try {\n          srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n        } catch (e) {\n          //Nothing to do with the error. Execution will continue.\n        }\n        if (this._pointA === null) {\n          this._pointA = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        } else if (this._pointB === null) {\n          this._pointB = {\n            x: evt.clientX,\n            y: evt.clientY,\n            pointerId: evt.pointerId,\n            type: evt.pointerType\n          };\n        }\n        if (this._currentActiveButton === -1 && !isTouch) {\n          this._currentActiveButton = evt.button;\n        }\n        this.onButtonDown(evt);\n        if (!noPreventDefault) {\n          evt.preventDefault();\n          element && element.focus();\n        }\n      } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\n        this.onDoubleTap(evt.pointerType);\n      } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\n        try {\n          srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n        } catch (e) {\n          //Nothing to do with the error.\n        }\n        if (!isTouch) {\n          this._pointB = null; // Mouse and pen are mono pointer\n        }\n        //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\n        //but emptying completely pointers collection is required to fix a bug on iPhone :\n        //when changing orientation while pinching camera,\n        //one pointer stay pressed forever if we don't release all pointers\n        //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n        if (engine._badOS) {\n          this._pointA = this._pointB = null;\n        } else {\n          //only remove the impacted pointer in case of multitouch allowing on most\n          //platforms switching from rotate to zoom and pan seamlessly.\n          if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\n            this._pointA = this._pointB;\n            this._pointB = null;\n          } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\n            this._pointB = null;\n          } else {\n            this._pointA = this._pointB = null;\n          }\n        }\n        if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\n          // Previous pinch data is populated but a button has been lifted\n          // so pinch has ended.\n          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, 0,\n          // pinchSquaredDistance\n          previousMultiTouchPanPosition, null // multiTouchPanPosition\n          );\n\n          previousPinchSquaredDistance = 0;\n          previousMultiTouchPanPosition = null;\n        }\n        this._currentActiveButton = -1;\n        this.onButtonUp(evt);\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n      } else if (p.type === PointerEventTypes.POINTERMOVE) {\n        if (!noPreventDefault) {\n          evt.preventDefault();\n        }\n        // One button down\n        if (this._pointA && this._pointB === null) {\n          const offsetX = evt.clientX - this._pointA.x;\n          const offsetY = evt.clientY - this._pointA.y;\n          this.onTouch(this._pointA, offsetX, offsetY);\n          this._pointA.x = evt.clientX;\n          this._pointA.y = evt.clientY;\n        }\n        // Two buttons down: pinch\n        else if (this._pointA && this._pointB) {\n          const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\n          ed.x = evt.clientX;\n          ed.y = evt.clientY;\n          const distX = this._pointA.x - this._pointB.x;\n          const distY = this._pointA.y - this._pointB.y;\n          const pinchSquaredDistance = distX * distX + distY * distY;\n          const multiTouchPanPosition = {\n            x: (this._pointA.x + this._pointB.x) / 2,\n            y: (this._pointA.y + this._pointB.y) / 2,\n            pointerId: evt.pointerId,\n            type: p.type\n          };\n          this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\n          previousMultiTouchPanPosition = multiTouchPanPosition;\n          previousPinchSquaredDistance = pinchSquaredDistance;\n        }\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP);\n    this._onLostFocus = () => {\n      this._pointA = this._pointB = null;\n      previousPinchSquaredDistance = 0;\n      previousMultiTouchPanPosition = null;\n      this.onLostFocus();\n    };\n    this._contextMenuBind = this.onContextMenu.bind(this);\n    element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\n    const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n    if (hostWindow) {\n      Tools.RegisterTopRootEvents(hostWindow, [{\n        name: \"blur\",\n        handler: this._onLostFocus\n      }]);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._onLostFocus) {\n      const hostWindow = this.camera.getScene().getEngine().getHostWindow();\n      if (hostWindow) {\n        Tools.UnregisterTopRootEvents(hostWindow, [{\n          name: \"blur\",\n          handler: this._onLostFocus\n        }]);\n      }\n    }\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      this._observer = null;\n      if (this._contextMenuBind) {\n        const inputElement = this.camera.getScene().getEngine().getInputElement();\n        inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n      this._onLostFocus = null;\n    }\n    this._altKey = false;\n    this._ctrlKey = false;\n    this._metaKey = false;\n    this._shiftKey = false;\n    this._buttonsPressed = 0;\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"BaseCameraPointersInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"pointers\";\n  }\n  /**\n   * Called on pointer POINTERDOUBLETAP event.\n   * Override this method to provide functionality on POINTERDOUBLETAP event.\n   * @param type\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onDoubleTap(type) {}\n  /**\n   * Called on pointer POINTERMOVE event if only a single touch is active.\n   * Override this method to provide functionality.\n   * @param point\n   * @param offsetX\n   * @param offsetY\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onTouch(point, offsetX, offsetY) {}\n  /**\n   * Called on pointer POINTERMOVE event if multiple touches are active.\n   * Override this method to provide functionality.\n   * @param _pointA\n   * @param _pointB\n   * @param previousPinchSquaredDistance\n   * @param pinchSquaredDistance\n   * @param previousMultiTouchPanPosition\n   * @param multiTouchPanPosition\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onMultiTouch(_pointA, _pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition) {}\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n  onContextMenu(evt) {\n    evt.preventDefault();\n  }\n  /**\n   * Called each time a new POINTERDOWN event occurs. Ie, for each button\n   * press.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onButtonDown(evt) {}\n  /**\n   * Called each time a new POINTERUP event occurs. Ie, for each button\n   * release.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onButtonUp(evt) {}\n  /**\n   * Called when window becomes inactive.\n   * Override this method to provide functionality.\n   */\n  onLostFocus() {}\n}\n__decorate([serialize()], BaseCameraPointersInput.prototype, \"buttons\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","Tools","PointerEventTypes","BaseCameraPointersInput","constructor","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","engine","camera","getEngine","element","getInputElement","previousPinchSquaredDistance","previousMultiTouchPanPosition","_pointA","_pointB","_altKey","_ctrlKey","_metaKey","_shiftKey","_buttonsPressed","_pointerInput","p","evt","event","isTouch","pointerType","isInVRExclusivePointerMode","type","POINTERMOVE","buttons","indexOf","button","srcElement","target","altKey","ctrlKey","metaKey","shiftKey","isPointerLock","offsetX","movementX","offsetY","movementY","onTouch","POINTERDOWN","_currentActiveButton","setPointerCapture","pointerId","e","x","clientX","y","clientY","onButtonDown","preventDefault","focus","POINTERDOUBLETAP","onDoubleTap","POINTERUP","releasePointerCapture","_badOS","onMultiTouch","onButtonUp","ed","distX","distY","pinchSquaredDistance","multiTouchPanPosition","_observer","getScene","_inputManager","_addCameraPointerObserver","_onLostFocus","onLostFocus","_contextMenuBind","onContextMenu","bind","addEventListener","hostWindow","getHostWindow","RegisterTopRootEvents","name","handler","detachControl","UnregisterTopRootEvents","_removeCameraPointerObserver","inputElement","removeEventListener","getClassName","getSimpleName","point","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/Inputs/BaseCameraPointersInput.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { EventState, Observer } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo, PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Base class for Camera Pointer Inputs.\r\n * See FollowCameraPointersInput in src/Cameras/Inputs/followCameraPointersInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraPointersInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * Whether keyboard modifier keys are pressed at time of last mouse event.\r\n     */\r\n    protected _altKey: boolean;\r\n    protected _ctrlKey: boolean;\r\n    protected _metaKey: boolean;\r\n    protected _shiftKey: boolean;\r\n\r\n    /**\r\n     * Which mouse buttons were pressed at time of last mouse event.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n     */\r\n    protected _buttonsPressed: number;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _contextMenuBind: EventListener;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n        let previousPinchSquaredDistance = 0;\r\n        let previousMultiTouchPanPosition: Nullable<PointerTouch> = null;\r\n\r\n        this._pointA = null;\r\n        this._pointB = null;\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n\r\n        this._pointerInput = (p) => {\r\n            const evt = <IPointerEvent>p.event;\r\n            const isTouch = evt.pointerType === \"touch\";\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                return;\r\n            }\r\n\r\n            const srcElement = <HTMLElement>evt.target;\r\n\r\n            this._altKey = evt.altKey;\r\n            this._ctrlKey = evt.ctrlKey;\r\n            this._metaKey = evt.metaKey;\r\n            this._shiftKey = evt.shiftKey;\r\n            this._buttonsPressed = evt.buttons;\r\n\r\n            if (engine.isPointerLock) {\r\n                const offsetX = evt.movementX;\r\n                const offsetY = evt.movementY;\r\n\r\n                this.onTouch(null, offsetX, offsetY);\r\n                this._pointA = null;\r\n                this._pointB = null;\r\n            } else if (p.type === PointerEventTypes.POINTERDOWN && (this._currentActiveButton === -1 || isTouch)) {\r\n                try {\r\n                    srcElement?.setPointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error. Execution will continue.\r\n                }\r\n\r\n                if (this._pointA === null) {\r\n                    this._pointA = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                } else if (this._pointB === null) {\r\n                    this._pointB = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                        pointerId: evt.pointerId,\r\n                        type: evt.pointerType,\r\n                    };\r\n                }\r\n\r\n                if (this._currentActiveButton === -1 && !isTouch) {\r\n                    this._currentActiveButton = evt.button;\r\n                }\r\n                this.onButtonDown(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                    element && element.focus();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERDOUBLETAP) {\r\n                this.onDoubleTap(evt.pointerType);\r\n            } else if (p.type === PointerEventTypes.POINTERUP && (this._currentActiveButton === evt.button || isTouch)) {\r\n                try {\r\n                    srcElement?.releasePointerCapture(evt.pointerId);\r\n                } catch (e) {\r\n                    //Nothing to do with the error.\r\n                }\r\n\r\n                if (!isTouch) {\r\n                    this._pointB = null; // Mouse and pen are mono pointer\r\n                }\r\n\r\n                //would be better to use pointers.remove(evt.pointerId) for multitouch gestures,\r\n                //but emptying completely pointers collection is required to fix a bug on iPhone :\r\n                //when changing orientation while pinching camera,\r\n                //one pointer stay pressed forever if we don't release all pointers\r\n                //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\r\n                if (engine._badOS) {\r\n                    this._pointA = this._pointB = null;\r\n                } else {\r\n                    //only remove the impacted pointer in case of multitouch allowing on most\r\n                    //platforms switching from rotate to zoom and pan seamlessly.\r\n                    if (this._pointB && this._pointA && this._pointA.pointerId == evt.pointerId) {\r\n                        this._pointA = this._pointB;\r\n                        this._pointB = null;\r\n                    } else if (this._pointA && this._pointB && this._pointB.pointerId == evt.pointerId) {\r\n                        this._pointB = null;\r\n                    } else {\r\n                        this._pointA = this._pointB = null;\r\n                    }\r\n                }\r\n\r\n                if (previousPinchSquaredDistance !== 0 || previousMultiTouchPanPosition) {\r\n                    // Previous pinch data is populated but a button has been lifted\r\n                    // so pinch has ended.\r\n                    this.onMultiTouch(\r\n                        this._pointA,\r\n                        this._pointB,\r\n                        previousPinchSquaredDistance,\r\n                        0, // pinchSquaredDistance\r\n                        previousMultiTouchPanPosition,\r\n                        null // multiTouchPanPosition\r\n                    );\r\n                    previousPinchSquaredDistance = 0;\r\n                    previousMultiTouchPanPosition = null;\r\n                }\r\n\r\n                this._currentActiveButton = -1;\r\n                this.onButtonUp(evt);\r\n\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n            } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                if (!noPreventDefault) {\r\n                    evt.preventDefault();\r\n                }\r\n\r\n                // One button down\r\n                if (this._pointA && this._pointB === null) {\r\n                    const offsetX = evt.clientX - this._pointA.x;\r\n                    const offsetY = evt.clientY - this._pointA.y;\r\n                    this.onTouch(this._pointA, offsetX, offsetY);\r\n\r\n                    this._pointA.x = evt.clientX;\r\n                    this._pointA.y = evt.clientY;\r\n                }\r\n                // Two buttons down: pinch\r\n                else if (this._pointA && this._pointB) {\r\n                    const ed = this._pointA.pointerId === evt.pointerId ? this._pointA : this._pointB;\r\n                    ed.x = evt.clientX;\r\n                    ed.y = evt.clientY;\r\n                    const distX = this._pointA.x - this._pointB.x;\r\n                    const distY = this._pointA.y - this._pointB.y;\r\n                    const pinchSquaredDistance = distX * distX + distY * distY;\r\n                    const multiTouchPanPosition = {\r\n                        x: (this._pointA.x + this._pointB.x) / 2,\r\n                        y: (this._pointA.y + this._pointB.y) / 2,\r\n                        pointerId: evt.pointerId,\r\n                        type: p.type,\r\n                    };\r\n\r\n                    this.onMultiTouch(this._pointA, this._pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n                    previousMultiTouchPanPosition = multiTouchPanPosition;\r\n                    previousPinchSquaredDistance = pinchSquaredDistance;\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(\r\n                this._pointerInput,\r\n                PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE | PointerEventTypes.POINTERDOUBLETAP\r\n            );\r\n\r\n        this._onLostFocus = () => {\r\n            this._pointA = this._pointB = null;\r\n            previousPinchSquaredDistance = 0;\r\n            previousMultiTouchPanPosition = null;\r\n            this.onLostFocus();\r\n        };\r\n\r\n        this._contextMenuBind = this.onContextMenu.bind(this);\r\n\r\n        element && element.addEventListener(\"contextmenu\", this._contextMenuBind, false);\r\n\r\n        const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            Tools.RegisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._onLostFocus) {\r\n            const hostWindow = this.camera.getScene().getEngine().getHostWindow();\r\n            if (hostWindow) {\r\n                Tools.UnregisterTopRootEvents(hostWindow, [{ name: \"blur\", handler: this._onLostFocus }]);\r\n            }\r\n        }\r\n\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n\r\n            if (this._contextMenuBind) {\r\n                const inputElement = this.camera.getScene().getEngine().getInputElement();\r\n                inputElement && inputElement.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            this._onLostFocus = null;\r\n        }\r\n\r\n        this._altKey = false;\r\n        this._ctrlKey = false;\r\n        this._metaKey = false;\r\n        this._shiftKey = false;\r\n        this._buttonsPressed = 0;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"pointers\";\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     * Override this method to provide functionality on POINTERDOUBLETAP event.\r\n     * @param type\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onDoubleTap(type: string) {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * Override this method to provide functionality.\r\n     * @param point\r\n     * @param offsetX\r\n     * @param offsetY\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA\r\n     * @param _pointB\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {}\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onButtonDown(evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public onButtonUp(evt: IPointerEvent): void {}\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     * Override this method to provide functionality.\r\n     */\r\n    public onLostFocus(): void {}\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _pointA: Nullable<PointerTouch>;\r\n    private _pointB: Nullable<PointerTouch>;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}