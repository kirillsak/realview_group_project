{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\n/**\n * Block used to provide an image for a TextureBlock\n */\nexport class ImageSourceBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new ImageSourceBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this.registerOutput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\"));\n  }\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(texture) {\n    var _a;\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  /**\n   * Gets the sampler name associated with this image source\n   */\n  get samplerName() {\n    return this._samplerName;\n  }\n  bind(effect) {\n    if (!this.texture) {\n      return;\n    }\n    effect.setTexture(this._samplerName, this.texture);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ImageSourceBlock\";\n  }\n  /**\n   * Gets the output component\n   */\n  get source() {\n    return this._outputs[0];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n      // Declarations\n      state.sharedData.blockingBlocks.push(this);\n      state.sharedData.textureBlocks.push(this);\n      state.sharedData.bindableBlocks.push(this);\n    }\n    state._emit2DSampler(this._samplerName);\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","Texture","NodeMaterial","NodeMaterialConnectionPointCustomObject","EngineStore","ImageSourceBlock","constructor","name","VertexAndFragment","registerOutput","Object","Output","texture","_texture","scene","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","samplerName","_samplerName","bind","effect","setTexture","isReady","isReadyOrNotBlocking","getClassName","source","_outputs","_buildBlock","state","target","Vertex","_getFreeVariableName","sharedData","blockingBlocks","push","textureBlocks","bindableBlocks","_emit2DSampler","_dumpPropertiesCode","codeString","_codeVariableName","noMipmap","invertY","samplingMode","wrapU","wrapV","uAng","vAng","wAng","uOffset","vOffset","uScale","vScale","coordinatesMode","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","IgnoreTexturesAtLoadTime","url","undefined","indexOf","Parse"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/imageSourceBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\n/**\r\n * Block used to provide an image for a TextureBlock\r\n */\r\nexport class ImageSourceBlock extends NodeMaterialBlock {\r\n    private _samplerName: string;\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this image source\r\n     */\r\n    public get samplerName(): string {\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ImageSourceBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this.registerOutput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Output, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setTexture(this._samplerName, this.texture);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ImageSourceBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            // Declarations\r\n            state.sharedData.blockingBlocks.push(this);\r\n            state.sharedData.textureBlocks.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n        }\r\n\r\n        state._emit2DSampler(this._samplerName);\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ImageSourceBlock\", ImageSourceBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}