{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nWebGPUEngine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n  const texture = new InternalTexture(this, InternalTextureSource.Raw);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.width = width;\n  texture.height = height;\n  texture.format = format;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture.type = type;\n  texture._useSRGBBuffer = useSRGBBuffer;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\n  this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nWebGPUEngine.prototype.updateRawTexture = function (texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n  if (!texture) {\n    return;\n  }\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.invertY = invertY;\n    texture._compression = compression;\n    texture._useSRGBBuffer = useSRGBBuffer;\n  }\n  if (bufferView) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const needConversion = format === 4;\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\n    }\n    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n  texture.isReady = true;\n};\nWebGPUEngine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {\n  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\n  if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n    generateMipMaps = false;\n    samplingMode = 1;\n    Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\n  } else if (type === 1 && !this._caps.textureFloatRender) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\n  } else if (type === 2 && !this._caps.colorBufferFloat) {\n    generateMipMaps = false;\n    Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\n  }\n  texture.isCube = true;\n  texture.format = format === 4 ? 5 : format;\n  texture.type = type;\n  texture.generateMipMaps = generateMipMaps;\n  texture.width = size;\n  texture.height = size;\n  texture.samplingMode = samplingMode;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferViewArray = data;\n  }\n  texture.invertY = invertY;\n  texture._compression = compression;\n  texture._cachedWrapU = 0;\n  texture._cachedWrapV = 0;\n  this._textureHelper.createGPUTextureForInternalTexture(texture);\n  if (data) {\n    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n  }\n  texture.isReady = true;\n  return texture;\n};\nWebGPUEngine.prototype.updateRawCubeTexture = function (texture, bufferView, format, type, invertY, compression = null) {\n  texture._bufferViewArray = bufferView;\n  texture.invertY = invertY;\n  texture._compression = compression;\n  const gpuTextureWrapper = texture._hardwareTexture;\n  const needConversion = format === 4;\n  const data = [];\n  for (let i = 0; i < bufferView.length; ++i) {\n    let faceData = bufferView[i];\n    if (needConversion) {\n      faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);\n    }\n    data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\n  }\n  this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\n  if (texture.generateMipMaps) {\n    this._generateMipmaps(texture, this._uploadEncoder);\n  }\n  texture.isReady = true;\n};\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {\n  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\n  scene === null || scene === void 0 ? void 0 : scene.addPendingData(texture);\n  texture.url = url;\n  this._internalTexturesCache.push(texture);\n  const onerror = (request, exception) => {\n    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);\n    if (onError && request) {\n      onError(request.status + \" \" + request.statusText, exception);\n    }\n  };\n  const internalCallback = data => {\n    const width = texture.width;\n    const faceDataArrays = callback(data);\n    if (!faceDataArrays) {\n      return;\n    }\n    const faces = [0, 2, 4, 1, 3, 5];\n    if (mipmapGenerator) {\n      const needConversion = format === 4;\n      const mipData = mipmapGenerator(faceDataArrays);\n      const gpuTextureWrapper = texture._hardwareTexture;\n      const faces = [0, 1, 2, 3, 4, 5];\n      for (let level = 0; level < mipData.length; level++) {\n        const mipSize = width >> level;\n        const allFaces = [];\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n          let mipFaceData = mipData[level][faces[faceIndex]];\n          if (needConversion) {\n            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n          }\n          allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\n        }\n        this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\n      }\n    } else {\n      const allFaces = [];\n      for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n        allFaces.push(faceDataArrays[faces[faceIndex]]);\n      }\n      this.updateRawCubeTexture(texture, allFaces, format, type, invertY);\n    }\n    texture.isReady = true;\n    scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);\n    if (onLoad) {\n      onLoad();\n    }\n  };\n  this._loadFile(url, data => {\n    internalCallback(data);\n  }, undefined, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);\n  return texture;\n};\nWebGPUEngine.prototype.createRawTexture3D = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {\n  const source = InternalTextureSource.Raw3D;\n  const texture = new InternalTexture(this, source);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.baseDepth = depth;\n  texture.width = width;\n  texture.height = height;\n  texture.depth = depth;\n  texture.format = format;\n  texture.type = textureType;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.is3D = true;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\n  this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nWebGPUEngine.prototype.updateRawTexture3D = function (texture, bufferView, format, invertY, compression = null, textureType = 0) {\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.format = format;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n  if (bufferView) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const needConversion = format === 4;\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\n    }\n    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n  texture.isReady = true;\n};\nWebGPUEngine.prototype.createRawTexture2DArray = function (data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0, creationFlags = 0) {\n  const source = InternalTextureSource.Raw2DArray;\n  const texture = new InternalTexture(this, source);\n  texture.baseWidth = width;\n  texture.baseHeight = height;\n  texture.baseDepth = depth;\n  texture.width = width;\n  texture.height = height;\n  texture.depth = depth;\n  texture.format = format;\n  texture.type = textureType;\n  texture.generateMipMaps = generateMipMaps;\n  texture.samplingMode = samplingMode;\n  texture.is2DArray = true;\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = data;\n  }\n  this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\n  this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\n  this._internalTexturesCache.push(texture);\n  return texture;\n};\nWebGPUEngine.prototype.updateRawTexture2DArray = function (texture, bufferView, format, invertY, compression = null, textureType = 0) {\n  if (!this._doNotHandleContextLost) {\n    texture._bufferView = bufferView;\n    texture.format = format;\n    texture.invertY = invertY;\n    texture._compression = compression;\n  }\n  if (bufferView) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const needConversion = format === 4;\n    if (needConversion) {\n      bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\n    }\n    const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n    this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\n    if (texture.generateMipMaps) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n  }\n  texture.isReady = true;\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {\n  // Create new RGBA data container.\n  let rgbaData;\n  let val1 = 1;\n  if (textureType === 1) {\n    rgbaData = new Float32Array(width * height * 4);\n  } else if (textureType === 2) {\n    rgbaData = new Uint16Array(width * height * 4);\n    val1 = 15360; // 15360 is the encoding of 1 in half float\n  } else if (textureType === 7) {\n    rgbaData = new Uint32Array(width * height * 4);\n  } else {\n    rgbaData = new Uint8Array(width * height * 4);\n  }\n  // Convert each pixel.\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const index = (y * width + x) * 3;\n      const newIndex = (y * width + x) * 4;\n      // Map Old Value to new value.\n      rgbaData[newIndex + 0] = rgbData[index + 0];\n      rgbaData[newIndex + 1] = rgbData[index + 1];\n      rgbaData[newIndex + 2] = rgbData[index + 2];\n      // Add fully opaque alpha channel.\n      rgbaData[newIndex + 3] = val1;\n    }\n  }\n  return rgbaData;\n}","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","WebGPUEngine","Logger","prototype","createRawTexture","data","width","height","format","generateMipMaps","invertY","samplingMode","compression","type","texture","Raw","baseWidth","baseHeight","_compression","_useSRGBBuffer","useSRGBBuffer","_doNotHandleContextLost","_bufferView","_textureHelper","createGPUTextureForInternalTexture","undefined","creationFlags","updateRawTexture","_internalTexturesCache","push","bufferView","gpuTextureWrapper","_hardwareTexture","needConversion","_convertRGBtoRGBATextureData","Uint8Array","buffer","byteOffset","byteLength","updateTexture","depth","_generateMipmaps","_uploadEncoder","isReady","createRawCubeTexture","size","CubeRaw","Warn","isCube","_bufferViewArray","_cachedWrapU","_cachedWrapV","updateRawCubeTexture","i","length","faceData","updateCubeTextures","underlyingResource","createRawCubeTextureFromUrl","url","scene","noMipmap","callback","mipmapGenerator","onLoad","onError","addPendingData","onerror","request","exception","removePendingData","status","statusText","internalCallback","faceDataArrays","faces","mipData","level","mipSize","allFaces","faceIndex","mipFaceData","_loadFile","offlineProvider","createRawTexture3D","textureType","source","Raw3D","baseDepth","is3D","updateRawTexture3D","createRawTexture2DArray","Raw2DArray","is2DArray","updateRawTexture2DArray","rgbData","rgbaData","val1","Float32Array","Uint16Array","Uint32Array","x","y","index","newIndex"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.rawTexture.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IWebRequest } from \"../../../Misc/interfaces/iWebRequest\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"../webgpuHardwareTexture\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\ndeclare type Scene = import(\"../../../scene\").Scene;\r\n\r\nWebGPUEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0,\r\n    useSRGBBuffer: boolean = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, useSRGBBuffer);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, type);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n\r\n    if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    texture.isCube = true;\r\n    texture.format = format === Constants.TEXTUREFORMAT_RGB ? Constants.TEXTUREFORMAT_RGBA : format;\r\n    texture.type = type;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    texture.samplingMode = samplingMode;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    }\r\n\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    bufferView: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null\r\n): void {\r\n    texture._bufferViewArray = bufferView;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n    const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n    const data = [];\r\n    for (let i = 0; i < bufferView.length; ++i) {\r\n        let faceData = bufferView[i];\r\n        if (needConversion) {\r\n            faceData = _convertRGBtoRGBATextureData(bufferView[i], texture.width, texture.height, type);\r\n        }\r\n        data.push(new Uint8Array(faceData.buffer, faceData.byteOffset, faceData.byteLength));\r\n    }\r\n\r\n    this._textureHelper.updateCubeTextures(data, gpuTextureWrapper.underlyingResource!, texture.width, texture.height, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n    if (texture.generateMipMaps) {\r\n        this._generateMipmaps(texture, this._uploadEncoder);\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        const faces = [0, 2, 4, 1, 3, 5];\r\n\r\n        if (mipmapGenerator) {\r\n            const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n            const faces = [0, 1, 2, 3, 4, 5];\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n                const allFaces = [];\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faces[faceIndex]];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    allFaces.push(new Uint8Array(mipFaceData.buffer, mipFaceData.byteOffset, mipFaceData.byteLength));\r\n                }\r\n                this._textureHelper.updateCubeTextures(allFaces, gpuTextureWrapper.underlyingResource!, mipSize, mipSize, gpuTextureWrapper.format, invertY, false, 0, 0);\r\n            }\r\n        } else {\r\n            const allFaces = [];\r\n            for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                allFaces.push(faceDataArrays[faces[faceIndex]]);\r\n            }\r\n            this.updateRawCubeTexture(texture, allFaces, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        scene?.removePendingData(texture);\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture3D = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw3D;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is3D = true;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, undefined, creationFlags);\r\n\r\n    this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture3D = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\nWebGPUEngine.prototype.createRawTexture2DArray = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    depth: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    creationFlags: number = 0\r\n): InternalTexture {\r\n    const source = InternalTextureSource.Raw2DArray;\r\n    const texture = new InternalTexture(this, source);\r\n\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.baseDepth = depth;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.depth = depth;\r\n    texture.format = format;\r\n    texture.type = textureType;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.is2DArray = true;\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags);\r\n\r\n    this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nWebGPUEngine.prototype.updateRawTexture2DArray = function (\r\n    texture: InternalTexture,\r\n    bufferView: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n): void {\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = bufferView;\r\n        texture.format = format;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (bufferView) {\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const needConversion = format === Constants.TEXTUREFORMAT_RGB;\r\n\r\n        if (needConversion) {\r\n            bufferView = _convertRGBtoRGBATextureData(bufferView, texture.width, texture.height, textureType);\r\n        }\r\n\r\n        const data = new Uint8Array(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\r\n\r\n        this._textureHelper.updateTexture(data, texture, texture.width, texture.height, texture.depth, gpuTextureWrapper.format, 0, 0, invertY, false, 0, 0);\r\n        if (texture.generateMipMaps) {\r\n            this._generateMipmaps(texture, this._uploadEncoder);\r\n        }\r\n    }\r\n\r\n    texture.isReady = true;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}