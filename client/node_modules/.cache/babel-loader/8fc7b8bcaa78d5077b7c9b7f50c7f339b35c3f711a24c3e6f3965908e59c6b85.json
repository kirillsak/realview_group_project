{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\n/**\n * Defines a subdivision inside a mesh\n */\nexport class SubMesh {\n  /**\n   * Creates a new submesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\n   */\n  constructor( /** the material index to use */\n  materialIndex, /** vertex index start */\n  verticesStart, /** vertices count */\n  verticesCount, /** index start */\n  indexStart, /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    this._mainDrawWrapperOverride = null;\n    /** @internal */\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @internal */\n    this._lastColliderWorldVertices = null;\n    /** @internal */\n    this._lastColliderTransformMatrix = null;\n    /** @internal */\n    this._wasDispatched = false;\n    /** @internal */\n    this._renderId = 0;\n    /** @internal */\n    this._alphaIndex = 0;\n    /** @internal */\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n    this._engine = this._mesh.getScene().getEngine();\n    this.resetDrawCache();\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   * Gets material defines used by the effect associated to the sub mesh\n   */\n  get materialDefines() {\n    var _a;\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;\n  }\n  /**\n   * Sets material defines used by the effect associated to the sub mesh\n   */\n  set materialDefines(defines) {\n    var _a;\n    const drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n    drawWrapper.defines = defines;\n  }\n  /**\n   * @internal\n   */\n  _getDrawWrapper(passId, createIfNotExisting = false) {\n    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;\n    let drawWrapper = this._drawWrappers[passId];\n    if (!drawWrapper && createIfNotExisting) {\n      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\n    }\n    return drawWrapper;\n  }\n  /**\n   * @internal\n   */\n  _removeDrawWrapper(passId, disposeWrapper = true) {\n    var _a;\n    if (disposeWrapper) {\n      (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    this._drawWrappers[passId] = undefined;\n  }\n  /**\n   * Gets associated (main) effect (possibly the effect override if defined)\n   */\n  get effect() {\n    var _a, _b;\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;\n  }\n  /** @internal */\n  get _drawWrapper() {\n    var _a;\n    return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n  }\n  /** @internal */\n  get _drawWrapperOverride() {\n    return this._mainDrawWrapperOverride;\n  }\n  /**\n   * @internal\n   */\n  _setMainDrawWrapperOverride(wrapper) {\n    this._mainDrawWrapperOverride = wrapper;\n  }\n  /**\n   * Sets associated effect (effect used to render this submesh)\n   * @param effect defines the effect to associate with\n   * @param defines defines the set of defines used to compile this effect\n   * @param materialContext material context associated to the effect\n   * @param resetContext true to reset the draw context\n   */\n  setEffect(effect, defines = null, materialContext, resetContext = true) {\n    const drawWrapper = this._drawWrapper;\n    drawWrapper.setEffect(effect, defines, resetContext);\n    if (materialContext !== undefined) {\n      drawWrapper.materialContext = materialContext;\n    }\n    if (!effect) {\n      drawWrapper.defines = null;\n      drawWrapper.materialContext = undefined;\n    }\n  }\n  /**\n   * Resets the draw wrappers cache\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n  resetDrawCache(passId) {\n    if (this._drawWrappers) {\n      if (passId !== undefined) {\n        this._removeDrawWrapper(passId);\n        return;\n      } else {\n        for (const drawWrapper of this._drawWrappers) {\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n    this._drawWrappers = [];\n  }\n  /**\n   * Add a new submesh to a mesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns the new submesh\n   */\n  static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n  /**\n   * Returns true if this submesh covers the entire parent mesh\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get IsGlobal() {\n    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\n  }\n  /**\n   * Returns the submesh BoundingInfo object\n   * @returns current bounding info (or mesh's one if the submesh is global)\n   */\n  getBoundingInfo() {\n    if (this.IsGlobal) {\n      return this._mesh.getBoundingInfo();\n    }\n    return this._boundingInfo;\n  }\n  /**\n   * Sets the submesh BoundingInfo\n   * @param boundingInfo defines the new bounding info to use\n   * @returns the SubMesh\n   */\n  setBoundingInfo(boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  }\n  /**\n   * Returns the mesh of the current submesh\n   * @returns the parent mesh\n   */\n  getMesh() {\n    return this._mesh;\n  }\n  /**\n   * Returns the rendering mesh of the submesh\n   * @returns the rendering mesh (could be different from parent mesh)\n   */\n  getRenderingMesh() {\n    return this._renderingMesh;\n  }\n  /**\n   * Returns the replacement mesh of the submesh\n   * @returns the replacement mesh (could be different from parent mesh)\n   */\n  getReplacementMesh() {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  }\n  /**\n   * Returns the effective mesh of the submesh\n   * @returns the effective mesh (could be different from parent mesh)\n   */\n  getEffectiveMesh() {\n    const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  }\n  /**\n   * Returns the submesh material\n   * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\n   * @returns null or the current material\n   */\n  getMaterial(getDefaultMaterial = true) {\n    var _a;\n    const rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;\n    if (!rootMaterial) {\n      return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\n    } else if (this._isMultiMaterial(rootMaterial)) {\n      const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this.resetDrawCache();\n      }\n      return effectiveMaterial;\n    }\n    return rootMaterial;\n  }\n  _isMultiMaterial(material) {\n    return material.getSubMaterial !== undefined;\n  }\n  // Methods\n  /**\n   * Sets a new updated BoundingInfo object to the submesh\n   * @param data defines an optional position array to use to determine the bounding info\n   * @returns the SubMesh\n   */\n  refreshBoundingInfo(data = null) {\n    this._lastColliderWorldVertices = null;\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\n    }\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n    const indices = this._renderingMesh.getIndices();\n    let extend;\n    //is this the only submesh?\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      const boundingInfo = this._renderingMesh.getBoundingInfo();\n      //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _checkCollision(collider) {\n    const boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  }\n  /**\n   * Updates the submesh BoundingInfo\n   * @param world defines the world matrix to use to update the bounding info\n   * @returns the submesh\n   */\n  updateBoundingInfo(world) {\n    let boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n    return this;\n  }\n  /**\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is intersecting with the frustum\n   */\n  isInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  }\n  /**\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is inside the frustum\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * Renders the submesh\n   * @param enableAlphaMode defines if alpha needs to be used\n   * @returns the submesh\n   */\n  render(enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _getLinesIndexBuffer(indices, engine) {\n    if (!this._linesIndexBuffer) {\n      const linesIndices = [];\n      for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n    return this._linesIndexBuffer;\n  }\n  /**\n   * Checks if the submesh intersects with a ray\n   * @param ray defines the ray to test\n   * @returns true is the passed ray intersects the submesh bounding box\n   */\n  canIntersects(ray) {\n    const boundingInfo = this.getBoundingInfo();\n    if (!boundingInfo) {\n      return false;\n    }\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  }\n  /**\n   * Intersects current submesh with a ray\n   * @param ray defines the ray to test\n   * @param positions defines mesh's positions array\n   * @param indices defines mesh's indices array\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns intersection info or null if no intersection\n   */\n  intersects(ray, positions, indices, fastCheck, trianglePredicate) {\n    const material = this.getMaterial();\n    if (!material) {\n      return null;\n    }\n    let step = 3;\n    let checkStopper = false;\n    switch (material.fillMode) {\n      case 3:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n      default:\n        break;\n    }\n    // LineMesh first as it's also a Mesh...\n    if (material.fillMode === 4) {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  }\n  /**\n   * @internal\n   */\n  _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null;\n    // Line test\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      const p0 = positions[indices[index]];\n      const p1 = positions[indices[index + 1]];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n      if (length < 0) {\n        continue;\n      }\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null;\n    // Line test\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n      if (length < 0) {\n        continue;\n      }\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    let intersectInfo = null;\n    // Triangles test\n    let faceId = -1;\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n      faceId++;\n      const indexA = indices[index];\n      const indexB = indices[index + 1];\n      const indexC = indices[index + 2];\n      if (checkStopper && indexC === 0xffffffff) {\n        index += 2;\n        continue;\n      }\n      const p0 = positions[indexA];\n      const p1 = positions[indexB];\n      const p2 = positions[indexC];\n      // stay defensive and don't check against undefined positions.\n      if (!p0 || !p1 || !p2) {\n        continue;\n      }\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\n        continue;\n      }\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceId;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n  _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {\n    let intersectInfo = null;\n    // Triangles test\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const p2 = positions[index + 2];\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\n        continue;\n      }\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    return intersectInfo;\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  }\n  // Clone\n  /**\n   * Creates a new submesh from the passed mesh\n   * @param newMesh defines the new hosting mesh\n   * @param newRenderingMesh defines an optional rendering mesh\n   * @returns the new submesh\n   */\n  clone(newMesh, newRenderingMesh) {\n    const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n    if (!this.IsGlobal) {\n      const boundingInfo = this.getBoundingInfo();\n      if (!boundingInfo) {\n        return result;\n      }\n      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n    return result;\n  }\n  // Dispose\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n      this._linesIndexBuffer = null;\n    }\n    // Remove from mesh\n    const index = this._mesh.subMeshes.indexOf(this);\n    this._mesh.subMeshes.splice(index, 1);\n    this.resetDrawCache();\n  }\n  /**\n   * Gets the class name\n   * @returns the string \"SubMesh\".\n   */\n  getClassName() {\n    return \"SubMesh\";\n  }\n  // Statics\n  /**\n   * Creates a new submesh from indices data\n   * @param materialIndex the index of the main mesh material\n   * @param startIndex the index where to start the copy in the mesh indices array\n   * @param indexCount the number of indices to copy then from the startIndex\n   * @param mesh the main mesh to create the submesh from\n   * @param renderingMesh the optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns a new submesh\n   */\n  static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    let minVertexIndex = Number.MAX_VALUE;\n    let maxVertexIndex = -Number.MAX_VALUE;\n    const whatWillRender = renderingMesh || mesh;\n    const indices = whatWillRender.getIndices();\n    for (let index = startIndex; index < startIndex + indexCount; index++) {\n      const vertexIndex = indices[index];\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n}","map":{"version":3,"mappings":"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","names":["VertexBuffer","IntersectionInfo","BoundingInfo","extractMinAndMaxIndexed","DrawWrapper","SubMesh","constructor","materialIndex","verticesStart","verticesCount","indexStart","indexCount","mesh","renderingMesh","createBoundingBox","addToMesh","_mesh","_renderingMesh","subMeshes","push","_engine","getScene","getEngine","resetDrawCache","_trianglePlanes","_id","length","refreshBoundingInfo","computeWorldMatrix","materialDefines","_mainDrawWrapperOverride","defines","_getDrawWrapper","drawWrapper","undefined","passId","createIfNotExisting","currentRenderPassId","_drawWrappers","_removeDrawWrapper","disposeWrapper","dispose","effect","_drawWrapper","_drawWrapperOverride","_setMainDrawWrapperOverride","wrapper","setEffect","materialContext","resetContext","AddToMesh","IsGlobal","getTotalVertices","getTotalIndices","getBoundingInfo","_boundingInfo","setBoundingInfo","boundingInfo","getMesh","getRenderingMesh","getReplacementMesh","_internalAbstractMeshDataInfo","_actAsRegularMesh","getEffectiveMesh","replacementMesh","getMaterial","getDefaultMaterial","rootMaterial","getMaterialForRenderPass","material","defaultMaterial","_isMultiMaterial","effectiveMaterial","getSubMaterial","_currentMaterial","data","_lastColliderWorldVertices","geometry","getVerticesData","PositionKind","indices","getIndices","extend","minimum","clone","maximum","boundingBias","reConstruct","_checkCollision","collider","updateBoundingInfo","world","update","isInFrustum","frustumPlanes","cullingStrategy","isCompletelyInFrustum","render","enableAlphaMode","_getLinesIndexBuffer","engine","_linesIndexBuffer","linesIndices","index","createIndexBuffer","_linesIndexCount","canIntersects","ray","intersectsBox","boundingBox","intersects","positions","fastCheck","trianglePredicate","step","checkStopper","fillMode","_intersectUnIndexedLines","intersectionThreshold","_intersectLines","_unIndexed","_intersectUnIndexedTriangles","_intersectTriangles","intersectInfo","p0","p1","intersectionSegment","distance","faceId","indexA","indexB","indexC","p2","currentIntersectInfo","intersectsTriangle","_rebuild","newMesh","newRenderingMesh","result","_releaseBuffer","indexOf","splice","getClassName","CreateFromIndices","startIndex","minVertexIndex","Number","MAX_VALUE","maxVertexIndex","whatWillRender","vertexIndex"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/subMesh.ts"],"sourcesContent":["import type { Nullable, IndicesArray, DeepImmutable, FloatArray } from \"../types\";\r\nimport type { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMaxIndexed } from \"../Maths/math.functions\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { IMaterialContext } from \"../Engines/IMaterialContext\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type MaterialDefines = import(\"../Materials/materialDefines\").MaterialDefines;\r\ndeclare type MultiMaterial = import(\"../Materials/multiMaterial\").MultiMaterial;\r\ndeclare type AbstractMesh = import(\"./abstractMesh\").AbstractMesh;\r\ndeclare type Mesh = import(\"./mesh\").Mesh;\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\ndeclare type TrianglePickingPredicate = import(\"../Culling/ray\").TrianglePickingPredicate;\r\n\r\n/**\r\n * Defines a subdivision inside a mesh\r\n */\r\nexport class SubMesh implements ICullable {\r\n    private _engine: Engine;\r\n    /** @internal */\r\n    public _drawWrappers: Array<DrawWrapper>; // index in this array = pass id\r\n    private _mainDrawWrapperOverride: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Gets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public get materialDefines(): Nullable<MaterialDefines> {\r\n        return this._mainDrawWrapperOverride ? (this._mainDrawWrapperOverride.defines as MaterialDefines) : (this._getDrawWrapper()?.defines as Nullable<MaterialDefines>);\r\n    }\r\n\r\n    /**\r\n     * Sets material defines used by the effect associated to the sub mesh\r\n     */\r\n    public set materialDefines(defines: Nullable<MaterialDefines>) {\r\n        const drawWrapper = this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n        drawWrapper.defines = defines;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getDrawWrapper(passId?: number, createIfNotExisting = false): DrawWrapper | undefined {\r\n        passId = passId ?? this._engine.currentRenderPassId;\r\n        let drawWrapper = this._drawWrappers[passId];\r\n        if (!drawWrapper && createIfNotExisting) {\r\n            this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());\r\n        }\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _removeDrawWrapper(passId: number, disposeWrapper = true) {\r\n        if (disposeWrapper) {\r\n            this._drawWrappers[passId]?.dispose();\r\n        }\r\n        this._drawWrappers[passId] = undefined as any;\r\n    }\r\n\r\n    /**\r\n     * Gets associated (main) effect (possibly the effect override if defined)\r\n     */\r\n    public get effect(): Nullable<Effect> {\r\n        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapper(): DrawWrapper {\r\n        return this._mainDrawWrapperOverride ?? this._getDrawWrapper(undefined, true)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _drawWrapperOverride(): Nullable<DrawWrapper> {\r\n        return this._mainDrawWrapperOverride;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setMainDrawWrapperOverride(wrapper: Nullable<DrawWrapper>): void {\r\n        this._mainDrawWrapperOverride = wrapper;\r\n    }\r\n\r\n    /**\r\n     * Sets associated effect (effect used to render this submesh)\r\n     * @param effect defines the effect to associate with\r\n     * @param defines defines the set of defines used to compile this effect\r\n     * @param materialContext material context associated to the effect\r\n     * @param resetContext true to reset the draw context\r\n     */\r\n    public setEffect(effect: Nullable<Effect>, defines: Nullable<string | MaterialDefines> = null, materialContext?: IMaterialContext, resetContext = true) {\r\n        const drawWrapper = this._drawWrapper;\r\n        drawWrapper.setEffect(effect, defines, resetContext);\r\n        if (materialContext !== undefined) {\r\n            drawWrapper.materialContext = materialContext;\r\n        }\r\n        if (!effect) {\r\n            drawWrapper.defines = null;\r\n            drawWrapper.materialContext = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\r\n     */\r\n    public resetDrawCache(passId?: number): void {\r\n        if (this._drawWrappers) {\r\n            if (passId !== undefined) {\r\n                this._removeDrawWrapper(passId);\r\n                return;\r\n            } else {\r\n                for (const drawWrapper of this._drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    /** @internal */\r\n    public _linesIndexCount: number = 0;\r\n    private _mesh: AbstractMesh;\r\n    private _renderingMesh: Mesh;\r\n    private _boundingInfo: BoundingInfo;\r\n    private _linesIndexBuffer: Nullable<DataBuffer> = null;\r\n    /** @internal */\r\n    public _lastColliderWorldVertices: Nullable<Vector3[]> = null;\r\n    /** @internal */\r\n    public _trianglePlanes: Plane[];\r\n    /** @internal */\r\n    public _lastColliderTransformMatrix: Nullable<Matrix> = null;\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /** @internal */\r\n    public _renderId = 0;\r\n    /** @internal */\r\n    public _alphaIndex: number = 0;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    private _currentMaterial: Nullable<Material> = null;\r\n\r\n    /**\r\n     * Add a new submesh to a mesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns the new submesh\r\n     */\r\n    public static AddToMesh(\r\n        materialIndex: number,\r\n        verticesStart: number,\r\n        verticesCount: number,\r\n        indexStart: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n\r\n    /**\r\n     * Creates a new submesh\r\n     * @param materialIndex defines the material index to use\r\n     * @param verticesStart defines vertex index start\r\n     * @param verticesCount defines vertices count\r\n     * @param indexStart defines index start\r\n     * @param indexCount defines indices count\r\n     * @param mesh defines the parent mesh\r\n     * @param renderingMesh defines an optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\r\n     */\r\n    constructor(\r\n        /** the material index to use */\r\n        public materialIndex: number,\r\n        /** vertex index start */\r\n        public verticesStart: number,\r\n        /** vertices count */\r\n        public verticesCount: number,\r\n        /** index start */\r\n        public indexStart: number,\r\n        /** indices count */\r\n        public indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true,\r\n        addToMesh = true\r\n    ) {\r\n        this._mesh = mesh;\r\n        this._renderingMesh = renderingMesh || <Mesh>mesh;\r\n        if (addToMesh) {\r\n            mesh.subMeshes.push(this);\r\n        }\r\n\r\n        this._engine = this._mesh.getScene().getEngine();\r\n        this.resetDrawCache();\r\n        this._trianglePlanes = [];\r\n\r\n        this._id = mesh.subMeshes.length - 1;\r\n\r\n        if (createBoundingBox) {\r\n            this.refreshBoundingInfo();\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if this submesh covers the entire parent mesh\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get IsGlobal(): boolean {\r\n        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh BoundingInfo object\r\n     * @returns current bounding info (or mesh's one if the submesh is global)\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        if (this.IsGlobal) {\r\n            return this._mesh.getBoundingInfo();\r\n        }\r\n\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Sets the submesh BoundingInfo\r\n     * @param boundingInfo defines the new bounding info to use\r\n     * @returns the SubMesh\r\n     */\r\n    public setBoundingInfo(boundingInfo: BoundingInfo): SubMesh {\r\n        this._boundingInfo = boundingInfo;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the mesh of the current submesh\r\n     * @returns the parent mesh\r\n     */\r\n    public getMesh(): AbstractMesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the rendering mesh of the submesh\r\n     * @returns the rendering mesh (could be different from parent mesh)\r\n     */\r\n    public getRenderingMesh(): Mesh {\r\n        return this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the replacement mesh of the submesh\r\n     * @returns the replacement mesh (could be different from parent mesh)\r\n     */\r\n    public getReplacementMesh(): Nullable<AbstractMesh> {\r\n        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n    }\r\n\r\n    /**\r\n     * Returns the effective mesh of the submesh\r\n     * @returns the effective mesh (could be different from parent mesh)\r\n     */\r\n    public getEffectiveMesh(): AbstractMesh {\r\n        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\r\n\r\n        return replacementMesh ? replacementMesh : this._renderingMesh;\r\n    }\r\n\r\n    /**\r\n     * Returns the submesh material\r\n     * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\r\n     * @returns null or the current material\r\n     */\r\n    public getMaterial(getDefaultMaterial = true): Nullable<Material> {\r\n        const rootMaterial = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;\r\n\r\n        if (!rootMaterial) {\r\n            return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\r\n        } else if (this._isMultiMaterial(rootMaterial)) {\r\n            const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\r\n\r\n            if (this._currentMaterial !== effectiveMaterial) {\r\n                this._currentMaterial = effectiveMaterial;\r\n                this.resetDrawCache();\r\n            }\r\n\r\n            return effectiveMaterial;\r\n        }\r\n\r\n        return rootMaterial;\r\n    }\r\n\r\n    private _isMultiMaterial(material: Material): material is MultiMaterial {\r\n        return (material as MultiMaterial).getSubMaterial !== undefined;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Sets a new updated BoundingInfo object to the submesh\r\n     * @param data defines an optional position array to use to determine the bounding info\r\n     * @returns the SubMesh\r\n     */\r\n    public refreshBoundingInfo(data: Nullable<FloatArray> = null): SubMesh {\r\n        this._lastColliderWorldVertices = null;\r\n\r\n        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\r\n            return this;\r\n        }\r\n\r\n        if (!data) {\r\n            data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);\r\n        }\r\n\r\n        if (!data) {\r\n            this._boundingInfo = this._mesh.getBoundingInfo();\r\n            return this;\r\n        }\r\n\r\n        const indices = <IndicesArray>this._renderingMesh.getIndices();\r\n        let extend: { minimum: Vector3; maximum: Vector3 };\r\n\r\n        //is this the only submesh?\r\n        if (this.indexStart === 0 && this.indexCount === indices.length) {\r\n            const boundingInfo = this._renderingMesh.getBoundingInfo();\r\n\r\n            //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\r\n            extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };\r\n        } else {\r\n            extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\r\n        }\r\n\r\n        if (this._boundingInfo) {\r\n            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\r\n        } else {\r\n            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        return boundingInfo._checkCollision(collider);\r\n    }\r\n\r\n    /**\r\n     * Updates the submesh BoundingInfo\r\n     * @param world defines the world matrix to use to update the bounding info\r\n     * @returns the submesh\r\n     */\r\n    public updateBoundingInfo(world: DeepImmutable<Matrix>): SubMesh {\r\n        let boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            this.refreshBoundingInfo();\r\n            boundingInfo = this.getBoundingInfo();\r\n        }\r\n        if (boundingInfo) {\r\n            (<BoundingInfo>boundingInfo).update(world);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is intersecting with the frustum\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\r\n     * @param frustumPlanes defines the frustum planes\r\n     * @returns true if the submesh is inside the frustum\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Plane[]): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return boundingInfo.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Renders the submesh\r\n     * @param enableAlphaMode defines if alpha needs to be used\r\n     * @returns the submesh\r\n     */\r\n    public render(enableAlphaMode: boolean): SubMesh {\r\n        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLinesIndexBuffer(indices: IndicesArray, engine: Engine): DataBuffer {\r\n        if (!this._linesIndexBuffer) {\r\n            const linesIndices = [];\r\n\r\n            for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\r\n                linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\r\n            }\r\n\r\n            this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\r\n            this._linesIndexCount = linesIndices.length;\r\n        }\r\n        return this._linesIndexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submesh intersects with a ray\r\n     * @param ray defines the ray to test\r\n     * @returns true is the passed ray intersects the submesh bounding box\r\n     */\r\n    public canIntersects(ray: Ray): boolean {\r\n        const boundingInfo = this.getBoundingInfo();\r\n\r\n        if (!boundingInfo) {\r\n            return false;\r\n        }\r\n        return ray.intersectsBox(boundingInfo.boundingBox);\r\n    }\r\n\r\n    /**\r\n     * Intersects current submesh with a ray\r\n     * @param ray defines the ray to test\r\n     * @param positions defines mesh's positions array\r\n     * @param indices defines mesh's indices array\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @returns intersection info or null if no intersection\r\n     */\r\n    public intersects(ray: Ray, positions: Vector3[], indices: IndicesArray, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<IntersectionInfo> {\r\n        const material = this.getMaterial();\r\n        if (!material) {\r\n            return null;\r\n        }\r\n        let step = 3;\r\n        let checkStopper = false;\r\n\r\n        switch (material.fillMode) {\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                return null;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                step = 1;\r\n                checkStopper = true;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n\r\n        // LineMesh first as it's also a Mesh...\r\n        if (material.fillMode === Constants.MATERIAL_LineListDrawMode) {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length) {\r\n                return this._intersectUnIndexedLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n            }\r\n            return this._intersectLines(ray, positions, indices, (this._mesh as any).intersectionThreshold, fastCheck);\r\n        } else {\r\n            // Check if mesh is unindexed\r\n            if (!indices.length && this._mesh._unIndexed) {\r\n                return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\r\n            }\r\n\r\n            return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\r\n            const p0 = positions[indices[index]];\r\n            const p1 = positions[indices[index + 1]];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedLines(ray: Ray, positions: Vector3[], indices: IndicesArray, intersectionThreshold: number, fastCheck?: boolean): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Line test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n\r\n            const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\r\n            if (length < 0) {\r\n                continue;\r\n            }\r\n\r\n            if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\r\n                intersectInfo = new IntersectionInfo(null, null, length);\r\n                intersectInfo.faceId = index / 2;\r\n                if (fastCheck) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        step: number,\r\n        checkStopper: boolean,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n\r\n        // Triangles test\r\n        let faceId = -1;\r\n        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\r\n            faceId++;\r\n            const indexA = indices[index];\r\n            const indexB = indices[index + 1];\r\n            const indexC = indices[index + 2];\r\n\r\n            if (checkStopper && indexC === 0xffffffff) {\r\n                index += 2;\r\n                continue;\r\n            }\r\n\r\n            const p0 = positions[indexA];\r\n            const p1 = positions[indexB];\r\n            const p2 = positions[indexC];\r\n\r\n            // stay defensive and don't check against undefined positions.\r\n            if (!p0 || !p1 || !p2) {\r\n                continue;\r\n            }\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = faceId;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _intersectUnIndexedTriangles(\r\n        ray: Ray,\r\n        positions: Vector3[],\r\n        indices: IndicesArray,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate\r\n    ): Nullable<IntersectionInfo> {\r\n        let intersectInfo: Nullable<IntersectionInfo> = null;\r\n        // Triangles test\r\n        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\r\n            const p0 = positions[index];\r\n            const p1 = positions[index + 1];\r\n            const p2 = positions[index + 2];\r\n\r\n            if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\r\n                continue;\r\n            }\r\n\r\n            const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\r\n\r\n            if (currentIntersectInfo) {\r\n                if (currentIntersectInfo.distance < 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\r\n                    intersectInfo = currentIntersectInfo;\r\n                    intersectInfo.faceId = index / 3;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return intersectInfo;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._linesIndexBuffer = null;\r\n        }\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Creates a new submesh from the passed mesh\r\n     * @param newMesh defines the new hosting mesh\r\n     * @param newRenderingMesh defines an optional rendering mesh\r\n     * @returns the new submesh\r\n     */\r\n    public clone(newMesh: AbstractMesh, newRenderingMesh?: Mesh): SubMesh {\r\n        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\r\n\r\n        if (!this.IsGlobal) {\r\n            const boundingInfo = this.getBoundingInfo();\r\n\r\n            if (!boundingInfo) {\r\n                return result;\r\n            }\r\n\r\n            result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Dispose\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._linesIndexBuffer) {\r\n            this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\r\n            this._linesIndexBuffer = null;\r\n        }\r\n\r\n        // Remove from mesh\r\n        const index = this._mesh.subMeshes.indexOf(this);\r\n        this._mesh.subMeshes.splice(index, 1);\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns the string \"SubMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"SubMesh\";\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a new submesh from indices data\r\n     * @param materialIndex the index of the main mesh material\r\n     * @param startIndex the index where to start the copy in the mesh indices array\r\n     * @param indexCount the number of indices to copy then from the startIndex\r\n     * @param mesh the main mesh to create the submesh from\r\n     * @param renderingMesh the optional rendering mesh\r\n     * @param createBoundingBox defines if bounding box should be created for this submesh\r\n     * @returns a new submesh\r\n     */\r\n    public static CreateFromIndices(\r\n        materialIndex: number,\r\n        startIndex: number,\r\n        indexCount: number,\r\n        mesh: AbstractMesh,\r\n        renderingMesh?: Mesh,\r\n        createBoundingBox: boolean = true\r\n    ): SubMesh {\r\n        let minVertexIndex = Number.MAX_VALUE;\r\n        let maxVertexIndex = -Number.MAX_VALUE;\r\n\r\n        const whatWillRender = renderingMesh || mesh;\r\n        const indices = whatWillRender!.getIndices()!;\r\n\r\n        for (let index = startIndex; index < startIndex + indexCount; index++) {\r\n            const vertexIndex = indices[index];\r\n\r\n            if (vertexIndex < minVertexIndex) {\r\n                minVertexIndex = vertexIndex;\r\n            }\r\n            if (vertexIndex > maxVertexIndex) {\r\n                maxVertexIndex = vertexIndex;\r\n            }\r\n        }\r\n\r\n        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}