{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\n/**\n * PostProcessRenderPipeline\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderPipeline {\n  /**\n   * Initializes a PostProcessRenderPipeline\n   * @param _engine engine to add the pipeline to\n   * @param name name of the pipeline\n   */\n  constructor(_engine, name) {\n    this._engine = _engine;\n    this._name = name;\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n    this._cameras = [];\n  }\n  /**\n   * Gets pipeline name\n   */\n  get name() {\n    return this._name;\n  }\n  /** Gets the list of attached cameras */\n  get cameras() {\n    return this._cameras;\n  }\n  /**\n   * Gets the class name\n   * @returns \"PostProcessRenderPipeline\"\n   */\n  getClassName() {\n    return \"PostProcessRenderPipeline\";\n  }\n  /**\n   * If all the render effects in the pipeline are supported\n   */\n  get isSupported() {\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        if (!this._renderEffects[renderEffectName].isSupported) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Adds an effect to the pipeline\n   * @param renderEffect the effect to add\n   */\n  addEffect(renderEffect) {\n    this._renderEffects[renderEffect._name] = renderEffect;\n  }\n  // private\n  /** @internal */\n  _rebuild() {}\n  /**\n   * @internal\n   */\n  _enableEffect(renderEffectName, cameras) {\n    const renderEffects = this._renderEffects[renderEffectName];\n    if (!renderEffects) {\n      return;\n    }\n    renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\n  }\n  /**\n   * @internal\n   */\n  _disableEffect(renderEffectName, cameras) {\n    const renderEffects = this._renderEffects[renderEffectName];\n    if (!renderEffects) {\n      return;\n    }\n    renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\n  }\n  /**\n   * @internal\n   */\n  _attachCameras(cameras, unique) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    const indicesToDelete = [];\n    let i;\n    for (i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      if (!camera) {\n        continue;\n      }\n      if (this._cameras.indexOf(camera) === -1) {\n        this._cameras.push(camera);\n      } else if (unique) {\n        indicesToDelete.push(i);\n      }\n    }\n    for (i = 0; i < indicesToDelete.length; i++) {\n      cams.splice(indicesToDelete[i], 1);\n    }\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        this._renderEffects[renderEffectName]._attachCameras(cams);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachCameras(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        this._renderEffects[renderEffectName]._detachCameras(cams);\n      }\n    }\n    for (let i = 0; i < cams.length; i++) {\n      this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\n    }\n  }\n  /** @internal */\n  _update() {\n    for (const renderEffectName in this._renderEffects) {\n      if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\n        this._renderEffects[renderEffectName]._update();\n      }\n    }\n    for (let i = 0; i < this._cameras.length; i++) {\n      if (!this._cameras[i]) {\n        continue;\n      }\n      const cameraName = this._cameras[i].name;\n      if (this._renderEffectsForIsolatedPass[cameraName]) {\n        this._renderEffectsForIsolatedPass[cameraName]._update();\n      }\n    }\n  }\n  /** @internal */\n  _reset() {\n    this._renderEffects = {};\n    this._renderEffectsForIsolatedPass = new Array();\n  }\n  _enableMSAAOnFirstPostProcess(sampleCount) {\n    if (!this._engine._features.supportMSAA) {\n      return false;\n    }\n    // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\n    const effectKeys = Object.keys(this._renderEffects);\n    if (effectKeys.length > 0) {\n      const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\n      if (postProcesses) {\n        postProcesses[0].samples = sampleCount;\n      }\n    }\n    return true;\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  setPrePassRenderer(prePassRenderer) {\n    // Do Nothing by default\n    return false;\n  }\n  /**\n   * Disposes of the pipeline\n   */\n  dispose() {\n    // Must be implemented by children\n  }\n}\n__decorate([serialize()], PostProcessRenderPipeline.prototype, \"_name\", void 0);","map":{"version":3,"mappings":"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","names":["Tools","serialize","PostProcessRenderPipeline","constructor","_engine","name","_name","_renderEffects","_renderEffectsForIsolatedPass","Array","_cameras","cameras","getClassName","isSupported","renderEffectName","Object","prototype","hasOwnProperty","call","addEffect","renderEffect","_rebuild","_enableEffect","renderEffects","_enable","MakeArray","_disableEffect","_disable","_attachCameras","unique","cams","indicesToDelete","i","length","camera","indexOf","push","splice","_detachCameras","_update","cameraName","_reset","_enableMSAAOnFirstPostProcess","sampleCount","_features","supportMSAA","effectKeys","keys","postProcesses","getPostProcesses","samples","setPrePassRenderer","prePassRenderer","dispose","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/RenderPipeline/postProcessRenderPipeline.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { PostProcessRenderEffect } from \"./postProcessRenderEffect\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\n\r\ndeclare type PrePassRenderer = import(\"../../Rendering/prePassRenderer\").PrePassRenderer;\r\n\r\n/**\r\n * PostProcessRenderPipeline\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderPipeline {\r\n    protected _renderEffects: { [key: string]: PostProcessRenderEffect };\r\n    protected _renderEffectsForIsolatedPass: PostProcessRenderEffect[];\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    protected _cameras: Camera[];\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _name: string;\r\n\r\n    /**\r\n     * Gets pipeline name\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /** Gets the list of attached cameras */\r\n    public get cameras() {\r\n        return this._cameras;\r\n    }\r\n\r\n    /**\r\n     * Initializes a PostProcessRenderPipeline\r\n     * @param _engine engine to add the pipeline to\r\n     * @param name name of the pipeline\r\n     */\r\n    constructor(private _engine: Engine, name: string) {\r\n        this._name = name;\r\n\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n\r\n        this._cameras = [];\r\n    }\r\n\r\n    /**\r\n     * Gets the class name\r\n     * @returns \"PostProcessRenderPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcessRenderPipeline\";\r\n    }\r\n\r\n    /**\r\n     * If all the render effects in the pipeline are supported\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                if (!this._renderEffects[renderEffectName].isSupported) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Adds an effect to the pipeline\r\n     * @param renderEffect the effect to add\r\n     */\r\n    public addEffect(renderEffect: PostProcessRenderEffect): void {\r\n        (<any>this._renderEffects)[renderEffect._name] = renderEffect;\r\n    }\r\n\r\n    // private\r\n\r\n    /** @internal */\r\n    public _rebuild() {}\r\n\r\n    /** @internal */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera): void;\r\n    /** @internal */\r\n    public _enableEffect(renderEffectName: string, cameras: Camera[]): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _enableEffect(renderEffectName: string, cameras: any): void {\r\n        const renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._enable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @internal */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /** @internal */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _disableEffect(renderEffectName: string, cameras: Nullable<Camera[]>): void {\r\n        const renderEffects: PostProcessRenderEffect = (<any>this._renderEffects)[renderEffectName];\r\n\r\n        if (!renderEffects) {\r\n            return;\r\n        }\r\n\r\n        renderEffects._disable(Tools.MakeArray(cameras || this._cameras));\r\n    }\r\n\r\n    /** @internal */\r\n    public _attachCameras(cameras: Camera, unique: boolean): void;\r\n    /** @internal */\r\n    public _attachCameras(cameras: Camera[], unique: boolean): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: any, unique: boolean): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        const indicesToDelete = [];\r\n        let i: number;\r\n        for (i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            if (this._cameras.indexOf(camera) === -1) {\r\n                this._cameras.push(camera);\r\n            } else if (unique) {\r\n                indicesToDelete.push(i);\r\n            }\r\n        }\r\n\r\n        for (i = 0; i < indicesToDelete.length; i++) {\r\n            cams.splice(indicesToDelete[i], 1);\r\n        }\r\n\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._attachCameras(cams);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /** @internal */\r\n    public _detachCameras(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._detachCameras(cams);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            this._cameras.splice(this._cameras.indexOf(cams[i]), 1);\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _update(): void {\r\n        for (const renderEffectName in this._renderEffects) {\r\n            if (Object.prototype.hasOwnProperty.call(this._renderEffects, renderEffectName)) {\r\n                this._renderEffects[renderEffectName]._update();\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            if (!this._cameras[i]) {\r\n                continue;\r\n            }\r\n            const cameraName = this._cameras[i].name;\r\n            if ((<any>this._renderEffectsForIsolatedPass)[cameraName]) {\r\n                (<any>this._renderEffectsForIsolatedPass)[cameraName]._update();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _reset(): void {\r\n        this._renderEffects = {};\r\n        this._renderEffectsForIsolatedPass = new Array<PostProcessRenderEffect>();\r\n    }\r\n\r\n    protected _enableMSAAOnFirstPostProcess(sampleCount: number): boolean {\r\n        if (!this._engine._features.supportMSAA) {\r\n            return false;\r\n        }\r\n\r\n        // Set samples of the very first post process to 4 to enable native anti-aliasing in browsers that support webGL 2.0 (See: https://github.com/BabylonJS/Babylon.js/issues/3754)\r\n        const effectKeys = Object.keys(this._renderEffects);\r\n        if (effectKeys.length > 0) {\r\n            const postProcesses = this._renderEffects[effectKeys[0]].getPostProcesses();\r\n            if (postProcesses) {\r\n                postProcesses[0].samples = sampleCount;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        // Do Nothing by default\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the pipeline\r\n     */\r\n    public dispose() {\r\n        // Must be implemented by children\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}