{"ast":null,"code":"import { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space } from \"../Maths/math.axis.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Class used to apply inverse kinematics to bones\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#boneikcontroller\n */\nexport class BoneIKController {\n  /**\n   * Creates a new BoneIKController\n   * @param mesh defines the TransformNode to control\n   * @param bone defines the bone to control. The bone needs to have a parent bone. It also needs to have a length greater than 0 or a children we can use to infer its length.\n   * @param options defines options to set up the controller\n   * @param options.targetMesh\n   * @param options.poleTargetMesh\n   * @param options.poleTargetBone\n   * @param options.poleTargetLocalOffset\n   * @param options.poleAngle\n   * @param options.bendAxis\n   * @param options.maxAngle\n   * @param options.slerpAmount\n   */\n  constructor(mesh, bone, options) {\n    /**\n     * Gets or sets the target position\n     */\n    this.targetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target position\n     */\n    this.poleTargetPosition = Vector3.Zero();\n    /**\n     * Gets or sets the pole target local offset\n     */\n    this.poleTargetLocalOffset = Vector3.Zero();\n    /**\n     * Gets or sets the pole angle\n     */\n    this.poleAngle = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n    this.slerpAmount = 1;\n    this._bone1Quat = Quaternion.Identity();\n    this._bone1Mat = Matrix.Identity();\n    this._bone2Ang = Math.PI;\n    this._maxAngle = Math.PI;\n    this._rightHandedSystem = false;\n    this._bendAxis = Vector3.Right();\n    this._slerping = false;\n    this._adjustRoll = 0;\n    this._notEnoughInformation = false;\n    this._bone2 = bone;\n    const bone1 = bone.getParent();\n    if (!bone1) {\n      this._notEnoughInformation = true;\n      Logger.Error(\"BoneIKController: bone must have a parent for IK to work.\");\n      return;\n    }\n    this._bone1 = bone1;\n    if (this._bone2.children.length === 0 && !this._bone2.length) {\n      this._notEnoughInformation = true;\n      Logger.Error(\"BoneIKController: bone must not be a leaf or it should have a length for IK to work.\");\n      return;\n    }\n    this.mesh = mesh;\n    const bonePos = bone.getPosition();\n    if (bone.getAbsoluteTransform().determinant() > 0) {\n      this._rightHandedSystem = true;\n      this._bendAxis.x = 0;\n      this._bendAxis.y = 0;\n      this._bendAxis.z = -1;\n      if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\n        this._adjustRoll = Math.PI * 0.5;\n        this._bendAxis.z = 1;\n      }\n    }\n    if (this._bone1.length && this._bone2.length) {\n      const boneScale1 = this._bone1.getScale();\n      const boneScale2 = this._bone2.getScale();\n      this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n    } else if (this._bone2.children[0]) {\n      mesh.computeWorldMatrix(true);\n      const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\n      const pos2 = this._bone2.getAbsolutePosition(mesh);\n      const pos3 = this._bone1.getAbsolutePosition(mesh);\n      this._bone2Length = Vector3.Distance(pos1, pos2);\n      this._bone1Length = Vector3.Distance(pos2, pos3);\n    } else {\n      mesh.computeWorldMatrix(true);\n      const boneScale2 = this._bone2.getScale();\n      this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n      const pos2 = this._bone2.getAbsolutePosition(mesh);\n      const pos3 = this._bone1.getAbsolutePosition(mesh);\n      this._bone1Length = Vector3.Distance(pos2, pos3);\n    }\n    this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\n    this.maxAngle = Math.PI;\n    if (options) {\n      if (options.targetMesh) {\n        this.targetMesh = options.targetMesh;\n        this.targetMesh.computeWorldMatrix(true);\n      }\n      if (options.poleTargetMesh) {\n        this.poleTargetMesh = options.poleTargetMesh;\n        this.poleTargetMesh.computeWorldMatrix(true);\n      } else if (options.poleTargetBone) {\n        this.poleTargetBone = options.poleTargetBone;\n      } else if (this._bone1.getParent()) {\n        this.poleTargetBone = this._bone1.getParent();\n      }\n      if (options.poleTargetLocalOffset) {\n        this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\n      }\n      if (options.poleAngle) {\n        this.poleAngle = options.poleAngle;\n      }\n      if (options.bendAxis) {\n        this._bendAxis.copyFrom(options.bendAxis);\n      }\n      if (options.maxAngle) {\n        this.maxAngle = options.maxAngle;\n      }\n      if (options.slerpAmount) {\n        this.slerpAmount = options.slerpAmount;\n      }\n    }\n  }\n  /**\n   * Gets or sets maximum allowed angle\n   */\n  get maxAngle() {\n    return this._maxAngle;\n  }\n  set maxAngle(value) {\n    this._setMaxAngle(value);\n  }\n  _setMaxAngle(ang) {\n    if (ang < 0) {\n      ang = 0;\n    }\n    if (ang > Math.PI || ang == undefined) {\n      ang = Math.PI;\n    }\n    this._maxAngle = ang;\n    const a = this._bone1Length;\n    const b = this._bone2Length;\n    this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\n  }\n  /**\n   * Force the controller to update the bones\n   */\n  update() {\n    if (this._notEnoughInformation) {\n      return;\n    }\n    const target = this.targetPosition;\n    const poleTarget = this.poleTargetPosition;\n    const mat1 = BoneIKController._TmpMats[0];\n    const mat2 = BoneIKController._TmpMats[1];\n    if (this.targetMesh) {\n      target.copyFrom(this.targetMesh.getAbsolutePosition());\n    }\n    if (this.poleTargetBone) {\n      this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\n    } else if (this.poleTargetMesh) {\n      Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\n    }\n    const bonePos = BoneIKController._TmpVecs[0];\n    const zaxis = BoneIKController._TmpVecs[1];\n    const xaxis = BoneIKController._TmpVecs[2];\n    const yaxis = BoneIKController._TmpVecs[3];\n    const upAxis = BoneIKController._TmpVecs[4];\n    const tmpQuat = BoneIKController._TmpQuat;\n    this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);\n    poleTarget.subtractToRef(bonePos, upAxis);\n    if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\n      upAxis.y = 1;\n    } else {\n      upAxis.normalize();\n    }\n    target.subtractToRef(bonePos, yaxis);\n    yaxis.normalize();\n    Vector3.CrossToRef(yaxis, upAxis, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(yaxis, zaxis, xaxis);\n    xaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\n    const a = this._bone1Length;\n    const b = this._bone2Length;\n    let c = Vector3.Distance(bonePos, target);\n    if (this._maxReach > 0) {\n      c = Math.min(this._maxReach, c);\n    }\n    let acosa = (b * b + c * c - a * a) / (2 * b * c);\n    let acosb = (c * c + a * a - b * b) / (2 * c * a);\n    if (acosa > 1) {\n      acosa = 1;\n    }\n    if (acosb > 1) {\n      acosb = 1;\n    }\n    if (acosa < -1) {\n      acosa = -1;\n    }\n    if (acosb < -1) {\n      acosb = -1;\n    }\n    const angA = Math.acos(acosa);\n    const angB = Math.acos(acosb);\n    let angC = -angA - angB;\n    if (this._rightHandedSystem) {\n      Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n      Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    } else {\n      const _tmpVec = BoneIKController._TmpVecs[5];\n      _tmpVec.copyFrom(this._bendAxis);\n      _tmpVec.x *= -1;\n      Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\n      mat2.multiplyToRef(mat1, mat1);\n    }\n    if (this.poleAngle) {\n      Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\n      mat1.multiplyToRef(mat2, mat1);\n    }\n    if (this._bone1) {\n      if (this.slerpAmount < 1) {\n        if (!this._slerping) {\n          Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\n        }\n        Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\n        Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\n        angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\n        this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\n        this._slerping = true;\n      } else {\n        this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\n        this._bone1Mat.copyFrom(mat1);\n        this._slerping = false;\n      }\n      this._updateLinkedTransformRotation(this._bone1);\n    }\n    this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\n    this._updateLinkedTransformRotation(this._bone2);\n    this._bone2Ang = angC;\n  }\n  _updateLinkedTransformRotation(bone) {\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  }\n}\nBoneIKController._TmpVecs = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\nBoneIKController._TmpQuat = Quaternion.Identity();\nBoneIKController._TmpMats = [Matrix.Identity(), Matrix.Identity()];","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","Space","Logger","BoneIKController","constructor","mesh","bone","options","Zero","Identity","Math","PI","Right","_bone2","bone1","getParent","_notEnoughInformation","Error","_bone1","children","length","bonePos","getPosition","getAbsoluteTransform","determinant","_rightHandedSystem","_bendAxis","x","y","z","_adjustRoll","boneScale1","getScale","boneScale2","_bone1Length","scaling","_bone2Length","computeWorldMatrix","pos1","getAbsolutePosition","pos2","pos3","Distance","getRotationMatrixToRef","WORLD","_bone1Mat","maxAngle","targetMesh","poleTargetMesh","poleTargetBone","poleTargetLocalOffset","copyFrom","poleAngle","bendAxis","slerpAmount","_maxAngle","value","_setMaxAngle","ang","undefined","a","b","_maxReach","sqrt","cos","update","target","targetPosition","poleTarget","poleTargetPosition","mat1","_TmpMats","mat2","getAbsolutePositionFromLocalToRef","TransformCoordinatesToRef","getWorldMatrix","_TmpVecs","zaxis","xaxis","yaxis","upAxis","tmpQuat","_TmpQuat","getAbsolutePositionToRef","subtractToRef","normalize","CrossToRef","FromXYZAxesToRef","c","min","acosa","acosb","angA","acos","angB","angC","RotationYawPitchRollToRef","multiplyToRef","RotationAxisToRef","_tmpVec","_slerping","FromRotationMatrixToRef","_bone1Quat","SlerpToRef","_bone2Ang","setRotationQuaternion","setRotationMatrix","_updateLinkedTransformRotation","setAxisAngle","LOCAL","_linkedTransformNode","rotationQuaternion","getRotationQuaternionToRef"],"sourceRoot":"","sources":["../../../../lts/core/generated/Bones/boneIKController.ts"],"sourcesContent":["import type { Bone } from \"./bone\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Space } from \"../Maths/math.axis\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Class used to apply inverse kinematics to bones\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#boneikcontroller\r\n */\r\nexport class BoneIKController {\r\n    private static _TmpVecs: Vector3[] = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = [Matrix.Identity(), Matrix.Identity()];\r\n\r\n    /**\r\n     * Gets or sets the target TransformNode\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public targetMesh: TransformNode;\r\n\r\n    /** Gets or sets the mesh used as pole */\r\n    public poleTargetMesh: TransformNode;\r\n\r\n    /**\r\n     * Gets or sets the bone used as pole\r\n     */\r\n    public poleTargetBone: Nullable<Bone>;\r\n\r\n    /**\r\n     * Gets or sets the target position\r\n     */\r\n    public targetPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole target position\r\n     */\r\n    public poleTargetPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole target local offset\r\n     */\r\n    public poleTargetLocalOffset = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets the pole angle\r\n     */\r\n    public poleAngle = 0;\r\n\r\n    /**\r\n     * Gets or sets the TransformNode associated with the controller\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public mesh: TransformNode;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _bone1Quat = Quaternion.Identity();\r\n    private _bone1Mat = Matrix.Identity();\r\n    private _bone2Ang = Math.PI;\r\n\r\n    private _bone1: Bone;\r\n    private _bone2: Bone;\r\n    private _bone1Length: number;\r\n    private _bone2Length: number;\r\n    private _maxAngle = Math.PI;\r\n    private _maxReach: number;\r\n\r\n    private _rightHandedSystem = false;\r\n\r\n    private _bendAxis = Vector3.Right();\r\n    private _slerping = false;\r\n\r\n    private _adjustRoll = 0;\r\n\r\n    private _notEnoughInformation = false;\r\n\r\n    /**\r\n     * Gets or sets maximum allowed angle\r\n     */\r\n    public get maxAngle(): number {\r\n        return this._maxAngle;\r\n    }\r\n\r\n    public set maxAngle(value: number) {\r\n        this._setMaxAngle(value);\r\n    }\r\n\r\n    /**\r\n     * Creates a new BoneIKController\r\n     * @param mesh defines the TransformNode to control\r\n     * @param bone defines the bone to control. The bone needs to have a parent bone. It also needs to have a length greater than 0 or a children we can use to infer its length.\r\n     * @param options defines options to set up the controller\r\n     * @param options.targetMesh\r\n     * @param options.poleTargetMesh\r\n     * @param options.poleTargetBone\r\n     * @param options.poleTargetLocalOffset\r\n     * @param options.poleAngle\r\n     * @param options.bendAxis\r\n     * @param options.maxAngle\r\n     * @param options.slerpAmount\r\n     */\r\n    constructor(\r\n        mesh: TransformNode,\r\n        bone: Bone,\r\n        options?: {\r\n            targetMesh?: TransformNode;\r\n            poleTargetMesh?: TransformNode;\r\n            poleTargetBone?: Bone;\r\n            poleTargetLocalOffset?: Vector3;\r\n            poleAngle?: number;\r\n            bendAxis?: Vector3;\r\n            maxAngle?: number;\r\n            slerpAmount?: number;\r\n        }\r\n    ) {\r\n        this._bone2 = bone;\r\n        const bone1 = bone.getParent();\r\n\r\n        if (!bone1) {\r\n            this._notEnoughInformation = true;\r\n            Logger.Error(\"BoneIKController: bone must have a parent for IK to work.\");\r\n            return;\r\n        }\r\n        this._bone1 = bone1;\r\n\r\n        if (this._bone2.children.length === 0 && !this._bone2.length) {\r\n            this._notEnoughInformation = true;\r\n            Logger.Error(\"BoneIKController: bone must not be a leaf or it should have a length for IK to work.\");\r\n            return;\r\n        }\r\n\r\n        this.mesh = mesh;\r\n\r\n        const bonePos = bone.getPosition();\r\n\r\n        if (bone.getAbsoluteTransform().determinant() > 0) {\r\n            this._rightHandedSystem = true;\r\n            this._bendAxis.x = 0;\r\n            this._bendAxis.y = 0;\r\n            this._bendAxis.z = -1;\r\n\r\n            if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\r\n                this._adjustRoll = Math.PI * 0.5;\r\n                this._bendAxis.z = 1;\r\n            }\r\n        }\r\n\r\n        if (this._bone1.length && this._bone2.length) {\r\n            const boneScale1 = this._bone1.getScale();\r\n            const boneScale2 = this._bone2.getScale();\r\n\r\n            this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\r\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\r\n        } else if (this._bone2.children[0]) {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            const pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\r\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\r\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\r\n\r\n            this._bone2Length = Vector3.Distance(pos1, pos2);\r\n            this._bone1Length = Vector3.Distance(pos2, pos3);\r\n        } else {\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            const boneScale2 = this._bone2.getScale();\r\n            this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\r\n\r\n            const pos2 = this._bone2.getAbsolutePosition(mesh);\r\n            const pos3 = this._bone1.getAbsolutePosition(mesh);\r\n\r\n            this._bone1Length = Vector3.Distance(pos2, pos3);\r\n        }\r\n\r\n        this._bone1.getRotationMatrixToRef(Space.WORLD, mesh, this._bone1Mat);\r\n        this.maxAngle = Math.PI;\r\n\r\n        if (options) {\r\n            if (options.targetMesh) {\r\n                this.targetMesh = options.targetMesh;\r\n                this.targetMesh.computeWorldMatrix(true);\r\n            }\r\n\r\n            if (options.poleTargetMesh) {\r\n                this.poleTargetMesh = options.poleTargetMesh;\r\n                this.poleTargetMesh.computeWorldMatrix(true);\r\n            } else if (options.poleTargetBone) {\r\n                this.poleTargetBone = options.poleTargetBone;\r\n            } else if (this._bone1.getParent()) {\r\n                this.poleTargetBone = this._bone1.getParent();\r\n            }\r\n\r\n            if (options.poleTargetLocalOffset) {\r\n                this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\r\n            }\r\n\r\n            if (options.poleAngle) {\r\n                this.poleAngle = options.poleAngle;\r\n            }\r\n\r\n            if (options.bendAxis) {\r\n                this._bendAxis.copyFrom(options.bendAxis);\r\n            }\r\n\r\n            if (options.maxAngle) {\r\n                this.maxAngle = options.maxAngle;\r\n            }\r\n\r\n            if (options.slerpAmount) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setMaxAngle(ang: number): void {\r\n        if (ang < 0) {\r\n            ang = 0;\r\n        }\r\n\r\n        if (ang > Math.PI || ang == undefined) {\r\n            ang = Math.PI;\r\n        }\r\n\r\n        this._maxAngle = ang;\r\n\r\n        const a = this._bone1Length;\r\n        const b = this._bone2Length;\r\n\r\n        this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\r\n    }\r\n\r\n    /**\r\n     * Force the controller to update the bones\r\n     */\r\n    public update(): void {\r\n        if (this._notEnoughInformation) {\r\n            return;\r\n        }\r\n\r\n        const target = this.targetPosition;\r\n        const poleTarget = this.poleTargetPosition;\r\n\r\n        const mat1 = BoneIKController._TmpMats[0];\r\n        const mat2 = BoneIKController._TmpMats[1];\r\n\r\n        if (this.targetMesh) {\r\n            target.copyFrom(this.targetMesh.getAbsolutePosition());\r\n        }\r\n\r\n        if (this.poleTargetBone) {\r\n            this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\r\n        } else if (this.poleTargetMesh) {\r\n            Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\r\n        }\r\n\r\n        const bonePos = BoneIKController._TmpVecs[0];\r\n        const zaxis = BoneIKController._TmpVecs[1];\r\n        const xaxis = BoneIKController._TmpVecs[2];\r\n        const yaxis = BoneIKController._TmpVecs[3];\r\n        const upAxis = BoneIKController._TmpVecs[4];\r\n\r\n        const tmpQuat = BoneIKController._TmpQuat;\r\n\r\n        this._bone1.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        poleTarget.subtractToRef(bonePos, upAxis);\r\n\r\n        if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\r\n            upAxis.y = 1;\r\n        } else {\r\n            upAxis.normalize();\r\n        }\r\n\r\n        target.subtractToRef(bonePos, yaxis);\r\n        yaxis.normalize();\r\n\r\n        Vector3.CrossToRef(yaxis, upAxis, zaxis);\r\n        zaxis.normalize();\r\n\r\n        Vector3.CrossToRef(yaxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\r\n\r\n        const a = this._bone1Length;\r\n        const b = this._bone2Length;\r\n\r\n        let c = Vector3.Distance(bonePos, target);\r\n\r\n        if (this._maxReach > 0) {\r\n            c = Math.min(this._maxReach, c);\r\n        }\r\n\r\n        let acosa = (b * b + c * c - a * a) / (2 * b * c);\r\n        let acosb = (c * c + a * a - b * b) / (2 * c * a);\r\n\r\n        if (acosa > 1) {\r\n            acosa = 1;\r\n        }\r\n\r\n        if (acosb > 1) {\r\n            acosb = 1;\r\n        }\r\n\r\n        if (acosa < -1) {\r\n            acosa = -1;\r\n        }\r\n\r\n        if (acosb < -1) {\r\n            acosb = -1;\r\n        }\r\n\r\n        const angA = Math.acos(acosa);\r\n        const angB = Math.acos(acosb);\r\n\r\n        let angC = -angA - angB;\r\n\r\n        if (this._rightHandedSystem) {\r\n            Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n\r\n            Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n        } else {\r\n            const _tmpVec = BoneIKController._TmpVecs[5];\r\n\r\n            _tmpVec.copyFrom(this._bendAxis);\r\n            _tmpVec.x *= -1;\r\n\r\n            Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\r\n            mat2.multiplyToRef(mat1, mat1);\r\n        }\r\n\r\n        if (this.poleAngle) {\r\n            Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\r\n            mat1.multiplyToRef(mat2, mat1);\r\n        }\r\n\r\n        if (this._bone1) {\r\n            if (this.slerpAmount < 1) {\r\n                if (!this._slerping) {\r\n                    Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\r\n                }\r\n                Quaternion.FromRotationMatrixToRef(mat1, tmpQuat);\r\n                Quaternion.SlerpToRef(this._bone1Quat, tmpQuat, this.slerpAmount, this._bone1Quat);\r\n                angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\r\n\r\n                this._bone1.setRotationQuaternion(this._bone1Quat, Space.WORLD, this.mesh);\r\n                this._slerping = true;\r\n            } else {\r\n                this._bone1.setRotationMatrix(mat1, Space.WORLD, this.mesh);\r\n                this._bone1Mat.copyFrom(mat1);\r\n                this._slerping = false;\r\n            }\r\n            this._updateLinkedTransformRotation(this._bone1);\r\n        }\r\n\r\n        this._bone2.setAxisAngle(this._bendAxis, angC, Space.LOCAL);\r\n        this._updateLinkedTransformRotation(this._bone2);\r\n        this._bone2Ang = angC;\r\n    }\r\n\r\n    private _updateLinkedTransformRotation(bone: Bone): void {\r\n        if (bone._linkedTransformNode) {\r\n            if (!bone._linkedTransformNode.rotationQuaternion) {\r\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\r\n            }\r\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}