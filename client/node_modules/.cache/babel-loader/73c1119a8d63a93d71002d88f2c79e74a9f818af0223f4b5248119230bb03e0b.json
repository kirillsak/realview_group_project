{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { VideoTexture } from \"../Materials/Textures/videoTexture.js\";\nimport { TextureDome } from \"./textureDome.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\n/**\n * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.\n * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\nexport class VideoDome extends TextureDome {\n  /**\n   * Get the video texture associated with this video dome\n   */\n  get videoTexture() {\n    return this._texture;\n  }\n  /**\n   * Get the video mode of this dome\n   */\n  get videoMode() {\n    return this.textureMode;\n  }\n  /**\n   * Set the video mode of this dome.\n   * @see textureMode\n   */\n  set videoMode(value) {\n    this.textureMode = value;\n  }\n  _initTexture(urlsOrElement, scene, options) {\n    const tempOptions = {\n      loop: options.loop,\n      autoPlay: options.autoPlay,\n      autoUpdateTexture: true,\n      poster: options.poster\n    };\n    const texture = new VideoTexture((this.name || \"videoDome\") + \"_texture\", urlsOrElement, scene, options.generateMipMaps, this._useDirectMapping, Texture.TRILINEAR_SAMPLINGMODE, tempOptions);\n    // optional configuration\n    if (options.clickToPlay) {\n      this._pointerObserver = scene.onPointerObservable.add(data => {\n        var _a;\n        ((_a = data.pickInfo) === null || _a === void 0 ? void 0 : _a.pickedMesh) === this.mesh && this._texture.video.play();\n      }, PointerEventTypes.POINTERDOWN);\n    }\n    this._textureObserver = texture.onLoadObservable.add(() => {\n      this.onLoadObservable.notifyObservers();\n    });\n    return texture;\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    this._texture.onLoadObservable.remove(this._textureObserver);\n    this._scene.onPointerObservable.remove(this._pointerObserver);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n}\n/**\n * Define the video source as a Monoscopic panoramic 360 video.\n */\nVideoDome.MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;\n/**\n * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.\n */\nVideoDome.MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;\n/**\n * Define the video source as a Stereoscopic Side by Side panoramic 360 video.\n */\nVideoDome.MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;","map":{"version":3,"mappings":"AACA,SAASA,OAAO,QAAQ,kCAAgC;AAExD,SAASC,YAAY,QAAQ,uCAAqC;AAClE,SAASC,WAAW,QAAQ,kBAAgB;AAE5C,SAASC,iBAAiB,QAAQ,4BAA0B;AAI5D;;;;;;AAMA,OAAM,MAAOC,SAAU,SAAQF,WAAyB;EAcpD;;;EAGA,IAAWG,YAAY;IACnB,OAAO,IAAI,CAACC,QAAQ;EACxB;EACA;;;EAGA,IAAWC,SAAS;IAChB,OAAO,IAAI,CAACC,WAAW;EAC3B;EACA;;;;EAIA,IAAWD,SAAS,CAACE,KAAa;IAC9B,IAAI,CAACD,WAAW,GAAGC,KAAK;EAC5B;EAKUC,YAAY,CAACC,aAAmD,EAAEC,KAAY,EAAEC,OAAY;IAClG,MAAMC,WAAW,GAAyB;MAAEC,IAAI,EAAEF,OAAO,CAACE,IAAI;MAAEC,QAAQ,EAAEH,OAAO,CAACG,QAAQ;MAAEC,iBAAiB,EAAE,IAAI;MAAEC,MAAM,EAAEL,OAAO,CAACK;IAAM,CAAE;IAC7I,MAAMC,OAAO,GAAG,IAAIlB,YAAY,CAC5B,CAAC,IAAI,CAACmB,IAAI,IAAI,WAAW,IAAI,UAAU,EACvCT,aAAa,EACbC,KAAK,EACLC,OAAO,CAACQ,eAAe,EACvB,IAAI,CAACC,iBAAiB,EACtBtB,OAAO,CAACuB,sBAAsB,EAC9BT,WAAW,CACd;IACD;IACA,IAAID,OAAO,CAACW,WAAW,EAAE;MACrB,IAAI,CAACC,gBAAgB,GAAGb,KAAK,CAACc,mBAAmB,CAACC,GAAG,CAAEC,IAAI,IAAI;;QAC3D,WAAI,CAACC,QAAQ,0CAAEC,UAAU,MAAK,IAAI,CAACC,IAAI,IAAI,IAAI,CAACzB,QAAQ,CAAC0B,KAAK,CAACC,IAAI,EAAE;MACzE,CAAC,EAAE9B,iBAAiB,CAAC+B,WAAW,CAAC;;IAErC,IAAI,CAACC,gBAAgB,GAAGhB,OAAO,CAACiB,gBAAgB,CAACT,GAAG,CAAC,MAAK;MACtD,IAAI,CAACS,gBAAgB,CAACC,eAAe,EAAE;IAC3C,CAAC,CAAC;IACF,OAAOlB,OAAO;EAClB;EAEA;;;;;EAKOmB,OAAO,CAACC,YAAsB,EAAEC,0BAA0B,GAAG,KAAK;IACrE,IAAI,CAAClC,QAAQ,CAAC8B,gBAAgB,CAACK,MAAM,CAAC,IAAI,CAACN,gBAAgB,CAAC;IAC5D,IAAI,CAACO,MAAM,CAAChB,mBAAmB,CAACe,MAAM,CAAC,IAAI,CAAChB,gBAAgB,CAAC;IAC7D,KAAK,CAACa,OAAO,CAACC,YAAY,EAAEC,0BAA0B,CAAC;EAC3D;;AApEA;;;AAGuBpC,yBAAe,GAAGF,WAAW,CAACyC,eAAe;AACpE;;;AAGuBvC,wBAAc,GAAGF,WAAW,CAAC0C,cAAc;AAClE;;;AAGuBxC,yBAAe,GAAGF,WAAW,CAAC2C,eAAe","names":["Texture","VideoTexture","TextureDome","PointerEventTypes","VideoDome","videoTexture","_texture","videoMode","textureMode","value","_initTexture","urlsOrElement","scene","options","tempOptions","loop","autoPlay","autoUpdateTexture","poster","texture","name","generateMipMaps","_useDirectMapping","TRILINEAR_SAMPLINGMODE","clickToPlay","_pointerObserver","onPointerObservable","add","data","pickInfo","pickedMesh","mesh","video","play","POINTERDOWN","_textureObserver","onLoadObservable","notifyObservers","dispose","doNotRecurse","disposeMaterialAndTextures","remove","_scene","MODE_MONOSCOPIC","MODE_TOPBOTTOM","MODE_SIDEBYSIDE"],"sourceRoot":"","sources":["../../../../lts/core/generated/Helpers/videoDome.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { VideoTextureSettings } from \"../Materials/Textures/videoTexture\";\r\nimport { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport { TextureDome } from \"./textureDome\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\n\r\n/**\r\n * Display a 360/180 degree video on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple videos with different locations in the scene.\r\n * This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport class VideoDome extends TextureDome<VideoTexture> {\r\n    /**\r\n     * Define the video source as a Monoscopic panoramic 360 video.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Define the video source as a Stereoscopic TopBottom/OverUnder panoramic 360 video.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = TextureDome.MODE_TOPBOTTOM;\r\n    /**\r\n     * Define the video source as a Stereoscopic Side by Side panoramic 360 video.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = TextureDome.MODE_SIDEBYSIDE;\r\n\r\n    /**\r\n     * Get the video texture associated with this video dome\r\n     */\r\n    public get videoTexture(): VideoTexture {\r\n        return this._texture;\r\n    }\r\n    /**\r\n     * Get the video mode of this dome\r\n     */\r\n    public get videoMode(): number {\r\n        return this.textureMode;\r\n    }\r\n    /**\r\n     * Set the video mode of this dome.\r\n     * @see textureMode\r\n     */\r\n    public set videoMode(value: number) {\r\n        this.textureMode = value;\r\n    }\r\n\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _textureObserver: Nullable<Observer<Texture>>;\r\n\r\n    protected _initTexture(urlsOrElement: string | string[] | HTMLVideoElement, scene: Scene, options: any): VideoTexture {\r\n        const tempOptions: VideoTextureSettings = { loop: options.loop, autoPlay: options.autoPlay, autoUpdateTexture: true, poster: options.poster };\r\n        const texture = new VideoTexture(\r\n            (this.name || \"videoDome\") + \"_texture\",\r\n            urlsOrElement,\r\n            scene,\r\n            options.generateMipMaps,\r\n            this._useDirectMapping,\r\n            Texture.TRILINEAR_SAMPLINGMODE,\r\n            tempOptions\r\n        );\r\n        // optional configuration\r\n        if (options.clickToPlay) {\r\n            this._pointerObserver = scene.onPointerObservable.add((data) => {\r\n                data.pickInfo?.pickedMesh === this.mesh && this._texture.video.play();\r\n            }, PointerEventTypes.POINTERDOWN);\r\n        }\r\n        this._textureObserver = texture.onLoadObservable.add(() => {\r\n            this.onLoadObservable.notifyObservers();\r\n        });\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._texture.onLoadObservable.remove(this._textureObserver);\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}