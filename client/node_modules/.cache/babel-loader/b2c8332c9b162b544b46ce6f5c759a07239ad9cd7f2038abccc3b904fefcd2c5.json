{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * Effect wrapping a compute shader and let execute (dispatch) the shader\n */\nexport class ComputeEffect {\n  /**\n   * Creates a compute effect that can be used to execute a compute shader\n   * @param baseName Name of the effect\n   * @param options Set of all options to create the effect\n   * @param engine The engine the effect is created for\n   * @param key Effect Key identifying uniquely compiled shader variants\n   */\n  constructor(baseName, options, engine, key = \"\") {\n    var _a, _b;\n    /**\n     * Name of the effect.\n     */\n    this.name = null;\n    /**\n     * String container all the define statements that should be set on the shader.\n     */\n    this.defines = \"\";\n    /**\n     * Callback that will be called when the shader is compiled.\n     */\n    this.onCompiled = null;\n    /**\n     * Callback that will be called if an error occurs during shader compilation.\n     */\n    this.onError = null;\n    /**\n     * Unique ID of the effect.\n     */\n    this.uniqueId = 0;\n    /**\n     * Observable that will be called when the shader is compiled.\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\n     */\n    this.onCompileObservable = new Observable();\n    /**\n     * Observable that will be called if an error occurs during shader compilation.\n     */\n    this.onErrorObservable = new Observable();\n    /**\n     * Observable that will be called when effect is bound.\n     */\n    this.onBindObservable = new Observable();\n    /**\n     * @internal\n     * Specifies if the effect was previously ready\n     */\n    this._wasPreviouslyReady = false;\n    this._isReady = false;\n    this._compilationError = \"\";\n    /** @internal */\n    this._key = \"\";\n    this._computeSourceCodeOverride = \"\";\n    /** @internal */\n    this._pipelineContext = null;\n    /** @internal */\n    this._computeSourceCode = \"\";\n    this._rawComputeSourceCode = \"\";\n    this._shaderLanguage = ShaderLanguage.WGSL;\n    this.name = baseName;\n    this._key = key;\n    this._engine = engine;\n    this.uniqueId = ComputeEffect._UniqueIdSeed++;\n    this.defines = (_a = options.defines) !== null && _a !== void 0 ? _a : \"\";\n    this.onError = options.onError;\n    this.onCompiled = options.onCompiled;\n    this._entryPoint = (_b = options.entryPoint) !== null && _b !== void 0 ? _b : \"main\";\n    this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\n    this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\n    this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\n    let computeSource;\n    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\n    if (baseName.computeSource) {\n      computeSource = \"source:\" + baseName.computeSource;\n    } else if (baseName.computeElement) {\n      computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\n      if (!computeSource) {\n        computeSource = baseName.computeElement;\n      }\n    } else {\n      computeSource = baseName.compute || baseName;\n    }\n    const processorOptions = {\n      defines: this.defines.split(\"\\n\"),\n      indexParameters: undefined,\n      isFragment: false,\n      shouldUseHighPrecisionShader: false,\n      processor: null,\n      supportsUniformBuffers: this._engine.supportsUniformBuffers,\n      shadersRepository: this._shaderRepository,\n      includesShadersStore: this._includeShaderStore,\n      version: (this._engine.version * 100).toString(),\n      platformName: this._engine.shaderPlatformName,\n      processingContext: null,\n      isNDCHalfZRange: this._engine.isNDCHalfZRange,\n      useReverseDepthBuffer: this._engine.useReverseDepthBuffer\n    };\n    this._loadShader(computeSource, \"Compute\", \"\", computeCode => {\n      ShaderProcessor.Initialize(processorOptions);\n      ShaderProcessor.PreProcess(computeCode, processorOptions, migratedCommputeCode => {\n        this._rawComputeSourceCode = computeCode;\n        if (options.processFinalCode) {\n          migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\n        }\n        const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\n        this._useFinalCode(finalShaders.vertexCode, baseName);\n      }, this._engine);\n    });\n  }\n  _useFinalCode(migratedCommputeCode, baseName) {\n    if (baseName) {\n      const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\n      this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\n    } else {\n      this._computeSourceCode = migratedCommputeCode;\n    }\n    this._prepareEffect();\n  }\n  /**\n   * Unique key for this effect\n   */\n  get key() {\n    return this._key;\n  }\n  /**\n   * If the effect has been compiled and prepared.\n   * @returns if the effect is compiled and prepared.\n   */\n  isReady() {\n    try {\n      return this._isReadyInternal();\n    } catch (_a) {\n      return false;\n    }\n  }\n  _isReadyInternal() {\n    if (this._isReady) {\n      return true;\n    }\n    if (this._pipelineContext) {\n      return this._pipelineContext.isReady;\n    }\n    return false;\n  }\n  /**\n   * The engine the effect was initialized with.\n   * @returns the engine.\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * The pipeline context for this effect\n   * @returns the associated pipeline context\n   */\n  getPipelineContext() {\n    return this._pipelineContext;\n  }\n  /**\n   * The error from the last compilation.\n   * @returns the error string.\n   */\n  getCompilationError() {\n    return this._compilationError;\n  }\n  /**\n   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\n   * @param func The callback to be used.\n   */\n  executeWhenCompiled(func) {\n    if (this.isReady()) {\n      func(this);\n      return;\n    }\n    this.onCompileObservable.add(effect => {\n      func(effect);\n    });\n    if (!this._pipelineContext || this._pipelineContext.isAsync) {\n      setTimeout(() => {\n        this._checkIsReady(null);\n      }, 16);\n    }\n  }\n  _checkIsReady(previousPipelineContext) {\n    try {\n      if (this._isReadyInternal()) {\n        return;\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n      return;\n    }\n    setTimeout(() => {\n      this._checkIsReady(previousPipelineContext);\n    }, 16);\n  }\n  _loadShader(shader, key, optionalKey, callback) {\n    if (typeof HTMLElement !== \"undefined\") {\n      // DOM element ?\n      if (shader instanceof HTMLElement) {\n        const shaderCode = GetDOMTextContent(shader);\n        callback(shaderCode);\n        return;\n      }\n    }\n    // Direct source ?\n    if (shader.substr(0, 7) === \"source:\") {\n      callback(shader.substr(7));\n      return;\n    }\n    // Base64 encoded ?\n    if (shader.substr(0, 7) === \"base64:\") {\n      const shaderBinary = window.atob(shader.substr(7));\n      callback(shaderBinary);\n      return;\n    }\n    // Is in local store ?\n    if (this._shaderStore[shader + key + \"Shader\"]) {\n      callback(this._shaderStore[shader + key + \"Shader\"]);\n      return;\n    }\n    if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\n      callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\n      return;\n    }\n    let shaderUrl;\n    if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\n      shaderUrl = shader;\n    } else {\n      shaderUrl = this._shaderRepository + shader;\n    }\n    this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\n  }\n  /**\n   * Gets the compute shader source code of this effect\n   */\n  get computeSourceCode() {\n    var _a, _b;\n    return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) !== null && _b !== void 0 ? _b : this._computeSourceCode;\n  }\n  /**\n   * Gets the compute shader source code before it has been processed by the preprocessor\n   */\n  get rawComputeSourceCode() {\n    return this._rawComputeSourceCode;\n  }\n  /**\n   * Prepares the effect\n   * @internal\n   */\n  _prepareEffect() {\n    const defines = this.defines;\n    const previousPipelineContext = this._pipelineContext;\n    this._isReady = false;\n    try {\n      const engine = this._engine;\n      this._pipelineContext = engine.createComputePipelineContext();\n      this._pipelineContext._name = this._key;\n      engine._prepareComputePipelineContext(this._pipelineContext, this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode, this._rawComputeSourceCode, this._computeSourceCodeOverride ? null : defines, this._entryPoint);\n      engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\n        this._compilationError = \"\";\n        this._isReady = true;\n        if (this.onCompiled) {\n          this.onCompiled(this);\n        }\n        this.onCompileObservable.notifyObservers(this);\n        this.onCompileObservable.clear();\n        if (previousPipelineContext) {\n          this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\n        }\n      });\n      if (this._pipelineContext.isAsync) {\n        this._checkIsReady(previousPipelineContext);\n      }\n    } catch (e) {\n      this._processCompilationErrors(e, previousPipelineContext);\n    }\n  }\n  _getShaderCodeAndErrorLine(code, error) {\n    const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\n    let errorLine = null;\n    if (error && code) {\n      const res = error.match(regexp);\n      if (res && res.length === 2) {\n        const lineNumber = parseInt(res[1]);\n        const lines = code.split(\"\\n\", -1);\n        if (lines.length >= lineNumber) {\n          errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\n        }\n      }\n    }\n    return [code, errorLine];\n  }\n  _processCompilationErrors(e, previousPipelineContext = null) {\n    var _a;\n    this._compilationError = e.message;\n    // Let's go through fallbacks then\n    Logger.Error(\"Unable to compile compute effect:\");\n    Logger.Error(\"Defines:\\r\\n\" + this.defines);\n    if (ComputeEffect.LogShaderCodeOnCompilationError) {\n      let lineErrorVertex = null,\n        code = null;\n      if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getComputeShaderCode()) {\n        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\n        if (code) {\n          Logger.Error(\"Compute code:\");\n          Logger.Error(code);\n        }\n      }\n      if (lineErrorVertex) {\n        Logger.Error(lineErrorVertex);\n      }\n    }\n    Logger.Error(\"Error: \" + this._compilationError);\n    if (previousPipelineContext) {\n      this._pipelineContext = previousPipelineContext;\n      this._isReady = true;\n      if (this.onError) {\n        this.onError(this, this._compilationError);\n      }\n      this.onErrorObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Release all associated resources.\n   **/\n  dispose() {\n    if (this._pipelineContext) {\n      this._pipelineContext.dispose();\n    }\n    this._engine._releaseComputeEffect(this);\n  }\n  /**\n   * This function will add a new compute shader to the shader store\n   * @param name the name of the shader\n   * @param computeShader compute shader content\n   */\n  static RegisterShader(name, computeShader) {\n    ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\n  }\n}\nComputeEffect._UniqueIdSeed = 0;\n/**\n * Enable logging of the shader code when a compilation error occurs\n */\nComputeEffect.LogShaderCodeOnCompilationError = true;","map":{"version":3,"mappings":"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","names":["Logger","Observable","GetDOMTextContent","IsWindowObjectExist","ShaderProcessor","ShaderStore","ShaderLanguage","ComputeEffect","constructor","baseName","options","engine","key","WGSL","name","_key","_engine","uniqueId","_UniqueIdSeed","defines","onError","onCompiled","_entryPoint","entryPoint","_shaderStore","GetShadersStore","_shaderLanguage","_shaderRepository","GetShadersRepository","_includeShaderStore","GetIncludesShadersStore","computeSource","hostDocument","getHostDocument","computeElement","getElementById","compute","processorOptions","split","indexParameters","undefined","isFragment","shouldUseHighPrecisionShader","processor","supportsUniformBuffers","shadersRepository","includesShadersStore","version","toString","platformName","shaderPlatformName","processingContext","isNDCHalfZRange","useReverseDepthBuffer","_loadShader","computeCode","Initialize","PreProcess","migratedCommputeCode","_rawComputeSourceCode","processFinalCode","finalShaders","Finalize","_useFinalCode","vertexCode","spectorName","_computeSourceCode","_prepareEffect","isReady","_isReadyInternal","_isReady","_pipelineContext","getEngine","getPipelineContext","getCompilationError","_compilationError","executeWhenCompiled","func","onCompileObservable","add","effect","isAsync","setTimeout","_checkIsReady","previousPipelineContext","e","_processCompilationErrors","shader","optionalKey","callback","HTMLElement","shaderCode","substr","shaderBinary","window","atob","shaderUrl","indexOf","_loadFile","toLowerCase","computeSourceCode","_computeSourceCodeOverride","_getComputeShaderCode","rawComputeSourceCode","createComputePipelineContext","_name","_prepareComputePipelineContext","_executeWhenComputeStateIsCompiled","notifyObservers","clear","_deleteComputePipelineContext","_getShaderCodeAndErrorLine","code","error","regexp","errorLine","res","match","length","lineNumber","parseInt","lines","message","Error","LogShaderCodeOnCompilationError","lineErrorVertex","onErrorObservable","dispose","_releaseComputeEffect","RegisterShader","computeShader"],"sourceRoot":"","sources":["../../../../lts/core/generated/Compute/computeEffect.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IComputePipelineContext } from \"./IComputePipelineContext\";\r\nimport { GetDOMTextContent, IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport type { ProcessingOptions } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * Options to be used when creating a compute effect.\r\n */\r\nexport interface IComputeEffectCreationOptions {\r\n    /**\r\n     * Define statements that will be set in the shader.\r\n     */\r\n    defines: any;\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    onCompiled: Nullable<(effect: ComputeEffect) => void>;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    onError: Nullable<(effect: ComputeEffect, errors: string) => void>;\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * Effect wrapping a compute shader and let execute (dispatch) the shader\r\n */\r\nexport class ComputeEffect {\r\n    private static _UniqueIdSeed = 0;\r\n\r\n    /**\r\n     * Enable logging of the shader code when a compilation error occurs\r\n     */\r\n    public static LogShaderCodeOnCompilationError = true;\r\n    /**\r\n     * Name of the effect.\r\n     */\r\n    public name: any = null;\r\n    /**\r\n     * String container all the define statements that should be set on the shader.\r\n     */\r\n    public defines: string = \"\";\r\n    /**\r\n     * Callback that will be called when the shader is compiled.\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n    /**\r\n     * Callback that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n    /**\r\n     * Unique ID of the effect.\r\n     */\r\n    public uniqueId = 0;\r\n    /**\r\n     * Observable that will be called when the shader is compiled.\r\n     * It is recommended to use executeWhenCompile() or to make sure that scene.isReady() is called to get this observable raised.\r\n     */\r\n    public onCompileObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called if an error occurs during shader compilation.\r\n     */\r\n    public onErrorObservable = new Observable<ComputeEffect>();\r\n    /**\r\n     * Observable that will be called when effect is bound.\r\n     */\r\n    public onBindObservable = new Observable<ComputeEffect>();\r\n\r\n    /**\r\n     * @internal\r\n     * Specifies if the effect was previously ready\r\n     */\r\n    public _wasPreviouslyReady = false;\r\n\r\n    private _engine: Engine;\r\n    private _isReady = false;\r\n    private _compilationError = \"\";\r\n    /** @internal */\r\n    public _key: string = \"\";\r\n    private _computeSourceCodeOverride: string = \"\";\r\n    /** @internal */\r\n    public _pipelineContext: Nullable<IComputePipelineContext> = null;\r\n    /** @internal */\r\n    public _computeSourceCode: string = \"\";\r\n    private _rawComputeSourceCode: string = \"\";\r\n    private _entryPoint: string;\r\n    private _shaderLanguage = ShaderLanguage.WGSL;\r\n    private _shaderStore: { [key: string]: string };\r\n    private _shaderRepository: string;\r\n    private _includeShaderStore: { [key: string]: string };\r\n\r\n    /**\r\n     * Creates a compute effect that can be used to execute a compute shader\r\n     * @param baseName Name of the effect\r\n     * @param options Set of all options to create the effect\r\n     * @param engine The engine the effect is created for\r\n     * @param key Effect Key identifying uniquely compiled shader variants\r\n     */\r\n    constructor(baseName: any, options: IComputeEffectCreationOptions, engine: Engine, key = \"\") {\r\n        this.name = baseName;\r\n        this._key = key;\r\n\r\n        this._engine = engine;\r\n        this.uniqueId = ComputeEffect._UniqueIdSeed++;\r\n\r\n        this.defines = options.defines ?? \"\";\r\n        this.onError = options.onError;\r\n        this.onCompiled = options.onCompiled;\r\n        this._entryPoint = options.entryPoint ?? \"main\";\r\n\r\n        this._shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);\r\n        this._shaderRepository = ShaderStore.GetShadersRepository(this._shaderLanguage);\r\n        this._includeShaderStore = ShaderStore.GetIncludesShadersStore(this._shaderLanguage);\r\n\r\n        let computeSource: any;\r\n\r\n        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;\r\n\r\n        if (baseName.computeSource) {\r\n            computeSource = \"source:\" + baseName.computeSource;\r\n        } else if (baseName.computeElement) {\r\n            computeSource = hostDocument ? hostDocument.getElementById(baseName.computeElement) : null;\r\n\r\n            if (!computeSource) {\r\n                computeSource = baseName.computeElement;\r\n            }\r\n        } else {\r\n            computeSource = baseName.compute || baseName;\r\n        }\r\n\r\n        const processorOptions: ProcessingOptions = {\r\n            defines: this.defines.split(\"\\n\"),\r\n            indexParameters: undefined,\r\n            isFragment: false,\r\n            shouldUseHighPrecisionShader: false,\r\n            processor: null,\r\n            supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n            shadersRepository: this._shaderRepository,\r\n            includesShadersStore: this._includeShaderStore,\r\n            version: (this._engine.version * 100).toString(),\r\n            platformName: this._engine.shaderPlatformName,\r\n            processingContext: null,\r\n            isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n        };\r\n\r\n        this._loadShader(computeSource, \"Compute\", \"\", (computeCode) => {\r\n            ShaderProcessor.Initialize(processorOptions);\r\n            ShaderProcessor.PreProcess(\r\n                computeCode,\r\n                processorOptions,\r\n                (migratedCommputeCode) => {\r\n                    this._rawComputeSourceCode = computeCode;\r\n                    if (options.processFinalCode) {\r\n                        migratedCommputeCode = options.processFinalCode(migratedCommputeCode);\r\n                    }\r\n                    const finalShaders = ShaderProcessor.Finalize(migratedCommputeCode, \"\", processorOptions);\r\n                    this._useFinalCode(finalShaders.vertexCode, baseName);\r\n                },\r\n                this._engine\r\n            );\r\n        });\r\n    }\r\n\r\n    private _useFinalCode(migratedCommputeCode: string, baseName: any) {\r\n        if (baseName) {\r\n            const compute = baseName.computeElement || baseName.compute || baseName.spectorName || baseName;\r\n\r\n            this._computeSourceCode = \"//#define SHADER_NAME compute:\" + compute + \"\\n\" + migratedCommputeCode;\r\n        } else {\r\n            this._computeSourceCode = migratedCommputeCode;\r\n        }\r\n        this._prepareEffect();\r\n    }\r\n\r\n    /**\r\n     * Unique key for this effect\r\n     */\r\n    public get key(): string {\r\n        return this._key;\r\n    }\r\n\r\n    /**\r\n     * If the effect has been compiled and prepared.\r\n     * @returns if the effect is compiled and prepared.\r\n     */\r\n    public isReady(): boolean {\r\n        try {\r\n            return this._isReadyInternal();\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private _isReadyInternal(): boolean {\r\n        if (this._isReady) {\r\n            return true;\r\n        }\r\n        if (this._pipelineContext) {\r\n            return this._pipelineContext.isReady;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * The engine the effect was initialized with.\r\n     * @returns the engine.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The pipeline context for this effect\r\n     * @returns the associated pipeline context\r\n     */\r\n    public getPipelineContext(): Nullable<IComputePipelineContext> {\r\n        return this._pipelineContext;\r\n    }\r\n\r\n    /**\r\n     * The error from the last compilation.\r\n     * @returns the error string.\r\n     */\r\n    public getCompilationError(): string {\r\n        return this._compilationError;\r\n    }\r\n\r\n    /**\r\n     * Adds a callback to the onCompiled observable and call the callback immediately if already ready.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenCompiled(func: (effect: ComputeEffect) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        this.onCompileObservable.add((effect) => {\r\n            func(effect);\r\n        });\r\n\r\n        if (!this._pipelineContext || this._pipelineContext.isAsync) {\r\n            setTimeout(() => {\r\n                this._checkIsReady(null);\r\n            }, 16);\r\n        }\r\n    }\r\n\r\n    private _checkIsReady(previousPipelineContext: Nullable<IComputePipelineContext>) {\r\n        try {\r\n            if (this._isReadyInternal()) {\r\n                return;\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n            return;\r\n        }\r\n\r\n        setTimeout(() => {\r\n            this._checkIsReady(previousPipelineContext);\r\n        }, 16);\r\n    }\r\n\r\n    private _loadShader(shader: any, key: string, optionalKey: string, callback: (data: any) => void): void {\r\n        if (typeof HTMLElement !== \"undefined\") {\r\n            // DOM element ?\r\n            if (shader instanceof HTMLElement) {\r\n                const shaderCode = GetDOMTextContent(shader);\r\n                callback(shaderCode);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Direct source ?\r\n        if (shader.substr(0, 7) === \"source:\") {\r\n            callback(shader.substr(7));\r\n            return;\r\n        }\r\n\r\n        // Base64 encoded ?\r\n        if (shader.substr(0, 7) === \"base64:\") {\r\n            const shaderBinary = window.atob(shader.substr(7));\r\n            callback(shaderBinary);\r\n            return;\r\n        }\r\n\r\n        // Is in local store ?\r\n        if (this._shaderStore[shader + key + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + key + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        if (optionalKey && this._shaderStore[shader + optionalKey + \"Shader\"]) {\r\n            callback(this._shaderStore[shader + optionalKey + \"Shader\"]);\r\n            return;\r\n        }\r\n\r\n        let shaderUrl;\r\n\r\n        if (shader[0] === \".\" || shader[0] === \"/\" || shader.indexOf(\"http\") > -1) {\r\n            shaderUrl = shader;\r\n        } else {\r\n            shaderUrl = this._shaderRepository + shader;\r\n        }\r\n\r\n        this._engine._loadFile(shaderUrl + \".\" + key.toLowerCase() + \".fx\", callback);\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code of this effect\r\n     */\r\n    public get computeSourceCode(): string {\r\n        return this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._pipelineContext?._getComputeShaderCode() ?? this._computeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the compute shader source code before it has been processed by the preprocessor\r\n     */\r\n    public get rawComputeSourceCode(): string {\r\n        return this._rawComputeSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Prepares the effect\r\n     * @internal\r\n     */\r\n    public _prepareEffect() {\r\n        const defines = this.defines;\r\n\r\n        const previousPipelineContext = this._pipelineContext;\r\n\r\n        this._isReady = false;\r\n\r\n        try {\r\n            const engine = this._engine;\r\n\r\n            this._pipelineContext = engine.createComputePipelineContext();\r\n            this._pipelineContext._name = this._key;\r\n\r\n            engine._prepareComputePipelineContext(\r\n                this._pipelineContext,\r\n                this._computeSourceCodeOverride ? this._computeSourceCodeOverride : this._computeSourceCode,\r\n                this._rawComputeSourceCode,\r\n                this._computeSourceCodeOverride ? null : defines,\r\n                this._entryPoint\r\n            );\r\n\r\n            engine._executeWhenComputeStateIsCompiled(this._pipelineContext, () => {\r\n                this._compilationError = \"\";\r\n                this._isReady = true;\r\n                if (this.onCompiled) {\r\n                    this.onCompiled(this);\r\n                }\r\n                this.onCompileObservable.notifyObservers(this);\r\n                this.onCompileObservable.clear();\r\n\r\n                if (previousPipelineContext) {\r\n                    this.getEngine()._deleteComputePipelineContext(previousPipelineContext);\r\n                }\r\n            });\r\n\r\n            if (this._pipelineContext.isAsync) {\r\n                this._checkIsReady(previousPipelineContext);\r\n            }\r\n        } catch (e) {\r\n            this._processCompilationErrors(e, previousPipelineContext);\r\n        }\r\n    }\r\n\r\n    private _getShaderCodeAndErrorLine(code: Nullable<string>, error: Nullable<string>): [Nullable<string>, Nullable<string>] {\r\n        const regexp = /COMPUTE SHADER ERROR: 0:(\\d+?):/;\r\n\r\n        let errorLine = null;\r\n\r\n        if (error && code) {\r\n            const res = error.match(regexp);\r\n            if (res && res.length === 2) {\r\n                const lineNumber = parseInt(res[1]);\r\n                const lines = code.split(\"\\n\", -1);\r\n                if (lines.length >= lineNumber) {\r\n                    errorLine = `Offending line [${lineNumber}] in compute code: ${lines[lineNumber - 1]}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return [code, errorLine];\r\n    }\r\n\r\n    private _processCompilationErrors(e: any, previousPipelineContext: Nullable<IComputePipelineContext> = null) {\r\n        this._compilationError = e.message;\r\n\r\n        // Let's go through fallbacks then\r\n        Logger.Error(\"Unable to compile compute effect:\");\r\n        Logger.Error(\"Defines:\\r\\n\" + this.defines);\r\n        if (ComputeEffect.LogShaderCodeOnCompilationError) {\r\n            let lineErrorVertex = null,\r\n                code = null;\r\n            if (this._pipelineContext?._getComputeShaderCode()) {\r\n                [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getComputeShaderCode(), this._compilationError);\r\n                if (code) {\r\n                    Logger.Error(\"Compute code:\");\r\n                    Logger.Error(code);\r\n                }\r\n            }\r\n            if (lineErrorVertex) {\r\n                Logger.Error(lineErrorVertex);\r\n            }\r\n        }\r\n        Logger.Error(\"Error: \" + this._compilationError);\r\n        if (previousPipelineContext) {\r\n            this._pipelineContext = previousPipelineContext;\r\n            this._isReady = true;\r\n            if (this.onError) {\r\n                this.onError(this, this._compilationError);\r\n            }\r\n            this.onErrorObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all associated resources.\r\n     **/\r\n    public dispose() {\r\n        if (this._pipelineContext) {\r\n            this._pipelineContext.dispose();\r\n        }\r\n        this._engine._releaseComputeEffect(this);\r\n    }\r\n\r\n    /**\r\n     * This function will add a new compute shader to the shader store\r\n     * @param name the name of the shader\r\n     * @param computeShader compute shader content\r\n     */\r\n    public static RegisterShader(name: string, computeShader: string) {\r\n        ShaderStore.GetShadersStore(ShaderLanguage.WGSL)[`${name}ComputeShader`] = computeShader;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}