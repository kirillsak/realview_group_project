{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { PhysicsImpostor } from \"../physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { Vector3, Quaternion } from \"../../../Maths/math.vector.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/** @internal */\nexport class OimoJSPlugin {\n  constructor(_useDeltaForWorldStep = true, iterations, oimoInjection = OIMO) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"OimoJSPlugin\";\n    this._fixedTimeStep = 1 / 60;\n    this._tmpImpostorsArray = [];\n    this._tmpPositionVector = Vector3.Zero();\n    this.BJSOIMO = oimoInjection;\n    this.world = new this.BJSOIMO.World({\n      iterations: iterations\n    });\n    this.world.clear();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  setGravity(gravity) {\n    this.world.gravity.set(gravity.x, gravity.y, gravity.z);\n  }\n  setTimeStep(timeStep) {\n    this.world.timeStep = timeStep;\n  }\n  getTimeStep() {\n    return this.world.timeStep;\n  }\n  executeStep(delta, impostors) {\n    impostors.forEach(function (impostor) {\n      impostor.beforeStep();\n    });\n    this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\n    this.world.step();\n    impostors.forEach(impostor => {\n      impostor.afterStep();\n      //update the ordered impostors array\n      this._tmpImpostorsArray[impostor.uniqueId] = impostor;\n    });\n    //check for collisions\n    let contact = this.world.contacts;\n    while (contact !== null) {\n      if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\n        contact = contact.next;\n        continue;\n      }\n      //is this body colliding with any other? get the impostor\n      const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\n      const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\n      if (!mainImpostor || !collidingImpostor) {\n        contact = contact.next;\n        continue;\n      }\n      mainImpostor.onCollide({\n        body: collidingImpostor.physicsBody,\n        point: null,\n        distance: 0,\n        impulse: 0,\n        normal: null\n      });\n      collidingImpostor.onCollide({\n        body: mainImpostor.physicsBody,\n        point: null,\n        distance: 0,\n        impulse: 0,\n        normal: null\n      });\n      contact = contact.next;\n    }\n  }\n  applyImpulse(impostor, force, contactPoint) {\n    const mass = impostor.physicsBody.mass;\n    impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\n  }\n  applyForce(impostor, force, contactPoint) {\n    Logger.Warn(\"Oimo doesn't support applying force. Using impulse instead.\");\n    this.applyImpulse(impostor, force, contactPoint);\n  }\n  generatePhysicsBody(impostor) {\n    //parent-child relationship. Does this impostor has a parent impostor?\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        //TODO is that needed?\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    if (impostor.isBodyInitRequired()) {\n      const bodyConfig = {\n        name: impostor.uniqueId,\n        //Oimo must have mass, also for static objects.\n        config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\n        size: [],\n        type: [],\n        pos: [],\n        posShape: [],\n        rot: [],\n        rotShape: [],\n        move: impostor.getParam(\"mass\") !== 0,\n        density: impostor.getParam(\"mass\"),\n        friction: impostor.getParam(\"friction\"),\n        restitution: impostor.getParam(\"restitution\"),\n        //Supporting older versions of Oimo\n        world: this.world\n      };\n      const impostors = [impostor];\n      const addToArray = parent => {\n        if (!parent.getChildMeshes) {\n          return;\n        }\n        parent.getChildMeshes().forEach(function (m) {\n          if (m.physicsImpostor) {\n            impostors.push(m.physicsImpostor);\n            //m.physicsImpostor._init();\n          }\n        });\n      };\n\n      addToArray(impostor.object);\n      const checkWithEpsilon = value => {\n        return Math.max(value, Epsilon);\n      };\n      const globalQuaternion = new Quaternion();\n      impostors.forEach(i => {\n        if (!i.object.rotationQuaternion) {\n          return;\n        }\n        //get the correct bounding box\n        const oldQuaternion = i.object.rotationQuaternion;\n        globalQuaternion.copyFrom(oldQuaternion);\n        i.object.rotationQuaternion.set(0, 0, 0, 1);\n        i.object.computeWorldMatrix(true);\n        const rot = globalQuaternion.toEulerAngles();\n        const impostorExtents = i.getObjectExtents();\n        // eslint-disable-next-line no-loss-of-precision\n        const radToDeg = 57.295779513082320876;\n        if (i === impostor) {\n          const center = impostor.getObjectCenter();\n          impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\n          this._tmpPositionVector.divideInPlace(impostor.object.scaling);\n          //Can also use Array.prototype.push.apply\n          bodyConfig.pos.push(center.x);\n          bodyConfig.pos.push(center.y);\n          bodyConfig.pos.push(center.z);\n          bodyConfig.posShape.push(0, 0, 0);\n          bodyConfig.rotShape.push(0, 0, 0);\n        } else {\n          const localPosition = i.object.position.clone();\n          bodyConfig.posShape.push(localPosition.x);\n          bodyConfig.posShape.push(localPosition.y);\n          bodyConfig.posShape.push(localPosition.z);\n          // bodyConfig.pos.push(0, 0, 0);\n          bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\n        }\n        i.object.rotationQuaternion.copyFrom(globalQuaternion);\n        // register mesh\n        switch (i.type) {\n          case PhysicsImpostor.ParticleImpostor:\n            Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\n          // eslint-disable-next-line no-fallthrough\n          case PhysicsImpostor.SphereImpostor:\n            {\n              const radiusX = impostorExtents.x;\n              const radiusY = impostorExtents.y;\n              const radiusZ = impostorExtents.z;\n              const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\n              bodyConfig.type.push(\"sphere\");\n              //due to the way oimo works with compounds, add 3 times\n              bodyConfig.size.push(size);\n              bodyConfig.size.push(size);\n              bodyConfig.size.push(size);\n              break;\n            }\n          case PhysicsImpostor.CylinderImpostor:\n            {\n              const sizeX = checkWithEpsilon(impostorExtents.x) / 2;\n              const sizeY = checkWithEpsilon(impostorExtents.y);\n              bodyConfig.type.push(\"cylinder\");\n              bodyConfig.size.push(sizeX);\n              bodyConfig.size.push(sizeY);\n              //due to the way oimo works with compounds, add one more value.\n              bodyConfig.size.push(sizeY);\n              break;\n            }\n          case PhysicsImpostor.PlaneImpostor:\n          case PhysicsImpostor.BoxImpostor:\n          default:\n            {\n              const sizeX = checkWithEpsilon(impostorExtents.x);\n              const sizeY = checkWithEpsilon(impostorExtents.y);\n              const sizeZ = checkWithEpsilon(impostorExtents.z);\n              bodyConfig.type.push(\"box\");\n              //if (i === impostor) {\n              bodyConfig.size.push(sizeX);\n              bodyConfig.size.push(sizeY);\n              bodyConfig.size.push(sizeZ);\n              //} else {\n              //    bodyConfig.size.push(0,0,0);\n              //}\n              break;\n            }\n        }\n        //actually not needed, but hey...\n        i.object.rotationQuaternion = oldQuaternion;\n      });\n      impostor.physicsBody = this.world.add(bodyConfig);\n      // set the quaternion, ignoring the previously defined (euler) rotation\n      impostor.physicsBody.resetQuaternion(globalQuaternion);\n      // update with delta 0, so the body will receive the new rotation.\n      impostor.physicsBody.updatePosition(0);\n    } else {\n      this._tmpPositionVector.copyFromFloats(0, 0, 0);\n    }\n    impostor.setDeltaPosition(this._tmpPositionVector);\n    //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\n    //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\n  }\n\n  removePhysicsBody(impostor) {\n    //impostor.physicsBody.dispose();\n    this.world.removeRigidBody(impostor.physicsBody);\n  }\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    const jointData = impostorJoint.joint.jointData;\n    const options = jointData.nativeParams || {};\n    let type;\n    const nativeJointData = {\n      body1: mainBody,\n      body2: connectedBody,\n      axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\n      axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\n      pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\n      pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\n      min: options.min,\n      max: options.max,\n      collision: options.collision || jointData.collision,\n      spring: options.spring,\n      //supporting older version of Oimo\n      world: this.world\n    };\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.BallAndSocketJoint:\n        type = \"jointBall\";\n        break;\n      case PhysicsJoint.SpringJoint:\n        {\n          Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n          const springData = jointData;\n          nativeJointData.min = springData.length || nativeJointData.min;\n          //Max should also be set, just make sure it is at least min\n          nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\n        }\n      // eslint-disable-next-line no-fallthrough\n      case PhysicsJoint.DistanceJoint:\n        type = \"jointDistance\";\n        nativeJointData.max = jointData.maxDistance;\n        break;\n      case PhysicsJoint.PrismaticJoint:\n        type = \"jointPrisme\";\n        break;\n      case PhysicsJoint.SliderJoint:\n        type = \"jointSlide\";\n        break;\n      case PhysicsJoint.WheelJoint:\n        type = \"jointWheel\";\n        break;\n      case PhysicsJoint.HingeJoint:\n      default:\n        type = \"jointHinge\";\n        break;\n    }\n    nativeJointData.type = type;\n    impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\n  }\n  removeJoint(impostorJoint) {\n    //Bug in Oimo prevents us from disposing a joint in the playground\n    //joint.joint.physicsJoint.dispose();\n    //So we will bruteforce it!\n    try {\n      this.world.removeJoint(impostorJoint.joint.physicsJoint);\n    } catch (e) {\n      Logger.Warn(e);\n    }\n  }\n  isSupported() {\n    return this.BJSOIMO !== undefined;\n  }\n  setTransformationFromPhysicsBody(impostor) {\n    if (!impostor.physicsBody.sleeping) {\n      if (impostor.physicsBody.shapes.next) {\n        let parent = impostor.physicsBody.shapes;\n        while (parent.next) {\n          parent = parent.next;\n        }\n        impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\n      } else {\n        const pos = impostor.physicsBody.getPosition();\n        impostor.object.position.set(pos.x, pos.y, pos.z);\n      }\n      if (impostor.object.rotationQuaternion) {\n        const quat = impostor.physicsBody.getQuaternion();\n        impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\n      }\n    }\n  }\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    const body = impostor.physicsBody;\n    // disable bidirectional for compound meshes\n    if (impostor.physicsBody.shapes.next) {\n      return;\n    }\n    body.position.set(newPosition.x, newPosition.y, newPosition.z);\n    body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n    body.syncShapes();\n    body.awake();\n  }\n  /*private _getLastShape(body: any): any {\n      var lastShape = body.shapes;\n      while (lastShape.next) {\n          lastShape = lastShape.next;\n      }\n      return lastShape;\n  }*/\n  setLinearVelocity(impostor, velocity) {\n    impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  setAngularVelocity(impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  getLinearVelocity(impostor) {\n    const v = impostor.physicsBody.linearVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  getAngularVelocity(impostor) {\n    const v = impostor.physicsBody.angularVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  setBodyMass(impostor, mass) {\n    const staticBody = mass === 0;\n    //this will actually set the body's density and not its mass.\n    //But this is how oimo treats the mass variable.\n    impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\n    impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\n  }\n  getBodyMass(impostor) {\n    return impostor.physicsBody.shapes.density;\n  }\n  getBodyFriction(impostor) {\n    return impostor.physicsBody.shapes.friction;\n  }\n  setBodyFriction(impostor, friction) {\n    impostor.physicsBody.shapes.friction = friction;\n  }\n  getBodyRestitution(impostor) {\n    return impostor.physicsBody.shapes.restitution;\n  }\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.shapes.restitution = restitution;\n  }\n  sleepBody(impostor) {\n    impostor.physicsBody.sleep();\n  }\n  wakeUpBody(impostor) {\n    impostor.physicsBody.awake();\n  }\n  updateDistanceJoint(joint, maxDistance, minDistance) {\n    joint.physicsJoint.limitMotor.upperLimit = maxDistance;\n    if (minDistance !== void 0) {\n      joint.physicsJoint.limitMotor.lowerLimit = minDistance;\n    }\n  }\n  setMotor(joint, speed, force, motorIndex) {\n    if (force !== undefined) {\n      Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\n    } else {\n      force = 1e6;\n    }\n    speed *= -1;\n    //TODO separate rotational and transational motors.\n    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n    if (motor) {\n      motor.setMotor(speed, force);\n    }\n  }\n  setLimit(joint, upperLimit, lowerLimit, motorIndex) {\n    //TODO separate rotational and transational motors.\n    const motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n    if (motor) {\n      motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\n    }\n  }\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.orientation.x;\n      mesh.rotationQuaternion.y = body.orientation.y;\n      mesh.rotationQuaternion.z = body.orientation.z;\n      mesh.rotationQuaternion.w = body.orientation.w;\n    }\n  }\n  getRadius(impostor) {\n    return impostor.physicsBody.shapes.radius;\n  }\n  getBoxSizeToRef(impostor, result) {\n    const shape = impostor.physicsBody.shapes;\n    result.x = shape.halfWidth * 2;\n    result.y = shape.halfHeight * 2;\n    result.z = shape.halfDepth * 2;\n  }\n  dispose() {\n    this.world.clear();\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n    this._raycastResult.reset(from, to);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\n    result.reset(from, to);\n  }\n}","map":{"version":3,"mappings":"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","names":["PhysicsImpostor","PhysicsJoint","Vector3","Quaternion","Logger","PhysicsRaycastResult","Epsilon","OimoJSPlugin","constructor","_useDeltaForWorldStep","iterations","oimoInjection","OIMO","Zero","BJSOIMO","world","World","clear","_raycastResult","getPluginVersion","setGravity","gravity","set","x","y","z","setTimeStep","timeStep","getTimeStep","executeStep","delta","impostors","forEach","impostor","beforeStep","_fixedTimeStep","step","afterStep","_tmpImpostorsArray","uniqueId","contact","contacts","touching","body1","sleeping","body2","next","mainImpostor","name","collidingImpostor","onCollide","body","physicsBody","point","distance","impulse","normal","applyImpulse","force","contactPoint","mass","scale","invScale","applyForce","Warn","generatePhysicsBody","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","bodyConfig","config","getParam","size","type","pos","posShape","rot","rotShape","move","density","friction","restitution","addToArray","getChildMeshes","m","physicsImpostor","push","object","checkWithEpsilon","value","Math","max","globalQuaternion","i","rotationQuaternion","oldQuaternion","copyFrom","computeWorldMatrix","toEulerAngles","impostorExtents","getObjectExtents","radToDeg","center","getObjectCenter","getAbsolutePivotPoint","subtractToRef","_tmpPositionVector","divideInPlace","scaling","localPosition","position","clone","ParticleImpostor","SphereImpostor","radiusX","radiusY","radiusZ","CylinderImpostor","sizeX","sizeY","PlaneImpostor","BoxImpostor","sizeZ","add","resetQuaternion","updatePosition","copyFromFloats","setDeltaPosition","removeRigidBody","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","jointData","joint","options","nativeParams","nativeJointData","axe1","mainAxis","asArray","axe2","connectedAxis","pos1","mainPivot","pos2","connectedPivot","min","collision","spring","BallAndSocketJoint","SpringJoint","springData","length","DistanceJoint","maxDistance","PrismaticJoint","SliderJoint","WheelJoint","HingeJoint","physicsJoint","removeJoint","e","isSupported","undefined","setTransformationFromPhysicsBody","shapes","getPosition","quat","getQuaternion","w","setPhysicsBodyTransformation","newPosition","newRotation","orientation","syncShapes","awake","setLinearVelocity","velocity","linearVelocity","setAngularVelocity","angularVelocity","getLinearVelocity","v","getAngularVelocity","setBodyMass","staticBody","setupMass","getBodyMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","sleepBody","sleep","wakeUpBody","updateDistanceJoint","minDistance","limitMotor","upperLimit","lowerLimit","setMotor","speed","motorIndex","motor","rotationalLimitMotor2","rotationalLimitMotor1","rotationalLimitMotor","setLimit","syncMeshWithImpostor","mesh","getRadius","radius","getBoxSizeToRef","result","shape","halfWidth","halfHeight","halfDepth","dispose","raycast","from","to","reset","raycastToRef"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Physics/v1/Plugins/oimoJSPlugin.ts"],"sourcesContent":["import type { IPhysicsEnabledObject } from \"..//physicsImpostor\";\r\nimport { PhysicsImpostor } from \"../physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\ndeclare let OIMO: any;\r\n\r\n/** @internal */\r\nexport class OimoJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"OimoJSPlugin\";\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSOIMO: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n\r\n    constructor(private _useDeltaForWorldStep: boolean = true, iterations?: number, oimoInjection = OIMO) {\r\n        this.BJSOIMO = oimoInjection;\r\n        this.world = new this.BJSOIMO.World({\r\n            iterations: iterations,\r\n        });\r\n        this.world.clear();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    public setGravity(gravity: Vector3) {\r\n        this.world.gravity.set(gravity.x, gravity.y, gravity.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this.world.timeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this.world.timeStep;\r\n    }\r\n\r\n    private _tmpImpostorsArray: Array<PhysicsImpostor> = [];\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>) {\r\n        impostors.forEach(function (impostor) {\r\n            impostor.beforeStep();\r\n        });\r\n\r\n        this.world.timeStep = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\r\n        this.world.step();\r\n\r\n        impostors.forEach((impostor) => {\r\n            impostor.afterStep();\r\n            //update the ordered impostors array\r\n            this._tmpImpostorsArray[impostor.uniqueId] = impostor;\r\n        });\r\n\r\n        //check for collisions\r\n        let contact = this.world.contacts;\r\n\r\n        while (contact !== null) {\r\n            if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n            //is this body colliding with any other? get the impostor\r\n            const mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\r\n            const collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\r\n\r\n            if (!mainImpostor || !collidingImpostor) {\r\n                contact = contact.next;\r\n                continue;\r\n            }\r\n\r\n            mainImpostor.onCollide({ body: collidingImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });\r\n            collidingImpostor.onCollide({ body: mainImpostor.physicsBody, point: null, distance: 0, impulse: 0, normal: null });\r\n            contact = contact.next;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const mass = impostor.physicsBody.mass;\r\n        impostor.physicsBody.applyImpulse(contactPoint.scale(this.world.invScale), force.scale(this.world.invScale * mass));\r\n    }\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        Logger.Warn(\"Oimo doesn't support applying force. Using impulse instead.\");\r\n        this.applyImpulse(impostor, force, contactPoint);\r\n    }\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        //parent-child relationship. Does this impostor has a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (impostor.isBodyInitRequired()) {\r\n            const bodyConfig: any = {\r\n                name: impostor.uniqueId,\r\n                //Oimo must have mass, also for static objects.\r\n                config: [impostor.getParam(\"mass\") || 0.001, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\r\n                size: [],\r\n                type: [],\r\n                pos: [],\r\n                posShape: [],\r\n                rot: [],\r\n                rotShape: [],\r\n                move: impostor.getParam(\"mass\") !== 0,\r\n                density: impostor.getParam(\"mass\"),\r\n                friction: impostor.getParam(\"friction\"),\r\n                restitution: impostor.getParam(\"restitution\"),\r\n                //Supporting older versions of Oimo\r\n                world: this.world,\r\n            };\r\n\r\n            const impostors = [impostor];\r\n            const addToArray = (parent: IPhysicsEnabledObject) => {\r\n                if (!parent.getChildMeshes) {\r\n                    return;\r\n                }\r\n                parent.getChildMeshes().forEach(function (m) {\r\n                    if (m.physicsImpostor) {\r\n                        impostors.push(m.physicsImpostor);\r\n                        //m.physicsImpostor._init();\r\n                    }\r\n                });\r\n            };\r\n            addToArray(impostor.object);\r\n\r\n            const checkWithEpsilon = (value: number): number => {\r\n                return Math.max(value, Epsilon);\r\n            };\r\n\r\n            const globalQuaternion: Quaternion = new Quaternion();\r\n\r\n            impostors.forEach((i) => {\r\n                if (!i.object.rotationQuaternion) {\r\n                    return;\r\n                }\r\n                //get the correct bounding box\r\n                const oldQuaternion = i.object.rotationQuaternion;\r\n                globalQuaternion.copyFrom(oldQuaternion);\r\n\r\n                i.object.rotationQuaternion.set(0, 0, 0, 1);\r\n                i.object.computeWorldMatrix(true);\r\n\r\n                const rot = globalQuaternion.toEulerAngles();\r\n                const impostorExtents = i.getObjectExtents();\r\n\r\n                // eslint-disable-next-line no-loss-of-precision\r\n                const radToDeg = 57.295779513082320876;\r\n\r\n                if (i === impostor) {\r\n                    const center = impostor.getObjectCenter();\r\n\r\n                    impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);\r\n                    this._tmpPositionVector.divideInPlace(impostor.object.scaling);\r\n\r\n                    //Can also use Array.prototype.push.apply\r\n                    bodyConfig.pos.push(center.x);\r\n                    bodyConfig.pos.push(center.y);\r\n                    bodyConfig.pos.push(center.z);\r\n                    bodyConfig.posShape.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(0, 0, 0);\r\n                } else {\r\n                    const localPosition = i.object.position.clone();\r\n                    bodyConfig.posShape.push(localPosition.x);\r\n                    bodyConfig.posShape.push(localPosition.y);\r\n                    bodyConfig.posShape.push(localPosition.z);\r\n\r\n                    // bodyConfig.pos.push(0, 0, 0);\r\n\r\n                    bodyConfig.rotShape.push(rot.x * radToDeg, rot.y * radToDeg, rot.z * radToDeg);\r\n                }\r\n\r\n                i.object.rotationQuaternion.copyFrom(globalQuaternion);\r\n\r\n                // register mesh\r\n                switch (i.type) {\r\n                    case PhysicsImpostor.ParticleImpostor:\r\n                        Logger.Warn(\"No Particle support in OIMO.js. using SphereImpostor instead\");\r\n                    // eslint-disable-next-line no-fallthrough\r\n                    case PhysicsImpostor.SphereImpostor: {\r\n                        const radiusX = impostorExtents.x;\r\n                        const radiusY = impostorExtents.y;\r\n                        const radiusZ = impostorExtents.z;\r\n\r\n                        const size = Math.max(checkWithEpsilon(radiusX), checkWithEpsilon(radiusY), checkWithEpsilon(radiusZ)) / 2;\r\n\r\n                        bodyConfig.type.push(\"sphere\");\r\n                        //due to the way oimo works with compounds, add 3 times\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        bodyConfig.size.push(size);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.CylinderImpostor: {\r\n                        const sizeX = checkWithEpsilon(impostorExtents.x) / 2;\r\n                        const sizeY = checkWithEpsilon(impostorExtents.y);\r\n                        bodyConfig.type.push(\"cylinder\");\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        //due to the way oimo works with compounds, add one more value.\r\n                        bodyConfig.size.push(sizeY);\r\n                        break;\r\n                    }\r\n                    case PhysicsImpostor.PlaneImpostor:\r\n                    case PhysicsImpostor.BoxImpostor:\r\n                    default: {\r\n                        const sizeX = checkWithEpsilon(impostorExtents.x);\r\n                        const sizeY = checkWithEpsilon(impostorExtents.y);\r\n                        const sizeZ = checkWithEpsilon(impostorExtents.z);\r\n\r\n                        bodyConfig.type.push(\"box\");\r\n                        //if (i === impostor) {\r\n                        bodyConfig.size.push(sizeX);\r\n                        bodyConfig.size.push(sizeY);\r\n                        bodyConfig.size.push(sizeZ);\r\n                        //} else {\r\n                        //    bodyConfig.size.push(0,0,0);\r\n                        //}\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                //actually not needed, but hey...\r\n                i.object.rotationQuaternion = oldQuaternion;\r\n            });\r\n            impostor.physicsBody = this.world.add(bodyConfig);\r\n            // set the quaternion, ignoring the previously defined (euler) rotation\r\n            impostor.physicsBody.resetQuaternion(globalQuaternion);\r\n            // update with delta 0, so the body will receive the new rotation.\r\n            impostor.physicsBody.updatePosition(0);\r\n        } else {\r\n            this._tmpPositionVector.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpPositionVector);\r\n\r\n        //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\r\n        //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\r\n    }\r\n\r\n    private _tmpPositionVector: Vector3 = Vector3.Zero();\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        //impostor.physicsBody.dispose();\r\n        this.world.removeRigidBody(impostor.physicsBody);\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        const jointData = impostorJoint.joint.jointData;\r\n        const options = jointData.nativeParams || {};\r\n        let type;\r\n        const nativeJointData: any = {\r\n            body1: mainBody,\r\n            body2: connectedBody,\r\n\r\n            axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\r\n            axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\r\n            pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\r\n            pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\r\n\r\n            min: options.min,\r\n            max: options.max,\r\n            collision: options.collision || jointData.collision,\r\n            spring: options.spring,\r\n\r\n            //supporting older version of Oimo\r\n            world: this.world,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n                type = \"jointBall\";\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                Logger.Warn(\"OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\r\n                const springData = <SpringJointData>jointData;\r\n                nativeJointData.min = springData.length || nativeJointData.min;\r\n                //Max should also be set, just make sure it is at least min\r\n                nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\r\n            }\r\n            // eslint-disable-next-line no-fallthrough\r\n            case PhysicsJoint.DistanceJoint:\r\n                type = \"jointDistance\";\r\n                nativeJointData.max = (<DistanceJointData>jointData).maxDistance;\r\n                break;\r\n            case PhysicsJoint.PrismaticJoint:\r\n                type = \"jointPrisme\";\r\n                break;\r\n            case PhysicsJoint.SliderJoint:\r\n                type = \"jointSlide\";\r\n                break;\r\n            case PhysicsJoint.WheelJoint:\r\n                type = \"jointWheel\";\r\n                break;\r\n            case PhysicsJoint.HingeJoint:\r\n            default:\r\n                type = \"jointHinge\";\r\n                break;\r\n        }\r\n        nativeJointData.type = type;\r\n        impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        //Bug in Oimo prevents us from disposing a joint in the playground\r\n        //joint.joint.physicsJoint.dispose();\r\n        //So we will bruteforce it!\r\n        try {\r\n            this.world.removeJoint(impostorJoint.joint.physicsJoint);\r\n        } catch (e) {\r\n            Logger.Warn(e);\r\n        }\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSOIMO !== undefined;\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        if (!impostor.physicsBody.sleeping) {\r\n            if (impostor.physicsBody.shapes.next) {\r\n                let parent = impostor.physicsBody.shapes;\r\n                while (parent.next) {\r\n                    parent = parent.next;\r\n                }\r\n                impostor.object.position.set(parent.position.x, parent.position.y, parent.position.z);\r\n            } else {\r\n                const pos = impostor.physicsBody.getPosition();\r\n                impostor.object.position.set(pos.x, pos.y, pos.z);\r\n            }\r\n\r\n            if (impostor.object.rotationQuaternion) {\r\n                const quat = impostor.physicsBody.getQuaternion();\r\n                impostor.object.rotationQuaternion.set(quat.x, quat.y, quat.z, quat.w);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        const body = impostor.physicsBody;\r\n        // disable bidirectional for compound meshes\r\n        if (impostor.physicsBody.shapes.next) {\r\n            return;\r\n        }\r\n        body.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        body.orientation.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n        body.syncShapes();\r\n        body.awake();\r\n    }\r\n\r\n    /*private _getLastShape(body: any): any {\r\n        var lastShape = body.shapes;\r\n        while (lastShape.next) {\r\n            lastShape = lastShape.next;\r\n        }\r\n        return lastShape;\r\n    }*/\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.linearVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.linearVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        const staticBody: boolean = mass === 0;\r\n        //this will actually set the body's density and not its mass.\r\n        //But this is how oimo treats the mass variable.\r\n        impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\r\n        impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.density;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.shapes.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.shapes.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.awake();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number, minDistance?: number) {\r\n        joint.physicsJoint.limitMotor.upperLimit = maxDistance;\r\n        if (minDistance !== void 0) {\r\n            joint.physicsJoint.limitMotor.lowerLimit = minDistance;\r\n        }\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed: number, force?: number, motorIndex?: number) {\r\n        if (force !== undefined) {\r\n            Logger.Warn(\"OimoJS plugin currently has unexpected behavior when using setMotor with force parameter\");\r\n        } else {\r\n            force = 1e6;\r\n        }\r\n        speed *= -1;\r\n\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setMotor(speed, force);\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, upperLimit: number, lowerLimit?: number, motorIndex?: number) {\r\n        //TODO separate rotational and transational motors.\r\n        const motor = motorIndex\r\n            ? joint.physicsJoint.rotationalLimitMotor2\r\n            : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\r\n        if (motor) {\r\n            motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\r\n        }\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.orientation.x;\r\n            mesh.rotationQuaternion.y = body.orientation.y;\r\n            mesh.rotationQuaternion.z = body.orientation.z;\r\n            mesh.rotationQuaternion.w = body.orientation.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.shapes.radius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes;\r\n        result.x = shape.halfWidth * 2;\r\n        result.y = shape.halfHeight * 2;\r\n        result.z = shape.halfDepth * 2;\r\n    }\r\n\r\n    public dispose() {\r\n        this.world.clear();\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        this._raycastResult.reset(from, to);\r\n\r\n        return this._raycastResult;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        Logger.Warn(\"raycast is not currently supported by the Oimo physics plugin\");\r\n\r\n        result.reset(from, to);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}