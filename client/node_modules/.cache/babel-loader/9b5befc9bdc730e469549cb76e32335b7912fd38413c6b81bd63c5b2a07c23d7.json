{"ast":null,"code":"import { Observable } from \"../../Misc/observable.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport \"../../Engines/Extensions/engine.videoTexture.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\nfunction removeSource(video) {\n  // Remove any <source> elements, etc.\n  while (video.firstChild) {\n    video.removeChild(video.firstChild);\n  }\n  // detach srcObject\n  video.srcObject = null;\n  // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\n  video.src = \"\";\n  // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\n  video.removeAttribute(\"src\");\n}\n/**\n * If you want to display a video in your scene, this is the special texture for that.\n * This special texture works similar to other textures, with the exception of a few parameters.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\n */\nexport class VideoTexture extends Texture {\n  /**\n   * Creates a video texture.\n   * If you want to display a video in your scene, this is the special texture for that.\n   * This special texture works similar to other textures, with the exception of a few parameters.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\n   * @param name optional name, will detect from video source, if not defined\n   * @param src can be used to provide an url, array of urls or an already setup HTML video element.\n   * @param scene is obviously the current scene.\n   * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\n   * @param invertY is false by default but can be used to invert video on Y axis\n   * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\n   * @param settings allows finer control over video usage\n   * @param onError defines a callback triggered when an error occurred during the loading session\n   * @param format defines the texture format to use (Engine.TEXTUREFORMAT_RGBA by default)\n   */\n  constructor(name, src, scene, generateMipMaps = false, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, settings = {}, onError, format = 5) {\n    var _a, _b;\n    super(null, scene, !generateMipMaps, invertY);\n    this._onUserActionRequestedObservable = null;\n    this._stillImageCaptured = false;\n    this._displayingPosterTexture = false;\n    this._frameId = -1;\n    this._currentSrc = null;\n    this._errorFound = false;\n    this._createInternalTexture = () => {\n      var _a;\n      if (this._texture != null) {\n        if (this._displayingPosterTexture) {\n          this._texture.dispose();\n          this._displayingPosterTexture = false;\n        } else {\n          return;\n        }\n      }\n      if (!this._getEngine().needPOTTextures || Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight)) {\n        this.wrapU = Texture.WRAP_ADDRESSMODE;\n        this.wrapV = Texture.WRAP_ADDRESSMODE;\n      } else {\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._generateMipMaps = false;\n      }\n      this._texture = this._getEngine().createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);\n      this._texture.format = (_a = this._format) !== null && _a !== void 0 ? _a : 5;\n      if (!this.video.autoplay && !this._settings.poster && !this._settings.independentVideoSource) {\n        const oldHandler = this.video.onplaying;\n        const oldMuted = this.video.muted;\n        this.video.muted = true;\n        this.video.onplaying = () => {\n          this.video.muted = oldMuted;\n          this.video.onplaying = oldHandler;\n          this._updateInternalTexture();\n          if (!this._errorFound) {\n            this.video.pause();\n          }\n          if (this.onLoadObservable.hasObservers()) {\n            this.onLoadObservable.notifyObservers(this);\n          }\n        };\n        this._handlePlay();\n      } else {\n        this._updateInternalTexture();\n        if (this.onLoadObservable.hasObservers()) {\n          this.onLoadObservable.notifyObservers(this);\n        }\n      }\n    };\n    this._reset = () => {\n      if (this._texture == null) {\n        return;\n      }\n      if (!this._displayingPosterTexture) {\n        this._texture.dispose();\n        this._texture = null;\n      }\n    };\n    this._updateInternalTexture = () => {\n      if (this._texture == null) {\n        return;\n      }\n      if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\n        return;\n      }\n      if (this._displayingPosterTexture) {\n        return;\n      }\n      const frameId = this.getScene().getFrameId();\n      if (this._frameId === frameId) {\n        return;\n      }\n      this._frameId = frameId;\n      this._getEngine().updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : this.video, this._invertY);\n    };\n    this._settings = {\n      autoPlay: true,\n      loop: true,\n      autoUpdateTexture: true,\n      ...settings\n    };\n    this._onError = onError;\n    this._generateMipMaps = generateMipMaps;\n    this._initialSamplingMode = samplingMode;\n    this.autoUpdateTexture = this._settings.autoUpdateTexture;\n    this._currentSrc = src;\n    this.name = name || this._getName(src);\n    this.video = this._getVideo(src);\n    this._externalTexture = (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.createExternalTexture(this.video)) !== null && _b !== void 0 ? _b : null;\n    if (!this._settings.independentVideoSource) {\n      if (this._settings.poster) {\n        this.video.poster = this._settings.poster;\n      }\n      if (this._settings.autoPlay !== undefined) {\n        this.video.autoplay = this._settings.autoPlay;\n      }\n      if (this._settings.loop !== undefined) {\n        this.video.loop = this._settings.loop;\n      }\n      if (this._settings.muted !== undefined) {\n        this.video.muted = this._settings.muted;\n      }\n      this.video.setAttribute(\"playsinline\", \"\");\n      this.video.addEventListener(\"paused\", this._updateInternalTexture);\n      this.video.addEventListener(\"seeked\", this._updateInternalTexture);\n      this.video.addEventListener(\"emptied\", this._reset);\n      if (this._settings.autoPlay) {\n        this._handlePlay();\n      }\n    }\n    this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? \"play\" : \"canplay\";\n    this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    this._format = format;\n    const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;\n    if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {\n      this._texture = this._getEngine().createTexture(this._settings.poster, false, !this.invertY, scene);\n      this._displayingPosterTexture = true;\n    } else if (videoHasEnoughData) {\n      this._createInternalTexture();\n    }\n  }\n  /**\n   * Event triggered when a dom action is required by the user to play the video.\n   * This happens due to recent changes in browser policies preventing video to auto start.\n   */\n  get onUserActionRequestedObservable() {\n    if (!this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable = new Observable();\n    }\n    return this._onUserActionRequestedObservable;\n  }\n  _processError(reason) {\n    this._errorFound = true;\n    if (this._onError) {\n      this._onError(reason === null || reason === void 0 ? void 0 : reason.message);\n    } else {\n      Logger.Error(reason === null || reason === void 0 ? void 0 : reason.message);\n    }\n  }\n  _handlePlay() {\n    this._errorFound = false;\n    this.video.play().catch(reason => {\n      if ((reason === null || reason === void 0 ? void 0 : reason.name) === \"NotAllowedError\") {\n        if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\n          this._onUserActionRequestedObservable.notifyObservers(this);\n          return;\n        } else if (!this.video.muted) {\n          Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\n          this.video.muted = true;\n          this._errorFound = false;\n          this.video.play().catch(otherReason => {\n            this._processError(otherReason);\n          });\n          return;\n        }\n      }\n      this._processError(reason);\n    });\n  }\n  /**\n   * Get the current class name of the video texture useful for serialization or dynamic coding.\n   * @returns \"VideoTexture\"\n   */\n  getClassName() {\n    return \"VideoTexture\";\n  }\n  _getName(src) {\n    if (src instanceof HTMLVideoElement) {\n      return src.currentSrc;\n    }\n    if (typeof src === \"object\") {\n      return src.toString();\n    }\n    return src;\n  }\n  _getVideo(src) {\n    if (src.isNative) {\n      return src;\n    }\n    if (src instanceof HTMLVideoElement) {\n      Tools.SetCorsBehavior(src.currentSrc, src);\n      return src;\n    }\n    const video = document.createElement(\"video\");\n    if (typeof src === \"string\") {\n      Tools.SetCorsBehavior(src, video);\n      video.src = src;\n    } else {\n      Tools.SetCorsBehavior(src[0], video);\n      src.forEach(url => {\n        const source = document.createElement(\"source\");\n        source.src = url;\n        video.appendChild(source);\n      });\n    }\n    this.onDisposeObservable.addOnce(() => {\n      removeSource(video);\n    });\n    return video;\n  }\n  /**\n   * @internal Internal method to initiate `update`.\n   */\n  _rebuild() {\n    this.update();\n  }\n  /**\n   * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\n   */\n  update() {\n    if (!this.autoUpdateTexture) {\n      // Expecting user to call `updateTexture` manually\n      return;\n    }\n    this.updateTexture(true);\n  }\n  /**\n   * Update Texture in `manual` mode. Does not do anything if not visible or paused.\n   * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\n   */\n  updateTexture(isVisible) {\n    if (!isVisible) {\n      return;\n    }\n    if (this.video.paused && this._stillImageCaptured) {\n      return;\n    }\n    this._stillImageCaptured = true;\n    this._updateInternalTexture();\n  }\n  /**\n   * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\n   * @param url New url.\n   */\n  updateURL(url) {\n    this.video.src = url;\n    this._currentSrc = url;\n  }\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    return new VideoTexture(this.name, this._currentSrc, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    var _a;\n    super.dispose();\n    this._currentSrc = null;\n    if (this._onUserActionRequestedObservable) {\n      this._onUserActionRequestedObservable.clear();\n      this._onUserActionRequestedObservable = null;\n    }\n    this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\n    if (!this._settings.independentVideoSource) {\n      this.video.removeEventListener(\"paused\", this._updateInternalTexture);\n      this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\n      this.video.removeEventListener(\"emptied\", this._reset);\n      this.video.pause();\n    }\n    (_a = this._externalTexture) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n  /**\n   * Creates a video texture straight from a stream.\n   * @param scene Define the scene the texture should be created in\n   * @param stream Define the stream the texture should be created from\n   * @param constraints video constraints\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   * @returns The created video texture as a promise\n   */\n  static CreateFromStreamAsync(scene, stream, constraints, invertY = true) {\n    const video = scene.getEngine().createVideoElement(constraints);\n    if (scene.getEngine()._badOS) {\n      // Yes... I know and I hope to remove it soon...\n      document.body.appendChild(video);\n      video.style.transform = \"scale(0.0001, 0.0001)\";\n      video.style.opacity = \"0\";\n      video.style.position = \"fixed\";\n      video.style.bottom = \"0px\";\n      video.style.right = \"0px\";\n    }\n    video.setAttribute(\"autoplay\", \"\");\n    video.setAttribute(\"muted\", \"true\");\n    video.setAttribute(\"playsinline\", \"\");\n    video.muted = true;\n    if (video.isNative) {\n      // No additional configuration needed for native\n    } else if (video.mozSrcObject !== undefined) {\n      // hack for Firefox < 19\n      video.mozSrcObject = stream;\n    } else {\n      if (typeof video.srcObject == \"object\") {\n        video.srcObject = stream;\n      } else {\n        // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\n        video.src = window.URL && window.URL.createObjectURL(stream);\n      }\n    }\n    return new Promise(resolve => {\n      const onPlaying = () => {\n        const videoTexture = new VideoTexture(\"video\", video, scene, true, invertY, undefined, undefined, undefined, 4);\n        if (scene.getEngine()._badOS) {\n          videoTexture.onDisposeObservable.addOnce(() => {\n            video.remove();\n          });\n        }\n        videoTexture.onDisposeObservable.addOnce(() => {\n          removeSource(video);\n        });\n        resolve(videoTexture);\n        video.removeEventListener(\"playing\", onPlaying);\n      };\n      video.addEventListener(\"playing\", onPlaying);\n      video.play();\n    });\n  }\n  /**\n   * Creates a video texture straight from your WebCam video feed.\n   * @param scene Define the scene the texture should be created in\n   * @param constraints Define the constraints to use to create the web cam feed from WebRTC\n   * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   * @returns The created video texture as a promise\n   */\n  static async CreateFromWebCamAsync(scene, constraints, audioConstaints = false, invertY = true) {\n    if (navigator.mediaDevices) {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        video: constraints,\n        audio: audioConstaints\n      });\n      const videoTexture = await this.CreateFromStreamAsync(scene, stream, constraints, invertY);\n      videoTexture.onDisposeObservable.addOnce(() => {\n        stream.getTracks().forEach(track => {\n          track.stop();\n        });\n      });\n      return videoTexture;\n    }\n    return Promise.reject(\"No support for userMedia on this device\");\n  }\n  /**\n   * Creates a video texture straight from your WebCam video feed.\n   * @param scene Defines the scene the texture should be created in\n   * @param onReady Defines a callback to triggered once the texture will be ready\n   * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\n   * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\n   * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\n   */\n  static CreateFromWebCam(scene, onReady, constraints, audioConstaints = false, invertY = true) {\n    this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY).then(function (videoTexture) {\n      if (onReady) {\n        onReady(videoTexture);\n      }\n    }).catch(function (err) {\n      Logger.Error(err.name);\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","Tools","Logger","Texture","removeSource","video","firstChild","removeChild","srcObject","src","removeAttribute","VideoTexture","constructor","name","scene","generateMipMaps","invertY","samplingMode","TRILINEAR_SAMPLINGMODE","settings","onError","format","_texture","_displayingPosterTexture","dispose","_getEngine","needPOTTextures","IsExponentOfTwo","videoWidth","videoHeight","wrapU","WRAP_ADDRESSMODE","wrapV","CLAMP_ADDRESSMODE","_generateMipMaps","createDynamicTexture","_format","autoplay","_settings","poster","independentVideoSource","oldHandler","onplaying","oldMuted","muted","_updateInternalTexture","_errorFound","pause","onLoadObservable","hasObservers","notifyObservers","_handlePlay","readyState","HAVE_CURRENT_DATA","frameId","getScene","getFrameId","_frameId","updateVideoTexture","_externalTexture","_invertY","autoPlay","loop","autoUpdateTexture","_onError","_initialSamplingMode","_currentSrc","_getName","_getVideo","_engine","createExternalTexture","undefined","setAttribute","addEventListener","_reset","_createInternalTextureOnEvent","_createInternalTexture","videoHasEnoughData","createTexture","onUserActionRequestedObservable","_onUserActionRequestedObservable","_processError","reason","message","Error","play","catch","Warn","otherReason","getClassName","HTMLVideoElement","currentSrc","toString","isNative","SetCorsBehavior","document","createElement","forEach","url","source","appendChild","onDisposeObservable","addOnce","_rebuild","update","updateTexture","isVisible","paused","_stillImageCaptured","updateURL","clone","clear","removeEventListener","CreateFromStreamAsync","stream","constraints","getEngine","createVideoElement","_badOS","body","style","transform","opacity","position","bottom","right","mozSrcObject","window","URL","createObjectURL","Promise","resolve","onPlaying","videoTexture","remove","CreateFromWebCamAsync","audioConstaints","navigator","mediaDevices","getUserMedia","audio","getTracks","track","stop","reject","CreateFromWebCam","onReady","then","err"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/videoTexture.ts"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { ExternalTexture } from \"./externalTexture\";\r\n\r\nimport \"../../Engines/Extensions/engine.videoTexture\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\nfunction removeSource(video: HTMLVideoElement): void {\r\n    // Remove any <source> elements, etc.\r\n    while (video.firstChild) {\r\n        video.removeChild(video.firstChild);\r\n    }\r\n\r\n    // detach srcObject\r\n    video.srcObject = null;\r\n\r\n    // Set a blank src (https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements)\r\n    video.src = \"\";\r\n\r\n    // Prevent non-important errors maybe (https://twitter.com/beraliv/status/1205214277956775936)\r\n    video.removeAttribute(\"src\");\r\n}\r\n\r\n/**\r\n * Settings for finer control over video usage\r\n */\r\nexport interface VideoTextureSettings {\r\n    /**\r\n     * Applies `autoplay` to video, if specified\r\n     */\r\n    autoPlay?: boolean;\r\n\r\n    /**\r\n     * Applies `muted` to video, if specified\r\n     */\r\n    muted?: boolean;\r\n\r\n    /**\r\n     * Applies `loop` to video, if specified\r\n     */\r\n    loop?: boolean;\r\n\r\n    /**\r\n     * Automatically updates internal texture from video at every frame in the render loop\r\n     */\r\n    autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * Image src displayed during the video loading or until the user interacts with the video.\r\n     */\r\n    poster?: string;\r\n\r\n    /**\r\n     * Defines the associated texture format.\r\n     */\r\n    format?: number;\r\n\r\n    /**\r\n     * Notify babylon to not modify any video settings and not control the video's playback.\r\n     * Set this to true if you are controlling the way the video is being played, stopped and paused.\r\n     */\r\n    independentVideoSource?: boolean;\r\n}\r\n\r\n/**\r\n * If you want to display a video in your scene, this is the special texture for that.\r\n * This special texture works similar to other textures, with the exception of a few parameters.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\r\n */\r\nexport class VideoTexture extends Texture {\r\n    /**\r\n     * Tells whether textures will be updated automatically or user is required to call `updateTexture` manually\r\n     */\r\n    public readonly autoUpdateTexture: boolean;\r\n\r\n    /**\r\n     * The video instance used by the texture internally\r\n     */\r\n    public readonly video: HTMLVideoElement;\r\n\r\n    private _externalTexture: Nullable<ExternalTexture>;\r\n    private _onUserActionRequestedObservable: Nullable<Observable<Texture>> = null;\r\n\r\n    /**\r\n     * Event triggered when a dom action is required by the user to play the video.\r\n     * This happens due to recent changes in browser policies preventing video to auto start.\r\n     */\r\n    public get onUserActionRequestedObservable(): Observable<Texture> {\r\n        if (!this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable = new Observable<Texture>();\r\n        }\r\n        return this._onUserActionRequestedObservable;\r\n    }\r\n\r\n    private _generateMipMaps: boolean;\r\n    private _stillImageCaptured = false;\r\n    private _displayingPosterTexture = false;\r\n    private _settings: VideoTextureSettings;\r\n    private _createInternalTextureOnEvent: string;\r\n    private _frameId = -1;\r\n    private _currentSrc: Nullable<string | string[] | HTMLVideoElement> = null;\r\n    private _onError?: Nullable<(message?: string, exception?: any) => void>;\r\n    private _errorFound = false;\r\n\r\n    private _processError(reason: any) {\r\n        this._errorFound = true;\r\n        if (this._onError) {\r\n            this._onError(reason?.message);\r\n        } else {\r\n            Logger.Error(reason?.message);\r\n        }\r\n    }\r\n\r\n    private _handlePlay() {\r\n        this._errorFound = false;\r\n        this.video.play().catch((reason) => {\r\n            if (reason?.name === \"NotAllowedError\") {\r\n                if (this._onUserActionRequestedObservable && this._onUserActionRequestedObservable.hasObservers()) {\r\n                    this._onUserActionRequestedObservable.notifyObservers(this);\r\n                    return;\r\n                } else if (!this.video.muted) {\r\n                    Logger.Warn(\"Unable to autoplay a video with sound. Trying again with muted turned true\");\r\n                    this.video.muted = true;\r\n                    this._errorFound = false;\r\n                    this.video.play().catch((otherReason) => {\r\n                        this._processError(otherReason);\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._processError(reason);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture.\r\n     * If you want to display a video in your scene, this is the special texture for that.\r\n     * This special texture works similar to other textures, with the exception of a few parameters.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/videoTexture\r\n     * @param name optional name, will detect from video source, if not defined\r\n     * @param src can be used to provide an url, array of urls or an already setup HTML video element.\r\n     * @param scene is obviously the current scene.\r\n     * @param generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\r\n     * @param invertY is false by default but can be used to invert video on Y axis\r\n     * @param samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\r\n     * @param settings allows finer control over video usage\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param format defines the texture format to use (Engine.TEXTUREFORMAT_RGBA by default)\r\n     */\r\n    constructor(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._settings = {\r\n            autoPlay: true,\r\n            loop: true,\r\n            autoUpdateTexture: true,\r\n            ...settings,\r\n        };\r\n\r\n        this._onError = onError;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._initialSamplingMode = samplingMode;\r\n        this.autoUpdateTexture = this._settings.autoUpdateTexture;\r\n\r\n        this._currentSrc = src;\r\n        this.name = name || this._getName(src);\r\n        this.video = this._getVideo(src);\r\n        this._externalTexture = this._engine?.createExternalTexture(this.video) ?? null;\r\n        if (!this._settings.independentVideoSource) {\r\n            if (this._settings.poster) {\r\n                this.video.poster = this._settings.poster;\r\n            }\r\n            if (this._settings.autoPlay !== undefined) {\r\n                this.video.autoplay = this._settings.autoPlay;\r\n            }\r\n            if (this._settings.loop !== undefined) {\r\n                this.video.loop = this._settings.loop;\r\n            }\r\n            if (this._settings.muted !== undefined) {\r\n                this.video.muted = this._settings.muted;\r\n            }\r\n\r\n            this.video.setAttribute(\"playsinline\", \"\");\r\n            this.video.addEventListener(\"paused\", this._updateInternalTexture);\r\n            this.video.addEventListener(\"seeked\", this._updateInternalTexture);\r\n            this.video.addEventListener(\"emptied\", this._reset);\r\n\r\n            if (this._settings.autoPlay) {\r\n                this._handlePlay();\r\n            }\r\n        }\r\n\r\n        this._createInternalTextureOnEvent = this._settings.poster && !this._settings.autoPlay ? \"play\" : \"canplay\";\r\n        this.video.addEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        this._format = format;\r\n\r\n        const videoHasEnoughData = this.video.readyState >= this.video.HAVE_CURRENT_DATA;\r\n        if (this._settings.poster && (!this._settings.autoPlay || !videoHasEnoughData)) {\r\n            this._texture = this._getEngine()!.createTexture(this._settings.poster!, false, !this.invertY, scene);\r\n            this._displayingPosterTexture = true;\r\n        } else if (videoHasEnoughData) {\r\n            this._createInternalTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the video texture useful for serialization or dynamic coding.\r\n     * @returns \"VideoTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VideoTexture\";\r\n    }\r\n\r\n    private _getName(src: string | string[] | HTMLVideoElement): string {\r\n        if (src instanceof HTMLVideoElement) {\r\n            return src.currentSrc;\r\n        }\r\n\r\n        if (typeof src === \"object\") {\r\n            return src.toString();\r\n        }\r\n\r\n        return src;\r\n    }\r\n\r\n    private _getVideo(src: string | string[] | HTMLVideoElement): HTMLVideoElement {\r\n        if ((<any>src).isNative) {\r\n            return <HTMLVideoElement>src;\r\n        }\r\n        if (src instanceof HTMLVideoElement) {\r\n            Tools.SetCorsBehavior(src.currentSrc, src);\r\n            return src;\r\n        }\r\n        const video: HTMLVideoElement = document.createElement(\"video\");\r\n        if (typeof src === \"string\") {\r\n            Tools.SetCorsBehavior(src, video);\r\n            video.src = src;\r\n        } else {\r\n            Tools.SetCorsBehavior(src[0], video);\r\n            src.forEach((url) => {\r\n                const source = document.createElement(\"source\");\r\n                source.src = url;\r\n                video.appendChild(source);\r\n            });\r\n        }\r\n\r\n        this.onDisposeObservable.addOnce(() => {\r\n            removeSource(video);\r\n        });\r\n\r\n        return video;\r\n    }\r\n\r\n    private _createInternalTexture = (): void => {\r\n        if (this._texture != null) {\r\n            if (this._displayingPosterTexture) {\r\n                this._texture.dispose();\r\n                this._displayingPosterTexture = false;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!this._getEngine()!.needPOTTextures || (Tools.IsExponentOfTwo(this.video.videoWidth) && Tools.IsExponentOfTwo(this.video.videoHeight))) {\r\n            this.wrapU = Texture.WRAP_ADDRESSMODE;\r\n            this.wrapV = Texture.WRAP_ADDRESSMODE;\r\n        } else {\r\n            this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._generateMipMaps = false;\r\n        }\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this.samplingMode);\r\n        this._texture.format = this._format ?? Constants.TEXTUREFORMAT_RGBA;\r\n\r\n        if (!this.video.autoplay && !this._settings.poster && !this._settings.independentVideoSource) {\r\n            const oldHandler = this.video.onplaying;\r\n            const oldMuted = this.video.muted;\r\n            this.video.muted = true;\r\n            this.video.onplaying = () => {\r\n                this.video.muted = oldMuted;\r\n                this.video.onplaying = oldHandler;\r\n                this._updateInternalTexture();\r\n                if (!this._errorFound) {\r\n                    this.video.pause();\r\n                }\r\n                if (this.onLoadObservable.hasObservers()) {\r\n                    this.onLoadObservable.notifyObservers(this);\r\n                }\r\n            };\r\n            this._handlePlay();\r\n        } else {\r\n            this._updateInternalTexture();\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n        }\r\n    };\r\n\r\n    private _reset = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n\r\n        if (!this._displayingPosterTexture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @internal Internal method to initiate `update`.\r\n     */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n\r\n    /**\r\n     * Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.\r\n     */\r\n    public update(): void {\r\n        if (!this.autoUpdateTexture) {\r\n            // Expecting user to call `updateTexture` manually\r\n            return;\r\n        }\r\n\r\n        this.updateTexture(true);\r\n    }\r\n\r\n    /**\r\n     * Update Texture in `manual` mode. Does not do anything if not visible or paused.\r\n     * @param isVisible Visibility state, detected by user using `scene.getActiveMeshes()` or otherwise.\r\n     */\r\n    public updateTexture(isVisible: boolean): void {\r\n        if (!isVisible) {\r\n            return;\r\n        }\r\n        if (this.video.paused && this._stillImageCaptured) {\r\n            return;\r\n        }\r\n        this._stillImageCaptured = true;\r\n        this._updateInternalTexture();\r\n    }\r\n\r\n    protected _updateInternalTexture = (): void => {\r\n        if (this._texture == null) {\r\n            return;\r\n        }\r\n        if (this.video.readyState < this.video.HAVE_CURRENT_DATA) {\r\n            return;\r\n        }\r\n        if (this._displayingPosterTexture) {\r\n            return;\r\n        }\r\n\r\n        const frameId = this.getScene()!.getFrameId();\r\n        if (this._frameId === frameId) {\r\n            return;\r\n        }\r\n\r\n        this._frameId = frameId;\r\n\r\n        this._getEngine()!.updateVideoTexture(this._texture, this._externalTexture ? this._externalTexture : this.video, this._invertY);\r\n    };\r\n\r\n    /**\r\n     * Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.\r\n     * @param url New url.\r\n     */\r\n    public updateURL(url: string): void {\r\n        this.video.src = url;\r\n        this._currentSrc = url;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): VideoTexture {\r\n        return new VideoTexture(this.name, this._currentSrc!, this.getScene(), this._generateMipMaps, this.invertY, this.samplingMode, this._settings);\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this._currentSrc = null;\r\n\r\n        if (this._onUserActionRequestedObservable) {\r\n            this._onUserActionRequestedObservable.clear();\r\n            this._onUserActionRequestedObservable = null;\r\n        }\r\n\r\n        this.video.removeEventListener(this._createInternalTextureOnEvent, this._createInternalTexture);\r\n        if (!this._settings.independentVideoSource) {\r\n            this.video.removeEventListener(\"paused\", this._updateInternalTexture);\r\n            this.video.removeEventListener(\"seeked\", this._updateInternalTexture);\r\n            this.video.removeEventListener(\"emptied\", this._reset);\r\n            this.video.pause();\r\n        }\r\n\r\n        this._externalTexture?.dispose();\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from a stream.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param stream Define the stream the texture should be created from\r\n     * @param constraints video constraints\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static CreateFromStreamAsync(scene: Scene, stream: MediaStream, constraints: any, invertY = true): Promise<VideoTexture> {\r\n        const video = scene.getEngine().createVideoElement(constraints);\r\n\r\n        if (scene.getEngine()._badOS) {\r\n            // Yes... I know and I hope to remove it soon...\r\n            document.body.appendChild(video);\r\n            video.style.transform = \"scale(0.0001, 0.0001)\";\r\n            video.style.opacity = \"0\";\r\n            video.style.position = \"fixed\";\r\n            video.style.bottom = \"0px\";\r\n            video.style.right = \"0px\";\r\n        }\r\n\r\n        video.setAttribute(\"autoplay\", \"\");\r\n        video.setAttribute(\"muted\", \"true\");\r\n        video.setAttribute(\"playsinline\", \"\");\r\n        video.muted = true;\r\n\r\n        if (video.isNative) {\r\n            // No additional configuration needed for native\r\n        } else if (video.mozSrcObject !== undefined) {\r\n            // hack for Firefox < 19\r\n            video.mozSrcObject = stream;\r\n        } else {\r\n            if (typeof video.srcObject == \"object\") {\r\n                video.srcObject = stream;\r\n            } else {\r\n                // older API. See https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL#using_object_urls_for_media_streams\r\n                video.src = window.URL && window.URL.createObjectURL(stream as any);\r\n            }\r\n        }\r\n\r\n        return new Promise<VideoTexture>((resolve) => {\r\n            const onPlaying = () => {\r\n                const videoTexture = new VideoTexture(\"video\", video, scene, true, invertY, undefined, undefined, undefined, Constants.TEXTUREFORMAT_RGB);\r\n                if (scene.getEngine()._badOS) {\r\n                    videoTexture.onDisposeObservable.addOnce(() => {\r\n                        video.remove();\r\n                    });\r\n                }\r\n                videoTexture.onDisposeObservable.addOnce(() => {\r\n                    removeSource(video);\r\n                });\r\n\r\n                resolve(videoTexture);\r\n                video.removeEventListener(\"playing\", onPlaying);\r\n            };\r\n\r\n            video.addEventListener(\"playing\", onPlaying);\r\n            video.play();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Define the scene the texture should be created in\r\n     * @param constraints Define the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Define the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     * @returns The created video texture as a promise\r\n     */\r\n    public static async CreateFromWebCamAsync(\r\n        scene: Scene,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): Promise<VideoTexture> {\r\n        if (navigator.mediaDevices) {\r\n            const stream = await navigator.mediaDevices.getUserMedia({\r\n                video: constraints,\r\n                audio: audioConstaints,\r\n            });\r\n\r\n            const videoTexture = await this.CreateFromStreamAsync(scene, stream, constraints, invertY);\r\n            videoTexture.onDisposeObservable.addOnce(() => {\r\n                stream.getTracks().forEach((track) => {\r\n                    track.stop();\r\n                });\r\n            });\r\n\r\n            return videoTexture;\r\n        }\r\n\r\n        return Promise.reject(\"No support for userMedia on this device\");\r\n    }\r\n\r\n    /**\r\n     * Creates a video texture straight from your WebCam video feed.\r\n     * @param scene Defines the scene the texture should be created in\r\n     * @param onReady Defines a callback to triggered once the texture will be ready\r\n     * @param constraints Defines the constraints to use to create the web cam feed from WebRTC\r\n     * @param audioConstaints Defines the audio constraints to use to create the web cam feed from WebRTC\r\n     * @param invertY Defines if the video should be stored with invert Y set to true (true by default)\r\n     */\r\n    public static CreateFromWebCam(\r\n        scene: Scene,\r\n        onReady: (videoTexture: VideoTexture) => void,\r\n        constraints: {\r\n            minWidth: number;\r\n            maxWidth: number;\r\n            minHeight: number;\r\n            maxHeight: number;\r\n            deviceId: string;\r\n        } & MediaTrackConstraints,\r\n        audioConstaints: boolean | MediaTrackConstraints = false,\r\n        invertY = true\r\n    ): void {\r\n        this.CreateFromWebCamAsync(scene, constraints, audioConstaints, invertY)\r\n            .then(function (videoTexture) {\r\n                if (onReady) {\r\n                    onReady(videoTexture);\r\n                }\r\n            })\r\n            .catch(function (err) {\r\n                Logger.Error(err.name);\r\n            });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}