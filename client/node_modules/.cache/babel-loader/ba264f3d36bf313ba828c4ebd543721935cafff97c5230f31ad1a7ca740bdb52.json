{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _CreationDataStorage, Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { LinesMesh } from \"../../Meshes/linesMesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Creates the VertexData of the LineSystem\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n *  - lines an array of lines, each line being an array of successive Vector3\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n * @param options.lines\n * @param options.colors\n * @returns the VertexData of the LineSystem\n */\nexport function CreateLineSystemVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const lines = options.lines;\n  const colors = options.colors;\n  const vertexColors = [];\n  let idx = 0;\n  for (let l = 0; l < lines.length; l++) {\n    const points = lines[l];\n    for (let index = 0; index < points.length; index++) {\n      positions.push(points[index].x, points[index].y, points[index].z);\n      if (colors) {\n        const color = colors[l];\n        vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\n      }\n      if (index > 0) {\n        indices.push(idx - 1);\n        indices.push(idx);\n      }\n      idx++;\n    }\n  }\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  if (colors) {\n    vertexData.colors = vertexColors;\n  }\n  return vertexData;\n}\n/**\n * Create the VertexData for a DashedLines\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n *  - points an array successive Vector3\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n *  - dashNb the intended total number of dashes, optional, default 200\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @returns the VertexData for the DashedLines\n */\nexport function CreateDashedLinesVertexData(options) {\n  const dashSize = options.dashSize || 3;\n  const gapSize = options.gapSize || 1;\n  const dashNb = options.dashNb || 200;\n  const points = options.points;\n  const positions = new Array();\n  const indices = new Array();\n  const curvect = Vector3.Zero();\n  let lg = 0;\n  let nb = 0;\n  let shft = 0;\n  let dashshft = 0;\n  let curshft = 0;\n  let idx = 0;\n  let i = 0;\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    lg += curvect.length();\n  }\n  shft = lg / dashNb;\n  dashshft = dashSize * shft / (dashSize + gapSize);\n  for (i = 0; i < points.length - 1; i++) {\n    points[i + 1].subtractToRef(points[i], curvect);\n    nb = Math.floor(curvect.length() / shft);\n    curvect.normalize();\n    for (let j = 0; j < nb; j++) {\n      curshft = shft * j;\n      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n      indices.push(idx, idx + 1);\n      idx += 2;\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  return vertexData;\n}\n/**\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.lines\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line system mesh\n */\nexport function CreateLineSystem(name, options, scene) {\n  const instance = options.instance;\n  const lines = options.lines;\n  const colors = options.colors;\n  if (instance) {\n    // lines update\n    const positions = instance.getVerticesData(VertexBuffer.PositionKind);\n    let vertexColor;\n    let lineColors;\n    if (colors) {\n      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);\n    }\n    let i = 0;\n    let c = 0;\n    for (let l = 0; l < lines.length; l++) {\n      const points = lines[l];\n      for (let p = 0; p < points.length; p++) {\n        positions[i] = points[p].x;\n        positions[i + 1] = points[p].y;\n        positions[i + 2] = points[p].z;\n        if (colors && vertexColor) {\n          lineColors = colors[l];\n          vertexColor[c] = lineColors[p].r;\n          vertexColor[c + 1] = lineColors[p].g;\n          vertexColor[c + 2] = lineColors[p].b;\n          vertexColor[c + 3] = lineColors[p].a;\n          c += 4;\n        }\n        i += 3;\n      }\n    }\n    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n    if (colors && vertexColor) {\n      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\n    }\n    return instance;\n  }\n  // line system creation\n  const useVertexColor = colors ? true : false;\n  const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\n  const vertexData = CreateLineSystemVertexData(options);\n  vertexData.applyToMesh(lineSystem, options.updatable);\n  return lineSystem;\n}\n/**\n * Creates a line mesh\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * The optional parameter `colors` is an array of successive Color4, one per line point\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\n * @param name defines the name of the new line system\n * @param options defines the options used to create the line system\n * @param options.points\n * @param options.updatable\n * @param options.instance\n * @param options.colors\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns a new line mesh\n */\nexport function CreateLines(name, options, scene = null) {\n  const colors = options.colors ? [options.colors] : null;\n  const lines = CreateLineSystem(name, {\n    lines: [options.points],\n    updatable: options.updatable,\n    instance: options.instance,\n    colors: colors,\n    useVertexAlpha: options.useVertexAlpha,\n    material: options.material\n  }, scene);\n  return lines;\n}\n/**\n * Creates a dashed line mesh\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\n * * The parameter `points` is an array successive Vector3\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\n * * When updating an instance, remember that only point positions can change, not the number of points\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.points\n * @param options.dashSize\n * @param options.gapSize\n * @param options.dashNb\n * @param options.updatable\n * @param options.instance\n * @param options.useVertexAlpha\n * @param options.material\n * @param scene defines the hosting scene\n * @returns the dashed line mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\n */\nexport function CreateDashedLines(name, options, scene = null) {\n  const points = options.points;\n  const instance = options.instance;\n  const gapSize = options.gapSize || 1;\n  const dashSize = options.dashSize || 3;\n  if (instance) {\n    //  dashed lines update\n    const positionFunction = positions => {\n      const curvect = Vector3.Zero();\n      const nbSeg = positions.length / 6;\n      let lg = 0;\n      let nb = 0;\n      let shft = 0;\n      let dashshft = 0;\n      let curshft = 0;\n      let p = 0;\n      let i = 0;\n      let j = 0;\n      for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        lg += curvect.length();\n      }\n      shft = lg / nbSeg;\n      const dashSize = instance._creationDataStorage.dashSize;\n      const gapSize = instance._creationDataStorage.gapSize;\n      dashshft = dashSize * shft / (dashSize + gapSize);\n      for (i = 0; i < points.length - 1; i++) {\n        points[i + 1].subtractToRef(points[i], curvect);\n        nb = Math.floor(curvect.length() / shft);\n        curvect.normalize();\n        j = 0;\n        while (j < nb && p < positions.length) {\n          curshft = shft * j;\n          positions[p] = points[i].x + curshft * curvect.x;\n          positions[p + 1] = points[i].y + curshft * curvect.y;\n          positions[p + 2] = points[i].z + curshft * curvect.z;\n          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n          p += 6;\n          j++;\n        }\n      }\n      while (p < positions.length) {\n        positions[p] = points[i].x;\n        positions[p + 1] = points[i].y;\n        positions[p + 2] = points[i].z;\n        p += 3;\n      }\n    };\n    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\n      Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\n    }\n    instance.updateMeshPositions(positionFunction, false);\n    return instance;\n  }\n  // dashed lines creation\n  const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\n  const vertexData = CreateDashedLinesVertexData(options);\n  vertexData.applyToMesh(dashedLines, options.updatable);\n  dashedLines._creationDataStorage = new _CreationDataStorage();\n  dashedLines._creationDataStorage.dashSize = dashSize;\n  dashedLines._creationDataStorage.gapSize = gapSize;\n  return dashedLines;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const LinesBuilder = {\n  CreateDashedLines,\n  CreateLineSystem,\n  CreateLines\n};\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\nMesh.CreateLines = (name, points, scene = null, updatable = false, instance = null) => {\n  const options = {\n    points,\n    updatable,\n    instance\n  };\n  return CreateLines(name, options, scene);\n};\nMesh.CreateDashedLines = (name, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {\n  const options = {\n    points,\n    dashSize,\n    gapSize,\n    dashNb,\n    updatable,\n    instance\n  };\n  return CreateDashedLines(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","_CreationDataStorage","Mesh","VertexData","LinesMesh","VertexBuffer","Logger","CreateLineSystemVertexData","options","indices","positions","lines","colors","vertexColors","idx","l","length","points","index","push","x","y","z","color","r","g","b","a","vertexData","CreateDashedLinesVertexData","dashSize","gapSize","dashNb","Array","curvect","Zero","lg","nb","shft","dashshft","curshft","i","subtractToRef","Math","floor","normalize","j","CreateLineSystem","name","scene","instance","getVerticesData","PositionKind","vertexColor","lineColors","ColorKind","c","p","updateVerticesData","useVertexColor","lineSystem","undefined","useVertexAlpha","material","applyToMesh","updatable","CreateLines","CreateDashedLines","positionFunction","nbSeg","_creationDataStorage","Warn","updateMeshPositions","dashedLines","LinesBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/linesBuilder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\ndeclare type Material = import(\"../../Materials/material\").Material;\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @param options.lines\r\n * @param options.colors\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.lines\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene>\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param options.points\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.colors\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.points\r\n * @param options.dashSize\r\n * @param options.gapSize\r\n * @param options.dashNb\r\n * @param options.updatable\r\n * @param options.instance\r\n * @param options.useVertexAlpha\r\n * @param options.material\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\n(Mesh as any).CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}