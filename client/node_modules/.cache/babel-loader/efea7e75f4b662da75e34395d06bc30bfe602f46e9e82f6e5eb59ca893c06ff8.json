{"ast":null,"code":"import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\n/**\n * @internal\n * @deprecated\n */\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\n  constructor() {\n    super(\"KHR_materials_common\");\n  }\n  loadRuntimeExtensionsAsync(gltfRuntime) {\n    if (!gltfRuntime.extensions) {\n      return false;\n    }\n    const extension = gltfRuntime.extensions[this.name];\n    if (!extension) {\n      return false;\n    }\n    // Create lights\n    const lights = extension.lights;\n    if (lights) {\n      for (const thing in lights) {\n        const light = lights[thing];\n        switch (light.type) {\n          case \"ambient\":\n            {\n              const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\n              const ambient = light.ambient;\n              if (ambient) {\n                ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\n              }\n              break;\n            }\n          case \"point\":\n            {\n              const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\n              const point = light.point;\n              if (point) {\n                pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\n              }\n              break;\n            }\n          case \"directional\":\n            {\n              const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\n              const directional = light.directional;\n              if (directional) {\n                dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\n              }\n              break;\n            }\n          case \"spot\":\n            {\n              const spot = light.spot;\n              if (spot) {\n                const spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0.0, gltfRuntime.scene);\n                spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\n              }\n              break;\n            }\n          default:\n            Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\n            break;\n        }\n      }\n    }\n    return false;\n  }\n  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n    const material = gltfRuntime.materials[id];\n    if (!material || !material.extensions) {\n      return false;\n    }\n    const extension = material.extensions[this.name];\n    if (!extension) {\n      return false;\n    }\n    const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\n    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n    if (extension.technique === \"CONSTANT\") {\n      standardMaterial.disableLighting = true;\n    }\n    standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\n    standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\n    standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\n    // Ambient\n    if (typeof extension.values.ambient === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\n    } else {\n      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\n    }\n    // Diffuse\n    if (typeof extension.values.diffuse === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\n    } else {\n      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\n    }\n    // Emission\n    if (typeof extension.values.emission === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\n    } else {\n      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\n    }\n    // Specular\n    if (typeof extension.values.specular === \"string\") {\n      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\n    } else {\n      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\n    }\n    return true;\n  }\n  _loadTexture(gltfRuntime, id, material, propertyPath, onError) {\n    // Create buffer from texture url\n    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, buffer => {\n      // Create texture from buffer\n      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, texture => material[propertyPath] = texture);\n    }, onError);\n  }\n}\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());","map":{"version":3,"mappings":"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","names":["GLTFLoaderExtension","GLTFLoaderBase","GLTFLoader","Vector3","Color3","Tools","Material","StandardMaterial","HemisphericLight","DirectionalLight","PointLight","SpotLight","GLTFMaterialsCommonExtension","constructor","loadRuntimeExtensionsAsync","gltfRuntime","extensions","extension","name","lights","thing","light","type","ambientLight","scene","ambient","diffuse","FromArray","color","pointLight","point","dirLight","directional","spot","spotLight","fallOffAngle","Math","PI","fallOffExponent","Warn","loadMaterialAsync","id","onSuccess","onError","material","materials","standardMaterial","sideOrientation","CounterClockWiseSideOrientation","technique","disableLighting","backFaceCulling","doubleSided","undefined","alpha","values","transparency","specularPower","shininess","_loadTexture","ambientColor","diffuseColor","emission","emissiveColor","specular","specularColor","propertyPath","LoadTextureBufferAsync","buffer","CreateTextureAsync","texture","RegisterExtension"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/glTF/1.0/glTFMaterialsCommonExtension.ts"],"sourcesContent":["import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}