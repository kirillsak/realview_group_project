{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nlet meshIdProvider = 0;\n/**\n * The mesh detector is used to detect meshes in the real world when in AR\n */\nexport class WebXRMeshDetector extends WebXRAbstractFeature {\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._detectedMeshes = new Map();\n    /**\n     * Observers registered here will be executed when a new mesh was added to the session\n     */\n    this.onMeshAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when a mesh is no longer detected in the session\n     */\n    this.onMeshRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing mesh updates\n     */\n    this.onMeshUpdatedObservable = new Observable();\n    this.xrNativeFeatureName = \"mesh-detection\";\n    if (this._xrSessionManager.session) {\n      this._init();\n    } else {\n      this._xrSessionManager.onXRSessionInit.addOnce(() => {\n        this._init();\n      });\n    }\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    // Only supported by BabylonNative\n    if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n      this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\n    }\n    if (!this._options.doNotRemoveMeshesOnSessionEnded) {\n      this._detectedMeshes.forEach(mesh => {\n        this.onMeshRemovedObservable.notifyObservers(mesh);\n      });\n      this._detectedMeshes.clear();\n    }\n    return true;\n  }\n  dispose() {\n    super.dispose();\n    this.onMeshAddedObservable.clear();\n    this.onMeshRemovedObservable.clear();\n    this.onMeshUpdatedObservable.clear();\n  }\n  _onXRFrame(frame) {\n    var _a;\n    // TODO remove try catch\n    try {\n      if (!this.attached || !frame) {\n        return;\n      }\n      const detectedMeshes = (_a = frame.worldInformation) === null || _a === void 0 ? void 0 : _a.detectedMeshes;\n      if (detectedMeshes) {\n        const toRemove = new Set();\n        this._detectedMeshes.forEach((vertexData, xrMesh) => {\n          if (!detectedMeshes.has(xrMesh)) {\n            toRemove.add(xrMesh);\n          }\n        });\n        toRemove.forEach(xrMesh => {\n          const vertexData = this._detectedMeshes.get(xrMesh);\n          if (vertexData) {\n            this.onMeshRemovedObservable.notifyObservers(vertexData);\n            this._detectedMeshes.delete(xrMesh);\n          }\n        });\n        // now check for new ones\n        detectedMeshes.forEach(xrMesh => {\n          if (!this._detectedMeshes.has(xrMesh)) {\n            const partialVertexData = {\n              id: meshIdProvider++,\n              xrMesh: xrMesh\n            };\n            const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\n            this._detectedMeshes.set(xrMesh, vertexData);\n            this.onMeshAddedObservable.notifyObservers(vertexData);\n          } else {\n            // updated?\n            if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {\n              const vertexData = this._detectedMeshes.get(xrMesh);\n              if (vertexData) {\n                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\n                this.onMeshUpdatedObservable.notifyObservers(vertexData);\n              }\n            }\n          }\n        });\n      }\n    } catch (error) {\n      console.log(error.stack);\n    }\n  }\n  _init() {\n    // Only supported by BabylonNative\n    if (this._xrSessionManager.isNative) {\n      if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\n        this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\n      }\n      if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\n        this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\n      }\n    }\n  }\n  _updateVertexDataWithXRMesh(xrMesh, mesh, xrFrame) {\n    mesh.xrMesh = xrMesh;\n    mesh.worldParentNode = this._options.worldParentNode;\n    if (this._options.convertCoordinateSystems) {\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mesh.positions = new Float32Array(xrMesh.positions.length);\n        for (let i = 0; i < xrMesh.positions.length; i += 3) {\n          mesh.positions[i] = xrMesh.positions[i];\n          mesh.positions[i + 1] = xrMesh.positions[i + 1];\n          mesh.positions[i + 2] = -1 * xrMesh.positions[i + 2];\n        }\n        if (xrMesh.normals) {\n          mesh.normals = new Float32Array(xrMesh.normals.length);\n          for (let i = 0; i < xrMesh.normals.length; i += 3) {\n            mesh.normals[i] = xrMesh.normals[i];\n            mesh.normals[i + 1] = xrMesh.normals[i + 1];\n            mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\n          }\n        }\n      } else {\n        mesh.positions = xrMesh.positions;\n        mesh.normals = xrMesh.normals;\n      }\n      // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\n      mesh.indices = xrMesh.indices;\n      // matrix\n      const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\n      if (pose) {\n        const mat = mesh.transformationMatrix || new Matrix();\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n        mesh.transformationMatrix = mat;\n        if (this._options.worldParentNode) {\n          mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n        }\n      }\n    }\n    return mesh;\n  }\n}\n/**\n * The module's name\n */\nWebXRMeshDetector.Name = WebXRFeatureName.MESH_DETECTION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRMeshDetector.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMeshDetector.Name, (xrSessionManager, options) => {\n  return () => new WebXRMeshDetector(xrSessionManager, options);\n}, WebXRMeshDetector.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","WebXRAbstractFeature","Matrix","Observable","meshIdProvider","WebXRMeshDetector","constructor","_xrSessionManager","_options","Map","xrNativeFeatureName","session","_init","onXRSessionInit","addOnce","detach","isNative","trySetMeshDetectorEnabled","doNotRemoveMeshesOnSessionEnded","_detectedMeshes","forEach","mesh","onMeshRemovedObservable","notifyObservers","clear","dispose","onMeshAddedObservable","onMeshUpdatedObservable","_onXRFrame","frame","attached","detectedMeshes","worldInformation","toRemove","Set","vertexData","xrMesh","has","add","get","delete","partialVertexData","id","_updateVertexDataWithXRMesh","set","lastChangedTime","currentTimestamp","error","console","log","stack","preferredDetectorOptions","trySetPreferredMeshDetectorOptions","xrFrame","worldParentNode","convertCoordinateSystems","scene","useRightHandedSystem","positions","Float32Array","length","i","normals","indices","pose","getPose","meshSpace","referenceSpace","mat","transformationMatrix","FromArrayToRef","transform","matrix","toggleModelMatrixHandInPlace","multiplyToRef","getWorldMatrix","MESH_DETECTION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRMeshDetector.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Matrix } from \"../../Maths/math\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Options used in the mesh detector module\r\n */\r\nexport interface IWebXRMeshDetectorOptions {\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * If set to true a reference of the created meshes will be kept until the next session starts\r\n     * If not defined, meshes will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveMeshesOnSessionEnded?: boolean;\r\n    /**\r\n     * Preferred detector configuration, not all preferred options will be supported by all platforms.\r\n     */\r\n    preferredDetectorOptions?: XRGeometryDetectorOptions;\r\n    /**\r\n     * If set to true, WebXRMeshDetector will convert coordinate systems for meshes.\r\n     * If not defined, mesh conversions from right handed to left handed coordinate systems won't be conducted.\r\n     * Right handed mesh data will be available through IWebXRVertexData.xrMesh.\r\n     */\r\n    convertCoordinateSystems?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon interface for a XR mesh's vertex data.\r\n *\r\n * Currently not supported by WebXR, available only with BabylonNative\r\n */\r\nexport interface IWebXRVertexData {\r\n    /**\r\n     * A babylon-assigned ID for this mesh\r\n     */\r\n    id: number;\r\n    /**\r\n     * Data required for constructing a mesh in Babylon.js.\r\n     */\r\n    xrMesh: XRMesh;\r\n    /**\r\n     * The node to use to transform the local results to world coordinates.\r\n     * WorldParentNode will only exist if it was declared in the IWebXRMeshDetectorOptions.\r\n     */\r\n    worldParentNode?: TransformNode;\r\n    /**\r\n     * An array of vertex positions in babylon space. right/left hand system is taken into account.\r\n     * Positions will only be calculated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    positions?: Float32Array;\r\n    /**\r\n     * An array of indices in babylon space. Indices have a counterclockwise winding order.\r\n     * Indices will only be populated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    indices?: Uint32Array;\r\n    /**\r\n     * An array of vertex normals in babylon space. right/left hand system is taken into account.\r\n     * Normals will not be calculated if convertCoordinateSystems is undefined in the IWebXRMeshDetectorOptions.\r\n     * Different platforms may or may not support mesh normals when convertCoordinateSystems is set to true.\r\n     */\r\n    normals?: Float32Array;\r\n    /**\r\n     * A transformation matrix to apply on the mesh that will be built using the meshDefinition.\r\n     * Local vs. World are decided if worldParentNode was provided or not in the options when constructing the module.\r\n     * TransformationMatrix will only be calculated if convertCoordinateSystems is set to true in the IWebXRMeshDetectorOptions.\r\n     */\r\n    transformationMatrix?: Matrix;\r\n}\r\n\r\nlet meshIdProvider = 0;\r\n\r\n/**\r\n * The mesh detector is used to detect meshes in the real world when in AR\r\n */\r\nexport class WebXRMeshDetector extends WebXRAbstractFeature {\r\n    private _detectedMeshes: Map<XRMesh, IWebXRVertexData> = new Map<XRMesh, IWebXRVertexData>();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.MESH_DETECTION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new mesh was added to the session\r\n     */\r\n    public onMeshAddedObservable: Observable<IWebXRVertexData> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when a mesh is no longer detected in the session\r\n     */\r\n    public onMeshRemovedObservable: Observable<IWebXRVertexData> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing mesh updates\r\n     */\r\n    public onMeshUpdatedObservable: Observable<IWebXRVertexData> = new Observable();\r\n\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRMeshDetectorOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"mesh-detection\";\r\n        if (this._xrSessionManager.session) {\r\n            this._init();\r\n        } else {\r\n            this._xrSessionManager.onXRSessionInit.addOnce(() => {\r\n                this._init();\r\n            });\r\n        }\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        // Only supported by BabylonNative\r\n        if (!!this._xrSessionManager.isNative && !!this._xrSessionManager.session.trySetMeshDetectorEnabled) {\r\n            this._xrSessionManager.session.trySetMeshDetectorEnabled(false);\r\n        }\r\n\r\n        if (!this._options.doNotRemoveMeshesOnSessionEnded) {\r\n            this._detectedMeshes.forEach((mesh) => {\r\n                this.onMeshRemovedObservable.notifyObservers(mesh);\r\n            });\r\n\r\n            this._detectedMeshes.clear();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onMeshAddedObservable.clear();\r\n        this.onMeshRemovedObservable.clear();\r\n        this.onMeshUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // TODO remove try catch\r\n        try {\r\n            if (!this.attached || !frame) {\r\n                return;\r\n            }\r\n\r\n            const detectedMeshes = frame.worldInformation?.detectedMeshes;\r\n            if (detectedMeshes) {\r\n                const toRemove = new Set<XRMesh>();\r\n                this._detectedMeshes.forEach((vertexData, xrMesh) => {\r\n                    if (!detectedMeshes.has(xrMesh)) {\r\n                        toRemove.add(xrMesh);\r\n                    }\r\n                });\r\n                toRemove.forEach((xrMesh) => {\r\n                    const vertexData = this._detectedMeshes.get(xrMesh);\r\n                    if (vertexData) {\r\n                        this.onMeshRemovedObservable.notifyObservers(vertexData);\r\n                        this._detectedMeshes.delete(xrMesh);\r\n                    }\r\n                });\r\n\r\n                // now check for new ones\r\n                detectedMeshes.forEach((xrMesh) => {\r\n                    if (!this._detectedMeshes.has(xrMesh)) {\r\n                        const partialVertexData: Partial<IWebXRVertexData> = {\r\n                            id: meshIdProvider++,\r\n                            xrMesh: xrMesh,\r\n                        };\r\n                        const vertexData = this._updateVertexDataWithXRMesh(xrMesh, partialVertexData, frame);\r\n                        this._detectedMeshes.set(xrMesh, vertexData);\r\n                        this.onMeshAddedObservable.notifyObservers(vertexData);\r\n                    } else {\r\n                        // updated?\r\n                        if (xrMesh.lastChangedTime === this._xrSessionManager.currentTimestamp) {\r\n                            const vertexData = this._detectedMeshes.get(xrMesh);\r\n                            if (vertexData) {\r\n                                this._updateVertexDataWithXRMesh(xrMesh, vertexData, frame);\r\n                                this.onMeshUpdatedObservable.notifyObservers(vertexData);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.log(error.stack);\r\n        }\r\n    }\r\n\r\n    private _init() {\r\n        // Only supported by BabylonNative\r\n        if (this._xrSessionManager.isNative) {\r\n            if (this._xrSessionManager.session.trySetMeshDetectorEnabled) {\r\n                this._xrSessionManager.session.trySetMeshDetectorEnabled(true);\r\n            }\r\n\r\n            if (!!this._options.preferredDetectorOptions && !!this._xrSessionManager.session.trySetPreferredMeshDetectorOptions) {\r\n                this._xrSessionManager.session.trySetPreferredMeshDetectorOptions(this._options.preferredDetectorOptions);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateVertexDataWithXRMesh(xrMesh: XRMesh, mesh: Partial<IWebXRVertexData>, xrFrame: XRFrame): IWebXRVertexData {\r\n        mesh.xrMesh = xrMesh;\r\n        mesh.worldParentNode = this._options.worldParentNode;\r\n\r\n        if (this._options.convertCoordinateSystems) {\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mesh.positions = new Float32Array(xrMesh.positions.length);\r\n                for (let i = 0; i < xrMesh.positions.length; i += 3) {\r\n                    mesh.positions[i] = xrMesh.positions[i];\r\n                    mesh.positions[i + 1] = xrMesh.positions[i + 1];\r\n                    mesh.positions[i + 2] = -1 * xrMesh.positions[i + 2];\r\n                }\r\n\r\n                if (xrMesh.normals) {\r\n                    mesh.normals = new Float32Array(xrMesh.normals.length);\r\n                    for (let i = 0; i < xrMesh.normals.length; i += 3) {\r\n                        mesh.normals[i] = xrMesh.normals[i];\r\n                        mesh.normals[i + 1] = xrMesh.normals[i + 1];\r\n                        mesh.normals[i + 2] = -1 * xrMesh.normals[i + 2];\r\n                    }\r\n                }\r\n            } else {\r\n                mesh.positions = xrMesh.positions;\r\n                mesh.normals = xrMesh.normals;\r\n            }\r\n\r\n            // WebXR should provide indices in a counterclockwise winding order regardless of coordinate system handedness\r\n            mesh.indices = xrMesh.indices;\r\n\r\n            // matrix\r\n            const pose = xrFrame.getPose(xrMesh.meshSpace, this._xrSessionManager.referenceSpace);\r\n            if (pose) {\r\n                const mat = mesh.transformationMatrix || new Matrix();\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                mesh.transformationMatrix = mat;\r\n                if (this._options.worldParentNode) {\r\n                    mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n                }\r\n            }\r\n        }\r\n\r\n        return <IWebXRVertexData>mesh;\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMeshDetector.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMeshDetector(xrSessionManager, options);\r\n    },\r\n    WebXRMeshDetector.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}