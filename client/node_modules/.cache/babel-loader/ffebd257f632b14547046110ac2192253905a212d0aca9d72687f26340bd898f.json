{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\n/**\n * Uses the GPU to create a copy texture rescaled at a given size\n * @param texture Texture to copy from\n * @param width defines the desired width\n * @param height defines the desired height\n * @param useBilinearMode defines if bilinear mode has to be used\n * @returns the generated texture\n */\nexport function CreateResizedCopy(texture, width, height, useBilinearMode = true) {\n  const scene = texture.getScene();\n  const engine = scene.getEngine();\n  const rtt = new RenderTargetTexture(\"resized\" + texture.name, {\n    width: width,\n    height: height\n  }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);\n  rtt.wrapU = texture.wrapU;\n  rtt.wrapV = texture.wrapV;\n  rtt.uOffset = texture.uOffset;\n  rtt.vOffset = texture.vOffset;\n  rtt.uScale = texture.uScale;\n  rtt.vScale = texture.vScale;\n  rtt.uAng = texture.uAng;\n  rtt.vAng = texture.vAng;\n  rtt.wAng = texture.wAng;\n  rtt.coordinatesIndex = texture.coordinatesIndex;\n  rtt.level = texture.level;\n  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\n  rtt._texture.isReady = false;\n  texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n  texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n  const passPostProcess = new PassPostProcess(\"pass\", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);\n  passPostProcess.externalTextureSamplerBinding = true;\n  passPostProcess.getEffect().executeWhenCompiled(() => {\n    passPostProcess.onApply = function (effect) {\n      effect.setTexture(\"textureSampler\", texture);\n    };\n    const internalTexture = rtt.renderTarget;\n    if (internalTexture) {\n      scene.postProcessManager.directRender([passPostProcess], internalTexture);\n      engine.unBindFramebuffer(internalTexture);\n      rtt.disposeFramebufferObjects();\n      passPostProcess.dispose();\n      rtt.getInternalTexture().isReady = true;\n    }\n  });\n  return rtt;\n}\n/**\n * Apply a post process to a texture\n * @param postProcessName name of the fragment post process\n * @param internalTexture the texture to encode\n * @param scene the scene hosting the texture\n * @param type type of the output texture. If not provided, use the one from internalTexture\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n * @param format format of the output texture. If not provided, use the one from internalTexture\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n */\nexport function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format) {\n  // Gets everything ready.\n  const engine = internalTexture.getEngine();\n  internalTexture.isReady = false;\n  samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;\n  type = type !== null && type !== void 0 ? type : internalTexture.type;\n  format = format !== null && format !== void 0 ? format : internalTexture.format;\n  if (type === -1) {\n    type = 0;\n  }\n  return new Promise(resolve => {\n    // Create the post process\n    const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\n    postProcess.externalTextureSamplerBinding = true;\n    // Hold the output of the decoding.\n    const encodedTexture = engine.createRenderTargetTexture({\n      width: internalTexture.width,\n      height: internalTexture.height\n    }, {\n      generateDepthBuffer: false,\n      generateMipMaps: false,\n      generateStencilBuffer: false,\n      samplingMode,\n      type,\n      format\n    });\n    postProcess.getEffect().executeWhenCompiled(() => {\n      // PP Render Pass\n      postProcess.onApply = effect => {\n        effect._bindTexture(\"textureSampler\", internalTexture);\n        effect.setFloat2(\"scale\", 1, 1);\n      };\n      scene.postProcessManager.directRender([postProcess], encodedTexture, true);\n      // Cleanup\n      engine.restoreDefaultFramebuffer();\n      engine._releaseTexture(internalTexture);\n      if (postProcess) {\n        postProcess.dispose();\n      }\n      // Internal Swap\n      encodedTexture._swapAndDie(internalTexture);\n      // Ready to get rolling again.\n      internalTexture.type = type;\n      internalTexture.format = 5;\n      internalTexture.isReady = true;\n      resolve(internalTexture);\n    });\n  });\n}\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\nlet floatView;\nlet int32View;\n/**\n * Converts a number to half float\n * @param value number to convert\n * @returns converted number\n */\nexport function ToHalfFloat(value) {\n  if (!floatView) {\n    floatView = new Float32Array(1);\n    int32View = new Int32Array(floatView.buffer);\n  }\n  floatView[0] = value;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  bits += m & 1;\n  return bits;\n}\n/**\n * Converts a half float to a number\n * @param value half float to convert\n * @returns converted half float\n */\nexport function FromHalfFloat(value) {\n  const s = (value & 0x8000) >> 15;\n  const e = (value & 0x7c00) >> 10;\n  const f = value & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e == 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n/**\n * Class used to host texture specific utilities\n */\nexport const TextureTools = {\n  /**\n   * Uses the GPU to create a copy texture rescaled at a given size\n   * @param texture Texture to copy from\n   * @param width defines the desired width\n   * @param height defines the desired height\n   * @param useBilinearMode defines if bilinear mode has to be used\n   * @returns the generated texture\n   */\n  CreateResizedCopy,\n  /**\n   * Apply a post process to a texture\n   * @param postProcessName name of the fragment post process\n   * @param internalTexture the texture to encode\n   * @param scene the scene hosting the texture\n   * @param type type of the output texture. If not provided, use the one from internalTexture\n   * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\n   * @param format format of the output texture. If not provided, use the one from internalTexture\n   * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n   */\n  ApplyPostProcess,\n  /**\n   * Converts a number to half float\n   * @param value number to convert\n   * @returns converted number\n   */\n  ToHalfFloat,\n  /**\n   * Converts a half float to a number\n   * @param value half float to convert\n   * @returns converted half float\n   */\n  FromHalfFloat\n};","map":{"version":3,"mappings":"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","names":["Texture","RenderTargetTexture","PassPostProcess","PostProcess","CreateResizedCopy","texture","width","height","useBilinearMode","scene","getScene","engine","getEngine","rtt","name","noMipmap","_texture","type","samplingMode","wrapU","wrapV","uOffset","vOffset","uScale","vScale","uAng","vAng","wAng","coordinatesIndex","level","anisotropicFilteringLevel","isReady","CLAMP_ADDRESSMODE","passPostProcess","BILINEAR_SAMPLINGMODE","NEAREST_SAMPLINGMODE","externalTextureSamplerBinding","getEffect","executeWhenCompiled","onApply","effect","setTexture","internalTexture","renderTarget","postProcessManager","directRender","unBindFramebuffer","disposeFramebufferObjects","dispose","getInternalTexture","ApplyPostProcess","postProcessName","format","Promise","resolve","postProcess","undefined","encodedTexture","createRenderTargetTexture","generateDepthBuffer","generateMipMaps","generateStencilBuffer","_bindTexture","setFloat2","restoreDefaultFramebuffer","_releaseTexture","_swapAndDie","floatView","int32View","ToHalfFloat","value","Float32Array","Int32Array","buffer","x","bits","m","e","FromHalfFloat","s","f","Math","pow","NaN","Infinity","TextureTools"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/textureTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.getEffect().executeWhenCompiled(() => {\r\n        passPostProcess.onApply = function (effect) {\r\n            effect.setTexture(\"textureSampler\", texture);\r\n        };\r\n\r\n        const internalTexture = rtt.renderTarget;\r\n\r\n        if (internalTexture) {\r\n            scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n            engine.unBindFramebuffer(internalTexture);\r\n            rtt.disposeFramebufferObjects();\r\n            passPostProcess.dispose();\r\n\r\n            rtt.getInternalTexture()!.isReady = true;\r\n        }\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: internalTexture.width, height: internalTexture.height },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.getEffect().executeWhenCompiled(() => {\r\n            // PP Render Pass\r\n            postProcess.onApply = (effect) => {\r\n                effect._bindTexture(\"textureSampler\", internalTexture);\r\n                effect.setFloat2(\"scale\", 1, 1);\r\n            };\r\n            scene.postProcessManager.directRender([postProcess!], encodedTexture, true);\r\n\r\n            // Cleanup\r\n            engine.restoreDefaultFramebuffer();\r\n            engine._releaseTexture(internalTexture);\r\n            if (postProcess) {\r\n                postProcess.dispose();\r\n            }\r\n\r\n            // Internal Swap\r\n            encodedTexture._swapAndDie(internalTexture);\r\n\r\n            // Ready to get rolling again.\r\n            internalTexture.type = type!;\r\n            internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n            internalTexture.isReady = true;\r\n\r\n            resolve(internalTexture);\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}