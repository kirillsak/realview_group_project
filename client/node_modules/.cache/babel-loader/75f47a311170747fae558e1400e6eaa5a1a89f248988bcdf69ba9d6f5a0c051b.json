{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { SineEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { Curve3 } from \"../../Maths/math.path.js\";\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { setAndStartTimer } from \"../../Misc/timer.js\";\n/**\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\n * the input of the attached controllers.\n */\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\n  /**\n   * constructs a new teleportation system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._controllers = {};\n    this._snappedToPoint = false;\n    this._tmpRay = new Ray(new Vector3(), new Vector3());\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    /**\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\n     */\n    this.skipNextTeleportation = false;\n    /**\n     * Is movement backwards enabled\n     */\n    this.backwardsMovementEnabled = true;\n    /**\n     * Distance to travel when moving backwards\n     */\n    this.backwardsTeleportationDistance = 0.7;\n    /**\n     * The distance from the user to the inspection point in the direction of the controller\n     * A higher number will allow the user to move further\n     * defaults to 5 (meters, in xr units)\n     */\n    this.parabolicCheckRadius = 5;\n    /**\n     * Should the module support parabolic ray on top of direct ray\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\n     * Very helpful when moving between floors / different heights\n     */\n    this.parabolicRayEnabled = true;\n    /**\n     * The second type of ray - straight line.\n     * Should it be enabled or should the parabolic line be the only one.\n     */\n    this.straightRayEnabled = true;\n    /**\n     * How much rotation should be applied when rotating right and left\n     */\n    this.rotationAngle = Math.PI / 8;\n    /**\n     * This observable will notify when the target mesh position was updated.\n     * The picking info it provides contains the point to which the target mesh will move ()\n     */\n    this.onTargetMeshPositionUpdatedObservable = new Observable();\n    /**\n     * Is teleportation enabled. Can be used to allow rotation only.\n     */\n    this.teleportationEnabled = true;\n    this._rotationEnabled = true;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId] || this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness) {\n        // already attached\n        return;\n      }\n      this._controllers[xrController.uniqueId] = {\n        xrController,\n        teleportationState: {\n          forward: false,\n          backwards: false,\n          rotating: false,\n          currentRotation: 0,\n          baseRotation: 0\n        }\n      };\n      const controllerData = this._controllers[xrController.uniqueId];\n      // motion controller only available to gamepad-enabled input sources.\n      if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\n        // motion controller support\n        const initMotionController = () => {\n          if (xrController.motionController) {\n            const movementController = xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) || xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\n            if (!movementController || this._options.useMainComponentOnly) {\n              // use trigger to move on long press\n              const mainComponent = xrController.motionController.getMainComponent();\n              if (!mainComponent) {\n                return;\n              }\n              controllerData.teleportationComponent = mainComponent;\n              controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\n                if (!this.teleportationEnabled) {\n                  return;\n                }\n                // did \"pressed\" changed?\n                if (mainComponent.changes.pressed) {\n                  if (mainComponent.changes.pressed.current) {\n                    // simulate \"forward\" thumbstick push\n                    controllerData.teleportationState.forward = true;\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                    controllerData.teleportationState.currentRotation = 0;\n                    const timeToSelect = this._options.timeToTeleport || 3000;\n                    setAndStartTimer({\n                      timeout: timeToSelect,\n                      contextObservable: this._xrSessionManager.onXRFrameObservable,\n                      breakCondition: () => !mainComponent.pressed,\n                      onEnded: () => {\n                        if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                          this._teleportForward(xrController.uniqueId);\n                        }\n                      }\n                    });\n                  } else {\n                    controllerData.teleportationState.forward = false;\n                    this._currentTeleportationControllerId = \"\";\n                  }\n                }\n              });\n            } else {\n              controllerData.teleportationComponent = movementController;\n              // use thumbstick (or touchpad if thumbstick not available)\n              controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add(axesData => {\n                if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\n                  controllerData.teleportationState.backwards = false;\n                }\n                if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\n                  // teleport backwards\n                  // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\n                  if (!controllerData.teleportationState.backwards) {\n                    controllerData.teleportationState.backwards = true;\n                    // teleport backwards ONCE\n                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion);\n                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\n                    // get only the y rotation\n                    this._tmpVector.x = 0;\n                    this._tmpVector.z = 0;\n                    // get the quaternion\n                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\n                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\n                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\n                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\n                    this._tmpRay.origin.copyFrom(this._tmpVector);\n                    // This will prevent the user from \"falling\" to a lower platform!\n                    // TODO - should this be a flag? 'allow falling to lower platforms'?\n                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\n                    // Right handed system had here \"1\" instead of -1. This is unneeded.\n                    this._tmpRay.direction.set(0, -1, 0);\n                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, o => {\n                      return this._floorMeshes.indexOf(o) !== -1;\n                    });\n                    // pick must exist, but stay safe\n                    if (pick && pick.pickedPoint) {\n                      // Teleport the users feet to where they targeted. Ignore the Y axis.\n                      // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\n                      this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\n                      this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\n                    }\n                  }\n                }\n                if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\n                  controllerData.teleportationState.forward = true;\n                  this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n                  controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n                }\n                if (axesData.x) {\n                  if (!controllerData.teleportationState.forward) {\n                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\n                      // rotate in the right direction positive is right\n                      controllerData.teleportationState.rotating = true;\n                      const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\n                      Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n                    }\n                  } else {\n                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\n                      // set the rotation of the forward movement\n                      if (this.rotationEnabled) {\n                        setTimeout(() => {\n                          controllerData.teleportationState.currentRotation = Math.atan2(axesData.x, axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1));\n                        });\n                      } else {\n                        controllerData.teleportationState.currentRotation = 0;\n                      }\n                    }\n                  }\n                } else {\n                  controllerData.teleportationState.rotating = false;\n                }\n                if (axesData.x === 0 && axesData.y === 0) {\n                  if (controllerData.teleportationState.forward) {\n                    this._teleportForward(xrController.uniqueId);\n                  }\n                }\n              });\n            }\n          }\n        };\n        if (xrController.motionController) {\n          initMotionController();\n        } else {\n          xrController.onMotionControllerInitObservable.addOnce(() => {\n            initMotionController();\n          });\n        }\n      } else {\n        this._xrSessionManager.scene.onPointerObservable.add(pointerInfo => {\n          if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n            controllerData.teleportationState.forward = true;\n            this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\n            controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\n            controllerData.teleportationState.currentRotation = 0;\n            const timeToSelect = this._options.timeToTeleport || 3000;\n            setAndStartTimer({\n              timeout: timeToSelect,\n              contextObservable: this._xrSessionManager.onXRFrameObservable,\n              onEnded: () => {\n                if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\n                  this._teleportForward(xrController.uniqueId);\n                }\n              }\n            });\n          } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n            controllerData.teleportationState.forward = false;\n            this._currentTeleportationControllerId = \"\";\n          }\n        });\n      }\n    };\n    // create default mesh if not provided\n    if (!this._options.teleportationTargetMesh) {\n      this._createDefaultTargetMesh();\n    }\n    this._floorMeshes = this._options.floorMeshes || [];\n    this._snapToPositions = this._options.snapPositions || [];\n    this._setTargetMeshVisibility(false);\n  }\n  /**\n   * Is rotation enabled when moving forward?\n   * Disabling this feature will prevent the user from deciding the direction when teleporting\n   */\n  get rotationEnabled() {\n    return this._rotationEnabled;\n  }\n  /**\n   * Sets whether rotation is enabled or not\n   * @param enabled is rotation enabled when teleportation is shown\n   */\n  set rotationEnabled(enabled) {\n    this._rotationEnabled = enabled;\n    if (this._options.teleportationTargetMesh) {\n      const children = this._options.teleportationTargetMesh.getChildMeshes(false, node => node.name === \"rotationCone\");\n      if (children[0]) {\n        children[0].setEnabled(enabled);\n      }\n    }\n  }\n  /**\n   * Exposes the currently set teleportation target mesh.\n   */\n  get teleportationTargetMesh() {\n    return this._options.teleportationTargetMesh || null;\n  }\n  /**\n   * Get the snapPointsOnly flag\n   */\n  get snapPointsOnly() {\n    return !!this._options.snapPointsOnly;\n  }\n  /**\n   * Sets the snapPointsOnly flag\n   * @param snapToPoints should teleportation be exclusively to snap points\n   */\n  set snapPointsOnly(snapToPoints) {\n    this._options.snapPointsOnly = snapToPoints;\n  }\n  /**\n   * Add a new mesh to the floor meshes array\n   * @param mesh the mesh to use as floor mesh\n   */\n  addFloorMesh(mesh) {\n    this._floorMeshes.push(mesh);\n  }\n  /**\n   * Add a mesh to the list of meshes blocking the teleportation ray\n   * @param mesh The mesh to add to the teleportation-blocking meshes\n   */\n  addBlockerMesh(mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n    this._options.pickBlockerMeshes.push(mesh);\n  }\n  /**\n   * Add a new snap-to point to fix teleportation to this position\n   * @param newSnapPoint The new Snap-To point\n   */\n  addSnapPoint(newSnapPoint) {\n    this._snapToPositions.push(newSnapPoint);\n  }\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    // Safety reset\n    this._currentTeleportationControllerId = \"\";\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    return true;\n  }\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    this._setTargetMeshVisibility(false);\n    this._currentTeleportationControllerId = \"\";\n    this._controllers = {};\n    return true;\n  }\n  dispose() {\n    super.dispose();\n    this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\n  }\n  /**\n   * Remove a mesh from the floor meshes array\n   * @param mesh the mesh to remove\n   */\n  removeFloorMesh(mesh) {\n    const index = this._floorMeshes.indexOf(mesh);\n    if (index !== -1) {\n      this._floorMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Remove a mesh from the blocker meshes array\n   * @param mesh the mesh to remove\n   */\n  removeBlockerMesh(mesh) {\n    this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\n    const index = this._options.pickBlockerMeshes.indexOf(mesh);\n    if (index !== -1) {\n      this._options.pickBlockerMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Remove a mesh from the floor meshes array using its name\n   * @param name the mesh name to remove\n   */\n  removeFloorMeshByName(name) {\n    const mesh = this._xrSessionManager.scene.getMeshByName(name);\n    if (mesh) {\n      this.removeFloorMesh(mesh);\n    }\n  }\n  /**\n   * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\n   * @param snapPointToRemove the point (or a clone of it) to be removed from the array\n   * @returns was the point found and removed or not\n   */\n  removeSnapPoint(snapPointToRemove) {\n    // check if the object is in the array\n    let index = this._snapToPositions.indexOf(snapPointToRemove);\n    // if not found as an object, compare to the points\n    if (index === -1) {\n      for (let i = 0; i < this._snapToPositions.length; ++i) {\n        // equals? index is i, break the loop\n        if (this._snapToPositions[i].equals(snapPointToRemove)) {\n          index = i;\n          break;\n        }\n      }\n    }\n    // index is not -1? remove the object\n    if (index !== -1) {\n      this._snapToPositions.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * This function sets a selection feature that will be disabled when\n   * the forward ray is shown and will be reattached when hidden.\n   * This is used to remove the selection rays when moving.\n   * @param selectionFeature the feature to disable when forward movement is enabled\n   */\n  setSelectionFeature(selectionFeature) {\n    this._selectionFeature = selectionFeature;\n  }\n  _onXRFrame(_xrFrame) {\n    const frame = this._xrSessionManager.currentFrame;\n    const scene = this._xrSessionManager.scene;\n    if (!this.attach || !frame) {\n      return;\n    }\n    // render target if needed\n    const targetMesh = this._options.teleportationTargetMesh;\n    if (this._currentTeleportationControllerId) {\n      if (!targetMesh) {\n        return;\n      }\n      targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\n      const controllerData = this._controllers[this._currentTeleportationControllerId];\n      if (controllerData && controllerData.teleportationState.forward) {\n        // set the rotation\n        Quaternion.RotationYawPitchRollToRef(controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation, 0, 0, targetMesh.rotationQuaternion);\n        // set the ray and position\n        let hitPossible = false;\n        controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\n        if (this.straightRayEnabled) {\n          // first check if direct ray possible\n          // pick grounds that are LOWER only. upper will use parabolic path\n          const pick = scene.pickWithRay(this._tmpRay, o => {\n            // check for mesh-blockers\n            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n            const index = this._floorMeshes.indexOf(o);\n            if (index === -1) {\n              return false;\n            }\n            return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\n          });\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n            this._setTargetMeshPosition(pick);\n            this._setTargetMeshVisibility(true);\n            this._showParabolicPath(pick);\n          }\n        }\n        // straight ray is still the main ray, but disabling the straight line will force parabolic line.\n        if (this.parabolicRayEnabled && !hitPossible) {\n          // radius compensation according to pointer rotation around X\n          const xRotation = controllerData.xrController.pointer.rotationQuaternion.toEulerAngles().x;\n          const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\n          // check parabolic ray\n          const radius = this.parabolicCheckRadius * compensation;\n          this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\n          this._tmpVector.y = this._tmpRay.origin.y;\n          this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\n          this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\n          this._tmpRay.direction.normalize();\n          const pick = scene.pickWithRay(this._tmpRay, o => {\n            // check for mesh-blockers\n            if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\n              return true;\n            }\n            return this._floorMeshes.indexOf(o) !== -1;\n          });\n          if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\n            return;\n          } else if (pick && pick.pickedPoint) {\n            hitPossible = true;\n            this._setTargetMeshPosition(pick);\n            this._setTargetMeshVisibility(true);\n            this._showParabolicPath(pick);\n          }\n        }\n        // if needed, set visible:\n        this._setTargetMeshVisibility(hitPossible);\n      } else {\n        this._setTargetMeshVisibility(false);\n      }\n    } else {\n      this._setTargetMeshVisibility(false);\n    }\n  }\n  _createDefaultTargetMesh() {\n    // set defaults\n    this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    const teleportationTarget = CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, sceneToRenderTo);\n    teleportationTarget.isPickable = false;\n    if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\n      teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\n    } else {\n      const length = 512;\n      const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\n      dynamicTexture.hasAlpha = true;\n      const context = dynamicTexture.getContext();\n      const centerX = length / 2;\n      const centerY = length / 2;\n      const radius = 200;\n      context.beginPath();\n      context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n      context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\n      context.fill();\n      context.lineWidth = 10;\n      context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\n      context.stroke();\n      context.closePath();\n      dynamicTexture.update();\n      const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\n      teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n      teleportationTarget.material = teleportationCircleMaterial;\n    }\n    const torus = CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 20\n    }, sceneToRenderTo);\n    torus.isPickable = false;\n    torus.parent = teleportationTarget;\n    if (!this._options.defaultTargetMeshOptions.disableAnimation) {\n      const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n      const keys = [];\n      keys.push({\n        frame: 0,\n        value: 0\n      });\n      keys.push({\n        frame: 30,\n        value: 0.4\n      });\n      keys.push({\n        frame: 60,\n        value: 0\n      });\n      animationInnerCircle.setKeys(keys);\n      const easingFunction = new SineEase();\n      easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n      animationInnerCircle.setEasingFunction(easingFunction);\n      torus.animations = [];\n      torus.animations.push(animationInnerCircle);\n      sceneToRenderTo.beginAnimation(torus, 0, 60, true);\n    }\n    const cone = CreateCylinder(\"rotationCone\", {\n      diameterTop: 0,\n      tessellation: 4\n    }, sceneToRenderTo);\n    cone.isPickable = false;\n    cone.scaling.set(0.5, 0.12, 0.2);\n    cone.rotate(Axis.X, Math.PI / 2);\n    cone.position.z = 0.6;\n    cone.parent = torus;\n    if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\n      torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n      cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\n    } else {\n      const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\n      torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\n      if (torusConeMaterial.disableLighting) {\n        torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\n      } else {\n        torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\n      }\n      torusConeMaterial.alpha = 0.9;\n      torus.material = torusConeMaterial;\n      cone.material = torusConeMaterial;\n      this._teleportationRingMaterial = torusConeMaterial;\n    }\n    if (this._options.renderingGroupId !== undefined) {\n      teleportationTarget.renderingGroupId = this._options.renderingGroupId;\n      torus.renderingGroupId = this._options.renderingGroupId;\n      cone.renderingGroupId = this._options.renderingGroupId;\n    }\n    this._options.teleportationTargetMesh = teleportationTarget;\n    // hide the teleportation target mesh right after creating it.\n    this._setTargetMeshVisibility(false);\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.teleportationComponent) {\n      if (controllerData.onAxisChangedObserver) {\n        controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\n      }\n      if (controllerData.onButtonChangedObserver) {\n        controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\n      }\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n  _findClosestSnapPointWithRadius(realPosition, radius = this._options.snapToPositionRadius || 0.8) {\n    let closestPoint = null;\n    let closestDistance = Number.MAX_VALUE;\n    if (this._snapToPositions.length) {\n      const radiusSquared = radius * radius;\n      this._snapToPositions.forEach(position => {\n        const dist = Vector3.DistanceSquared(position, realPosition);\n        if (dist <= radiusSquared && dist < closestDistance) {\n          closestDistance = dist;\n          closestPoint = position;\n        }\n      });\n    }\n    return closestPoint;\n  }\n  _setTargetMeshPosition(pickInfo) {\n    const newPosition = pickInfo.pickedPoint;\n    if (!this._options.teleportationTargetMesh || !newPosition) {\n      return;\n    }\n    const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\n    this._snappedToPoint = !!snapPosition;\n    if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\n    } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\n      this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\n    }\n    this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\n    this._options.teleportationTargetMesh.position.y += 0.01;\n    this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\n  }\n  _setTargetMeshVisibility(visible) {\n    if (!this._options.teleportationTargetMesh) {\n      return;\n    }\n    if (this._options.teleportationTargetMesh.isVisible === visible) {\n      return;\n    }\n    this._options.teleportationTargetMesh.isVisible = visible;\n    this._options.teleportationTargetMesh.getChildren(undefined, false).forEach(m => {\n      m.isVisible = visible;\n    });\n    if (!visible) {\n      if (this._quadraticBezierCurve) {\n        this._quadraticBezierCurve.dispose();\n        this._quadraticBezierCurve = null;\n      }\n      if (this._selectionFeature) {\n        this._selectionFeature.attach();\n      }\n    } else {\n      if (this._selectionFeature) {\n        this._selectionFeature.detach();\n      }\n    }\n  }\n  _showParabolicPath(pickInfo) {\n    if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\n      return;\n    }\n    const sceneToRenderTo = this._options.useUtilityLayer ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene : this._xrSessionManager.scene;\n    const controllerData = this._controllers[this._currentTeleportationControllerId];\n    const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray.origin, pickInfo.pickedPoint, 25);\n    if (!this._options.generateRayPathMesh) {\n      this._quadraticBezierCurve = CreateLines(\"teleportation path line\", {\n        points: quadraticBezierVectors.getPoints(),\n        instance: this._quadraticBezierCurve,\n        updatable: true\n      }, sceneToRenderTo);\n    } else {\n      this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\n    }\n    this._quadraticBezierCurve.isPickable = false;\n    if (this._options.renderingGroupId !== undefined) {\n      this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\n    }\n  }\n  _teleportForward(controllerId) {\n    const controllerData = this._controllers[controllerId];\n    if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\n      return;\n    }\n    controllerData.teleportationState.forward = false;\n    this._currentTeleportationControllerId = \"\";\n    if (this.snapPointsOnly && !this._snappedToPoint) {\n      return;\n    }\n    if (this.skipNextTeleportation) {\n      this.skipNextTeleportation = false;\n      return;\n    }\n    // do the movement forward here\n    if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\n      const height = this._options.xrInput.xrCamera.realWorldHeight;\n      this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n      this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\n      this._options.xrInput.xrCamera.position.y += height;\n      Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(this._options.xrInput.xrCamera.rotationQuaternion, this._options.xrInput.xrCamera.rotationQuaternion);\n      this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRMotionControllerTeleportation.Name = WebXRFeatureName.TELEPORTATION;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRMotionControllerTeleportation.Version = 1;\nWebXRFeaturesManager.AddWebXRFeature(WebXRMotionControllerTeleportation.Name, (xrSessionManager, options) => {\n  return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\n}, WebXRMotionControllerTeleportation.Version, true);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","WebXRControllerComponent","Vector3","Quaternion","Ray","DynamicTexture","CreateCylinder","SineEase","EasingFunction","Animation","Axis","StandardMaterial","CreateGround","CreateTorus","Curve3","CreateLines","WebXRAbstractFeature","Color3","UtilityLayerRenderer","PointerEventTypes","setAndStartTimer","WebXRMotionControllerTeleportation","constructor","_xrSessionManager","_options","Math","PI","xrController","_controllers","uniqueId","forceHandedness","inputSource","handedness","teleportationState","forward","backwards","rotating","currentRotation","baseRotation","controllerData","targetRayMode","gamepad","initMotionController","motionController","movementController","getComponentOfType","THUMBSTICK_TYPE","TOUCHPAD_TYPE","useMainComponentOnly","mainComponent","getMainComponent","teleportationComponent","onButtonChangedObserver","onButtonStateChangedObservable","add","teleportationEnabled","changes","pressed","current","_currentTeleportationControllerId","xrInput","xrCamera","rotationQuaternion","toEulerAngles","y","timeToSelect","timeToTeleport","timeout","contextObservable","onXRFrameObservable","breakCondition","onEnded","_teleportForward","onAxisChangedObserver","onAxisValueChangedObservable","axesData","backwardsMovementEnabled","snapPointsOnly","_tmpQuaternion","copyFrom","toEulerAnglesToRef","_tmpVector","x","z","FromEulerVectorToRef","set","backwardsTeleportationDistance","scene","useRightHandedSystem","rotateByQuaternionToRef","addInPlace","position","_tmpRay","origin","length","realWorldHeight","direction","pick","pickWithRay","o","_floorMeshes","indexOf","pickedPoint","abs","rotation","rotationAngle","FromEulerAngles","multiplyToRef","rotationEnabled","setTimeout","atan2","onMotionControllerInitObservable","addOnce","onPointerObservable","pointerInfo","type","POINTERDOWN","POINTERUP","teleportationTargetMesh","_createDefaultTargetMesh","floorMeshes","_snapToPositions","snapPositions","_setTargetMeshVisibility","_rotationEnabled","enabled","children","getChildMeshes","node","name","setEnabled","snapToPoints","addFloorMesh","mesh","push","addBlockerMesh","pickBlockerMeshes","addSnapPoint","newSnapPoint","attach","controllers","forEach","_attachController","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","detach","Object","keys","controllerId","dispose","removeFloorMesh","index","splice","removeBlockerMesh","removeFloorMeshByName","getMeshByName","removeSnapPoint","snapPointToRemove","i","equals","setSelectionFeature","selectionFeature","_selectionFeature","_onXRFrame","_xrFrame","frame","currentFrame","targetMesh","RotationYawPitchRollToRef","hitPossible","getWorldPointerRayToRef","straightRayEnabled","absolutePosition","globalPosition","pickedMesh","_setTargetMeshPosition","_showParabolicPath","parabolicRayEnabled","xRotation","pointer","compensation","radius","parabolicCheckRadius","addToRef","scale","subtractToRef","normalize","defaultTargetMeshOptions","sceneToRenderTo","useUtilityLayer","customUtilityLayerScene","DefaultUtilityLayer","utilityLayerScene","teleportationTarget","width","height","subdivisions","isPickable","teleportationCircleMaterial","material","dynamicTexture","hasAlpha","context","getContext","centerX","centerY","beginPath","arc","fillStyle","teleportationFillColor","fill","lineWidth","strokeStyle","teleportationBorderColor","stroke","closePath","update","diffuseTexture","torus","diameter","thickness","tessellation","parent","disableAnimation","animationInnerCircle","ANIMATIONTYPE_FLOAT","ANIMATIONLOOPMODE_CYCLE","value","setKeys","easingFunction","setEasingMode","EASINGMODE_EASEINOUT","setEasingFunction","animations","beginAnimation","cone","diameterTop","scaling","rotate","X","torusArrowMaterial","torusConeMaterial","disableLighting","emissiveColor","diffuseColor","alpha","_teleportationRingMaterial","renderingGroupId","undefined","xrControllerUniqueId","remove","_findClosestSnapPointWithRadius","realPosition","snapToPositionRadius","closestPoint","closestDistance","Number","MAX_VALUE","radiusSquared","dist","DistanceSquared","pickInfo","newPosition","snapPosition","_snappedToPoint","onTargetMeshPositionUpdatedObservable","notifyObservers","visible","isVisible","getChildren","m","_quadraticBezierCurve","quadraticBezierVectors","CreateQuadraticBezier","ray","generateRayPathMesh","points","getPoints","instance","updatable","skipNextTeleportation","onBeforeCameraTeleport","onAfterCameraTeleport","TELEPORTATION","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRControllerTeleportation.ts"],"sourcesContent":["import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport type { IWebXRMotionControllerAxesValue } from \"../motionController/webXRControllerComponent\";\r\nimport { WebXRControllerComponent } from \"../motionController/webXRControllerComponent\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Material } from \"../../Materials/material\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { SineEase, EasingFunction } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Curve3 } from \"../../Maths/math.path\";\r\nimport { CreateLines } from \"../../Meshes/Builders/linesBuilder\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { UtilityLayerRenderer } from \"../../Rendering/utilityLayerRenderer\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { setAndStartTimer } from \"../../Misc/timer\";\r\nimport type { LinesMesh } from \"../../Meshes/linesMesh\";\r\n\r\n/**\r\n * The options container for the teleportation module\r\n */\r\nexport interface IWebXRTeleportationOptions {\r\n    /**\r\n     * if provided, this scene will be used to render meshes.\r\n     */\r\n    customUtilityLayerScene?: Scene;\r\n    /**\r\n     * Values to configure the default target mesh\r\n     */\r\n    defaultTargetMeshOptions?: {\r\n        /**\r\n         * Fill color of the teleportation area\r\n         */\r\n        teleportationFillColor?: string;\r\n        /**\r\n         * Border color for the teleportation area\r\n         */\r\n        teleportationBorderColor?: string;\r\n        /**\r\n         * Disable the mesh's animation sequence\r\n         */\r\n        disableAnimation?: boolean;\r\n        /**\r\n         * Disable lighting on the material or the ring and arrow\r\n         */\r\n        disableLighting?: boolean;\r\n        /**\r\n         * Override the default material of the torus and arrow\r\n         */\r\n        torusArrowMaterial?: Material;\r\n        /**\r\n         * Override the default material of the Landing Zone\r\n         */\r\n        teleportationCircleMaterial?: Material;\r\n    };\r\n    /**\r\n     * A list of meshes to use as floor meshes.\r\n     * Meshes can be added and removed after initializing the feature using the\r\n     * addFloorMesh and removeFloorMesh functions\r\n     * If empty, rotation will still work\r\n     */\r\n    floorMeshes?: AbstractMesh[];\r\n    /**\r\n     *  use this rendering group id for the meshes (optional)\r\n     */\r\n    renderingGroupId?: number;\r\n    /**\r\n     * Should teleportation move only to snap points\r\n     */\r\n    snapPointsOnly?: boolean;\r\n    /**\r\n     * An array of points to which the teleportation will snap to.\r\n     * If the teleportation ray is in the proximity of one of those points, it will be corrected to this point.\r\n     */\r\n    snapPositions?: Vector3[];\r\n    /**\r\n     * How close should the teleportation ray be in order to snap to position.\r\n     * Default to 0.8 units (meters)\r\n     */\r\n    snapToPositionRadius?: number;\r\n    /**\r\n     * Provide your own teleportation mesh instead of babylon's wonderful doughnut.\r\n     * If you want to support rotation, make sure your mesh has a direction indicator.\r\n     *\r\n     * When left untouched, the default mesh will be initialized.\r\n     */\r\n    teleportationTargetMesh?: AbstractMesh;\r\n    /**\r\n     * If main component is used (no thumbstick), how long should the \"long press\" take before teleport\r\n     */\r\n    timeToTeleport?: number;\r\n    /**\r\n     * Disable using the thumbstick and use the main component (usually trigger) on long press.\r\n     * This will be automatically true if the controller doesn't have a thumbstick or touchpad.\r\n     */\r\n    useMainComponentOnly?: boolean;\r\n    /**\r\n     * Should meshes created here be added to a utility layer or the main scene\r\n     */\r\n    useUtilityLayer?: boolean;\r\n    /**\r\n     * Babylon XR Input class for controller\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Meshes that the teleportation ray cannot go through\r\n     */\r\n    pickBlockerMeshes?: AbstractMesh[];\r\n\r\n    /**\r\n     * Should teleport work only on a specific hand?\r\n     */\r\n    forceHandedness?: XRHandedness;\r\n\r\n    /**\r\n     * If provided, this function will be used to generate the ray mesh instead of the lines mesh being used per default\r\n     */\r\n    generateRayPathMesh?: (points: Vector3[], pickingInfo: PickingInfo) => AbstractMesh;\r\n}\r\n\r\n/**\r\n * This is a teleportation feature to be used with WebXR-enabled motion controllers.\r\n * When enabled and attached, the feature will allow a user to move around and rotate in the scene using\r\n * the input of the attached controllers.\r\n */\r\nexport class WebXRMotionControllerTeleportation extends WebXRAbstractFeature {\r\n    private _controllers: {\r\n        [controllerUniqueId: string]: {\r\n            xrController: WebXRInputSource;\r\n            teleportationComponent?: WebXRControllerComponent;\r\n            teleportationState: {\r\n                forward: boolean;\r\n                backwards: boolean;\r\n                currentRotation: number;\r\n                baseRotation: number;\r\n                rotating: boolean;\r\n            };\r\n            onAxisChangedObserver?: Nullable<Observer<IWebXRMotionControllerAxesValue>>;\r\n            onButtonChangedObserver?: Nullable<Observer<WebXRControllerComponent>>;\r\n        };\r\n    } = {};\r\n    private _currentTeleportationControllerId: string;\r\n    private _floorMeshes: AbstractMesh[];\r\n    private _quadraticBezierCurve: Nullable<AbstractMesh>;\r\n    private _selectionFeature: Nullable<IWebXRFeature>;\r\n    private _snapToPositions: Vector3[];\r\n    private _snappedToPoint: boolean = false;\r\n    private _teleportationRingMaterial?: StandardMaterial;\r\n    private _tmpRay = new Ray(new Vector3(), new Vector3());\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Skip the next teleportation. This can be controlled by the user to prevent the user from teleportation\r\n     * to sections that are not yet \"unlocked\", but should still show the teleportation mesh.\r\n     */\r\n    public skipNextTeleportation = false;\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.TELEPORTATION;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Is movement backwards enabled\r\n     */\r\n    public backwardsMovementEnabled = true;\r\n    /**\r\n     * Distance to travel when moving backwards\r\n     */\r\n    public backwardsTeleportationDistance: number = 0.7;\r\n    /**\r\n     * The distance from the user to the inspection point in the direction of the controller\r\n     * A higher number will allow the user to move further\r\n     * defaults to 5 (meters, in xr units)\r\n     */\r\n    public parabolicCheckRadius: number = 5;\r\n    /**\r\n     * Should the module support parabolic ray on top of direct ray\r\n     * If enabled, the user will be able to point \"at the sky\" and move according to predefined radius distance\r\n     * Very helpful when moving between floors / different heights\r\n     */\r\n    public parabolicRayEnabled: boolean = true;\r\n\r\n    /**\r\n     * The second type of ray - straight line.\r\n     * Should it be enabled or should the parabolic line be the only one.\r\n     */\r\n    public straightRayEnabled: boolean = true;\r\n    /**\r\n     * How much rotation should be applied when rotating right and left\r\n     */\r\n    public rotationAngle: number = Math.PI / 8;\r\n\r\n    /**\r\n     * This observable will notify when the target mesh position was updated.\r\n     * The picking info it provides contains the point to which the target mesh will move ()\r\n     */\r\n    public onTargetMeshPositionUpdatedObservable: Observable<PickingInfo> = new Observable();\r\n\r\n    /**\r\n     * Is teleportation enabled. Can be used to allow rotation only.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _rotationEnabled: boolean = true;\r\n\r\n    /**\r\n     * Is rotation enabled when moving forward?\r\n     * Disabling this feature will prevent the user from deciding the direction when teleporting\r\n     */\r\n    public get rotationEnabled(): boolean {\r\n        return this._rotationEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets whether rotation is enabled or not\r\n     * @param enabled is rotation enabled when teleportation is shown\r\n     */\r\n    public set rotationEnabled(enabled: boolean) {\r\n        this._rotationEnabled = enabled;\r\n\r\n        if (this._options.teleportationTargetMesh) {\r\n            const children = this._options.teleportationTargetMesh.getChildMeshes(false, (node) => node.name === \"rotationCone\");\r\n            if (children[0]) {\r\n                children[0].setEnabled(enabled);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exposes the currently set teleportation target mesh.\r\n     */\r\n    public get teleportationTargetMesh(): Nullable<AbstractMesh> {\r\n        return this._options.teleportationTargetMesh || null;\r\n    }\r\n\r\n    /**\r\n     * constructs a new teleportation system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRTeleportationOptions) {\r\n        super(_xrSessionManager);\r\n        // create default mesh if not provided\r\n        if (!this._options.teleportationTargetMesh) {\r\n            this._createDefaultTargetMesh();\r\n        }\r\n\r\n        this._floorMeshes = this._options.floorMeshes || [];\r\n        this._snapToPositions = this._options.snapPositions || [];\r\n\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    /**\r\n     * Get the snapPointsOnly flag\r\n     */\r\n    public get snapPointsOnly(): boolean {\r\n        return !!this._options.snapPointsOnly;\r\n    }\r\n\r\n    /**\r\n     * Sets the snapPointsOnly flag\r\n     * @param snapToPoints should teleportation be exclusively to snap points\r\n     */\r\n    public set snapPointsOnly(snapToPoints: boolean) {\r\n        this._options.snapPointsOnly = snapToPoints;\r\n    }\r\n\r\n    /**\r\n     * Add a new mesh to the floor meshes array\r\n     * @param mesh the mesh to use as floor mesh\r\n     */\r\n    public addFloorMesh(mesh: AbstractMesh) {\r\n        this._floorMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to the list of meshes blocking the teleportation ray\r\n     * @param mesh The mesh to add to the teleportation-blocking meshes\r\n     */\r\n    public addBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        this._options.pickBlockerMeshes.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * Add a new snap-to point to fix teleportation to this position\r\n     * @param newSnapPoint The new Snap-To point\r\n     */\r\n    public addSnapPoint(newSnapPoint: Vector3) {\r\n        this._snapToPositions.push(newSnapPoint);\r\n    }\r\n\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Safety reset\r\n        this._currentTeleportationControllerId = \"\";\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        this._setTargetMeshVisibility(false);\r\n        this._currentTeleportationControllerId = \"\";\r\n        this._controllers = {};\r\n\r\n        return true;\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.dispose(false, true);\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeFloorMesh(mesh: AbstractMesh) {\r\n        const index = this._floorMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._floorMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the blocker meshes array\r\n     * @param mesh the mesh to remove\r\n     */\r\n    public removeBlockerMesh(mesh: AbstractMesh) {\r\n        this._options.pickBlockerMeshes = this._options.pickBlockerMeshes || [];\r\n        const index = this._options.pickBlockerMeshes.indexOf(mesh);\r\n        if (index !== -1) {\r\n            this._options.pickBlockerMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the floor meshes array using its name\r\n     * @param name the mesh name to remove\r\n     */\r\n    public removeFloorMeshByName(name: string) {\r\n        const mesh = this._xrSessionManager.scene.getMeshByName(name);\r\n        if (mesh) {\r\n            this.removeFloorMesh(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will iterate through the array, searching for this point or equal to it. It will then remove it from the snap-to array\r\n     * @param snapPointToRemove the point (or a clone of it) to be removed from the array\r\n     * @returns was the point found and removed or not\r\n     */\r\n    public removeSnapPoint(snapPointToRemove: Vector3): boolean {\r\n        // check if the object is in the array\r\n        let index = this._snapToPositions.indexOf(snapPointToRemove);\r\n        // if not found as an object, compare to the points\r\n        if (index === -1) {\r\n            for (let i = 0; i < this._snapToPositions.length; ++i) {\r\n                // equals? index is i, break the loop\r\n                if (this._snapToPositions[i].equals(snapPointToRemove)) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // index is not -1? remove the object\r\n        if (index !== -1) {\r\n            this._snapToPositions.splice(index, 1);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * This function sets a selection feature that will be disabled when\r\n     * the forward ray is shown and will be reattached when hidden.\r\n     * This is used to remove the selection rays when moving.\r\n     * @param selectionFeature the feature to disable when forward movement is enabled\r\n     */\r\n    public setSelectionFeature(selectionFeature: Nullable<IWebXRFeature>) {\r\n        this._selectionFeature = selectionFeature;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        const frame = this._xrSessionManager.currentFrame;\r\n        const scene = this._xrSessionManager.scene;\r\n        if (!this.attach || !frame) {\r\n            return;\r\n        }\r\n\r\n        // render target if needed\r\n        const targetMesh = this._options.teleportationTargetMesh;\r\n        if (this._currentTeleportationControllerId) {\r\n            if (!targetMesh) {\r\n                return;\r\n            }\r\n            targetMesh.rotationQuaternion = targetMesh.rotationQuaternion || new Quaternion();\r\n            const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n            if (controllerData && controllerData.teleportationState.forward) {\r\n                // set the rotation\r\n                Quaternion.RotationYawPitchRollToRef(\r\n                    controllerData.teleportationState.currentRotation + controllerData.teleportationState.baseRotation,\r\n                    0,\r\n                    0,\r\n                    targetMesh.rotationQuaternion\r\n                );\r\n                // set the ray and position\r\n\r\n                let hitPossible = false;\r\n                controllerData.xrController.getWorldPointerRayToRef(this._tmpRay);\r\n                if (this.straightRayEnabled) {\r\n                    // first check if direct ray possible\r\n                    // pick grounds that are LOWER only. upper will use parabolic path\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        const index = this._floorMeshes.indexOf(o);\r\n                        if (index === -1) {\r\n                            return false;\r\n                        }\r\n                        return this._floorMeshes[index].absolutePosition.y < this._options.xrInput.xrCamera.globalPosition.y;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n                // straight ray is still the main ray, but disabling the straight line will force parabolic line.\r\n                if (this.parabolicRayEnabled && !hitPossible) {\r\n                    // radius compensation according to pointer rotation around X\r\n                    const xRotation = controllerData.xrController.pointer.rotationQuaternion!.toEulerAngles().x;\r\n                    const compensation = 1 + (Math.PI / 2 - Math.abs(xRotation));\r\n                    // check parabolic ray\r\n                    const radius = this.parabolicCheckRadius * compensation;\r\n                    this._tmpRay.origin.addToRef(this._tmpRay.direction.scale(radius * 2), this._tmpVector);\r\n                    this._tmpVector.y = this._tmpRay.origin.y;\r\n                    this._tmpRay.origin.addInPlace(this._tmpRay.direction.scale(radius));\r\n                    this._tmpVector.subtractToRef(this._tmpRay.origin, this._tmpRay.direction);\r\n                    this._tmpRay.direction.normalize();\r\n\r\n                    const pick = scene.pickWithRay(this._tmpRay, (o) => {\r\n                        // check for mesh-blockers\r\n                        if (this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(o) !== -1) {\r\n                            return true;\r\n                        }\r\n                        return this._floorMeshes.indexOf(o) !== -1;\r\n                    });\r\n                    if (pick && pick.pickedMesh && this._options.pickBlockerMeshes && this._options.pickBlockerMeshes.indexOf(pick.pickedMesh) !== -1) {\r\n                        return;\r\n                    } else if (pick && pick.pickedPoint) {\r\n                        hitPossible = true;\r\n                        this._setTargetMeshPosition(pick);\r\n                        this._setTargetMeshVisibility(true);\r\n                        this._showParabolicPath(pick);\r\n                    }\r\n                }\r\n\r\n                // if needed, set visible:\r\n                this._setTargetMeshVisibility(hitPossible);\r\n            } else {\r\n                this._setTargetMeshVisibility(false);\r\n            }\r\n        } else {\r\n            this._setTargetMeshVisibility(false);\r\n        }\r\n    }\r\n\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId] || (this._options.forceHandedness && xrController.inputSource.handedness !== this._options.forceHandedness)) {\r\n            // already attached\r\n            return;\r\n        }\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            teleportationState: {\r\n                forward: false,\r\n                backwards: false,\r\n                rotating: false,\r\n                currentRotation: 0,\r\n                baseRotation: 0,\r\n            },\r\n        };\r\n        const controllerData = this._controllers[xrController.uniqueId];\r\n        // motion controller only available to gamepad-enabled input sources.\r\n        if (controllerData.xrController.inputSource.targetRayMode === \"tracked-pointer\" && controllerData.xrController.inputSource.gamepad) {\r\n            // motion controller support\r\n            const initMotionController = () => {\r\n                if (xrController.motionController) {\r\n                    const movementController =\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.THUMBSTICK_TYPE) ||\r\n                        xrController.motionController.getComponentOfType(WebXRControllerComponent.TOUCHPAD_TYPE);\r\n                    if (!movementController || this._options.useMainComponentOnly) {\r\n                        // use trigger to move on long press\r\n                        const mainComponent = xrController.motionController.getMainComponent();\r\n                        if (!mainComponent) {\r\n                            return;\r\n                        }\r\n                        controllerData.teleportationComponent = mainComponent;\r\n                        controllerData.onButtonChangedObserver = mainComponent.onButtonStateChangedObservable.add(() => {\r\n                            if (!this.teleportationEnabled) {\r\n                                return;\r\n                            }\r\n                            // did \"pressed\" changed?\r\n                            if (mainComponent.changes.pressed) {\r\n                                if (mainComponent.changes.pressed.current) {\r\n                                    // simulate \"forward\" thumbstick push\r\n                                    controllerData.teleportationState.forward = true;\r\n                                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                                    controllerData.teleportationState.currentRotation = 0;\r\n                                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                                    setAndStartTimer({\r\n                                        timeout: timeToSelect,\r\n                                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                                        breakCondition: () => !mainComponent.pressed,\r\n                                        onEnded: () => {\r\n                                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                                this._teleportForward(xrController.uniqueId);\r\n                                            }\r\n                                        },\r\n                                    });\r\n                                } else {\r\n                                    controllerData.teleportationState.forward = false;\r\n                                    this._currentTeleportationControllerId = \"\";\r\n                                }\r\n                            }\r\n                        });\r\n                    } else {\r\n                        controllerData.teleportationComponent = movementController;\r\n                        // use thumbstick (or touchpad if thumbstick not available)\r\n                        controllerData.onAxisChangedObserver = movementController.onAxisValueChangedObservable.add((axesData) => {\r\n                            if (axesData.y <= 0.7 && controllerData.teleportationState.backwards) {\r\n                                controllerData.teleportationState.backwards = false;\r\n                            }\r\n                            if (axesData.y > 0.7 && !controllerData.teleportationState.forward && this.backwardsMovementEnabled && !this.snapPointsOnly) {\r\n                                // teleport backwards\r\n\r\n                                // General gist: Go Back N units, cast a ray towards the floor. If collided, move.\r\n                                if (!controllerData.teleportationState.backwards) {\r\n                                    controllerData.teleportationState.backwards = true;\r\n                                    // teleport backwards ONCE\r\n                                    this._tmpQuaternion.copyFrom(this._options.xrInput.xrCamera.rotationQuaternion!);\r\n                                    this._tmpQuaternion.toEulerAnglesToRef(this._tmpVector);\r\n                                    // get only the y rotation\r\n                                    this._tmpVector.x = 0;\r\n                                    this._tmpVector.z = 0;\r\n                                    // get the quaternion\r\n                                    Quaternion.FromEulerVectorToRef(this._tmpVector, this._tmpQuaternion);\r\n                                    this._tmpVector.set(0, 0, this.backwardsTeleportationDistance * (this._xrSessionManager.scene.useRightHandedSystem ? 1.0 : -1.0));\r\n                                    this._tmpVector.rotateByQuaternionToRef(this._tmpQuaternion, this._tmpVector);\r\n                                    this._tmpVector.addInPlace(this._options.xrInput.xrCamera.position);\r\n                                    this._tmpRay.origin.copyFrom(this._tmpVector);\r\n                                    // This will prevent the user from \"falling\" to a lower platform!\r\n                                    // TODO - should this be a flag? 'allow falling to lower platforms'?\r\n                                    this._tmpRay.length = this._options.xrInput.xrCamera.realWorldHeight + 0.1;\r\n                                    // Right handed system had here \"1\" instead of -1. This is unneeded.\r\n                                    this._tmpRay.direction.set(0, -1, 0);\r\n                                    const pick = this._xrSessionManager.scene.pickWithRay(this._tmpRay, (o) => {\r\n                                        return this._floorMeshes.indexOf(o) !== -1;\r\n                                    });\r\n\r\n                                    // pick must exist, but stay safe\r\n                                    if (pick && pick.pickedPoint) {\r\n                                        // Teleport the users feet to where they targeted. Ignore the Y axis.\r\n                                        // If the \"falling to lower platforms\" feature is implemented the Y axis should be set here as well\r\n                                        this._options.xrInput.xrCamera.position.x = pick.pickedPoint.x;\r\n                                        this._options.xrInput.xrCamera.position.z = pick.pickedPoint.z;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (axesData.y < -0.7 && !this._currentTeleportationControllerId && !controllerData.teleportationState.rotating && this.teleportationEnabled) {\r\n                                controllerData.teleportationState.forward = true;\r\n                                this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                                controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                            }\r\n                            if (axesData.x) {\r\n                                if (!controllerData.teleportationState.forward) {\r\n                                    if (!controllerData.teleportationState.rotating && Math.abs(axesData.x) > 0.7) {\r\n                                        // rotate in the right direction positive is right\r\n                                        controllerData.teleportationState.rotating = true;\r\n                                        const rotation = this.rotationAngle * (axesData.x > 0 ? 1 : -1) * (this._xrSessionManager.scene.useRightHandedSystem ? -1 : 1);\r\n                                        Quaternion.FromEulerAngles(0, rotation, 0).multiplyToRef(\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion,\r\n                                            this._options.xrInput.xrCamera.rotationQuaternion\r\n                                        );\r\n                                    }\r\n                                } else {\r\n                                    if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId) {\r\n                                        // set the rotation of the forward movement\r\n                                        if (this.rotationEnabled) {\r\n                                            setTimeout(() => {\r\n                                                controllerData.teleportationState.currentRotation = Math.atan2(\r\n                                                    axesData.x,\r\n                                                    axesData.y * (this._xrSessionManager.scene.useRightHandedSystem ? 1 : -1)\r\n                                                );\r\n                                            });\r\n                                        } else {\r\n                                            controllerData.teleportationState.currentRotation = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                controllerData.teleportationState.rotating = false;\r\n                            }\r\n\r\n                            if (axesData.x === 0 && axesData.y === 0) {\r\n                                if (controllerData.teleportationState.forward) {\r\n                                    this._teleportForward(xrController.uniqueId);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            if (xrController.motionController) {\r\n                initMotionController();\r\n            } else {\r\n                xrController.onMotionControllerInitObservable.addOnce(() => {\r\n                    initMotionController();\r\n                });\r\n            }\r\n        } else {\r\n            this._xrSessionManager.scene.onPointerObservable.add((pointerInfo) => {\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    controllerData.teleportationState.forward = true;\r\n                    this._currentTeleportationControllerId = controllerData.xrController.uniqueId;\r\n                    controllerData.teleportationState.baseRotation = this._options.xrInput.xrCamera.rotationQuaternion.toEulerAngles().y;\r\n                    controllerData.teleportationState.currentRotation = 0;\r\n                    const timeToSelect = this._options.timeToTeleport || 3000;\r\n                    setAndStartTimer({\r\n                        timeout: timeToSelect,\r\n                        contextObservable: this._xrSessionManager.onXRFrameObservable,\r\n                        onEnded: () => {\r\n                            if (this._currentTeleportationControllerId === controllerData.xrController.uniqueId && controllerData.teleportationState.forward) {\r\n                                this._teleportForward(xrController.uniqueId);\r\n                            }\r\n                        },\r\n                    });\r\n                } else if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    controllerData.teleportationState.forward = false;\r\n                    this._currentTeleportationControllerId = \"\";\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    private _createDefaultTargetMesh() {\r\n        // set defaults\r\n        this._options.defaultTargetMeshOptions = this._options.defaultTargetMeshOptions || {};\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n        const teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, sceneToRenderTo);\r\n        teleportationTarget.isPickable = false;\r\n\r\n        if (this._options.defaultTargetMeshOptions.teleportationCircleMaterial) {\r\n            teleportationTarget.material = this._options.defaultTargetMeshOptions.teleportationCircleMaterial;\r\n        } else {\r\n            const length = 512;\r\n            const dynamicTexture = new DynamicTexture(\"teleportationPlaneDynamicTexture\", length, sceneToRenderTo, true);\r\n            dynamicTexture.hasAlpha = true;\r\n            const context = dynamicTexture.getContext();\r\n            const centerX = length / 2;\r\n            const centerY = length / 2;\r\n            const radius = 200;\r\n            context.beginPath();\r\n            context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n            context.fillStyle = this._options.defaultTargetMeshOptions.teleportationFillColor || \"#444444\";\r\n            context.fill();\r\n            context.lineWidth = 10;\r\n            context.strokeStyle = this._options.defaultTargetMeshOptions.teleportationBorderColor || \"#FFFFFF\";\r\n            context.stroke();\r\n            context.closePath();\r\n            dynamicTexture.update();\r\n            const teleportationCircleMaterial = new StandardMaterial(\"teleportationPlaneMaterial\", sceneToRenderTo);\r\n            teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n            teleportationTarget.material = teleportationCircleMaterial;\r\n        }\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 20,\r\n            },\r\n            sceneToRenderTo\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = teleportationTarget;\r\n        if (!this._options.defaultTargetMeshOptions.disableAnimation) {\r\n            const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n            const keys = [];\r\n            keys.push({\r\n                frame: 0,\r\n                value: 0,\r\n            });\r\n            keys.push({\r\n                frame: 30,\r\n                value: 0.4,\r\n            });\r\n            keys.push({\r\n                frame: 60,\r\n                value: 0,\r\n            });\r\n            animationInnerCircle.setKeys(keys);\r\n            const easingFunction = new SineEase();\r\n            easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n            animationInnerCircle.setEasingFunction(easingFunction);\r\n            torus.animations = [];\r\n            torus.animations.push(animationInnerCircle);\r\n            sceneToRenderTo.beginAnimation(torus, 0, 60, true);\r\n        }\r\n\r\n        const cone = CreateCylinder(\"rotationCone\", { diameterTop: 0, tessellation: 4 }, sceneToRenderTo);\r\n        cone.isPickable = false;\r\n        cone.scaling.set(0.5, 0.12, 0.2);\r\n\r\n        cone.rotate(Axis.X, Math.PI / 2);\r\n\r\n        cone.position.z = 0.6;\r\n        cone.parent = torus;\r\n\r\n        if (this._options.defaultTargetMeshOptions.torusArrowMaterial) {\r\n            torus.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n            cone.material = this._options.defaultTargetMeshOptions.torusArrowMaterial;\r\n        } else {\r\n            const torusConeMaterial = new StandardMaterial(\"torusConsMat\", sceneToRenderTo);\r\n            torusConeMaterial.disableLighting = !!this._options.defaultTargetMeshOptions.disableLighting;\r\n            if (torusConeMaterial.disableLighting) {\r\n                torusConeMaterial.emissiveColor = new Color3(0.3, 0.3, 1.0);\r\n            } else {\r\n                torusConeMaterial.diffuseColor = new Color3(0.3, 0.3, 1.0);\r\n            }\r\n            torusConeMaterial.alpha = 0.9;\r\n            torus.material = torusConeMaterial;\r\n            cone.material = torusConeMaterial;\r\n            this._teleportationRingMaterial = torusConeMaterial;\r\n        }\r\n\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            teleportationTarget.renderingGroupId = this._options.renderingGroupId;\r\n            torus.renderingGroupId = this._options.renderingGroupId;\r\n            cone.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n\r\n        this._options.teleportationTargetMesh = teleportationTarget;\r\n        // hide the teleportation target mesh right after creating it.\r\n        this._setTargetMeshVisibility(false);\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.teleportationComponent) {\r\n            if (controllerData.onAxisChangedObserver) {\r\n                controllerData.teleportationComponent.onAxisValueChangedObservable.remove(controllerData.onAxisChangedObserver);\r\n            }\r\n            if (controllerData.onButtonChangedObserver) {\r\n                controllerData.teleportationComponent.onButtonStateChangedObservable.remove(controllerData.onButtonChangedObserver);\r\n            }\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n\r\n    private _findClosestSnapPointWithRadius(realPosition: Vector3, radius: number = this._options.snapToPositionRadius || 0.8) {\r\n        let closestPoint: Nullable<Vector3> = null;\r\n        let closestDistance = Number.MAX_VALUE;\r\n        if (this._snapToPositions.length) {\r\n            const radiusSquared = radius * radius;\r\n            this._snapToPositions.forEach((position) => {\r\n                const dist = Vector3.DistanceSquared(position, realPosition);\r\n                if (dist <= radiusSquared && dist < closestDistance) {\r\n                    closestDistance = dist;\r\n                    closestPoint = position;\r\n                }\r\n            });\r\n        }\r\n        return closestPoint;\r\n    }\r\n\r\n    private _setTargetMeshPosition(pickInfo: PickingInfo) {\r\n        const newPosition = pickInfo.pickedPoint;\r\n        if (!this._options.teleportationTargetMesh || !newPosition) {\r\n            return;\r\n        }\r\n        const snapPosition = this._findClosestSnapPointWithRadius(newPosition);\r\n        this._snappedToPoint = !!snapPosition;\r\n        if (this.snapPointsOnly && !this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(1.0, 0.3, 0.3);\r\n        } else if (this.snapPointsOnly && this._snappedToPoint && this._teleportationRingMaterial) {\r\n            this._teleportationRingMaterial.diffuseColor.set(0.3, 0.3, 1.0);\r\n        }\r\n        this._options.teleportationTargetMesh.position.copyFrom(snapPosition || newPosition);\r\n        this._options.teleportationTargetMesh.position.y += 0.01;\r\n        this.onTargetMeshPositionUpdatedObservable.notifyObservers(pickInfo);\r\n    }\r\n\r\n    private _setTargetMeshVisibility(visible: boolean) {\r\n        if (!this._options.teleportationTargetMesh) {\r\n            return;\r\n        }\r\n        if (this._options.teleportationTargetMesh.isVisible === visible) {\r\n            return;\r\n        }\r\n        this._options.teleportationTargetMesh.isVisible = visible;\r\n        this._options.teleportationTargetMesh.getChildren(undefined, false).forEach((m) => {\r\n            (<any>m).isVisible = visible;\r\n        });\r\n\r\n        if (!visible) {\r\n            if (this._quadraticBezierCurve) {\r\n                this._quadraticBezierCurve.dispose();\r\n                this._quadraticBezierCurve = null;\r\n            }\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.attach();\r\n            }\r\n        } else {\r\n            if (this._selectionFeature) {\r\n                this._selectionFeature.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _showParabolicPath(pickInfo: PickingInfo) {\r\n        if (!pickInfo.pickedPoint || !this._currentTeleportationControllerId) {\r\n            return;\r\n        }\r\n\r\n        const sceneToRenderTo = this._options.useUtilityLayer\r\n            ? this._options.customUtilityLayerScene || UtilityLayerRenderer.DefaultUtilityLayer.utilityLayerScene\r\n            : this._xrSessionManager.scene;\r\n\r\n        const controllerData = this._controllers[this._currentTeleportationControllerId];\r\n\r\n        const quadraticBezierVectors = Curve3.CreateQuadraticBezier(controllerData.xrController.pointer.absolutePosition, pickInfo.ray!.origin, pickInfo.pickedPoint, 25);\r\n        if (!this._options.generateRayPathMesh) {\r\n            this._quadraticBezierCurve = CreateLines(\r\n                \"teleportation path line\",\r\n                { points: quadraticBezierVectors.getPoints(), instance: this._quadraticBezierCurve as LinesMesh, updatable: true },\r\n                sceneToRenderTo\r\n            );\r\n        } else {\r\n            this._quadraticBezierCurve = this._options.generateRayPathMesh(quadraticBezierVectors.getPoints(), pickInfo);\r\n        }\r\n        this._quadraticBezierCurve.isPickable = false;\r\n        if (this._options.renderingGroupId !== undefined) {\r\n            this._quadraticBezierCurve.renderingGroupId = this._options.renderingGroupId;\r\n        }\r\n    }\r\n\r\n    private _teleportForward(controllerId: string) {\r\n        const controllerData = this._controllers[controllerId];\r\n        if (!controllerData || !controllerData.teleportationState.forward || !this.teleportationEnabled) {\r\n            return;\r\n        }\r\n        controllerData.teleportationState.forward = false;\r\n        this._currentTeleportationControllerId = \"\";\r\n        if (this.snapPointsOnly && !this._snappedToPoint) {\r\n            return;\r\n        }\r\n\r\n        if (this.skipNextTeleportation) {\r\n            this.skipNextTeleportation = false;\r\n            return;\r\n        }\r\n        // do the movement forward here\r\n        if (this._options.teleportationTargetMesh && this._options.teleportationTargetMesh.isVisible) {\r\n            const height = this._options.xrInput.xrCamera.realWorldHeight;\r\n            this._options.xrInput.xrCamera.onBeforeCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n            this._options.xrInput.xrCamera.position.copyFrom(this._options.teleportationTargetMesh.position);\r\n            this._options.xrInput.xrCamera.position.y += height;\r\n            Quaternion.FromEulerAngles(0, controllerData.teleportationState.currentRotation - (this._xrSessionManager.scene.useRightHandedSystem ? Math.PI : 0), 0).multiplyToRef(\r\n                this._options.xrInput.xrCamera.rotationQuaternion,\r\n                this._options.xrInput.xrCamera.rotationQuaternion\r\n            );\r\n            this._options.xrInput.xrCamera.onAfterCameraTeleport.notifyObservers(this._options.xrInput.xrCamera.position);\r\n        }\r\n    }\r\n}\r\n\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRMotionControllerTeleportation.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRMotionControllerTeleportation(xrSessionManager, options);\r\n    },\r\n    WebXRMotionControllerTeleportation.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}