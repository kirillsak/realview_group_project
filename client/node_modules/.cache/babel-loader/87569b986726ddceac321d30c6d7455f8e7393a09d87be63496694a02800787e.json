{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines a sound that can be played in the application.\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\n */\nexport class Sound {\n  /**\n   * Create a sound and attach it to a scene\n   * @param name Name of your sound\n   * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\n   * @param scene defines the scene the sound belongs to\n   * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\n   * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\n   */\n  constructor(name, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {\n    var _a, _b, _c, _d, _e;\n    /**\n     * Does the sound autoplay once loaded.\n     */\n    this.autoplay = false;\n    this._loop = false;\n    /**\n     * Does the sound use a custom attenuation curve to simulate the falloff\n     * happening when the source gets further away from the camera.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\n     */\n    this.useCustomAttenuation = false;\n    /**\n     * Is this sound currently played.\n     */\n    this.isPlaying = false;\n    /**\n     * Is this sound currently paused.\n     */\n    this.isPaused = false;\n    /**\n     * Define the reference distance the sound should be heard perfectly.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.refDistance = 1;\n    /**\n     * Define the roll off factor of spatial sounds.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.rolloffFactor = 1;\n    /**\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.maxDistance = 100;\n    /**\n     * Define the distance attenuation model the sound will follow.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    this.distanceModel = \"linear\";\n    /**\n     * Gets or sets an object used to store user defined information for the sound.\n     */\n    this.metadata = null;\n    /**\n     * Observable event when the current playing sound finishes.\n     */\n    this.onEndedObservable = new Observable();\n    this._spatialSound = false;\n    this._panningModel = \"equalpower\";\n    this._playbackRate = 1;\n    this._streaming = false;\n    this._startTime = 0;\n    this._currentTime = 0;\n    this._position = Vector3.Zero();\n    this._localDirection = new Vector3(1, 0, 0);\n    this._volume = 1;\n    this._isReadyToPlay = false;\n    this._isDirectional = false;\n    // Used if you'd like to create a directional sound.\n    // If not set, the sound will be omnidirectional\n    this._coneInnerAngle = 360;\n    this._coneOuterAngle = 360;\n    this._coneOuterGain = 0;\n    this._isOutputConnected = false;\n    this._urlType = \"Unknown\";\n    this.name = name;\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this._scene = scene;\n    Sound._SceneComponentInitialization(scene);\n    this._readyToPlayCallback = readyToPlayCallback;\n    // Default custom attenuation function is a linear attenuation\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {\n      if (currentDistance < maxDistance) {\n        return currentVolume * (1 - currentDistance / maxDistance);\n      } else {\n        return 0;\n      }\n    };\n    if (options) {\n      this.autoplay = options.autoplay || false;\n      this._loop = options.loop || false;\n      // if volume === 0, we need another way to check this option\n      if (options.volume !== undefined) {\n        this._volume = options.volume;\n      }\n      this._spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;\n      this.rolloffFactor = options.rolloffFactor || 1;\n      this.refDistance = options.refDistance || 1;\n      this.distanceModel = options.distanceModel || \"linear\";\n      this._playbackRate = options.playbackRate || 1;\n      this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;\n      this._length = options.length;\n      this._offset = options.offset;\n    }\n    if (((_e = Engine.audioEngine) === null || _e === void 0 ? void 0 : _e.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      this._soundGain = Engine.audioEngine.audioContext.createGain();\n      this._soundGain.gain.value = this._volume;\n      this._inputAudioNode = this._soundGain;\n      this._outputAudioNode = this._soundGain;\n      if (this._spatialSound) {\n        this._createSpatialParameters();\n      }\n      this._scene.mainSoundTrack.addSound(this);\n      let validParameter = true;\n      // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n      if (urlOrArrayBuffer) {\n        try {\n          if (typeof urlOrArrayBuffer === \"string\") {\n            this._urlType = \"String\";\n          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n            this._urlType = \"ArrayBuffer\";\n          } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\n            this._urlType = \"MediaElement\";\n          } else if (urlOrArrayBuffer instanceof MediaStream) {\n            this._urlType = \"MediaStream\";\n          } else if (urlOrArrayBuffer instanceof AudioBuffer) {\n            this._urlType = \"AudioBuffer\";\n          } else if (Array.isArray(urlOrArrayBuffer)) {\n            this._urlType = \"Array\";\n          }\n          let urls = [];\n          let codecSupportedFound = false;\n          switch (this._urlType) {\n            case \"MediaElement\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n              break;\n            case \"MediaStream\":\n              this._streaming = true;\n              this._isReadyToPlay = true;\n              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\n              if (this.autoplay) {\n                this.play(0, this._offset, this._length);\n              }\n              if (this._readyToPlayCallback) {\n                this._readyToPlayCallback();\n              }\n              break;\n            case \"ArrayBuffer\":\n              if (urlOrArrayBuffer.byteLength > 0) {\n                codecSupportedFound = true;\n                this._soundLoaded(urlOrArrayBuffer);\n              }\n              break;\n            case \"AudioBuffer\":\n              this._audioBufferLoaded(urlOrArrayBuffer);\n              break;\n            case \"String\":\n              urls.push(urlOrArrayBuffer);\n            // eslint-disable-next-line no-fallthrough\n            case \"Array\":\n              if (urls.length === 0) {\n                urls = urlOrArrayBuffer;\n              }\n              // If we found a supported format, we load it immediately and stop the loop\n              for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(\".wav\", url.length - 4) !== -1 || url.indexOf(\".m4a\", url.length - 4) !== -1 || url.indexOf(\".mp4\", url.length - 4) !== -1 || url.indexOf(\"blob:\") !== -1;\n                if (codecSupportedFound) {\n                  // Loading sound\n                  if (!this._streaming) {\n                    this._scene._loadFile(url, data => {\n                      this._soundLoaded(data);\n                    }, undefined, true, true, exception => {\n                      if (exception) {\n                        Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\n                      }\n                      Logger.Error(\"Sound creation aborted.\");\n                      this._scene.mainSoundTrack.removeSound(this);\n                    });\n                  }\n                  // Streaming sound using HTML5 Audio tag\n                  else {\n                    this._htmlAudioElement = new Audio(url);\n                    this._htmlAudioElement.controls = false;\n                    this._htmlAudioElement.loop = this.loop;\n                    Tools.SetCorsBehavior(url, this._htmlAudioElement);\n                    this._htmlAudioElement.preload = \"auto\";\n                    this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\n                      this._isReadyToPlay = true;\n                      if (this.autoplay) {\n                        this.play(0, this._offset, this._length);\n                      }\n                      if (this._readyToPlayCallback) {\n                        this._readyToPlayCallback();\n                      }\n                    });\n                    document.body.appendChild(this._htmlAudioElement);\n                    this._htmlAudioElement.load();\n                  }\n                  break;\n                }\n              }\n              break;\n            default:\n              validParameter = false;\n              break;\n          }\n          if (!validParameter) {\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n          } else {\n            if (!codecSupportedFound) {\n              this._isReadyToPlay = true;\n              // Simulating a ready to play event to avoid breaking code path\n              if (this._readyToPlayCallback) {\n                setTimeout(() => {\n                  if (this._readyToPlayCallback) {\n                    this._readyToPlayCallback();\n                  }\n                }, 1000);\n              }\n            }\n          }\n        } catch (ex) {\n          Logger.Error(\"Unexpected error. Sound creation aborted.\");\n          this._scene.mainSoundTrack.removeSound(this);\n        }\n      }\n    } else {\n      // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n      this._scene.mainSoundTrack.addSound(this);\n      if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {\n        Logger.Error(\"Web Audio is not supported by your browser.\");\n        Engine.audioEngine.WarnedWebAudioUnsupported = true;\n      }\n      // Simulating a ready to play event to avoid breaking code for non web audio browsers\n      if (this._readyToPlayCallback) {\n        setTimeout(() => {\n          if (this._readyToPlayCallback) {\n            this._readyToPlayCallback();\n          }\n        }, 1000);\n      }\n    }\n  }\n  /**\n   * Does the sound loop after it finishes playing once.\n   */\n  get loop() {\n    return this._loop;\n  }\n  set loop(value) {\n    if (value === this._loop) {\n      return;\n    }\n    this._loop = value;\n    this.updateOptions({\n      loop: value\n    });\n  }\n  /**\n   * Gets the current time for the sound.\n   */\n  get currentTime() {\n    var _a;\n    if (this._htmlAudioElement) {\n      return this._htmlAudioElement.currentTime;\n    }\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && (this.isPlaying || this.isPaused)) {\n      // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\n      // to get the actual current time.\n      const timeSinceLastStart = this.isPaused ? 0 : Engine.audioEngine.audioContext.currentTime - this._startTime;\n      return this._currentTime + timeSinceLastStart;\n    }\n    return 0;\n  }\n  /**\n   * Does this sound enables spatial sound.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  get spatialSound() {\n    return this._spatialSound;\n  }\n  /**\n   * Does this sound enables spatial sound.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  set spatialSound(newValue) {\n    var _a;\n    this._spatialSound = newValue;\n    if (this._spatialSound && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      this._createSpatialParameters();\n    }\n  }\n  /**\n   * Release the sound and its associated resources\n   */\n  dispose() {\n    var _a;\n    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {\n      if (this.isPlaying) {\n        this.stop();\n      }\n      this._isReadyToPlay = false;\n      if (this.soundTrackId === -1) {\n        this._scene.mainSoundTrack.removeSound(this);\n      } else if (this._scene.soundTracks) {\n        this._scene.soundTracks[this.soundTrackId].removeSound(this);\n      }\n      if (this._soundGain) {\n        this._soundGain.disconnect();\n        this._soundGain = null;\n      }\n      if (this._soundPanner) {\n        this._soundPanner.disconnect();\n        this._soundPanner = null;\n      }\n      if (this._soundSource) {\n        this._soundSource.disconnect();\n        this._soundSource = null;\n      }\n      this._audioBuffer = null;\n      if (this._htmlAudioElement) {\n        this._htmlAudioElement.pause();\n        this._htmlAudioElement.src = \"\";\n        document.body.removeChild(this._htmlAudioElement);\n      }\n      if (this._streamingSource) {\n        this._streamingSource.disconnect();\n      }\n      if (this._connectedTransformNode && this._registerFunc) {\n        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n        this._connectedTransformNode = null;\n      }\n    }\n  }\n  /**\n   * Gets if the sounds is ready to be played or not.\n   * @returns true if ready, otherwise false\n   */\n  isReady() {\n    return this._isReadyToPlay;\n  }\n  /**\n   * Get the current class name.\n   * @returns current class name\n   */\n  getClassName() {\n    return \"Sound\";\n  }\n  _audioBufferLoaded(buffer) {\n    var _a;\n    if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      return;\n    }\n    this._audioBuffer = buffer;\n    this._isReadyToPlay = true;\n    if (this.autoplay) {\n      this.play(0, this._offset, this._length);\n    }\n    if (this._readyToPlayCallback) {\n      this._readyToPlayCallback();\n    }\n  }\n  _soundLoaded(audioData) {\n    var _a;\n    if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      return;\n    }\n    Engine.audioEngine.audioContext.decodeAudioData(audioData, buffer => {\n      this._audioBufferLoaded(buffer);\n    }, err => {\n      Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\n    });\n  }\n  /**\n   * Sets the data of the sound from an audiobuffer\n   * @param audioBuffer The audioBuffer containing the data\n   */\n  setAudioBuffer(audioBuffer) {\n    var _a;\n    if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {\n      this._audioBuffer = audioBuffer;\n      this._isReadyToPlay = true;\n    }\n  }\n  /**\n   * Updates the current sounds options such as maxdistance, loop...\n   * @param options A JSON object containing values named as the object properties\n   */\n  updateOptions(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    if (options) {\n      this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;\n      this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;\n      this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;\n      this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;\n      this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;\n      this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;\n      this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;\n      this._length = (_h = options.length) !== null && _h !== void 0 ? _h : undefined;\n      this._setOffset((_j = options.offset) !== null && _j !== void 0 ? _j : undefined);\n      this.setVolume((_k = options.volume) !== null && _k !== void 0 ? _k : this._volume);\n      this._updateSpatialParameters();\n      if (this.isPlaying) {\n        if (this._streaming && this._htmlAudioElement) {\n          this._htmlAudioElement.playbackRate = this._playbackRate;\n          if (this._htmlAudioElement.loop !== this.loop) {\n            this._htmlAudioElement.loop = this.loop;\n          }\n        } else {\n          if (this._soundSource) {\n            this._soundSource.playbackRate.value = this._playbackRate;\n            if (this._soundSource.loop !== this.loop) {\n              this._soundSource.loop = this.loop;\n            }\n            if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\n              this._soundSource.loopStart = this._offset;\n            }\n            if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\n              this._soundSource.loopEnd = (this._offset | 0) + this._length;\n            }\n          }\n        }\n      }\n    }\n  }\n  _createSpatialParameters() {\n    var _a, _b;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {\n      if (this._scene.headphone) {\n        this._panningModel = \"HRTF\";\n      }\n      this._soundPanner = (_b = this._soundPanner) !== null && _b !== void 0 ? _b : Engine.audioEngine.audioContext.createPanner();\n      if (this._soundPanner && this._outputAudioNode) {\n        this._updateSpatialParameters();\n        this._soundPanner.connect(this._outputAudioNode);\n        this._inputAudioNode = this._soundPanner;\n      }\n    }\n  }\n  _updateSpatialParameters() {\n    if (this._spatialSound && this._soundPanner) {\n      if (this.useCustomAttenuation) {\n        // Tricks to disable in a way embedded Web Audio attenuation\n        this._soundPanner.distanceModel = \"linear\";\n        this._soundPanner.maxDistance = Number.MAX_VALUE;\n        this._soundPanner.refDistance = 1;\n        this._soundPanner.rolloffFactor = 1;\n        this._soundPanner.panningModel = this._panningModel;\n      } else {\n        this._soundPanner.distanceModel = this.distanceModel;\n        this._soundPanner.maxDistance = this.maxDistance;\n        this._soundPanner.refDistance = this.refDistance;\n        this._soundPanner.rolloffFactor = this.rolloffFactor;\n        this._soundPanner.panningModel = this._panningModel;\n      }\n    }\n  }\n  /**\n   * Switch the panning model to HRTF:\n   * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  switchPanningModelToHRTF() {\n    this._panningModel = \"HRTF\";\n    this._switchPanningModel();\n  }\n  /**\n   * Switch the panning model to Equal Power:\n   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n   */\n  switchPanningModelToEqualPower() {\n    this._panningModel = \"equalpower\";\n    this._switchPanningModel();\n  }\n  _switchPanningModel() {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n      this._soundPanner.panningModel = this._panningModel;\n    }\n  }\n  /**\n   * Connect this sound to a sound track audio node like gain...\n   * @param soundTrackAudioNode the sound track audio node to connect to\n   */\n  connectToSoundTrackAudioNode(soundTrackAudioNode) {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {\n      if (this._isOutputConnected) {\n        this._outputAudioNode.disconnect();\n      }\n      this._outputAudioNode.connect(soundTrackAudioNode);\n      this._isOutputConnected = true;\n    }\n  }\n  /**\n   * Transform this sound into a directional source\n   * @param coneInnerAngle Size of the inner cone in degree\n   * @param coneOuterAngle Size of the outer cone in degree\n   * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\n   */\n  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    if (coneOuterAngle < coneInnerAngle) {\n      Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n      return;\n    }\n    this._coneInnerAngle = coneInnerAngle;\n    this._coneOuterAngle = coneOuterAngle;\n    this._coneOuterGain = coneOuterGain;\n    this._isDirectional = true;\n    if (this.isPlaying && this.loop) {\n      this.stop();\n      this.play(0, this._offset, this._length);\n    }\n  }\n  /**\n   * Gets or sets the inner angle for the directional cone.\n   */\n  get directionalConeInnerAngle() {\n    return this._coneInnerAngle;\n  }\n  /**\n   * Gets or sets the inner angle for the directional cone.\n   */\n  set directionalConeInnerAngle(value) {\n    var _a;\n    if (value != this._coneInnerAngle) {\n      if (this._coneOuterAngle < value) {\n        Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n        return;\n      }\n      this._coneInnerAngle = value;\n      if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n        this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n      }\n    }\n  }\n  /**\n   * Gets or sets the outer angle for the directional cone.\n   */\n  get directionalConeOuterAngle() {\n    return this._coneOuterAngle;\n  }\n  /**\n   * Gets or sets the outer angle for the directional cone.\n   */\n  set directionalConeOuterAngle(value) {\n    var _a;\n    if (value != this._coneOuterAngle) {\n      if (value < this._coneInnerAngle) {\n        Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n        return;\n      }\n      this._coneOuterAngle = value;\n      if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {\n        this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n      }\n    }\n  }\n  /**\n   * Sets the position of the emitter if spatial sound is enabled\n   * @param newPosition Defines the new position\n   */\n  setPosition(newPosition) {\n    var _a;\n    if (newPosition.equals(this._position)) {\n      return;\n    }\n    this._position.copyFrom(newPosition);\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n      this._soundPanner.positionX.value = this._position.x;\n      this._soundPanner.positionY.value = this._position.y;\n      this._soundPanner.positionZ.value = this._position.z;\n    }\n  }\n  /**\n   * Sets the local direction of the emitter if spatial sound is enabled\n   * @param newLocalDirection Defines the new local direction\n   */\n  setLocalDirectionToMesh(newLocalDirection) {\n    var _a;\n    this._localDirection = newLocalDirection;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {\n      this._updateDirection();\n    }\n  }\n  _updateDirection() {\n    if (!this._connectedTransformNode || !this._soundPanner) {\n      return;\n    }\n    const mat = this._connectedTransformNode.getWorldMatrix();\n    const direction = Vector3.TransformNormal(this._localDirection, mat);\n    direction.normalize();\n    this._soundPanner.orientationX.value = direction.x;\n    this._soundPanner.orientationY.value = direction.y;\n    this._soundPanner.orientationZ.value = direction.z;\n  }\n  /** @internal */\n  updateDistanceFromListener() {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\n      const distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n    }\n  }\n  /**\n   * Sets a new custom attenuation function for the sound.\n   * @param callback Defines the function used for the attenuation\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\n   */\n  setAttenuationFunction(callback) {\n    this._customAttenuationFunction = callback;\n  }\n  /**\n   * Play the sound\n   * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\n   * @param offset (optional) Start the sound at a specific time in seconds\n   * @param length (optional) Sound duration (in seconds)\n   */\n  play(time, offset, length) {\n    var _a, _b, _c, _d;\n    if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {\n      try {\n        let startTime = time ? ((_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.currentTime) + time : (_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime;\n        if (!this._soundSource || !this._streamingSource) {\n          if (this._spatialSound && this._soundPanner) {\n            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\n              this._soundPanner.positionX.value = this._position.x;\n              this._soundPanner.positionY.value = this._position.y;\n              this._soundPanner.positionZ.value = this._position.z;\n            }\n            if (this._isDirectional) {\n              this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n              this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n              this._soundPanner.coneOuterGain = this._coneOuterGain;\n              if (this._connectedTransformNode) {\n                this._updateDirection();\n              } else {\n                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n              }\n            }\n          }\n        }\n        if (this._streaming) {\n          if (!this._streamingSource) {\n            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n            this._htmlAudioElement.onended = () => {\n              this._onended();\n            };\n            this._htmlAudioElement.playbackRate = this._playbackRate;\n          }\n          this._streamingSource.disconnect();\n          if (this._inputAudioNode) {\n            this._streamingSource.connect(this._inputAudioNode);\n          }\n          if (this._htmlAudioElement) {\n            // required to manage properly the new suspended default state of Chrome\n            // When the option 'streaming: true' is used, we need first to wait for\n            // the audio engine to be unlocked by a user gesture before trying to play\n            // an HTML Audio element\n            const tryToPlay = () => {\n              var _a, _b;\n              if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.unlocked) {\n                const playPromise = this._htmlAudioElement.play();\n                // In browsers that don’t yet support this functionality,\n                // playPromise won’t be defined.\n                if (playPromise !== undefined) {\n                  playPromise.catch(() => {\n                    var _a, _b;\n                    // Automatic playback failed.\n                    // Waiting for the audio engine to be unlocked by user click on unmute\n                    (_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.lock();\n                    if (this.loop || this.autoplay) {\n                      (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.onAudioUnlockedObservable.addOnce(() => {\n                        tryToPlay();\n                      });\n                    }\n                  });\n                }\n              } else {\n                if (this.loop || this.autoplay) {\n                  (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.onAudioUnlockedObservable.addOnce(() => {\n                    tryToPlay();\n                  });\n                }\n              }\n            };\n            tryToPlay();\n          }\n        } else {\n          const tryToPlay = () => {\n            var _a, _b, _c, _d;\n            if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) {\n              length = length || this._length;\n              if (offset !== undefined) {\n                this._setOffset(offset);\n              }\n              if (this._soundSource) {\n                const oldSource = this._soundSource;\n                oldSource.onended = () => {\n                  oldSource.disconnect();\n                };\n              }\n              this._soundSource = (_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.createBufferSource();\n              if (this._soundSource && this._inputAudioNode) {\n                this._soundSource.buffer = this._audioBuffer;\n                this._soundSource.connect(this._inputAudioNode);\n                this._soundSource.loop = this.loop;\n                if (offset !== undefined) {\n                  this._soundSource.loopStart = offset;\n                }\n                if (length !== undefined) {\n                  this._soundSource.loopEnd = (offset | 0) + length;\n                }\n                this._soundSource.playbackRate.value = this._playbackRate;\n                this._soundSource.onended = () => {\n                  this._onended();\n                };\n                startTime = time ? ((_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime) + time : Engine.audioEngine.audioContext.currentTime;\n                const actualOffset = ((this.isPaused ? this.currentTime : 0) + ((_d = this._offset) !== null && _d !== void 0 ? _d : 0)) % this._soundSource.buffer.duration;\n                this._soundSource.start(startTime, actualOffset, this.loop ? undefined : length);\n              }\n            }\n          };\n          if (((_d = Engine.audioEngine) === null || _d === void 0 ? void 0 : _d.audioContext.state) === \"suspended\") {\n            // Wait a bit for FF as context seems late to be ready.\n            setTimeout(() => {\n              var _a;\n              if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext.state) === \"suspended\") {\n                // Automatic playback failed.\n                // Waiting for the audio engine to be unlocked by user click on unmute\n                Engine.audioEngine.lock();\n                if (this.loop || this.autoplay) {\n                  Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\n                    tryToPlay();\n                  });\n                }\n              } else {\n                tryToPlay();\n              }\n            }, 500);\n          } else {\n            tryToPlay();\n          }\n        }\n        this._startTime = startTime;\n        this.isPlaying = true;\n        this.isPaused = false;\n      } catch (ex) {\n        Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n      }\n    }\n  }\n  _onended() {\n    this.isPlaying = false;\n    if (this.onended) {\n      this.onended();\n    }\n    this.onEndedObservable.notifyObservers(this);\n  }\n  /**\n   * Stop the sound\n   * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\n   */\n  stop(time) {\n    var _a;\n    if (this.isPlaying) {\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n          // Test needed for Firefox or it will generate an Invalid State Error\n          if (this._htmlAudioElement.currentTime > 0) {\n            this._htmlAudioElement.currentTime = 0;\n          }\n        } else {\n          this._streamingSource.disconnect();\n        }\n        this.isPlaying = false;\n      } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {\n        const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : undefined;\n        this._soundSource.onended = () => {\n          this.isPlaying = false;\n          this.isPaused = false;\n          this._startTime = 0;\n          this._currentTime = 0;\n          this._soundSource.onended = () => void 0;\n        };\n        this._stopSoundSource(stopTime);\n      }\n    } else if (this.isPaused) {\n      this.isPaused = false;\n      this._startTime = 0;\n      this._currentTime = 0;\n    }\n  }\n  /**\n   * Put the sound in pause\n   */\n  pause() {\n    var _a;\n    if (this.isPlaying) {\n      if (this._streaming) {\n        if (this._htmlAudioElement) {\n          this._htmlAudioElement.pause();\n        } else {\n          this._streamingSource.disconnect();\n        }\n        this.isPlaying = false;\n        this.isPaused = true;\n      } else if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) {\n        this._stopSoundSource();\n        this.isPlaying = false;\n        this.isPaused = true;\n        this._currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\n      }\n    }\n  }\n  /**\n   * Sets a dedicated volume for this sounds\n   * @param newVolume Define the new volume of the sound\n   * @param time Define time for gradual change to new volume\n   */\n  setVolume(newVolume, time) {\n    var _a;\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._soundGain) {\n      if (time && Engine.audioEngine.audioContext) {\n        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\n        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\n        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\n      } else {\n        this._soundGain.gain.value = newVolume;\n      }\n    }\n    this._volume = newVolume;\n  }\n  /**\n   * Set the sound play back rate\n   * @param newPlaybackRate Define the playback rate the sound should be played at\n   */\n  setPlaybackRate(newPlaybackRate) {\n    this._playbackRate = newPlaybackRate;\n    if (this.isPlaying) {\n      if (this._streaming && this._htmlAudioElement) {\n        this._htmlAudioElement.playbackRate = this._playbackRate;\n      } else if (this._soundSource) {\n        this._soundSource.playbackRate.value = this._playbackRate;\n      }\n    }\n  }\n  /**\n   * Gets the sound play back rate.\n   * @returns the  play back rate of the sound\n   */\n  getPlaybackRate() {\n    return this._playbackRate;\n  }\n  /**\n   * Gets the volume of the sound.\n   * @returns the volume of the sound\n   */\n  getVolume() {\n    return this._volume;\n  }\n  /**\n   * Attach the sound to a dedicated mesh\n   * @param transformNode The transform node to connect the sound with\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\n   */\n  attachToMesh(transformNode) {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n      this._registerFunc = null;\n    }\n    this._connectedTransformNode = transformNode;\n    if (!this._spatialSound) {\n      this._spatialSound = true;\n      this._createSpatialParameters();\n      if (this.isPlaying && this.loop) {\n        this.stop();\n        this.play(0, this._offset, this._length);\n      }\n    }\n    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n    this._registerFunc = transformNode => this._onRegisterAfterWorldMatrixUpdate(transformNode);\n    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n  }\n  /**\n   * Detach the sound from the previously attached mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\n   */\n  detachFromMesh() {\n    if (this._connectedTransformNode && this._registerFunc) {\n      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n      this._registerFunc = null;\n      this._connectedTransformNode = null;\n    }\n  }\n  _onRegisterAfterWorldMatrixUpdate(node) {\n    var _a;\n    if (!node.getBoundingInfo) {\n      this.setPosition(node.absolutePosition);\n    } else {\n      const mesh = node;\n      const boundingInfo = mesh.getBoundingInfo();\n      this.setPosition(boundingInfo.boundingSphere.centerWorld);\n    }\n    if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {\n      this._updateDirection();\n    }\n  }\n  /**\n   * Clone the current sound in the scene.\n   * @returns the new sound clone\n   */\n  clone() {\n    if (!this._streaming) {\n      const setBufferAndRun = () => {\n        if (this._isReadyToPlay) {\n          clonedSound._audioBuffer = this.getAudioBuffer();\n          clonedSound._isReadyToPlay = true;\n          if (clonedSound.autoplay) {\n            clonedSound.play(0, this._offset, this._length);\n          }\n        } else {\n          setTimeout(setBufferAndRun, 300);\n        }\n      };\n      const currentOptions = {\n        autoplay: this.autoplay,\n        loop: this.loop,\n        volume: this._volume,\n        spatialSound: this._spatialSound,\n        maxDistance: this.maxDistance,\n        useCustomAttenuation: this.useCustomAttenuation,\n        rolloffFactor: this.rolloffFactor,\n        refDistance: this.refDistance,\n        distanceModel: this.distanceModel\n      };\n      const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n      if (this.useCustomAttenuation) {\n        clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n      }\n      clonedSound.setPosition(this._position);\n      clonedSound.setPlaybackRate(this._playbackRate);\n      setBufferAndRun();\n      return clonedSound;\n    }\n    // Can't clone a streaming sound\n    else {\n      return null;\n    }\n  }\n  /**\n   * Gets the current underlying audio buffer containing the data\n   * @returns the audio buffer\n   */\n  getAudioBuffer() {\n    return this._audioBuffer;\n  }\n  /**\n   * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\n   * @returns the source node\n   */\n  getSoundSource() {\n    return this._soundSource;\n  }\n  /**\n   * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\n   * @returns the gain node\n   */\n  getSoundGain() {\n    return this._soundGain;\n  }\n  /**\n   * Serializes the Sound in a JSON representation\n   * @returns the JSON representation of the sound\n   */\n  serialize() {\n    const serializationObject = {\n      name: this.name,\n      url: this.name,\n      autoplay: this.autoplay,\n      loop: this.loop,\n      volume: this._volume,\n      spatialSound: this._spatialSound,\n      maxDistance: this.maxDistance,\n      rolloffFactor: this.rolloffFactor,\n      refDistance: this.refDistance,\n      distanceModel: this.distanceModel,\n      playbackRate: this._playbackRate,\n      panningModel: this._panningModel,\n      soundTrackId: this.soundTrackId,\n      metadata: this.metadata\n    };\n    if (this._spatialSound) {\n      if (this._connectedTransformNode) {\n        serializationObject.connectedMeshId = this._connectedTransformNode.id;\n      }\n      serializationObject.position = this._position.asArray();\n      serializationObject.refDistance = this.refDistance;\n      serializationObject.distanceModel = this.distanceModel;\n      serializationObject.isDirectional = this._isDirectional;\n      serializationObject.localDirectionToMesh = this._localDirection.asArray();\n      serializationObject.coneInnerAngle = this._coneInnerAngle;\n      serializationObject.coneOuterAngle = this._coneOuterAngle;\n      serializationObject.coneOuterGain = this._coneOuterGain;\n    }\n    return serializationObject;\n  }\n  /**\n   * Parse a JSON representation of a sound to instantiate in a given scene\n   * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\n   * @param scene Define the scene the new parsed sound should be created in\n   * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\n   * @param sourceSound Define a sound place holder if do not need to instantiate a new one\n   * @returns the newly parsed sound\n   */\n  static Parse(parsedSound, scene, rootUrl, sourceSound) {\n    const soundName = parsedSound.name;\n    let soundUrl;\n    if (parsedSound.url) {\n      soundUrl = rootUrl + parsedSound.url;\n    } else {\n      soundUrl = rootUrl + soundName;\n    }\n    const options = {\n      autoplay: parsedSound.autoplay,\n      loop: parsedSound.loop,\n      volume: parsedSound.volume,\n      spatialSound: parsedSound.spatialSound,\n      maxDistance: parsedSound.maxDistance,\n      rolloffFactor: parsedSound.rolloffFactor,\n      refDistance: parsedSound.refDistance,\n      distanceModel: parsedSound.distanceModel,\n      playbackRate: parsedSound.playbackRate\n    };\n    let newSound;\n    if (!sourceSound) {\n      newSound = new Sound(soundName, soundUrl, scene, () => {\n        scene.removePendingData(newSound);\n      }, options);\n      scene.addPendingData(newSound);\n    } else {\n      const setBufferAndRun = () => {\n        if (sourceSound._isReadyToPlay) {\n          newSound._audioBuffer = sourceSound.getAudioBuffer();\n          newSound._isReadyToPlay = true;\n          if (newSound.autoplay) {\n            newSound.play(0, newSound._offset, newSound._length);\n          }\n        } else {\n          setTimeout(setBufferAndRun, 300);\n        }\n      };\n      newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n      setBufferAndRun();\n    }\n    if (parsedSound.position) {\n      const soundPosition = Vector3.FromArray(parsedSound.position);\n      newSound.setPosition(soundPosition);\n    }\n    if (parsedSound.isDirectional) {\n      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n      if (parsedSound.localDirectionToMesh) {\n        const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n        newSound.setLocalDirectionToMesh(localDirectionToMesh);\n      }\n    }\n    if (parsedSound.connectedMeshId) {\n      const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\n      if (connectedMesh) {\n        newSound.attachToMesh(connectedMesh);\n      }\n    }\n    if (parsedSound.metadata) {\n      newSound.metadata = parsedSound.metadata;\n    }\n    return newSound;\n  }\n  _setOffset(value) {\n    if (this._offset === value) {\n      return;\n    }\n    if (this.isPaused) {\n      this.stop();\n      this.isPaused = false;\n    }\n    this._offset = value;\n  }\n  _stopSoundSource(stopTime) {\n    if (this._soundSource) {\n      this._soundSource.stop(stopTime);\n      this._soundSource.disconnect();\n    }\n  }\n}\n/**\n * @internal\n */\nSound._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"AudioSceneComponent\");\n};","map":{"version":3,"mappings":"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","names":["Tools","Observable","Vector3","Engine","Logger","_WarnImport","EngineStore","Sound","constructor","name","urlOrArrayBuffer","scene","readyToPlayCallback","options","Zero","LastCreatedScene","_scene","_SceneComponentInitialization","_readyToPlayCallback","_customAttenuationFunction","currentVolume","currentDistance","maxDistance","refDistance","rolloffFactor","autoplay","_loop","loop","volume","undefined","_volume","_spatialSound","spatialSound","useCustomAttenuation","distanceModel","_playbackRate","playbackRate","_streaming","streaming","_length","length","_offset","offset","audioEngine","canUseWebAudio","audioContext","_soundGain","createGain","gain","value","_inputAudioNode","_outputAudioNode","_createSpatialParameters","mainSoundTrack","addSound","validParameter","_urlType","ArrayBuffer","HTMLMediaElement","MediaStream","AudioBuffer","Array","isArray","urls","codecSupportedFound","_isReadyToPlay","_streamingSource","createMediaElementSource","play","createMediaStreamSource","byteLength","_soundLoaded","_audioBufferLoaded","push","i","url","skipCodecCheck","indexOf","isMP3supported","isOGGsupported","_loadFile","data","exception","Error","status","removeSound","_htmlAudioElement","Audio","controls","SetCorsBehavior","preload","addEventListener","document","body","appendChild","load","setTimeout","ex","WarnedWebAudioUnsupported","updateOptions","currentTime","isPlaying","isPaused","timeSinceLastStart","_startTime","_currentTime","newValue","dispose","stop","soundTrackId","soundTracks","disconnect","_soundPanner","_soundSource","_audioBuffer","pause","src","removeChild","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","isReady","getClassName","buffer","audioData","decodeAudioData","err","setAudioBuffer","audioBuffer","_setOffset","setVolume","_updateSpatialParameters","loopStart","loopEnd","headphone","_panningModel","createPanner","connect","Number","MAX_VALUE","panningModel","switchPanningModelToHRTF","_switchPanningModel","switchPanningModelToEqualPower","connectToSoundTrackAudioNode","soundTrackAudioNode","_isOutputConnected","setDirectionalCone","coneInnerAngle","coneOuterAngle","coneOuterGain","_coneInnerAngle","_coneOuterAngle","_coneOuterGain","_isDirectional","directionalConeInnerAngle","directionalConeOuterAngle","setPosition","newPosition","equals","_position","copyFrom","isNaN","x","y","z","positionX","positionY","positionZ","setLocalDirectionToMesh","newLocalDirection","_localDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","orientationX","orientationY","orientationZ","updateDistanceFromListener","activeCamera","distance","getDistanceToCamera","setAttenuationFunction","callback","time","audioEnabled","startTime","setOrientation","onended","_onended","tryToPlay","unlocked","playPromise","catch","lock","onAudioUnlockedObservable","addOnce","oldSource","createBufferSource","actualOffset","duration","start","state","message","onEndedObservable","notifyObservers","stopTime","_stopSoundSource","newVolume","cancelScheduledValues","setValueAtTime","linearRampToValueAtTime","setPlaybackRate","newPlaybackRate","getPlaybackRate","getVolume","attachToMesh","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","detachFromMesh","node","getBoundingInfo","absolutePosition","mesh","boundingInfo","boundingSphere","centerWorld","clone","setBufferAndRun","clonedSound","getAudioBuffer","currentOptions","getSoundSource","getSoundGain","serialize","serializationObject","metadata","connectedMeshId","id","position","asArray","isDirectional","localDirectionToMesh","Parse","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","removePendingData","addPendingData","soundPosition","FromArray","connectedMesh","getMeshById","_"],"sourceRoot":"","sources":["../../../../lts/core/generated/Audio/sound.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public autoplay: boolean = false;\r\n\r\n    private _loop = false;\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (value === this._loop) {\r\n            return;\r\n        }\r\n\r\n        this._loop = value;\r\n        this.updateOptions({ loop: value });\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public isPlaying: boolean = false;\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public isPaused: boolean = false;\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public maxDistance: number = 100;\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public distanceModel: string = \"linear\";\r\n    /**\r\n     * @internal\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        if (this._htmlAudioElement) {\r\n            return this._htmlAudioElement.currentTime;\r\n        }\r\n\r\n        if (Engine.audioEngine?.audioContext && (this.isPlaying || this.isPaused)) {\r\n            // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\r\n            // to get the actual current time.\r\n            const timeSinceLastStart = this.isPaused ? 0 : Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            return this._currentTime + timeSinceLastStart;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._spatialSound;\r\n    }\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        this._spatialSound = newValue;\r\n        if (this._spatialSound && Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._createSpatialParameters();\r\n        }\r\n    }\r\n    private _spatialSound: boolean = false;\r\n    private _panningModel: string = \"equalpower\";\r\n    private _playbackRate: number = 1;\r\n    private _streaming: boolean = false;\r\n    private _startTime: number = 0;\r\n    private _currentTime: number = 0;\r\n    private _position: Vector3 = Vector3.Zero();\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: Nullable<() => any>;\r\n    private _audioBuffer: Nullable<AudioBuffer>;\r\n    private _soundSource: Nullable<AudioBufferSourceNode>;\r\n    private _streamingSource: AudioNode;\r\n    private _soundPanner: Nullable<PannerNode>;\r\n    private _soundGain: Nullable<GainNode>;\r\n    private _inputAudioNode: Nullable<AudioNode>;\r\n    private _outputAudioNode: Nullable<AudioNode>;\r\n    // Used if you'd like to create a directional sound.\r\n    // If not set, the sound will be omnidirectional\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _coneOuterGain: number = 0;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _htmlAudioElement: HTMLAudioElement;\r\n    private _urlType: \"Unknown\" | \"String\" | \"Array\" | \"ArrayBuffer\" | \"MediaStream\" | \"AudioBuffer\" | \"MediaElement\" = \"Unknown\";\r\n    private _length?: number;\r\n    private _offset?: number;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        this.name = name;\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this._loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this._spatialSound = options.spatialSound ?? false;\r\n            this.maxDistance = options.maxDistance ?? 100;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = options.streaming ?? false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            this._soundGain = Engine.audioEngine.audioContext.createGain();\r\n            this._soundGain!.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this._spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            let validParameter = true;\r\n\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                    } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n                        this._urlType = \"MediaElement\";\r\n                    } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    } else if (urlOrArrayBuffer instanceof AudioBuffer) {\r\n                        this._urlType = \"AudioBuffer\";\r\n                    } else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n\r\n                    let urls: string[] = [];\r\n                    let codecSupportedFound = false;\r\n\r\n                    switch (this._urlType) {\r\n                        case \"MediaElement\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if ((<ArrayBuffer>urlOrArrayBuffer).byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"AudioBuffer\":\r\n                            this._audioBufferLoaded(urlOrArrayBuffer);\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        // eslint-disable-next-line no-fallthrough\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (let i = 0; i < urls.length; i++) {\r\n                                const url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                    (url.indexOf(\".mp3\", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported) ||\r\n                                    (url.indexOf(\".ogg\", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported) ||\r\n                                    url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".mp4\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(\r\n                                            url,\r\n                                            (data) => {\r\n                                                this._soundLoaded(data as ArrayBuffer);\r\n                                            },\r\n                                            undefined,\r\n                                            true,\r\n                                            true,\r\n                                            (exception) => {\r\n                                                if (exception) {\r\n                                                    Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                                }\r\n                                                Logger.Error(\"Sound creation aborted.\");\r\n                                                this._scene.mainSoundTrack.removeSound(this);\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", () => {\r\n                                            this._isReadyToPlay = true;\r\n                                            if (this.autoplay) {\r\n                                                this.play(0, this._offset, this._length);\r\n                                            }\r\n                                            if (this._readyToPlayCallback) {\r\n                                                this._readyToPlayCallback();\r\n                                            }\r\n                                        });\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    } else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                setTimeout(() => {\r\n                                    if (this._readyToPlayCallback) {\r\n                                        this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        } else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                Engine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                setTimeout(() => {\r\n                    if (this._readyToPlayCallback) {\r\n                        this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n            }\r\n\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n            }\r\n\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    private _audioBufferLoaded(buffer: AudioBuffer) {\r\n        if (!Engine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        this._audioBuffer = buffer;\r\n        this._isReadyToPlay = true;\r\n        if (this.autoplay) {\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n        if (this._readyToPlayCallback) {\r\n            this._readyToPlayCallback();\r\n        }\r\n    }\r\n\r\n    private _soundLoaded(audioData: ArrayBuffer) {\r\n        if (!Engine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        Engine.audioEngine.audioContext.decodeAudioData(\r\n            audioData,\r\n            (buffer) => {\r\n                this._audioBufferLoaded(buffer);\r\n            },\r\n            (err: any) => {\r\n                Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (Engine.audioEngine?.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\r\n            this._length = options.length ?? undefined;\r\n            this._setOffset(options.offset ?? undefined);\r\n            this.setVolume(options.volume ?? this._volume);\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                } else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset! | 0) + this._length!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createSpatialParameters() {\r\n        if (Engine.audioEngine?.canUseWebAudio && Engine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = this._soundPanner ?? Engine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (this._spatialSound && this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            } else {\r\n                this._soundPanner.distanceModel = this.distanceModel as any;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    private _switchPanningModel() {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value != this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value != this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (newPosition.equals(this._position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(newPosition);\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n            this._soundPanner.positionX.value = this._position.x;\r\n            this._soundPanner.positionY.value = this._position.y;\r\n            this._soundPanner.positionZ.value = this._position.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (Engine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.orientationX.value = direction.x;\r\n        this._soundPanner.orientationY.value = direction.y;\r\n        this._soundPanner.orientationZ.value = direction.z;\r\n    }\r\n\r\n    /** @internal */\r\n    public updateDistanceFromListener() {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            const distance = this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && Engine.audioEngine?.audioContext) {\r\n            try {\r\n                let startTime = time ? Engine.audioEngine?.audioContext.currentTime + time : Engine.audioEngine?.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this._spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.positionX.value = this._position.x;\r\n                            this._soundPanner.positionY.value = this._position.y;\r\n                            this._soundPanner.positionZ.value = this._position.z;\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            } else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource) {\r\n                        this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = () => {\r\n                            this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    this._streamingSource.disconnect();\r\n                    if (this._inputAudioNode) {\r\n                        this._streamingSource.connect(this._inputAudioNode);\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio element\r\n                        const tryToPlay = () => {\r\n                            if (Engine.audioEngine?.unlocked) {\r\n                                const playPromise = this._htmlAudioElement.play();\r\n\r\n                                // In browsers that don’t yet support this functionality,\r\n                                // playPromise won’t be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    playPromise.catch(() => {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        Engine.audioEngine?.lock();\r\n                                        if (this.loop || this.autoplay) {\r\n                                            Engine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                if (this.loop || this.autoplay) {\r\n                                    Engine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                } else {\r\n                    const tryToPlay = () => {\r\n                        if (Engine.audioEngine?.audioContext) {\r\n                            length = length || this._length;\r\n\r\n                            if (offset !== undefined) {\r\n                                this._setOffset(offset);\r\n                            }\r\n\r\n                            if (this._soundSource) {\r\n                                const oldSource = this._soundSource;\r\n                                oldSource.onended = () => {\r\n                                    oldSource.disconnect();\r\n                                };\r\n                            }\r\n                            this._soundSource = Engine.audioEngine?.audioContext.createBufferSource();\r\n                            if (this._soundSource && this._inputAudioNode) {\r\n                                this._soundSource.buffer = this._audioBuffer;\r\n                                this._soundSource.connect(this._inputAudioNode);\r\n                                this._soundSource.loop = this.loop;\r\n                                if (offset !== undefined) {\r\n                                    this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    this._soundSource.loopEnd = (offset! | 0) + length!;\r\n                                }\r\n                                this._soundSource.playbackRate.value = this._playbackRate;\r\n                                this._soundSource.onended = () => {\r\n                                    this._onended();\r\n                                };\r\n                                startTime = time ? Engine.audioEngine?.audioContext!.currentTime + time : Engine.audioEngine.audioContext!.currentTime;\r\n                                const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource!.buffer!.duration;\r\n                                this._soundSource!.start(startTime, actualOffset, this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (Engine.audioEngine?.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        setTimeout(() => {\r\n                            if (Engine.audioEngine?.audioContext!.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                Engine.audioEngine.lock();\r\n                                if (this.loop || this.autoplay) {\r\n                                    Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    } else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        this.isPlaying = false;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (this.isPlaying) {\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (Engine.audioEngine?.audioContext && this._soundSource) {\r\n                const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : undefined;\r\n                this._soundSource.onended = () => {\r\n                    this.isPlaying = false;\r\n                    this.isPaused = false;\r\n                    this._startTime = 0;\r\n                    this._currentTime = 0;\r\n                    this._soundSource!.onended = () => void 0;\r\n                };\r\n                this._stopSoundSource(stopTime);\r\n            }\r\n        } else if (this.isPaused) {\r\n            this.isPaused = false;\r\n            this._startTime = 0;\r\n            this._currentTime = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (this.isPlaying) {\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                } else {\r\n                    this._streamingSource.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n            } else if (Engine.audioEngine?.audioContext) {\r\n                this._stopSoundSource();\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n                this._currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (Engine.audioEngine?.canUseWebAudio && this._soundGain) {\r\n            if (time && Engine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);\r\n            } else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            } else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sound play back rate.\r\n     * @returns the  play back rate of the sound\r\n     */\r\n    public getPlaybackRate(): number {\r\n        return this._playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this._spatialSound) {\r\n            this._spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (Engine.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!this._streaming) {\r\n            const setBufferAndRun = () => {\r\n                if (this._isReadyToPlay) {\r\n                    clonedSound._audioBuffer = this.getAudioBuffer();\r\n                    clonedSound._isReadyToPlay = true;\r\n                    if (clonedSound.autoplay) {\r\n                        clonedSound.play(0, this._offset, this._length);\r\n                    }\r\n                } else {\r\n                    setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            const currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this._spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n\r\n            const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        return this._audioBuffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        return this._soundSource;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundGain;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this.name,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this._spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this._spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n\r\n        let newSound: Sound;\r\n\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene.removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene.addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                if (sourceSound._isReadyToPlay) {\r\n                    newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                    newSound._isReadyToPlay = true;\r\n                    if (newSound.autoplay) {\r\n                        newSound.play(0, newSound._offset, newSound._length);\r\n                    }\r\n                } else {\r\n                    setTimeout(setBufferAndRun, 300);\r\n                }\r\n            };\r\n\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n\r\n        return newSound;\r\n    }\r\n\r\n    private _setOffset(value?: number) {\r\n        if (this._offset === value) {\r\n            return;\r\n        }\r\n        if (this.isPaused) {\r\n            this.stop();\r\n            this.isPaused = false;\r\n        }\r\n        this._offset = value;\r\n    }\r\n\r\n    private _stopSoundSource(stopTime?: number) {\r\n        if (this._soundSource) {\r\n            this._soundSource.stop(stopTime);\r\n            this._soundSource.disconnect();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}