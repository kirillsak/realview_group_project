{"ast":null,"code":"import { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Space } from \"../../Maths/math.axis.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\n */\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\n  constructor() {\n    super(...arguments);\n    this._sceneRenderObserver = null;\n    this._targetPosition = new Vector3(0, 0, 0);\n    this._targetOrientation = new Quaternion();\n    this._targetScaling = new Vector3(1, 1, 1);\n    this._startingPosition = new Vector3(0, 0, 0);\n    this._startingOrientation = new Quaternion();\n    this._startingScaling = new Vector3(1, 1, 1);\n    /**\n     * Fires when position is updated\n     */\n    this.onPositionChangedObservable = new Observable();\n    /**\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\n     */\n    this.dragDeltaRatio = 0.2;\n    /**\n     * If the object should rotate to face the drag origin\n     */\n    this.rotateDraggedObject = true;\n    /**\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\n     */\n    this.rotateAroundYOnly = false;\n    /**\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\n     */\n    this.rotateWithMotionController = true;\n    /**\n     * Use this flag to update the target but not move the owner node towards the target\n     */\n    this.disableMovement = false;\n    /**\n     * Should the object rotate towards the camera when we start dragging it\n     */\n    this.faceCameraOnDragStart = false;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"SixDofDrag\";\n  }\n  /**\n   * Attaches the six DoF drag behavior\n   * @param ownerNode The mesh that will be dragged around once attached\n   */\n  attach(ownerNode) {\n    super.attach(ownerNode);\n    ownerNode.isNearGrabbable = true;\n    // Node that will save the owner's transform\n    this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\n    this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\n    // On every frame move towards target scaling to avoid jitter caused by vr controllers\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n      if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\n        // 1 pointer only drags mesh\n        const oldParent = ownerNode.parent;\n        ownerNode.setParent(null);\n        ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));\n        this.onPositionChangedObservable.notifyObservers({\n          position: ownerNode.absolutePosition\n        });\n        // Only rotate the mesh if it's parent has uniform scaling\n        if (!oldParent || oldParent.scaling && !oldParent.scaling.isNonUniformWithinEpsilon(0.001)) {\n          Quaternion.SlerpToRef(ownerNode.rotationQuaternion, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion);\n        }\n        ownerNode.setParent(oldParent);\n      }\n    });\n  }\n  _getPositionOffsetAround(transformationLocalOrigin, scaling, rotation) {\n    const translationMatrix = TmpVectors.Matrix[0]; // T\n    const translationMatrixInv = TmpVectors.Matrix[1]; // T'\n    const rotationMatrix = TmpVectors.Matrix[2]; // R\n    const scaleMatrix = TmpVectors.Matrix[3]; // S\n    const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\n    Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\n    Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\n    Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\n    Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\n    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\n    finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\n    finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\n    return finalMatrix.getTranslation();\n  }\n  _onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation) {\n    const pointerDelta = TmpVectors.Vector3[0];\n    pointerDelta.setAll(0);\n    if (this._dragging === this._dragType.DRAG) {\n      if (this.rotateDraggedObject) {\n        if (this.rotateAroundYOnly) {\n          // Convert change in rotation to only y axis rotation\n          Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        } else {\n          TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\n        }\n        TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\n      }\n    } else if (this._dragging === this._dragType.NEAR_DRAG || this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController) {\n      worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\n    }\n    this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\n  }\n  _twoPointersPositionUpdated() {\n    const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\n    const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\n    const startingCenter = TmpVectors.Vector3[0];\n    startingPosition0.addToRef(startingPosition1, startingCenter);\n    startingCenter.scaleInPlace(0.5);\n    const startingVector = TmpVectors.Vector3[1];\n    startingPosition1.subtractToRef(startingPosition0, startingVector);\n    const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\n    const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\n    const currentCenter = TmpVectors.Vector3[2];\n    currentPosition0.addToRef(currentPosition1, currentCenter);\n    currentCenter.scaleInPlace(0.5);\n    const currentVector = TmpVectors.Vector3[3];\n    currentPosition1.subtractToRef(currentPosition0, currentVector);\n    const scaling = currentVector.length() / startingVector.length();\n    const translation = currentCenter.subtract(startingCenter);\n    const rotationQuaternion = Quaternion.FromEulerAngles(0, Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly), 0);\n    const oldParent = this._ownerNode.parent;\n    this._ownerNode.setParent(null);\n    const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\n    this._virtualTransformNode.rotationQuaternion.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion);\n    this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\n    this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\n    this.onPositionChangedObservable.notifyObservers({\n      position: this._ownerNode.position\n    });\n    this._ownerNode.setParent(oldParent);\n  }\n  _targetDragStart() {\n    const pointerCount = this.currentDraggingPointerIds.length;\n    const oldParent = this._ownerNode.parent;\n    if (!this._ownerNode.rotationQuaternion) {\n      this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\n    }\n    const worldPivot = this._ownerNode.getAbsolutePivotPoint();\n    this._ownerNode.setParent(null);\n    if (pointerCount === 1) {\n      this._targetPosition.copyFrom(this._ownerNode.position);\n      this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\n      this._targetScaling.copyFrom(this._ownerNode.scaling);\n      if (this.faceCameraOnDragStart && this._scene.activeCamera) {\n        const toCamera = TmpVectors.Vector3[0];\n        this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\n        toCamera.normalize();\n        const quat = TmpVectors.Quaternion[0];\n        if (this._scene.useRightHandedSystem) {\n          Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        } else {\n          Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\n        }\n        quat.normalize();\n        Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\n        this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\n      }\n      this._startingPosition.copyFrom(this._targetPosition);\n      this._startingOrientation.copyFrom(this._targetOrientation);\n      this._startingScaling.copyFrom(this._targetScaling);\n    } else if (pointerCount === 2) {\n      this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\n      this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\n      this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\n      this._virtualTransformNode.rotationQuaternion.copyFrom(this._ownerNode.rotationQuaternion);\n      this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\n      this._resetVirtualMeshesPosition();\n    }\n    this._ownerNode.setParent(oldParent);\n  }\n  _targetDrag(worldDeltaPosition, worldDeltaRotation) {\n    if (this.currentDraggingPointerIds.length === 1) {\n      this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\n    } else if (this.currentDraggingPointerIds.length === 2) {\n      this._twoPointersPositionUpdated();\n    }\n  }\n  _targetDragEnd() {\n    if (this.currentDraggingPointerIds.length === 1) {\n      // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\n      this._resetVirtualMeshesPosition();\n      const previousFaceCameraFlag = this.faceCameraOnDragStart;\n      this.faceCameraOnDragStart = false;\n      this._targetDragStart();\n      this.faceCameraOnDragStart = previousFaceCameraFlag;\n    }\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    super.detach();\n    if (this._ownerNode) {\n      this._ownerNode.isNearGrabbable = false;\n      this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    }\n    if (this._virtualTransformNode) {\n      this._virtualTransformNode.dispose();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","TmpVectors","Observable","BaseSixDofDragBehavior","TransformNode","Space","SixDofDragBehavior","constructor","name","attach","ownerNode","isNearGrabbable","_virtualTransformNode","_virtualScene","rotationQuaternion","Identity","_sceneRenderObserver","getScene","onBeforeRenderObservable","add","currentDraggingPointerIds","length","_moving","disableMovement","oldParent","parent","setParent","position","addInPlace","_targetPosition","subtract","scale","dragDeltaRatio","onPositionChangedObservable","notifyObservers","absolutePosition","scaling","isNonUniformWithinEpsilon","SlerpToRef","_targetOrientation","_getPositionOffsetAround","transformationLocalOrigin","rotation","translationMatrix","translationMatrixInv","rotationMatrix","scaleMatrix","finalMatrix","TranslationToRef","x","y","z","FromQuaternionToRef","ScalingToRef","multiplyToRef","getTranslation","_onePointerPositionUpdated","worldDeltaPosition","worldDeltaRotation","pointerDelta","setAll","_dragging","_dragType","DRAG","rotateDraggedObject","rotateAroundYOnly","RotationYawPitchRollToRef","toEulerAngles","copyFrom","_startingOrientation","NEAR_DRAG","DRAG_WITH_CONTROLLER","rotateWithMotionController","_startingPosition","_twoPointersPositionUpdated","startingPosition0","_virtualMeshesInfo","startingPosition","startingPosition1","startingCenter","addToRef","scaleInPlace","startingVector","subtractToRef","currentPosition0","dragMesh","currentPosition1","currentCenter","currentVector","translation","FromEulerAngles","GetAngleBetweenVectorsOnPlane","normalize","UpReadOnly","_ownerNode","positionOffset","getAbsolutePivotPoint","scaleToRef","_targetDragStart","pointerCount","RotationYawPitchRoll","worldPivot","_targetScaling","faceCameraOnDragStart","_scene","activeCamera","toCamera","quat","useRightHandedSystem","FromLookDirectionRHToRef","FromLookDirectionLHToRef","_startingScaling","setPivotPoint","LOCAL","WORLD","_resetVirtualMeshesPosition","_targetDrag","_targetDragEnd","previousFaceCameraFlag","detach","remove","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/sixDofDragBehavior.ts"],"sourcesContent":["import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { BaseSixDofDragBehavior } from \"./baseSixDofDragBehavior\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Space } from \"../../Maths/math.axis\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be dragged around based on directions and origin of the pointer's ray\r\n */\r\nexport class SixDofDragBehavior extends BaseSixDofDragBehavior {\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n    private _virtualTransformNode: TransformNode;\r\n\r\n    protected _targetPosition = new Vector3(0, 0, 0);\r\n    protected _targetOrientation = new Quaternion();\r\n    protected _targetScaling = new Vector3(1, 1, 1);\r\n    protected _startingPosition = new Vector3(0, 0, 0);\r\n    protected _startingOrientation = new Quaternion();\r\n    protected _startingScaling = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Fires when position is updated\r\n     */\r\n    public onPositionChangedObservable = new Observable<{ position: Vector3 }>();\r\n\r\n    /**\r\n     * The distance towards the target drag position to move each frame. This can be useful to avoid jitter. Set this to 1 for no delay. (Default: 0.2)\r\n     */\r\n    public dragDeltaRatio = 0.2;\r\n\r\n    /**\r\n     * If the object should rotate to face the drag origin\r\n     */\r\n    public rotateDraggedObject = true;\r\n\r\n    /**\r\n     * If `rotateDraggedObject` is set to `true`, this parameter determines if we are only rotating around the y axis (yaw)\r\n     */\r\n    public rotateAroundYOnly = false;\r\n\r\n    /**\r\n     * Should the behavior rotate 1:1 with the motion controller, when one is used.\r\n     */\r\n    public rotateWithMotionController = true;\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SixDofDrag\";\r\n    }\r\n\r\n    /**\r\n     * Use this flag to update the target but not move the owner node towards the target\r\n     */\r\n    public disableMovement: boolean = false;\r\n\r\n    /**\r\n     * Should the object rotate towards the camera when we start dragging it\r\n     */\r\n    public faceCameraOnDragStart = false;\r\n\r\n    /**\r\n     * Attaches the six DoF drag behavior\r\n     * @param ownerNode The mesh that will be dragged around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        super.attach(ownerNode);\r\n\r\n        ownerNode.isNearGrabbable = true;\r\n\r\n        // Node that will save the owner's transform\r\n        this._virtualTransformNode = new TransformNode(\"virtual_sixDof\", BaseSixDofDragBehavior._virtualScene);\r\n        this._virtualTransformNode.rotationQuaternion = Quaternion.Identity();\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this.currentDraggingPointerIds.length === 1 && this._moving && !this.disableMovement) {\r\n                // 1 pointer only drags mesh\r\n                const oldParent = ownerNode.parent;\r\n                ownerNode.setParent(null);\r\n                ownerNode.position.addInPlace(this._targetPosition.subtract(ownerNode.position).scale(this.dragDeltaRatio));\r\n\r\n                this.onPositionChangedObservable.notifyObservers({ position: ownerNode.absolutePosition });\r\n\r\n                // Only rotate the mesh if it's parent has uniform scaling\r\n                if (!oldParent || ((oldParent as Mesh).scaling && !(oldParent as Mesh).scaling.isNonUniformWithinEpsilon(0.001))) {\r\n                    Quaternion.SlerpToRef(ownerNode.rotationQuaternion!, this._targetOrientation, this.dragDeltaRatio, ownerNode.rotationQuaternion!);\r\n                }\r\n\r\n                ownerNode.setParent(oldParent);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _getPositionOffsetAround(transformationLocalOrigin: Vector3, scaling: number, rotation: Quaternion): Vector3 {\r\n        const translationMatrix = TmpVectors.Matrix[0]; // T\r\n        const translationMatrixInv = TmpVectors.Matrix[1]; // T'\r\n        const rotationMatrix = TmpVectors.Matrix[2]; // R\r\n        const scaleMatrix = TmpVectors.Matrix[3]; // S\r\n        const finalMatrix = TmpVectors.Matrix[4]; // T' x R x S x T\r\n\r\n        Matrix.TranslationToRef(transformationLocalOrigin.x, transformationLocalOrigin.y, transformationLocalOrigin.z, translationMatrix); // T\r\n        Matrix.TranslationToRef(-transformationLocalOrigin.x, -transformationLocalOrigin.y, -transformationLocalOrigin.z, translationMatrixInv); // T'\r\n        Matrix.FromQuaternionToRef(rotation, rotationMatrix); // R\r\n        Matrix.ScalingToRef(scaling, scaling, scaling, scaleMatrix);\r\n        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix); // T' x R\r\n        finalMatrix.multiplyToRef(scaleMatrix, finalMatrix); // T' x R x S\r\n        finalMatrix.multiplyToRef(translationMatrix, finalMatrix); // T' x R x S x T\r\n\r\n        return finalMatrix.getTranslation();\r\n    }\r\n\r\n    private _onePointerPositionUpdated(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        const pointerDelta = TmpVectors.Vector3[0];\r\n        pointerDelta.setAll(0);\r\n\r\n        if (this._dragging === this._dragType.DRAG) {\r\n            if (this.rotateDraggedObject) {\r\n                if (this.rotateAroundYOnly) {\r\n                    // Convert change in rotation to only y axis rotation\r\n                    Quaternion.RotationYawPitchRollToRef(worldDeltaRotation.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                } else {\r\n                    TmpVectors.Quaternion[0].copyFrom(worldDeltaRotation);\r\n                }\r\n                TmpVectors.Quaternion[0].multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n            }\r\n        } else if (this._dragging === this._dragType.NEAR_DRAG || (this._dragging === this._dragType.DRAG_WITH_CONTROLLER && this.rotateWithMotionController)) {\r\n            worldDeltaRotation.multiplyToRef(this._startingOrientation, this._targetOrientation);\r\n        }\r\n\r\n        this._targetPosition.copyFrom(this._startingPosition).addInPlace(worldDeltaPosition);\r\n    }\r\n\r\n    private _twoPointersPositionUpdated() {\r\n        const startingPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].startingPosition;\r\n        const startingPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].startingPosition;\r\n        const startingCenter = TmpVectors.Vector3[0];\r\n        startingPosition0.addToRef(startingPosition1, startingCenter);\r\n        startingCenter.scaleInPlace(0.5);\r\n        const startingVector = TmpVectors.Vector3[1];\r\n        startingPosition1.subtractToRef(startingPosition0, startingVector);\r\n\r\n        const currentPosition0 = this._virtualMeshesInfo[this.currentDraggingPointerIds[0]].dragMesh.absolutePosition;\r\n        const currentPosition1 = this._virtualMeshesInfo[this.currentDraggingPointerIds[1]].dragMesh.absolutePosition;\r\n        const currentCenter = TmpVectors.Vector3[2];\r\n        currentPosition0.addToRef(currentPosition1, currentCenter);\r\n        currentCenter.scaleInPlace(0.5);\r\n        const currentVector = TmpVectors.Vector3[3];\r\n        currentPosition1.subtractToRef(currentPosition0, currentVector);\r\n\r\n        const scaling = currentVector.length() / startingVector.length();\r\n        const translation = currentCenter.subtract(startingCenter);\r\n        const rotationQuaternion = Quaternion.FromEulerAngles(\r\n            0,\r\n            Vector3.GetAngleBetweenVectorsOnPlane(startingVector.normalize(), currentVector.normalize(), Vector3.UpReadOnly),\r\n            0\r\n        );\r\n\r\n        const oldParent = this._ownerNode.parent;\r\n        this._ownerNode.setParent(null);\r\n\r\n        const positionOffset = this._getPositionOffsetAround(startingCenter.subtract(this._virtualTransformNode.getAbsolutePivotPoint()), scaling, rotationQuaternion);\r\n        this._virtualTransformNode.rotationQuaternion!.multiplyToRef(rotationQuaternion, this._ownerNode.rotationQuaternion!);\r\n        this._virtualTransformNode.scaling.scaleToRef(scaling, this._ownerNode.scaling);\r\n        this._virtualTransformNode.position.addToRef(translation.addInPlace(positionOffset), this._ownerNode.position);\r\n        this.onPositionChangedObservable.notifyObservers({ position: this._ownerNode.position });\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDragStart() {\r\n        const pointerCount = this.currentDraggingPointerIds.length;\r\n        const oldParent = this._ownerNode.parent;\r\n\r\n        if (!this._ownerNode.rotationQuaternion) {\r\n            this._ownerNode.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ownerNode.rotation.y, this._ownerNode.rotation.x, this._ownerNode.rotation.z);\r\n        }\r\n        const worldPivot = this._ownerNode.getAbsolutePivotPoint();\r\n        this._ownerNode.setParent(null);\r\n\r\n        if (pointerCount === 1) {\r\n            this._targetPosition.copyFrom(this._ownerNode.position);\r\n            this._targetOrientation.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._targetScaling.copyFrom(this._ownerNode.scaling);\r\n\r\n            if (this.faceCameraOnDragStart && this._scene.activeCamera) {\r\n                const toCamera = TmpVectors.Vector3[0];\r\n                this._scene.activeCamera.position.subtractToRef(worldPivot, toCamera);\r\n                toCamera.normalize();\r\n                const quat = TmpVectors.Quaternion[0];\r\n                if (this._scene.useRightHandedSystem) {\r\n                    Quaternion.FromLookDirectionRHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                } else {\r\n                    Quaternion.FromLookDirectionLHToRef(toCamera, new Vector3(0, 1, 0), quat);\r\n                }\r\n                quat.normalize();\r\n                Quaternion.RotationYawPitchRollToRef(quat.toEulerAngles().y, 0, 0, TmpVectors.Quaternion[0]);\r\n                this._targetOrientation.copyFrom(TmpVectors.Quaternion[0]);\r\n            }\r\n            this._startingPosition.copyFrom(this._targetPosition);\r\n            this._startingOrientation.copyFrom(this._targetOrientation);\r\n            this._startingScaling.copyFrom(this._targetScaling);\r\n        } else if (pointerCount === 2) {\r\n            this._virtualTransformNode.setPivotPoint(new Vector3(0, 0, 0), Space.LOCAL);\r\n            this._virtualTransformNode.position.copyFrom(this._ownerNode.position);\r\n            this._virtualTransformNode.scaling.copyFrom(this._ownerNode.scaling);\r\n            this._virtualTransformNode.rotationQuaternion!.copyFrom(this._ownerNode.rotationQuaternion);\r\n            this._virtualTransformNode.setPivotPoint(worldPivot, Space.WORLD);\r\n            this._resetVirtualMeshesPosition();\r\n        }\r\n\r\n        this._ownerNode.setParent(oldParent);\r\n    }\r\n\r\n    protected _targetDrag(worldDeltaPosition: Vector3, worldDeltaRotation: Quaternion) {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            this._onePointerPositionUpdated(worldDeltaPosition, worldDeltaRotation);\r\n        } else if (this.currentDraggingPointerIds.length === 2) {\r\n            this._twoPointersPositionUpdated();\r\n        }\r\n    }\r\n\r\n    protected _targetDragEnd() {\r\n        if (this.currentDraggingPointerIds.length === 1) {\r\n            // We still have 1 active pointer, we must simulate a dragstart with a reseted position/orientation\r\n            this._resetVirtualMeshesPosition();\r\n            const previousFaceCameraFlag = this.faceCameraOnDragStart;\r\n            this.faceCameraOnDragStart = false;\r\n            this._targetDragStart();\r\n            this.faceCameraOnDragStart = previousFaceCameraFlag;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        super.detach();\r\n\r\n        if (this._ownerNode) {\r\n            (this._ownerNode as Mesh).isNearGrabbable = false;\r\n            this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n\r\n        if (this._virtualTransformNode) {\r\n            this._virtualTransformNode.dispose();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}