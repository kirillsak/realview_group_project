{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ThinEngine } from \"../thinEngine.js\";\nThinEngine.prototype.restoreSingleAttachment = function () {\n  const gl = this._gl;\n  this.bindAttachments([gl.BACK]);\n};\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n  const gl = this._gl;\n  this.bindAttachments([gl.COLOR_ATTACHMENT0]);\n};\nThinEngine.prototype.buildTextureLayout = function (textureStatus) {\n  const gl = this._gl;\n  const result = [];\n  for (let i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(gl[\"COLOR_ATTACHMENT\" + i]);\n    } else {\n      result.push(gl.NONE);\n    }\n  }\n  return result;\n};\nThinEngine.prototype.bindAttachments = function (attachments) {\n  const gl = this._gl;\n  gl.drawBuffers(attachments);\n};\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n  this._currentRenderTarget = null;\n  // If MSAA, we need to bitblt back to main texture\n  const gl = this._gl;\n  const attachments = rtWrapper._attachments;\n  const count = attachments.length;\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      for (let j = 0; j < count; j++) {\n        attachments[j] = gl.NONE;\n      }\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      gl.readBuffer(attachments[i]);\n      gl.drawBuffers(attachments);\n      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n    }\n    for (let i = 0; i < count; i++) {\n      attachments[i] = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    }\n    gl.drawBuffers(attachments);\n  }\n  for (let i = 0; i < count; i++) {\n    const texture = rtWrapper.textures[i];\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\n      gl.generateMipmap(gl.TEXTURE_2D);\n      this._bindTextureDirectly(gl.TEXTURE_2D, null);\n    }\n  }\n  if (onBeforeUnbind) {\n    if (rtWrapper._MSAAFramebuffer) {\n      // Bind the correct framebuffer\n      this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n    }\n    onBeforeUnbind();\n  }\n  this._bindUnboundFramebuffer(null);\n};\nThinEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers = true) {\n  let generateMipMaps = false;\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let generateDepthTexture = false;\n  let depthTextureFormat = 15;\n  let textureCount = 1;\n  const defaultType = 0;\n  const defaultSamplingMode = 3;\n  const defaultUseSRGBBuffer = false;\n  let types = new Array();\n  let samplingModes = new Array();\n  let useSRGBBuffers = new Array();\n  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    if (options.types) {\n      types = options.types;\n    }\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n    if (options.useSRGBBuffers) {\n      useSRGBBuffers = options.useSRGBBuffers;\n    }\n    if (this.webGLVersion > 1 && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 16 || options.depthTextureFormat === 14 || options.depthTextureFormat === 18)) {\n      depthTextureFormat = options.depthTextureFormat;\n    }\n  }\n  const gl = this._gl;\n  // Create the framebuffer\n  const framebuffer = gl.createFramebuffer();\n  this._bindUnboundFramebuffer(framebuffer);\n  const width = size.width || size;\n  const height = size.height || size;\n  const textures = [];\n  const attachments = [];\n  const useStencilTexture = this.webGLVersion > 1 && generateDepthTexture && (options.depthTextureFormat === 13 || options.depthTextureFormat === 17 || options.depthTextureFormat === 18);\n  const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);\n  rtWrapper._framebuffer = framebuffer;\n  rtWrapper._depthStencilBuffer = depthStencilBuffer;\n  rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  for (let i = 0; i < textureCount; i++) {\n    let samplingMode = samplingModes[i] || defaultSamplingMode;\n    let type = types[i] || defaultType;\n    let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n    useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\n    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    const attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n    textures.push(texture);\n    attachments.push(attachment);\n    gl.activeTexture(gl[\"TEXTURE\" + i]);\n    gl.bindTexture(gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, 5, useSRGBBuffer);\n    gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);\n    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);\n    if (generateMipMaps) {\n      this._gl.generateMipmap(this._gl.TEXTURE_2D);\n    }\n    // Unbind\n    this._bindTextureDirectly(gl.TEXTURE_2D, null);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    this._internalTexturesCache.push(texture);\n  }\n  if (generateDepthTexture && this._caps.depthTextureExtension) {\n    // Depth texture\n    const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\n    let depthTextureType = 5;\n    let glDepthTextureInternalFormat = gl.DEPTH_COMPONENT16;\n    let glDepthTextureFormat = gl.DEPTH_COMPONENT;\n    let glDepthTextureType = gl.UNSIGNED_SHORT;\n    let glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n    if (this.webGLVersion < 2) {\n      glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\n    } else {\n      if (depthTextureFormat === 14) {\n        depthTextureType = 1;\n        glDepthTextureType = gl.FLOAT;\n        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\n      } else if (depthTextureFormat === 18) {\n        depthTextureType = 0;\n        glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\n        glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\n        glDepthTextureFormat = gl.DEPTH_STENCIL;\n        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n      } else if (depthTextureFormat === 16) {\n        depthTextureType = 0;\n        glDepthTextureType = gl.UNSIGNED_INT;\n        glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\n        glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\n      } else if (depthTextureFormat === 13 || depthTextureFormat === 17) {\n        depthTextureType = 12;\n        glDepthTextureType = gl.UNSIGNED_INT_24_8;\n        glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\n        glDepthTextureFormat = gl.DEPTH_STENCIL;\n        glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture.underlyingResource, 0);\n    depthTexture.baseWidth = width;\n    depthTexture.baseHeight = height;\n    depthTexture.width = width;\n    depthTexture.height = height;\n    depthTexture.isReady = true;\n    depthTexture.samples = 1;\n    depthTexture.generateMipMaps = generateMipMaps;\n    depthTexture.samplingMode = 1;\n    depthTexture.format = depthTextureFormat;\n    depthTexture.type = depthTextureType;\n    textures.push(depthTexture);\n    this._internalTexturesCache.push(depthTexture);\n  }\n  rtWrapper.setTextures(textures);\n  if (initializeBuffers) {\n    gl.drawBuffers(attachments);\n  }\n  this._bindUnboundFramebuffer(null);\n  this.resetTextureCache();\n  return rtWrapper;\n};\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples, initializeBuffers = true) {\n  if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\n    return 1;\n  }\n  if (rtWrapper.samples === samples) {\n    return samples;\n  }\n  const count = rtWrapper._attachments.length;\n  if (count === 0) {\n    return 1;\n  }\n  const gl = this._gl;\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  // Dispose previous render buffers\n  const useDepthStencil = !!rtWrapper._depthStencilBuffer;\n  if (useDepthStencil) {\n    gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\n    rtWrapper._depthStencilBuffer = null;\n  }\n  if (rtWrapper._MSAAFramebuffer) {\n    gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\n    rtWrapper._MSAAFramebuffer = null;\n  }\n  if (samples > 1 && gl.renderbufferStorageMultisample) {\n    const framebuffer = gl.createFramebuffer();\n    if (!framebuffer) {\n      throw new Error(\"Unable to create multi sampled framebuffer\");\n    }\n    rtWrapper._MSAAFramebuffer = framebuffer;\n    this._bindUnboundFramebuffer(framebuffer);\n    const attachments = [];\n    for (let i = 0; i < count; i++) {\n      const texture = rtWrapper.textures[i];\n      const hardwareTexture = texture._hardwareTexture;\n      const attachment = gl[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\n      const colorRenderbuffer = hardwareTexture._MSAARenderBuffer ? this._updateRenderBuffer(hardwareTexture._MSAARenderBuffer, texture.width, texture.height, samples, -1 /* not used */, this._getRGBAMultiSampleBufferFormat(texture.type), attachment) : this._createRenderBuffer(texture.width, texture.height, samples, -1 /* not used */, this._getRGBAMultiSampleBufferFormat(texture.type), attachment);\n      if (!colorRenderbuffer) {\n        throw new Error(\"Unable to create multi sampled framebuffer\");\n      }\n      hardwareTexture._MSAARenderBuffer = colorRenderbuffer;\n      texture.samples = samples;\n      attachments.push(attachment);\n    }\n    if (initializeBuffers) {\n      gl.drawBuffers(attachments);\n    }\n  } else {\n    this._bindUnboundFramebuffer(rtWrapper._framebuffer);\n  }\n  if (useDepthStencil) {\n    rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);\n  }\n  this._bindUnboundFramebuffer(null);\n  return samples;\n};","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","Logger","ThinEngine","prototype","restoreSingleAttachment","gl","_gl","bindAttachments","BACK","restoreSingleAttachmentForRenderTarget","COLOR_ATTACHMENT0","buildTextureLayout","textureStatus","result","i","length","push","NONE","attachments","drawBuffers","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","_currentRenderTarget","_attachments","count","_MSAAFramebuffer","bindFramebuffer","READ_FRAMEBUFFER","DRAW_FRAMEBUFFER","_framebuffer","texture","textures","j","webGLVersion","readBuffer","blitFramebuffer","width","height","COLOR_BUFFER_BIT","NEAREST","generateMipMaps","isCube","_bindTextureDirectly","TEXTURE_2D","generateMipmap","_bindUnboundFramebuffer","createMultipleRenderTarget","size","options","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","defaultType","defaultSamplingMode","defaultUseSRGBBuffer","types","Array","samplingModes","useSRGBBuffers","_createHardwareRenderTargetWrapper","undefined","framebuffer","createFramebuffer","useStencilTexture","depthStencilBuffer","_setupFramebufferDepthAttachments","_depthStencilBuffer","_generateDepthBuffer","_generateStencilBuffer","samplingMode","type","useSRGBBuffer","filters","_getSamplingParameters","Warn","_caps","supportSRGBBuffers","isWebGPU","MultiRenderTarget","attachment","activeTexture","bindTexture","_hardwareTexture","underlyingResource","texParameteri","TEXTURE_MAG_FILTER","mag","TEXTURE_MIN_FILTER","min","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","internalSizedFormat","_getRGBABufferInternalSizedFormat","texImage2D","RGBA","_getWebGLTextureType","framebufferTexture2D","baseWidth","baseHeight","isReady","samples","_useSRGBBuffer","_internalTexturesCache","depthTextureExtension","depthTexture","Depth","depthTextureType","glDepthTextureInternalFormat","DEPTH_COMPONENT16","glDepthTextureFormat","DEPTH_COMPONENT","glDepthTextureType","UNSIGNED_SHORT","glDepthTextureAttachment","DEPTH_ATTACHMENT","FLOAT","DEPTH_COMPONENT32F","FLOAT_32_UNSIGNED_INT_24_8_REV","DEPTH32F_STENCIL8","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","UNSIGNED_INT","DEPTH_COMPONENT24","UNSIGNED_INT_24_8","DEPTH24_STENCIL8","TEXTURE0","FRAMEBUFFER","format","setTextures","resetTextureCache","updateMultipleRenderTargetTextureSampleCount","Math","getCaps","maxMSAASamples","useDepthStencil","deleteRenderbuffer","deleteFramebuffer","renderbufferStorageMultisample","Error","hardwareTexture","colorRenderbuffer","_MSAARenderBuffer","_updateRenderBuffer","_getRGBAMultiSampleBufferFormat","_createRenderBuffer"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.multiRender.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { WebGLHardwareTexture } from \"../WebGL/webGLHardwareTexture\";\r\nimport type { TextureSize } from \"../../Materials/Textures/textureCreationOptions\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Unbind a list of render target textures from the webGL context\r\n         * This is used only when drawBuffer extension or webGL2 are active\r\n         * @param rtWrapper defines the render target wrapper to unbind\r\n         * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated\r\n         * @param onBeforeUnbind defines a function which will be called before the effective unbind\r\n         */\r\n        unBindMultiColorAttachmentFramebuffer(rtWrapper: RenderTargetWrapper, disableGenerateMipMaps: boolean, onBeforeUnbind?: () => void): void;\r\n\r\n        /**\r\n         * Create a multi render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multiple-render-target\r\n         * @param size defines the size of the texture\r\n         * @param options defines the creation options\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns a new render target wrapper ready to render textures\r\n         */\r\n        createMultipleRenderTarget(size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Update the sample count for a given multiple render target texture\r\n         * @see https://doc.babylonjs.com/setup/support/webGL2#multisample-render-targets\r\n         * @param rtWrapper defines the render target wrapper to update\r\n         * @param samples defines the sample count to set\r\n         * @param initializeBuffers if set to true, the engine will make an initializing call of drawBuffers\r\n         * @returns the effective sample count (could be 0 if multisample render targets are not supported)\r\n         */\r\n        updateMultipleRenderTargetTextureSampleCount(rtWrapper: Nullable<RenderTargetWrapper>, samples: number, initializeBuffers?: boolean): number;\r\n\r\n        /**\r\n         * Select a subsets of attachments to draw to.\r\n         * @param attachments gl attachments\r\n         */\r\n        bindAttachments(attachments: number[]): void;\r\n\r\n        /**\r\n         * Creates a layout object to draw/clear on specific textures in a MRT\r\n         * @param textureStatus textureStatus[i] indicates if the i-th is active\r\n         * @returns A layout to be fed to the engine, calling `bindAttachments`.\r\n         */\r\n        buildTextureLayout(textureStatus: boolean[]): number[];\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is the canvas frame buffer\r\n         */\r\n        restoreSingleAttachment(): void;\r\n\r\n        /**\r\n         * Restores the webgl state to only draw on the main color attachment\r\n         * when the frame buffer associated is not the canvas frame buffer\r\n         */\r\n        restoreSingleAttachmentForRenderTarget(): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.restoreSingleAttachment = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.BACK]);\r\n};\r\n\r\nThinEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    const gl = this._gl;\r\n\r\n    this.bindAttachments([gl.COLOR_ATTACHMENT0]);\r\n};\r\n\r\nThinEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const gl = this._gl;\r\n\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push((<any>gl)[\"COLOR_ATTACHMENT\" + i]);\r\n        } else {\r\n            result.push(gl.NONE);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nThinEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    const gl = this._gl;\r\n\r\n    gl.drawBuffers(attachments);\r\n};\r\n\r\nThinEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: WebGLRenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    this._currentRenderTarget = null;\r\n\r\n    // If MSAA, we need to bitblt back to main texture\r\n    const gl = this._gl;\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, rtWrapper._MSAAFramebuffer);\r\n        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, rtWrapper._framebuffer);\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n\r\n            for (let j = 0; j < count; j++) {\r\n                attachments[j] = gl.NONE;\r\n            }\r\n\r\n            attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n            gl.readBuffer(attachments[i]);\r\n            gl.drawBuffers(attachments);\r\n            gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\r\n        }\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            attachments[i] = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n        }\r\n\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n        }\r\n    }\r\n\r\n    if (onBeforeUnbind) {\r\n        if (rtWrapper._MSAAFramebuffer) {\r\n            // Bind the correct framebuffer\r\n            this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n        }\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n};\r\n\r\nThinEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers: boolean = true): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n    let useSRGBBuffers = new Array<boolean>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGLRenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n        if (\r\n            this.webGLVersion > 1 &&\r\n            (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24 ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT ||\r\n                options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8)\r\n        ) {\r\n            depthTextureFormat = options.depthTextureFormat;\r\n        }\r\n    }\r\n    const gl = this._gl;\r\n    // Create the framebuffer\r\n    const framebuffer = gl.createFramebuffer();\r\n    this._bindUnboundFramebuffer(framebuffer);\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n\r\n    const useStencilTexture =\r\n        this.webGLVersion > 1 &&\r\n        generateDepthTexture &&\r\n        (options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 ||\r\n            options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 ||\r\n            options.depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8);\r\n    const depthStencilBuffer = this._setupFramebufferDepthAttachments(!useStencilTexture && generateStencilBuffer, !generateDepthTexture && generateDepthBuffer, width, height);\r\n\r\n    rtWrapper._framebuffer = framebuffer;\r\n    rtWrapper._depthStencilBuffer = depthStencilBuffer;\r\n    rtWrapper._generateDepthBuffer = !generateDepthTexture && generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = !useStencilTexture && generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n        let useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        useSRGBBuffer = useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n        const attachment = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n        textures.push(texture);\r\n        attachments.push(attachment);\r\n\r\n        gl.activeTexture((<any>gl)[\"TEXTURE\" + i]);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture._hardwareTexture!.underlyingResource);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        const internalSizedFormat = this._getRGBABufferInternalSizedFormat(type, Constants.TEXTUREFORMAT_RGBA, useSRGBBuffer);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalSizedFormat, width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);\r\n\r\n        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture!.underlyingResource, 0);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n        }\r\n\r\n        // Unbind\r\n        this._bindTextureDirectly(gl.TEXTURE_2D, null);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n    }\r\n\r\n    if (generateDepthTexture && this._caps.depthTextureExtension) {\r\n        // Depth texture\r\n        const depthTexture = new InternalTexture(this, InternalTextureSource.Depth);\r\n\r\n        let depthTextureType = Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n        let glDepthTextureInternalFormat = gl.DEPTH_COMPONENT16;\r\n        let glDepthTextureFormat = gl.DEPTH_COMPONENT;\r\n        let glDepthTextureType = gl.UNSIGNED_SHORT;\r\n        let glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\r\n        if (this.webGLVersion < 2) {\r\n            glDepthTextureInternalFormat = gl.DEPTH_COMPONENT;\r\n        } else {\r\n            if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32_FLOAT) {\r\n                depthTextureType = Constants.TEXTURETYPE_FLOAT;\r\n                glDepthTextureType = gl.FLOAT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT32F;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                glDepthTextureType = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;\r\n                glDepthTextureInternalFormat = gl.DEPTH32F_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                glDepthTextureType = gl.UNSIGNED_INT;\r\n                glDepthTextureInternalFormat = gl.DEPTH_COMPONENT24;\r\n                glDepthTextureAttachment = gl.DEPTH_ATTACHMENT;\r\n            } else if (depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 || depthTextureFormat === Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8) {\r\n                depthTextureType = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;\r\n                glDepthTextureType = gl.UNSIGNED_INT_24_8;\r\n                glDepthTextureInternalFormat = gl.DEPTH24_STENCIL8;\r\n                glDepthTextureFormat = gl.DEPTH_STENCIL;\r\n                glDepthTextureAttachment = gl.DEPTH_STENCIL_ATTACHMENT;\r\n            }\r\n        }\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, glDepthTextureInternalFormat, width, height, 0, glDepthTextureFormat, glDepthTextureType, null);\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, glDepthTextureAttachment, gl.TEXTURE_2D, depthTexture._hardwareTexture!.underlyingResource, 0);\r\n\r\n        depthTexture.baseWidth = width;\r\n        depthTexture.baseHeight = height;\r\n        depthTexture.width = width;\r\n        depthTexture.height = height;\r\n        depthTexture.isReady = true;\r\n        depthTexture.samples = 1;\r\n        depthTexture.generateMipMaps = generateMipMaps;\r\n        depthTexture.samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        depthTexture.format = depthTextureFormat;\r\n        depthTexture.type = depthTextureType;\r\n\r\n        textures.push(depthTexture);\r\n        this._internalTexturesCache.push(depthTexture);\r\n    }\r\n    rtWrapper.setTextures(textures);\r\n    if (initializeBuffers) {\r\n        gl.drawBuffers(attachments);\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    this.resetTextureCache();\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (\r\n    rtWrapper: Nullable<WebGLRenderTargetWrapper>,\r\n    samples: number,\r\n    initializeBuffers: boolean = true\r\n): number {\r\n    if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {\r\n        return 1;\r\n    }\r\n\r\n    if (rtWrapper.samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper._attachments!.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    const gl = this._gl;\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    // Dispose previous render buffers\r\n    const useDepthStencil = !!rtWrapper._depthStencilBuffer;\r\n    if (useDepthStencil) {\r\n        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);\r\n        rtWrapper._depthStencilBuffer = null;\r\n    }\r\n\r\n    if (rtWrapper._MSAAFramebuffer) {\r\n        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);\r\n        rtWrapper._MSAAFramebuffer = null;\r\n    }\r\n\r\n    if (samples > 1 && gl.renderbufferStorageMultisample) {\r\n        const framebuffer = gl.createFramebuffer();\r\n\r\n        if (!framebuffer) {\r\n            throw new Error(\"Unable to create multi sampled framebuffer\");\r\n        }\r\n\r\n        rtWrapper._MSAAFramebuffer = framebuffer;\r\n        this._bindUnboundFramebuffer(framebuffer);\r\n\r\n        const attachments = [];\r\n\r\n        for (let i = 0; i < count; i++) {\r\n            const texture = rtWrapper.textures![i];\r\n            const hardwareTexture = texture._hardwareTexture as WebGLHardwareTexture;\r\n            const attachment = (<any>gl)[this.webGLVersion > 1 ? \"COLOR_ATTACHMENT\" + i : \"COLOR_ATTACHMENT\" + i + \"_WEBGL\"];\r\n\r\n            const colorRenderbuffer = hardwareTexture._MSAARenderBuffer\r\n                ? this._updateRenderBuffer(\r\n                      hardwareTexture._MSAARenderBuffer,\r\n                      texture.width,\r\n                      texture.height,\r\n                      samples,\r\n                      -1 /* not used */,\r\n                      this._getRGBAMultiSampleBufferFormat(texture.type),\r\n                      attachment\r\n                  )\r\n                : this._createRenderBuffer(texture.width, texture.height, samples, -1 /* not used */, this._getRGBAMultiSampleBufferFormat(texture.type), attachment);\r\n\r\n            if (!colorRenderbuffer) {\r\n                throw new Error(\"Unable to create multi sampled framebuffer\");\r\n            }\r\n\r\n            hardwareTexture._MSAARenderBuffer = colorRenderbuffer;\r\n            texture.samples = samples;\r\n\r\n            attachments.push(attachment);\r\n        }\r\n        if (initializeBuffers) {\r\n            gl.drawBuffers(attachments);\r\n        }\r\n    } else {\r\n        this._bindUnboundFramebuffer(rtWrapper._framebuffer);\r\n    }\r\n\r\n    if (useDepthStencil) {\r\n        rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(\r\n            rtWrapper._generateStencilBuffer,\r\n            rtWrapper._generateDepthBuffer,\r\n            rtWrapper.texture.width,\r\n            rtWrapper.texture.height,\r\n            samples\r\n        );\r\n    }\r\n\r\n    this._bindUnboundFramebuffer(null);\r\n\r\n    return samples;\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}