{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera.js\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera.js\";\nimport { AnimationKeyInterpolation } from \"@babylonjs/core/Animations/animationKey.js\";\nimport { AnimationGroup } from \"@babylonjs/core/Animations/animationGroup.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { TransformNode } from \"@babylonjs/core/Meshes/transformNode.js\";\nimport { Buffer, VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { MorphTarget } from \"@babylonjs/core/Morph/morphTarget.js\";\nimport { MorphTargetManager } from \"@babylonjs/core/Morph/morphTargetManager.js\";\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader.js\";\nimport { DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFileError } from \"@babylonjs/core/Misc/fileTools.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { BoundingInfo } from \"@babylonjs/core/Culling/boundingInfo.js\";\nimport { nodeAnimationData } from \"./glTFLoaderAnimation.js\";\n// https://stackoverflow.com/a/48218209\nfunction mergeDeep(...objects) {\n  const isObject = obj => obj && typeof obj === \"object\";\n  return objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach(key => {\n      const pVal = prev[key];\n      const oVal = obj[key];\n      if (Array.isArray(pVal) && Array.isArray(oVal)) {\n        prev[key] = pVal.concat(...oVal);\n      } else if (isObject(pVal) && isObject(oVal)) {\n        prev[key] = mergeDeep(pVal, oVal);\n      } else {\n        prev[key] = oVal;\n      }\n    });\n    return prev;\n  }, {});\n}\n/**\n * Helper class for working with arrays when loading the glTF asset\n */\nexport class ArrayItem {\n  /**\n   * Gets an item from the given array.\n   * @param context The context when loading the asset\n   * @param array The array to get the item from\n   * @param index The index to the array\n   * @returns The array item\n   */\n  static Get(context, array, index) {\n    if (!array || index == undefined || !array[index]) {\n      throw new Error(`${context}: Failed to find index (${index})`);\n    }\n    return array[index];\n  }\n  /**\n   * Assign an `index` field to each item of the given array.\n   * @param array The array of items\n   */\n  static Assign(array) {\n    if (array) {\n      for (let index = 0; index < array.length; index++) {\n        array[index].index = index;\n      }\n    }\n  }\n}\n/**\n * The glTF 2.0 loader\n */\nexport class GLTFLoader {\n  /**\n   * @internal\n   */\n  constructor(parent) {\n    /** @internal */\n    this._completePromises = new Array();\n    /** @internal */\n    this._assetContainer = null;\n    /** Storage */\n    this._babylonLights = [];\n    /** @internal */\n    this._disableInstancedMesh = 0;\n    this._extensions = new Array();\n    this._disposed = false;\n    this._rootUrl = null;\n    this._fileName = null;\n    this._uniqueRootUrl = null;\n    this._bin = null;\n    this._rootBabylonMesh = null;\n    this._defaultBabylonMaterialData = {};\n    this._postSceneLoadActions = new Array();\n    this._parent = parent;\n  }\n  /**\n   * Registers a loader extension.\n   * @param name The name of the loader extension.\n   * @param factory The factory function that creates the loader extension.\n   */\n  static RegisterExtension(name, factory) {\n    if (GLTFLoader.UnregisterExtension(name)) {\n      Logger.Warn(`Extension with the name '${name}' already exists`);\n    }\n    GLTFLoader._RegisteredExtensions[name] = {\n      factory: factory\n    };\n  }\n  /**\n   * Unregisters a loader extension.\n   * @param name The name of the loader extension.\n   * @returns A boolean indicating whether the extension has been unregistered\n   */\n  static UnregisterExtension(name) {\n    if (!GLTFLoader._RegisteredExtensions[name]) {\n      return false;\n    }\n    delete GLTFLoader._RegisteredExtensions[name];\n    return true;\n  }\n  /**\n   * The object that represents the glTF JSON.\n   */\n  get gltf() {\n    if (!this._gltf) {\n      throw new Error(\"glTF JSON is not available\");\n    }\n    return this._gltf;\n  }\n  /**\n   * The BIN chunk of a binary glTF.\n   */\n  get bin() {\n    return this._bin;\n  }\n  /**\n   * The parent file loader.\n   */\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * The Babylon scene when loading the asset.\n   */\n  get babylonScene() {\n    if (!this._babylonScene) {\n      throw new Error(\"Scene is not available\");\n    }\n    return this._babylonScene;\n  }\n  /**\n   * The root Babylon mesh when loading the asset.\n   */\n  get rootBabylonMesh() {\n    return this._rootBabylonMesh;\n  }\n  /** @internal */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n    this._disposed = true;\n    this._completePromises.length = 0;\n    this._extensions.forEach(extension => extension.dispose && extension.dispose());\n    this._extensions.length = 0;\n    this._gltf = null; // TODO\n    this._bin = null;\n    this._babylonScene = null; // TODO\n    this._rootBabylonMesh = null;\n    this._defaultBabylonMaterialData = {};\n    this._postSceneLoadActions.length = 0;\n    this._parent.dispose();\n  }\n  /**\n   * @internal\n   */\n  importMeshAsync(meshesNames, scene, container, data, rootUrl, onProgress, fileName = \"\") {\n    return Promise.resolve().then(() => {\n      this._babylonScene = scene;\n      this._assetContainer = container;\n      this._loadData(data);\n      let nodes = null;\n      if (meshesNames) {\n        const nodeMap = {};\n        if (this._gltf.nodes) {\n          for (const node of this._gltf.nodes) {\n            if (node.name) {\n              nodeMap[node.name] = node.index;\n            }\n          }\n        }\n        const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\n        nodes = names.map(name => {\n          const node = nodeMap[name];\n          if (node === undefined) {\n            throw new Error(`Failed to find node '${name}'`);\n          }\n          return node;\n        });\n      }\n      return this._loadAsync(rootUrl, fileName, nodes, () => {\n        return {\n          meshes: this._getMeshes(),\n          particleSystems: [],\n          skeletons: this._getSkeletons(),\n          animationGroups: this._getAnimationGroups(),\n          lights: this._babylonLights,\n          transformNodes: this._getTransformNodes(),\n          geometries: this._getGeometries()\n        };\n      });\n    });\n  }\n  /**\n   * @internal\n   */\n  loadAsync(scene, data, rootUrl, onProgress, fileName = \"\") {\n    return Promise.resolve().then(() => {\n      this._babylonScene = scene;\n      this._loadData(data);\n      return this._loadAsync(rootUrl, fileName, null, () => undefined);\n    });\n  }\n  _loadAsync(rootUrl, fileName, nodes, resultFunc) {\n    return Promise.resolve().then(() => {\n      this._rootUrl = rootUrl;\n      this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\n      this._fileName = fileName;\n      this._loadExtensions();\n      this._checkExtensions();\n      const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\n      const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\n      this._parent._startPerformanceCounter(loadingToReadyCounterName);\n      this._parent._startPerformanceCounter(loadingToCompleteCounterName);\n      this._parent._setState(GLTFLoaderState.LOADING);\n      this._extensionsOnLoading();\n      const promises = new Array();\n      // Block the marking of materials dirty until the scene is loaded.\n      const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\n      this._babylonScene.blockMaterialDirtyMechanism = true;\n      if (!this.parent.loadOnlyMaterials) {\n        if (nodes) {\n          promises.push(this.loadSceneAsync(\"/nodes\", {\n            nodes: nodes,\n            index: -1\n          }));\n        } else if (this._gltf.scene != undefined || this._gltf.scenes && this._gltf.scenes[0]) {\n          const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\n          promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\n        }\n      }\n      if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\n        for (let m = 0; m < this._gltf.materials.length; ++m) {\n          const material = this._gltf.materials[m];\n          const context = \"/materials/\" + m;\n          const babylonDrawMode = Material.TriangleFillMode;\n          promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\n        }\n      }\n      // Restore the blocking of material dirty.\n      this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\n      if (this._parent.compileMaterials) {\n        promises.push(this._compileMaterialsAsync());\n      }\n      if (this._parent.compileShadowGenerators) {\n        promises.push(this._compileShadowGeneratorsAsync());\n      }\n      const resultPromise = Promise.all(promises).then(() => {\n        if (this._rootBabylonMesh) {\n          this._rootBabylonMesh.setEnabled(true);\n        }\n        this._extensionsOnReady();\n        this._parent._setState(GLTFLoaderState.READY);\n        this._startAnimations();\n        return resultFunc();\n      });\n      return resultPromise.then(result => {\n        this._parent._endPerformanceCounter(loadingToReadyCounterName);\n        Tools.SetImmediate(() => {\n          if (!this._disposed) {\n            Promise.all(this._completePromises).then(() => {\n              this._parent._endPerformanceCounter(loadingToCompleteCounterName);\n              this._parent._setState(GLTFLoaderState.COMPLETE);\n              this._parent.onCompleteObservable.notifyObservers(undefined);\n              this._parent.onCompleteObservable.clear();\n              this.dispose();\n            }, error => {\n              this._parent.onErrorObservable.notifyObservers(error);\n              this._parent.onErrorObservable.clear();\n              this.dispose();\n            });\n          }\n        });\n        return result;\n      });\n    }).catch(error => {\n      if (!this._disposed) {\n        this._parent.onErrorObservable.notifyObservers(error);\n        this._parent.onErrorObservable.clear();\n        this.dispose();\n      }\n      throw error;\n    });\n  }\n  _loadData(data) {\n    this._gltf = data.json;\n    this._setupData();\n    if (data.bin) {\n      const buffers = this._gltf.buffers;\n      if (buffers && buffers[0] && !buffers[0].uri) {\n        const binaryBuffer = buffers[0];\n        if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\n          Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\n        }\n        this._bin = data.bin;\n      } else {\n        Logger.Warn(\"Unexpected BIN chunk\");\n      }\n    }\n  }\n  _setupData() {\n    ArrayItem.Assign(this._gltf.accessors);\n    ArrayItem.Assign(this._gltf.animations);\n    ArrayItem.Assign(this._gltf.buffers);\n    ArrayItem.Assign(this._gltf.bufferViews);\n    ArrayItem.Assign(this._gltf.cameras);\n    ArrayItem.Assign(this._gltf.images);\n    ArrayItem.Assign(this._gltf.materials);\n    ArrayItem.Assign(this._gltf.meshes);\n    ArrayItem.Assign(this._gltf.nodes);\n    ArrayItem.Assign(this._gltf.samplers);\n    ArrayItem.Assign(this._gltf.scenes);\n    ArrayItem.Assign(this._gltf.skins);\n    ArrayItem.Assign(this._gltf.textures);\n    if (this._gltf.nodes) {\n      const nodeParents = {};\n      for (const node of this._gltf.nodes) {\n        if (node.children) {\n          for (const index of node.children) {\n            nodeParents[index] = node.index;\n          }\n        }\n      }\n      const rootNode = this._createRootNode();\n      for (const node of this._gltf.nodes) {\n        const parentIndex = nodeParents[node.index];\n        node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\n      }\n    }\n  }\n  _loadExtensions() {\n    for (const name in GLTFLoader._RegisteredExtensions) {\n      const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\n      if (extension.name !== name) {\n        Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\n      }\n      this._extensions.push(extension);\n      this._parent.onExtensionLoadedObservable.notifyObservers(extension);\n    }\n    this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\n    this._parent.onExtensionLoadedObservable.clear();\n  }\n  _checkExtensions() {\n    if (this._gltf.extensionsRequired) {\n      for (const name of this._gltf.extensionsRequired) {\n        const available = this._extensions.some(extension => extension.name === name && extension.enabled);\n        if (!available) {\n          throw new Error(`Require extension ${name} is not available`);\n        }\n      }\n    }\n  }\n  _createRootNode() {\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\n    this._rootBabylonMesh._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    this._rootBabylonMesh.setEnabled(false);\n    const rootNode = {\n      _babylonTransformNode: this._rootBabylonMesh,\n      index: -1\n    };\n    switch (this._parent.coordinateSystemMode) {\n      case GLTFLoaderCoordinateSystemMode.AUTO:\n        {\n          if (!this._babylonScene.useRightHandedSystem) {\n            rootNode.rotation = [0, 1, 0, 0];\n            rootNode.scale = [1, 1, -1];\n            GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\n          }\n          break;\n        }\n      case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED:\n        {\n          this._babylonScene.useRightHandedSystem = true;\n          break;\n        }\n      default:\n        {\n          throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\n        }\n    }\n    this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\n    return rootNode;\n  }\n  /**\n   * Loads a glTF scene.\n   * @param context The context when loading the asset\n   * @param scene The glTF scene property\n   * @returns A promise that resolves when the load is complete\n   */\n  loadSceneAsync(context, scene) {\n    const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    const promises = new Array();\n    this.logOpen(`${context} ${scene.name || \"\"}`);\n    if (scene.nodes) {\n      for (const index of scene.nodes) {\n        const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\n        promises.push(this.loadNodeAsync(`/nodes/${node.index}`, node, babylonMesh => {\n          babylonMesh.parent = this._rootBabylonMesh;\n        }));\n      }\n    }\n    for (const action of this._postSceneLoadActions) {\n      action();\n    }\n    promises.push(this._loadAnimationsAsync());\n    this.logClose();\n    return Promise.all(promises).then(() => {});\n  }\n  _forEachPrimitive(node, callback) {\n    if (node._primitiveBabylonMeshes) {\n      for (const babylonMesh of node._primitiveBabylonMeshes) {\n        callback(babylonMesh);\n      }\n    }\n  }\n  _getGeometries() {\n    const geometries = new Array();\n    const nodes = this._gltf.nodes;\n    if (nodes) {\n      for (const node of nodes) {\n        this._forEachPrimitive(node, babylonMesh => {\n          const geometry = babylonMesh.geometry;\n          if (geometry && geometries.indexOf(geometry) === -1) {\n            geometries.push(geometry);\n          }\n        });\n      }\n    }\n    return geometries;\n  }\n  _getMeshes() {\n    const meshes = new Array();\n    // Root mesh is always first, if available.\n    if (this._rootBabylonMesh) {\n      meshes.push(this._rootBabylonMesh);\n    }\n    const nodes = this._gltf.nodes;\n    if (nodes) {\n      for (const node of nodes) {\n        this._forEachPrimitive(node, babylonMesh => {\n          meshes.push(babylonMesh);\n        });\n      }\n    }\n    return meshes;\n  }\n  _getTransformNodes() {\n    const transformNodes = new Array();\n    const nodes = this._gltf.nodes;\n    if (nodes) {\n      for (const node of nodes) {\n        if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\n          transformNodes.push(node._babylonTransformNode);\n        }\n        if (node._babylonTransformNodeForSkin) {\n          transformNodes.push(node._babylonTransformNodeForSkin);\n        }\n      }\n    }\n    return transformNodes;\n  }\n  _getSkeletons() {\n    const skeletons = new Array();\n    const skins = this._gltf.skins;\n    if (skins) {\n      for (const skin of skins) {\n        if (skin._data) {\n          skeletons.push(skin._data.babylonSkeleton);\n        }\n      }\n    }\n    return skeletons;\n  }\n  _getAnimationGroups() {\n    const animationGroups = new Array();\n    const animations = this._gltf.animations;\n    if (animations) {\n      for (const animation of animations) {\n        if (animation._babylonAnimationGroup) {\n          animationGroups.push(animation._babylonAnimationGroup);\n        }\n      }\n    }\n    return animationGroups;\n  }\n  _startAnimations() {\n    switch (this._parent.animationStartMode) {\n      case GLTFLoaderAnimationStartMode.NONE:\n        {\n          // do nothing\n          break;\n        }\n      case GLTFLoaderAnimationStartMode.FIRST:\n        {\n          const babylonAnimationGroups = this._getAnimationGroups();\n          if (babylonAnimationGroups.length !== 0) {\n            babylonAnimationGroups[0].start(true);\n          }\n          break;\n        }\n      case GLTFLoaderAnimationStartMode.ALL:\n        {\n          const babylonAnimationGroups = this._getAnimationGroups();\n          for (const babylonAnimationGroup of babylonAnimationGroups) {\n            babylonAnimationGroup.start(true);\n          }\n          break;\n        }\n      default:\n        {\n          Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\n          return;\n        }\n    }\n  }\n  /**\n   * Loads a glTF node.\n   * @param context The context when loading the asset\n   * @param node The glTF node property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\n   */\n  loadNodeAsync(context, node, assign = () => {}) {\n    const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    if (node._babylonTransformNode) {\n      throw new Error(`${context}: Invalid recursive node hierarchy`);\n    }\n    const promises = new Array();\n    this.logOpen(`${context} ${node.name || \"\"}`);\n    const loadNode = babylonTransformNode => {\n      GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\n      GLTFLoader._LoadTransform(node, babylonTransformNode);\n      if (node.camera != undefined) {\n        const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\n        promises.push(this.loadCameraAsync(`/cameras/${camera.index}`, camera, babylonCamera => {\n          babylonCamera.parent = babylonTransformNode;\n        }));\n      }\n      if (node.children) {\n        for (const index of node.children) {\n          const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\n          promises.push(this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, childBabylonMesh => {\n            childBabylonMesh.parent = babylonTransformNode;\n          }));\n        }\n      }\n      assign(babylonTransformNode);\n    };\n    if (node.mesh == undefined || node.skin != undefined) {\n      const nodeName = node.name || `node${node.index}`;\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      const transformNode = new TransformNode(nodeName, this._babylonScene);\n      transformNode._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      if (node.mesh == undefined) {\n        node._babylonTransformNode = transformNode;\n      } else {\n        node._babylonTransformNodeForSkin = transformNode;\n      }\n      loadNode(transformNode);\n    }\n    if (node.mesh != undefined) {\n      if (node.skin == undefined) {\n        const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\n        promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\n      } else {\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n        // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\n        // transform, which effectively ignores the transform of the skinned mesh, as per spec.\n        const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\n        promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, babylonTransformNode => {\n          const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;\n          // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\n          babylonTransformNode.metadata = mergeDeep(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\n          const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\n          promises.push(this._loadSkinAsync(`/skins/${skin.index}`, node, skin, babylonSkeleton => {\n            this._forEachPrimitive(node, babylonMesh => {\n              babylonMesh.skeleton = babylonSkeleton;\n            });\n            // Wait until all the nodes are parented before parenting the skinned mesh.\n            this._postSceneLoadActions.push(() => {\n              if (skin.skeleton != undefined) {\n                // Place the skinned mesh node as a sibling of the skeleton root node.\n                // Handle special case when the parent of the skeleton root is the skinned mesh.\n                const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent;\n                if (node.index === parentNode.index) {\n                  babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\n                } else {\n                  babylonTransformNode.parent = parentNode._babylonTransformNode;\n                }\n              } else {\n                babylonTransformNode.parent = this._rootBabylonMesh;\n              }\n              this._parent.onSkinLoadedObservable.notifyObservers({\n                node: babylonTransformNodeForSkin,\n                skinnedNode: babylonTransformNode\n              });\n            });\n          }));\n        }));\n      }\n    }\n    this.logClose();\n    return Promise.all(promises).then(() => {\n      this._forEachPrimitive(node, babylonMesh => {\n        if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {\n          // simply apply the world matrices to the bounding info - the extends are already ok\n          babylonMesh._updateBoundingInfo();\n        } else {\n          babylonMesh.refreshBoundingInfo(true);\n        }\n      });\n      return node._babylonTransformNode;\n    });\n  }\n  _loadMeshAsync(context, node, mesh, assign) {\n    const primitives = mesh.primitives;\n    if (!primitives || !primitives.length) {\n      throw new Error(`${context}: Primitives are missing`);\n    }\n    if (primitives[0].index == undefined) {\n      ArrayItem.Assign(primitives);\n    }\n    const promises = new Array();\n    this.logOpen(`${context} ${mesh.name || \"\"}`);\n    const name = node.name || `node${node.index}`;\n    if (primitives.length === 1) {\n      const primitive = mesh.primitives[0];\n      promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, babylonMesh => {\n        node._babylonTransformNode = babylonMesh;\n        node._primitiveBabylonMeshes = [babylonMesh];\n      }));\n    } else {\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      node._babylonTransformNode = new TransformNode(name, this._babylonScene);\n      node._babylonTransformNode._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      node._primitiveBabylonMeshes = [];\n      for (const primitive of primitives) {\n        promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, babylonMesh => {\n          babylonMesh.parent = node._babylonTransformNode;\n          node._primitiveBabylonMeshes.push(babylonMesh);\n        }));\n      }\n    }\n    assign(node._babylonTransformNode);\n    this.logClose();\n    return Promise.all(promises).then(() => {\n      return node._babylonTransformNode;\n    });\n  }\n  /**\n   * @internal Define this method to modify the default behavior when loading data for mesh primitives.\n   * @param context The context when loading the asset\n   * @param name The mesh name when loading the asset\n   * @param node The glTF node when loading the asset\n   * @param mesh The glTF mesh when loading the asset\n   * @param primitive The glTF mesh primitive property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\n   */\n  _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n    const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    this.logOpen(`${context}`);\n    const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\n    let babylonAbstractMesh;\n    let promise;\n    if (shouldInstance && primitive._instanceData) {\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\n      babylonAbstractMesh._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      promise = primitive._instanceData.promise;\n    } else {\n      const promises = new Array();\n      this._babylonScene._blockEntityCollection = !!this._assetContainer;\n      const babylonMesh = new Mesh(name, this._babylonScene);\n      babylonMesh._parentContainer = this._assetContainer;\n      this._babylonScene._blockEntityCollection = false;\n      babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n      this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\n      promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then(babylonGeometry => {\n        return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\n          if (this._disposed) {\n            return;\n          }\n          this._babylonScene._blockEntityCollection = !!this._assetContainer;\n          babylonGeometry.applyToMesh(babylonMesh);\n          babylonGeometry._parentContainer = this._assetContainer;\n          this._babylonScene._blockEntityCollection = false;\n        });\n      }));\n      const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n      if (primitive.material == undefined) {\n        let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\n        if (!babylonMaterial) {\n          babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\n          this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n          this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\n        }\n        babylonMesh.material = babylonMaterial;\n      } else if (!this.parent.skipMaterials) {\n        const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\n        promises.push(this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, babylonMaterial => {\n          babylonMesh.material = babylonMaterial;\n        }));\n      }\n      promise = Promise.all(promises);\n      if (shouldInstance) {\n        primitive._instanceData = {\n          babylonSourceMesh: babylonMesh,\n          promise: promise\n        };\n      }\n      babylonAbstractMesh = babylonMesh;\n    }\n    GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\n    this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\n    assign(babylonAbstractMesh);\n    this.logClose();\n    return promise.then(() => {\n      return babylonAbstractMesh;\n    });\n  }\n  _loadVertexDataAsync(context, primitive, babylonMesh) {\n    const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    const attributes = primitive.attributes;\n    if (!attributes) {\n      throw new Error(`${context}: Attributes are missing`);\n    }\n    const promises = new Array();\n    const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\n    if (primitive.indices == undefined) {\n      babylonMesh.isUnIndexed = true;\n    } else {\n      const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\n      promises.push(this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then(data => {\n        babylonGeometry.setIndices(data);\n      }));\n    }\n    const loadAttribute = (attribute, kind, callback) => {\n      if (attributes[attribute] == undefined) {\n        return;\n      }\n      babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n      if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n        babylonMesh._delayInfo.push(kind);\n      }\n      const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\n      promises.push(this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then(babylonVertexBuffer => {\n        if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\n          const mmin = accessor.min,\n            mmax = accessor.max;\n          if (mmin !== undefined && mmax !== undefined) {\n            if (accessor.normalized && accessor.componentType !== 5126 /* FLOAT */) {\n              let divider = 1;\n              switch (accessor.componentType) {\n                case 5120 /* BYTE */:\n                  divider = 127.0;\n                  break;\n                case 5121 /* UNSIGNED_BYTE */:\n                  divider = 255.0;\n                  break;\n                case 5122 /* SHORT */:\n                  divider = 32767.0;\n                  break;\n                case 5123 /* UNSIGNED_SHORT */:\n                  divider = 65535.0;\n                  break;\n              }\n              for (let i = 0; i < 3; ++i) {\n                mmin[i] = Math.max(mmin[i] / divider, -1.0);\n                mmax[i] = Math.max(mmax[i] / divider, -1.0);\n              }\n            }\n            const min = TmpVectors.Vector3[0],\n              max = TmpVectors.Vector3[1];\n            min.copyFromFloats(...mmin);\n            max.copyFromFloats(...mmax);\n            babylonGeometry._boundingInfo = new BoundingInfo(min, max);\n            babylonGeometry.useBoundingInfoFromGeometry = true;\n          }\n        }\n        babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\n      }));\n      if (kind == VertexBuffer.MatricesIndicesExtraKind) {\n        babylonMesh.numBoneInfluencers = 8;\n      }\n      if (callback) {\n        callback(accessor);\n      }\n    };\n    loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n    loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n    loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n    loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n    loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n    loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n    loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n    loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n    loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n    loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n    loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n    loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\n    loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\n    loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, accessor => {\n      if (accessor.type === \"VEC4\" /* VEC4 */) {\n        babylonMesh.hasVertexAlpha = true;\n      }\n    });\n    return Promise.all(promises).then(() => {\n      return babylonGeometry;\n    });\n  }\n  _createMorphTargets(context, node, mesh, primitive, babylonMesh) {\n    if (!primitive.targets) {\n      return;\n    }\n    if (node._numMorphTargets == undefined) {\n      node._numMorphTargets = primitive.targets.length;\n    } else if (primitive.targets.length !== node._numMorphTargets) {\n      throw new Error(`${context}: Primitives do not have the same number of targets`);\n    }\n    const targetNames = mesh.extras ? mesh.extras.targetNames : null;\n    babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\n    babylonMesh.morphTargetManager.areUpdatesFrozen = true;\n    for (let index = 0; index < primitive.targets.length; index++) {\n      const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\n      const name = targetNames ? targetNames[index] : `morphTarget${index}`;\n      babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\n      // TODO: tell the target whether it has positions, normals, tangents\n    }\n  }\n\n  _loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry) {\n    if (!primitive.targets) {\n      return Promise.resolve();\n    }\n    const promises = new Array();\n    const morphTargetManager = babylonMesh.morphTargetManager;\n    for (let index = 0; index < morphTargetManager.numTargets; index++) {\n      const babylonMorphTarget = morphTargetManager.getTarget(index);\n      promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\n    }\n    return Promise.all(promises).then(() => {\n      morphTargetManager.areUpdatesFrozen = false;\n    });\n  }\n  _loadMorphTargetVertexDataAsync(context, babylonGeometry, attributes, babylonMorphTarget) {\n    const promises = new Array();\n    const loadAttribute = (attribute, kind, setData) => {\n      if (attributes[attribute] == undefined) {\n        return;\n      }\n      const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\n      if (!babylonVertexBuffer) {\n        return;\n      }\n      const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\n      promises.push(this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then(data => {\n        setData(babylonVertexBuffer, data);\n      }));\n    };\n    loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\n      const positions = new Float32Array(data.length);\n      babylonVertexBuffer.forEach(data.length, (value, index) => {\n        positions[index] = data[index] + value;\n      });\n      babylonMorphTarget.setPositions(positions);\n    });\n    loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\n      const normals = new Float32Array(data.length);\n      babylonVertexBuffer.forEach(normals.length, (value, index) => {\n        normals[index] = data[index] + value;\n      });\n      babylonMorphTarget.setNormals(normals);\n    });\n    loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\n      const tangents = new Float32Array(data.length / 3 * 4);\n      let dataIndex = 0;\n      babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {\n        // Tangent data for morph targets is stored as xyz delta.\n        // The vertexData.tangent is stored as xyzw.\n        // So we need to skip every fourth vertexData.tangent.\n        if ((index + 1) % 4 !== 0) {\n          tangents[dataIndex] = data[dataIndex] + value;\n          dataIndex++;\n        }\n      });\n      babylonMorphTarget.setTangents(tangents);\n    });\n    return Promise.all(promises).then(() => {});\n  }\n  static _LoadTransform(node, babylonNode) {\n    // Ignore the TRS of skinned nodes.\n    // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\n    if (node.skin != undefined) {\n      return;\n    }\n    let position = Vector3.Zero();\n    let rotation = Quaternion.Identity();\n    let scaling = Vector3.One();\n    if (node.matrix) {\n      const matrix = Matrix.FromArray(node.matrix);\n      matrix.decompose(scaling, rotation, position);\n    } else {\n      if (node.translation) {\n        position = Vector3.FromArray(node.translation);\n      }\n      if (node.rotation) {\n        rotation = Quaternion.FromArray(node.rotation);\n      }\n      if (node.scale) {\n        scaling = Vector3.FromArray(node.scale);\n      }\n    }\n    babylonNode.position = position;\n    babylonNode.rotationQuaternion = rotation;\n    babylonNode.scaling = scaling;\n  }\n  _loadSkinAsync(context, node, skin, assign) {\n    const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    if (skin._data) {\n      assign(skin._data.babylonSkeleton);\n      return skin._data.promise;\n    }\n    const skeletonId = `skeleton${skin.index}`;\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\n    babylonSkeleton._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    this._loadBones(context, skin, babylonSkeleton);\n    const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(inverseBindMatricesData => {\n      this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\n    });\n    skin._data = {\n      babylonSkeleton: babylonSkeleton,\n      promise: promise\n    };\n    assign(babylonSkeleton);\n    return promise;\n  }\n  _loadBones(context, skin, babylonSkeleton) {\n    if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\n      const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\n      if (rootNode) {\n        if (skin.skeleton === undefined) {\n          skin.skeleton = rootNode.index;\n        } else {\n          const isParent = (a, b) => {\n            for (; b.parent; b = b.parent) {\n              if (b.parent === a) {\n                return true;\n              }\n            }\n            return false;\n          };\n          const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\n          if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\n            Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\n            skin.skeleton = rootNode.index;\n          }\n        }\n      } else {\n        Logger.Warn(`${context}: Failed to find common root`);\n      }\n    }\n    const babylonBones = {};\n    for (const index of skin.joints) {\n      const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\n      this._loadBone(node, skin, babylonSkeleton, babylonBones);\n    }\n  }\n  _findSkeletonRootNode(context, joints) {\n    if (joints.length === 0) {\n      return null;\n    }\n    const paths = {};\n    for (const index of joints) {\n      const path = new Array();\n      let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\n      while (node.index !== -1) {\n        path.unshift(node);\n        node = node.parent;\n      }\n      paths[index] = path;\n    }\n    let rootNode = null;\n    for (let i = 0;; ++i) {\n      let path = paths[joints[0]];\n      if (i >= path.length) {\n        return rootNode;\n      }\n      const node = path[i];\n      for (let j = 1; j < joints.length; ++j) {\n        path = paths[joints[j]];\n        if (i >= path.length || node !== path[i]) {\n          return rootNode;\n        }\n      }\n      rootNode = node;\n    }\n  }\n  _loadBone(node, skin, babylonSkeleton, babylonBones) {\n    let babylonBone = babylonBones[node.index];\n    if (babylonBone) {\n      return babylonBone;\n    }\n    let parentBabylonBone = null;\n    if (node.index !== skin.skeleton) {\n      if (node.parent && node.parent.index !== -1) {\n        parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\n      } else if (skin.skeleton !== undefined) {\n        Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\n      }\n    }\n    const boneIndex = skin.joints.indexOf(node.index);\n    babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\n    babylonBones[node.index] = babylonBone;\n    // Wait until the scene is loaded to ensure the transform nodes are loaded.\n    this._postSceneLoadActions.push(() => {\n      // Link the Babylon bone with the corresponding Babylon transform node.\n      // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\n      babylonBone.linkTransformNode(node._babylonTransformNode);\n    });\n    return babylonBone;\n  }\n  _loadSkinInverseBindMatricesDataAsync(context, skin) {\n    if (skin.inverseBindMatrices == undefined) {\n      return Promise.resolve(null);\n    }\n    const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\n    return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\n  }\n  _updateBoneMatrices(babylonSkeleton, inverseBindMatricesData) {\n    for (const babylonBone of babylonSkeleton.bones) {\n      const baseMatrix = Matrix.Identity();\n      const boneIndex = babylonBone._index;\n      if (inverseBindMatricesData && boneIndex !== -1) {\n        Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\n        baseMatrix.invertToRef(baseMatrix);\n      }\n      const babylonParentBone = babylonBone.getParent();\n      if (babylonParentBone) {\n        baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\n      }\n      babylonBone.updateMatrix(baseMatrix, false, false);\n      babylonBone._updateDifferenceMatrix(undefined, false);\n    }\n  }\n  _getNodeMatrix(node) {\n    return node.matrix ? Matrix.FromArray(node.matrix) : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());\n  }\n  /**\n   * Loads a glTF camera.\n   * @param context The context when loading the asset\n   * @param camera The glTF camera property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded Babylon camera when the load is complete\n   */\n  loadCameraAsync(context, camera, assign = () => {}) {\n    const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    const promises = new Array();\n    this.logOpen(`${context} ${camera.name || \"\"}`);\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\n    babylonCamera._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    babylonCamera.ignoreParentScaling = true;\n    camera._babylonCamera = babylonCamera;\n    babylonCamera.rotation = new Vector3(0, Math.PI, 0);\n    switch (camera.type) {\n      case \"perspective\" /* PERSPECTIVE */:\n        {\n          const perspective = camera.perspective;\n          if (!perspective) {\n            throw new Error(`${context}: Camera perspective properties are missing`);\n          }\n          babylonCamera.fov = perspective.yfov;\n          babylonCamera.minZ = perspective.znear;\n          babylonCamera.maxZ = perspective.zfar || 0;\n          break;\n        }\n      case \"orthographic\" /* ORTHOGRAPHIC */:\n        {\n          if (!camera.orthographic) {\n            throw new Error(`${context}: Camera orthographic properties are missing`);\n          }\n          babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n          babylonCamera.orthoLeft = -camera.orthographic.xmag;\n          babylonCamera.orthoRight = camera.orthographic.xmag;\n          babylonCamera.orthoBottom = -camera.orthographic.ymag;\n          babylonCamera.orthoTop = camera.orthographic.ymag;\n          babylonCamera.minZ = camera.orthographic.znear;\n          babylonCamera.maxZ = camera.orthographic.zfar;\n          break;\n        }\n      default:\n        {\n          throw new Error(`${context}: Invalid camera type (${camera.type})`);\n        }\n    }\n    GLTFLoader.AddPointerMetadata(babylonCamera, context);\n    this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\n    assign(babylonCamera);\n    this.logClose();\n    return Promise.all(promises).then(() => {\n      return babylonCamera;\n    });\n  }\n  _loadAnimationsAsync() {\n    const animations = this._gltf.animations;\n    if (!animations) {\n      return Promise.resolve();\n    }\n    const promises = new Array();\n    for (let index = 0; index < animations.length; index++) {\n      const animation = animations[index];\n      promises.push(this.loadAnimationAsync(`/animations/${animation.index}`, animation).then(animationGroup => {\n        // Delete the animation group if it ended up not having any animations in it.\n        if (animationGroup.targetedAnimations.length === 0) {\n          animationGroup.dispose();\n        }\n      }));\n    }\n    return Promise.all(promises).then(() => {});\n  }\n  /**\n   * Loads a glTF animation.\n   * @param context The context when loading the asset\n   * @param animation The glTF animation property\n   * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\n   */\n  loadAnimationAsync(context, animation) {\n    const promise = this._extensionsLoadAnimationAsync(context, animation);\n    if (promise) {\n      return promise;\n    }\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\n    babylonAnimationGroup._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    animation._babylonAnimationGroup = babylonAnimationGroup;\n    const promises = new Array();\n    ArrayItem.Assign(animation.channels);\n    ArrayItem.Assign(animation.samplers);\n    for (const channel of animation.channels) {\n      promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\n        babylonTarget.animations = babylonTarget.animations || [];\n        babylonTarget.animations.push(babylonAnimation);\n        babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\n      }));\n    }\n    return Promise.all(promises).then(() => {\n      babylonAnimationGroup.normalize(0);\n      return babylonAnimationGroup;\n    });\n  }\n  /**\n   * @hidden\n   * Loads a glTF animation channel.\n   * @param context The context when loading the asset\n   * @param animationContext The context of the animation when loading the asset\n   * @param animation The glTF animation property\n   * @param channel The glTF animation channel property\n   * @param onLoad Called for each animation loaded\n   * @returns A void promise that resolves when the load is complete\n   */\n  _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {\n    const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\n    if (promise) {\n      return promise;\n    }\n    if (channel.target.node == undefined) {\n      return Promise.resolve();\n    }\n    const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\n    // Ignore animations that have no animation targets.\n    if (channel.target.path === \"weights\" /* WEIGHTS */ && !targetNode._numMorphTargets || channel.target.path !== \"weights\" /* WEIGHTS */ && !targetNode._babylonTransformNode) {\n      return Promise.resolve();\n    }\n    let properties;\n    switch (channel.target.path) {\n      case \"translation\" /* TRANSLATION */:\n        {\n          properties = nodeAnimationData.translation;\n          break;\n        }\n      case \"rotation\" /* ROTATION */:\n        {\n          properties = nodeAnimationData.rotation;\n          break;\n        }\n      case \"scale\" /* SCALE */:\n        {\n          properties = nodeAnimationData.scale;\n          break;\n        }\n      case \"weights\" /* WEIGHTS */:\n        {\n          properties = nodeAnimationData.weights;\n          break;\n        }\n      default:\n        {\n          throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\n        }\n    }\n    const targetInfo = {\n      target: targetNode,\n      properties: properties\n    };\n    return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\n  }\n  /**\n   * @hidden\n   * Loads a glTF animation channel.\n   * @param context The context when loading the asset\n   * @param animationContext The context of the animation when loading the asset\n   * @param animation The glTF animation property\n   * @param channel The glTF animation channel property\n   * @param targetInfo The glTF target and properties\n   * @param onLoad Called for each animation loaded\n   * @returns A void promise that resolves when the load is complete\n   */\n  _loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad) {\n    const fps = this.parent.targetFps;\n    const invfps = 1 / fps;\n    const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\n    return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then(data => {\n      let numAnimations = 0;\n      // Extract the corresponding values from the read value.\n      // GLTF values may be dispatched to several Babylon properties.\n      // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\n      // - albedoColor as Color3(`r`, `g`, `b`)\n      // - alpha as `a`\n      for (const property of targetInfo.properties) {\n        const stride = property.getStride(targetInfo.target);\n        const input = data.input;\n        const output = data.output;\n        const keys = new Array(input.length);\n        let outputOffset = 0;\n        switch (data.interpolation) {\n          case \"STEP\" /* STEP */:\n            {\n              for (let index = 0; index < input.length; index++) {\n                const value = property.getValue(targetInfo.target, output, outputOffset, 1);\n                outputOffset += stride;\n                keys[index] = {\n                  frame: input[index] * fps,\n                  value: value,\n                  interpolation: AnimationKeyInterpolation.STEP\n                };\n              }\n              break;\n            }\n          case \"CUBICSPLINE\" /* CUBICSPLINE */:\n            {\n              for (let index = 0; index < input.length; index++) {\n                const inTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\n                outputOffset += stride;\n                const value = property.getValue(targetInfo.target, output, outputOffset, 1);\n                outputOffset += stride;\n                const outTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\n                outputOffset += stride;\n                keys[index] = {\n                  frame: input[index] * fps,\n                  inTangent: inTangent,\n                  value: value,\n                  outTangent: outTangent\n                };\n              }\n              break;\n            }\n          case \"LINEAR\" /* LINEAR */:\n            {\n              for (let index = 0; index < input.length; index++) {\n                const value = property.getValue(targetInfo.target, output, outputOffset, 1);\n                outputOffset += stride;\n                keys[index] = {\n                  frame: input[index] * fps,\n                  value: value\n                };\n              }\n              break;\n            }\n        }\n        if (outputOffset > 0) {\n          const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\n          property.buildAnimations(targetInfo.target, name, fps, keys, (babylonAnimatable, babylonAnimation) => {\n            ++numAnimations;\n            onLoad(babylonAnimatable, babylonAnimation);\n          });\n        }\n      }\n    });\n  }\n  _loadAnimationSamplerAsync(context, sampler) {\n    if (sampler._data) {\n      return sampler._data;\n    }\n    const interpolation = sampler.interpolation || \"LINEAR\" /* LINEAR */;\n    switch (interpolation) {\n      case \"STEP\" /* STEP */:\n      case \"LINEAR\" /* LINEAR */:\n      case \"CUBICSPLINE\" /* CUBICSPLINE */:\n        {\n          break;\n        }\n      default:\n        {\n          throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\n        }\n    }\n    const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\n    const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\n    sampler._data = Promise.all([this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor), this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor)]).then(([inputData, outputData]) => {\n      return {\n        input: inputData,\n        interpolation: interpolation,\n        output: outputData\n      };\n    });\n    return sampler._data;\n  }\n  /**\n   * Loads a glTF buffer.\n   * @param context The context when loading the asset\n   * @param buffer The glTF buffer property\n   * @param byteOffset The byte offset to use\n   * @param byteLength The byte length to use\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n  loadBufferAsync(context, buffer, byteOffset, byteLength) {\n    const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    if (!buffer._data) {\n      if (buffer.uri) {\n        buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\n      } else {\n        if (!this._bin) {\n          throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n        }\n        buffer._data = this._bin.readAsync(0, buffer.byteLength);\n      }\n    }\n    return buffer._data.then(data => {\n      try {\n        return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\n      } catch (e) {\n        throw new Error(`${context}: ${e.message}`);\n      }\n    });\n  }\n  /**\n   * Loads a glTF buffer view.\n   * @param context The context when loading the asset\n   * @param bufferView The glTF buffer view property\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n  loadBufferViewAsync(context, bufferView) {\n    const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    if (bufferView._data) {\n      return bufferView._data;\n    }\n    const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\n    bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\n    return bufferView._data;\n  }\n  _loadAccessorAsync(context, accessor, constructor) {\n    if (accessor._data) {\n      return accessor._data;\n    }\n    const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\n    const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\n    const length = numComponents * accessor.count;\n    if (accessor.bufferView == undefined) {\n      accessor._data = Promise.resolve(new constructor(length));\n    } else {\n      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n      accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(data => {\n        if (accessor.componentType === 5126 /* FLOAT */ && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\n          return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\n        } else {\n          const typedArray = new constructor(length);\n          VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView.byteStride || byteStride, numComponents, accessor.componentType, typedArray.length, accessor.normalized || false, (value, index) => {\n            typedArray[index] = value;\n          });\n          return typedArray;\n        }\n      });\n    }\n    if (accessor.sparse) {\n      const sparse = accessor.sparse;\n      accessor._data = accessor._data.then(data => {\n        const typedArray = data;\n        const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\n        const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\n        return Promise.all([this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView), this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView)]).then(([indicesData, valuesData]) => {\n          const indices = GLTFLoader._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count);\n          const sparseLength = numComponents * sparse.count;\n          let values;\n          if (accessor.componentType === 5126 /* FLOAT */ && !accessor.normalized) {\n            values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n          } else {\n            const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\n            values = new constructor(sparseLength);\n            VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\n              values[index] = value;\n            });\n          }\n          let valuesIndex = 0;\n          for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\n            let dataIndex = indices[indicesIndex] * numComponents;\n            for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\n              typedArray[dataIndex++] = values[valuesIndex++];\n            }\n          }\n          return typedArray;\n        });\n      });\n    }\n    return accessor._data;\n  }\n  /**\n   * @internal\n   */\n  _loadFloatAccessorAsync(context, accessor) {\n    return this._loadAccessorAsync(context, accessor, Float32Array);\n  }\n  _loadIndicesAccessorAsync(context, accessor) {\n    if (accessor.type !== \"SCALAR\" /* SCALAR */) {\n      throw new Error(`${context}/type: Invalid value ${accessor.type}`);\n    }\n    if (accessor.componentType !== 5121 /* UNSIGNED_BYTE */ && accessor.componentType !== 5123 /* UNSIGNED_SHORT */ && accessor.componentType !== 5125 /* UNSIGNED_INT */) {\n      throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\n    }\n    if (accessor._data) {\n      return accessor._data;\n    }\n    if (accessor.sparse) {\n      const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\n      accessor._data = this._loadAccessorAsync(context, accessor, constructor);\n    } else {\n      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n      accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(data => {\n        return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\n      });\n    }\n    return accessor._data;\n  }\n  _loadVertexBufferViewAsync(bufferView) {\n    if (bufferView._babylonBuffer) {\n      return bufferView._babylonBuffer;\n    }\n    const engine = this._babylonScene.getEngine();\n    bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(data => {\n      return new Buffer(engine, data, false);\n    });\n    return bufferView._babylonBuffer;\n  }\n  _loadVertexAccessorAsync(context, accessor, kind) {\n    var _a;\n    if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {\n      return accessor._babylonVertexBuffer[kind];\n    }\n    if (!accessor._babylonVertexBuffer) {\n      accessor._babylonVertexBuffer = {};\n    }\n    const engine = this._babylonScene.getEngine();\n    if (accessor.sparse) {\n      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(data => {\n        return new VertexBuffer(engine, data, kind, false);\n      });\n    }\n    // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\n    // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\n    else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\n      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(data => {\n        return new VertexBuffer(engine, data, kind, false);\n      });\n    } else {\n      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\n      accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then(babylonBuffer => {\n        const size = GLTFLoader._GetNumComponents(context, accessor.type);\n        return new VertexBuffer(engine, babylonBuffer, kind, false, false, bufferView.byteStride, false, accessor.byteOffset, size, accessor.componentType, accessor.normalized, true, 1, true);\n      });\n    }\n    return accessor._babylonVertexBuffer[kind];\n  }\n  _loadMaterialMetallicRoughnessPropertiesAsync(context, properties, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(`${context}: Material type not supported`);\n    }\n    const promises = new Array();\n    if (properties) {\n      if (properties.baseColorFactor) {\n        babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\n        babylonMaterial.alpha = properties.baseColorFactor[3];\n      } else {\n        babylonMaterial.albedoColor = Color3.White();\n      }\n      babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\n      babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\n      if (properties.baseColorTexture) {\n        promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, texture => {\n          texture.name = `${babylonMaterial.name} (Base Color)`;\n          babylonMaterial.albedoTexture = texture;\n        }));\n      }\n      if (properties.metallicRoughnessTexture) {\n        properties.metallicRoughnessTexture.nonColorData = true;\n        promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, texture => {\n          texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\n          babylonMaterial.metallicTexture = texture;\n        }));\n        babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\n        babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\n        babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\n      }\n    }\n    return Promise.all(promises).then(() => {});\n  }\n  /**\n   * @internal\n   */\n  _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign = () => {}) {\n    const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    material._data = material._data || {};\n    let babylonData = material._data[babylonDrawMode];\n    if (!babylonData) {\n      this.logOpen(`${context} ${material.name || \"\"}`);\n      const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\n      babylonData = {\n        babylonMaterial: babylonMaterial,\n        babylonMeshes: [],\n        promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)\n      };\n      material._data[babylonDrawMode] = babylonData;\n      GLTFLoader.AddPointerMetadata(babylonMaterial, context);\n      this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\n      this.logClose();\n    }\n    if (babylonMesh) {\n      babylonData.babylonMeshes.push(babylonMesh);\n      babylonMesh.onDisposeObservable.addOnce(() => {\n        const index = babylonData.babylonMeshes.indexOf(babylonMesh);\n        if (index !== -1) {\n          babylonData.babylonMeshes.splice(index, 1);\n        }\n      });\n    }\n    assign(babylonData.babylonMaterial);\n    return babylonData.promise.then(() => {\n      return babylonData.babylonMaterial;\n    });\n  }\n  _createDefaultMaterial(name, babylonDrawMode) {\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    const babylonMaterial = new PBRMaterial(name, this._babylonScene);\n    babylonMaterial._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n    babylonMaterial.fillMode = babylonDrawMode;\n    babylonMaterial.enableSpecularAntiAliasing = true;\n    babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\n    babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\n    babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n    babylonMaterial.metallic = 1;\n    babylonMaterial.roughness = 1;\n    return babylonMaterial;\n  }\n  /**\n   * Creates a Babylon material from a glTF material.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonDrawMode The draw mode for the Babylon material\n   * @returns The Babylon material\n   */\n  createMaterial(context, material, babylonDrawMode) {\n    const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    const name = material.name || `material${material.index}`;\n    const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\n    return babylonMaterial;\n  }\n  /**\n   * Loads properties from a glTF material into a Babylon material.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonMaterial The Babylon material\n   * @returns A promise that resolves when the load is complete\n   */\n  loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n    const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    const promises = new Array();\n    promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n    if (material.pbrMetallicRoughness) {\n      promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\n    }\n    this.loadMaterialAlphaProperties(context, material, babylonMaterial);\n    return Promise.all(promises).then(() => {});\n  }\n  /**\n   * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonMaterial The Babylon material\n   * @returns A promise that resolves when the load is complete\n   */\n  loadMaterialBasePropertiesAsync(context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(`${context}: Material type not supported`);\n    }\n    const promises = new Array();\n    babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\n    if (material.doubleSided) {\n      babylonMaterial.backFaceCulling = false;\n      babylonMaterial.twoSidedLighting = true;\n    }\n    if (material.normalTexture) {\n      material.normalTexture.nonColorData = true;\n      promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, texture => {\n        texture.name = `${babylonMaterial.name} (Normal)`;\n        babylonMaterial.bumpTexture = texture;\n      }));\n      babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\n      babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\n      if (material.normalTexture.scale != undefined && babylonMaterial.bumpTexture) {\n        babylonMaterial.bumpTexture.level = material.normalTexture.scale;\n      }\n      babylonMaterial.forceIrradianceInFragment = true;\n    }\n    if (material.occlusionTexture) {\n      material.occlusionTexture.nonColorData = true;\n      promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, texture => {\n        texture.name = `${babylonMaterial.name} (Occlusion)`;\n        babylonMaterial.ambientTexture = texture;\n      }));\n      babylonMaterial.useAmbientInGrayScale = true;\n      if (material.occlusionTexture.strength != undefined) {\n        babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\n      }\n    }\n    if (material.emissiveTexture) {\n      promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, texture => {\n        texture.name = `${babylonMaterial.name} (Emissive)`;\n        babylonMaterial.emissiveTexture = texture;\n      }));\n    }\n    return Promise.all(promises).then(() => {});\n  }\n  /**\n   * Loads the alpha properties from a glTF material into a Babylon material.\n   * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\n   * @param context The context when loading the asset\n   * @param material The glTF material property\n   * @param babylonMaterial The Babylon material\n   */\n  loadMaterialAlphaProperties(context, material, babylonMaterial) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(`${context}: Material type not supported`);\n    }\n    const alphaMode = material.alphaMode || \"OPAQUE\" /* OPAQUE */;\n    switch (alphaMode) {\n      case \"OPAQUE\" /* OPAQUE */:\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\n          break;\n        }\n      case \"MASK\" /* MASK */:\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\n          babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\n          if (babylonMaterial.albedoTexture) {\n            babylonMaterial.albedoTexture.hasAlpha = true;\n          }\n          break;\n        }\n      case \"BLEND\" /* BLEND */:\n        {\n          babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\n          if (babylonMaterial.albedoTexture) {\n            babylonMaterial.albedoTexture.hasAlpha = true;\n            babylonMaterial.useAlphaFromAlbedoTexture = true;\n          }\n          break;\n        }\n      default:\n        {\n          throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\n        }\n    }\n  }\n  /**\n   * Loads a glTF texture info.\n   * @param context The context when loading the asset\n   * @param textureInfo The glTF texture info property\n   * @param assign A function called synchronously after parsing the glTF properties\n   * @returns A promise that resolves with the loaded Babylon texture when the load is complete\n   */\n  loadTextureInfoAsync(context, textureInfo, assign = () => {}) {\n    const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    this.logOpen(`${context}`);\n    if (textureInfo.texCoord >= 6) {\n      throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\n    }\n    const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\n    texture._textureInfo = textureInfo;\n    const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, babylonTexture => {\n      babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\n      GLTFLoader.AddPointerMetadata(babylonTexture, context);\n      this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\n      assign(babylonTexture);\n    });\n    this.logClose();\n    return promise;\n  }\n  /**\n   * @internal\n   */\n  _loadTextureAsync(context, texture, assign = () => {}) {\n    const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    this.logOpen(`${context} ${texture.name || \"\"}`);\n    const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\n    const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\n    const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\n    this.logClose();\n    return promise;\n  }\n  /**\n   * @internal\n   */\n  _createTextureAsync(context, sampler, image, assign = () => {}, textureLoaderOptions, useSRGBBuffer) {\n    const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\n    const promises = new Array();\n    const deferred = new Deferred();\n    this._babylonScene._blockEntityCollection = !!this._assetContainer;\n    const textureCreationOptions = {\n      noMipmap: samplerData.noMipMaps,\n      invertY: false,\n      samplingMode: samplerData.samplingMode,\n      onLoad: () => {\n        if (!this._disposed) {\n          deferred.resolve();\n        }\n      },\n      onError: (message, exception) => {\n        if (!this._disposed) {\n          deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\n        }\n      },\n      mimeType: image.mimeType,\n      loaderOptions: textureLoaderOptions,\n      useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers\n    };\n    const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\n    babylonTexture._parentContainer = this._assetContainer;\n    this._babylonScene._blockEntityCollection = false;\n    promises.push(deferred.promise);\n    promises.push(this.loadImageAsync(`/images/${image.index}`, image).then(data => {\n      const name = image.uri || `${this._fileName}#image${image.index}`;\n      const dataUrl = `data:${this._uniqueRootUrl}${name}`;\n      babylonTexture.updateURL(dataUrl, data);\n    }));\n    babylonTexture.wrapU = samplerData.wrapU;\n    babylonTexture.wrapV = samplerData.wrapV;\n    assign(babylonTexture);\n    return Promise.all(promises).then(() => {\n      return babylonTexture;\n    });\n  }\n  _loadSampler(context, sampler) {\n    if (!sampler._data) {\n      sampler._data = {\n        noMipMaps: sampler.minFilter === 9728 /* NEAREST */ || sampler.minFilter === 9729 /* LINEAR */,\n        samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\n        wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\n        wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)\n      };\n    }\n    return sampler._data;\n  }\n  /**\n   * Loads a glTF image.\n   * @param context The context when loading the asset\n   * @param image The glTF image property\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n  loadImageAsync(context, image) {\n    if (!image._data) {\n      this.logOpen(`${context} ${image.name || \"\"}`);\n      if (image.uri) {\n        image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\n      } else {\n        const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\n        image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n      }\n      this.logClose();\n    }\n    return image._data;\n  }\n  /**\n   * Loads a glTF uri.\n   * @param context The context when loading the asset\n   * @param property The glTF property associated with the uri\n   * @param uri The base64 or relative uri\n   * @returns A promise that resolves with the loaded data when the load is complete\n   */\n  loadUriAsync(context, property, uri) {\n    const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\n    if (extensionPromise) {\n      return extensionPromise;\n    }\n    if (!GLTFLoader._ValidateUri(uri)) {\n      throw new Error(`${context}: '${uri}' is invalid`);\n    }\n    if (IsBase64DataUrl(uri)) {\n      const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\n      this.log(`${context}: Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\n      return Promise.resolve(data);\n    }\n    this.log(`${context}: Loading ${uri}`);\n    return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(url => {\n      return new Promise((resolve, reject) => {\n        this._parent._loadFile(this._babylonScene, url, data => {\n          if (!this._disposed) {\n            this.log(`${context}: Loaded ${uri} (${data.byteLength} bytes)`);\n            resolve(new Uint8Array(data));\n          }\n        }, true, request => {\n          reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\n        });\n      });\n    });\n  }\n  /**\n   * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.\n   * @param babylonObject the Babylon object with _internalMetadata\n   * @param pointer the JSON pointer\n   */\n  static AddPointerMetadata(babylonObject, pointer) {\n    babylonObject.metadata = babylonObject.metadata || {};\n    const metadata = babylonObject._internalMetadata = babylonObject._internalMetadata || {};\n    const gltf = metadata.gltf = metadata.gltf || {};\n    const pointers = gltf.pointers = gltf.pointers || [];\n    pointers.push(pointer);\n  }\n  static _GetTextureWrapMode(context, mode) {\n    // Set defaults if undefined\n    mode = mode == undefined ? 10497 /* REPEAT */ : mode;\n    switch (mode) {\n      case 33071 /* CLAMP_TO_EDGE */:\n        return Texture.CLAMP_ADDRESSMODE;\n      case 33648 /* MIRRORED_REPEAT */:\n        return Texture.MIRROR_ADDRESSMODE;\n      case 10497 /* REPEAT */:\n        return Texture.WRAP_ADDRESSMODE;\n      default:\n        Logger.Warn(`${context}: Invalid value (${mode})`);\n        return Texture.WRAP_ADDRESSMODE;\n    }\n  }\n  static _GetTextureSamplingMode(context, sampler) {\n    // Set defaults if undefined\n    const magFilter = sampler.magFilter == undefined ? 9729 /* LINEAR */ : sampler.magFilter;\n    const minFilter = sampler.minFilter == undefined ? 9987 /* LINEAR_MIPMAP_LINEAR */ : sampler.minFilter;\n    if (magFilter === 9729 /* LINEAR */) {\n      switch (minFilter) {\n        case 9728 /* NEAREST */:\n          return Texture.LINEAR_NEAREST;\n        case 9729 /* LINEAR */:\n          return Texture.LINEAR_LINEAR;\n        case 9984 /* NEAREST_MIPMAP_NEAREST */:\n          return Texture.LINEAR_NEAREST_MIPNEAREST;\n        case 9985 /* LINEAR_MIPMAP_NEAREST */:\n          return Texture.LINEAR_LINEAR_MIPNEAREST;\n        case 9986 /* NEAREST_MIPMAP_LINEAR */:\n          return Texture.LINEAR_NEAREST_MIPLINEAR;\n        case 9987 /* LINEAR_MIPMAP_LINEAR */:\n          return Texture.LINEAR_LINEAR_MIPLINEAR;\n        default:\n          Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n          return Texture.LINEAR_LINEAR_MIPLINEAR;\n      }\n    } else {\n      if (magFilter !== 9728 /* NEAREST */) {\n        Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\n      }\n      switch (minFilter) {\n        case 9728 /* NEAREST */:\n          return Texture.NEAREST_NEAREST;\n        case 9729 /* LINEAR */:\n          return Texture.NEAREST_LINEAR;\n        case 9984 /* NEAREST_MIPMAP_NEAREST */:\n          return Texture.NEAREST_NEAREST_MIPNEAREST;\n        case 9985 /* LINEAR_MIPMAP_NEAREST */:\n          return Texture.NEAREST_LINEAR_MIPNEAREST;\n        case 9986 /* NEAREST_MIPMAP_LINEAR */:\n          return Texture.NEAREST_NEAREST_MIPLINEAR;\n        case 9987 /* LINEAR_MIPMAP_LINEAR */:\n          return Texture.NEAREST_LINEAR_MIPLINEAR;\n        default:\n          Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\n          return Texture.NEAREST_NEAREST_MIPNEAREST;\n      }\n    }\n  }\n  static _GetTypedArrayConstructor(context, componentType) {\n    switch (componentType) {\n      case 5120 /* BYTE */:\n        return Int8Array;\n      case 5121 /* UNSIGNED_BYTE */:\n        return Uint8Array;\n      case 5122 /* SHORT */:\n        return Int16Array;\n      case 5123 /* UNSIGNED_SHORT */:\n        return Uint16Array;\n      case 5125 /* UNSIGNED_INT */:\n        return Uint32Array;\n      case 5126 /* FLOAT */:\n        return Float32Array;\n      default:\n        throw new Error(`${context}: Invalid component type ${componentType}`);\n    }\n  }\n  static _GetTypedArray(context, componentType, bufferView, byteOffset, length) {\n    const buffer = bufferView.buffer;\n    byteOffset = bufferView.byteOffset + (byteOffset || 0);\n    const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\n    const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\n    if (byteOffset % componentTypeLength !== 0) {\n      // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\n      Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\n      return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\n    }\n    return new constructor(buffer, byteOffset, length);\n  }\n  static _GetNumComponents(context, type) {\n    switch (type) {\n      case \"SCALAR\":\n        return 1;\n      case \"VEC2\":\n        return 2;\n      case \"VEC3\":\n        return 3;\n      case \"VEC4\":\n        return 4;\n      case \"MAT2\":\n        return 4;\n      case \"MAT3\":\n        return 9;\n      case \"MAT4\":\n        return 16;\n    }\n    throw new Error(`${context}: Invalid type (${type})`);\n  }\n  static _ValidateUri(uri) {\n    return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\n  }\n  /**\n   * @internal\n   */\n  static _GetDrawMode(context, mode) {\n    if (mode == undefined) {\n      mode = 4 /* TRIANGLES */;\n    }\n\n    switch (mode) {\n      case 0 /* POINTS */:\n        return Material.PointListDrawMode;\n      case 1 /* LINES */:\n        return Material.LineListDrawMode;\n      case 2 /* LINE_LOOP */:\n        return Material.LineLoopDrawMode;\n      case 3 /* LINE_STRIP */:\n        return Material.LineStripDrawMode;\n      case 4 /* TRIANGLES */:\n        return Material.TriangleFillMode;\n      case 5 /* TRIANGLE_STRIP */:\n        return Material.TriangleStripDrawMode;\n      case 6 /* TRIANGLE_FAN */:\n        return Material.TriangleFanDrawMode;\n    }\n    throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\n  }\n  _compileMaterialsAsync() {\n    this._parent._startPerformanceCounter(\"Compile materials\");\n    const promises = new Array();\n    if (this._gltf.materials) {\n      for (const material of this._gltf.materials) {\n        if (material._data) {\n          for (const babylonDrawMode in material._data) {\n            const babylonData = material._data[babylonDrawMode];\n            for (const babylonMesh of babylonData.babylonMeshes) {\n              // Ensure nonUniformScaling is set if necessary.\n              babylonMesh.computeWorldMatrix(true);\n              const babylonMaterial = babylonData.babylonMaterial;\n              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\n              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                useInstances: true\n              }));\n              if (this._parent.useClipPlane) {\n                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                  clipPlane: true\n                }));\n                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, {\n                  clipPlane: true,\n                  useInstances: true\n                }));\n              }\n            }\n          }\n        }\n      }\n    }\n    return Promise.all(promises).then(() => {\n      this._parent._endPerformanceCounter(\"Compile materials\");\n    });\n  }\n  _compileShadowGeneratorsAsync() {\n    this._parent._startPerformanceCounter(\"Compile shadow generators\");\n    const promises = new Array();\n    const lights = this._babylonScene.lights;\n    for (const light of lights) {\n      const generator = light.getShadowGenerator();\n      if (generator) {\n        promises.push(generator.forceCompilationAsync());\n      }\n    }\n    return Promise.all(promises).then(() => {\n      this._parent._endPerformanceCounter(\"Compile shadow generators\");\n    });\n  }\n  _forEachExtensions(action) {\n    for (const extension of this._extensions) {\n      if (extension.enabled) {\n        action(extension);\n      }\n    }\n  }\n  _applyExtensions(property, functionName, actionAsync) {\n    for (const extension of this._extensions) {\n      if (extension.enabled) {\n        const id = `${extension.name}.${functionName}`;\n        const loaderProperty = property;\n        loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\n        const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\n        if (!activeLoaderExtensionFunctions[id]) {\n          activeLoaderExtensionFunctions[id] = true;\n          try {\n            const result = actionAsync(extension);\n            if (result) {\n              return result;\n            }\n          } finally {\n            delete activeLoaderExtensionFunctions[id];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  _extensionsOnLoading() {\n    this._forEachExtensions(extension => extension.onLoading && extension.onLoading());\n  }\n  _extensionsOnReady() {\n    this._forEachExtensions(extension => extension.onReady && extension.onReady());\n  }\n  _extensionsLoadSceneAsync(context, scene) {\n    return this._applyExtensions(scene, \"loadScene\", extension => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\n  }\n  _extensionsLoadNodeAsync(context, node, assign) {\n    return this._applyExtensions(node, \"loadNode\", extension => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\n  }\n  _extensionsLoadCameraAsync(context, camera, assign) {\n    return this._applyExtensions(camera, \"loadCamera\", extension => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\n  }\n  _extensionsLoadVertexDataAsync(context, primitive, babylonMesh) {\n    return this._applyExtensions(primitive, \"loadVertexData\", extension => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\n  }\n  _extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n    return this._applyExtensions(primitive, \"loadMeshPrimitive\", extension => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign));\n  }\n  _extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {\n    return this._applyExtensions(material, \"loadMaterial\", extension => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));\n  }\n  _extensionsCreateMaterial(context, material, babylonDrawMode) {\n    return this._applyExtensions(material, \"createMaterial\", extension => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\n  }\n  _extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial) {\n    return this._applyExtensions(material, \"loadMaterialProperties\", extension => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n  }\n  _extensionsLoadTextureInfoAsync(context, textureInfo, assign) {\n    return this._applyExtensions(textureInfo, \"loadTextureInfo\", extension => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\n  }\n  _extensionsLoadTextureAsync(context, texture, assign) {\n    return this._applyExtensions(texture, \"loadTexture\", extension => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\n  }\n  _extensionsLoadAnimationAsync(context, animation) {\n    return this._applyExtensions(animation, \"loadAnimation\", extension => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\n  }\n  _extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {\n    return this._applyExtensions(animation, \"loadAnimationChannel\", extension => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad));\n  }\n  _extensionsLoadSkinAsync(context, node, skin) {\n    return this._applyExtensions(skin, \"loadSkin\", extension => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\n  }\n  _extensionsLoadUriAsync(context, property, uri) {\n    return this._applyExtensions(property, \"loadUri\", extension => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\n  }\n  _extensionsLoadBufferViewAsync(context, bufferView) {\n    return this._applyExtensions(bufferView, \"loadBufferView\", extension => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\n  }\n  _extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength) {\n    return this._applyExtensions(buffer, \"loadBuffer\", extension => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\n  }\n  /**\n   * Helper method called by a loader extension to load an glTF extension.\n   * @param context The context when loading the asset\n   * @param property The glTF property to load the extension from\n   * @param extensionName The name of the extension to load\n   * @param actionAsync The action to run\n   * @returns The promise returned by actionAsync or null if the extension does not exist\n   */\n  static LoadExtensionAsync(context, property, extensionName, actionAsync) {\n    if (!property.extensions) {\n      return null;\n    }\n    const extensions = property.extensions;\n    const extension = extensions[extensionName];\n    if (!extension) {\n      return null;\n    }\n    return actionAsync(`${context}/extensions/${extensionName}`, extension);\n  }\n  /**\n   * Helper method called by a loader extension to load a glTF extra.\n   * @param context The context when loading the asset\n   * @param property The glTF property to load the extra from\n   * @param extensionName The name of the extension to load\n   * @param actionAsync The action to run\n   * @returns The promise returned by actionAsync or null if the extra does not exist\n   */\n  static LoadExtraAsync(context, property, extensionName, actionAsync) {\n    if (!property.extras) {\n      return null;\n    }\n    const extras = property.extras;\n    const extra = extras[extensionName];\n    if (!extra) {\n      return null;\n    }\n    return actionAsync(`${context}/extras/${extensionName}`, extra);\n  }\n  /**\n   * Checks for presence of an extension.\n   * @param name The name of the extension to check\n   * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\n   */\n  isExtensionUsed(name) {\n    return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\n  }\n  /**\n   * Increments the indentation level and logs a message.\n   * @param message The message to log\n   */\n  logOpen(message) {\n    this._parent._logOpen(message);\n  }\n  /**\n   * Decrements the indentation level.\n   */\n  logClose() {\n    this._parent._logClose();\n  }\n  /**\n   * Logs a message\n   * @param message The message to log\n   */\n  log(message) {\n    this._parent._log(message);\n  }\n  /**\n   * Starts a performance counter.\n   * @param counterName The name of the performance counter\n   */\n  startPerformanceCounter(counterName) {\n    this._parent._startPerformanceCounter(counterName);\n  }\n  /**\n   * Ends a performance counter.\n   * @param counterName The name of the performance counter\n   */\n  endPerformanceCounter(counterName) {\n    this._parent._endPerformanceCounter(counterName);\n  }\n}\nGLTFLoader._RegisteredExtensions = {};\n/**\n * The default glTF sampler.\n */\nGLTFLoader.DefaultSampler = {\n  index: -1\n};\nGLTFFileLoader._CreateGLTF2Loader = parent => new GLTFLoader(parent);","map":{"version":3,"mappings":";;AACA,SAASA,QAAQ,QAAE;AACnB,SAASC,UAAU,EAAEC,OAAO,EAAEC,MAAM,EAAEC,UAAU,QAAE;AAClD,SAASC,MAAM,QAAE;AACjB,SAASC,KAAK,QAAE;AAChB,SAASC,MAAM,QAAE;AACjB,SAASC,UAAU,QAAE;AAIrB,SAASC,yBAAyB,QAAE;AACpC,SAASC,cAAc,QAAE;AACzB,SAASC,IAAI,QAAE;AACf,SAASC,QAAQ,QAAE;AACnB,SAASC,QAAQ,QAAE;AACnB,SAASC,WAAW,QAAE;AAGtB,SAASC,OAAO,QAAE;AAClB,SAASC,aAAa,QAAE;AACxB,SAASC,MAAM,EAAEC,YAAY,QAAE;AAC/B,SAASC,QAAQ,QAAE;AAGnB,SAASC,IAAI,QAAE;AACf,SAASC,WAAW,QAAE;AACtB,SAASC,kBAAkB,QAAE;AA0C7B,SAASC,cAAc,EAAEC,eAAe,EAAEC,8BAA8B,EAAEC,4BAA4B,QAAQ,sBAAoB;AAElI,SAASC,uBAAuB,EAAEC,eAAe,EAAEC,aAAa,QAAE;AAClE,SAASC,MAAM,QAAE;AAEjB,SAASC,YAAY,QAAE;AAGvB,SAASC,iBAAiB,QAAQ,0BAAwB;AA2B1D;AACA,SAASC,SAAS,CAAC,GAAGC,OAAc;EAChC,MAAMC,QAAQ,GAAIC,GAAQ,IAAKA,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ;EAE7D,OAAOF,OAAO,CAACG,MAAM,CAAC,CAACC,IAAI,EAAEF,GAAG,KAAI;IAChCG,MAAM,CAACC,IAAI,CAACJ,GAAG,CAAC,CAACK,OAAO,CAAEC,GAAG,IAAI;MAC7B,MAAMC,IAAI,GAAGL,IAAI,CAACI,GAAG,CAAC;MACtB,MAAME,IAAI,GAAGR,GAAG,CAACM,GAAG,CAAC;MAErB,IAAIG,KAAK,CAACC,OAAO,CAACH,IAAI,CAAC,IAAIE,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;QAC5CN,IAAI,CAACI,GAAG,CAAC,GAAGC,IAAI,CAACI,MAAM,CAAC,GAAGH,IAAI,CAAC;OACnC,MAAM,IAAIT,QAAQ,CAACQ,IAAI,CAAC,IAAIR,QAAQ,CAACS,IAAI,CAAC,EAAE;QACzCN,IAAI,CAACI,GAAG,CAAC,GAAGT,SAAS,CAACU,IAAI,EAAEC,IAAI,CAAC;OACpC,MAAM;QACHN,IAAI,CAACI,GAAG,CAAC,GAAGE,IAAI;;IAExB,CAAC,CAAC;IAEF,OAAON,IAAI;EACf,CAAC,EAAE,EAAE,CAAC;AACV;AAEA;;;AAGA,OAAM,MAAOU,SAAS;EAClB;;;;;;;EAOO,OAAOC,GAAG,CAAIC,OAAe,EAAEC,KAA+B,EAAEC,KAAyB;IAC5F,IAAI,CAACD,KAAK,IAAIC,KAAK,IAAIC,SAAS,IAAI,CAACF,KAAK,CAACC,KAAK,CAAC,EAAE;MAC/C,MAAM,IAAIE,KAAK,CAAC,GAAGJ,OAAO,2BAA2BE,KAAK,GAAG,CAAC;;IAGlE,OAAOD,KAAK,CAACC,KAAK,CAAC;EACvB;EAEA;;;;EAIO,OAAOG,MAAM,CAACJ,KAAoB;IACrC,IAAIA,KAAK,EAAE;MACP,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,CAACK,MAAM,EAAEJ,KAAK,EAAE,EAAE;QAC/CD,KAAK,CAACC,KAAK,CAAC,CAACA,KAAK,GAAGA,KAAK;;;EAGtC;;AAYJ;;;AAGA,OAAM,MAAOK,UAAU;EAyGnB;;;EAGAC,YAAYC,MAAsB;IA3GlC;IACgB,sBAAiB,GAAG,IAAId,KAAK,EAAgB;IAE7D;IACO,oBAAe,GAA6B,IAAI;IAEvD;IACO,mBAAc,GAAY,EAAE;IAEnC;IACO,0BAAqB,GAAG,CAAC;IAGf,gBAAW,GAAG,IAAIA,KAAK,EAAwB;IACxD,cAAS,GAAG,KAAK;IACjB,aAAQ,GAAqB,IAAI;IACjC,cAAS,GAAqB,IAAI;IAClC,mBAAc,GAAqB,IAAI;IAEvC,SAAI,GAA0B,IAAI;IAElC,qBAAgB,GAAmB,IAAI;IACvC,gCAA2B,GAAqC,EAAE;IACzD,0BAAqB,GAAG,IAAIA,KAAK,EAAc;IAqF5D,IAAI,CAACe,OAAO,GAAGD,MAAM;EACzB;EA7EA;;;;;EAKO,OAAOE,iBAAiB,CAACC,IAAY,EAAEC,OAAqD;IAC/F,IAAIN,UAAU,CAACO,mBAAmB,CAACF,IAAI,CAAC,EAAE;MACtChC,MAAM,CAACmC,IAAI,CAAC,4BAA4BH,IAAI,kBAAkB,CAAC;;IAGnEL,UAAU,CAACS,qBAAqB,CAACJ,IAAI,CAAC,GAAG;MACrCC,OAAO,EAAEA;KACZ;EACL;EAEA;;;;;EAKO,OAAOC,mBAAmB,CAACF,IAAY;IAC1C,IAAI,CAACL,UAAU,CAACS,qBAAqB,CAACJ,IAAI,CAAC,EAAE;MACzC,OAAO,KAAK;;IAGhB,OAAOL,UAAU,CAACS,qBAAqB,CAACJ,IAAI,CAAC;IAC7C,OAAO,IAAI;EACf;EAEA;;;EAGA,IAAWK,IAAI;IACX,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MACb,MAAM,IAAId,KAAK,CAAC,4BAA4B,CAAC;;IAGjD,OAAO,IAAI,CAACc,KAAK;EACrB;EAEA;;;EAGA,IAAWC,GAAG;IACV,OAAO,IAAI,CAACC,IAAI;EACpB;EAEA;;;EAGA,IAAWX,MAAM;IACb,OAAO,IAAI,CAACC,OAAO;EACvB;EAEA;;;EAGA,IAAWW,YAAY;IACnB,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;MACrB,MAAM,IAAIlB,KAAK,CAAC,wBAAwB,CAAC;;IAG7C,OAAO,IAAI,CAACkB,aAAa;EAC7B;EAEA;;;EAGA,IAAWC,eAAe;IACtB,OAAO,IAAI,CAACC,gBAAgB;EAChC;EASA;EACOC,OAAO;IACV,IAAI,IAAI,CAACC,SAAS,EAAE;MAChB;;IAGJ,IAAI,CAACA,SAAS,GAAG,IAAI;IAErB,IAAI,CAACC,iBAAiB,CAACrB,MAAM,GAAG,CAAC;IAEjC,IAAI,CAACsB,WAAW,CAACrC,OAAO,CAAEsC,SAAS,IAAKA,SAAS,CAACJ,OAAO,IAAII,SAAS,CAACJ,OAAO,EAAE,CAAC;IACjF,IAAI,CAACG,WAAW,CAACtB,MAAM,GAAG,CAAC;IAE1B,IAAI,CAACY,KAAyB,GAAG,IAAI,CAAC,CAAC;IACxC,IAAI,CAACE,IAAI,GAAG,IAAI;IACf,IAAI,CAACE,aAAiC,GAAG,IAAI,CAAC,CAAC;IAChD,IAAI,CAACE,gBAAgB,GAAG,IAAI;IAC5B,IAAI,CAACM,2BAA2B,GAAG,EAAE;IACrC,IAAI,CAACC,qBAAqB,CAACzB,MAAM,GAAG,CAAC;IAErC,IAAI,CAACI,OAAO,CAACe,OAAO,EAAE;EAC1B;EAEA;;;EAGOO,eAAe,CAClBC,WAAgB,EAChBC,KAAY,EACZC,SAAmC,EACnCC,IAAqB,EACrBC,OAAe,EACfC,UAAuD,EACvDC,QAAQ,GAAG,EAAE;IAEb,OAAOC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAK;MAC/B,IAAI,CAACpB,aAAa,GAAGY,KAAK;MAC1B,IAAI,CAACS,eAAe,GAAGR,SAAS;MAChC,IAAI,CAACS,SAAS,CAACR,IAAI,CAAC;MAEpB,IAAIS,KAAK,GAA4B,IAAI;MAEzC,IAAIZ,WAAW,EAAE;QACb,MAAMa,OAAO,GAA+B,EAAE;QAC9C,IAAI,IAAI,CAAC5B,KAAK,CAAC2B,KAAK,EAAE;UAClB,KAAK,MAAME,IAAI,IAAI,IAAI,CAAC7B,KAAK,CAAC2B,KAAK,EAAE;YACjC,IAAIE,IAAI,CAACnC,IAAI,EAAE;cACXkC,OAAO,CAACC,IAAI,CAACnC,IAAI,CAAC,GAAGmC,IAAI,CAAC7C,KAAK;;;;QAK3C,MAAM8C,KAAK,GAAGf,WAAW,YAAYtC,KAAK,GAAGsC,WAAW,GAAG,CAACA,WAAW,CAAC;QACxEY,KAAK,GAAGG,KAAK,CAACC,GAAG,CAAErC,IAAI,IAAI;UACvB,MAAMmC,IAAI,GAAGD,OAAO,CAAClC,IAAI,CAAC;UAC1B,IAAImC,IAAI,KAAK5C,SAAS,EAAE;YACpB,MAAM,IAAIC,KAAK,CAAC,wBAAwBQ,IAAI,GAAG,CAAC;;UAGpD,OAAOmC,IAAI;QACf,CAAC,CAAC;;MAGN,OAAO,IAAI,CAACG,UAAU,CAACb,OAAO,EAAEE,QAAQ,EAAEM,KAAK,EAAE,MAAK;QAClD,OAAO;UACHM,MAAM,EAAE,IAAI,CAACC,UAAU,EAAE;UACzBC,eAAe,EAAE,EAAE;UACnBC,SAAS,EAAE,IAAI,CAACC,aAAa,EAAE;UAC/BC,eAAe,EAAE,IAAI,CAACC,mBAAmB,EAAE;UAC3CC,MAAM,EAAE,IAAI,CAACC,cAAc;UAC3BC,cAAc,EAAE,IAAI,CAACC,kBAAkB,EAAE;UACzCC,UAAU,EAAE,IAAI,CAACC,cAAc;SAClC;MACL,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;EAGOC,SAAS,CAAC9B,KAAY,EAAEE,IAAqB,EAAEC,OAAe,EAAEC,UAAuD,EAAEC,QAAQ,GAAG,EAAE;IACzI,OAAOC,OAAO,CAACC,OAAO,EAAE,CAACC,IAAI,CAAC,MAAK;MAC/B,IAAI,CAACpB,aAAa,GAAGY,KAAK;MAC1B,IAAI,CAACU,SAAS,CAACR,IAAI,CAAC;MACpB,OAAO,IAAI,CAACc,UAAU,CAACb,OAAO,EAAEE,QAAQ,EAAE,IAAI,EAAE,MAAMpC,SAAS,CAAC;IACpE,CAAC,CAAC;EACN;EAEQ+C,UAAU,CAAIb,OAAe,EAAEE,QAAgB,EAAEM,KAA8B,EAAEoB,UAAmB;IACxG,OAAOzB,OAAO,CAACC,OAAO,EAAE,CACnBC,IAAI,CAAC,MAAK;MACP,IAAI,CAACwB,QAAQ,GAAG7B,OAAO;MACvB,IAAI,CAAC8B,cAAc,GAAG,CAAC9B,OAAO,CAAC+B,UAAU,CAAC,OAAO,CAAC,IAAI7B,QAAQ,GAAGF,OAAO,GAAG,GAAGA,OAAO,GAAGgC,IAAI,CAACC,GAAG,EAAE,GAAG;MACrG,IAAI,CAACC,SAAS,GAAGhC,QAAQ;MAEzB,IAAI,CAACiC,eAAe,EAAE;MACtB,IAAI,CAACC,gBAAgB,EAAE;MAEvB,MAAMC,yBAAyB,GAAG,GAAGpG,eAAe,CAACA,eAAe,CAACqG,OAAO,CAAC,OAAOrG,eAAe,CAACA,eAAe,CAACsG,KAAK,CAAC,EAAE;MAC5H,MAAMC,4BAA4B,GAAG,GAAGvG,eAAe,CAACA,eAAe,CAACqG,OAAO,CAAC,OAAOrG,eAAe,CAACA,eAAe,CAACwG,QAAQ,CAAC,EAAE;MAElI,IAAI,CAACpE,OAAO,CAACqE,wBAAwB,CAACL,yBAAyB,CAAC;MAChE,IAAI,CAAChE,OAAO,CAACqE,wBAAwB,CAACF,4BAA4B,CAAC;MAEnE,IAAI,CAACnE,OAAO,CAACsE,SAAS,CAAC1G,eAAe,CAACqG,OAAO,CAAC;MAC/C,IAAI,CAACM,oBAAoB,EAAE;MAE3B,MAAMC,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;MAE1C;MACA,MAAMwF,8BAA8B,GAAG,IAAI,CAAC7D,aAAa,CAAC8D,2BAA2B;MACrF,IAAI,CAAC9D,aAAa,CAAC8D,2BAA2B,GAAG,IAAI;MAErD,IAAI,CAAC,IAAI,CAAC3E,MAAM,CAAC4E,iBAAiB,EAAE;QAChC,IAAIxC,KAAK,EAAE;UACPqC,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACC,cAAc,CAAC,QAAQ,EAAE;YAAE1C,KAAK,EAAEA,KAAK;YAAE3C,KAAK,EAAE,CAAC;UAAC,CAAE,CAAC,CAAC;SAC5E,MAAM,IAAI,IAAI,CAACgB,KAAK,CAACgB,KAAK,IAAI/B,SAAS,IAAK,IAAI,CAACe,KAAK,CAACsE,MAAM,IAAI,IAAI,CAACtE,KAAK,CAACsE,MAAM,CAAC,CAAC,CAAE,EAAE;UACrF,MAAMtD,KAAK,GAAGpC,SAAS,CAACC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAACmB,KAAK,CAACsE,MAAM,EAAE,IAAI,CAACtE,KAAK,CAACgB,KAAK,IAAI,CAAC,CAAC;UAC/EgD,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACC,cAAc,CAAC,WAAWrD,KAAK,CAAChC,KAAK,EAAE,EAAEgC,KAAK,CAAC,CAAC;;;MAI3E,IAAI,CAAC,IAAI,CAACzB,MAAM,CAACgF,aAAa,IAAI,IAAI,CAAChF,MAAM,CAACiF,gBAAgB,IAAI,IAAI,CAACxE,KAAK,CAACyE,SAAS,EAAE;QACpF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC1E,KAAK,CAACyE,SAAS,CAACrF,MAAM,EAAE,EAAEsF,CAAC,EAAE;UAClD,MAAMC,QAAQ,GAAG,IAAI,CAAC3E,KAAK,CAACyE,SAAS,CAACC,CAAC,CAAC;UACxC,MAAM5F,OAAO,GAAG,aAAa,GAAG4F,CAAC;UACjC,MAAME,eAAe,GAAGnI,QAAQ,CAACoI,gBAAgB;UAEjDb,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACU,kBAAkB,CAAChG,OAAO,EAAE6F,QAAQ,EAAE,IAAI,EAAEC,eAAe,EAAE,MAAK,CAAE,CAAC,CAAC,CAAC;;;MAIlG;MACA,IAAI,CAACxE,aAAa,CAAC8D,2BAA2B,GAAGD,8BAA8B;MAE/E,IAAI,IAAI,CAACzE,OAAO,CAACuF,gBAAgB,EAAE;QAC/Bf,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACY,sBAAsB,EAAE,CAAC;;MAGhD,IAAI,IAAI,CAACxF,OAAO,CAACyF,uBAAuB,EAAE;QACtCjB,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACc,6BAA6B,EAAE,CAAC;;MAGvD,MAAMC,aAAa,GAAG7D,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;QAClD,IAAI,IAAI,CAAClB,gBAAgB,EAAE;UACvB,IAAI,CAACA,gBAAgB,CAAC+E,UAAU,CAAC,IAAI,CAAC;;QAG1C,IAAI,CAACC,kBAAkB,EAAE;QACzB,IAAI,CAAC9F,OAAO,CAACsE,SAAS,CAAC1G,eAAe,CAACsG,KAAK,CAAC;QAE7C,IAAI,CAAC6B,gBAAgB,EAAE;QAEvB,OAAOxC,UAAU,EAAE;MACvB,CAAC,CAAC;MAEF,OAAOoC,aAAa,CAAC3D,IAAI,CAAEgE,MAAM,IAAI;QACjC,IAAI,CAAChG,OAAO,CAACiG,sBAAsB,CAACjC,yBAAyB,CAAC;QAE9DtH,KAAK,CAACwJ,YAAY,CAAC,MAAK;UACpB,IAAI,CAAC,IAAI,CAAClF,SAAS,EAAE;YACjBc,OAAO,CAAC8D,GAAG,CAAC,IAAI,CAAC3E,iBAAiB,CAAC,CAACe,IAAI,CACpC,MAAK;cACD,IAAI,CAAChC,OAAO,CAACiG,sBAAsB,CAAC9B,4BAA4B,CAAC;cAEjE,IAAI,CAACnE,OAAO,CAACsE,SAAS,CAAC1G,eAAe,CAACwG,QAAQ,CAAC;cAEhD,IAAI,CAACpE,OAAO,CAACmG,oBAAoB,CAACC,eAAe,CAAC3G,SAAS,CAAC;cAC5D,IAAI,CAACO,OAAO,CAACmG,oBAAoB,CAACE,KAAK,EAAE;cAEzC,IAAI,CAACtF,OAAO,EAAE;YAClB,CAAC,EACAuF,KAAK,IAAI;cACN,IAAI,CAACtG,OAAO,CAACuG,iBAAiB,CAACH,eAAe,CAACE,KAAK,CAAC;cACrD,IAAI,CAACtG,OAAO,CAACuG,iBAAiB,CAACF,KAAK,EAAE;cAEtC,IAAI,CAACtF,OAAO,EAAE;YAClB,CAAC,CACJ;;QAET,CAAC,CAAC;QAEF,OAAOiF,MAAM;MACjB,CAAC,CAAC;IACN,CAAC,CAAC,CACDQ,KAAK,CAAEF,KAAK,IAAI;MACb,IAAI,CAAC,IAAI,CAACtF,SAAS,EAAE;QACjB,IAAI,CAAChB,OAAO,CAACuG,iBAAiB,CAACH,eAAe,CAACE,KAAK,CAAC;QACrD,IAAI,CAACtG,OAAO,CAACuG,iBAAiB,CAACF,KAAK,EAAE;QAEtC,IAAI,CAACtF,OAAO,EAAE;;MAGlB,MAAMuF,KAAK;IACf,CAAC,CAAC;EACV;EAEQpE,SAAS,CAACR,IAAqB;IACnC,IAAI,CAAClB,KAAK,GAAGkB,IAAI,CAAC+E,IAAa;IAC/B,IAAI,CAACC,UAAU,EAAE;IAEjB,IAAIhF,IAAI,CAACjB,GAAG,EAAE;MACV,MAAMkG,OAAO,GAAG,IAAI,CAACnG,KAAK,CAACmG,OAAO;MAClC,IAAIA,OAAO,IAAIA,OAAO,CAAC,CAAC,CAAC,IAAI,CAACA,OAAO,CAAC,CAAC,CAAC,CAACC,GAAG,EAAE;QAC1C,MAAMC,YAAY,GAAGF,OAAO,CAAC,CAAC,CAAC;QAC/B,IAAIE,YAAY,CAACC,UAAU,GAAGpF,IAAI,CAACjB,GAAG,CAACqG,UAAU,GAAG,CAAC,IAAID,YAAY,CAACC,UAAU,GAAGpF,IAAI,CAACjB,GAAG,CAACqG,UAAU,EAAE;UACpG5I,MAAM,CAACmC,IAAI,CAAC,yBAAyBwG,YAAY,CAACC,UAAU,4CAA4CpF,IAAI,CAACjB,GAAG,CAACqG,UAAU,GAAG,CAAC;;QAGnI,IAAI,CAACpG,IAAI,GAAGgB,IAAI,CAACjB,GAAG;OACvB,MAAM;QACHvC,MAAM,CAACmC,IAAI,CAAC,sBAAsB,CAAC;;;EAG/C;EAEQqG,UAAU;IACdtH,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACuG,SAAS,CAAC;IACtC3H,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACwG,UAAU,CAAC;IACvC5H,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACmG,OAAO,CAAC;IACpCvH,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACyG,WAAW,CAAC;IACxC7H,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC0G,OAAO,CAAC;IACpC9H,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC2G,MAAM,CAAC;IACnC/H,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACyE,SAAS,CAAC;IACtC7F,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACiC,MAAM,CAAC;IACnCrD,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC2B,KAAK,CAAC;IAClC/C,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC4G,QAAQ,CAAC;IACrChI,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAACsE,MAAM,CAAC;IACnC1F,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC6G,KAAK,CAAC;IAClCjI,SAAS,CAACO,MAAM,CAAC,IAAI,CAACa,KAAK,CAAC8G,QAAQ,CAAC;IAErC,IAAI,IAAI,CAAC9G,KAAK,CAAC2B,KAAK,EAAE;MAClB,MAAMoF,WAAW,GAAgC,EAAE;MACnD,KAAK,MAAMlF,IAAI,IAAI,IAAI,CAAC7B,KAAK,CAAC2B,KAAK,EAAE;QACjC,IAAIE,IAAI,CAACmF,QAAQ,EAAE;UACf,KAAK,MAAMhI,KAAK,IAAI6C,IAAI,CAACmF,QAAQ,EAAE;YAC/BD,WAAW,CAAC/H,KAAK,CAAC,GAAG6C,IAAI,CAAC7C,KAAK;;;;MAK3C,MAAMiI,QAAQ,GAAG,IAAI,CAACC,eAAe,EAAE;MACvC,KAAK,MAAMrF,IAAI,IAAI,IAAI,CAAC7B,KAAK,CAAC2B,KAAK,EAAE;QACjC,MAAMwF,WAAW,GAAGJ,WAAW,CAAClF,IAAI,CAAC7C,KAAK,CAAC;QAC3C6C,IAAI,CAACtC,MAAM,GAAG4H,WAAW,KAAKlI,SAAS,GAAGgI,QAAQ,GAAG,IAAI,CAACjH,KAAK,CAAC2B,KAAK,CAACwF,WAAW,CAAC;;;EAG9F;EAEQ7D,eAAe;IACnB,KAAK,MAAM5D,IAAI,IAAIL,UAAU,CAACS,qBAAqB,EAAE;MACjD,MAAMa,SAAS,GAAGtB,UAAU,CAACS,qBAAqB,CAACJ,IAAI,CAAC,CAACC,OAAO,CAAC,IAAI,CAAC;MACtE,IAAIgB,SAAS,CAACjB,IAAI,KAAKA,IAAI,EAAE;QACzBhC,MAAM,CAACmC,IAAI,CAAC,sFAAsFc,SAAS,CAACjB,IAAI,QAAQA,IAAI,EAAE,CAAC;;MAGnI,IAAI,CAACgB,WAAW,CAAC0D,IAAI,CAACzD,SAAS,CAAC;MAChC,IAAI,CAACnB,OAAO,CAAC4H,2BAA2B,CAACxB,eAAe,CAACjF,SAAS,CAAC;;IAGvE,IAAI,CAACD,WAAW,CAAC2G,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,CAACD,CAAC,CAACE,KAAK,IAAIC,MAAM,CAACC,SAAS,KAAKH,CAAC,CAACC,KAAK,IAAIC,MAAM,CAACC,SAAS,CAAC,CAAC;IAC9F,IAAI,CAAClI,OAAO,CAAC4H,2BAA2B,CAACvB,KAAK,EAAE;EACpD;EAEQtC,gBAAgB;IACpB,IAAI,IAAI,CAACvD,KAAK,CAAC2H,kBAAkB,EAAE;MAC/B,KAAK,MAAMjI,IAAI,IAAI,IAAI,CAACM,KAAK,CAAC2H,kBAAkB,EAAE;QAC9C,MAAMC,SAAS,GAAG,IAAI,CAAClH,WAAW,CAACmH,IAAI,CAAElH,SAAS,IAAKA,SAAS,CAACjB,IAAI,KAAKA,IAAI,IAAIiB,SAAS,CAACmH,OAAO,CAAC;QACpG,IAAI,CAACF,SAAS,EAAE;UACZ,MAAM,IAAI1I,KAAK,CAAC,qBAAqBQ,IAAI,mBAAmB,CAAC;;;;EAI7E;EAEQwH,eAAe;IACnB,IAAI,CAAC9G,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;IAClE,IAAI,CAACnB,gBAAgB,GAAG,IAAItD,IAAI,CAAC,UAAU,EAAE,IAAI,CAACoD,aAAa,CAAC;IAChE,IAAI,CAACE,gBAAgB,CAAC0H,gBAAgB,GAAG,IAAI,CAACvG,eAAe;IAC7D,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;IACjD,IAAI,CAACzH,gBAAgB,CAAC+E,UAAU,CAAC,KAAK,CAAC;IAEvC,MAAM4B,QAAQ,GAAU;MACpBgB,qBAAqB,EAAE,IAAI,CAAC3H,gBAAgB;MAC5CtB,KAAK,EAAE,CAAC;KACX;IAED,QAAQ,IAAI,CAACQ,OAAO,CAAC0I,oBAAoB;MACrC,KAAK7K,8BAA8B,CAAC8K,IAAI;QAAE;UACtC,IAAI,CAAC,IAAI,CAAC/H,aAAa,CAACgI,oBAAoB,EAAE;YAC1CnB,QAAQ,CAACoB,QAAQ,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAChCpB,QAAQ,CAACqB,KAAK,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;YAC3BjJ,UAAU,CAACkJ,cAAc,CAACtB,QAAQ,EAAE,IAAI,CAAC3G,gBAAgB,CAAC;;UAE9D;;MAEJ,KAAKjD,8BAA8B,CAACmL,kBAAkB;QAAE;UACpD,IAAI,CAACpI,aAAa,CAACgI,oBAAoB,GAAG,IAAI;UAC9C;;MAEJ;QAAS;UACL,MAAM,IAAIlJ,KAAK,CAAC,mCAAmC,IAAI,CAACM,OAAO,CAAC0I,oBAAoB,GAAG,CAAC;;IAC3F;IAGL,IAAI,CAAC1I,OAAO,CAACiJ,sBAAsB,CAAC7C,eAAe,CAAC,IAAI,CAACtF,gBAAgB,CAAC;IAC1E,OAAO2G,QAAQ;EACnB;EAEA;;;;;;EAMO5C,cAAc,CAACvF,OAAe,EAAEkC,KAAa;IAChD,MAAM0H,gBAAgB,GAAG,IAAI,CAACC,yBAAyB,CAAC7J,OAAO,EAAEkC,KAAK,CAAC;IACvE,IAAI0H,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,MAAM1E,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,IAAI,CAACmK,OAAO,CAAC,GAAG9J,OAAO,IAAIkC,KAAK,CAACtB,IAAI,IAAI,EAAE,EAAE,CAAC;IAE9C,IAAIsB,KAAK,CAACW,KAAK,EAAE;MACb,KAAK,MAAM3C,KAAK,IAAIgC,KAAK,CAACW,KAAK,EAAE;QAC7B,MAAME,IAAI,GAAGjD,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,UAAUE,KAAK,EAAE,EAAE,IAAI,CAACgB,KAAK,CAAC2B,KAAK,EAAE3C,KAAK,CAAC;QAChFgF,QAAQ,CAACI,IAAI,CACT,IAAI,CAACyE,aAAa,CAAC,UAAUhH,IAAI,CAAC7C,KAAK,EAAE,EAAE6C,IAAI,EAAGiH,WAAW,IAAI;UAC7DA,WAAW,CAACvJ,MAAM,GAAG,IAAI,CAACe,gBAAgB;QAC9C,CAAC,CAAC,CACL;;;IAIT,KAAK,MAAMyI,MAAM,IAAI,IAAI,CAAClI,qBAAqB,EAAE;MAC7CkI,MAAM,EAAE;;IAGZ/E,QAAQ,CAACI,IAAI,CAAC,IAAI,CAAC4E,oBAAoB,EAAE,CAAC;IAE1C,IAAI,CAACC,QAAQ,EAAE;IAEf,OAAO3H,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EAC/C;EAEQ0H,iBAAiB,CAACrH,IAAW,EAAEsH,QAA6C;IAChF,IAAItH,IAAI,CAACuH,uBAAuB,EAAE;MAC9B,KAAK,MAAMN,WAAW,IAAIjH,IAAI,CAACuH,uBAAuB,EAAE;QACpDD,QAAQ,CAACL,WAAW,CAAC;;;EAGjC;EAEQjG,cAAc;IAClB,MAAMD,UAAU,GAAG,IAAInE,KAAK,EAAY;IAExC,MAAMkD,KAAK,GAAG,IAAI,CAAC3B,KAAK,CAAC2B,KAAK;IAC9B,IAAIA,KAAK,EAAE;MACP,KAAK,MAAME,IAAI,IAAIF,KAAK,EAAE;QACtB,IAAI,CAACuH,iBAAiB,CAACrH,IAAI,EAAGiH,WAAW,IAAI;UACzC,MAAMO,QAAQ,GAAIP,WAAoB,CAACO,QAAQ;UAC/C,IAAIA,QAAQ,IAAIzG,UAAU,CAAC0G,OAAO,CAACD,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;YACjDzG,UAAU,CAACwB,IAAI,CAACiF,QAAQ,CAAC;;QAEjC,CAAC,CAAC;;;IAIV,OAAOzG,UAAU;EACrB;EAEQV,UAAU;IACd,MAAMD,MAAM,GAAG,IAAIxD,KAAK,EAAgB;IAExC;IACA,IAAI,IAAI,CAAC6B,gBAAgB,EAAE;MACvB2B,MAAM,CAACmC,IAAI,CAAC,IAAI,CAAC9D,gBAAgB,CAAC;;IAGtC,MAAMqB,KAAK,GAAG,IAAI,CAAC3B,KAAK,CAAC2B,KAAK;IAC9B,IAAIA,KAAK,EAAE;MACP,KAAK,MAAME,IAAI,IAAIF,KAAK,EAAE;QACtB,IAAI,CAACuH,iBAAiB,CAACrH,IAAI,EAAGiH,WAAW,IAAI;UACzC7G,MAAM,CAACmC,IAAI,CAAC0E,WAAW,CAAC;QAC5B,CAAC,CAAC;;;IAIV,OAAO7G,MAAM;EACjB;EAEQU,kBAAkB;IACtB,MAAMD,cAAc,GAAG,IAAIjE,KAAK,EAAiB;IAEjD,MAAMkD,KAAK,GAAG,IAAI,CAAC3B,KAAK,CAAC2B,KAAK;IAC9B,IAAIA,KAAK,EAAE;MACP,KAAK,MAAME,IAAI,IAAIF,KAAK,EAAE;QACtB,IAAIE,IAAI,CAACoG,qBAAqB,IAAIpG,IAAI,CAACoG,qBAAqB,CAACsB,YAAY,EAAE,KAAK,eAAe,EAAE;UAC7F7G,cAAc,CAAC0B,IAAI,CAACvC,IAAI,CAACoG,qBAAqB,CAAC;;QAEnD,IAAIpG,IAAI,CAAC2H,4BAA4B,EAAE;UACnC9G,cAAc,CAAC0B,IAAI,CAACvC,IAAI,CAAC2H,4BAA4B,CAAC;;;;IAKlE,OAAO9G,cAAc;EACzB;EAEQL,aAAa;IACjB,MAAMD,SAAS,GAAG,IAAI3D,KAAK,EAAY;IAEvC,MAAMoI,KAAK,GAAG,IAAI,CAAC7G,KAAK,CAAC6G,KAAK;IAC9B,IAAIA,KAAK,EAAE;MACP,KAAK,MAAM4C,IAAI,IAAI5C,KAAK,EAAE;QACtB,IAAI4C,IAAI,CAACC,KAAK,EAAE;UACZtH,SAAS,CAACgC,IAAI,CAACqF,IAAI,CAACC,KAAK,CAACC,eAAe,CAAC;;;;IAKtD,OAAOvH,SAAS;EACpB;EAEQG,mBAAmB;IACvB,MAAMD,eAAe,GAAG,IAAI7D,KAAK,EAAkB;IAEnD,MAAM+H,UAAU,GAAG,IAAI,CAACxG,KAAK,CAACwG,UAAU;IACxC,IAAIA,UAAU,EAAE;MACZ,KAAK,MAAMoD,SAAS,IAAIpD,UAAU,EAAE;QAChC,IAAIoD,SAAS,CAACC,sBAAsB,EAAE;UAClCvH,eAAe,CAAC8B,IAAI,CAACwF,SAAS,CAACC,sBAAsB,CAAC;;;;IAKlE,OAAOvH,eAAe;EAC1B;EAEQiD,gBAAgB;IACpB,QAAQ,IAAI,CAAC/F,OAAO,CAACsK,kBAAkB;MACnC,KAAKxM,4BAA4B,CAACyM,IAAI;QAAE;UACpC;UACA;;MAEJ,KAAKzM,4BAA4B,CAAC0M,KAAK;QAAE;UACrC,MAAMC,sBAAsB,GAAG,IAAI,CAAC1H,mBAAmB,EAAE;UACzD,IAAI0H,sBAAsB,CAAC7K,MAAM,KAAK,CAAC,EAAE;YACrC6K,sBAAsB,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,IAAI,CAAC;;UAEzC;;MAEJ,KAAK5M,4BAA4B,CAAC6M,GAAG;QAAE;UACnC,MAAMF,sBAAsB,GAAG,IAAI,CAAC1H,mBAAmB,EAAE;UACzD,KAAK,MAAM6H,qBAAqB,IAAIH,sBAAsB,EAAE;YACxDG,qBAAqB,CAACF,KAAK,CAAC,IAAI,CAAC;;UAErC;;MAEJ;QAAS;UACLxM,MAAM,CAACwB,KAAK,CAAC,iCAAiC,IAAI,CAACM,OAAO,CAACsK,kBAAkB,GAAG,CAAC;UACjF;;IACH;EAET;EAEA;;;;;;;EAOOjB,aAAa,CAAC/J,OAAe,EAAE+C,IAAW,EAAEwI,SAAwD,MAAK,CAAE,CAAC;IAC/G,MAAM3B,gBAAgB,GAAG,IAAI,CAAC4B,wBAAwB,CAACxL,OAAO,EAAE+C,IAAI,EAAEwI,MAAM,CAAC;IAC7E,IAAI3B,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI7G,IAAI,CAACoG,qBAAqB,EAAE;MAC5B,MAAM,IAAI/I,KAAK,CAAC,GAAGJ,OAAO,oCAAoC,CAAC;;IAGnE,MAAMkF,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,IAAI,CAACmK,OAAO,CAAC,GAAG9J,OAAO,IAAI+C,IAAI,CAACnC,IAAI,IAAI,EAAE,EAAE,CAAC;IAE7C,MAAM6K,QAAQ,GAAIC,oBAAmC,IAAI;MACrDnL,UAAU,CAACoL,kBAAkB,CAACD,oBAAoB,EAAE1L,OAAO,CAAC;MAC5DO,UAAU,CAACkJ,cAAc,CAAC1G,IAAI,EAAE2I,oBAAoB,CAAC;MAErD,IAAI3I,IAAI,CAAC6I,MAAM,IAAIzL,SAAS,EAAE;QAC1B,MAAMyL,MAAM,GAAG9L,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,SAAS,EAAE,IAAI,CAACkB,KAAK,CAAC0G,OAAO,EAAE7E,IAAI,CAAC6I,MAAM,CAAC;QAClF1G,QAAQ,CAACI,IAAI,CACT,IAAI,CAACuG,eAAe,CAAC,YAAYD,MAAM,CAAC1L,KAAK,EAAE,EAAE0L,MAAM,EAAGE,aAAa,IAAI;UACvEA,aAAa,CAACrL,MAAM,GAAGiL,oBAAoB;QAC/C,CAAC,CAAC,CACL;;MAGL,IAAI3I,IAAI,CAACmF,QAAQ,EAAE;QACf,KAAK,MAAMhI,KAAK,IAAI6C,IAAI,CAACmF,QAAQ,EAAE;UAC/B,MAAM6D,SAAS,GAAGjM,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,aAAaE,KAAK,EAAE,EAAE,IAAI,CAACgB,KAAK,CAAC2B,KAAK,EAAE3C,KAAK,CAAC;UACxFgF,QAAQ,CAACI,IAAI,CACT,IAAI,CAACyE,aAAa,CAAC,UAAUgC,SAAS,CAAC7L,KAAK,EAAE,EAAE6L,SAAS,EAAGC,gBAAgB,IAAI;YAC5EA,gBAAgB,CAACvL,MAAM,GAAGiL,oBAAoB;UAClD,CAAC,CAAC,CACL;;;MAITH,MAAM,CAACG,oBAAoB,CAAC;IAChC,CAAC;IAED,IAAI3I,IAAI,CAACkJ,IAAI,IAAI9L,SAAS,IAAI4C,IAAI,CAAC4H,IAAI,IAAIxK,SAAS,EAAE;MAClD,MAAM+L,QAAQ,GAAGnJ,IAAI,CAACnC,IAAI,IAAI,OAAOmC,IAAI,CAAC7C,KAAK,EAAE;MACjD,IAAI,CAACoB,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;MAClE,MAAMwJ,aAAa,GAAG,IAAIrO,aAAa,CAACoO,QAAQ,EAAE,IAAI,CAAC5K,aAAa,CAAC;MACrE6K,aAAa,CAACjD,gBAAgB,GAAG,IAAI,CAACvG,eAAe;MACrD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;MACjD,IAAIlG,IAAI,CAACkJ,IAAI,IAAI9L,SAAS,EAAE;QACxB4C,IAAI,CAACoG,qBAAqB,GAAGgD,aAAa;OAC7C,MAAM;QACHpJ,IAAI,CAAC2H,4BAA4B,GAAGyB,aAAa;;MAErDV,QAAQ,CAACU,aAAa,CAAC;;IAG3B,IAAIpJ,IAAI,CAACkJ,IAAI,IAAI9L,SAAS,EAAE;MACxB,IAAI4C,IAAI,CAAC4H,IAAI,IAAIxK,SAAS,EAAE;QACxB,MAAM8L,IAAI,GAAGnM,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,OAAO,EAAE,IAAI,CAACkB,KAAK,CAACiC,MAAM,EAAEJ,IAAI,CAACkJ,IAAI,CAAC;QAC3E/G,QAAQ,CAACI,IAAI,CAAC,IAAI,CAAC8G,cAAc,CAAC,WAAWH,IAAI,CAAC/L,KAAK,EAAE,EAAE6C,IAAI,EAAEkJ,IAAI,EAAER,QAAQ,CAAC,CAAC;OACpF,MAAM;QACH;QACA;QACA;QAEA,MAAMQ,IAAI,GAAGnM,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,OAAO,EAAE,IAAI,CAACkB,KAAK,CAACiC,MAAM,EAAEJ,IAAI,CAACkJ,IAAI,CAAC;QAC3E/G,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC8G,cAAc,CAAC,WAAWH,IAAI,CAAC/L,KAAK,EAAE,EAAE6C,IAAI,EAAEkJ,IAAI,EAAGP,oBAAoB,IAAI;UAC9E,MAAMW,2BAA2B,GAAGtJ,IAAI,CAAC2H,4BAA6B;UAEtE;UACAgB,oBAAoB,CAACY,QAAQ,GAAGvN,SAAS,CAACsN,2BAA2B,CAACC,QAAQ,EAAEZ,oBAAoB,CAACY,QAAQ,IAAI,EAAE,CAAC;UAEpH,MAAM3B,IAAI,GAAG7K,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,OAAO,EAAE,IAAI,CAACkB,KAAK,CAAC6G,KAAK,EAAEhF,IAAI,CAAC4H,IAAI,CAAC;UAC1EzF,QAAQ,CAACI,IAAI,CACT,IAAI,CAACiH,cAAc,CAAC,UAAU5B,IAAI,CAACzK,KAAK,EAAE,EAAE6C,IAAI,EAAE4H,IAAI,EAAGE,eAAe,IAAI;YACxE,IAAI,CAACT,iBAAiB,CAACrH,IAAI,EAAGiH,WAAW,IAAI;cACzCA,WAAW,CAACwC,QAAQ,GAAG3B,eAAe;YAC1C,CAAC,CAAC;YAEF;YACA,IAAI,CAAC9I,qBAAqB,CAACuD,IAAI,CAAC,MAAK;cACjC,IAAIqF,IAAI,CAAC6B,QAAQ,IAAIrM,SAAS,EAAE;gBAC5B;gBACA;gBACA,MAAMsM,UAAU,GAAG3M,SAAS,CAACC,GAAG,CAAC,UAAU4K,IAAI,CAACzK,KAAK,WAAW,EAAE,IAAI,CAACgB,KAAK,CAAC2B,KAAK,EAAE8H,IAAI,CAAC6B,QAAQ,CAAC,CAAC/L,MAAO;gBAC1G,IAAIsC,IAAI,CAAC7C,KAAK,KAAKuM,UAAU,CAACvM,KAAK,EAAE;kBACjCwL,oBAAoB,CAACjL,MAAM,GAAG4L,2BAA2B,CAAC5L,MAAM;iBACnE,MAAM;kBACHiL,oBAAoB,CAACjL,MAAM,GAAGgM,UAAU,CAACtD,qBAAsB;;eAEtE,MAAM;gBACHuC,oBAAoB,CAACjL,MAAM,GAAG,IAAI,CAACe,gBAAgB;;cAGvD,IAAI,CAACd,OAAO,CAACgM,sBAAsB,CAAC5F,eAAe,CAAC;gBAAE/D,IAAI,EAAEsJ,2BAA2B;gBAAEM,WAAW,EAAEjB;cAAoB,CAAE,CAAC;YACjI,CAAC,CAAC;UACN,CAAC,CAAC,CACL;QACL,CAAC,CAAC,CACL;;;IAIT,IAAI,CAACvB,QAAQ,EAAE;IAEf,OAAO3H,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,IAAI,CAAC0H,iBAAiB,CAACrH,IAAI,EAAGiH,WAAW,IAAI;QACzC,IAAKA,WAAoB,CAACO,QAAQ,IAAKP,WAAoB,CAACO,QAAS,CAACqC,2BAA2B,EAAE;UAC/F;UACA5C,WAAW,CAAC6C,mBAAmB,EAAE;SACpC,MAAM;UACH7C,WAAW,CAAC8C,mBAAmB,CAAC,IAAI,CAAC;;MAE7C,CAAC,CAAC;MAEF,OAAO/J,IAAI,CAACoG,qBAAsB;IACtC,CAAC,CAAC;EACN;EAEQiD,cAAc,CAACpM,OAAe,EAAE+C,IAAW,EAAEkJ,IAAW,EAAEV,MAAqD;IACnH,MAAMwB,UAAU,GAAGd,IAAI,CAACc,UAAU;IAClC,IAAI,CAACA,UAAU,IAAI,CAACA,UAAU,CAACzM,MAAM,EAAE;MACnC,MAAM,IAAIF,KAAK,CAAC,GAAGJ,OAAO,0BAA0B,CAAC;;IAGzD,IAAI+M,UAAU,CAAC,CAAC,CAAC,CAAC7M,KAAK,IAAIC,SAAS,EAAE;MAClCL,SAAS,CAACO,MAAM,CAAC0M,UAAU,CAAC;;IAGhC,MAAM7H,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,IAAI,CAACmK,OAAO,CAAC,GAAG9J,OAAO,IAAIiM,IAAI,CAACrL,IAAI,IAAI,EAAE,EAAE,CAAC;IAE7C,MAAMA,IAAI,GAAGmC,IAAI,CAACnC,IAAI,IAAI,OAAOmC,IAAI,CAAC7C,KAAK,EAAE;IAE7C,IAAI6M,UAAU,CAACzM,MAAM,KAAK,CAAC,EAAE;MACzB,MAAM0M,SAAS,GAAGf,IAAI,CAACc,UAAU,CAAC,CAAC,CAAC;MACpC7H,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC2H,uBAAuB,CAAC,GAAGjN,OAAO,eAAegN,SAAS,CAAC9M,KAAK,EAAE,EAAEU,IAAI,EAAEmC,IAAI,EAAEkJ,IAAI,EAAEe,SAAS,EAAGhD,WAAW,IAAI;QAClHjH,IAAI,CAACoG,qBAAqB,GAAGa,WAAW;QACxCjH,IAAI,CAACuH,uBAAuB,GAAG,CAACN,WAAW,CAAC;MAChD,CAAC,CAAC,CACL;KACJ,MAAM;MACH,IAAI,CAAC1I,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;MAClEI,IAAI,CAACoG,qBAAqB,GAAG,IAAIrL,aAAa,CAAC8C,IAAI,EAAE,IAAI,CAACU,aAAa,CAAC;MACxEyB,IAAI,CAACoG,qBAAqB,CAACD,gBAAgB,GAAG,IAAI,CAACvG,eAAe;MAClE,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;MACjDlG,IAAI,CAACuH,uBAAuB,GAAG,EAAE;MACjC,KAAK,MAAM0C,SAAS,IAAID,UAAU,EAAE;QAChC7H,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC2H,uBAAuB,CAAC,GAAGjN,OAAO,eAAegN,SAAS,CAAC9M,KAAK,EAAE,EAAE,GAAGU,IAAI,aAAaoM,SAAS,CAAC9M,KAAK,EAAE,EAAE6C,IAAI,EAAEkJ,IAAI,EAAEe,SAAS,EAAGhD,WAAW,IAAI;UACnJA,WAAW,CAACvJ,MAAM,GAAGsC,IAAI,CAACoG,qBAAsB;UAChDpG,IAAI,CAACuH,uBAAwB,CAAChF,IAAI,CAAC0E,WAAW,CAAC;QACnD,CAAC,CAAC,CACL;;;IAITuB,MAAM,CAACxI,IAAI,CAACoG,qBAAsB,CAAC;IAEnC,IAAI,CAACgB,QAAQ,EAAE;IAEf,OAAO3H,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,OAAOK,IAAI,CAACoG,qBAAsB;IACtC,CAAC,CAAC;EACN;EAEA;;;;;;;;;;EAUO8D,uBAAuB,CAC1BjN,OAAe,EACfY,IAAY,EACZmC,IAAW,EACXkJ,IAAW,EACXe,SAAyB,EACzBzB,MAA2C;IAE3C,MAAM3B,gBAAgB,GAAG,IAAI,CAACsD,iCAAiC,CAAClN,OAAO,EAAEY,IAAI,EAAEmC,IAAI,EAAEkJ,IAAI,EAAEe,SAAS,EAAEzB,MAAM,CAAC;IAC7G,IAAI3B,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI,CAACE,OAAO,CAAC,GAAG9J,OAAO,EAAE,CAAC;IAE1B,MAAMmN,cAAc,GAAG,IAAI,CAACC,qBAAqB,KAAK,CAAC,IAAI,IAAI,CAAC1M,OAAO,CAAC2M,eAAe,IAAItK,IAAI,CAAC4H,IAAI,IAAIxK,SAAS,IAAI,CAAC8L,IAAI,CAACc,UAAU,CAAC,CAAC,CAAC,CAACO,OAAO;IAEhJ,IAAIC,mBAAiC;IACrC,IAAIC,OAAqB;IAEzB,IAAIL,cAAc,IAAIH,SAAS,CAACS,aAAa,EAAE;MAC3C,IAAI,CAACnM,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;MAClE4K,mBAAmB,GAAGP,SAAS,CAACS,aAAa,CAACC,iBAAiB,CAACC,cAAc,CAAC/M,IAAI,CAAkB;MACrG2M,mBAAmB,CAACrE,gBAAgB,GAAG,IAAI,CAACvG,eAAe;MAC3D,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;MACjDuE,OAAO,GAAGR,SAAS,CAACS,aAAa,CAACD,OAAO;KAC5C,MAAM;MACH,MAAMtI,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;MAE1C,IAAI,CAAC2B,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;MAClE,MAAMqH,WAAW,GAAG,IAAI9L,IAAI,CAAC0C,IAAI,EAAE,IAAI,CAACU,aAAa,CAAC;MACtD0I,WAAW,CAACd,gBAAgB,GAAG,IAAI,CAACvG,eAAe;MACnD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;MACjDe,WAAW,CAAC4D,+BAA+B,GAAG,IAAI,CAACtM,aAAa,CAACgI,oBAAoB,GAAG3L,QAAQ,CAACkQ,+BAA+B,GAAGlQ,QAAQ,CAACmQ,wBAAwB;MAEpK,IAAI,CAACC,mBAAmB,CAAC/N,OAAO,EAAE+C,IAAI,EAAEkJ,IAAI,EAAEe,SAAS,EAAEhD,WAAW,CAAC;MACrE9E,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC0I,oBAAoB,CAAChO,OAAO,EAAEgN,SAAS,EAAEhD,WAAW,CAAC,CAACtH,IAAI,CAAEuL,eAAe,IAAI;QAChF,OAAO,IAAI,CAACC,sBAAsB,CAAClO,OAAO,EAAEgN,SAAS,EAAEhD,WAAW,EAAEiE,eAAe,CAAC,CAACvL,IAAI,CAAC,MAAK;UAC3F,IAAI,IAAI,CAAChB,SAAS,EAAE;YAChB;;UAGJ,IAAI,CAACJ,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;UAClEsL,eAAe,CAACE,WAAW,CAACnE,WAAW,CAAC;UACxCiE,eAAe,CAAC/E,gBAAgB,GAAG,IAAI,CAACvG,eAAe;UACvD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;QACrD,CAAC,CAAC;MACN,CAAC,CAAC,CACL;MAED,MAAMnD,eAAe,GAAGvF,UAAU,CAAC6N,YAAY,CAACpO,OAAO,EAAEgN,SAAS,CAACqB,IAAI,CAAC;MACxE,IAAIrB,SAAS,CAACnH,QAAQ,IAAI1F,SAAS,EAAE;QACjC,IAAImO,eAAe,GAAG,IAAI,CAACxM,2BAA2B,CAACgE,eAAe,CAAC;QACvE,IAAI,CAACwI,eAAe,EAAE;UAClBA,eAAe,GAAG,IAAI,CAACC,sBAAsB,CAAC,uBAAuB,EAAEzI,eAAe,CAAC;UACvF,IAAI,CAACpF,OAAO,CAAC8N,0BAA0B,CAAC1H,eAAe,CAACwH,eAAe,CAAC;UACxE,IAAI,CAACxM,2BAA2B,CAACgE,eAAe,CAAC,GAAGwI,eAAe;;QAEvEtE,WAAW,CAACnE,QAAQ,GAAGyI,eAAe;OACzC,MAAM,IAAI,CAAC,IAAI,CAAC7N,MAAM,CAACgF,aAAa,EAAE;QACnC,MAAMI,QAAQ,GAAG/F,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,WAAW,EAAE,IAAI,CAACkB,KAAK,CAACyE,SAAS,EAAEqH,SAAS,CAACnH,QAAQ,CAAC;QAC/FX,QAAQ,CAACI,IAAI,CACT,IAAI,CAACU,kBAAkB,CAAC,cAAcH,QAAQ,CAAC3F,KAAK,EAAE,EAAE2F,QAAQ,EAAEmE,WAAW,EAAElE,eAAe,EAAGwI,eAAe,IAAI;UAChHtE,WAAW,CAACnE,QAAQ,GAAGyI,eAAe;QAC1C,CAAC,CAAC,CACL;;MAGLd,OAAO,GAAGhL,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC;MAE/B,IAAIiI,cAAc,EAAE;QAChBH,SAAS,CAACS,aAAa,GAAG;UACtBC,iBAAiB,EAAE1D,WAAW;UAC9BwD,OAAO,EAAEA;SACZ;;MAGLD,mBAAmB,GAAGvD,WAAW;;IAGrCzJ,UAAU,CAACoL,kBAAkB,CAAC4B,mBAAmB,EAAEvN,OAAO,CAAC;IAC3D,IAAI,CAACU,OAAO,CAACiJ,sBAAsB,CAAC7C,eAAe,CAACyG,mBAAmB,CAAC;IACxEhC,MAAM,CAACgC,mBAAmB,CAAC;IAE3B,IAAI,CAACpD,QAAQ,EAAE;IAEf,OAAOqD,OAAO,CAAC9K,IAAI,CAAC,MAAK;MACrB,OAAO6K,mBAAmB;IAC9B,CAAC,CAAC;EACN;EAEQS,oBAAoB,CAAChO,OAAe,EAAEgN,SAAyB,EAAEhD,WAAiB;IACtF,MAAMJ,gBAAgB,GAAG,IAAI,CAAC6E,8BAA8B,CAACzO,OAAO,EAAEgN,SAAS,EAAEhD,WAAW,CAAC;IAC7F,IAAIJ,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,MAAM8E,UAAU,GAAG1B,SAAS,CAAC0B,UAAU;IACvC,IAAI,CAACA,UAAU,EAAE;MACb,MAAM,IAAItO,KAAK,CAAC,GAAGJ,OAAO,0BAA0B,CAAC;;IAGzD,MAAMkF,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,MAAMsO,eAAe,GAAG,IAAIhQ,QAAQ,CAAC+L,WAAW,CAACpJ,IAAI,EAAE,IAAI,CAACU,aAAa,CAAC;IAE1E,IAAI0L,SAAS,CAAC2B,OAAO,IAAIxO,SAAS,EAAE;MAChC6J,WAAW,CAAC4E,WAAW,GAAG,IAAI;KACjC,MAAM;MACH,MAAMC,QAAQ,GAAG/O,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,UAAU,EAAE,IAAI,CAACkB,KAAK,CAACuG,SAAS,EAAEuF,SAAS,CAAC2B,OAAO,CAAC;MAC7FzJ,QAAQ,CAACI,IAAI,CACT,IAAI,CAACwJ,yBAAyB,CAAC,cAAcD,QAAQ,CAAC3O,KAAK,EAAE,EAAE2O,QAAQ,CAAC,CAACnM,IAAI,CAAEN,IAAI,IAAI;QACnF6L,eAAe,CAACc,UAAU,CAAC3M,IAAI,CAAC;MACpC,CAAC,CAAC,CACL;;IAGL,MAAM4M,aAAa,GAAG,CAACC,SAAiB,EAAEC,IAAY,EAAE7E,QAAwC,KAAI;MAChG,IAAIqE,UAAU,CAACO,SAAS,CAAC,IAAI9O,SAAS,EAAE;QACpC;;MAGJ6J,WAAW,CAACmF,UAAU,GAAGnF,WAAW,CAACmF,UAAU,IAAI,EAAE;MACrD,IAAInF,WAAW,CAACmF,UAAU,CAAC3E,OAAO,CAAC0E,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;QAC7ClF,WAAW,CAACmF,UAAU,CAAC7J,IAAI,CAAC4J,IAAI,CAAC;;MAGrC,MAAML,QAAQ,GAAG/O,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,eAAeiP,SAAS,EAAE,EAAE,IAAI,CAAC/N,KAAK,CAACuG,SAAS,EAAEiH,UAAU,CAACO,SAAS,CAAC,CAAC;MACjH/J,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC8J,wBAAwB,CAAC,cAAcP,QAAQ,CAAC3O,KAAK,EAAE,EAAE2O,QAAQ,EAAEK,IAAI,CAAC,CAACxM,IAAI,CAAE2M,mBAAmB,IAAI;QACvG,IAAIA,mBAAmB,CAACC,OAAO,EAAE,KAAKtR,YAAY,CAACuR,YAAY,IAAI,CAAC,IAAI,CAAC9O,MAAM,CAAC+O,wBAAwB,IAAI,CAACxF,WAAW,CAACwC,QAAQ,EAAE;UAC/H,MAAMiD,IAAI,GAAGZ,QAAQ,CAACa,GAA+B;YACjDC,IAAI,GAAGd,QAAQ,CAACe,GAA+B;UACnD,IAAIH,IAAI,KAAKtP,SAAS,IAAIwP,IAAI,KAAKxP,SAAS,EAAE;YAC1C,IAAI0O,QAAQ,CAACgB,UAAU,IAAIhB,QAAQ,CAACiB,aAAa,uBAAkC;cAC/E,IAAIC,OAAO,GAAG,CAAC;cACf,QAAQlB,QAAQ,CAACiB,aAAa;gBAC1B;kBACIC,OAAO,GAAG,KAAK;kBACf;gBACJ;kBACIA,OAAO,GAAG,KAAK;kBACf;gBACJ;kBACIA,OAAO,GAAG,OAAO;kBACjB;gBACJ;kBACIA,OAAO,GAAG,OAAO;kBACjB;cAAM;cAEd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;gBACxBP,IAAI,CAACO,CAAC,CAAC,GAAGC,IAAI,CAACL,GAAG,CAACH,IAAI,CAACO,CAAC,CAAC,GAAGD,OAAO,EAAE,CAAC,GAAG,CAAC;gBAC3CJ,IAAI,CAACK,CAAC,CAAC,GAAGC,IAAI,CAACL,GAAG,CAACD,IAAI,CAACK,CAAC,CAAC,GAAGD,OAAO,EAAE,CAAC,GAAG,CAAC;;;YAGnD,MAAML,GAAG,GAAGxS,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;cAC7B4S,GAAG,GAAG1S,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC;YAC/B0S,GAAG,CAACQ,cAAc,CAAC,GAAGT,IAAI,CAAC;YAC3BG,GAAG,CAACM,cAAc,CAAC,GAAGP,IAAI,CAAC;YAC3B1B,eAAe,CAACkC,aAAa,GAAG,IAAItR,YAAY,CAAC6Q,GAAG,EAAEE,GAAG,CAAC;YAC1D3B,eAAe,CAACrB,2BAA2B,GAAG,IAAI;;;QAG1DqB,eAAe,CAACmC,iBAAiB,CAACf,mBAAmB,EAAER,QAAQ,CAACwB,KAAK,CAAC;MAC1E,CAAC,CAAC,CACL;MAED,IAAInB,IAAI,IAAIlR,YAAY,CAACsS,wBAAwB,EAAE;QAC/CtG,WAAW,CAACuG,kBAAkB,GAAG,CAAC;;MAGtC,IAAIlG,QAAQ,EAAE;QACVA,QAAQ,CAACwE,QAAQ,CAAC;;IAE1B,CAAC;IAEDG,aAAa,CAAC,UAAU,EAAEhR,YAAY,CAACuR,YAAY,CAAC;IACpDP,aAAa,CAAC,QAAQ,EAAEhR,YAAY,CAACwS,UAAU,CAAC;IAChDxB,aAAa,CAAC,SAAS,EAAEhR,YAAY,CAACyS,WAAW,CAAC;IAClDzB,aAAa,CAAC,YAAY,EAAEhR,YAAY,CAAC0S,MAAM,CAAC;IAChD1B,aAAa,CAAC,YAAY,EAAEhR,YAAY,CAAC2S,OAAO,CAAC;IACjD3B,aAAa,CAAC,YAAY,EAAEhR,YAAY,CAAC4S,OAAO,CAAC;IACjD5B,aAAa,CAAC,YAAY,EAAEhR,YAAY,CAAC6S,OAAO,CAAC;IACjD7B,aAAa,CAAC,YAAY,EAAEhR,YAAY,CAAC8S,OAAO,CAAC;IACjD9B,aAAa,CAAC,YAAY,EAAEhR,YAAY,CAAC+S,OAAO,CAAC;IACjD/B,aAAa,CAAC,UAAU,EAAEhR,YAAY,CAACgT,mBAAmB,CAAC;IAC3DhC,aAAa,CAAC,WAAW,EAAEhR,YAAY,CAACiT,mBAAmB,CAAC;IAC5DjC,aAAa,CAAC,UAAU,EAAEhR,YAAY,CAACsS,wBAAwB,CAAC;IAChEtB,aAAa,CAAC,WAAW,EAAEhR,YAAY,CAACkT,wBAAwB,CAAC;IACjElC,aAAa,CAAC,SAAS,EAAEhR,YAAY,CAACmT,SAAS,EAAGtC,QAAQ,IAAI;MAC1D,IAAIA,QAAQ,CAACuC,IAAI,wBAAwB;QACrCpH,WAAW,CAACqH,cAAc,GAAG,IAAI;;IAEzC,CAAC,CAAC;IAEF,OAAO7O,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,OAAOuL,eAAe;IAC1B,CAAC,CAAC;EACN;EAEQF,mBAAmB,CAAC/N,OAAe,EAAE+C,IAAW,EAAEkJ,IAAW,EAAEe,SAAyB,EAAEhD,WAAiB;IAC/G,IAAI,CAACgD,SAAS,CAACM,OAAO,EAAE;MACpB;;IAGJ,IAAIvK,IAAI,CAACuO,gBAAgB,IAAInR,SAAS,EAAE;MACpC4C,IAAI,CAACuO,gBAAgB,GAAGtE,SAAS,CAACM,OAAO,CAAChN,MAAM;KACnD,MAAM,IAAI0M,SAAS,CAACM,OAAO,CAAChN,MAAM,KAAKyC,IAAI,CAACuO,gBAAgB,EAAE;MAC3D,MAAM,IAAIlR,KAAK,CAAC,GAAGJ,OAAO,qDAAqD,CAAC;;IAGpF,MAAMuR,WAAW,GAAGtF,IAAI,CAACuF,MAAM,GAAGvF,IAAI,CAACuF,MAAM,CAACD,WAAW,GAAG,IAAI;IAEhEvH,WAAW,CAACyH,kBAAkB,GAAG,IAAIrT,kBAAkB,CAAC4L,WAAW,CAAC0H,QAAQ,EAAE,CAAC;IAC/E1H,WAAW,CAACyH,kBAAkB,CAACE,gBAAgB,GAAG,IAAI;IAEtD,KAAK,IAAIzR,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG8M,SAAS,CAACM,OAAO,CAAChN,MAAM,EAAEJ,KAAK,EAAE,EAAE;MAC3D,MAAM0R,MAAM,GAAG7O,IAAI,CAAC8O,OAAO,GAAG9O,IAAI,CAAC8O,OAAO,CAAC3R,KAAK,CAAC,GAAG+L,IAAI,CAAC4F,OAAO,GAAG5F,IAAI,CAAC4F,OAAO,CAAC3R,KAAK,CAAC,GAAG,CAAC;MAC1F,MAAMU,IAAI,GAAG2Q,WAAW,GAAGA,WAAW,CAACrR,KAAK,CAAC,GAAG,cAAcA,KAAK,EAAE;MACrE8J,WAAW,CAACyH,kBAAkB,CAACK,SAAS,CAAC,IAAI3T,WAAW,CAACyC,IAAI,EAAEgR,MAAM,EAAE5H,WAAW,CAAC0H,QAAQ,EAAE,CAAC,CAAC;MAC/F;;EAER;;EAEQxD,sBAAsB,CAAClO,OAAe,EAAEgN,SAAyB,EAAEhD,WAAiB,EAAEiE,eAAyB;IACnH,IAAI,CAACjB,SAAS,CAACM,OAAO,EAAE;MACpB,OAAO9K,OAAO,CAACC,OAAO,EAAE;;IAG5B,MAAMyC,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,MAAM8R,kBAAkB,GAAGzH,WAAW,CAACyH,kBAAmB;IAC1D,KAAK,IAAIvR,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGuR,kBAAkB,CAACM,UAAU,EAAE7R,KAAK,EAAE,EAAE;MAChE,MAAM8R,kBAAkB,GAAGP,kBAAkB,CAACQ,SAAS,CAAC/R,KAAK,CAAC;MAC9DgF,QAAQ,CAACI,IAAI,CAAC,IAAI,CAAC4M,+BAA+B,CAAC,GAAGlS,OAAO,YAAYE,KAAK,EAAE,EAAE+N,eAAe,EAAEjB,SAAS,CAACM,OAAO,CAACpN,KAAK,CAAC,EAAE8R,kBAAkB,CAAC,CAAC;;IAGrJ,OAAOxP,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC+O,kBAAkB,CAACE,gBAAgB,GAAG,KAAK;IAC/C,CAAC,CAAC;EACN;EAEQO,+BAA+B,CAAClS,OAAe,EAAEiO,eAAyB,EAAES,UAAsC,EAAEsD,kBAA+B;IACvJ,MAAM9M,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,MAAMqP,aAAa,GAAG,CAACC,SAAiB,EAAEC,IAAY,EAAEiD,OAAwE,KAAI;MAChI,IAAIzD,UAAU,CAACO,SAAS,CAAC,IAAI9O,SAAS,EAAE;QACpC;;MAGJ,MAAMkP,mBAAmB,GAAGpB,eAAe,CAACmE,eAAe,CAAClD,IAAI,CAAC;MACjE,IAAI,CAACG,mBAAmB,EAAE;QACtB;;MAGJ,MAAMR,QAAQ,GAAG/O,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,IAAIiP,SAAS,EAAE,EAAE,IAAI,CAAC/N,KAAK,CAACuG,SAAS,EAAEiH,UAAU,CAACO,SAAS,CAAC,CAAC;MACtG/J,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC+M,uBAAuB,CAAC,cAAcxD,QAAQ,CAAC3O,KAAK,EAAE,EAAE2O,QAAQ,CAAC,CAACnM,IAAI,CAAEN,IAAI,IAAI;QACjF+P,OAAO,CAAC9C,mBAAmB,EAAEjN,IAAI,CAAC;MACtC,CAAC,CAAC,CACL;IACL,CAAC;IAED4M,aAAa,CAAC,UAAU,EAAEhR,YAAY,CAACuR,YAAY,EAAE,CAACF,mBAAmB,EAAEjN,IAAI,KAAI;MAC/E,MAAMkQ,SAAS,GAAG,IAAIC,YAAY,CAACnQ,IAAI,CAAC9B,MAAM,CAAC;MAC/C+O,mBAAmB,CAAC9P,OAAO,CAAC6C,IAAI,CAAC9B,MAAM,EAAE,CAACkS,KAAK,EAAEtS,KAAK,KAAI;QACtDoS,SAAS,CAACpS,KAAK,CAAC,GAAGkC,IAAI,CAAClC,KAAK,CAAC,GAAGsS,KAAK;MAC1C,CAAC,CAAC;MAEFR,kBAAkB,CAACS,YAAY,CAACH,SAAS,CAAC;IAC9C,CAAC,CAAC;IAEFtD,aAAa,CAAC,QAAQ,EAAEhR,YAAY,CAACwS,UAAU,EAAE,CAACnB,mBAAmB,EAAEjN,IAAI,KAAI;MAC3E,MAAMsQ,OAAO,GAAG,IAAIH,YAAY,CAACnQ,IAAI,CAAC9B,MAAM,CAAC;MAC7C+O,mBAAmB,CAAC9P,OAAO,CAACmT,OAAO,CAACpS,MAAM,EAAE,CAACkS,KAAK,EAAEtS,KAAK,KAAI;QACzDwS,OAAO,CAACxS,KAAK,CAAC,GAAGkC,IAAI,CAAClC,KAAK,CAAC,GAAGsS,KAAK;MACxC,CAAC,CAAC;MAEFR,kBAAkB,CAACW,UAAU,CAACD,OAAO,CAAC;IAC1C,CAAC,CAAC;IAEF1D,aAAa,CAAC,SAAS,EAAEhR,YAAY,CAACyS,WAAW,EAAE,CAACpB,mBAAmB,EAAEjN,IAAI,KAAI;MAC7E,MAAMwQ,QAAQ,GAAG,IAAIL,YAAY,CAAEnQ,IAAI,CAAC9B,MAAM,GAAG,CAAC,GAAI,CAAC,CAAC;MACxD,IAAIuS,SAAS,GAAG,CAAC;MACjBxD,mBAAmB,CAAC9P,OAAO,CAAE6C,IAAI,CAAC9B,MAAM,GAAG,CAAC,GAAI,CAAC,EAAE,CAACkS,KAAK,EAAEtS,KAAK,KAAI;QAChE;QACA;QACA;QACA,IAAI,CAACA,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;UACvB0S,QAAQ,CAACC,SAAS,CAAC,GAAGzQ,IAAI,CAACyQ,SAAS,CAAC,GAAGL,KAAK;UAC7CK,SAAS,EAAE;;MAEnB,CAAC,CAAC;MACFb,kBAAkB,CAACc,WAAW,CAACF,QAAQ,CAAC;IAC5C,CAAC,CAAC;IAEF,OAAOpQ,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EAC/C;EAEQ,OAAO+G,cAAc,CAAC1G,IAAW,EAAEgQ,WAA0B;IACjE;IACA;IACA,IAAIhQ,IAAI,CAAC4H,IAAI,IAAIxK,SAAS,EAAE;MACxB;;IAGJ,IAAI6S,QAAQ,GAAGhW,OAAO,CAACiW,IAAI,EAAE;IAC7B,IAAI1J,QAAQ,GAAGxM,UAAU,CAACmW,QAAQ,EAAE;IACpC,IAAIC,OAAO,GAAGnW,OAAO,CAACoW,GAAG,EAAE;IAE3B,IAAIrQ,IAAI,CAACsQ,MAAM,EAAE;MACb,MAAMA,MAAM,GAAGpW,MAAM,CAACqW,SAAS,CAACvQ,IAAI,CAACsQ,MAAM,CAAC;MAC5CA,MAAM,CAACE,SAAS,CAACJ,OAAO,EAAE5J,QAAQ,EAAEyJ,QAAQ,CAAC;KAChD,MAAM;MACH,IAAIjQ,IAAI,CAACyQ,WAAW,EAAE;QAClBR,QAAQ,GAAGhW,OAAO,CAACsW,SAAS,CAACvQ,IAAI,CAACyQ,WAAW,CAAC;;MAElD,IAAIzQ,IAAI,CAACwG,QAAQ,EAAE;QACfA,QAAQ,GAAGxM,UAAU,CAACuW,SAAS,CAACvQ,IAAI,CAACwG,QAAQ,CAAC;;MAElD,IAAIxG,IAAI,CAACyG,KAAK,EAAE;QACZ2J,OAAO,GAAGnW,OAAO,CAACsW,SAAS,CAACvQ,IAAI,CAACyG,KAAK,CAAC;;;IAI/CuJ,WAAW,CAACC,QAAQ,GAAGA,QAAQ;IAC/BD,WAAW,CAACU,kBAAkB,GAAGlK,QAAQ;IACzCwJ,WAAW,CAACI,OAAO,GAAGA,OAAO;EACjC;EAEQ5G,cAAc,CAACvM,OAAe,EAAE+C,IAAW,EAAE4H,IAAW,EAAEY,MAA2C;IACzG,MAAM3B,gBAAgB,GAAG,IAAI,CAAC8J,wBAAwB,CAAC1T,OAAO,EAAE+C,IAAI,EAAE4H,IAAI,CAAC;IAC3E,IAAIf,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAIe,IAAI,CAACC,KAAK,EAAE;MACZW,MAAM,CAACZ,IAAI,CAACC,KAAK,CAACC,eAAe,CAAC;MAClC,OAAOF,IAAI,CAACC,KAAK,CAAC4C,OAAO;;IAG7B,MAAMmG,UAAU,GAAG,WAAWhJ,IAAI,CAACzK,KAAK,EAAE;IAC1C,IAAI,CAACoB,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;IAClE,MAAMkI,eAAe,GAAG,IAAInN,QAAQ,CAACiN,IAAI,CAAC/J,IAAI,IAAI+S,UAAU,EAAEA,UAAU,EAAE,IAAI,CAACrS,aAAa,CAAC;IAC7FuJ,eAAe,CAAC3B,gBAAgB,GAAG,IAAI,CAACvG,eAAe;IACvD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;IAEjD,IAAI,CAAC2K,UAAU,CAAC5T,OAAO,EAAE2K,IAAI,EAAEE,eAAe,CAAC;IAC/C,MAAM2C,OAAO,GAAG,IAAI,CAACqG,qCAAqC,CAAC7T,OAAO,EAAE2K,IAAI,CAAC,CAACjI,IAAI,CAAEoR,uBAAuB,IAAI;MACvG,IAAI,CAACC,mBAAmB,CAAClJ,eAAe,EAAEiJ,uBAAuB,CAAC;IACtE,CAAC,CAAC;IAEFnJ,IAAI,CAACC,KAAK,GAAG;MACTC,eAAe,EAAEA,eAAe;MAChC2C,OAAO,EAAEA;KACZ;IAEDjC,MAAM,CAACV,eAAe,CAAC;IAEvB,OAAO2C,OAAO;EAClB;EAEQoG,UAAU,CAAC5T,OAAe,EAAE2K,IAAW,EAAEE,eAAyB;IACtE,IAAIF,IAAI,CAAC6B,QAAQ,IAAIrM,SAAS,IAAI,IAAI,CAACO,OAAO,CAACsT,6BAA6B,EAAE;MAC1E,MAAM7L,QAAQ,GAAG,IAAI,CAAC8L,qBAAqB,CAAC,GAAGjU,OAAO,SAAS,EAAE2K,IAAI,CAACuJ,MAAM,CAAC;MAC7E,IAAI/L,QAAQ,EAAE;QACV,IAAIwC,IAAI,CAAC6B,QAAQ,KAAKrM,SAAS,EAAE;UAC7BwK,IAAI,CAAC6B,QAAQ,GAAGrE,QAAQ,CAACjI,KAAK;SACjC,MAAM;UACH,MAAMiU,QAAQ,GAAG,CAAC3L,CAAQ,EAAEC,CAAQ,KAAa;YAC7C,OAAOA,CAAC,CAAChI,MAAM,EAAEgI,CAAC,GAAGA,CAAC,CAAChI,MAAM,EAAE;cAC3B,IAAIgI,CAAC,CAAChI,MAAM,KAAK+H,CAAC,EAAE;gBAChB,OAAO,IAAI;;;YAInB,OAAO,KAAK;UAChB,CAAC;UAED,MAAM4L,YAAY,GAAGtU,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,WAAW,EAAE,IAAI,CAACkB,KAAK,CAAC2B,KAAK,EAAE8H,IAAI,CAAC6B,QAAQ,CAAC;UAC1F,IAAI4H,YAAY,KAAKjM,QAAQ,IAAI,CAACgM,QAAQ,CAACC,YAAY,EAAEjM,QAAQ,CAAC,EAAE;YAChEvJ,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,0FAA0F,CAAC;YACjH2K,IAAI,CAAC6B,QAAQ,GAAGrE,QAAQ,CAACjI,KAAK;;;OAGzC,MAAM;QACHtB,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,8BAA8B,CAAC;;;IAI7D,MAAMqU,YAAY,GAA8B,EAAE;IAClD,KAAK,MAAMnU,KAAK,IAAIyK,IAAI,CAACuJ,MAAM,EAAE;MAC7B,MAAMnR,IAAI,GAAGjD,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,WAAWE,KAAK,EAAE,EAAE,IAAI,CAACgB,KAAK,CAAC2B,KAAK,EAAE3C,KAAK,CAAC;MACjF,IAAI,CAACoU,SAAS,CAACvR,IAAI,EAAE4H,IAAI,EAAEE,eAAe,EAAEwJ,YAAY,CAAC;;EAEjE;EAEQJ,qBAAqB,CAACjU,OAAe,EAAEkU,MAAqB;IAChE,IAAIA,MAAM,CAAC5T,MAAM,KAAK,CAAC,EAAE;MACrB,OAAO,IAAI;;IAGf,MAAMiU,KAAK,GAAsC,EAAE;IACnD,KAAK,MAAMrU,KAAK,IAAIgU,MAAM,EAAE;MACxB,MAAMM,IAAI,GAAG,IAAI7U,KAAK,EAAS;MAC/B,IAAIoD,IAAI,GAAGjD,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,IAAIE,KAAK,EAAE,EAAE,IAAI,CAACgB,KAAK,CAAC2B,KAAK,EAAE3C,KAAK,CAAC;MACxE,OAAO6C,IAAI,CAAC7C,KAAK,KAAK,CAAC,CAAC,EAAE;QACtBsU,IAAI,CAACC,OAAO,CAAC1R,IAAI,CAAC;QAClBA,IAAI,GAAGA,IAAI,CAACtC,MAAO;;MAEvB8T,KAAK,CAACrU,KAAK,CAAC,GAAGsU,IAAI;;IAGvB,IAAIrM,QAAQ,GAAoB,IAAI;IACpC,KAAK,IAAI6H,CAAC,GAAG,CAAC,GAAI,EAAEA,CAAC,EAAE;MACnB,IAAIwE,IAAI,GAAGD,KAAK,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC;MAC3B,IAAIlE,CAAC,IAAIwE,IAAI,CAAClU,MAAM,EAAE;QAClB,OAAO6H,QAAQ;;MAGnB,MAAMpF,IAAI,GAAGyR,IAAI,CAACxE,CAAC,CAAC;MACpB,KAAK,IAAI0E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,MAAM,CAAC5T,MAAM,EAAE,EAAEoU,CAAC,EAAE;QACpCF,IAAI,GAAGD,KAAK,CAACL,MAAM,CAACQ,CAAC,CAAC,CAAC;QACvB,IAAI1E,CAAC,IAAIwE,IAAI,CAAClU,MAAM,IAAIyC,IAAI,KAAKyR,IAAI,CAACxE,CAAC,CAAC,EAAE;UACtC,OAAO7H,QAAQ;;;MAIvBA,QAAQ,GAAGpF,IAAI;;EAEvB;EAEQuR,SAAS,CAACvR,IAAW,EAAE4H,IAAW,EAAEE,eAAyB,EAAEwJ,YAAuC;IAC1G,IAAIM,WAAW,GAAGN,YAAY,CAACtR,IAAI,CAAC7C,KAAK,CAAC;IAC1C,IAAIyU,WAAW,EAAE;MACb,OAAOA,WAAW;;IAGtB,IAAIC,iBAAiB,GAAmB,IAAI;IAC5C,IAAI7R,IAAI,CAAC7C,KAAK,KAAKyK,IAAI,CAAC6B,QAAQ,EAAE;MAC9B,IAAIzJ,IAAI,CAACtC,MAAM,IAAIsC,IAAI,CAACtC,MAAM,CAACP,KAAK,KAAK,CAAC,CAAC,EAAE;QACzC0U,iBAAiB,GAAG,IAAI,CAACN,SAAS,CAACvR,IAAI,CAACtC,MAAM,EAAEkK,IAAI,EAAEE,eAAe,EAAEwJ,YAAY,CAAC;OACvF,MAAM,IAAI1J,IAAI,CAAC6B,QAAQ,KAAKrM,SAAS,EAAE;QACpCvB,MAAM,CAACmC,IAAI,CAAC,UAAU4J,IAAI,CAACzK,KAAK,+CAA+C,CAAC;;;IAIxF,MAAM2U,SAAS,GAAGlK,IAAI,CAACuJ,MAAM,CAAC1J,OAAO,CAACzH,IAAI,CAAC7C,KAAK,CAAC;IACjDyU,WAAW,GAAG,IAAIlX,IAAI,CAACsF,IAAI,CAACnC,IAAI,IAAI,QAAQmC,IAAI,CAAC7C,KAAK,EAAE,EAAE2K,eAAe,EAAE+J,iBAAiB,EAAE,IAAI,CAACE,cAAc,CAAC/R,IAAI,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE8R,SAAS,CAAC;IAC/IR,YAAY,CAACtR,IAAI,CAAC7C,KAAK,CAAC,GAAGyU,WAAW;IAEtC;IACA,IAAI,CAAC5S,qBAAqB,CAACuD,IAAI,CAAC,MAAK;MACjC;MACA;MACAqP,WAAW,CAACI,iBAAiB,CAAChS,IAAI,CAACoG,qBAAsB,CAAC;IAC9D,CAAC,CAAC;IAEF,OAAOwL,WAAW;EACtB;EAEQd,qCAAqC,CAAC7T,OAAe,EAAE2K,IAAW;IACtE,IAAIA,IAAI,CAACqK,mBAAmB,IAAI7U,SAAS,EAAE;MACvC,OAAOqC,OAAO,CAACC,OAAO,CAAC,IAAI,CAAC;;IAGhC,MAAMoM,QAAQ,GAAG/O,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,sBAAsB,EAAE,IAAI,CAACkB,KAAK,CAACuG,SAAS,EAAEkD,IAAI,CAACqK,mBAAmB,CAAC;IAChH,OAAO,IAAI,CAAC3C,uBAAuB,CAAC,cAAcxD,QAAQ,CAAC3O,KAAK,EAAE,EAAE2O,QAAQ,CAAC;EACjF;EAEQkF,mBAAmB,CAAClJ,eAAyB,EAAEiJ,uBAA+C;IAClG,KAAK,MAAMa,WAAW,IAAI9J,eAAe,CAACoK,KAAK,EAAE;MAC7C,MAAMC,UAAU,GAAGjY,MAAM,CAACiW,QAAQ,EAAE;MACpC,MAAM2B,SAAS,GAAGF,WAAW,CAACQ,MAAO;MACrC,IAAIrB,uBAAuB,IAAIe,SAAS,KAAK,CAAC,CAAC,EAAE;QAC7C5X,MAAM,CAACmY,cAAc,CAACtB,uBAAuB,EAAEe,SAAS,GAAG,EAAE,EAAEK,UAAU,CAAC;QAC1EA,UAAU,CAACG,WAAW,CAACH,UAAU,CAAC;;MAGtC,MAAMI,iBAAiB,GAAGX,WAAW,CAACY,SAAS,EAAE;MACjD,IAAID,iBAAiB,EAAE;QACnBJ,UAAU,CAACM,aAAa,CAACF,iBAAiB,CAACG,4BAA4B,EAAE,EAAEP,UAAU,CAAC;;MAG1FP,WAAW,CAACe,YAAY,CAACR,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC;MAClDP,WAAW,CAACgB,uBAAuB,CAACxV,SAAS,EAAE,KAAK,CAAC;;EAE7D;EAEQ2U,cAAc,CAAC/R,IAAW;IAC9B,OAAOA,IAAI,CAACsQ,MAAM,GACZpW,MAAM,CAACqW,SAAS,CAACvQ,IAAI,CAACsQ,MAAM,CAAC,GAC7BpW,MAAM,CAAC2Y,OAAO,CACV7S,IAAI,CAACyG,KAAK,GAAGxM,OAAO,CAACsW,SAAS,CAACvQ,IAAI,CAACyG,KAAK,CAAC,GAAGxM,OAAO,CAACoW,GAAG,EAAE,EAC1DrQ,IAAI,CAACwG,QAAQ,GAAGxM,UAAU,CAACuW,SAAS,CAACvQ,IAAI,CAACwG,QAAQ,CAAC,GAAGxM,UAAU,CAACmW,QAAQ,EAAE,EAC3EnQ,IAAI,CAACyQ,WAAW,GAAGxW,OAAO,CAACsW,SAAS,CAACvQ,IAAI,CAACyQ,WAAW,CAAC,GAAGxW,OAAO,CAACiW,IAAI,EAAE,CAC1E;EACX;EAEA;;;;;;;EAOOpH,eAAe,CAAC7L,OAAe,EAAE4L,MAAe,EAAEL,SAA0C,MAAK,CAAE,CAAC;IACvG,MAAM3B,gBAAgB,GAAG,IAAI,CAACiM,0BAA0B,CAAC7V,OAAO,EAAE4L,MAAM,EAAEL,MAAM,CAAC;IACjF,IAAI3B,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,MAAM1E,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,IAAI,CAACmK,OAAO,CAAC,GAAG9J,OAAO,IAAI4L,MAAM,CAAChL,IAAI,IAAI,EAAE,EAAE,CAAC;IAE/C,IAAI,CAACU,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;IAClE,MAAMmJ,aAAa,GAAG,IAAIxO,UAAU,CAACsO,MAAM,CAAChL,IAAI,IAAI,SAASgL,MAAM,CAAC1L,KAAK,EAAE,EAAElD,OAAO,CAACiW,IAAI,EAAE,EAAE,IAAI,CAAC3R,aAAa,EAAE,KAAK,CAAC;IACvHwK,aAAa,CAAC5C,gBAAgB,GAAG,IAAI,CAACvG,eAAe;IACrD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;IACjD6C,aAAa,CAACgK,mBAAmB,GAAG,IAAI;IACxClK,MAAM,CAACmK,cAAc,GAAGjK,aAAa;IAErCA,aAAa,CAACvC,QAAQ,GAAG,IAAIvM,OAAO,CAAC,CAAC,EAAEiT,IAAI,CAAC+F,EAAE,EAAE,CAAC,CAAC;IAEnD,QAAQpK,MAAM,CAACwF,IAAI;MACf;QAA6B;UACzB,MAAM6E,WAAW,GAAGrK,MAAM,CAACqK,WAAW;UACtC,IAAI,CAACA,WAAW,EAAE;YACd,MAAM,IAAI7V,KAAK,CAAC,GAAGJ,OAAO,6CAA6C,CAAC;;UAG5E8L,aAAa,CAACoK,GAAG,GAAGD,WAAW,CAACE,IAAI;UACpCrK,aAAa,CAACsK,IAAI,GAAGH,WAAW,CAACI,KAAK;UACtCvK,aAAa,CAACwK,IAAI,GAAGL,WAAW,CAACM,IAAI,IAAI,CAAC;UAC1C;;MAEJ;QAA8B;UAC1B,IAAI,CAAC3K,MAAM,CAAC4K,YAAY,EAAE;YACtB,MAAM,IAAIpW,KAAK,CAAC,GAAGJ,OAAO,8CAA8C,CAAC;;UAG7E8L,aAAa,CAACuC,IAAI,GAAGhR,MAAM,CAACoZ,mBAAmB;UAC/C3K,aAAa,CAAC4K,SAAS,GAAG,CAAC9K,MAAM,CAAC4K,YAAY,CAACG,IAAI;UACnD7K,aAAa,CAAC8K,UAAU,GAAGhL,MAAM,CAAC4K,YAAY,CAACG,IAAI;UACnD7K,aAAa,CAAC+K,WAAW,GAAG,CAACjL,MAAM,CAAC4K,YAAY,CAACM,IAAI;UACrDhL,aAAa,CAACiL,QAAQ,GAAGnL,MAAM,CAAC4K,YAAY,CAACM,IAAI;UACjDhL,aAAa,CAACsK,IAAI,GAAGxK,MAAM,CAAC4K,YAAY,CAACH,KAAK;UAC9CvK,aAAa,CAACwK,IAAI,GAAG1K,MAAM,CAAC4K,YAAY,CAACD,IAAI;UAC7C;;MAEJ;QAAS;UACL,MAAM,IAAInW,KAAK,CAAC,GAAGJ,OAAO,0BAA0B4L,MAAM,CAACwF,IAAI,GAAG,CAAC;;IACtE;IAGL7Q,UAAU,CAACoL,kBAAkB,CAACG,aAAa,EAAE9L,OAAO,CAAC;IACrD,IAAI,CAACU,OAAO,CAACsW,wBAAwB,CAAClQ,eAAe,CAACgF,aAAa,CAAC;IACpEP,MAAM,CAACO,aAAa,CAAC;IAErB,IAAI,CAAC3B,QAAQ,EAAE;IAEf,OAAO3H,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,OAAOoJ,aAAa;IACxB,CAAC,CAAC;EACN;EAEQ5B,oBAAoB;IACxB,MAAMxC,UAAU,GAAG,IAAI,CAACxG,KAAK,CAACwG,UAAU;IACxC,IAAI,CAACA,UAAU,EAAE;MACb,OAAOlF,OAAO,CAACC,OAAO,EAAE;;IAG5B,MAAMyC,QAAQ,GAAG,IAAIvF,KAAK,EAAiB;IAE3C,KAAK,IAAIO,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGwH,UAAU,CAACpH,MAAM,EAAEJ,KAAK,EAAE,EAAE;MACpD,MAAM4K,SAAS,GAAGpD,UAAU,CAACxH,KAAK,CAAC;MACnCgF,QAAQ,CAACI,IAAI,CACT,IAAI,CAAC2R,kBAAkB,CAAC,eAAenM,SAAS,CAAC5K,KAAK,EAAE,EAAE4K,SAAS,CAAC,CAACpI,IAAI,CAAEwU,cAAc,IAAI;QACzF;QACA,IAAIA,cAAc,CAACC,kBAAkB,CAAC7W,MAAM,KAAK,CAAC,EAAE;UAChD4W,cAAc,CAACzV,OAAO,EAAE;;MAEhC,CAAC,CAAC,CACL;;IAGL,OAAOe,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EAC/C;EAEA;;;;;;EAMOuU,kBAAkB,CAACjX,OAAe,EAAE8K,SAAqB;IAC5D,MAAM0C,OAAO,GAAG,IAAI,CAAC4J,6BAA6B,CAACpX,OAAO,EAAE8K,SAAS,CAAC;IACtE,IAAI0C,OAAO,EAAE;MACT,OAAOA,OAAO;;IAGlB,IAAI,CAAClM,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;IAClE,MAAM2I,qBAAqB,GAAG,IAAI9N,cAAc,CAACsN,SAAS,CAAClK,IAAI,IAAI,YAAYkK,SAAS,CAAC5K,KAAK,EAAE,EAAE,IAAI,CAACoB,aAAa,CAAC;IACrHgK,qBAAqB,CAACpC,gBAAgB,GAAG,IAAI,CAACvG,eAAe;IAC7D,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;IACjD6B,SAAS,CAACC,sBAAsB,GAAGO,qBAAqB;IAExD,MAAMpG,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1CG,SAAS,CAACO,MAAM,CAACyK,SAAS,CAACuM,QAAQ,CAAC;IACpCvX,SAAS,CAACO,MAAM,CAACyK,SAAS,CAAChD,QAAQ,CAAC;IAEpC,KAAK,MAAMwP,OAAO,IAAIxM,SAAS,CAACuM,QAAQ,EAAE;MACtCnS,QAAQ,CAACI,IAAI,CACT,IAAI,CAACiS,0BAA0B,CAAC,GAAGvX,OAAO,aAAasX,OAAO,CAACpX,KAAK,EAAE,EAAEF,OAAO,EAAE8K,SAAS,EAAEwM,OAAO,EAAE,CAACE,aAAa,EAAEC,gBAAgB,KAAI;QACrID,aAAa,CAAC9P,UAAU,GAAG8P,aAAa,CAAC9P,UAAU,IAAI,EAAE;QACzD8P,aAAa,CAAC9P,UAAU,CAACpC,IAAI,CAACmS,gBAAgB,CAAC;QAC/CnM,qBAAqB,CAACoM,oBAAoB,CAACD,gBAAgB,EAAED,aAAa,CAAC;MAC/E,CAAC,CAAC,CACL;;IAGL,OAAOhV,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC4I,qBAAqB,CAACqM,SAAS,CAAC,CAAC,CAAC;MAClC,OAAOrM,qBAAqB;IAChC,CAAC,CAAC;EACN;EAEA;;;;;;;;;;EAUOiM,0BAA0B,CAC7BvX,OAAe,EACf4X,gBAAwB,EACxB9M,SAAqB,EACrBwM,OAA0B,EAC1BO,MAA6E;IAE7E,MAAMrK,OAAO,GAAG,IAAI,CAACsK,oCAAoC,CAAC9X,OAAO,EAAE4X,gBAAgB,EAAE9M,SAAS,EAAEwM,OAAO,EAAEO,MAAM,CAAC;IAChH,IAAIrK,OAAO,EAAE;MACT,OAAOA,OAAO;;IAGlB,IAAI8J,OAAO,CAACS,MAAM,CAAChV,IAAI,IAAI5C,SAAS,EAAE;MAClC,OAAOqC,OAAO,CAACC,OAAO,EAAE;;IAG5B,MAAMuV,UAAU,GAAGlY,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,cAAc,EAAE,IAAI,CAACkB,KAAK,CAAC2B,KAAK,EAAEyU,OAAO,CAACS,MAAM,CAAChV,IAAI,CAAC;IAEjG;IACA,IACKuU,OAAO,CAACS,MAAM,CAACvD,IAAI,gCAA2C,CAACwD,UAAU,CAAC1G,gBAAgB,IAC1FgG,OAAO,CAACS,MAAM,CAACvD,IAAI,gCAA2C,CAACwD,UAAU,CAAC7O,qBAAsB,EACnG;MACE,OAAO3G,OAAO,CAACC,OAAO,EAAE;;IAG5B,IAAIwV,UAAwC;IAC5C,QAAQX,OAAO,CAACS,MAAM,CAACvD,IAAI;MACvB;QAA6C;UACzCyD,UAAU,GAAGnZ,iBAAiB,CAAC0U,WAAW;UAC1C;;MAEJ;QAA0C;UACtCyE,UAAU,GAAGnZ,iBAAiB,CAACyK,QAAQ;UACvC;;MAEJ;QAAuC;UACnC0O,UAAU,GAAGnZ,iBAAiB,CAAC0K,KAAK;UACpC;;MAEJ;QAAyC;UACrCyO,UAAU,GAAGnZ,iBAAiB,CAAC+S,OAAO;UACtC;;MAEJ;QAAS;UACL,MAAM,IAAIzR,KAAK,CAAC,GAAGJ,OAAO,gCAAgCsX,OAAO,CAACS,MAAM,CAACvD,IAAI,GAAG,CAAC;;IACpF;IAGL,MAAM0D,UAAU,GAAyB;MACrCH,MAAM,EAAEC,UAAU;MAClBC,UAAU,EAAEA;KACf;IAED,OAAO,IAAI,CAACE,wCAAwC,CAACnY,OAAO,EAAE4X,gBAAgB,EAAE9M,SAAS,EAAEwM,OAAO,EAAEY,UAAU,EAAEL,MAAM,CAAC;EAC3H;EAEA;;;;;;;;;;;EAWOM,wCAAwC,CAC3CnY,OAAe,EACf4X,gBAAwB,EACxB9M,SAAqB,EACrBwM,OAA0B,EAC1BY,UAAgC,EAChCL,MAA6E;IAE7E,MAAMO,GAAG,GAAG,IAAI,CAAC3X,MAAM,CAAC4X,SAAS;IACjC,MAAMC,MAAM,GAAG,CAAC,GAAGF,GAAG;IAEtB,MAAMG,OAAO,GAAGzY,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,UAAU,EAAE8K,SAAS,CAAChD,QAAQ,EAAEwP,OAAO,CAACiB,OAAO,CAAC;IACxF,OAAO,IAAI,CAACC,0BAA0B,CAAC,GAAGZ,gBAAgB,aAAaN,OAAO,CAACiB,OAAO,EAAE,EAAEA,OAAO,CAAC,CAAC7V,IAAI,CAAEN,IAAI,IAAI;MAC7G,IAAIqW,aAAa,GAAG,CAAC;MAErB;MACA;MACA;MACA;MACA;MACA,KAAK,MAAMC,QAAQ,IAAIR,UAAU,CAACD,UAAU,EAAE;QAC1C,MAAMU,MAAM,GAAGD,QAAQ,CAACE,SAAS,CAACV,UAAU,CAACH,MAAM,CAAC;QACpD,MAAMc,KAAK,GAAGzW,IAAI,CAACyW,KAAK;QACxB,MAAMC,MAAM,GAAG1W,IAAI,CAAC0W,MAAM;QAC1B,MAAMxZ,IAAI,GAAG,IAAIK,KAAK,CAAgBkZ,KAAK,CAACvY,MAAM,CAAC;QACnD,IAAIyY,YAAY,GAAG,CAAC;QAEpB,QAAQ3W,IAAI,CAAC4W,aAAa;UACtB;YAAyC;cACrC,KAAK,IAAI9Y,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG2Y,KAAK,CAACvY,MAAM,EAAEJ,KAAK,EAAE,EAAE;gBAC/C,MAAMsS,KAAK,GAAGkG,QAAQ,CAACO,QAAQ,CAACf,UAAU,CAACH,MAAM,EAAEe,MAAM,EAAEC,YAAY,EAAE,CAAC,CAAC;gBAC3EA,YAAY,IAAIJ,MAAM;gBAEtBrZ,IAAI,CAACY,KAAK,CAAC,GAAG;kBACVgZ,KAAK,EAAEL,KAAK,CAAC3Y,KAAK,CAAC,GAAGkY,GAAG;kBACzB5F,KAAK,EAAEA,KAAK;kBACZwG,aAAa,EAAEzb,yBAAyB,CAAC4b;iBAC5C;;cAEL;;UAEJ;YAAgD;cAC5C,KAAK,IAAIjZ,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG2Y,KAAK,CAACvY,MAAM,EAAEJ,KAAK,EAAE,EAAE;gBAC/C,MAAMkZ,SAAS,GAAGV,QAAQ,CAACO,QAAQ,CAACf,UAAU,CAACH,MAAM,EAAEe,MAAM,EAAEC,YAAY,EAAET,MAAM,CAAC;gBACpFS,YAAY,IAAIJ,MAAM;gBACtB,MAAMnG,KAAK,GAAGkG,QAAQ,CAACO,QAAQ,CAACf,UAAU,CAACH,MAAM,EAAEe,MAAM,EAAEC,YAAY,EAAE,CAAC,CAAC;gBAC3EA,YAAY,IAAIJ,MAAM;gBACtB,MAAMU,UAAU,GAAGX,QAAQ,CAACO,QAAQ,CAACf,UAAU,CAACH,MAAM,EAAEe,MAAM,EAAEC,YAAY,EAAET,MAAM,CAAC;gBACrFS,YAAY,IAAIJ,MAAM;gBAEtBrZ,IAAI,CAACY,KAAK,CAAC,GAAG;kBACVgZ,KAAK,EAAEL,KAAK,CAAC3Y,KAAK,CAAC,GAAGkY,GAAG;kBACzBgB,SAAS,EAAEA,SAAS;kBACpB5G,KAAK,EAAEA,KAAK;kBACZ6G,UAAU,EAAEA;iBACf;;cAEL;;UAEJ;YAA2C;cACvC,KAAK,IAAInZ,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG2Y,KAAK,CAACvY,MAAM,EAAEJ,KAAK,EAAE,EAAE;gBAC/C,MAAMsS,KAAK,GAAGkG,QAAQ,CAACO,QAAQ,CAACf,UAAU,CAACH,MAAM,EAAEe,MAAM,EAAEC,YAAY,EAAE,CAAC,CAAC;gBAC3EA,YAAY,IAAIJ,MAAM;gBAEtBrZ,IAAI,CAACY,KAAK,CAAC,GAAG;kBACVgZ,KAAK,EAAEL,KAAK,CAAC3Y,KAAK,CAAC,GAAGkY,GAAG;kBACzB5F,KAAK,EAAEA;iBACV;;cAEL;;QACH;QAGL,IAAIuG,YAAY,GAAG,CAAC,EAAE;UAClB,MAAMnY,IAAI,GAAG,GAAGkK,SAAS,CAAClK,IAAI,IAAI,YAAYkK,SAAS,CAAC5K,KAAK,EAAE,WAAWoX,OAAO,CAACpX,KAAK,IAAIuY,aAAa,EAAE;UAC1GC,QAAQ,CAACY,eAAe,CAACpB,UAAU,CAACH,MAAM,EAAEnX,IAAI,EAAEwX,GAAG,EAAE9Y,IAAI,EAAE,CAACia,iBAAiB,EAAE9B,gBAAgB,KAAI;YACjG,EAAEgB,aAAa;YACfZ,MAAM,CAAC0B,iBAAiB,EAAE9B,gBAAgB,CAAC;UAC/C,CAAC,CAAC;;;IAGd,CAAC,CAAC;EACN;EAEQe,0BAA0B,CAACxY,OAAe,EAAEuY,OAA0B;IAC1E,IAAIA,OAAO,CAAC3N,KAAK,EAAE;MACf,OAAO2N,OAAO,CAAC3N,KAAK;;IAGxB,MAAMoO,aAAa,GAAGT,OAAO,CAACS,aAAa;IAC3C,QAAQA,aAAa;MACjB;MACA;MACA;QAAgD;UAC5C;;MAEJ;QAAS;UACL,MAAM,IAAI5Y,KAAK,CAAC,GAAGJ,OAAO,kCAAkCuY,OAAO,CAACS,aAAa,GAAG,CAAC;;IACxF;IAGL,MAAMQ,aAAa,GAAG1Z,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,QAAQ,EAAE,IAAI,CAACkB,KAAK,CAACuG,SAAS,EAAE8Q,OAAO,CAACM,KAAK,CAAC;IAC5F,MAAMY,cAAc,GAAG3Z,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,SAAS,EAAE,IAAI,CAACkB,KAAK,CAACuG,SAAS,EAAE8Q,OAAO,CAACO,MAAM,CAAC;IAC/FP,OAAO,CAAC3N,KAAK,GAAGpI,OAAO,CAAC8D,GAAG,CAAC,CACxB,IAAI,CAAC+L,uBAAuB,CAAC,cAAcmH,aAAa,CAACtZ,KAAK,EAAE,EAAEsZ,aAAa,CAAC,EAChF,IAAI,CAACnH,uBAAuB,CAAC,cAAcoH,cAAc,CAACvZ,KAAK,EAAE,EAAEuZ,cAAc,CAAC,CACrF,CAAC,CAAC/W,IAAI,CAAC,CAAC,CAACgX,SAAS,EAAEC,UAAU,CAAC,KAAI;MAChC,OAAO;QACHd,KAAK,EAAEa,SAAS;QAChBV,aAAa,EAAEA,aAAa;QAC5BF,MAAM,EAAEa;OACX;IACL,CAAC,CAAC;IAEF,OAAOpB,OAAO,CAAC3N,KAAK;EACxB;EAEA;;;;;;;;EAQOgP,eAAe,CAAC5Z,OAAe,EAAE6Z,MAAe,EAAEC,UAAkB,EAAEtS,UAAkB;IAC3F,MAAMoC,gBAAgB,GAAG,IAAI,CAACmQ,0BAA0B,CAAC/Z,OAAO,EAAE6Z,MAAM,EAAEC,UAAU,EAAEtS,UAAU,CAAC;IACjG,IAAIoC,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI,CAACiQ,MAAM,CAACjP,KAAK,EAAE;MACf,IAAIiP,MAAM,CAACvS,GAAG,EAAE;QACZuS,MAAM,CAACjP,KAAK,GAAG,IAAI,CAACoP,YAAY,CAAC,GAAGha,OAAO,MAAM,EAAE6Z,MAAM,EAAEA,MAAM,CAACvS,GAAG,CAAC;OACzE,MAAM;QACH,IAAI,CAAC,IAAI,CAAClG,IAAI,EAAE;UACZ,MAAM,IAAIhB,KAAK,CAAC,GAAGJ,OAAO,iEAAiE,CAAC;;QAGhG6Z,MAAM,CAACjP,KAAK,GAAG,IAAI,CAACxJ,IAAI,CAAC6Y,SAAS,CAAC,CAAC,EAAEJ,MAAM,CAACrS,UAAU,CAAC;;;IAIhE,OAAOqS,MAAM,CAACjP,KAAK,CAAClI,IAAI,CAAEN,IAAI,IAAI;MAC9B,IAAI;QACA,OAAO,IAAI8X,UAAU,CAAC9X,IAAI,CAACyX,MAAM,EAAEzX,IAAI,CAAC0X,UAAU,GAAGA,UAAU,EAAEtS,UAAU,CAAC;OAC/E,CAAC,OAAO2S,CAAC,EAAE;QACR,MAAM,IAAI/Z,KAAK,CAAC,GAAGJ,OAAO,KAAKma,CAAC,CAACC,OAAO,EAAE,CAAC;;IAEnD,CAAC,CAAC;EACN;EAEA;;;;;;EAMOC,mBAAmB,CAACra,OAAe,EAAEsa,UAAuB;IAC/D,MAAM1Q,gBAAgB,GAAG,IAAI,CAAC2Q,8BAA8B,CAACva,OAAO,EAAEsa,UAAU,CAAC;IACjF,IAAI1Q,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI0Q,UAAU,CAAC1P,KAAK,EAAE;MAClB,OAAO0P,UAAU,CAAC1P,KAAK;;IAG3B,MAAMiP,MAAM,GAAG/Z,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,SAAS,EAAE,IAAI,CAACkB,KAAK,CAACmG,OAAO,EAAEiT,UAAU,CAACT,MAAM,CAAC;IACxFS,UAAU,CAAC1P,KAAK,GAAG,IAAI,CAACgP,eAAe,CAAC,YAAYC,MAAM,CAAC3Z,KAAK,EAAE,EAAE2Z,MAAM,EAAES,UAAU,CAACR,UAAU,IAAI,CAAC,EAAEQ,UAAU,CAAC9S,UAAU,CAAC;IAE9H,OAAO8S,UAAU,CAAC1P,KAAK;EAC3B;EAEQ4P,kBAAkB,CAACxa,OAAe,EAAE6O,QAAmB,EAAErO,WAAkC;IAC/F,IAAIqO,QAAQ,CAACjE,KAAK,EAAE;MAChB,OAAOiE,QAAQ,CAACjE,KAAK;;IAGzB,MAAM6P,aAAa,GAAGla,UAAU,CAACma,iBAAiB,CAAC1a,OAAO,EAAE6O,QAAQ,CAACuC,IAAI,CAAC;IAC1E,MAAMuJ,UAAU,GAAGF,aAAa,GAAGzc,YAAY,CAAC4c,iBAAiB,CAAC/L,QAAQ,CAACiB,aAAa,CAAC;IACzF,MAAMxP,MAAM,GAAGma,aAAa,GAAG5L,QAAQ,CAACwB,KAAK;IAE7C,IAAIxB,QAAQ,CAACyL,UAAU,IAAIna,SAAS,EAAE;MAClC0O,QAAQ,CAACjE,KAAK,GAAGpI,OAAO,CAACC,OAAO,CAAC,IAAIjC,WAAW,CAACF,MAAM,CAAC,CAAC;KAC5D,MAAM;MACH,MAAMga,UAAU,GAAGxa,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,aAAa,EAAE,IAAI,CAACkB,KAAK,CAACyG,WAAW,EAAEkH,QAAQ,CAACyL,UAAU,CAAC;MACtGzL,QAAQ,CAACjE,KAAK,GAAG,IAAI,CAACyP,mBAAmB,CAAC,gBAAgBC,UAAU,CAACpa,KAAK,EAAE,EAAEoa,UAAU,CAAC,CAAC5X,IAAI,CAAEN,IAAI,IAAI;QACpG,IAAIyM,QAAQ,CAACiB,aAAa,yBAAoC,CAACjB,QAAQ,CAACgB,UAAU,KAAK,CAACyK,UAAU,CAACK,UAAU,IAAIL,UAAU,CAACK,UAAU,KAAKA,UAAU,CAAC,EAAE;UACpJ,OAAOpa,UAAU,CAACsa,cAAc,CAAC7a,OAAO,EAAE6O,QAAQ,CAACiB,aAAa,EAAE1N,IAAI,EAAEyM,QAAQ,CAACiL,UAAU,EAAExZ,MAAM,CAAC;SACvG,MAAM;UACH,MAAMwa,UAAU,GAAG,IAAIta,WAAW,CAACF,MAAM,CAAC;UAC1CtC,YAAY,CAAC+c,OAAO,CAChB3Y,IAAI,EACJyM,QAAQ,CAACiL,UAAU,IAAI,CAAC,EACxBQ,UAAU,CAACK,UAAU,IAAIA,UAAU,EACnCF,aAAa,EACb5L,QAAQ,CAACiB,aAAa,EACtBgL,UAAU,CAACxa,MAAM,EACjBuO,QAAQ,CAACgB,UAAU,IAAI,KAAK,EAC5B,CAAC2C,KAAK,EAAEtS,KAAK,KAAI;YACb4a,UAAU,CAAC5a,KAAK,CAAC,GAAGsS,KAAK;UAC7B,CAAC,CACJ;UACD,OAAOsI,UAAU;;MAEzB,CAAC,CAAC;;IAGN,IAAIjM,QAAQ,CAACmM,MAAM,EAAE;MACjB,MAAMA,MAAM,GAAGnM,QAAQ,CAACmM,MAAM;MAC9BnM,QAAQ,CAACjE,KAAK,GAAGiE,QAAQ,CAACjE,KAAK,CAAClI,IAAI,CAAEN,IAAI,IAAI;QAC1C,MAAM0Y,UAAU,GAAG1Y,IAAsB;QACzC,MAAM6Y,iBAAiB,GAAGnb,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,4BAA4B,EAAE,IAAI,CAACkB,KAAK,CAACyG,WAAW,EAAEqT,MAAM,CAACrM,OAAO,CAAC2L,UAAU,CAAC;QAClI,MAAMY,gBAAgB,GAAGpb,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,2BAA2B,EAAE,IAAI,CAACkB,KAAK,CAACyG,WAAW,EAAEqT,MAAM,CAACG,MAAM,CAACb,UAAU,CAAC;QAC/H,OAAO9X,OAAO,CAAC8D,GAAG,CAAC,CACf,IAAI,CAAC+T,mBAAmB,CAAC,gBAAgBY,iBAAiB,CAAC/a,KAAK,EAAE,EAAE+a,iBAAiB,CAAC,EACtF,IAAI,CAACZ,mBAAmB,CAAC,gBAAgBa,gBAAgB,CAAChb,KAAK,EAAE,EAAEgb,gBAAgB,CAAC,CACvF,CAAC,CAACxY,IAAI,CAAC,CAAC,CAAC0Y,WAAW,EAAEC,UAAU,CAAC,KAAI;UAClC,MAAM1M,OAAO,GAAGpO,UAAU,CAACsa,cAAc,CACrC,GAAG7a,OAAO,iBAAiB,EAC3Bgb,MAAM,CAACrM,OAAO,CAACmB,aAAa,EAC5BsL,WAAW,EACXJ,MAAM,CAACrM,OAAO,CAACmL,UAAU,EACzBkB,MAAM,CAAC3K,KAAK,CACC;UAEjB,MAAMiL,YAAY,GAAGb,aAAa,GAAGO,MAAM,CAAC3K,KAAK;UACjD,IAAI8K,MAAsB;UAE1B,IAAItM,QAAQ,CAACiB,aAAa,yBAAoC,CAACjB,QAAQ,CAACgB,UAAU,EAAE;YAChFsL,MAAM,GAAG5a,UAAU,CAACsa,cAAc,CAAC,GAAG7a,OAAO,gBAAgB,EAAE6O,QAAQ,CAACiB,aAAa,EAAEuL,UAAU,EAAEL,MAAM,CAACG,MAAM,CAACrB,UAAU,EAAEwB,YAAY,CAAC;WAC7I,MAAM;YACH,MAAMC,UAAU,GAAGhb,UAAU,CAACsa,cAAc,CAAC,GAAG7a,OAAO,gBAAgB,EAAE6O,QAAQ,CAACiB,aAAa,EAAEuL,UAAU,EAAEL,MAAM,CAACG,MAAM,CAACrB,UAAU,EAAEwB,YAAY,CAAC;YACpJH,MAAM,GAAG,IAAI3a,WAAW,CAAC8a,YAAY,CAAC;YACtCtd,YAAY,CAAC+c,OAAO,CAACQ,UAAU,EAAE,CAAC,EAAEZ,UAAU,EAAEF,aAAa,EAAE5L,QAAQ,CAACiB,aAAa,EAAEqL,MAAM,CAAC7a,MAAM,EAAEuO,QAAQ,CAACgB,UAAU,IAAI,KAAK,EAAE,CAAC2C,KAAK,EAAEtS,KAAK,KAAI;cACjJib,MAAM,CAACjb,KAAK,CAAC,GAAGsS,KAAK;YACzB,CAAC,CAAC;;UAGN,IAAIgJ,WAAW,GAAG,CAAC;UACnB,KAAK,IAAIC,YAAY,GAAG,CAAC,EAAEA,YAAY,GAAG9M,OAAO,CAACrO,MAAM,EAAEmb,YAAY,EAAE,EAAE;YACtE,IAAI5I,SAAS,GAAGlE,OAAO,CAAC8M,YAAY,CAAC,GAAGhB,aAAa;YACrD,KAAK,IAAIiB,cAAc,GAAG,CAAC,EAAEA,cAAc,GAAGjB,aAAa,EAAEiB,cAAc,EAAE,EAAE;cAC3EZ,UAAU,CAACjI,SAAS,EAAE,CAAC,GAAGsI,MAAM,CAACK,WAAW,EAAE,CAAC;;;UAIvD,OAAOV,UAAU;QACrB,CAAC,CAAC;MACN,CAAC,CAAC;;IAGN,OAAOjM,QAAQ,CAACjE,KAAK;EACzB;EAEA;;;EAGOyH,uBAAuB,CAACrS,OAAe,EAAE6O,QAAmB;IAC/D,OAAO,IAAI,CAAC2L,kBAAkB,CAACxa,OAAO,EAAE6O,QAAQ,EAAE0D,YAAY,CAA0B;EAC5F;EAEQzD,yBAAyB,CAAC9O,OAAe,EAAE6O,QAAmB;IAClE,IAAIA,QAAQ,CAACuC,IAAI,4BAA0B;MACvC,MAAM,IAAIhR,KAAK,CAAC,GAAGJ,OAAO,wBAAwB6O,QAAQ,CAACuC,IAAI,EAAE,CAAC;;IAGtE,IACIvC,QAAQ,CAACiB,aAAa,iCACtBjB,QAAQ,CAACiB,aAAa,kCACtBjB,QAAQ,CAACiB,aAAa,8BACxB;MACE,MAAM,IAAI1P,KAAK,CAAC,GAAGJ,OAAO,iCAAiC6O,QAAQ,CAACiB,aAAa,EAAE,CAAC;;IAGxF,IAAIjB,QAAQ,CAACjE,KAAK,EAAE;MAChB,OAAOiE,QAAQ,CAACjE,KAA8B;;IAGlD,IAAIiE,QAAQ,CAACmM,MAAM,EAAE;MACjB,MAAMxa,WAAW,GAAGD,UAAU,CAACob,yBAAyB,CAAC,GAAG3b,OAAO,gBAAgB,EAAE6O,QAAQ,CAACiB,aAAa,CAAC;MAC5GjB,QAAQ,CAACjE,KAAK,GAAG,IAAI,CAAC4P,kBAAkB,CAACxa,OAAO,EAAE6O,QAAQ,EAAErO,WAAW,CAAC;KAC3E,MAAM;MACH,MAAM8Z,UAAU,GAAGxa,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,aAAa,EAAE,IAAI,CAACkB,KAAK,CAACyG,WAAW,EAAEkH,QAAQ,CAACyL,UAAU,CAAC;MACtGzL,QAAQ,CAACjE,KAAK,GAAG,IAAI,CAACyP,mBAAmB,CAAC,gBAAgBC,UAAU,CAACpa,KAAK,EAAE,EAAEoa,UAAU,CAAC,CAAC5X,IAAI,CAAEN,IAAI,IAAI;QACpG,OAAO7B,UAAU,CAACsa,cAAc,CAAC7a,OAAO,EAAE6O,QAAQ,CAACiB,aAAa,EAAE1N,IAAI,EAAEyM,QAAQ,CAACiL,UAAU,EAAEjL,QAAQ,CAACwB,KAAK,CAAC;MAChH,CAAC,CAAC;;IAGN,OAAOxB,QAAQ,CAACjE,KAA8B;EAClD;EAEQgR,0BAA0B,CAACtB,UAAuB;IACtD,IAAIA,UAAU,CAACuB,cAAc,EAAE;MAC3B,OAAOvB,UAAU,CAACuB,cAAc;;IAGpC,MAAMC,MAAM,GAAG,IAAI,CAACxa,aAAa,CAACya,SAAS,EAAE;IAC7CzB,UAAU,CAACuB,cAAc,GAAG,IAAI,CAACxB,mBAAmB,CAAC,gBAAgBC,UAAU,CAACpa,KAAK,EAAE,EAAEoa,UAAU,CAAC,CAAC5X,IAAI,CAAEN,IAAI,IAAI;MAC/G,OAAO,IAAIrE,MAAM,CAAC+d,MAAM,EAAE1Z,IAAI,EAAE,KAAK,CAAC;IAC1C,CAAC,CAAC;IAEF,OAAOkY,UAAU,CAACuB,cAAc;EACpC;EAEQzM,wBAAwB,CAACpP,OAAe,EAAE6O,QAAmB,EAAEK,IAAY;;IAC/E,IAAI,cAAQ,CAAC8M,oBAAoB,0CAAG9M,IAAI,CAAC,EAAE;MACvC,OAAOL,QAAQ,CAACmN,oBAAoB,CAAC9M,IAAI,CAAC;;IAG9C,IAAI,CAACL,QAAQ,CAACmN,oBAAoB,EAAE;MAChCnN,QAAQ,CAACmN,oBAAoB,GAAG,EAAE;;IAGtC,MAAMF,MAAM,GAAG,IAAI,CAACxa,aAAa,CAACya,SAAS,EAAE;IAE7C,IAAIlN,QAAQ,CAACmM,MAAM,EAAE;MACjBnM,QAAQ,CAACmN,oBAAoB,CAAC9M,IAAI,CAAC,GAAG,IAAI,CAACmD,uBAAuB,CAACrS,OAAO,EAAE6O,QAAQ,CAAC,CAACnM,IAAI,CAAEN,IAAI,IAAI;QAChG,OAAO,IAAIpE,YAAY,CAAC8d,MAAM,EAAE1Z,IAAI,EAAE8M,IAAI,EAAE,KAAK,CAAC;MACtD,CAAC,CAAC;;IAEN;IACA;IAAA,KACK,IAAIA,IAAI,KAAKlR,YAAY,CAACgT,mBAAmB,IAAI9B,IAAI,KAAKlR,YAAY,CAACsS,wBAAwB,EAAE;MAClGzB,QAAQ,CAACmN,oBAAoB,CAAC9M,IAAI,CAAC,GAAG,IAAI,CAACmD,uBAAuB,CAACrS,OAAO,EAAE6O,QAAQ,CAAC,CAACnM,IAAI,CAAEN,IAAI,IAAI;QAChG,OAAO,IAAIpE,YAAY,CAAC8d,MAAM,EAAE1Z,IAAI,EAAE8M,IAAI,EAAE,KAAK,CAAC;MACtD,CAAC,CAAC;KACL,MAAM;MACH,MAAMoL,UAAU,GAAGxa,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,aAAa,EAAE,IAAI,CAACkB,KAAK,CAACyG,WAAW,EAAEkH,QAAQ,CAACyL,UAAU,CAAC;MACtGzL,QAAQ,CAACmN,oBAAoB,CAAC9M,IAAI,CAAC,GAAG,IAAI,CAAC0M,0BAA0B,CAACtB,UAAU,CAAC,CAAC5X,IAAI,CAAEuZ,aAAa,IAAI;QACrG,MAAMC,IAAI,GAAG3b,UAAU,CAACma,iBAAiB,CAAC1a,OAAO,EAAE6O,QAAQ,CAACuC,IAAI,CAAC;QACjE,OAAO,IAAIpT,YAAY,CACnB8d,MAAM,EACNG,aAAa,EACb/M,IAAI,EACJ,KAAK,EACL,KAAK,EACLoL,UAAU,CAACK,UAAU,EACrB,KAAK,EACL9L,QAAQ,CAACiL,UAAU,EACnBoC,IAAI,EACJrN,QAAQ,CAACiB,aAAa,EACtBjB,QAAQ,CAACgB,UAAU,EACnB,IAAI,EACJ,CAAC,EACD,IAAI,CACP;MACL,CAAC,CAAC;;IAGN,OAAOhB,QAAQ,CAACmN,oBAAoB,CAAC9M,IAAI,CAAC;EAC9C;EAEQiN,6CAA6C,CAACnc,OAAe,EAAEiY,UAAyC,EAAE3J,eAAyB;IACvI,IAAI,EAAEA,eAAe,YAAY1Q,WAAW,CAAC,EAAE;MAC3C,MAAM,IAAIwC,KAAK,CAAC,GAAGJ,OAAO,+BAA+B,CAAC;;IAG9D,MAAMkF,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,IAAIsY,UAAU,EAAE;MACZ,IAAIA,UAAU,CAACmE,eAAe,EAAE;QAC5B9N,eAAe,CAAC+N,WAAW,GAAGlf,MAAM,CAACmW,SAAS,CAAC2E,UAAU,CAACmE,eAAe,CAAC;QAC1E9N,eAAe,CAACgO,KAAK,GAAGrE,UAAU,CAACmE,eAAe,CAAC,CAAC,CAAC;OACxD,MAAM;QACH9N,eAAe,CAAC+N,WAAW,GAAGlf,MAAM,CAACof,KAAK,EAAE;;MAGhDjO,eAAe,CAACkO,QAAQ,GAAGvE,UAAU,CAACwE,cAAc,IAAItc,SAAS,GAAG,CAAC,GAAG8X,UAAU,CAACwE,cAAc;MACjGnO,eAAe,CAACoO,SAAS,GAAGzE,UAAU,CAAC0E,eAAe,IAAIxc,SAAS,GAAG,CAAC,GAAG8X,UAAU,CAAC0E,eAAe;MAEpG,IAAI1E,UAAU,CAAC2E,gBAAgB,EAAE;QAC7B1X,QAAQ,CAACI,IAAI,CACT,IAAI,CAACuX,oBAAoB,CAAC,GAAG7c,OAAO,mBAAmB,EAAEiY,UAAU,CAAC2E,gBAAgB,EAAGE,OAAO,IAAI;UAC9FA,OAAO,CAAClc,IAAI,GAAG,GAAG0N,eAAe,CAAC1N,IAAI,eAAe;UACrD0N,eAAe,CAACyO,aAAa,GAAGD,OAAO;QAC3C,CAAC,CAAC,CACL;;MAGL,IAAI7E,UAAU,CAAC+E,wBAAwB,EAAE;QACrC/E,UAAU,CAAC+E,wBAAwB,CAACC,YAAY,GAAG,IAAI;QACvD/X,QAAQ,CAACI,IAAI,CACT,IAAI,CAACuX,oBAAoB,CAAC,GAAG7c,OAAO,2BAA2B,EAAEiY,UAAU,CAAC+E,wBAAwB,EAAGF,OAAO,IAAI;UAC9GA,OAAO,CAAClc,IAAI,GAAG,GAAG0N,eAAe,CAAC1N,IAAI,uBAAuB;UAC7D0N,eAAe,CAAC4O,eAAe,GAAGJ,OAAO;QAC7C,CAAC,CAAC,CACL;QAEDxO,eAAe,CAAC6O,oCAAoC,GAAG,IAAI;QAC3D7O,eAAe,CAAC8O,oCAAoC,GAAG,IAAI;QAC3D9O,eAAe,CAAC+O,oCAAoC,GAAG,KAAK;;;IAIpE,OAAO7a,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EAC/C;EAEA;;;EAGOsD,kBAAkB,CACrBhG,OAAe,EACf6F,QAAmB,EACnBmE,WAA2B,EAC3BlE,eAAuB,EACvByF,SAA8C,MAAK,CAAE,CAAC;IAEtD,MAAM3B,gBAAgB,GAAG,IAAI,CAAC0T,4BAA4B,CAACtd,OAAO,EAAE6F,QAAQ,EAAEmE,WAAW,EAAElE,eAAe,EAAEyF,MAAM,CAAC;IACnH,IAAI3B,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B/D,QAAQ,CAAC+E,KAAK,GAAG/E,QAAQ,CAAC+E,KAAK,IAAI,EAAE;IACrC,IAAI2S,WAAW,GAAG1X,QAAQ,CAAC+E,KAAK,CAAC9E,eAAe,CAAC;IACjD,IAAI,CAACyX,WAAW,EAAE;MACd,IAAI,CAACzT,OAAO,CAAC,GAAG9J,OAAO,IAAI6F,QAAQ,CAACjF,IAAI,IAAI,EAAE,EAAE,CAAC;MAEjD,MAAM0N,eAAe,GAAG,IAAI,CAACkP,cAAc,CAACxd,OAAO,EAAE6F,QAAQ,EAAEC,eAAe,CAAC;MAE/EyX,WAAW,GAAG;QACVjP,eAAe,EAAEA,eAAe;QAChCmP,aAAa,EAAE,EAAE;QACjBjQ,OAAO,EAAE,IAAI,CAACkQ,2BAA2B,CAAC1d,OAAO,EAAE6F,QAAQ,EAAEyI,eAAe;OAC/E;MAEDzI,QAAQ,CAAC+E,KAAK,CAAC9E,eAAe,CAAC,GAAGyX,WAAW;MAE7Chd,UAAU,CAACoL,kBAAkB,CAAC2C,eAAe,EAAEtO,OAAO,CAAC;MACvD,IAAI,CAACU,OAAO,CAAC8N,0BAA0B,CAAC1H,eAAe,CAACwH,eAAe,CAAC;MAExE,IAAI,CAACnE,QAAQ,EAAE;;IAGnB,IAAIH,WAAW,EAAE;MACbuT,WAAW,CAACE,aAAa,CAACnY,IAAI,CAAC0E,WAAW,CAAC;MAE3CA,WAAW,CAAC2T,mBAAmB,CAACC,OAAO,CAAC,MAAK;QACzC,MAAM1d,KAAK,GAAGqd,WAAW,CAACE,aAAa,CAACjT,OAAO,CAACR,WAAW,CAAC;QAC5D,IAAI9J,KAAK,KAAK,CAAC,CAAC,EAAE;UACdqd,WAAW,CAACE,aAAa,CAACI,MAAM,CAAC3d,KAAK,EAAE,CAAC,CAAC;;MAElD,CAAC,CAAC;;IAGNqL,MAAM,CAACgS,WAAW,CAACjP,eAAe,CAAC;IAEnC,OAAOiP,WAAW,CAAC/P,OAAO,CAAC9K,IAAI,CAAC,MAAK;MACjC,OAAO6a,WAAW,CAACjP,eAAe;IACtC,CAAC,CAAC;EACN;EAEQC,sBAAsB,CAAC3N,IAAY,EAAEkF,eAAuB;IAChE,IAAI,CAACxE,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;IAClE,MAAM2L,eAAe,GAAG,IAAI1Q,WAAW,CAACgD,IAAI,EAAE,IAAI,CAACU,aAAa,CAAC;IACjEgN,eAAe,CAACpF,gBAAgB,GAAG,IAAI,CAACvG,eAAe;IACvD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;IACjD;IACAqF,eAAe,CAACwP,QAAQ,GAAGhY,eAAe;IAC1CwI,eAAe,CAACyP,0BAA0B,GAAG,IAAI;IACjDzP,eAAe,CAAC0P,oBAAoB,GAAG,CAAC,IAAI,CAACtd,OAAO,CAACud,sBAAsB;IAC3E3P,eAAe,CAAC4P,oBAAoB,GAAG,CAAC,IAAI,CAACxd,OAAO,CAACud,sBAAsB;IAC3E3P,eAAe,CAAC6P,gBAAgB,GAAGvgB,WAAW,CAACwgB,kBAAkB;IACjE9P,eAAe,CAACkO,QAAQ,GAAG,CAAC;IAC5BlO,eAAe,CAACoO,SAAS,GAAG,CAAC;IAC7B,OAAOpO,eAAe;EAC1B;EAEA;;;;;;;EAOOkP,cAAc,CAACxd,OAAe,EAAE6F,QAAmB,EAAEC,eAAuB;IAC/E,MAAM8D,gBAAgB,GAAG,IAAI,CAACyU,yBAAyB,CAACre,OAAO,EAAE6F,QAAQ,EAAEC,eAAe,CAAC;IAC3F,IAAI8D,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,MAAMhJ,IAAI,GAAGiF,QAAQ,CAACjF,IAAI,IAAI,WAAWiF,QAAQ,CAAC3F,KAAK,EAAE;IACzD,MAAMoO,eAAe,GAAG,IAAI,CAACC,sBAAsB,CAAC3N,IAAI,EAAEkF,eAAe,CAAC;IAE1E,OAAOwI,eAAe;EAC1B;EAEA;;;;;;;EAOOoP,2BAA2B,CAAC1d,OAAe,EAAE6F,QAAmB,EAAEyI,eAAyB;IAC9F,MAAM1E,gBAAgB,GAAG,IAAI,CAAC0U,sCAAsC,CAACte,OAAO,EAAE6F,QAAQ,EAAEyI,eAAe,CAAC;IACxG,IAAI1E,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,MAAM1E,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1CuF,QAAQ,CAACI,IAAI,CAAC,IAAI,CAACiZ,+BAA+B,CAACve,OAAO,EAAE6F,QAAQ,EAAEyI,eAAe,CAAC,CAAC;IAEvF,IAAIzI,QAAQ,CAAC2Y,oBAAoB,EAAE;MAC/BtZ,QAAQ,CAACI,IAAI,CAAC,IAAI,CAAC6W,6CAA6C,CAAC,GAAGnc,OAAO,uBAAuB,EAAE6F,QAAQ,CAAC2Y,oBAAoB,EAAElQ,eAAe,CAAC,CAAC;;IAGxJ,IAAI,CAACmQ,2BAA2B,CAACze,OAAO,EAAE6F,QAAQ,EAAEyI,eAAe,CAAC;IAEpE,OAAO9L,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EAC/C;EAEA;;;;;;;EAOO6b,+BAA+B,CAACve,OAAe,EAAE6F,QAAmB,EAAEyI,eAAyB;IAClG,IAAI,EAAEA,eAAe,YAAY1Q,WAAW,CAAC,EAAE;MAC3C,MAAM,IAAIwC,KAAK,CAAC,GAAGJ,OAAO,+BAA+B,CAAC;;IAG9D,MAAMkF,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C2O,eAAe,CAACoQ,aAAa,GAAG7Y,QAAQ,CAAC8Y,cAAc,GAAGxhB,MAAM,CAACmW,SAAS,CAACzN,QAAQ,CAAC8Y,cAAc,CAAC,GAAG,IAAIxhB,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACzH,IAAI0I,QAAQ,CAAC+Y,WAAW,EAAE;MACtBtQ,eAAe,CAACuQ,eAAe,GAAG,KAAK;MACvCvQ,eAAe,CAACwQ,gBAAgB,GAAG,IAAI;;IAG3C,IAAIjZ,QAAQ,CAACkZ,aAAa,EAAE;MACxBlZ,QAAQ,CAACkZ,aAAa,CAAC9B,YAAY,GAAG,IAAI;MAC1C/X,QAAQ,CAACI,IAAI,CACT,IAAI,CAACuX,oBAAoB,CAAC,GAAG7c,OAAO,gBAAgB,EAAE6F,QAAQ,CAACkZ,aAAa,EAAGjC,OAAO,IAAI;QACtFA,OAAO,CAAClc,IAAI,GAAG,GAAG0N,eAAe,CAAC1N,IAAI,WAAW;QACjD0N,eAAe,CAAC0Q,WAAW,GAAGlC,OAAO;MACzC,CAAC,CAAC,CACL;MAEDxO,eAAe,CAAC2Q,gBAAgB,GAAG,CAAC,IAAI,CAAC3d,aAAa,CAACgI,oBAAoB;MAC3EgF,eAAe,CAAC4Q,gBAAgB,GAAG,IAAI,CAAC5d,aAAa,CAACgI,oBAAoB;MAC1E,IAAIzD,QAAQ,CAACkZ,aAAa,CAACvV,KAAK,IAAIrJ,SAAS,IAAImO,eAAe,CAAC0Q,WAAW,EAAE;QAC1E1Q,eAAe,CAAC0Q,WAAW,CAACG,KAAK,GAAGtZ,QAAQ,CAACkZ,aAAa,CAACvV,KAAK;;MAGpE8E,eAAe,CAAC8Q,yBAAyB,GAAG,IAAI;;IAGpD,IAAIvZ,QAAQ,CAACwZ,gBAAgB,EAAE;MAC3BxZ,QAAQ,CAACwZ,gBAAgB,CAACpC,YAAY,GAAG,IAAI;MAC7C/X,QAAQ,CAACI,IAAI,CACT,IAAI,CAACuX,oBAAoB,CAAC,GAAG7c,OAAO,mBAAmB,EAAE6F,QAAQ,CAACwZ,gBAAgB,EAAGvC,OAAO,IAAI;QAC5FA,OAAO,CAAClc,IAAI,GAAG,GAAG0N,eAAe,CAAC1N,IAAI,cAAc;QACpD0N,eAAe,CAACgR,cAAc,GAAGxC,OAAO;MAC5C,CAAC,CAAC,CACL;MAEDxO,eAAe,CAACiR,qBAAqB,GAAG,IAAI;MAC5C,IAAI1Z,QAAQ,CAACwZ,gBAAgB,CAACG,QAAQ,IAAIrf,SAAS,EAAE;QACjDmO,eAAe,CAACmR,sBAAsB,GAAG5Z,QAAQ,CAACwZ,gBAAgB,CAACG,QAAQ;;;IAInF,IAAI3Z,QAAQ,CAAC6Z,eAAe,EAAE;MAC1Bxa,QAAQ,CAACI,IAAI,CACT,IAAI,CAACuX,oBAAoB,CAAC,GAAG7c,OAAO,kBAAkB,EAAE6F,QAAQ,CAAC6Z,eAAe,EAAG5C,OAAO,IAAI;QAC1FA,OAAO,CAAClc,IAAI,GAAG,GAAG0N,eAAe,CAAC1N,IAAI,aAAa;QACnD0N,eAAe,CAACoR,eAAe,GAAG5C,OAAO;MAC7C,CAAC,CAAC,CACL;;IAGL,OAAOta,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EAC/C;EAEA;;;;;;;EAOO+b,2BAA2B,CAACze,OAAe,EAAE6F,QAAmB,EAAEyI,eAAyB;IAC9F,IAAI,EAAEA,eAAe,YAAY1Q,WAAW,CAAC,EAAE;MAC3C,MAAM,IAAIwC,KAAK,CAAC,GAAGJ,OAAO,+BAA+B,CAAC;;IAG9D,MAAM2f,SAAS,GAAG9Z,QAAQ,CAAC8Z,SAAS;IACpC,QAAQA,SAAS;MACb;QAA+B;UAC3BrR,eAAe,CAAC6P,gBAAgB,GAAGvgB,WAAW,CAACwgB,kBAAkB;UACjE;;MAEJ;QAA6B;UACzB9P,eAAe,CAAC6P,gBAAgB,GAAGvgB,WAAW,CAACgiB,qBAAqB;UACpEtR,eAAe,CAACuR,WAAW,GAAGha,QAAQ,CAACia,WAAW,IAAI3f,SAAS,GAAG,GAAG,GAAG0F,QAAQ,CAACia,WAAW;UAC5F,IAAIxR,eAAe,CAACyO,aAAa,EAAE;YAC/BzO,eAAe,CAACyO,aAAa,CAACgD,QAAQ,GAAG,IAAI;;UAEjD;;MAEJ;QAA8B;UAC1BzR,eAAe,CAAC6P,gBAAgB,GAAGvgB,WAAW,CAACoiB,sBAAsB;UACrE,IAAI1R,eAAe,CAACyO,aAAa,EAAE;YAC/BzO,eAAe,CAACyO,aAAa,CAACgD,QAAQ,GAAG,IAAI;YAC7CzR,eAAe,CAAC2R,yBAAyB,GAAG,IAAI;;UAEpD;;MAEJ;QAAS;UACL,MAAM,IAAI7f,KAAK,CAAC,GAAGJ,OAAO,8BAA8B6F,QAAQ,CAAC8Z,SAAS,GAAG,CAAC;;IACjF;EAET;EAEA;;;;;;;EAOO9C,oBAAoB,CAAC7c,OAAe,EAAEkgB,WAAyB,EAAE3U,SAAgD,MAAK,CAAE,CAAC;IAC5H,MAAM3B,gBAAgB,GAAG,IAAI,CAACuW,+BAA+B,CAACngB,OAAO,EAAEkgB,WAAW,EAAE3U,MAAM,CAAC;IAC3F,IAAI3B,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI,CAACE,OAAO,CAAC,GAAG9J,OAAO,EAAE,CAAC;IAE1B,IAAIkgB,WAAW,CAACE,QAAS,IAAI,CAAC,EAAE;MAC5B,MAAM,IAAIhgB,KAAK,CAAC,GAAGJ,OAAO,6BAA6BkgB,WAAW,CAACE,QAAQ,GAAG,CAAC;;IAGnF,MAAMtD,OAAO,GAAGhd,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,QAAQ,EAAE,IAAI,CAACkB,KAAK,CAAC8G,QAAQ,EAAEkY,WAAW,CAAChgB,KAAK,CAAC;IACzF4c,OAAO,CAACuD,YAAY,GAAGH,WAAW;IAElC,MAAM1S,OAAO,GAAG,IAAI,CAAC8S,iBAAiB,CAAC,aAAaJ,WAAW,CAAChgB,KAAK,EAAE,EAAE4c,OAAO,EAAGyD,cAAc,IAAI;MACjGA,cAAc,CAACC,gBAAgB,GAAGN,WAAW,CAACE,QAAQ,IAAI,CAAC;MAC3D7f,UAAU,CAACoL,kBAAkB,CAAC4U,cAAc,EAAEvgB,OAAO,CAAC;MACtD,IAAI,CAACU,OAAO,CAAC+f,yBAAyB,CAAC3Z,eAAe,CAACyZ,cAAc,CAAC;MACtEhV,MAAM,CAACgV,cAAc,CAAC;IAC1B,CAAC,CAAC;IAEF,IAAI,CAACpW,QAAQ,EAAE;IAEf,OAAOqD,OAAO;EAClB;EAEA;;;EAGO8S,iBAAiB,CAACtgB,OAAe,EAAE8c,OAAiB,EAAEvR,SAAgD,MAAK,CAAE,CAAC;IACjH,MAAM3B,gBAAgB,GAAG,IAAI,CAAC8W,2BAA2B,CAAC1gB,OAAO,EAAE8c,OAAO,EAAEvR,MAAM,CAAC;IACnF,IAAI3B,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI,CAACE,OAAO,CAAC,GAAG9J,OAAO,IAAI8c,OAAO,CAAClc,IAAI,IAAI,EAAE,EAAE,CAAC;IAEhD,MAAM2X,OAAO,GAAGuE,OAAO,CAACvE,OAAO,IAAIpY,SAAS,GAAGI,UAAU,CAACogB,cAAc,GAAG7gB,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,UAAU,EAAE,IAAI,CAACkB,KAAK,CAAC4G,QAAQ,EAAEgV,OAAO,CAACvE,OAAO,CAAC;IACpJ,MAAMqI,KAAK,GAAG9gB,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,SAAS,EAAE,IAAI,CAACkB,KAAK,CAAC2G,MAAM,EAAEiV,OAAO,CAAC+D,MAAM,CAAC;IACnF,MAAMrT,OAAO,GAAG,IAAI,CAACsT,mBAAmB,CAAC9gB,OAAO,EAAEuY,OAAO,EAAEqI,KAAK,EAAErV,MAAM,EAAEpL,SAAS,EAAE,CAAC2c,OAAO,CAACuD,YAAY,CAACpD,YAAY,CAAC;IAExH,IAAI,CAAC9S,QAAQ,EAAE;IAEf,OAAOqD,OAAO;EAClB;EAEA;;;EAGOsT,mBAAmB,CACtB9gB,OAAe,EACfuY,OAAiB,EACjBqI,KAAa,EACbrV,SAAgD,MAAK,CAAE,CAAC,EACxDwV,oBAA0B,EAC1BC,aAAuB;IAEvB,MAAMC,WAAW,GAAG,IAAI,CAACC,YAAY,CAAC,aAAa3I,OAAO,CAACrY,KAAK,EAAE,EAAEqY,OAAO,CAAC;IAE5E,MAAMrT,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,MAAMwhB,QAAQ,GAAG,IAAIrkB,QAAQ,EAAQ;IACrC,IAAI,CAACwE,aAAa,CAAC2H,sBAAsB,GAAG,CAAC,CAAC,IAAI,CAACtG,eAAe;IAClE,MAAMye,sBAAsB,GAA4B;MACpDC,QAAQ,EAAEJ,WAAW,CAACK,SAAS;MAC/BC,OAAO,EAAE,KAAK;MACdC,YAAY,EAAEP,WAAW,CAACO,YAAY;MACtC3J,MAAM,EAAE,MAAK;QACT,IAAI,CAAC,IAAI,CAACnW,SAAS,EAAE;UACjByf,QAAQ,CAAC1e,OAAO,EAAE;;MAE1B,CAAC;MACDgf,OAAO,EAAE,CAACrH,OAAgB,EAAEsH,SAAe,KAAI;QAC3C,IAAI,CAAC,IAAI,CAAChgB,SAAS,EAAE;UACjByf,QAAQ,CAACQ,MAAM,CAAC,IAAIvhB,KAAK,CAAC,GAAGJ,OAAO,KAAK0hB,SAAS,IAAIA,SAAS,CAACtH,OAAO,GAAGsH,SAAS,CAACtH,OAAO,GAAGA,OAAO,IAAI,wBAAwB,EAAE,CAAC,CAAC;;MAE7I,CAAC;MACDwH,QAAQ,EAAEhB,KAAK,CAACgB,QAAQ;MACxBC,aAAa,EAAEd,oBAAoB;MACnCC,aAAa,EAAE,CAAC,CAACA,aAAa,IAAI,IAAI,CAACtgB,OAAO,CAACohB;KAClD;IACD,MAAMvB,cAAc,GAAG,IAAI1iB,OAAO,CAAC,IAAI,EAAE,IAAI,CAACyD,aAAa,EAAE8f,sBAAsB,CAAC;IACpFb,cAAc,CAACrX,gBAAgB,GAAG,IAAI,CAACvG,eAAe;IACtD,IAAI,CAACrB,aAAa,CAAC2H,sBAAsB,GAAG,KAAK;IACjD/D,QAAQ,CAACI,IAAI,CAAC6b,QAAQ,CAAC3T,OAAO,CAAC;IAE/BtI,QAAQ,CAACI,IAAI,CACT,IAAI,CAACyc,cAAc,CAAC,WAAWnB,KAAK,CAAC1gB,KAAK,EAAE,EAAE0gB,KAAK,CAAC,CAACle,IAAI,CAAEN,IAAI,IAAI;MAC/D,MAAMxB,IAAI,GAAGggB,KAAK,CAACtZ,GAAG,IAAI,GAAG,IAAI,CAAC/C,SAAS,SAASqc,KAAK,CAAC1gB,KAAK,EAAE;MACjE,MAAM8hB,OAAO,GAAG,QAAQ,IAAI,CAAC7d,cAAc,GAAGvD,IAAI,EAAE;MACpD2f,cAAc,CAAC0B,SAAS,CAACD,OAAO,EAAE5f,IAAI,CAAC;IAC3C,CAAC,CAAC,CACL;IAEDme,cAAc,CAAC2B,KAAK,GAAGjB,WAAW,CAACiB,KAAK;IACxC3B,cAAc,CAAC4B,KAAK,GAAGlB,WAAW,CAACkB,KAAK;IACxC5W,MAAM,CAACgV,cAAc,CAAC;IAEtB,OAAO/d,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,OAAO6d,cAAc;IACzB,CAAC,CAAC;EACN;EAEQW,YAAY,CAAClhB,OAAe,EAAEuY,OAAiB;IACnD,IAAI,CAACA,OAAO,CAAC3N,KAAK,EAAE;MAChB2N,OAAO,CAAC3N,KAAK,GAAG;QACZ0W,SAAS,EAAE/I,OAAO,CAAC6J,SAAS,2BAAiC7J,OAAO,CAAC6J,SAAS;QAC9EZ,YAAY,EAAEjhB,UAAU,CAAC8hB,uBAAuB,CAACriB,OAAO,EAAEuY,OAAO,CAAC;QAClE2J,KAAK,EAAE3hB,UAAU,CAAC+hB,mBAAmB,CAAC,GAAGtiB,OAAO,QAAQ,EAAEuY,OAAO,CAACgK,KAAK,CAAC;QACxEJ,KAAK,EAAE5hB,UAAU,CAAC+hB,mBAAmB,CAAC,GAAGtiB,OAAO,QAAQ,EAAEuY,OAAO,CAACiK,KAAK;OAC1E;;IAGL,OAAOjK,OAAO,CAAC3N,KAAK;EACxB;EAEA;;;;;;EAMOmX,cAAc,CAAC/hB,OAAe,EAAE4gB,KAAa;IAChD,IAAI,CAACA,KAAK,CAAChW,KAAK,EAAE;MACd,IAAI,CAACd,OAAO,CAAC,GAAG9J,OAAO,IAAI4gB,KAAK,CAAChgB,IAAI,IAAI,EAAE,EAAE,CAAC;MAE9C,IAAIggB,KAAK,CAACtZ,GAAG,EAAE;QACXsZ,KAAK,CAAChW,KAAK,GAAG,IAAI,CAACoP,YAAY,CAAC,GAAGha,OAAO,MAAM,EAAE4gB,KAAK,EAAEA,KAAK,CAACtZ,GAAG,CAAC;OACtE,MAAM;QACH,MAAMgT,UAAU,GAAGxa,SAAS,CAACC,GAAG,CAAC,GAAGC,OAAO,aAAa,EAAE,IAAI,CAACkB,KAAK,CAACyG,WAAW,EAAEiZ,KAAK,CAACtG,UAAU,CAAC;QACnGsG,KAAK,CAAChW,KAAK,GAAG,IAAI,CAACyP,mBAAmB,CAAC,gBAAgBC,UAAU,CAACpa,KAAK,EAAE,EAAEoa,UAAU,CAAC;;MAG1F,IAAI,CAACnQ,QAAQ,EAAE;;IAGnB,OAAOyW,KAAK,CAAChW,KAAK;EACtB;EAEA;;;;;;;EAOOoP,YAAY,CAACha,OAAe,EAAE0Y,QAAmB,EAAEpR,GAAW;IACjE,MAAMsC,gBAAgB,GAAG,IAAI,CAAC6Y,uBAAuB,CAACziB,OAAO,EAAE0Y,QAAQ,EAAEpR,GAAG,CAAC;IAC7E,IAAIsC,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB;;IAG3B,IAAI,CAACrJ,UAAU,CAACmiB,YAAY,CAACpb,GAAG,CAAC,EAAE;MAC/B,MAAM,IAAIlH,KAAK,CAAC,GAAGJ,OAAO,MAAMsH,GAAG,cAAc,CAAC;;IAGtD,IAAI5I,eAAe,CAAC4I,GAAG,CAAC,EAAE;MACtB,MAAMlF,IAAI,GAAG,IAAI8X,UAAU,CAACzb,uBAAuB,CAAC6I,GAAG,CAAC,CAAC;MACzD,IAAI,CAACqb,GAAG,CAAC,GAAG3iB,OAAO,aAAasH,GAAG,CAACsb,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQxgB,IAAI,CAAC9B,MAAM,SAAS,CAAC;MAC9E,OAAOkC,OAAO,CAACC,OAAO,CAACL,IAAI,CAAC;;IAGhC,IAAI,CAACugB,GAAG,CAAC,GAAG3iB,OAAO,aAAasH,GAAG,EAAE,CAAC;IAEtC,OAAO,IAAI,CAAC5G,OAAO,CAACmiB,kBAAkB,CAAC,IAAI,CAAC3e,QAAQ,GAAGoD,GAAG,CAAC,CAAC5E,IAAI,CAAEogB,GAAG,IAAI;MACrE,OAAO,IAAItgB,OAAO,CAAC,CAACC,OAAO,EAAEkf,MAAM,KAAI;QACnC,IAAI,CAACjhB,OAAO,CAACqiB,SAAS,CAClB,IAAI,CAACzhB,aAAa,EAClBwhB,GAAG,EACF1gB,IAAI,IAAI;UACL,IAAI,CAAC,IAAI,CAACV,SAAS,EAAE;YACjB,IAAI,CAACihB,GAAG,CAAC,GAAG3iB,OAAO,YAAYsH,GAAG,KAAMlF,IAAoB,CAACoF,UAAU,SAAS,CAAC;YACjF/E,OAAO,CAAC,IAAIyX,UAAU,CAAC9X,IAAmB,CAAC,CAAC;;QAEpD,CAAC,EACD,IAAI,EACH4gB,OAAO,IAAI;UACRrB,MAAM,CAAC,IAAIhjB,aAAa,CAAC,GAAGqB,OAAO,qBAAqBsH,GAAG,IAAI0b,OAAO,GAAG,IAAI,GAAGA,OAAO,CAACC,MAAM,GAAG,GAAG,GAAGD,OAAO,CAACE,UAAU,GAAG,EAAE,EAAE,EAAEF,OAAO,CAAC,CAAC;QAC/I,CAAC,CACJ;MACL,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;;;EAKO,OAAOrX,kBAAkB,CAACwX,aAA4B,EAAEC,OAAe;IAC1ED,aAAa,CAAC7W,QAAQ,GAAG6W,aAAa,CAAC7W,QAAQ,IAAI,EAAE;IACrD,MAAMA,QAAQ,GAAI6W,aAAa,CAACE,iBAAiB,GAAGF,aAAa,CAACE,iBAAiB,IAAI,EAAG;IAC1F,MAAMpiB,IAAI,GAAIqL,QAAQ,CAACrL,IAAI,GAAGqL,QAAQ,CAACrL,IAAI,IAAI,EAAG;IAClD,MAAMqiB,QAAQ,GAAIriB,IAAI,CAACqiB,QAAQ,GAAGriB,IAAI,CAACqiB,QAAQ,IAAI,EAAG;IACtDA,QAAQ,CAAChe,IAAI,CAAC8d,OAAO,CAAC;EAC1B;EAEQ,OAAOd,mBAAmB,CAACtiB,OAAe,EAAEqO,IAAiC;IACjF;IACAA,IAAI,GAAGA,IAAI,IAAIlO,SAAS,GAAE,qBAA0BkO,IAAI;IAExD,QAAQA,IAAI;MACR;QACI,OAAOxQ,OAAO,CAAC0lB,iBAAiB;MACpC;QACI,OAAO1lB,OAAO,CAAC2lB,kBAAkB;MACrC;QACI,OAAO3lB,OAAO,CAAC4lB,gBAAgB;MACnC;QACI7kB,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,oBAAoBqO,IAAI,GAAG,CAAC;QAClD,OAAOxQ,OAAO,CAAC4lB,gBAAgB;IAAC;EAE5C;EAEQ,OAAOpB,uBAAuB,CAACriB,OAAe,EAAEuY,OAAiB;IACrE;IACA,MAAMmL,SAAS,GAAGnL,OAAO,CAACmL,SAAS,IAAIvjB,SAAS,GAAE,oBAA2BoY,OAAO,CAACmL,SAAS;IAC9F,MAAMtB,SAAS,GAAG7J,OAAO,CAAC6J,SAAS,IAAIjiB,SAAS,GAAE,kCAAyCoY,OAAO,CAAC6J,SAAS;IAE5G,IAAIsB,SAAS,wBAA8B;MACvC,QAAQtB,SAAS;QACb;UACI,OAAOvkB,OAAO,CAAC8lB,cAAc;QACjC;UACI,OAAO9lB,OAAO,CAAC+lB,aAAa;QAChC;UACI,OAAO/lB,OAAO,CAACgmB,yBAAyB;QAC5C;UACI,OAAOhmB,OAAO,CAACimB,wBAAwB;QAC3C;UACI,OAAOjmB,OAAO,CAACkmB,wBAAwB;QAC3C;UACI,OAAOlmB,OAAO,CAACmmB,uBAAuB;QAC1C;UACIplB,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,8BAA8BoiB,SAAS,GAAG,CAAC;UACjE,OAAOvkB,OAAO,CAACmmB,uBAAuB;MAAC;KAElD,MAAM;MACH,IAAIN,SAAS,yBAA+B;QACxC9kB,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,8BAA8B0jB,SAAS,GAAG,CAAC;;MAGrE,QAAQtB,SAAS;QACb;UACI,OAAOvkB,OAAO,CAAComB,eAAe;QAClC;UACI,OAAOpmB,OAAO,CAACqmB,cAAc;QACjC;UACI,OAAOrmB,OAAO,CAACsmB,0BAA0B;QAC7C;UACI,OAAOtmB,OAAO,CAACumB,yBAAyB;QAC5C;UACI,OAAOvmB,OAAO,CAACwmB,yBAAyB;QAC5C;UACI,OAAOxmB,OAAO,CAACymB,wBAAwB;QAC3C;UACI1lB,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,8BAA8BoiB,SAAS,GAAG,CAAC;UACjE,OAAOvkB,OAAO,CAACsmB,0BAA0B;MAAC;;EAG1D;EAEQ,OAAOxI,yBAAyB,CAAC3b,OAAe,EAAE8P,aAAoC;IAC1F,QAAQA,aAAa;MACjB;QACI,OAAOyU,SAAS;MACpB;QACI,OAAOrK,UAAU;MACrB;QACI,OAAOsK,UAAU;MACrB;QACI,OAAOC,WAAW;MACtB;QACI,OAAOC,WAAW;MACtB;QACI,OAAOnS,YAAY;MACvB;QACI,MAAM,IAAInS,KAAK,CAAC,GAAGJ,OAAO,4BAA4B8P,aAAa,EAAE,CAAC;IAAC;EAEnF;EAEQ,OAAO+K,cAAc,CACzB7a,OAAe,EACf8P,aAAoC,EACpCwK,UAA2B,EAC3BR,UAA8B,EAC9BxZ,MAAc;IAEd,MAAMuZ,MAAM,GAAGS,UAAU,CAACT,MAAM;IAChCC,UAAU,GAAGQ,UAAU,CAACR,UAAU,IAAIA,UAAU,IAAI,CAAC,CAAC;IAEtD,MAAMtZ,WAAW,GAAGD,UAAU,CAACob,yBAAyB,CAAC,GAAG3b,OAAO,gBAAgB,EAAE8P,aAAa,CAAC;IAEnG,MAAM6U,mBAAmB,GAAG3mB,YAAY,CAAC4c,iBAAiB,CAAC9K,aAAa,CAAC;IACzE,IAAIgK,UAAU,GAAG6K,mBAAmB,KAAK,CAAC,EAAE;MACxC;MACA/lB,MAAM,CAACmC,IAAI,CAAC,GAAGf,OAAO,oCAAoC8Z,UAAU,sDAAsD6K,mBAAmB,GAAG,CAAC;MACjJ,OAAO,IAAInkB,WAAW,CAACqZ,MAAM,CAAC+K,KAAK,CAAC9K,UAAU,EAAEA,UAAU,GAAGxZ,MAAM,GAAGqkB,mBAAmB,CAAC,EAAE,CAAC,CAAC;;IAGlG,OAAO,IAAInkB,WAAW,CAACqZ,MAAM,EAAEC,UAAU,EAAExZ,MAAM,CAAC;EACtD;EAEQ,OAAOoa,iBAAiB,CAAC1a,OAAe,EAAEoR,IAAY;IAC1D,QAAQA,IAAI;MACR,KAAK,QAAQ;QACT,OAAO,CAAC;MACZ,KAAK,MAAM;QACP,OAAO,CAAC;MACZ,KAAK,MAAM;QACP,OAAO,CAAC;MACZ,KAAK,MAAM;QACP,OAAO,CAAC;MACZ,KAAK,MAAM;QACP,OAAO,CAAC;MACZ,KAAK,MAAM;QACP,OAAO,CAAC;MACZ,KAAK,MAAM;QACP,OAAO,EAAE;IAAC;IAGlB,MAAM,IAAIhR,KAAK,CAAC,GAAGJ,OAAO,mBAAmBoR,IAAI,GAAG,CAAC;EACzD;EAEQ,OAAOsR,YAAY,CAACpb,GAAW;IACnC,OAAOlK,KAAK,CAACynB,QAAQ,CAACvd,GAAG,CAAC,IAAIA,GAAG,CAACkD,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;EAC1D;EAEA;;;EAGO,OAAO4D,YAAY,CAACpO,OAAe,EAAEqO,IAAwB;IAChE,IAAIA,IAAI,IAAIlO,SAAS,EAAE;MACnBkO,IAAI;;;IAGR,QAAQA,IAAI;MACR;QACI,OAAO1Q,QAAQ,CAACmnB,iBAAiB;MACrC;QACI,OAAOnnB,QAAQ,CAAConB,gBAAgB;MACpC;QACI,OAAOpnB,QAAQ,CAACqnB,gBAAgB;MACpC;QACI,OAAOrnB,QAAQ,CAACsnB,iBAAiB;MACrC;QACI,OAAOtnB,QAAQ,CAACoI,gBAAgB;MACpC;QACI,OAAOpI,QAAQ,CAACunB,qBAAqB;MACzC;QACI,OAAOvnB,QAAQ,CAACwnB,mBAAmB;IAAC;IAG5C,MAAM,IAAI/kB,KAAK,CAAC,GAAGJ,OAAO,kCAAkCqO,IAAI,GAAG,CAAC;EACxE;EAEQnI,sBAAsB;IAC1B,IAAI,CAACxF,OAAO,CAACqE,wBAAwB,CAAC,mBAAmB,CAAC;IAE1D,MAAMG,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,IAAI,IAAI,CAACuB,KAAK,CAACyE,SAAS,EAAE;MACtB,KAAK,MAAME,QAAQ,IAAI,IAAI,CAAC3E,KAAK,CAACyE,SAAS,EAAE;QACzC,IAAIE,QAAQ,CAAC+E,KAAK,EAAE;UAChB,KAAK,MAAM9E,eAAe,IAAID,QAAQ,CAAC+E,KAAK,EAAE;YAC1C,MAAM2S,WAAW,GAAG1X,QAAQ,CAAC+E,KAAK,CAAC9E,eAAe,CAAC;YACnD,KAAK,MAAMkE,WAAW,IAAIuT,WAAW,CAACE,aAAa,EAAE;cACjD;cACAzT,WAAW,CAACob,kBAAkB,CAAC,IAAI,CAAC;cAEpC,MAAM9W,eAAe,GAAGiP,WAAW,CAACjP,eAAe;cACnDpJ,QAAQ,CAACI,IAAI,CAACgJ,eAAe,CAAC+W,qBAAqB,CAACrb,WAAW,CAAC,CAAC;cACjE9E,QAAQ,CAACI,IAAI,CAACgJ,eAAe,CAAC+W,qBAAqB,CAACrb,WAAW,EAAE;gBAAEsb,YAAY,EAAE;cAAI,CAAE,CAAC,CAAC;cACzF,IAAI,IAAI,CAAC5kB,OAAO,CAAC6kB,YAAY,EAAE;gBAC3BrgB,QAAQ,CAACI,IAAI,CAACgJ,eAAe,CAAC+W,qBAAqB,CAACrb,WAAW,EAAE;kBAAEwb,SAAS,EAAE;gBAAI,CAAE,CAAC,CAAC;gBACtFtgB,QAAQ,CAACI,IAAI,CAACgJ,eAAe,CAAC+W,qBAAqB,CAACrb,WAAW,EAAE;kBAAEwb,SAAS,EAAE,IAAI;kBAAEF,YAAY,EAAE;gBAAI,CAAE,CAAC,CAAC;;;;;;;IAQlI,OAAO9iB,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,IAAI,CAAChC,OAAO,CAACiG,sBAAsB,CAAC,mBAAmB,CAAC;IAC5D,CAAC,CAAC;EACN;EAEQP,6BAA6B;IACjC,IAAI,CAAC1F,OAAO,CAACqE,wBAAwB,CAAC,2BAA2B,CAAC;IAElE,MAAMG,QAAQ,GAAG,IAAIvF,KAAK,EAAgB;IAE1C,MAAM+D,MAAM,GAAG,IAAI,CAACpC,aAAa,CAACoC,MAAM;IACxC,KAAK,MAAM+hB,KAAK,IAAI/hB,MAAM,EAAE;MACxB,MAAMgiB,SAAS,GAAGD,KAAK,CAACE,kBAAkB,EAAE;MAC5C,IAAID,SAAS,EAAE;QACXxgB,QAAQ,CAACI,IAAI,CAACogB,SAAS,CAACL,qBAAqB,EAAE,CAAC;;;IAIxD,OAAO7iB,OAAO,CAAC8D,GAAG,CAACpB,QAAQ,CAAC,CAACxC,IAAI,CAAC,MAAK;MACnC,IAAI,CAAChC,OAAO,CAACiG,sBAAsB,CAAC,2BAA2B,CAAC;IACpE,CAAC,CAAC;EACN;EAEQif,kBAAkB,CAAC3b,MAAiD;IACxE,KAAK,MAAMpI,SAAS,IAAI,IAAI,CAACD,WAAW,EAAE;MACtC,IAAIC,SAAS,CAACmH,OAAO,EAAE;QACnBiB,MAAM,CAACpI,SAAS,CAAC;;;EAG7B;EAEQgkB,gBAAgB,CAAInN,QAAmB,EAAEoN,YAAoB,EAAEC,WAAyE;IAC5I,KAAK,MAAMlkB,SAAS,IAAI,IAAI,CAACD,WAAW,EAAE;MACtC,IAAIC,SAAS,CAACmH,OAAO,EAAE;QACnB,MAAMgd,EAAE,GAAG,GAAGnkB,SAAS,CAACjB,IAAI,IAAIklB,YAAY,EAAE;QAC9C,MAAMG,cAAc,GAAGvN,QAA2B;QAClDuN,cAAc,CAACC,+BAA+B,GAAGD,cAAc,CAACC,+BAA+B,IAAI,EAAE;QACrG,MAAMC,8BAA8B,GAAGF,cAAc,CAACC,+BAA+B;QACrF,IAAI,CAACC,8BAA8B,CAACH,EAAE,CAAC,EAAE;UACrCG,8BAA8B,CAACH,EAAE,CAAC,GAAG,IAAI;UAEzC,IAAI;YACA,MAAMtf,MAAM,GAAGqf,WAAW,CAAClkB,SAAS,CAAC;YACrC,IAAI6E,MAAM,EAAE;cACR,OAAOA,MAAM;;WAEpB,SAAS;YACN,OAAOyf,8BAA8B,CAACH,EAAE,CAAC;;;;;IAMzD,OAAO,IAAI;EACf;EAEQ/gB,oBAAoB;IACxB,IAAI,CAAC2gB,kBAAkB,CAAE/jB,SAAS,IAAKA,SAAS,CAACukB,SAAS,IAAIvkB,SAAS,CAACukB,SAAS,EAAE,CAAC;EACxF;EAEQ5f,kBAAkB;IACtB,IAAI,CAACof,kBAAkB,CAAE/jB,SAAS,IAAKA,SAAS,CAACwkB,OAAO,IAAIxkB,SAAS,CAACwkB,OAAO,EAAE,CAAC;EACpF;EAEQxc,yBAAyB,CAAC7J,OAAe,EAAEkC,KAAa;IAC5D,OAAO,IAAI,CAAC2jB,gBAAgB,CAAC3jB,KAAK,EAAE,WAAW,EAAGL,SAAS,IAAKA,SAAS,CAAC0D,cAAc,IAAI1D,SAAS,CAAC0D,cAAc,CAACvF,OAAO,EAAEkC,KAAK,CAAC,CAAC;EACzI;EAEQsJ,wBAAwB,CAACxL,OAAe,EAAE+C,IAAW,EAAEwI,MAAqD;IAChH,OAAO,IAAI,CAACsa,gBAAgB,CAAC9iB,IAAI,EAAE,UAAU,EAAGlB,SAAS,IAAKA,SAAS,CAACkI,aAAa,IAAIlI,SAAS,CAACkI,aAAa,CAAC/J,OAAO,EAAE+C,IAAI,EAAEwI,MAAM,CAAC,CAAC;EAC5I;EAEQsK,0BAA0B,CAAC7V,OAAe,EAAE4L,MAAe,EAAEL,MAAuC;IACxG,OAAO,IAAI,CAACsa,gBAAgB,CAACja,MAAM,EAAE,YAAY,EAAG/J,SAAS,IAAKA,SAAS,CAACgK,eAAe,IAAIhK,SAAS,CAACgK,eAAe,CAAC7L,OAAO,EAAE4L,MAAM,EAAEL,MAAM,CAAC,CAAC;EACtJ;EAEQkD,8BAA8B,CAACzO,OAAe,EAAEgN,SAAyB,EAAEhD,WAAiB;IAChG,OAAO,IAAI,CAAC6b,gBAAgB,CAAC7Y,SAAS,EAAE,gBAAgB,EAAGnL,SAAS,IAAKA,SAAS,CAACmM,oBAAoB,IAAInM,SAAS,CAACmM,oBAAoB,CAAChO,OAAO,EAAEgN,SAAS,EAAEhD,WAAW,CAAC,CAAC;EAC/K;EAEQkD,iCAAiC,CACrClN,OAAe,EACfY,IAAY,EACZmC,IAAW,EACXkJ,IAAW,EACXe,SAAyB,EACzBzB,MAA2C;IAE3C,OAAO,IAAI,CAACsa,gBAAgB,CACxB7Y,SAAS,EACT,mBAAmB,EAClBnL,SAAS,IAAKA,SAAS,CAACoL,uBAAuB,IAAIpL,SAAS,CAACoL,uBAAuB,CAACjN,OAAO,EAAEY,IAAI,EAAEmC,IAAI,EAAEkJ,IAAI,EAAEe,SAAS,EAAEzB,MAAM,CAAC,CACtI;EACL;EAEQ+R,4BAA4B,CAChCtd,OAAe,EACf6F,QAAmB,EACnBmE,WAA2B,EAC3BlE,eAAuB,EACvByF,MAA2C;IAE3C,OAAO,IAAI,CAACsa,gBAAgB,CACxBhgB,QAAQ,EACR,cAAc,EACbhE,SAAS,IAAKA,SAAS,CAACmE,kBAAkB,IAAInE,SAAS,CAACmE,kBAAkB,CAAChG,OAAO,EAAE6F,QAAQ,EAAEmE,WAAW,EAAElE,eAAe,EAAEyF,MAAM,CAAC,CACvI;EACL;EAEQ8S,yBAAyB,CAACre,OAAe,EAAE6F,QAAmB,EAAEC,eAAuB;IAC3F,OAAO,IAAI,CAAC+f,gBAAgB,CAAChgB,QAAQ,EAAE,gBAAgB,EAAGhE,SAAS,IAAKA,SAAS,CAAC2b,cAAc,IAAI3b,SAAS,CAAC2b,cAAc,CAACxd,OAAO,EAAE6F,QAAQ,EAAEC,eAAe,CAAC,CAAC;EACrK;EAEQwY,sCAAsC,CAACte,OAAe,EAAE6F,QAAmB,EAAEyI,eAAyB;IAC1G,OAAO,IAAI,CAACuX,gBAAgB,CACxBhgB,QAAQ,EACR,wBAAwB,EACvBhE,SAAS,IAAKA,SAAS,CAAC6b,2BAA2B,IAAI7b,SAAS,CAAC6b,2BAA2B,CAAC1d,OAAO,EAAE6F,QAAQ,EAAEyI,eAAe,CAAC,CACpI;EACL;EAEQ6R,+BAA+B,CAACngB,OAAe,EAAEkgB,WAAyB,EAAE3U,MAA6C;IAC7H,OAAO,IAAI,CAACsa,gBAAgB,CAAC3F,WAAW,EAAE,iBAAiB,EAAGre,SAAS,IAAKA,SAAS,CAACgb,oBAAoB,IAAIhb,SAAS,CAACgb,oBAAoB,CAAC7c,OAAO,EAAEkgB,WAAW,EAAE3U,MAAM,CAAC,CAAC;EAC/K;EAEQmV,2BAA2B,CAAC1gB,OAAe,EAAE8c,OAAiB,EAAEvR,MAA6C;IACjH,OAAO,IAAI,CAACsa,gBAAgB,CAAC/I,OAAO,EAAE,aAAa,EAAGjb,SAAS,IAAKA,SAAS,CAACye,iBAAiB,IAAIze,SAAS,CAACye,iBAAiB,CAACtgB,OAAO,EAAE8c,OAAO,EAAEvR,MAAM,CAAC,CAAC;EAC7J;EAEQ6L,6BAA6B,CAACpX,OAAe,EAAE8K,SAAqB;IACxE,OAAO,IAAI,CAAC+a,gBAAgB,CAAC/a,SAAS,EAAE,eAAe,EAAGjJ,SAAS,IAAKA,SAAS,CAACoV,kBAAkB,IAAIpV,SAAS,CAACoV,kBAAkB,CAACjX,OAAO,EAAE8K,SAAS,CAAC,CAAC;EAC7J;EAEQgN,oCAAoC,CACxC9X,OAAe,EACf4X,gBAAwB,EACxB9M,SAAqB,EACrBwM,OAA0B,EAC1BO,MAA6E;IAE7E,OAAO,IAAI,CAACgO,gBAAgB,CACxB/a,SAAS,EACT,sBAAsB,EACrBjJ,SAAS,IAAKA,SAAS,CAAC0V,0BAA0B,IAAI1V,SAAS,CAAC0V,0BAA0B,CAACvX,OAAO,EAAE4X,gBAAgB,EAAE9M,SAAS,EAAEwM,OAAO,EAAEO,MAAM,CAAC,CACrJ;EACL;EAEQnE,wBAAwB,CAAC1T,OAAe,EAAE+C,IAAW,EAAE4H,IAAW;IACtE,OAAO,IAAI,CAACkb,gBAAgB,CAAClb,IAAI,EAAE,UAAU,EAAG9I,SAAS,IAAKA,SAAS,CAAC0K,cAAc,IAAI1K,SAAS,CAAC0K,cAAc,CAACvM,OAAO,EAAE+C,IAAI,EAAE4H,IAAI,CAAC,CAAC;EAC5I;EAEQ8X,uBAAuB,CAACziB,OAAe,EAAE0Y,QAAmB,EAAEpR,GAAW;IAC7E,OAAO,IAAI,CAACue,gBAAgB,CAACnN,QAAQ,EAAE,SAAS,EAAG7W,SAAS,IAAKA,SAAS,CAACykB,aAAa,IAAIzkB,SAAS,CAACykB,aAAa,CAACtmB,OAAO,EAAE0Y,QAAQ,EAAEpR,GAAG,CAAC,CAAC;EAChJ;EAEQiT,8BAA8B,CAACva,OAAe,EAAEsa,UAAuB;IAC3E,OAAO,IAAI,CAACuL,gBAAgB,CAACvL,UAAU,EAAE,gBAAgB,EAAGzY,SAAS,IAAKA,SAAS,CAACwY,mBAAmB,IAAIxY,SAAS,CAACwY,mBAAmB,CAACra,OAAO,EAAEsa,UAAU,CAAC,CAAC;EAClK;EAEQP,0BAA0B,CAAC/Z,OAAe,EAAE6Z,MAAe,EAAEC,UAAkB,EAAEtS,UAAkB;IACvG,OAAO,IAAI,CAACqe,gBAAgB,CAAChM,MAAM,EAAE,YAAY,EAAGhY,SAAS,IAAKA,SAAS,CAAC+X,eAAe,IAAI/X,SAAS,CAAC+X,eAAe,CAAC5Z,OAAO,EAAE6Z,MAAM,EAAEC,UAAU,EAAEtS,UAAU,CAAC,CAAC;EACtK;EAEA;;;;;;;;EAQO,OAAO+e,kBAAkB,CAC5BvmB,OAAe,EACf0Y,QAAmB,EACnB8N,aAAqB,EACrBT,WAA4F;IAE5F,IAAI,CAACrN,QAAQ,CAAC+N,UAAU,EAAE;MACtB,OAAO,IAAI;;IAGf,MAAMA,UAAU,GAAG/N,QAAQ,CAAC+N,UAAU;IAEtC,MAAM5kB,SAAS,GAAG4kB,UAAU,CAACD,aAAa,CAAe;IACzD,IAAI,CAAC3kB,SAAS,EAAE;MACZ,OAAO,IAAI;;IAGf,OAAOkkB,WAAW,CAAC,GAAG/lB,OAAO,eAAewmB,aAAa,EAAE,EAAE3kB,SAAS,CAAC;EAC3E;EAEA;;;;;;;;EAQO,OAAO6kB,cAAc,CACxB1mB,OAAe,EACf0Y,QAAmB,EACnB8N,aAAqB,EACrBT,WAAgF;IAEhF,IAAI,CAACrN,QAAQ,CAAClH,MAAM,EAAE;MAClB,OAAO,IAAI;;IAGf,MAAMA,MAAM,GAAGkH,QAAQ,CAAClH,MAAM;IAE9B,MAAMmV,KAAK,GAAGnV,MAAM,CAACgV,aAAa,CAAW;IAC7C,IAAI,CAACG,KAAK,EAAE;MACR,OAAO,IAAI;;IAGf,OAAOZ,WAAW,CAAC,GAAG/lB,OAAO,WAAWwmB,aAAa,EAAE,EAAEG,KAAK,CAAC;EACnE;EAEA;;;;;EAKOC,eAAe,CAAChmB,IAAY;IAC/B,OAAO,CAAC,CAAC,IAAI,CAACM,KAAK,CAAC2lB,cAAc,IAAI,IAAI,CAAC3lB,KAAK,CAAC2lB,cAAc,CAACrc,OAAO,CAAC5J,IAAI,CAAC,KAAK,CAAC,CAAC;EACxF;EAEA;;;;EAIOkJ,OAAO,CAACsQ,OAAe;IAC1B,IAAI,CAAC1Z,OAAO,CAAComB,QAAQ,CAAC1M,OAAO,CAAC;EAClC;EAEA;;;EAGOjQ,QAAQ;IACX,IAAI,CAACzJ,OAAO,CAACqmB,SAAS,EAAE;EAC5B;EAEA;;;;EAIOpE,GAAG,CAACvI,OAAe;IACtB,IAAI,CAAC1Z,OAAO,CAACsmB,IAAI,CAAC5M,OAAO,CAAC;EAC9B;EAEA;;;;EAIO6M,uBAAuB,CAACC,WAAmB;IAC9C,IAAI,CAACxmB,OAAO,CAACqE,wBAAwB,CAACmiB,WAAW,CAAC;EACtD;EAEA;;;;EAIOC,qBAAqB,CAACD,WAAmB;IAC5C,IAAI,CAACxmB,OAAO,CAACiG,sBAAsB,CAACugB,WAAW,CAAC;EACpD;;AAlqFe3mB,gCAAqB,GAA6C,EAAE;AAEnF;;;AAGuBA,yBAAc,GAAa;EAAEL,KAAK,EAAE,CAAC;AAAC,CAAE;AAgqFnE7B,cAAc,CAAC+oB,kBAAkB,GAAI3mB,MAAM,IAAK,IAAIF,UAAU,CAACE,MAAM,CAAC","names":["Deferred","Quaternion","Vector3","Matrix","TmpVectors","Color3","Tools","Camera","FreeCamera","AnimationKeyInterpolation","AnimationGroup","Bone","Skeleton","Material","PBRMaterial","Texture","TransformNode","Buffer","VertexBuffer","Geometry","Mesh","MorphTarget","MorphTargetManager","GLTFFileLoader","GLTFLoaderState","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","DecodeBase64UrlToBinary","IsBase64DataUrl","LoadFileError","Logger","BoundingInfo","nodeAnimationData","mergeDeep","objects","isObject","obj","reduce","prev","Object","keys","forEach","key","pVal","oVal","Array","isArray","concat","ArrayItem","Get","context","array","index","undefined","Error","Assign","length","GLTFLoader","constructor","parent","_parent","RegisterExtension","name","factory","UnregisterExtension","Warn","_RegisteredExtensions","gltf","_gltf","bin","_bin","babylonScene","_babylonScene","rootBabylonMesh","_rootBabylonMesh","dispose","_disposed","_completePromises","_extensions","extension","_defaultBabylonMaterialData","_postSceneLoadActions","importMeshAsync","meshesNames","scene","container","data","rootUrl","onProgress","fileName","Promise","resolve","then","_assetContainer","_loadData","nodes","nodeMap","node","names","map","_loadAsync","meshes","_getMeshes","particleSystems","skeletons","_getSkeletons","animationGroups","_getAnimationGroups","lights","_babylonLights","transformNodes","_getTransformNodes","geometries","_getGeometries","loadAsync","resultFunc","_rootUrl","_uniqueRootUrl","startsWith","Date","now","_fileName","_loadExtensions","_checkExtensions","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_startPerformanceCounter","_setState","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadOnlyMaterials","push","loadSceneAsync","scenes","skipMaterials","loadAllMaterials","materials","m","material","babylonDrawMode","TriangleFillMode","_loadMaterialAsync","compileMaterials","_compileMaterialsAsync","compileShadowGenerators","_compileShadowGeneratorsAsync","resultPromise","all","setEnabled","_extensionsOnReady","_startAnimations","result","_endPerformanceCounter","SetImmediate","onCompleteObservable","notifyObservers","clear","error","onErrorObservable","catch","json","_setupData","buffers","uri","binaryBuffer","byteLength","accessors","animations","bufferViews","cameras","images","samplers","skins","textures","nodeParents","children","rootNode","_createRootNode","parentIndex","onExtensionLoadedObservable","sort","a","b","order","Number","MAX_VALUE","extensionsRequired","available","some","enabled","_blockEntityCollection","_parentContainer","_babylonTransformNode","coordinateSystemMode","AUTO","useRightHandedSystem","rotation","scale","_LoadTransform","FORCE_RIGHT_HANDED","onMeshLoadedObservable","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","babylonMesh","action","_loadAnimationsAsync","logClose","_forEachPrimitive","callback","_primitiveBabylonMeshes","geometry","indexOf","getClassName","_babylonTransformNodeForSkin","skin","_data","babylonSkeleton","animation","_babylonAnimationGroup","animationStartMode","NONE","FIRST","babylonAnimationGroups","start","ALL","babylonAnimationGroup","assign","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","camera","loadCameraAsync","babylonCamera","childNode","childBabylonMesh","mesh","nodeName","transformNode","_loadMeshAsync","babylonTransformNodeForSkin","metadata","_loadSkinAsync","skeleton","parentNode","onSkinLoadedObservable","skinnedNode","useBoundingInfoFromGeometry","_updateBoundingInfo","refreshBoundingInfo","primitives","primitive","_loadMeshPrimitiveAsync","_extensionsLoadMeshPrimitiveAsync","shouldInstance","_disableInstancedMesh","createInstances","targets","babylonAbstractMesh","promise","_instanceData","babylonSourceMesh","createInstance","overrideMaterialSideOrientation","CounterClockWiseSideOrientation","ClockWiseSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","_GetDrawMode","mode","babylonMaterial","_createDefaultMaterial","onMaterialLoadedObservable","_extensionsLoadVertexDataAsync","attributes","indices","isUnIndexed","accessor","_loadIndicesAccessorAsync","setIndices","loadAttribute","attribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","getKind","PositionKind","alwaysComputeBoundingBox","mmin","min","mmax","max","normalized","componentType","divider","i","Math","copyFromFloats","_boundingInfo","setVerticesBuffer","count","MatricesIndicesExtraKind","numBoneInfluencers","NormalKind","TangentKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","MatricesIndicesKind","MatricesWeightsKind","MatricesWeightsExtraKind","ColorKind","type","hasVertexAlpha","_numMorphTargets","targetNames","extras","morphTargetManager","getScene","areUpdatesFrozen","weight","weights","addTarget","numTargets","babylonMorphTarget","getTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","positions","Float32Array","value","setPositions","normals","setNormals","tangents","dataIndex","setTangents","babylonNode","position","Zero","Identity","scaling","One","matrix","FromArray","decompose","translation","rotationQuaternion","_extensionsLoadSkinAsync","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","alwaysComputeSkeletonRootNode","_findSkeletonRootNode","joints","isParent","skeletonNode","babylonBones","_loadBone","paths","path","unshift","j","babylonBone","parentBabylonBone","boneIndex","_getNodeMatrix","linkTransformNode","inverseBindMatrices","bones","baseMatrix","_index","FromArrayToRef","invertToRef","babylonParentBone","getParent","multiplyToRef","getInvertedAbsoluteTransform","updateMatrix","_updateDifferenceMatrix","Compose","_extensionsLoadCameraAsync","ignoreParentScaling","_babylonCamera","PI","perspective","fov","yfov","minZ","znear","maxZ","zfar","orthographic","ORTHOGRAPHIC_CAMERA","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","onCameraLoadedObservable","loadAnimationAsync","animationGroup","targetedAnimations","_extensionsLoadAnimationAsync","channels","channel","_loadAnimationChannelAsync","babylonTarget","babylonAnimation","addTargetedAnimation","normalize","animationContext","onLoad","_extensionsLoadAnimationChannelAsync","target","targetNode","properties","targetInfo","_loadAnimationChannelFromTargetInfoAsync","fps","targetFps","invfps","sampler","_loadAnimationSamplerAsync","numAnimations","property","stride","getStride","input","output","outputOffset","interpolation","getValue","frame","STEP","inTangent","outTangent","buildAnimations","babylonAnimatable","inputAccessor","outputAccessor","inputData","outputData","loadBufferAsync","buffer","byteOffset","_extensionsLoadBufferAsync","loadUriAsync","readAsync","Uint8Array","e","message","loadBufferViewAsync","bufferView","_extensionsLoadBufferViewAsync","_loadAccessorAsync","numComponents","_GetNumComponents","byteStride","GetTypeByteLength","_GetTypedArray","typedArray","ForEach","sparse","indicesBufferView","valuesBufferView","values","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_GetTypedArrayConstructor","_loadVertexBufferViewAsync","_babylonBuffer","engine","getEngine","_babylonVertexBuffer","babylonBuffer","size","_loadMaterialMetallicRoughnessPropertiesAsync","baseColorFactor","albedoColor","alpha","White","metallic","metallicFactor","roughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","texture","albedoTexture","metallicRoughnessTexture","nonColorData","metallicTexture","useMetallnessFromMetallicTextureBlue","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","onDisposeObservable","addOnce","splice","fillMode","enableSpecularAntiAliasing","useRadianceOverAlpha","transparencyAsCoverage","useSpecularOverAlpha","transparencyMode","PBRMATERIAL_OPAQUE","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","emissiveColor","emissiveFactor","doubleSided","backFaceCulling","twoSidedLighting","normalTexture","bumpTexture","invertNormalMapX","invertNormalMapY","level","forceIrradianceInFragment","occlusionTexture","ambientTexture","useAmbientInGrayScale","strength","ambientTextureStrength","emissiveTexture","alphaMode","PBRMATERIAL_ALPHATEST","alphaCutOff","alphaCutoff","hasAlpha","PBRMATERIAL_ALPHABLEND","useAlphaFromAlbedoTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_textureInfo","_loadTextureAsync","babylonTexture","coordinatesIndex","onTextureLoadedObservable","_extensionsLoadTextureAsync","DefaultSampler","image","source","_createTextureAsync","textureLoaderOptions","useSRGBBuffer","samplerData","_loadSampler","deferred","textureCreationOptions","noMipmap","noMipMaps","invertY","samplingMode","onError","exception","reject","mimeType","loaderOptions","useSRGBBuffers","loadImageAsync","dataUrl","updateURL","wrapU","wrapV","minFilter","_GetTextureSamplingMode","_GetTextureWrapMode","wrapS","wrapT","_extensionsLoadUriAsync","_ValidateUri","log","substr","preprocessUrlAsync","url","_loadFile","request","status","statusText","babylonObject","pointer","_internalMetadata","pointers","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","WRAP_ADDRESSMODE","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","Int8Array","Int16Array","Uint16Array","Uint32Array","componentTypeLength","slice","IsBase64","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","computeWorldMatrix","forceCompilationAsync","useInstances","useClipPlane","clipPlane","light","generator","getShadowGenerator","_forEachExtensions","_applyExtensions","functionName","actionAsync","id","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","onLoading","onReady","_loadUriAsync","LoadExtensionAsync","extensionName","extensions","LoadExtraAsync","extra","isExtensionUsed","extensionsUsed","_logOpen","_logClose","_log","startPerformanceCounter","counterName","endPerformanceCounter","_CreateGLTF2Loader"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/glTF/2.0/glTFLoader.ts"],"sourcesContent":["import type { IndicesArray, Nullable } from \"core/types\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ITextureCreationOptions } from \"core/Materials/Textures/texture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Buffer, VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport {\r\n    AnimationChannelTargetPath,\r\n    AnimationSamplerInterpolation,\r\n    AccessorType,\r\n    CameraType,\r\n    AccessorComponentType,\r\n    MaterialAlphaMode,\r\n    TextureMinFilter,\r\n    TextureWrapMode,\r\n    TextureMagFilter,\r\n    MeshPrimitiveMode,\r\n} from \"babylonjs-gltf2interface\";\r\nimport type {\r\n    IGLTF,\r\n    ISampler,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IAccessor,\r\n    ISkin,\r\n    ICamera,\r\n    IAnimation,\r\n    IBuffer,\r\n    IBufferView,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterial,\r\n    ITextureInfo,\r\n    ITexture,\r\n    IImage,\r\n    IMeshPrimitive,\r\n    IArrayItem,\r\n    _ISamplerData,\r\n    IAnimationChannel,\r\n    IAnimationSampler,\r\n    _IAnimationSamplerData,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DecodeBase64UrlToBinary, IsBase64DataUrl, LoadFileError } from \"core/Misc/fileTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Light } from \"core/Lights/light\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { AnimationPropertyInfo } from \"./glTFLoaderAnimation\";\r\nimport { nodeAnimationData } from \"./glTFLoaderAnimation\";\r\n\r\ninterface TypedArrayLike extends ArrayBufferView {\r\n    readonly length: number;\r\n    [n: number]: number;\r\n}\r\n\r\ninterface TypedArrayConstructor {\r\n    new (length: number): TypedArrayLike;\r\n    new (buffer: ArrayBufferLike, byteOffset: number, length?: number): TypedArrayLike;\r\n}\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensionFunctions: {\r\n        [id: string]: boolean;\r\n    };\r\n}\r\n\r\ninterface IRegisteredExtension {\r\n    factory: (loader: GLTFLoader) => IGLTFLoaderExtension;\r\n}\r\n\r\ninterface IWithMetadata {\r\n    metadata: any;\r\n    _internalMetadata: any;\r\n}\r\n\r\n// https://stackoverflow.com/a/48218209\r\nfunction mergeDeep(...objects: any[]): any {\r\n    const isObject = (obj: any) => obj && typeof obj === \"object\";\r\n\r\n    return objects.reduce((prev, obj) => {\r\n        Object.keys(obj).forEach((key) => {\r\n            const pVal = prev[key];\r\n            const oVal = obj[key];\r\n\r\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\r\n                prev[key] = pVal.concat(...oVal);\r\n            } else if (isObject(pVal) && isObject(oVal)) {\r\n                prev[key] = mergeDeep(pVal, oVal);\r\n            } else {\r\n                prev[key] = oVal;\r\n            }\r\n        });\r\n\r\n        return prev;\r\n    }, {});\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItem[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport interface IAnimationTargetInfo {\r\n    /** @internal */\r\n    target: any;\r\n\r\n    /** @internal */\r\n    properties: Array<AnimationPropertyInfo>;\r\n}\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    /** @internal */\r\n    public readonly _completePromises = new Array<Promise<any>>();\r\n\r\n    /** @internal */\r\n    public _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    /** Storage */\r\n    public _babylonLights: Light[] = [];\r\n\r\n    /** @internal */\r\n    public _disableInstancedMesh = 0;\r\n\r\n    private readonly _parent: GLTFFileLoader;\r\n    private readonly _extensions = new Array<IGLTFLoaderExtension>();\r\n    private _disposed = false;\r\n    private _rootUrl: Nullable<string> = null;\r\n    private _fileName: Nullable<string> = null;\r\n    private _uniqueRootUrl: Nullable<string> = null;\r\n    private _gltf: IGLTF;\r\n    private _bin: Nullable<IDataBuffer> = null;\r\n    private _babylonScene: Scene;\r\n    private _rootBabylonMesh: Nullable<Mesh> = null;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private readonly _postSceneLoadActions = new Array<() => void>();\r\n\r\n    private static _RegisteredExtensions: { [name: string]: IRegisteredExtension } = {};\r\n\r\n    /**\r\n     * The default glTF sampler.\r\n     */\r\n    public static readonly DefaultSampler: ISampler = { index: -1 };\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     */\r\n    public static RegisterExtension(name: string, factory: (loader: GLTFLoader) => IGLTFLoaderExtension): void {\r\n        if (GLTFLoader.UnregisterExtension(name)) {\r\n            Logger.Warn(`Extension with the name '${name}' already exists`);\r\n        }\r\n\r\n        GLTFLoader._RegisteredExtensions[name] = {\r\n            factory: factory,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFLoader._RegisteredExtensions[name]) {\r\n            return false;\r\n        }\r\n\r\n        delete GLTFLoader._RegisteredExtensions[name];\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    public get gltf(): IGLTF {\r\n        if (!this._gltf) {\r\n            throw new Error(\"glTF JSON is not available\");\r\n        }\r\n\r\n        return this._gltf;\r\n    }\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    public get bin(): Nullable<IDataBuffer> {\r\n        return this._bin;\r\n    }\r\n\r\n    /**\r\n     * The parent file loader.\r\n     */\r\n    public get parent(): GLTFFileLoader {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\r\n    public get babylonScene(): Scene {\r\n        if (!this._babylonScene) {\r\n            throw new Error(\"Scene is not available\");\r\n        }\r\n\r\n        return this._babylonScene;\r\n    }\r\n\r\n    /**\r\n     * The root Babylon mesh when loading the asset.\r\n     */\r\n    public get rootBabylonMesh(): Nullable<Mesh> {\r\n        return this._rootBabylonMesh;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        this._completePromises.length = 0;\r\n\r\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\r\n        this._extensions.length = 0;\r\n\r\n        (this._gltf as Nullable<IGLTF>) = null; // TODO\r\n        this._bin = null;\r\n        (this._babylonScene as Nullable<Scene>) = null; // TODO\r\n        this._rootBabylonMesh = null;\r\n        this._defaultBabylonMaterialData = {};\r\n        this._postSceneLoadActions.length = 0;\r\n\r\n        this._parent.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this._babylonScene = scene;\r\n            this._assetContainer = container;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this._gltf.nodes) {\r\n                    for (const node of this._gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return this._loadAsync(rootUrl, fileName, nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups(),\r\n                    lights: this._babylonLights,\r\n                    transformNodes: this._getTransformNodes(),\r\n                    geometries: this._getGeometries(),\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName = \"\"): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this._babylonScene = scene;\r\n            this._loadData(data);\r\n            return this._loadAsync(rootUrl, fileName, null, () => undefined);\r\n        });\r\n    }\r\n\r\n    private _loadAsync<T>(rootUrl: string, fileName: string, nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return Promise.resolve()\r\n            .then(() => {\r\n                this._rootUrl = rootUrl;\r\n                this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\r\n                this._fileName = fileName;\r\n\r\n                this._loadExtensions();\r\n                this._checkExtensions();\r\n\r\n                const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n                const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n                this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n                this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                this._parent._setState(GLTFLoaderState.LOADING);\r\n                this._extensionsOnLoading();\r\n\r\n                const promises = new Array<Promise<any>>();\r\n\r\n                // Block the marking of materials dirty until the scene is loaded.\r\n                const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\r\n                this._babylonScene.blockMaterialDirtyMechanism = true;\r\n\r\n                if (!this.parent.loadOnlyMaterials) {\r\n                    if (nodes) {\r\n                        promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\r\n                    } else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\r\n                        const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\r\n                        promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\r\n                    }\r\n                }\r\n\r\n                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\r\n                    for (let m = 0; m < this._gltf.materials.length; ++m) {\r\n                        const material = this._gltf.materials[m];\r\n                        const context = \"/materials/\" + m;\r\n                        const babylonDrawMode = Material.TriangleFillMode;\r\n\r\n                        promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\r\n                    }\r\n                }\r\n\r\n                // Restore the blocking of material dirty.\r\n                this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\r\n\r\n                if (this._parent.compileMaterials) {\r\n                    promises.push(this._compileMaterialsAsync());\r\n                }\r\n\r\n                if (this._parent.compileShadowGenerators) {\r\n                    promises.push(this._compileShadowGeneratorsAsync());\r\n                }\r\n\r\n                const resultPromise = Promise.all(promises).then(() => {\r\n                    if (this._rootBabylonMesh) {\r\n                        this._rootBabylonMesh.setEnabled(true);\r\n                    }\r\n\r\n                    this._extensionsOnReady();\r\n                    this._parent._setState(GLTFLoaderState.READY);\r\n\r\n                    this._startAnimations();\r\n\r\n                    return resultFunc();\r\n                });\r\n\r\n                return resultPromise.then((result) => {\r\n                    this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                    Tools.SetImmediate(() => {\r\n                        if (!this._disposed) {\r\n                            Promise.all(this._completePromises).then(\r\n                                () => {\r\n                                    this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                                    this._parent._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                                    this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                                    this._parent.onCompleteObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                },\r\n                                (error) => {\r\n                                    this._parent.onErrorObservable.notifyObservers(error);\r\n                                    this._parent.onErrorObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                }\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    return result;\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                if (!this._disposed) {\r\n                    this._parent.onErrorObservable.notifyObservers(error);\r\n                    this._parent.onErrorObservable.clear();\r\n\r\n                    this.dispose();\r\n                }\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this._gltf = data.json as IGLTF;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this._gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                this._bin = data.bin;\r\n            } else {\r\n                Logger.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this._gltf.accessors);\r\n        ArrayItem.Assign(this._gltf.animations);\r\n        ArrayItem.Assign(this._gltf.buffers);\r\n        ArrayItem.Assign(this._gltf.bufferViews);\r\n        ArrayItem.Assign(this._gltf.cameras);\r\n        ArrayItem.Assign(this._gltf.images);\r\n        ArrayItem.Assign(this._gltf.materials);\r\n        ArrayItem.Assign(this._gltf.meshes);\r\n        ArrayItem.Assign(this._gltf.nodes);\r\n        ArrayItem.Assign(this._gltf.samplers);\r\n        ArrayItem.Assign(this._gltf.scenes);\r\n        ArrayItem.Assign(this._gltf.skins);\r\n        ArrayItem.Assign(this._gltf.textures);\r\n\r\n        if (this._gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this._gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this._gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name in GLTFLoader._RegisteredExtensions) {\r\n            const extension = GLTFLoader._RegisteredExtensions[name].factory(this);\r\n            if (extension.name !== name) {\r\n                Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\r\n            }\r\n\r\n            this._extensions.push(extension);\r\n            this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n        }\r\n\r\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n    }\r\n\r\n    private _checkExtensions(): void {\r\n        if (this._gltf.extensionsRequired) {\r\n            for (const name of this._gltf.extensionsRequired) {\r\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\r\n                if (!available) {\r\n                    throw new Error(`Require extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createRootNode(): INode {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        this._rootBabylonMesh = new Mesh(\"__root__\", this._babylonScene);\r\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        this._rootBabylonMesh.setEnabled(false);\r\n\r\n        const rootNode: INode = {\r\n            _babylonTransformNode: this._rootBabylonMesh,\r\n            index: -1,\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this._babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this._babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (const index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\r\n                promises.push(\r\n                    this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\r\n                        babylonMesh.parent = this._rootBabylonMesh;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const action of this._postSceneLoadActions) {\r\n            action();\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGeometries(): Geometry[] {\r\n        const geometries = new Array<Geometry>();\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    const geometry = (babylonMesh as Mesh).geometry;\r\n                    if (geometry && geometries.indexOf(geometry) === -1) {\r\n                        geometries.push(geometry);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    private _getMeshes(): AbstractMesh[] {\r\n        const meshes = new Array<AbstractMesh>();\r\n\r\n        // Root mesh is always first, if available.\r\n        if (this._rootBabylonMesh) {\r\n            meshes.push(this._rootBabylonMesh);\r\n        }\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    meshes.push(babylonMesh);\r\n                });\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getTransformNodes(): TransformNode[] {\r\n        const transformNodes = new Array<TransformNode>();\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\r\n                    transformNodes.push(node._babylonTransformNode);\r\n                }\r\n                if (node._babylonTransformNodeForSkin) {\r\n                    transformNodes.push(node._babylonTransformNodeForSkin);\r\n                }\r\n            }\r\n        }\r\n\r\n        return transformNodes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons = new Array<Skeleton>();\r\n\r\n        const skins = this._gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._data) {\r\n                    skeletons.push(skin._data.babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups = new Array<AnimationGroup>();\r\n\r\n        const animations = this._gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => {}): Promise<TransformNode> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonTransformNode) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const loadNode = (babylonTransformNode: TransformNode) => {\r\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\r\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\r\n\r\n            if (node.camera != undefined) {\r\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\r\n                promises.push(\r\n                    this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                        babylonCamera.parent = babylonTransformNode;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (node.children) {\r\n                for (const index of node.children) {\r\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\r\n                    promises.push(\r\n                        this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\r\n                            childBabylonMesh.parent = babylonTransformNode;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            assign(babylonTransformNode);\r\n        };\r\n\r\n        if (node.mesh == undefined || node.skin != undefined) {\r\n            const nodeName = node.name || `node${node.index}`;\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\r\n            transformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            if (node.mesh == undefined) {\r\n                node._babylonTransformNode = transformNode;\r\n            } else {\r\n                node._babylonTransformNodeForSkin = transformNode;\r\n            }\r\n            loadNode(transformNode);\r\n        }\r\n\r\n        if (node.mesh != undefined) {\r\n            if (node.skin == undefined) {\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\r\n            } else {\r\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\r\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\r\n\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(\r\n                    this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\r\n                        const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin!;\r\n\r\n                        // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\r\n                        babylonTransformNode.metadata = mergeDeep(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\r\n\r\n                        const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\r\n                        promises.push(\r\n                            this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\r\n                                this._forEachPrimitive(node, (babylonMesh) => {\r\n                                    babylonMesh.skeleton = babylonSkeleton;\r\n                                });\r\n\r\n                                // Wait until all the nodes are parented before parenting the skinned mesh.\r\n                                this._postSceneLoadActions.push(() => {\r\n                                    if (skin.skeleton != undefined) {\r\n                                        // Place the skinned mesh node as a sibling of the skeleton root node.\r\n                                        // Handle special case when the parent of the skeleton root is the skinned mesh.\r\n                                        const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent!;\r\n                                        if (node.index === parentNode.index) {\r\n                                            babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\r\n                                        } else {\r\n                                            babylonTransformNode.parent = parentNode._babylonTransformNode!;\r\n                                        }\r\n                                    } else {\r\n                                        babylonTransformNode.parent = this._rootBabylonMesh;\r\n                                    }\r\n\r\n                                    this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });\r\n                                });\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                if ((babylonMesh as Mesh).geometry && (babylonMesh as Mesh).geometry!.useBoundingInfoFromGeometry) {\r\n                    // simply apply the world matrices to the bounding info - the extends are already ok\r\n                    babylonMesh._updateBoundingInfo();\r\n                } else {\r\n                    babylonMesh.refreshBoundingInfo(true);\r\n                }\r\n            });\r\n\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || !primitives.length) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        if (primitives[0].index == undefined) {\r\n            ArrayItem.Assign(primitives);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const name = node.name || `node${node.index}`;\r\n\r\n        if (primitives.length === 1) {\r\n            const primitive = mesh.primitives[0];\r\n            promises.push(\r\n                this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\r\n                    node._babylonTransformNode = babylonMesh;\r\n                    node._primitiveBabylonMeshes = [babylonMesh];\r\n                })\r\n            );\r\n        } else {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\r\n            node._babylonTransformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                promises.push(\r\n                    this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\r\n                        babylonMesh.parent = node._babylonTransformNode!;\r\n                        node._primitiveBabylonMeshes!.push(babylonMesh);\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        assign(node._babylonTransformNode!);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Define this method to modify the default behavior when loading data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param name The mesh name when loading the asset\r\n     * @param node The glTF node when loading the asset\r\n     * @param mesh The glTF mesh when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n     */\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Promise<AbstractMesh> {\r\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\r\n\r\n        let babylonAbstractMesh: AbstractMesh;\r\n        let promise: Promise<any>;\r\n\r\n        if (shouldInstance && primitive._instanceData) {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name) as InstancedMesh;\r\n            babylonAbstractMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            promise = primitive._instanceData.promise;\r\n        } else {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonMesh = new Mesh(name, this._babylonScene);\r\n            babylonMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            babylonMesh.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n\r\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n            promises.push(\r\n                this._loadVertexDataAsync(context, primitive, babylonMesh).then((babylonGeometry) => {\r\n                    return this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                        if (this._disposed) {\r\n                            return;\r\n                        }\r\n\r\n                        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n                        babylonGeometry.applyToMesh(babylonMesh);\r\n                        babylonGeometry._parentContainer = this._assetContainer;\r\n                        this._babylonScene._blockEntityCollection = false;\r\n                    });\r\n                })\r\n            );\r\n\r\n            const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n            if (primitive.material == undefined) {\r\n                let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n                if (!babylonMaterial) {\r\n                    babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\r\n                    this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                    this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n                }\r\n                babylonMesh.material = babylonMaterial;\r\n            } else if (!this.parent.skipMaterials) {\r\n                const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\r\n                promises.push(\r\n                    this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        babylonMesh.material = babylonMaterial;\r\n                    })\r\n                );\r\n            }\r\n\r\n            promise = Promise.all(promises);\r\n\r\n            if (shouldInstance) {\r\n                primitive._instanceData = {\r\n                    babylonSourceMesh: babylonMesh,\r\n                    promise: promise,\r\n                };\r\n            }\r\n\r\n            babylonAbstractMesh = babylonMesh;\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\r\n        assign(babylonAbstractMesh);\r\n\r\n        this.logClose();\r\n\r\n        return promise.then(() => {\r\n            return babylonAbstractMesh;\r\n        });\r\n    }\r\n\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        } else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\r\n            promises.push(\r\n                this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    babylonGeometry.setIndices(data);\r\n                })\r\n            );\r\n        }\r\n\r\n        const loadAttribute = (attribute: string, kind: string, callback?: (accessor: IAccessor) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                    if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\r\n                        const mmin = accessor.min as [number, number, number],\r\n                            mmax = accessor.max as [number, number, number];\r\n                        if (mmin !== undefined && mmax !== undefined) {\r\n                            if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n                                let divider = 1;\r\n                                switch (accessor.componentType) {\r\n                                    case AccessorComponentType.BYTE:\r\n                                        divider = 127.0;\r\n                                        break;\r\n                                    case AccessorComponentType.UNSIGNED_BYTE:\r\n                                        divider = 255.0;\r\n                                        break;\r\n                                    case AccessorComponentType.SHORT:\r\n                                        divider = 32767.0;\r\n                                        break;\r\n                                    case AccessorComponentType.UNSIGNED_SHORT:\r\n                                        divider = 65535.0;\r\n                                        break;\r\n                                }\r\n                                for (let i = 0; i < 3; ++i) {\r\n                                    mmin[i] = Math.max(mmin[i] / divider, -1.0);\r\n                                    mmax[i] = Math.max(mmax[i] / divider, -1.0);\r\n                                }\r\n                            }\r\n                            const min = TmpVectors.Vector3[0],\r\n                                max = TmpVectors.Vector3[1];\r\n                            min.copyFromFloats(...mmin);\r\n                            max.copyFromFloats(...mmax);\r\n                            babylonGeometry._boundingInfo = new BoundingInfo(min, max);\r\n                            babylonGeometry.useBoundingInfoFromGeometry = true;\r\n                        }\r\n                    }\r\n                    babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n                })\r\n            );\r\n\r\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\r\n                babylonMesh.numBoneInfluencers = 8;\r\n            }\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\r\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\r\n        if (!primitive.targets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        } else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\r\n\r\n        babylonMesh.morphTargetManager = new MorphTargetManager(babylonMesh.getScene());\r\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\r\n\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            morphTargetManager.areUpdatesFrozen = false;\r\n        });\r\n    }\r\n\r\n    private _loadMorphTargetVertexDataAsync(context: string, babylonGeometry: Geometry, attributes: { [name: string]: number }, babylonMorphTarget: MorphTarget): Promise<void> {\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    setData(babylonVertexBuffer, data);\r\n                })\r\n            );\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            const positions = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                positions[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(positions);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            const normals = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\r\n                normals[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(normals);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            const tangents = new Float32Array((data.length / 3) * 4);\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if ((index + 1) % 4 !== 0) {\r\n                    tangents[dataIndex] = data[dataIndex] + value;\r\n                    dataIndex++;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(tangents);\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\r\n        // Ignore the TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (node.skin != undefined) {\r\n            return;\r\n        }\r\n\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        } else {\r\n            if (node.translation) {\r\n                position = Vector3.FromArray(node.translation);\r\n            }\r\n            if (node.rotation) {\r\n                rotation = Quaternion.FromArray(node.rotation);\r\n            }\r\n            if (node.scale) {\r\n                scaling = Vector3.FromArray(node.scale);\r\n            }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin, assign: (babylonSkeleton: Skeleton) => void): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (skin._data) {\r\n            assign(skin._data.babylonSkeleton);\r\n            return skin._data.promise;\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\r\n        babylonSkeleton._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        this._loadBones(context, skin, babylonSkeleton);\r\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        });\r\n\r\n        skin._data = {\r\n            babylonSkeleton: babylonSkeleton,\r\n            promise: promise,\r\n        };\r\n\r\n        assign(babylonSkeleton);\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\r\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\r\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\r\n            if (rootNode) {\r\n                if (skin.skeleton === undefined) {\r\n                    skin.skeleton = rootNode.index;\r\n                } else {\r\n                    const isParent = (a: INode, b: INode): boolean => {\r\n                        for (; b.parent; b = b.parent) {\r\n                            if (b.parent === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n\r\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\r\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\r\n                        skin.skeleton = rootNode.index;\r\n                    }\r\n                }\r\n            } else {\r\n                Logger.Warn(`${context}: Failed to find common root`);\r\n            }\r\n        }\r\n\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _findSkeletonRootNode(context: string, joints: Array<number>): Nullable<INode> {\r\n        if (joints.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const paths: { [joint: number]: Array<INode> } = {};\r\n        for (const index of joints) {\r\n            const path = new Array<INode>();\r\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\r\n            while (node.index !== -1) {\r\n                path.unshift(node);\r\n                node = node.parent!;\r\n            }\r\n            paths[index] = path;\r\n        }\r\n\r\n        let rootNode: Nullable<INode> = null;\r\n        for (let i = 0; ; ++i) {\r\n            let path = paths[joints[0]];\r\n            if (i >= path.length) {\r\n                return rootNode;\r\n            }\r\n\r\n            const node = path[i];\r\n            for (let j = 1; j < joints.length; ++j) {\r\n                path = paths[joints[j]];\r\n                if (i >= path.length || node !== path[i]) {\r\n                    return rootNode;\r\n                }\r\n            }\r\n\r\n            rootNode = node;\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let parentBabylonBone: Nullable<Bone> = null;\r\n        if (node.index !== skin.skeleton) {\r\n            if (node.parent && node.parent.index !== -1) {\r\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\r\n            } else if (skin.skeleton !== undefined) {\r\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\r\n        this._postSceneLoadActions.push(() => {\r\n            // Link the Babylon bone with the corresponding Babylon transform node.\r\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\r\n            babylonBone.linkTransformNode(node._babylonTransformNode!);\r\n        });\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            const baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getInvertedAbsoluteTransform(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateDifferenceMatrix(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INode): Matrix {\r\n        return node.matrix\r\n            ? Matrix.FromArray(node.matrix)\r\n            : Matrix.Compose(\r\n                  node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                  node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                  node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero()\r\n              );\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => {}): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\r\n        babylonCamera._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        babylonCamera.ignoreParentScaling = true;\r\n        camera._babylonCamera = babylonCamera;\r\n\r\n        babylonCamera.rotation = new Vector3(0, Math.PI, 0);\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || 0;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n        assign(babylonCamera);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        const animations = this._gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<void>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(\r\n                this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\r\n                    // Delete the animation group if it ended up not having any animations in it.\r\n                    if (animationGroup.targetedAnimations.length === 0) {\r\n                        animationGroup.dispose();\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\r\n        babylonAnimationGroup._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        ArrayItem.Assign(animation.channels);\r\n        ArrayItem.Assign(animation.samplers);\r\n\r\n        for (const channel of animation.channels) {\r\n            promises.push(\r\n                this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\r\n                    babylonTarget.animations = babylonTarget.animations || [];\r\n                    babylonTarget.animations.push(babylonAnimation);\r\n                    babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            babylonAnimationGroup.normalize(0);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        if (channel.target.node == undefined) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if (\r\n            (channel.target.path === AnimationChannelTargetPath.WEIGHTS && !targetNode._numMorphTargets) ||\r\n            (channel.target.path !== AnimationChannelTargetPath.WEIGHTS && !targetNode._babylonTransformNode)\r\n        ) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        let properties: Array<AnimationPropertyInfo>;\r\n        switch (channel.target.path) {\r\n            case AnimationChannelTargetPath.TRANSLATION: {\r\n                properties = nodeAnimationData.translation;\r\n                break;\r\n            }\r\n            case AnimationChannelTargetPath.ROTATION: {\r\n                properties = nodeAnimationData.rotation;\r\n                break;\r\n            }\r\n            case AnimationChannelTargetPath.SCALE: {\r\n                properties = nodeAnimationData.scale;\r\n                break;\r\n            }\r\n            case AnimationChannelTargetPath.WEIGHTS: {\r\n                properties = nodeAnimationData.weights;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n            }\r\n        }\r\n\r\n        const targetInfo: IAnimationTargetInfo = {\r\n            target: targetNode,\r\n            properties: properties,\r\n        };\r\n\r\n        return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param targetInfo The glTF target and properties\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelFromTargetInfoAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        targetInfo: IAnimationTargetInfo,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const fps = this.parent.targetFps;\r\n        const invfps = 1 / fps;\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let numAnimations = 0;\r\n\r\n            // Extract the corresponding values from the read value.\r\n            // GLTF values may be dispatched to several Babylon properties.\r\n            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\r\n            // - albedoColor as Color3(`r`, `g`, `b`)\r\n            // - alpha as `a`\r\n            for (const property of targetInfo.properties) {\r\n                const stride = property.getStride(targetInfo.target);\r\n                const input = data.input;\r\n                const output = data.output;\r\n                const keys = new Array<IAnimationKey>(input.length);\r\n                let outputOffset = 0;\r\n\r\n                switch (data.interpolation) {\r\n                    case AnimationSamplerInterpolation.STEP: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                                interpolation: AnimationKeyInterpolation.STEP,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const inTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n                            const outTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                inTangent: inTangent,\r\n                                value: value,\r\n                                outTangent: outTangent,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.LINEAR: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = property.getValue(targetInfo.target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (outputOffset > 0) {\r\n                    const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\r\n                    property.buildAnimations(targetInfo.target, name, fps, keys, (babylonAnimatable, babylonAnimation) => {\r\n                        ++numAnimations;\r\n                        onLoad(babylonAnimatable, babylonAnimation);\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer.\r\n     * @param context The context when loading the asset\r\n     * @param buffer The glTF buffer property\r\n     * @param byteOffset The byte offset to use\r\n     * @param byteLength The byte length to use\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!buffer._data) {\r\n            if (buffer.uri) {\r\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\r\n            } else {\r\n                if (!this._bin) {\r\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n                }\r\n\r\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\r\n            }\r\n        }\r\n\r\n        return buffer._data.then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            } catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\r\n        if (accessor._data) {\r\n            return accessor._data;\r\n        }\r\n\r\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new constructor(length));\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\r\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n                } else {\r\n                    const typedArray = new constructor(length);\r\n                    VertexBuffer.ForEach(\r\n                        data,\r\n                        accessor.byteOffset || 0,\r\n                        bufferView.byteStride || byteStride,\r\n                        numComponents,\r\n                        accessor.componentType,\r\n                        typedArray.length,\r\n                        accessor.normalized || false,\r\n                        (value, index) => {\r\n                            typedArray[index] = value;\r\n                        }\r\n                    );\r\n                    return typedArray;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data) => {\r\n                const typedArray = data as TypedArrayLike;\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoader._GetTypedArray(\r\n                        `${context}/sparse/indices`,\r\n                        sparse.indices.componentType,\r\n                        indicesData,\r\n                        sparse.indices.byteOffset,\r\n                        sparse.count\r\n                    ) as IndicesArray;\r\n\r\n                    const sparseLength = numComponents * sparse.count;\r\n                    let values: TypedArrayLike;\r\n\r\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\r\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                    } else {\r\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                        values = new constructor(sparseLength);\r\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\r\n                            values[index] = value;\r\n                        });\r\n                    }\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            typedArray[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return typedArray;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\r\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\r\n    }\r\n\r\n    private _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT\r\n        ) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\r\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    private _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(engine, data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    private _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer?.[kind]) {\r\n            return accessor._babylonVertexBuffer[kind];\r\n        }\r\n\r\n        if (!accessor._babylonVertexBuffer) {\r\n            accessor._babylonVertexBuffer = {};\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n\r\n        if (accessor.sparse) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        }\r\n        // Load joint indices as a float array since the shaders expect float data but glTF uses unsigned byte/short.\r\n        // This prevents certain platforms (e.g. D3D) from having to convert the data to float on the fly.\r\n        else if (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\r\n                const size = GLTFLoader._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(\r\n                    engine,\r\n                    babylonBuffer,\r\n                    kind,\r\n                    false,\r\n                    false,\r\n                    bufferView.byteStride,\r\n                    false,\r\n                    accessor.byteOffset,\r\n                    size,\r\n                    accessor.componentType,\r\n                    accessor.normalized,\r\n                    true,\r\n                    1,\r\n                    true\r\n                );\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer[kind];\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                babylonMaterial.albedoColor = Color3.FromArray(properties.baseColorFactor);\r\n                babylonMaterial.alpha = properties.baseColorFactor[3];\r\n            } else {\r\n                babylonMaterial.albedoColor = Color3.White();\r\n            }\r\n\r\n            babylonMaterial.metallic = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            babylonMaterial.roughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        babylonMaterial.albedoTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                properties.metallicRoughnessTexture.nonColorData = true;\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\r\n                        babylonMaterial.metallicTexture = texture;\r\n                    })\r\n                );\r\n\r\n                babylonMaterial.useMetallnessFromMetallicTextureBlue = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureGreen = true;\r\n                babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void = () => {}\r\n    ): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._data = material._data || {};\r\n        let babylonData = material._data[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                babylonMaterial: babylonMaterial,\r\n                babylonMeshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\r\n            };\r\n\r\n            material._data[babylonDrawMode] = babylonData;\r\n\r\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        if (babylonMesh) {\r\n            babylonData.babylonMeshes.push(babylonMesh);\r\n\r\n            babylonMesh.onDisposeObservable.addOnce(() => {\r\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\r\n                if (index !== -1) {\r\n                    babylonData.babylonMeshes.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        assign(babylonData.babylonMaterial);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.babylonMaterial;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonMaterial = new PBRMaterial(name, this._babylonScene);\r\n        babylonMaterial._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        // Moved to mesh so user can change materials on gltf meshes: babylonMaterial.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.enableSpecularAntiAliasing = true;\r\n        babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;\r\n        babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n        babylonMaterial.metallic = 1;\r\n        babylonMaterial.roughness = 1;\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\r\n        const extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.emissiveColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n        if (material.doubleSided) {\r\n            babylonMaterial.backFaceCulling = false;\r\n            babylonMaterial.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            material.normalTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Normal)`;\r\n                    babylonMaterial.bumpTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n            babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n            if (material.normalTexture.scale != undefined && babylonMaterial.bumpTexture) {\r\n                babylonMaterial.bumpTexture.level = material.normalTexture.scale;\r\n            }\r\n\r\n            babylonMaterial.forceIrradianceInFragment = true;\r\n        }\r\n\r\n        if (material.occlusionTexture) {\r\n            material.occlusionTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Occlusion)`;\r\n                    babylonMaterial.ambientTexture = texture;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useAmbientInGrayScale = true;\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Emissive)`;\r\n                    babylonMaterial.emissiveTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_OPAQUE;\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHATEST;\r\n                babylonMaterial.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = PBRMaterial.PBRMATERIAL_ALPHABLEND;\r\n                if (babylonMaterial.albedoTexture) {\r\n                    babylonMaterial.albedoTexture.hasAlpha = true;\r\n                    babylonMaterial.useAlphaFromAlbedoTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        if (textureInfo.texCoord! >= 6) {\r\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\r\n        }\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\r\n        texture._textureInfo = textureInfo;\r\n\r\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\r\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\r\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\r\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createTextureAsync(\r\n        context: string,\r\n        sampler: ISampler,\r\n        image: IImage,\r\n        assign: (babylonTexture: BaseTexture) => void = () => {},\r\n        textureLoaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ): Promise<BaseTexture> {\r\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const deferred = new Deferred<void>();\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const textureCreationOptions: ITextureCreationOptions = {\r\n            noMipmap: samplerData.noMipMaps,\r\n            invertY: false,\r\n            samplingMode: samplerData.samplingMode,\r\n            onLoad: () => {\r\n                if (!this._disposed) {\r\n                    deferred.resolve();\r\n                }\r\n            },\r\n            onError: (message?: string, exception?: any) => {\r\n                if (!this._disposed) {\r\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\r\n                }\r\n            },\r\n            mimeType: image.mimeType,\r\n            loaderOptions: textureLoaderOptions,\r\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\r\n        };\r\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\r\n        babylonTexture._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        promises.push(deferred.promise);\r\n\r\n        promises.push(\r\n            this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\r\n                const name = image.uri || `${this._fileName}#image${image.index}`;\r\n                const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n                babylonTexture.updateURL(dataUrl, data);\r\n            })\r\n        );\r\n\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n        assign(babylonTexture);\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR,\r\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property associated with the uri\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoader._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (IsBase64DataUrl(uri)) {\r\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\r\n            this.log(`${context}: Decoded ${uri.substr(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`${context}: Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                this._parent._loadFile(\r\n                    this._babylonScene,\r\n                    url,\r\n                    (data) => {\r\n                        if (!this._disposed) {\r\n                            this.log(`${context}: Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\r\n                            resolve(new Uint8Array(data as ArrayBuffer));\r\n                        }\r\n                    },\r\n                    true,\r\n                    (request) => {\r\n                        reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.\r\n     * @param babylonObject the Babylon object with _internalMetadata\r\n     * @param pointer the JSON pointer\r\n     */\r\n    public static AddPointerMetadata(babylonObject: IWithMetadata, pointer: string): void {\r\n        babylonObject.metadata = babylonObject.metadata || {};\r\n        const metadata = (babylonObject._internalMetadata = babylonObject._internalMetadata || {});\r\n        const gltf = (metadata.gltf = metadata.gltf || {});\r\n        const pointers = (gltf.pointers = gltf.pointers || []);\r\n        pointers.push(pointer);\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Logger.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        } else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\r\n        switch (componentType) {\r\n            case AccessorComponentType.BYTE:\r\n                return Int8Array;\r\n            case AccessorComponentType.UNSIGNED_BYTE:\r\n                return Uint8Array;\r\n            case AccessorComponentType.SHORT:\r\n                return Int16Array;\r\n            case AccessorComponentType.UNSIGNED_SHORT:\r\n                return Uint16Array;\r\n            case AccessorComponentType.UNSIGNED_INT:\r\n                return Uint32Array;\r\n            case AccessorComponentType.FLOAT:\r\n                return Float32Array;\r\n            default:\r\n                throw new Error(`${context}: Invalid component type ${componentType}`);\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(\r\n        context: string,\r\n        componentType: AccessorComponentType,\r\n        bufferView: ArrayBufferView,\r\n        byteOffset: number | undefined,\r\n        length: number\r\n    ): TypedArrayLike {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\r\n\r\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\r\n        if (byteOffset % componentTypeLength !== 0) {\r\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\r\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\r\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\r\n        }\r\n\r\n        return new constructor(buffer, byteOffset, length);\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\":\r\n                return 1;\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS:\r\n                return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES:\r\n                return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP:\r\n                return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP:\r\n                return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES:\r\n                return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP:\r\n                return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN:\r\n                return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (this._gltf.materials) {\r\n            for (const material of this._gltf.materials) {\r\n                if (material._data) {\r\n                    for (const babylonDrawMode in material._data) {\r\n                        const babylonData = material._data[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.babylonMeshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.babylonMaterial;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const lights = this._babylonScene.lights;\r\n        for (const light of lights) {\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                const id = `${extension.name}.${functionName}`;\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\r\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\r\n                if (!activeLoaderExtensionFunctions[id]) {\r\n                    activeLoaderExtensionFunctions[id] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    } finally {\r\n                        delete activeLoaderExtensionFunctions[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    private _extensionsLoadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return this._applyExtensions(\r\n            primitive,\r\n            \"loadMeshPrimitive\",\r\n            (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterial\",\r\n            (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterialProperties\",\r\n            (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\r\n    }\r\n\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    private _extensionsLoadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            animation,\r\n            \"loadAnimationChannel\",\r\n            (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad)\r\n        );\r\n    }\r\n\r\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\r\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\r\n    }\r\n\r\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\r\n    }\r\n\r\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\r\n    }\r\n\r\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    public static LoadExtensionAsync<TExtension = any, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    public static LoadExtraAsync<TExtra = any, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Checks for presence of an extension.\r\n     * @param name The name of the extension to check\r\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n     */\r\n    public isExtensionUsed(name: string): boolean {\r\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}