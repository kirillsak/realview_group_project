{"ast":null,"code":"import { GLTFLoader } from \"../glTFLoader.js\";\nimport { Logger } from \"@babylonjs/core/Misc/logger.js\";\nimport { animationPointerTree } from \"./KHR_animation_pointer.data.js\";\nconst NAME = \"KHR_animation_pointer\";\n/**\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_animation_pointer {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n  }\n  /**\n   * Defines whether this extension is enabled.\n   */\n  get enabled() {\n    return this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n  }\n  /**\n   * Loads a glTF animation channel.\n   * @param context The context when loading the asset\n   * @param animationContext The context of the animation when loading the asset\n   * @param animation The glTF animation property\n   * @param channel The glTF animation channel property\n   * @param onLoad Called for each animation loaded\n   * @returns A void promise that resolves when the load is complete or null if not handled\n   */\n  _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {\n    var _a;\n    const extension = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer;\n    if (!extension) {\n      return null;\n    }\n    if (channel.target.path !== \"pointer\" /* POINTER */) {\n      Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${\"pointer\" /* POINTER */}) when using the ${this.name} extension`);\n    }\n    if (channel.target.node != undefined) {\n      Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);\n    }\n    const extensionContext = `${context}/extensions/${this.name}`;\n    const pointer = extension.pointer;\n    if (!pointer) {\n      throw new Error(`${extensionContext}: Pointer is missing`);\n    }\n    const targetInfo = this._parseAnimationPointer(`${extensionContext}/pointer`, pointer);\n    if (!targetInfo) {\n      Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);\n      return null;\n    }\n    return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\n  }\n  /**\n   * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\n   * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\n   * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\n   * <assetIndex> := <digit> | <name>\n   * <propertyPath> := <extensionPath> | <standardPath>\n   * <extensionPath> := \"extensions\"/<name>/<standardPath>\n   * <standardPath> := <name> | <name>/<standardPath>\n   * <name> := W+\n   * <digit> := D+\n   *\n   * Examples:\n   *  - \"/nodes/0/rotation\"\n   *  - \"/materials/2/emissiveFactor\"\n   *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\n   *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\n   */\n  _parseAnimationPointer(context, pointer) {\n    if (!pointer.startsWith(\"/\")) {\n      Logger.Warn(`${context}: Value (${pointer}) must start with a slash`);\n      return null;\n    }\n    const parts = pointer.split(\"/\");\n    // Remove the first part since it will be empty string as pointers must start with a slash.\n    parts.shift();\n    let node = animationPointerTree;\n    let gltfCurrentNode = this._loader.gltf;\n    let gltfTargetNode = undefined;\n    for (const part of parts) {\n      if (node.__array__) {\n        node = node.__array__;\n      } else {\n        node = node[part];\n        if (!node) {\n          return null;\n        }\n      }\n      gltfCurrentNode = gltfCurrentNode && gltfCurrentNode[part];\n      if (node.__target__) {\n        gltfTargetNode = gltfCurrentNode;\n      }\n    }\n    if (!gltfTargetNode || !Array.isArray(node)) {\n      return null;\n    }\n    return {\n      target: gltfTargetNode,\n      properties: node\n    };\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new KHR_animation_pointer(loader));","map":{"version":3,"mappings":"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","names":["GLTFLoader","Logger","animationPointerTree","NAME","KHR_animation_pointer","constructor","loader","_loader","enabled","isExtensionUsed","dispose","_loadAnimationChannelAsync","context","animationContext","animation","channel","onLoad","extension","target","extensions","path","Warn","name","node","undefined","extensionContext","pointer","Error","targetInfo","_parseAnimationPointer","_loadAnimationChannelFromTargetInfoAsync","startsWith","parts","split","shift","gltfCurrentNode","gltf","gltfTargetNode","part","__array__","__target__","Array","isArray","properties","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_animation_pointer.ts"],"sourcesContent":["import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IAnimationTargetInfo } from \"../glTFLoader\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimation, IAnimationChannel } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRAnimationPointer } from \"babylonjs-gltf2interface\";\r\nimport { AnimationChannelTargetPath } from \"babylonjs-gltf2interface\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { animationPointerTree } from \"./KHR_animation_pointer.data\";\r\n\r\nconst NAME = \"KHR_animation_pointer\";\r\n\r\n/**\r\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_animation_pointer implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public get enabled(): boolean {\r\n        return this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete or null if not handled\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        const extension = channel.target.extensions?.KHR_animation_pointer as IKHRAnimationPointer;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        if (channel.target.path !== AnimationChannelTargetPath.POINTER) {\r\n            Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${AnimationChannelTargetPath.POINTER}) when using the ${this.name} extension`);\r\n        }\r\n\r\n        if (channel.target.node != undefined) {\r\n            Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);\r\n        }\r\n\r\n        const extensionContext = `${context}/extensions/${this.name}`;\r\n\r\n        const pointer = extension.pointer;\r\n        if (!pointer) {\r\n            throw new Error(`${extensionContext}: Pointer is missing`);\r\n        }\r\n\r\n        const targetInfo = this._parseAnimationPointer(`${extensionContext}/pointer`, pointer);\r\n        if (!targetInfo) {\r\n            Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);\r\n            return null;\r\n        }\r\n\r\n        return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n    }\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     */\r\n    private _parseAnimationPointer(context: string, pointer: string): Nullable<IAnimationTargetInfo> {\r\n        if (!pointer.startsWith(\"/\")) {\r\n            Logger.Warn(`${context}: Value (${pointer}) must start with a slash`);\r\n            return null;\r\n        }\r\n\r\n        const parts = pointer.split(\"/\");\r\n\r\n        // Remove the first part since it will be empty string as pointers must start with a slash.\r\n        parts.shift();\r\n\r\n        let node: any = animationPointerTree;\r\n        let gltfCurrentNode: any = this._loader.gltf;\r\n        let gltfTargetNode: any = undefined;\r\n        for (const part of parts) {\r\n            if (node.__array__) {\r\n                node = node.__array__;\r\n            } else {\r\n                node = node[part];\r\n                if (!node) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            gltfCurrentNode = gltfCurrentNode && gltfCurrentNode[part];\r\n\r\n            if (node.__target__) {\r\n                gltfTargetNode = gltfCurrentNode;\r\n            }\r\n        }\r\n\r\n        if (!gltfTargetNode || !Array.isArray(node)) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            target: gltfTargetNode,\r\n            properties: node,\r\n        };\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_animation_pointer(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}