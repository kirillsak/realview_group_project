{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo.js\";\nimport { Scene } from \"../scene.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Class representing a ray with position and direction\n */\nexport class Ray {\n  /**\n   * Creates a new ray\n   * @param origin origin point\n   * @param direction direction\n   * @param length length of the ray\n   */\n  constructor( /** origin point */\n  origin, /** direction */\n  direction, /** length of the ray */\n  length = Number.MAX_VALUE) {\n    this.origin = origin;\n    this.direction = direction;\n    this.length = length;\n  }\n  // Methods\n  /**\n   * Clone the current ray\n   * @returns a new ray\n   */\n  clone() {\n    return new Ray(this.origin.clone(), this.direction.clone(), this.length);\n  }\n  /**\n   * Checks if the ray intersects a box\n   * This does not account for the ray length by design to improve perfs.\n   * @param minimum bound of the box\n   * @param maximum bound of the box\n   * @param intersectionTreshold extra extend to be added to the box in all direction\n   * @returns if the box was hit\n   */\n  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {\n    const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n    const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n    let d = 0.0;\n    let maxValue = Number.MAX_VALUE;\n    let inv;\n    let min;\n    let max;\n    let temp;\n    if (Math.abs(this.direction.x) < 0.0000001) {\n      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.x;\n      min = (newMinimum.x - this.origin.x) * inv;\n      max = (newMaximum.x - this.origin.x) * inv;\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n      if (d > maxValue) {\n        return false;\n      }\n    }\n    if (Math.abs(this.direction.y) < 0.0000001) {\n      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.y;\n      min = (newMinimum.y - this.origin.y) * inv;\n      max = (newMaximum.y - this.origin.y) * inv;\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n      if (d > maxValue) {\n        return false;\n      }\n    }\n    if (Math.abs(this.direction.z) < 0.0000001) {\n      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n        return false;\n      }\n    } else {\n      inv = 1.0 / this.direction.z;\n      min = (newMinimum.z - this.origin.z) * inv;\n      max = (newMaximum.z - this.origin.z) * inv;\n      if (max === -Infinity) {\n        max = Infinity;\n      }\n      if (min > max) {\n        temp = min;\n        min = max;\n        max = temp;\n      }\n      d = Math.max(min, d);\n      maxValue = Math.min(max, maxValue);\n      if (d > maxValue) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Checks if the ray intersects a box\n   * This does not account for the ray lenght by design to improve perfs.\n   * @param box the bounding box to check\n   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\n   * @returns if the box was hit\n   */\n  intersectsBox(box, intersectionTreshold = 0) {\n    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n  }\n  /**\n   * If the ray hits a sphere\n   * @param sphere the bounding sphere to check\n   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\n   * @returns true if it hits the sphere\n   */\n  intersectsSphere(sphere, intersectionTreshold = 0) {\n    const x = sphere.center.x - this.origin.x;\n    const y = sphere.center.y - this.origin.y;\n    const z = sphere.center.z - this.origin.z;\n    const pyth = x * x + y * y + z * z;\n    const radius = sphere.radius + intersectionTreshold;\n    const rr = radius * radius;\n    if (pyth <= rr) {\n      return true;\n    }\n    const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n    if (dot < 0.0) {\n      return false;\n    }\n    const temp = pyth - dot * dot;\n    return temp <= rr;\n  }\n  /**\n   * If the ray hits a triange\n   * @param vertex0 triangle vertex\n   * @param vertex1 triangle vertex\n   * @param vertex2 triangle vertex\n   * @returns intersection information if hit\n   */\n  intersectsTriangle(vertex0, vertex1, vertex2) {\n    const edge1 = Ray._TmpVector3[0];\n    const edge2 = Ray._TmpVector3[1];\n    const pvec = Ray._TmpVector3[2];\n    const tvec = Ray._TmpVector3[3];\n    const qvec = Ray._TmpVector3[4];\n    vertex1.subtractToRef(vertex0, edge1);\n    vertex2.subtractToRef(vertex0, edge2);\n    Vector3.CrossToRef(this.direction, edge2, pvec);\n    const det = Vector3.Dot(edge1, pvec);\n    if (det === 0) {\n      return null;\n    }\n    const invdet = 1 / det;\n    this.origin.subtractToRef(vertex0, tvec);\n    const bv = Vector3.Dot(tvec, pvec) * invdet;\n    if (bv < 0 || bv > 1.0) {\n      return null;\n    }\n    Vector3.CrossToRef(tvec, edge1, qvec);\n    const bw = Vector3.Dot(this.direction, qvec) * invdet;\n    if (bw < 0 || bv + bw > 1.0) {\n      return null;\n    }\n    //check if the distance is longer than the predefined length.\n    const distance = Vector3.Dot(edge2, qvec) * invdet;\n    if (distance > this.length) {\n      return null;\n    }\n    return new IntersectionInfo(1 - bv - bw, bv, distance);\n  }\n  /**\n   * Checks if ray intersects a plane\n   * @param plane the plane to check\n   * @returns the distance away it was hit\n   */\n  intersectsPlane(plane) {\n    let distance;\n    const result1 = Vector3.Dot(plane.normal, this.direction);\n    if (Math.abs(result1) < 9.99999997475243e-7) {\n      return null;\n    } else {\n      const result2 = Vector3.Dot(plane.normal, this.origin);\n      distance = (-plane.d - result2) / result1;\n      if (distance < 0.0) {\n        if (distance < -9.99999997475243e-7) {\n          return null;\n        } else {\n          return 0;\n        }\n      }\n      return distance;\n    }\n  }\n  /**\n   * Calculate the intercept of a ray on a given axis\n   * @param axis to check 'x' | 'y' | 'z'\n   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\n   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\n   */\n  intersectsAxis(axis, offset = 0) {\n    switch (axis) {\n      case \"y\":\n        {\n          const t = (this.origin.y - offset) / this.direction.y;\n          if (t > 0) {\n            return null;\n          }\n          return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n        }\n      case \"x\":\n        {\n          const t = (this.origin.x - offset) / this.direction.x;\n          if (t > 0) {\n            return null;\n          }\n          return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n        }\n      case \"z\":\n        {\n          const t = (this.origin.z - offset) / this.direction.z;\n          if (t > 0) {\n            return null;\n          }\n          return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n        }\n      default:\n        return null;\n    }\n  }\n  /**\n   * Checks if ray intersects a mesh\n   * @param mesh the mesh to check\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @returns picking info of the intersection\n   */\n  intersectsMesh(mesh, fastCheck) {\n    const tm = TmpVectors.Matrix[0];\n    mesh.getWorldMatrix().invertToRef(tm);\n    if (this._tmpRay) {\n      Ray.TransformToRef(this, tm, this._tmpRay);\n    } else {\n      this._tmpRay = Ray.Transform(this, tm);\n    }\n    return mesh.intersects(this._tmpRay, fastCheck);\n  }\n  /**\n   * Checks if ray intersects a mesh\n   * @param meshes the meshes to check\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param results array to store result in\n   * @returns Array of picking infos\n   */\n  intersectsMeshes(meshes, fastCheck, results) {\n    if (results) {\n      results.length = 0;\n    } else {\n      results = [];\n    }\n    for (let i = 0; i < meshes.length; i++) {\n      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n      if (pickInfo.hit) {\n        results.push(pickInfo);\n      }\n    }\n    results.sort(this._comparePickingInfo);\n    return results;\n  }\n  _comparePickingInfo(pickingInfoA, pickingInfoB) {\n    if (pickingInfoA.distance < pickingInfoB.distance) {\n      return -1;\n    } else if (pickingInfoA.distance > pickingInfoB.distance) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Intersection test between the ray and a given segment within a given tolerance (threshold)\n   * @param sega the first point of the segment to test the intersection against\n   * @param segb the second point of the segment to test the intersection against\n   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\n   * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\n   */\n  intersectionSegment(sega, segb, threshold) {\n    const o = this.origin;\n    const u = TmpVectors.Vector3[0];\n    const rsegb = TmpVectors.Vector3[1];\n    const v = TmpVectors.Vector3[2];\n    const w = TmpVectors.Vector3[3];\n    segb.subtractToRef(sega, u);\n    this.direction.scaleToRef(Ray._Rayl, v);\n    o.addToRef(v, rsegb);\n    sega.subtractToRef(o, w);\n    const a = Vector3.Dot(u, u); // always >= 0\n    const b = Vector3.Dot(u, v);\n    const c = Vector3.Dot(v, v); // always >= 0\n    const d = Vector3.Dot(u, w);\n    const e = Vector3.Dot(v, w);\n    const D = a * c - b * b; // always >= 0\n    let sN,\n      sD = D; // sc = sN / sD, default sD = D >= 0\n    let tN,\n      tD = D; // tc = tN / tD, default tD = D >= 0\n    // compute the line parameters of the two closest points\n    if (D < Ray._Smallnum) {\n      // the lines are almost parallel\n      sN = 0.0; // force using point P0 on segment S1\n      sD = 1.0; // to prevent possible division by 0.0 later\n      tN = e;\n      tD = c;\n    } else {\n      // get the closest points on the infinite lines\n      sN = b * e - c * d;\n      tN = a * e - b * d;\n      if (sN < 0.0) {\n        // sc < 0 => the s=0 edge is visible\n        sN = 0.0;\n        tN = e;\n        tD = c;\n      } else if (sN > sD) {\n        // sc > 1 => the s=1 edge is visible\n        sN = sD;\n        tN = e + b;\n        tD = c;\n      }\n    }\n    if (tN < 0.0) {\n      // tc < 0 => the t=0 edge is visible\n      tN = 0.0;\n      // recompute sc for this edge\n      if (-d < 0.0) {\n        sN = 0.0;\n      } else if (-d > a) {\n        sN = sD;\n      } else {\n        sN = -d;\n        sD = a;\n      }\n    } else if (tN > tD) {\n      // tc > 1 => the t=1 edge is visible\n      tN = tD;\n      // recompute sc for this edge\n      if (-d + b < 0.0) {\n        sN = 0;\n      } else if (-d + b > a) {\n        sN = sD;\n      } else {\n        sN = -d + b;\n        sD = a;\n      }\n    }\n    // finally do the division to get sc and tc\n    const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\n    const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\n    // get the difference of the two closest points\n    const qtc = TmpVectors.Vector3[4];\n    v.scaleToRef(tc, qtc);\n    const qsc = TmpVectors.Vector3[5];\n    u.scaleToRef(sc, qsc);\n    qsc.addInPlace(w);\n    const dP = TmpVectors.Vector3[6];\n    qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n    if (isIntersected) {\n      return qsc.length();\n    }\n    return -1;\n  }\n  /**\n   * Update the ray from viewport position\n   * @param x position\n   * @param y y position\n   * @param viewportWidth viewport width\n   * @param viewportHeight viewport height\n   * @param world world matrix\n   * @param view view matrix\n   * @param projection projection matrix\n   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n   * @returns this ray updated\n   */\n  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {\n    if (enableDistantPicking) {\n      // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\n      // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\n      // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\n      // This is slower (2 matrix inverts instead of 1) but precision is preserved.\n      // This is hidden behind `EnableDistantPicking` flag (default is false)\n      if (!Ray._RayDistant) {\n        Ray._RayDistant = Ray.Zero();\n      }\n      Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\n      const tm = TmpVectors.Matrix[0];\n      world.invertToRef(tm);\n      Ray.TransformToRef(Ray._RayDistant, tm, this);\n    } else {\n      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n    }\n    return this;\n  }\n  // Statics\n  /**\n   * Creates a ray with origin and direction of 0,0,0\n   * @returns the new ray\n   */\n  static Zero() {\n    return new Ray(Vector3.Zero(), Vector3.Zero());\n  }\n  /**\n   * Creates a new ray from screen space and viewport\n   * @param x position\n   * @param y y position\n   * @param viewportWidth viewport width\n   * @param viewportHeight viewport height\n   * @param world world matrix\n   * @param view view matrix\n   * @param projection projection matrix\n   * @returns new ray\n   */\n  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {\n    const result = Ray.Zero();\n    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n  }\n  /**\n   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n   * transformed to the given world matrix.\n   * @param origin The origin point\n   * @param end The end point\n   * @param world a matrix to transform the ray to. Default is the identity matrix.\n   * @returns the new ray\n   */\n  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {\n    const direction = end.subtract(origin);\n    const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n    direction.normalize();\n    return Ray.Transform(new Ray(origin, direction, length), world);\n  }\n  /**\n   * Transforms a ray by a matrix\n   * @param ray ray to transform\n   * @param matrix matrix to apply\n   * @returns the resulting new ray\n   */\n  static Transform(ray, matrix) {\n    const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    Ray.TransformToRef(ray, matrix, result);\n    return result;\n  }\n  /**\n   * Transforms a ray by a matrix\n   * @param ray ray to transform\n   * @param matrix matrix to apply\n   * @param result ray to store result in\n   */\n  static TransformToRef(ray, matrix, result) {\n    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n    result.length = ray.length;\n    const dir = result.direction;\n    const len = dir.length();\n    if (!(len === 0 || len === 1)) {\n      const num = 1.0 / len;\n      dir.x *= num;\n      dir.y *= num;\n      dir.z *= num;\n      result.length *= len;\n    }\n  }\n  /**\n   * Unproject a ray from screen space to object space\n   * @param sourceX defines the screen space x coordinate to use\n   * @param sourceY defines the screen space y coordinate to use\n   * @param viewportWidth defines the current width of the viewport\n   * @param viewportHeight defines the current height of the viewport\n   * @param world defines the world matrix to use (can be set to Identity to go to world space)\n   * @param view defines the view matrix to use\n   * @param projection defines the projection matrix to use\n   */\n  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n    var _a;\n    const matrix = TmpVectors.Matrix[0];\n    world.multiplyToRef(view, matrix);\n    matrix.multiplyToRef(projection, matrix);\n    matrix.invert();\n    const nearScreenSource = TmpVectors.Vector3[0];\n    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;\n    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);\n    nearScreenSource.z = ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) ? 0 : -1;\n    // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\n    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\n    const nearVec3 = TmpVectors.Vector3[2];\n    const farVec3 = TmpVectors.Vector3[3];\n    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\n    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\n    this.origin.copyFrom(nearVec3);\n    farVec3.subtractToRef(nearVec3, this.direction);\n    this.direction.normalize();\n  }\n}\nRay._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\nRay._RayDistant = Ray.Zero();\nRay._Smallnum = 0.00000001;\nRay._Rayl = 10e8;\nScene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace = false) {\n  const result = Ray.Zero();\n  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\n  return result;\n};\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n  const engine = this.getEngine();\n  if (!camera) {\n    if (!this.activeCamera) {\n      return this;\n    }\n    camera = this.activeCamera;\n  }\n  const cameraViewport = camera.viewport;\n  const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n  // Moving coordinates to local viewport world\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);\n  return this;\n};\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n  const result = Ray.Zero();\n  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\n  return result;\n};\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n  if (!PickingInfo) {\n    return this;\n  }\n  const engine = this.getEngine();\n  if (!camera) {\n    if (!this.activeCamera) {\n      throw new Error(\"Active camera not set\");\n    }\n    camera = this.activeCamera;\n  }\n  const cameraViewport = camera.viewport;\n  const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n  const identity = Matrix.Identity();\n  // Moving coordinates to local viewport world\n  x = x / engine.getHardwareScalingLevel() - viewport.x;\n  y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\n  result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\n  return this;\n};\nScene.prototype._internalPickForMesh = function (pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n  const ray = rayFunction(world, mesh.enableDistantPicking);\n  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n  if (!result || !result.hit) {\n    return null;\n  }\n  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n    return null;\n  }\n  return result;\n};\nScene.prototype._internalPick = function (rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n  let pickingInfo = null;\n  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    const mesh = this.meshes[meshIndex];\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n    const world = mesh.getWorldMatrix();\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      // first check if the ray intersects the whole bounding box/sphere of the mesh\n      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n      if (result) {\n        if (onlyBoundingInfo) {\n          // the user only asked for a bounding info check so we can return\n          return result;\n        }\n        const tmpMatrix = TmpVectors.Matrix[1];\n        const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n        for (let index = 0; index < thinMatrices.length; index++) {\n          const thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n          const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n          if (result) {\n            pickingInfo = result;\n            pickingInfo.thinInstanceIndex = index;\n            if (fastCheck) {\n              return pickingInfo;\n            }\n          }\n        }\n      }\n    } else {\n      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n      if (result) {\n        pickingInfo = result;\n        if (fastCheck) {\n          return pickingInfo;\n        }\n      }\n    }\n  }\n  return pickingInfo || new PickingInfo();\n};\nScene.prototype._internalMultiPick = function (rayFunction, predicate, trianglePredicate) {\n  if (!PickingInfo) {\n    return null;\n  }\n  const pickingInfos = new Array();\n  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n    const mesh = this.meshes[meshIndex];\n    if (predicate) {\n      if (!predicate(mesh)) {\n        continue;\n      }\n    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n      continue;\n    }\n    const world = mesh.getWorldMatrix();\n    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n      const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\n      if (result) {\n        const tmpMatrix = TmpVectors.Matrix[1];\n        const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n        for (let index = 0; index < thinMatrices.length; index++) {\n          const thinMatrix = thinMatrices[index];\n          thinMatrix.multiplyToRef(world, tmpMatrix);\n          const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n          if (result) {\n            result.thinInstanceIndex = index;\n            pickingInfos.push(result);\n          }\n        }\n      }\n    } else {\n      const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\n      if (result) {\n        pickingInfos.push(result);\n      }\n    }\n  }\n  return pickingInfos;\n};\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n  if (!PickingInfo) {\n    return null;\n  }\n  const result = this._internalPick(world => {\n    if (!this._tempPickingRay) {\n      this._tempPickingRay = Ray.Zero();\n    }\n    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\n    return this._tempPickingRay;\n  }, predicate, fastCheck, true);\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n  return result;\n};\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\n  get: () => true,\n  enumerable: false,\n  configurable: false\n});\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {\n  const result = this._internalPick((world, enableDistantPicking) => {\n    if (!this._tempPickingRay) {\n      this._tempPickingRay = Ray.Zero();\n    }\n    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\n    return this._tempPickingRay;\n  }, predicate, fastCheck, false, trianglePredicate);\n  if (result) {\n    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\n  }\n  return result;\n};\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n  const result = this._internalPick(world => {\n    if (!this._pickWithRayInverseMatrix) {\n      this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n    world.invertToRef(this._pickWithRayInverseMatrix);\n    if (!this._cachedRayForTransform) {\n      this._cachedRayForTransform = Ray.Zero();\n    }\n    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\n    return this._cachedRayForTransform;\n  }, predicate, fastCheck, false, trianglePredicate);\n  if (result) {\n    result.ray = ray;\n  }\n  return result;\n};\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n  return this._internalMultiPick(world => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\n};\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n  return this._internalMultiPick(world => {\n    if (!this._pickWithRayInverseMatrix) {\n      this._pickWithRayInverseMatrix = Matrix.Identity();\n    }\n    world.invertToRef(this._pickWithRayInverseMatrix);\n    if (!this._cachedRayForTransform) {\n      this._cachedRayForTransform = Ray.Zero();\n    }\n    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\n    return this._cachedRayForTransform;\n  }, predicate, trianglePredicate);\n};\nCamera.prototype.getForwardRay = function (length = 100, transform, origin) {\n  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n};\nCamera.prototype.getForwardRayToRef = function (refRay, length = 100, transform, origin) {\n  if (!transform) {\n    transform = this.getWorldMatrix();\n  }\n  refRay.length = length;\n  if (!origin) {\n    refRay.origin.copyFrom(this.position);\n  } else {\n    refRay.origin.copyFrom(origin);\n  }\n  TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n  Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\n  Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\n  return refRay;\n};","map":{"version":3,"mappings":"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","names":["ArrayTools","Matrix","Vector3","TmpVectors","PickingInfo","IntersectionInfo","Scene","Camera","EngineStore","Ray","constructor","origin","direction","length","Number","MAX_VALUE","clone","intersectsBoxMinMax","minimum","maximum","intersectionTreshold","newMinimum","_TmpVector3","copyFromFloats","x","y","z","newMaximum","d","maxValue","inv","min","max","temp","Math","abs","Infinity","intersectsBox","box","intersectsSphere","sphere","center","pyth","radius","rr","dot","intersectsTriangle","vertex0","vertex1","vertex2","edge1","edge2","pvec","tvec","qvec","subtractToRef","CrossToRef","det","Dot","invdet","bv","bw","distance","intersectsPlane","plane","result1","normal","result2","intersectsAxis","axis","offset","t","intersectsMesh","mesh","fastCheck","tm","getWorldMatrix","invertToRef","_tmpRay","TransformToRef","Transform","intersects","intersectsMeshes","meshes","results","i","pickInfo","hit","push","sort","_comparePickingInfo","pickingInfoA","pickingInfoB","intersectionSegment","sega","segb","threshold","o","u","rsegb","v","w","scaleToRef","_Rayl","addToRef","a","b","c","e","D","sN","sD","tN","tD","_Smallnum","sc","tc","qtc","qsc","addInPlace","dP","isIntersected","lengthSquared","update","viewportWidth","viewportHeight","world","view","projection","enableDistantPicking","_RayDistant","Zero","unprojectRayToRef","IdentityReadOnly","CreateNew","result","CreateNewFromTo","end","subtract","sqrt","normalize","ray","matrix","TransformCoordinatesToRef","TransformNormalToRef","dir","len","num","sourceX","sourceY","multiplyToRef","invert","nearScreenSource","LastCreatedEngine","isNDCHalfZRange","farScreenSource","nearVec3","farVec3","_UnprojectFromInvertedMatrixToRef","copyFrom","BuildArray","prototype","createPickingRay","camera","cameraViewSpace","createPickingRayToRef","engine","getEngine","activeCamera","cameraViewport","viewport","toGlobal","getRenderWidth","getRenderHeight","getHardwareScalingLevel","height","width","getViewMatrix","getProjectionMatrix","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","Error","identity","Identity","_internalPickForMesh","pickingInfo","rayFunction","onlyBoundingInfo","trianglePredicate","skipBoundingInfo","_internalPick","predicate","meshIndex","isEnabled","isVisible","isPickable","hasThinInstances","thinInstanceEnablePicking","tmpMatrix","thinMatrices","thinInstanceGetWorldMatrices","index","thinMatrix","thinInstanceIndex","_internalMultiPick","pickingInfos","Array","pickWithBoundingInfo","_tempPickingRay","Object","defineProperty","get","enumerable","configurable","pick","_enableDistantPicking","pickWithRay","_pickWithRayInverseMatrix","_cachedRayForTransform","multiPick","multiPickWithRay","getForwardRay","transform","getForwardRayToRef","refRay","position","set","_scene","useRightHandedSystem","NormalizeToRef"],"sourceRoot":"","sources":["../../../../lts/core/generated/Culling/ray.ts"],"sourcesContent":["import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < 0 || bv > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < 0 || bv + bw > 1.0) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(mesh: DeepImmutable<AbstractMesh>, fastCheck?: boolean): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const direction = end.subtract(origin);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        direction.normalize();\r\n\r\n        return Ray.Transform(new Ray(origin, direction, length), world);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): void {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = EngineStore.LastCreatedEngine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @internal */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @internal */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @internal */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): PickingInfo;\r\n\r\n        /** @internal */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @internal */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            return this;\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        viewport.width,\r\n        viewport.height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera) {\r\n        if (!this.activeCamera) {\r\n            throw new Error(\"Active camera not set\");\r\n        }\r\n\r\n        camera = this.activeCamera;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    x = x / engine.getHardwareScalingLevel() - viewport.x;\r\n    y = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - viewport.y - viewport.height);\r\n    result.update(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const world = mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos = new Array<PickingInfo>();\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const world = mesh.getWorldMatrix();\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\r\n    get: () => true,\r\n    enumerable: false,\r\n    configurable: false,\r\n});\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (!origin) {\r\n        refRay.origin.copyFrom(this.position);\r\n    } else {\r\n        refRay.origin.copyFrom(origin);\r\n    }\r\n    TmpVectors.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    Vector3.TransformNormalToRef(TmpVectors.Vector3[2], transform, TmpVectors.Vector3[3]);\r\n\r\n    Vector3.NormalizeToRef(TmpVectors.Vector3[3], refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}