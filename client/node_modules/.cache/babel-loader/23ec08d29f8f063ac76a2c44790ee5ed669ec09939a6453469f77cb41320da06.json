{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { AxisDragGizmo } from \"./axisDragGizmo.js\";\nimport { PlaneDragGizmo } from \"./planeDragGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\n/**\n * Gizmo that enables dragging a mesh along 3 axis\n */\nexport class PositionGizmo extends Gizmo {\n  /**\n   * Creates a PositionGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n    @param thickness display gizmo axis thickness\n   * @param gizmoManager\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, thickness = 1, gizmoManager) {\n    super(gizmoLayer);\n    /**\n     * protected variables\n     */\n    this._meshAttached = null;\n    this._nodeAttached = null;\n    this._observables = [];\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    /** Fires an event when any of it's sub gizmos are dragged */\n    this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n    this.onDragEndObservable = new Observable();\n    /**\n     * If set to true, planar drag is enabled\n     */\n    this._planarGizmoEnabled = false;\n    this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);\n    this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);\n    this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);\n    this.xPlaneGizmo = new PlaneDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), this.gizmoLayer, this);\n    this.yPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), this.gizmoLayer, this);\n    this.zPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), this.gizmoLayer, this);\n    // Relay drag events\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      gizmo.dragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(() => {\n        this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    this.attachedMesh = null;\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n    }\n  }\n  get attachedMesh() {\n    return this._meshAttached;\n  }\n  set attachedMesh(mesh) {\n    this._meshAttached = mesh;\n    this._nodeAttached = mesh;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedMesh = mesh;\n      } else {\n        gizmo.attachedMesh = null;\n      }\n    });\n  }\n  get attachedNode() {\n    return this._nodeAttached;\n  }\n  set attachedNode(node) {\n    this._meshAttached = null;\n    this._nodeAttached = node;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedNode = node;\n      } else {\n        gizmo.attachedNode = null;\n      }\n    });\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    let hovered = false;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      hovered = hovered || gizmo.isHovered;\n    });\n    return hovered;\n  }\n  /**\n   * If the planar drag gizmo is enabled\n   * setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.\n   */\n  set planarGizmoEnabled(value) {\n    this._planarGizmoEnabled = value;\n    [this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.isEnabled = value;\n        if (value) {\n          if (gizmo.attachedMesh) {\n            gizmo.attachedMesh = this.attachedMesh;\n          } else {\n            gizmo.attachedNode = this.attachedNode;\n          }\n        }\n      }\n    }, this);\n  }\n  get planarGizmoEnabled() {\n    return this._planarGizmoEnabled;\n  }\n  /**\n   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n   */\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    this._updateGizmoRotationToMatchAttachedMesh = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      }\n    });\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this._updateGizmoRotationToMatchAttachedMesh;\n  }\n  set updateGizmoPositionToMatchAttachedMesh(value) {\n    this._updateGizmoPositionToMatchAttachedMesh = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.updateGizmoPositionToMatchAttachedMesh = value;\n      }\n    });\n  }\n  get updateGizmoPositionToMatchAttachedMesh() {\n    return this._updateGizmoPositionToMatchAttachedMesh;\n  }\n  set updateScale(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateScale = value;\n      this.yGizmo.updateScale = value;\n      this.zGizmo.updateScale = value;\n    }\n  }\n  get updateScale() {\n    return this.xGizmo.updateScale;\n  }\n  /**\n   * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n   */\n  set snapDistance(value) {\n    this._snapDistance = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.snapDistance = value;\n      }\n    });\n  }\n  get snapDistance() {\n    return this._snapDistance;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.scaleRatio = value;\n      }\n    });\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param mesh Axis gizmo mesh\n   * @param cache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    });\n    this._observables.forEach(obs => {\n      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n    this.onDragStartObservable.clear();\n    this.onDragEndObservable.clear();\n  }\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n  setCustomMesh() {\n    Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo,gizmo.xPlaneGizmo, gizmo.yPlaneGizmo, gizmo.zPlaneGizmo)\");\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","Observable","Vector3","Color3","Gizmo","AxisDragGizmo","PlaneDragGizmo","UtilityLayerRenderer","PositionGizmo","constructor","gizmoLayer","DefaultUtilityLayer","thickness","gizmoManager","Map","xGizmo","Red","scale","yGizmo","Green","zGizmo","Blue","xPlaneGizmo","yPlaneGizmo","zPlaneGizmo","forEach","gizmo","dragBehavior","onDragStartObservable","add","notifyObservers","onDragEndObservable","attachedMesh","addToAxisCache","_gizmoAxisCache","GizmoAxisPointerObserver","_meshAttached","mesh","_nodeAttached","isEnabled","attachedNode","node","isHovered","hovered","planarGizmoEnabled","value","_planarGizmoEnabled","updateGizmoRotationToMatchAttachedMesh","_updateGizmoRotationToMatchAttachedMesh","updateGizmoPositionToMatchAttachedMesh","_updateGizmoPositionToMatchAttachedMesh","updateScale","snapDistance","_snapDistance","scaleRatio","_scaleRatio","cache","set","dispose","_observables","obs","utilityLayerScene","onPointerObservable","remove","clear","setCustomMesh","Error"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/positionGizmo.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Node } from \"../node\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { GizmoAxisCache, IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport type { IAxisDragGizmo } from \"./axisDragGizmo\";\r\nimport { AxisDragGizmo } from \"./axisDragGizmo\";\r\nimport type { IPlaneDragGizmo } from \"./planeDragGizmo\";\r\nimport { PlaneDragGizmo } from \"./planeDragGizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { GizmoManager } from \"./gizmoManager\";\r\n\r\n/**\r\n * Interface for position gizmo\r\n */\r\nexport interface IPositionGizmo extends IGizmo {\r\n    /** Internal gizmo used for interactions on the x axis */\r\n    xGizmo: IAxisDragGizmo;\r\n    /** Internal gizmo used for interactions on the y axis */\r\n    yGizmo: IAxisDragGizmo;\r\n    /** Internal gizmo used for interactions on the z axis */\r\n    zGizmo: IAxisDragGizmo;\r\n    /** Internal gizmo used for interactions on the yz plane */\r\n    xPlaneGizmo: IPlaneDragGizmo;\r\n    /** Internal gizmo used for interactions on the xz plane */\r\n    yPlaneGizmo: IPlaneDragGizmo;\r\n    /** Internal gizmo used for interactions on the xy plane */\r\n    zPlaneGizmo: IPlaneDragGizmo;\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    onDragStartObservable: Observable<unknown>;\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    onDragEndObservable: Observable<unknown>;\r\n    /**\r\n     * If the planar drag gizmo is enabled\r\n     * setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.\r\n     */\r\n    planarGizmoEnabled: boolean;\r\n    /** Drag distance in babylon units that the gizmo will snap to when dragged */\r\n    snapDistance: number;\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    addToAxisCache(mesh: Mesh, cache: GizmoAxisCache): void;\r\n}\r\n\r\n/**\r\n * Gizmo that enables dragging a mesh along 3 axis\r\n */\r\nexport class PositionGizmo extends Gizmo implements IPositionGizmo {\r\n    /**\r\n     * Internal gizmo used for interactions on the x axis\r\n     */\r\n    public xGizmo: IAxisDragGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the y axis\r\n     */\r\n    public yGizmo: IAxisDragGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the z axis\r\n     */\r\n    public zGizmo: IAxisDragGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the yz plane\r\n     */\r\n    public xPlaneGizmo: IPlaneDragGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the xz plane\r\n     */\r\n    public yPlaneGizmo: IPlaneDragGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the xy plane\r\n     */\r\n    public zPlaneGizmo: IPlaneDragGizmo;\r\n\r\n    /**\r\n     * protected variables\r\n     */\r\n    protected _meshAttached: Nullable<AbstractMesh> = null;\r\n    protected _nodeAttached: Nullable<Node> = null;\r\n    protected _snapDistance: number;\r\n    protected _observables: Observer<PointerInfo>[] = [];\r\n\r\n    /** Node Caching for quick lookup */\r\n    protected _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    public onDragStartObservable = new Observable();\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    public onDragEndObservable = new Observable();\r\n\r\n    /**\r\n     * If set to true, planar drag is enabled\r\n     */\r\n    protected _planarGizmoEnabled = false;\r\n\r\n    public get attachedMesh() {\r\n        return this._meshAttached;\r\n    }\r\n    public set attachedMesh(mesh: Nullable<AbstractMesh>) {\r\n        this._meshAttached = mesh;\r\n        this._nodeAttached = mesh;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedMesh = mesh;\r\n            } else {\r\n                gizmo.attachedMesh = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get attachedNode() {\r\n        return this._nodeAttached;\r\n    }\r\n    public set attachedNode(node: Nullable<Node>) {\r\n        this._meshAttached = null;\r\n        this._nodeAttached = node;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedNode = node;\r\n            } else {\r\n                gizmo.attachedNode = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            hovered = hovered || gizmo.isHovered;\r\n        });\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Creates a PositionGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n      @param thickness display gizmo axis thickness\r\n     * @param gizmoManager\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer, thickness: number = 1, gizmoManager?: GizmoManager) {\r\n        super(gizmoLayer);\r\n        this.xGizmo = new AxisDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), gizmoLayer, this, thickness);\r\n        this.yGizmo = new AxisDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), gizmoLayer, this, thickness);\r\n        this.zGizmo = new AxisDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), gizmoLayer, this, thickness);\r\n\r\n        this.xPlaneGizmo = new PlaneDragGizmo(new Vector3(1, 0, 0), Color3.Red().scale(0.5), this.gizmoLayer, this);\r\n        this.yPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 1, 0), Color3.Green().scale(0.5), this.gizmoLayer, this);\r\n        this.zPlaneGizmo = new PlaneDragGizmo(new Vector3(0, 0, 1), Color3.Blue().scale(0.5), this.gizmoLayer, this);\r\n        // Relay drag events\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n            });\r\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\r\n                this.onDragEndObservable.notifyObservers({});\r\n            });\r\n        });\r\n\r\n        this.attachedMesh = null;\r\n\r\n        if (gizmoManager) {\r\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\r\n        } else {\r\n            // Only subscribe to pointer event if gizmoManager isnt\r\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the planar drag gizmo is enabled\r\n     * setting this will enable/disable XY, XZ and YZ planes regardless of individual gizmo settings.\r\n     */\r\n    public set planarGizmoEnabled(value: boolean) {\r\n        this._planarGizmoEnabled = value;\r\n        [this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.isEnabled = value;\r\n                if (value) {\r\n                    if (gizmo.attachedMesh) {\r\n                        gizmo.attachedMesh = this.attachedMesh;\r\n                    } else {\r\n                        gizmo.attachedNode = this.attachedNode;\r\n                    }\r\n                }\r\n            }\r\n        }, this);\r\n    }\r\n    public get planarGizmoEnabled(): boolean {\r\n        return this._planarGizmoEnabled;\r\n    }\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            }\r\n        });\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoPositionToMatchAttachedMesh = value;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n            }\r\n        });\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this._updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n\r\n    public set updateScale(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateScale = value;\r\n            this.yGizmo.updateScale = value;\r\n            this.zGizmo.updateScale = value;\r\n        }\r\n    }\r\n    public get updateScale() {\r\n        return this.xGizmo.updateScale;\r\n    }\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\r\n    public set snapDistance(value: number) {\r\n        this._snapDistance = value;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.snapDistance = value;\r\n            }\r\n        });\r\n    }\r\n    public get snapDistance() {\r\n        return this._snapDistance;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.scaleRatio = value;\r\n            }\r\n        });\r\n    }\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(mesh: Mesh, cache: GizmoAxisCache) {\r\n        this._gizmoAxisCache.set(mesh, cache);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        [this.xGizmo, this.yGizmo, this.zGizmo, this.xPlaneGizmo, this.yPlaneGizmo, this.zPlaneGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.dispose();\r\n            }\r\n        });\r\n        this._observables.forEach((obs) => {\r\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\r\n        });\r\n        this.onDragStartObservable.clear();\r\n        this.onDragEndObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\r\n            \"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo,gizmo.xPlaneGizmo, gizmo.yPlaneGizmo, gizmo.zPlaneGizmo)\"\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}