{"ast":null,"code":"import { Matrix } from \"../../Maths/math.vector.js\";\nimport { VRDistortionCorrectionPostProcess } from \"../../PostProcesses/vrDistortionCorrectionPostProcess.js\";\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess.js\";\nimport { VRCameraMetrics } from \"../VR/vrCameraMetrics.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\n/**\n * @internal\n */\nexport function setVRRigMode(camera, rigParams) {\n  const metrics = rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();\n  camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;\n  camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\n  camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\n  camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;\n  camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;\n  camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;\n  camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;\n  camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n  camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\n  camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;\n  camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;\n  camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;\n  // For multiview on a webVR camera\n  // First multiview will be rendered to camera._multiviewTexture\n  // Then this postprocess will run on each eye to copy the right texture to each eye\n  if (metrics.multiviewEnabled) {\n    if (!camera.getScene().getEngine().getCaps().multiview) {\n      Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n      metrics.multiviewEnabled = false;\n    } else {\n      camera._useMultiviewToSingleView = true;\n      camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", camera, metrics.postProcessScaleFactor);\n    }\n  }\n  if (metrics.compensateDistortion) {\n    camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", camera._rigCameras[0], false, metrics);\n    camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", camera._rigCameras[1], true, metrics);\n  }\n}","map":{"version":3,"mappings":"AACA,SAASA,MAAM,QAAQ,4BAA0B;AACjD,SAASC,iCAAiC,QAAQ,0DAAwD;AAC1G,SAASC,kCAAkC,QAAQ,2DAAyD;AAC5G,SAASC,eAAe,QAAQ,0BAAwB;AACxD,SAASC,MAAM,QAAQ,sBAAoB;AAC3C,SAASC,QAAQ,QAAQ,8BAA4B;AAErD;;;AAGA,OAAM,SAAUC,YAAY,CAACC,MAAc,EAAEC,SAAc;EACvD,MAAMC,OAAO,GAAoBD,SAAS,CAACE,eAAe,IAAIP,eAAe,CAACQ,UAAU,EAAE;EAE1FJ,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACC,SAAS,GAAGL,OAAO;EAC1DF,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACG,QAAQ,GAAG,IAAIV,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC;EAC7DE,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACG,YAAY,GAAG,IAAIhB,MAAM,EAAE;EAClEO,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACI,SAAS,GAAGR,OAAO,CAACS,WAAW;EACtEX,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACM,eAAe,GAAGV,OAAO,CAACW,iBAAiB;EAClFb,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACS,mBAAmB,GAAGd,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACU,sBAAsB;EAExFf,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACC,SAAS,GAAGL,OAAO;EAC1DF,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACG,QAAQ,GAAG,IAAIV,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,CAAC;EAC/DE,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACG,YAAY,GAAG,IAAIhB,MAAM,EAAE;EAClEO,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACI,SAAS,GAAGR,OAAO,CAACc,YAAY;EACvEhB,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACC,gBAAgB,CAACM,eAAe,GAAGV,OAAO,CAACe,kBAAkB;EACnFjB,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACS,mBAAmB,GAAGd,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACU,sBAAsB;EAExF;EACA;EACA;EACA,IAAIb,OAAO,CAACgB,gBAAgB,EAAE;IAC1B,IAAI,CAAClB,MAAM,CAACmB,QAAQ,EAAE,CAACC,SAAS,EAAE,CAACC,OAAO,EAAE,CAACC,SAAS,EAAE;MACpDzB,MAAM,CAAC0B,IAAI,CAAC,gEAAgE,CAAC;MAC7ErB,OAAO,CAACgB,gBAAgB,GAAG,KAAK;KACnC,MAAM;MACHlB,MAAM,CAACwB,yBAAyB,GAAG,IAAI;MACvCxB,MAAM,CAACyB,eAAe,GAAG,IAAI9B,kCAAkC,CAAC,yBAAyB,EAAEK,MAAM,EAAEE,OAAO,CAACwB,sBAAsB,CAAC;;;EAI1I,IAAIxB,OAAO,CAACyB,oBAAoB,EAAE;IAC9B3B,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACoB,eAAe,GAAG,IAAI/B,iCAAiC,CAAC,8BAA8B,EAAEM,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,EAAE,KAAK,EAAEH,OAAO,CAAC;IACpJF,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,CAACoB,eAAe,GAAG,IAAI/B,iCAAiC,CAAC,+BAA+B,EAAEM,MAAM,CAACK,WAAW,CAAC,CAAC,CAAC,EAAE,IAAI,EAAEH,OAAO,CAAC;;AAE5J","names":["Matrix","VRDistortionCorrectionPostProcess","VRMultiviewToSingleviewPostProcess","VRCameraMetrics","Logger","Viewport","setVRRigMode","camera","rigParams","metrics","vrCameraMetrics","GetDefault","_rigCameras","_cameraRigParams","vrMetrics","viewport","vrWorkMatrix","vrHMatrix","leftHMatrix","vrPreViewMatrix","leftPreViewMatrix","getProjectionMatrix","_getVRProjectionMatrix","rightHMatrix","rightPreViewMatrix","multiviewEnabled","getScene","getEngine","getCaps","multiview","Warn","_useMultiviewToSingleView","_rigPostProcess","postProcessScaleFactor","compensateDistortion"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/RigModes/vrRigMode.ts"],"sourcesContent":["import type { Camera } from \"../camera\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { VRDistortionCorrectionPostProcess } from \"../../PostProcesses/vrDistortionCorrectionPostProcess\";\r\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess\";\r\nimport { VRCameraMetrics } from \"../VR/vrCameraMetrics\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function setVRRigMode(camera: Camera, rigParams: any) {\r\n    const metrics = <VRCameraMetrics>rigParams.vrCameraMetrics || VRCameraMetrics.GetDefault();\r\n\r\n    camera._rigCameras[0]._cameraRigParams.vrMetrics = metrics;\r\n    camera._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n    camera._rigCameras[0]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n    camera._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;\r\n    camera._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;\r\n    camera._rigCameras[0].getProjectionMatrix = camera._rigCameras[0]._getVRProjectionMatrix;\r\n\r\n    camera._rigCameras[1]._cameraRigParams.vrMetrics = metrics;\r\n    camera._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n    camera._rigCameras[1]._cameraRigParams.vrWorkMatrix = new Matrix();\r\n    camera._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;\r\n    camera._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;\r\n    camera._rigCameras[1].getProjectionMatrix = camera._rigCameras[1]._getVRProjectionMatrix;\r\n\r\n    // For multiview on a webVR camera\r\n    // First multiview will be rendered to camera._multiviewTexture\r\n    // Then this postprocess will run on each eye to copy the right texture to each eye\r\n    if (metrics.multiviewEnabled) {\r\n        if (!camera.getScene().getEngine().getCaps().multiview) {\r\n            Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n            metrics.multiviewEnabled = false;\r\n        } else {\r\n            camera._useMultiviewToSingleView = true;\r\n            camera._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", camera, metrics.postProcessScaleFactor);\r\n        }\r\n    }\r\n\r\n    if (metrics.compensateDistortion) {\r\n        camera._rigCameras[0]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", camera._rigCameras[0], false, metrics);\r\n        camera._rigCameras[1]._rigPostProcess = new VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", camera._rigCameras[1], true, metrics);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}