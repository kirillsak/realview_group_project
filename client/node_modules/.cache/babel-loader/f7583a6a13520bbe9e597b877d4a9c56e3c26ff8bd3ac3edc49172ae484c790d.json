{"ast":null,"code":"import { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer.js\";\nimport \"../Shaders/copyTextureToTexture.fragment.js\";\n/**\n * Conversion modes available when copying a texture into another one\n */\nexport var ConversionMode;\n(function (ConversionMode) {\n  ConversionMode[ConversionMode[\"None\"] = 0] = \"None\";\n  ConversionMode[ConversionMode[\"ToLinearSpace\"] = 1] = \"ToLinearSpace\";\n  ConversionMode[ConversionMode[\"ToGammaSpace\"] = 2] = \"ToGammaSpace\";\n})(ConversionMode || (ConversionMode = {}));\n/**\n * Class used for fast copy from one texture to another\n */\nexport class CopyTextureToTexture {\n  /**\n   * Constructs a new instance of the class\n   * @param engine The engine to use for the copy\n   * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)\n   */\n  constructor(engine, isDepthTexture = false) {\n    this._engine = engine;\n    this._isDepthTexture = isDepthTexture;\n    this._renderer = new EffectRenderer(engine);\n    this._effectWrapper = new EffectWrapper({\n      engine: engine,\n      name: \"CopyTextureToTexture\",\n      fragmentShader: \"copyTextureToTexture\",\n      useShaderStore: true,\n      uniformNames: [\"conversion\"],\n      samplerNames: [\"textureSampler\"],\n      defines: isDepthTexture ? [\"#define DEPTH_TEXTURE\"] : []\n    });\n    this._effectWrapper.onApplyObservable.add(() => {\n      if (isDepthTexture) {\n        engine.setState(false);\n        engine.setDepthBuffer(true);\n        engine.depthCullingState.depthMask = true;\n        engine.depthCullingState.depthFunc = 519;\n      }\n      if (this._textureIsInternal(this._source)) {\n        this._effectWrapper.effect._bindTexture(\"textureSampler\", this._source);\n      } else {\n        this._effectWrapper.effect.setTexture(\"textureSampler\", this._source);\n      }\n      this._effectWrapper.effect.setFloat(\"conversion\", this._conversion);\n    });\n  }\n  _textureIsInternal(texture) {\n    return texture.getInternalTexture === undefined;\n  }\n  /**\n   * Indicates if the effect is ready to be used for the copy\n   * @returns true if \"copy\" can be called without delay, else false\n   */\n  isReady() {\n    return this._effectWrapper.effect.isReady();\n  }\n  /**\n   * Copy one texture into another\n   * @param source The source texture\n   * @param destination The destination texture\n   * @param conversion The conversion mode that should be applied when copying\n   * @returns\n   */\n  copy(source, destination, conversion = ConversionMode.None) {\n    if (!this.isReady()) {\n      return false;\n    }\n    this._source = source;\n    this._conversion = conversion;\n    const engineDepthFunc = this._engine.depthCullingState.depthFunc;\n    this._renderer.render(this._effectWrapper, destination);\n    if (this._isDepthTexture && engineDepthFunc) {\n      this._engine.depthCullingState.depthFunc = engineDepthFunc;\n    }\n    return true;\n  }\n  /**\n   * Releases all the resources used by the class\n   */\n  dispose() {\n    this._effectWrapper.dispose();\n    this._renderer.dispose();\n  }\n}","map":{"version":3,"mappings":"AAEA,SAASA,cAAc,EAAEC,aAAa,QAAQ,gCAA8B;AAK5E,OAAO,6CAA2C;AAElD;;;AAGA,WAAYC,cAIX;AAJD,WAAYA,cAAc;EACtBA,mDAAQ;EACRA,qEAAiB;EACjBA,mEAAgB;AACpB,CAAC,EAJWA,cAAc,KAAdA,cAAc;AAM1B;;;AAGA,OAAM,MAAOC,oBAAoB;EAY7B;;;;;EAKAC,YAAYC,MAAkB,EAAEC,cAAc,GAAG,KAAK;IAClD,IAAI,CAACC,OAAO,GAAGF,MAAM;IACrB,IAAI,CAACG,eAAe,GAAGF,cAAc;IAErC,IAAI,CAACG,SAAS,GAAG,IAAIT,cAAc,CAACK,MAAM,CAAC;IAE3C,IAAI,CAACK,cAAc,GAAG,IAAIT,aAAa,CAAC;MACpCI,MAAM,EAAEA,MAAM;MACdM,IAAI,EAAE,sBAAsB;MAC5BC,cAAc,EAAE,sBAAsB;MACtCC,cAAc,EAAE,IAAI;MACpBC,YAAY,EAAE,CAAC,YAAY,CAAC;MAC5BC,YAAY,EAAE,CAAC,gBAAgB,CAAC;MAChCC,OAAO,EAAEV,cAAc,GAAG,CAAC,uBAAuB,CAAC,GAAG;KACzD,CAAC;IAEF,IAAI,CAACI,cAAc,CAACO,iBAAiB,CAACC,GAAG,CAAC,MAAK;MAC3C,IAAIZ,cAAc,EAAE;QAChBD,MAAM,CAACc,QAAQ,CAAC,KAAK,CAAC;QACtBd,MAAM,CAACe,cAAc,CAAC,IAAI,CAAC;QAC3Bf,MAAM,CAACgB,iBAAiB,CAACC,SAAS,GAAG,IAAI;QACzCjB,MAAM,CAACgB,iBAAiB,CAACE,SAAS,GAAG;;MAGzC,IAAI,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAACC,OAAO,CAAC,EAAE;QACvC,IAAI,CAACf,cAAc,CAACgB,MAAM,CAACC,YAAY,CAAC,gBAAgB,EAAE,IAAI,CAACF,OAAO,CAAC;OAC1E,MAAM;QACH,IAAI,CAACf,cAAc,CAACgB,MAAM,CAACE,UAAU,CAAC,gBAAgB,EAAE,IAAI,CAACH,OAAO,CAAC;;MAEzE,IAAI,CAACf,cAAc,CAACgB,MAAM,CAACG,QAAQ,CAAC,YAAY,EAAE,IAAI,CAACC,WAAW,CAAC;IACvE,CAAC,CAAC;EACN;EAxCQN,kBAAkB,CAACO,OAAsC;IAC7D,OAAQA,OAAuB,CAACC,kBAAkB,KAAKC,SAAS;EACpE;EAwCA;;;;EAIOC,OAAO;IACV,OAAO,IAAI,CAACxB,cAAc,CAACgB,MAAM,CAACQ,OAAO,EAAE;EAC/C;EAEA;;;;;;;EAOOC,IAAI,CAACC,MAAqC,EAAEC,WAAuD,EAAEC,UAAU,GAAGpC,cAAc,CAACqC,IAAI;IACxI,IAAI,CAAC,IAAI,CAACL,OAAO,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhB,IAAI,CAACT,OAAO,GAAGW,MAAM;IACrB,IAAI,CAACN,WAAW,GAAGQ,UAAU;IAE7B,MAAME,eAAe,GAAG,IAAI,CAACjC,OAAO,CAACc,iBAAiB,CAACE,SAAS;IAEhE,IAAI,CAACd,SAAS,CAACgC,MAAM,CAAC,IAAI,CAAC/B,cAAc,EAAE2B,WAAW,CAAC;IAEvD,IAAI,IAAI,CAAC7B,eAAe,IAAIgC,eAAe,EAAE;MACzC,IAAI,CAACjC,OAAO,CAACc,iBAAiB,CAACE,SAAS,GAAGiB,eAAe;;IAG9D,OAAO,IAAI;EACf;EAEA;;;EAGOE,OAAO;IACV,IAAI,CAAChC,cAAc,CAACgC,OAAO,EAAE;IAC7B,IAAI,CAACjC,SAAS,CAACiC,OAAO,EAAE;EAC5B","names":["EffectRenderer","EffectWrapper","ConversionMode","CopyTextureToTexture","constructor","engine","isDepthTexture","_engine","_isDepthTexture","_renderer","_effectWrapper","name","fragmentShader","useShaderStore","uniformNames","samplerNames","defines","onApplyObservable","add","setState","setDepthBuffer","depthCullingState","depthMask","depthFunc","_textureIsInternal","_source","effect","_bindTexture","setTexture","setFloat","_conversion","texture","getInternalTexture","undefined","isReady","copy","source","destination","conversion","None","engineDepthFunc","render","dispose"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/copyTextureToTexture.ts"],"sourcesContent":["import type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport type { IRenderTargetTexture, RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport type { ThinTexture } from \"../Materials/Textures/thinTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\nimport \"../Shaders/copyTextureToTexture.fragment\";\r\n\r\n/**\r\n * Conversion modes available when copying a texture into another one\r\n */\r\nexport enum ConversionMode {\r\n    None = 0,\r\n    ToLinearSpace = 1,\r\n    ToGammaSpace = 2,\r\n}\r\n\r\n/**\r\n * Class used for fast copy from one texture to another\r\n */\r\nexport class CopyTextureToTexture {\r\n    private _engine: ThinEngine;\r\n    private _isDepthTexture: boolean;\r\n    private _renderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n    private _source: InternalTexture | ThinTexture;\r\n    private _conversion: number;\r\n\r\n    private _textureIsInternal(texture: InternalTexture | ThinTexture): texture is InternalTexture {\r\n        return (texture as ThinTexture).getInternalTexture === undefined;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new instance of the class\r\n     * @param engine The engine to use for the copy\r\n     * @param isDepthTexture True means that we should write (using gl_FragDepth) into the depth texture attached to the destination (default: false)\r\n     */\r\n    constructor(engine: ThinEngine, isDepthTexture = false) {\r\n        this._engine = engine;\r\n        this._isDepthTexture = isDepthTexture;\r\n\r\n        this._renderer = new EffectRenderer(engine);\r\n\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine: engine,\r\n            name: \"CopyTextureToTexture\",\r\n            fragmentShader: \"copyTextureToTexture\",\r\n            useShaderStore: true,\r\n            uniformNames: [\"conversion\"],\r\n            samplerNames: [\"textureSampler\"],\r\n            defines: isDepthTexture ? [\"#define DEPTH_TEXTURE\"] : [],\r\n        });\r\n\r\n        this._effectWrapper.onApplyObservable.add(() => {\r\n            if (isDepthTexture) {\r\n                engine.setState(false);\r\n                engine.setDepthBuffer(true);\r\n                engine.depthCullingState.depthMask = true;\r\n                engine.depthCullingState.depthFunc = Constants.ALWAYS;\r\n            }\r\n\r\n            if (this._textureIsInternal(this._source)) {\r\n                this._effectWrapper.effect._bindTexture(\"textureSampler\", this._source);\r\n            } else {\r\n                this._effectWrapper.effect.setTexture(\"textureSampler\", this._source);\r\n            }\r\n            this._effectWrapper.effect.setFloat(\"conversion\", this._conversion);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Indicates if the effect is ready to be used for the copy\r\n     * @returns true if \"copy\" can be called without delay, else false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._effectWrapper.effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Copy one texture into another\r\n     * @param source The source texture\r\n     * @param destination The destination texture\r\n     * @param conversion The conversion mode that should be applied when copying\r\n     * @returns\r\n     */\r\n    public copy(source: InternalTexture | ThinTexture, destination: RenderTargetWrapper | IRenderTargetTexture, conversion = ConversionMode.None): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._source = source;\r\n        this._conversion = conversion;\r\n\r\n        const engineDepthFunc = this._engine.depthCullingState.depthFunc;\r\n\r\n        this._renderer.render(this._effectWrapper, destination);\r\n\r\n        if (this._isDepthTexture && engineDepthFunc) {\r\n            this._engine.depthCullingState.depthFunc = engineDepthFunc;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases all the resources used by the class\r\n     */\r\n    public dispose(): void {\r\n        this._effectWrapper.dispose();\r\n        this._renderer.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}