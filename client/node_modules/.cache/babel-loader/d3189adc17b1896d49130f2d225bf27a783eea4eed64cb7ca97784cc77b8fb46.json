{"ast":null,"code":"import * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUDrawContext {\n  constructor(bufferManager) {\n    this._bufferManager = bufferManager;\n    this.uniqueId = WebGPUDrawContext._Counter++;\n    this._useInstancing = false;\n    this._currentInstanceCount = 0;\n    this.reset();\n  }\n  isDirty(materialContextUpdateId) {\n    return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;\n  }\n  resetIsDirty(materialContextUpdateId) {\n    this._isDirty = false;\n    this._materialContextUpdateId = materialContextUpdateId;\n  }\n  get useInstancing() {\n    return this._useInstancing;\n  }\n  set useInstancing(use) {\n    if (this._useInstancing === use) {\n      return;\n    }\n    if (!use) {\n      if (this.indirectDrawBuffer) {\n        this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\n      }\n      this.indirectDrawBuffer = undefined;\n      this._indirectDrawData = undefined;\n    } else {\n      this.indirectDrawBuffer = this._bufferManager.createRawBuffer(40, WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Indirect);\n      this._indirectDrawData = new Uint32Array(5);\n      this._indirectDrawData[3] = 0;\n      this._indirectDrawData[4] = 0;\n    }\n    this._useInstancing = use;\n    this._currentInstanceCount = -1;\n  }\n  reset() {\n    this.buffers = {};\n    this._isDirty = true;\n    this._materialContextUpdateId = 0;\n    this.fastBundle = undefined;\n    this.bindGroups = undefined;\n  }\n  setBuffer(name, buffer) {\n    var _a;\n    this._isDirty || (this._isDirty = (buffer === null || buffer === void 0 ? void 0 : buffer.uniqueId) !== ((_a = this.buffers[name]) === null || _a === void 0 ? void 0 : _a.uniqueId));\n    this.buffers[name] = buffer;\n  }\n  setIndirectData(indexOrVertexCount, instanceCount, firstIndexOrVertex) {\n    if (instanceCount === this._currentInstanceCount || !this.indirectDrawBuffer || !this._indirectDrawData) {\n      // The current buffer is already up to date so do nothing\n      // Note that we only check for instanceCount and not indexOrVertexCount nor firstIndexOrVertex because those values\n      // are supposed to not change during the lifetime of a draw context\n      return;\n    }\n    this._currentInstanceCount = instanceCount;\n    this._indirectDrawData[0] = indexOrVertexCount;\n    this._indirectDrawData[1] = instanceCount;\n    this._indirectDrawData[2] = firstIndexOrVertex;\n    this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);\n  }\n  dispose() {\n    if (this.indirectDrawBuffer) {\n      this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\n      this.indirectDrawBuffer = undefined;\n      this._indirectDrawData = undefined;\n    }\n    this.fastBundle = undefined;\n    this.bindGroups = undefined;\n    this.buffers = undefined;\n  }\n}\nWebGPUDrawContext._Counter = 0;","map":{"version":3,"mappings":"AAIA,OAAO,KAAKA,eAAe,MAAM,sBAAoB;AAErD;AACA,OAAM,MAAOC,iBAAiB;EAsD1BC,YAAYC,aAAkC;IAC1C,IAAI,CAACC,cAAc,GAAGD,aAAa;IACnC,IAAI,CAACE,QAAQ,GAAGJ,iBAAiB,CAACK,QAAQ,EAAE;IAC5C,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACC,qBAAqB,GAAG,CAAC;IAC9B,IAAI,CAACC,KAAK,EAAE;EAChB;EAzCOC,OAAO,CAACC,uBAA+B;IAC1C,OAAO,IAAI,CAACC,QAAQ,IAAI,IAAI,CAACC,wBAAwB,KAAKF,uBAAuB;EACrF;EAEOG,YAAY,CAACH,uBAA+B;IAC/C,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB,IAAI,CAACC,wBAAwB,GAAGF,uBAAuB;EAC3D;EAEA,IAAWI,aAAa;IACpB,OAAO,IAAI,CAACR,cAAc;EAC9B;EAEA,IAAWQ,aAAa,CAACC,GAAY;IACjC,IAAI,IAAI,CAACT,cAAc,KAAKS,GAAG,EAAE;MAC7B;;IAGJ,IAAI,CAACA,GAAG,EAAE;MACN,IAAI,IAAI,CAACC,kBAAkB,EAAE;QACzB,IAAI,CAACb,cAAc,CAACc,aAAa,CAAC,IAAI,CAACD,kBAAkB,CAAC;;MAE9D,IAAI,CAACA,kBAAkB,GAAGE,SAAS;MACnC,IAAI,CAACC,iBAAiB,GAAGD,SAAS;KACrC,MAAM;MACH,IAAI,CAACF,kBAAkB,GAAG,IAAI,CAACb,cAAc,CAACiB,eAAe,CAAC,EAAE,EAAErB,eAAe,CAACsB,WAAW,CAACC,OAAO,GAAGvB,eAAe,CAACsB,WAAW,CAACE,QAAQ,CAAC;MAC7I,IAAI,CAACJ,iBAAiB,GAAG,IAAIK,WAAW,CAAC,CAAC,CAAC;MAC3C,IAAI,CAACL,iBAAiB,CAAC,CAAC,CAAC,GAAG,CAAC;MAC7B,IAAI,CAACA,iBAAiB,CAAC,CAAC,CAAC,GAAG,CAAC;;IAGjC,IAAI,CAACb,cAAc,GAAGS,GAAG;IACzB,IAAI,CAACR,qBAAqB,GAAG,CAAC,CAAC;EACnC;EAUOC,KAAK;IACR,IAAI,CAACiB,OAAO,GAAG,EAAE;IACjB,IAAI,CAACd,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,wBAAwB,GAAG,CAAC;IACjC,IAAI,CAACc,UAAU,GAAGR,SAAS;IAC3B,IAAI,CAACS,UAAU,GAAGT,SAAS;EAC/B;EAEOU,SAAS,CAACC,IAAY,EAAEC,MAAkC;;IAC7D,IAAI,CAACnB,QAAQ,KAAb,IAAI,CAACA,QAAQ,GAAK,OAAM,aAANmB,MAAM,uBAANA,MAAM,CAAE1B,QAAQ,OAAK,UAAI,CAACqB,OAAO,CAACI,IAAI,CAAC,0CAAEzB,QAAQ;IAEnE,IAAI,CAACqB,OAAO,CAACI,IAAI,CAAC,GAAGC,MAAM;EAC/B;EAEOC,eAAe,CAACC,kBAA0B,EAAEC,aAAqB,EAAEC,kBAA0B;IAChG,IAAID,aAAa,KAAK,IAAI,CAAC1B,qBAAqB,IAAI,CAAC,IAAI,CAACS,kBAAkB,IAAI,CAAC,IAAI,CAACG,iBAAiB,EAAE;MACrG;MACA;MACA;MACA;;IAEJ,IAAI,CAACZ,qBAAqB,GAAG0B,aAAa;IAE1C,IAAI,CAACd,iBAAkB,CAAC,CAAC,CAAC,GAAGa,kBAAkB;IAC/C,IAAI,CAACb,iBAAkB,CAAC,CAAC,CAAC,GAAGc,aAAa;IAC1C,IAAI,CAACd,iBAAkB,CAAC,CAAC,CAAC,GAAGe,kBAAkB;IAE/C,IAAI,CAAC/B,cAAc,CAACgC,UAAU,CAAC,IAAI,CAACnB,kBAAkB,EAAE,CAAC,EAAE,IAAI,CAACG,iBAAiB,EAAE,CAAC,EAAE,EAAE,CAAC;EAC7F;EAEOiB,OAAO;IACV,IAAI,IAAI,CAACpB,kBAAkB,EAAE;MACzB,IAAI,CAACb,cAAc,CAACc,aAAa,CAAC,IAAI,CAACD,kBAAkB,CAAC;MAC1D,IAAI,CAACA,kBAAkB,GAAGE,SAAS;MACnC,IAAI,CAACC,iBAAiB,GAAGD,SAAS;;IAEtC,IAAI,CAACQ,UAAU,GAAGR,SAAS;IAC3B,IAAI,CAACS,UAAU,GAAGT,SAAS;IAC3B,IAAI,CAACO,OAAO,GAAGP,SAAgB;EACnC;;AApGelB,0BAAQ,GAAG,CAAC","names":["WebGPUConstants","WebGPUDrawContext","constructor","bufferManager","_bufferManager","uniqueId","_Counter","_useInstancing","_currentInstanceCount","reset","isDirty","materialContextUpdateId","_isDirty","_materialContextUpdateId","resetIsDirty","useInstancing","use","indirectDrawBuffer","releaseBuffer","undefined","_indirectDrawData","createRawBuffer","BufferUsage","CopyDst","Indirect","Uint32Array","buffers","fastBundle","bindGroups","setBuffer","name","buffer","setIndirectData","indexOrVertexCount","instanceCount","firstIndexOrVertex","setRawData","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuDrawContext.ts"],"sourcesContent":["import type { WebGPUDataBuffer } from \"../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDrawContext } from \"../IDrawContext\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\n\r\n/** @internal */\r\nexport class WebGPUDrawContext implements IDrawContext {\r\n    private static _Counter = 0;\r\n\r\n    public fastBundle?: GPURenderBundle; // used only when compatibilityMode==false (fast mode)\r\n    public bindGroups?: GPUBindGroup[]; // cache of the bind groups. Will be reused for the next draw if isDirty==false (and materialContext.isDirty==false)\r\n\r\n    public uniqueId: number;\r\n\r\n    public buffers: { [name: string]: Nullable<WebGPUDataBuffer> };\r\n\r\n    public indirectDrawBuffer?: GPUBuffer;\r\n\r\n    private _materialContextUpdateId: number;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _useInstancing: boolean;\r\n    private _indirectDrawData?: Uint32Array;\r\n    private _currentInstanceCount: number;\r\n    private _isDirty: boolean;\r\n\r\n    public isDirty(materialContextUpdateId: number): boolean {\r\n        return this._isDirty || this._materialContextUpdateId !== materialContextUpdateId;\r\n    }\r\n\r\n    public resetIsDirty(materialContextUpdateId: number): void {\r\n        this._isDirty = false;\r\n        this._materialContextUpdateId = materialContextUpdateId;\r\n    }\r\n\r\n    public get useInstancing() {\r\n        return this._useInstancing;\r\n    }\r\n\r\n    public set useInstancing(use: boolean) {\r\n        if (this._useInstancing === use) {\r\n            return;\r\n        }\r\n\r\n        if (!use) {\r\n            if (this.indirectDrawBuffer) {\r\n                this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            }\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        } else {\r\n            this.indirectDrawBuffer = this._bufferManager.createRawBuffer(40, WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.Indirect);\r\n            this._indirectDrawData = new Uint32Array(5);\r\n            this._indirectDrawData[3] = 0;\r\n            this._indirectDrawData[4] = 0;\r\n        }\r\n\r\n        this._useInstancing = use;\r\n        this._currentInstanceCount = -1;\r\n    }\r\n\r\n    constructor(bufferManager: WebGPUBufferManager) {\r\n        this._bufferManager = bufferManager;\r\n        this.uniqueId = WebGPUDrawContext._Counter++;\r\n        this._useInstancing = false;\r\n        this._currentInstanceCount = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.buffers = {};\r\n        this._isDirty = true;\r\n        this._materialContextUpdateId = 0;\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n    }\r\n\r\n    public setBuffer(name: string, buffer: Nullable<WebGPUDataBuffer>): void {\r\n        this._isDirty ||= buffer?.uniqueId !== this.buffers[name]?.uniqueId;\r\n\r\n        this.buffers[name] = buffer;\r\n    }\r\n\r\n    public setIndirectData(indexOrVertexCount: number, instanceCount: number, firstIndexOrVertex: number): void {\r\n        if (instanceCount === this._currentInstanceCount || !this.indirectDrawBuffer || !this._indirectDrawData) {\r\n            // The current buffer is already up to date so do nothing\r\n            // Note that we only check for instanceCount and not indexOrVertexCount nor firstIndexOrVertex because those values\r\n            // are supposed to not change during the lifetime of a draw context\r\n            return;\r\n        }\r\n        this._currentInstanceCount = instanceCount;\r\n\r\n        this._indirectDrawData![0] = indexOrVertexCount;\r\n        this._indirectDrawData![1] = instanceCount;\r\n        this._indirectDrawData![2] = firstIndexOrVertex;\r\n\r\n        this._bufferManager.setRawData(this.indirectDrawBuffer, 0, this._indirectDrawData, 0, 20);\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.indirectDrawBuffer) {\r\n            this._bufferManager.releaseBuffer(this.indirectDrawBuffer);\r\n            this.indirectDrawBuffer = undefined;\r\n            this._indirectDrawData = undefined;\r\n        }\r\n        this.fastBundle = undefined;\r\n        this.bindGroups = undefined;\r\n        this.buffers = undefined as any;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}