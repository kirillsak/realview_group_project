{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size, options) {\n  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n  internalTexture.isCube = true;\n  const internalOptions = {\n    bilinearFiltering: false,\n    comparisonFunction: 0,\n    generateStencil: false,\n    samples: 1,\n    ...options\n  };\n  // TODO WEBGPU allow to choose the format?\n  internalTexture.format = internalOptions.generateStencil ? 13 : 14;\n  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);\n  this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\n  this._internalTexturesCache.push(internalTexture);\n  return internalTexture;\n};\nWebGPUEngine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, useSRGBBuffer = false) {\n  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, null, (texture, imgs) => {\n    const imageBitmaps = imgs; // we will always get an ImageBitmap array in WebGPU\n    const width = imageBitmaps[0].width;\n    const height = width;\n    this._setCubeMapTextureParams(texture, !noMipmap);\n    texture.format = format !== null && format !== void 0 ? format : -1;\n    const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\n    this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource, width, height, gpuTextureWrapper.format, false, false, 0, 0);\n    if (!noMipmap) {\n      this._generateMipmaps(texture, this._uploadEncoder);\n    }\n    texture.isReady = true;\n    texture.onLoadedObservable.notifyObservers(texture);\n    texture.onLoadedObservable.clear();\n    if (onLoad) {\n      onLoad();\n    }\n  }, !!useSRGBBuffer);\n};\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture, loadMipmap, maxLevel) {\n  texture.samplingMode = loadMipmap ? 3 : 2;\n  texture._cachedWrapU = 0;\n  texture._cachedWrapV = 0;\n  if (maxLevel) {\n    texture._maxLodLevel = maxLevel;\n  }\n};","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","WebGPUEngine","prototype","_createDepthStencilCubeTexture","size","options","internalTexture","DepthStencil","isCube","internalOptions","bilinearFiltering","comparisonFunction","generateStencil","samples","format","_setupDepthStencilTexture","_textureHelper","createGPUTextureForInternalTexture","_internalTexturesCache","push","createCubeTexture","rootUrl","scene","files","noMipmap","onLoad","onError","forcedExtension","createPolynomials","lodScale","lodOffset","fallback","useSRGBBuffer","createCubeTextureBase","texture","imgs","imageBitmaps","width","height","_setCubeMapTextureParams","gpuTextureWrapper","updateCubeTextures","underlyingResource","_generateMipmaps","_uploadEncoder","isReady","onLoadedObservable","notifyObservers","clear","loadMipmap","maxLevel","samplingMode","_cachedWrapU","_cachedWrapV","_maxLodLevel"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.cubeTexture.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { DepthTextureCreationOptions } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\n\r\ndeclare type Scene = import(\"../../../scene\").Scene;\r\n\r\nWebGPUEngine.prototype._createDepthStencilCubeTexture = function (size: number, options: DepthTextureCreationOptions): InternalTexture {\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n    internalTexture.isCube = true;\r\n\r\n    const internalOptions = {\r\n        bilinearFiltering: false,\r\n        comparisonFunction: 0,\r\n        generateStencil: false,\r\n        samples: 1,\r\n        ...options,\r\n    };\r\n\r\n    // TODO WEBGPU allow to choose the format?\r\n    internalTexture.format = internalOptions.generateStencil ? Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 : Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\r\n\r\n    this._setupDepthStencilTexture(\r\n        internalTexture,\r\n        size,\r\n        internalOptions.generateStencil,\r\n        internalOptions.bilinearFiltering,\r\n        internalOptions.comparisonFunction,\r\n        internalOptions.samples\r\n    );\r\n\r\n    this._textureHelper.createGPUTextureForInternalTexture(internalTexture);\r\n\r\n    this._internalTexturesCache.push(internalTexture);\r\n\r\n    return internalTexture;\r\n};\r\n\r\nWebGPUEngine.prototype.createCubeTexture = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    return this.createCubeTextureBase(\r\n        rootUrl,\r\n        scene,\r\n        files,\r\n        !!noMipmap,\r\n        onLoad,\r\n        onError,\r\n        format,\r\n        forcedExtension,\r\n        createPolynomials,\r\n        lodScale,\r\n        lodOffset,\r\n        fallback,\r\n        null,\r\n        (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n            const imageBitmaps = imgs as ImageBitmap[]; // we will always get an ImageBitmap array in WebGPU\r\n            const width = imageBitmaps[0].width;\r\n            const height = width;\r\n\r\n            this._setCubeMapTextureParams(texture, !noMipmap);\r\n            texture.format = format ?? -1;\r\n\r\n            const gpuTextureWrapper = this._textureHelper.createGPUTextureForInternalTexture(texture, width, height);\r\n\r\n            this._textureHelper.updateCubeTextures(imageBitmaps, gpuTextureWrapper.underlyingResource!, width, height, gpuTextureWrapper.format, false, false, 0, 0);\r\n\r\n            if (!noMipmap) {\r\n                this._generateMipmaps(texture, this._uploadEncoder);\r\n            }\r\n\r\n            texture.isReady = true;\r\n\r\n            texture.onLoadedObservable.notifyObservers(texture);\r\n            texture.onLoadedObservable.clear();\r\n\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        },\r\n        !!useSRGBBuffer\r\n    );\r\n};\r\n\r\nWebGPUEngine.prototype._setCubeMapTextureParams = function (texture: InternalTexture, loadMipmap: boolean, maxLevel?: number) {\r\n    texture.samplingMode = loadMipmap ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    if (maxLevel) {\r\n        texture._maxLodLevel = maxLevel;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}