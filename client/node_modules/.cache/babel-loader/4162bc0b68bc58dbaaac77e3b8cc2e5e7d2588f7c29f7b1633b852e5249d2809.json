{"ast":null,"code":"/**\n * Class used to evaluate queries containing `and` and `or` operators\n */\nexport class AndOrNotEvaluator {\n  /**\n   * Evaluate a query\n   * @param query defines the query to evaluate\n   * @param evaluateCallback defines the callback used to filter result\n   * @returns true if the query matches\n   */\n  static Eval(query, evaluateCallback) {\n    if (!query.match(/\\([^()]*\\)/g)) {\n      query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n    } else {\n      query = query.replace(/\\([^()]*\\)/g, r => {\n        // remove parenthesis\n        r = r.slice(1, r.length - 1);\n        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n      });\n    }\n    if (query === \"true\") {\n      return true;\n    }\n    if (query === \"false\") {\n      return false;\n    }\n    return AndOrNotEvaluator.Eval(query, evaluateCallback);\n  }\n  static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {\n    evaluateCallback = evaluateCallback || (r => {\n      return r === \"true\" ? true : false;\n    });\n    let result;\n    const or = parenthesisContent.split(\"||\");\n    for (const i in or) {\n      if (Object.prototype.hasOwnProperty.call(or, i)) {\n        let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n        const and = ori.split(\"&&\");\n        if (and.length > 1) {\n          for (let j = 0; j < and.length; ++j) {\n            const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n            if (andj !== \"true\" && andj !== \"false\") {\n              if (andj[0] === \"!\") {\n                result = !evaluateCallback(andj.substring(1));\n              } else {\n                result = evaluateCallback(andj);\n              }\n            } else {\n              result = andj === \"true\" ? true : false;\n            }\n            if (!result) {\n              // no need to continue since 'false && ... && ...' will always return false\n              ori = \"false\";\n              break;\n            }\n          }\n        }\n        if (result || ori === \"true\") {\n          // no need to continue since 'true || ... || ...' will always return true\n          result = true;\n          break;\n        }\n        // result equals false (or undefined)\n        if (ori !== \"true\" && ori !== \"false\") {\n          if (ori[0] === \"!\") {\n            result = !evaluateCallback(ori.substring(1));\n          } else {\n            result = evaluateCallback(ori);\n          }\n        } else {\n          result = ori === \"true\" ? true : false;\n        }\n      }\n    }\n    // the whole parenthesis scope is replaced by 'true' or 'false'\n    return result ? \"true\" : \"false\";\n  }\n  static _SimplifyNegation(booleanString) {\n    booleanString = booleanString.replace(/^[\\s!]+/, r => {\n      // remove whitespaces\n      r = r.replace(/[\\s]/g, () => \"\");\n      return r.length % 2 ? \"!\" : \"\";\n    });\n    booleanString = booleanString.trim();\n    if (booleanString === \"!true\") {\n      booleanString = \"false\";\n    } else if (booleanString === \"!false\") {\n      booleanString = \"true\";\n    }\n    return booleanString;\n  }\n}","map":{"version":3,"mappings":"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","names":["AndOrNotEvaluator","Eval","query","evaluateCallback","match","_HandleParenthesisContent","replace","r","slice","length","parenthesisContent","result","or","split","i","Object","prototype","hasOwnProperty","call","ori","_SimplifyNegation","trim","and","j","andj","substring","booleanString"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/andOrNotEvaluator.ts"],"sourcesContent":["/**\r\n * Class used to evaluate queries containing `and` and `or` operators\r\n */\r\nexport class AndOrNotEvaluator {\r\n    /**\r\n     * Evaluate a query\r\n     * @param query defines the query to evaluate\r\n     * @param evaluateCallback defines the callback used to filter result\r\n     * @returns true if the query matches\r\n     */\r\n    public static Eval(query: string, evaluateCallback: (val: any) => boolean): boolean {\r\n        if (!query.match(/\\([^()]*\\)/g)) {\r\n            query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\r\n        } else {\r\n            query = query.replace(/\\([^()]*\\)/g, (r) => {\r\n                // remove parenthesis\r\n                r = r.slice(1, r.length - 1);\r\n                return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\r\n            });\r\n        }\r\n\r\n        if (query === \"true\") {\r\n            return true;\r\n        }\r\n\r\n        if (query === \"false\") {\r\n            return false;\r\n        }\r\n\r\n        return AndOrNotEvaluator.Eval(query, evaluateCallback);\r\n    }\r\n\r\n    private static _HandleParenthesisContent(parenthesisContent: string, evaluateCallback: (val: string) => boolean): string {\r\n        evaluateCallback =\r\n            evaluateCallback ||\r\n            ((r) => {\r\n                return r === \"true\" ? true : false;\r\n            });\r\n\r\n        let result;\r\n        const or = parenthesisContent.split(\"||\");\r\n\r\n        for (const i in or) {\r\n            if (Object.prototype.hasOwnProperty.call(or, i)) {\r\n                let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\r\n                const and = ori.split(\"&&\");\r\n\r\n                if (and.length > 1) {\r\n                    for (let j = 0; j < and.length; ++j) {\r\n                        const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\r\n                        if (andj !== \"true\" && andj !== \"false\") {\r\n                            if (andj[0] === \"!\") {\r\n                                result = !evaluateCallback(andj.substring(1));\r\n                            } else {\r\n                                result = evaluateCallback(andj);\r\n                            }\r\n                        } else {\r\n                            result = andj === \"true\" ? true : false;\r\n                        }\r\n                        if (!result) {\r\n                            // no need to continue since 'false && ... && ...' will always return false\r\n                            ori = \"false\";\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (result || ori === \"true\") {\r\n                    // no need to continue since 'true || ... || ...' will always return true\r\n                    result = true;\r\n                    break;\r\n                }\r\n\r\n                // result equals false (or undefined)\r\n\r\n                if (ori !== \"true\" && ori !== \"false\") {\r\n                    if (ori[0] === \"!\") {\r\n                        result = !evaluateCallback(ori.substring(1));\r\n                    } else {\r\n                        result = evaluateCallback(ori);\r\n                    }\r\n                } else {\r\n                    result = ori === \"true\" ? true : false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // the whole parenthesis scope is replaced by 'true' or 'false'\r\n        return result ? \"true\" : \"false\";\r\n    }\r\n\r\n    private static _SimplifyNegation(booleanString: string): string {\r\n        booleanString = booleanString.replace(/^[\\s!]+/, (r) => {\r\n            // remove whitespaces\r\n            r = r.replace(/[\\s]/g, () => \"\");\r\n            return r.length % 2 ? \"!\" : \"\";\r\n        });\r\n\r\n        booleanString = booleanString.trim();\r\n\r\n        if (booleanString === \"!true\") {\r\n            booleanString = \"false\";\r\n        } else if (booleanString === \"!false\") {\r\n            booleanString = \"true\";\r\n        }\r\n\r\n        return booleanString;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}