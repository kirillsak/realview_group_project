{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\";\n// Sets the default audio engine to Babylon.js\nEngine.AudioEngineFactory = (hostElement, audioContext, audioDestination) => {\n  return new AudioEngine(hostElement, audioContext, audioDestination);\n};\n/**\n * This represents the default audio engine used in babylon.\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\n */\nexport class AudioEngine {\n  /**\n   * Instantiates a new audio engine.\n   *\n   * There should be only one per page as some browsers restrict the number\n   * of audio contexts you can create.\n   * @param hostElement defines the host element where to display the mute icon if necessary\n   * @param audioContext defines the audio context to be used by the audio engine\n   * @param audioDestination defines the audio destination node to be used by audio engine\n   */\n  constructor(hostElement = null, audioContext = null, audioDestination = null) {\n    this._audioContext = null;\n    this._audioContextInitialized = false;\n    this._muteButton = null;\n    this._audioDestination = null;\n    /**\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\n     */\n    this.canUseWebAudio = false;\n    /**\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\n     * @ignoreNaming\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.WarnedWebAudioUnsupported = false;\n    /**\n     * Gets whether or not mp3 are supported by your browser.\n     */\n    this.isMP3supported = false;\n    /**\n     * Gets whether or not ogg are supported by your browser.\n     */\n    this.isOGGsupported = false;\n    /**\n     * Gets whether audio has been unlocked on the device.\n     * Some Browsers have strong restrictions about Audio and won t autoplay unless\n     * a user interaction has happened.\n     */\n    this.unlocked = true;\n    /**\n     * Defines if the audio engine relies on a custom unlocked button.\n     * In this case, the embedded button will not be displayed.\n     */\n    this.useCustomUnlockedButton = false;\n    /**\n     * Event raised when audio has been unlocked on the browser.\n     */\n    this.onAudioUnlockedObservable = new Observable();\n    /**\n     * Event raised when audio has been locked on the browser.\n     */\n    this.onAudioLockedObservable = new Observable();\n    this._tryToRun = false;\n    this._onResize = () => {\n      this._moveButtonToTopLeft();\n    };\n    if (!IsWindowObjectExist()) {\n      return;\n    }\n    if (typeof window.AudioContext !== \"undefined\") {\n      this.canUseWebAudio = true;\n    }\n    const audioElem = document.createElement(\"audio\");\n    this._hostElement = hostElement;\n    this._audioContext = audioContext;\n    this._audioDestination = audioDestination;\n    try {\n      if (audioElem && !!audioElem.canPlayType && (audioElem.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, \"\") || audioElem.canPlayType(\"audio/mp3\").replace(/^no$/, \"\"))) {\n        this.isMP3supported = true;\n      }\n    } catch (e) {\n      // protect error during capability check.\n    }\n    try {\n      if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\")) {\n        this.isOGGsupported = true;\n      }\n    } catch (e) {\n      // protect error during capability check.\n    }\n  }\n  /**\n   * Gets the current AudioContext if available.\n   */\n  get audioContext() {\n    if (!this._audioContextInitialized) {\n      this._initializeAudioContext();\n    } else {\n      if (!this.unlocked && !this._muteButton) {\n        this._displayMuteButton();\n      }\n    }\n    return this._audioContext;\n  }\n  /**\n   * Flags the audio engine in Locked state.\n   * This happens due to new browser policies preventing audio to autoplay.\n   */\n  lock() {\n    this._triggerSuspendedState();\n  }\n  /**\n   * Unlocks the audio engine once a user action has been done on the dom.\n   * This is helpful to resume play once browser policies have been satisfied.\n   */\n  unlock() {\n    this._triggerRunningState();\n  }\n  _resumeAudioContext() {\n    let result;\n    if (this._audioContext.resume !== undefined) {\n      result = this._audioContext.resume();\n    }\n    return result || Promise.resolve();\n  }\n  _initializeAudioContext() {\n    try {\n      if (this.canUseWebAudio) {\n        if (!this._audioContext) {\n          this._audioContext = new AudioContext();\n        }\n        // create a global volume gain node\n        this.masterGain = this._audioContext.createGain();\n        this.masterGain.gain.value = 1;\n        if (!this._audioDestination) {\n          this._audioDestination = this._audioContext.destination;\n        }\n        this.masterGain.connect(this._audioDestination);\n        this._audioContextInitialized = true;\n        if (this._audioContext.state === \"running\") {\n          // Do not wait for the promise to unlock.\n          this._triggerRunningState();\n        }\n      }\n    } catch (e) {\n      this.canUseWebAudio = false;\n      Logger.Error(\"Web Audio: \" + e.message);\n    }\n  }\n  _triggerRunningState() {\n    if (this._tryToRun) {\n      return;\n    }\n    this._tryToRun = true;\n    this._resumeAudioContext().then(() => {\n      this._tryToRun = false;\n      if (this._muteButton) {\n        this._hideMuteButton();\n      }\n      // Notify users that the audio stack is unlocked/unmuted\n      this.unlocked = true;\n      this.onAudioUnlockedObservable.notifyObservers(this);\n    }).catch(() => {\n      this._tryToRun = false;\n      this.unlocked = false;\n    });\n  }\n  _triggerSuspendedState() {\n    this.unlocked = false;\n    this.onAudioLockedObservable.notifyObservers(this);\n    this._displayMuteButton();\n  }\n  _displayMuteButton() {\n    if (this.useCustomUnlockedButton || this._muteButton) {\n      return;\n    }\n    this._muteButton = document.createElement(\"BUTTON\");\n    this._muteButton.className = \"babylonUnmuteIcon\";\n    this._muteButton.id = \"babylonUnmuteIconBtn\";\n    this._muteButton.title = \"Unmute\";\n    const imageUrl = !window.SVGSVGElement ? \"https://cdn.babylonjs.com/Assets/audio.png\" : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\";\n    const css = \".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(\" + imageUrl + \");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }\";\n    const style = document.createElement(\"style\");\n    style.appendChild(document.createTextNode(css));\n    document.getElementsByTagName(\"head\")[0].appendChild(style);\n    document.body.appendChild(this._muteButton);\n    this._moveButtonToTopLeft();\n    this._muteButton.addEventListener(\"touchend\", () => {\n      this._triggerRunningState();\n    }, true);\n    this._muteButton.addEventListener(\"click\", () => {\n      this._triggerRunningState();\n    }, true);\n    window.addEventListener(\"resize\", this._onResize);\n  }\n  _moveButtonToTopLeft() {\n    if (this._hostElement && this._muteButton) {\n      this._muteButton.style.top = this._hostElement.offsetTop + 20 + \"px\";\n      this._muteButton.style.left = this._hostElement.offsetLeft + 20 + \"px\";\n    }\n  }\n  _hideMuteButton() {\n    if (this._muteButton) {\n      document.body.removeChild(this._muteButton);\n      this._muteButton = null;\n    }\n  }\n  /**\n   * Destroy and release the resources associated with the audio context.\n   */\n  dispose() {\n    if (this.canUseWebAudio && this._audioContextInitialized) {\n      if (this._connectedAnalyser && this._audioContext) {\n        this._connectedAnalyser.stopDebugCanvas();\n        this._connectedAnalyser.dispose();\n        this.masterGain.disconnect();\n        this.masterGain.connect(this._audioContext.destination);\n        this._connectedAnalyser = null;\n      }\n      this.masterGain.gain.value = 1;\n    }\n    this.WarnedWebAudioUnsupported = false;\n    this._hideMuteButton();\n    window.removeEventListener(\"resize\", this._onResize);\n    this.onAudioUnlockedObservable.clear();\n    this.onAudioLockedObservable.clear();\n  }\n  /**\n   * Gets the global volume sets on the master gain.\n   * @returns the global volume if set or -1 otherwise\n   */\n  getGlobalVolume() {\n    if (this.canUseWebAudio && this._audioContextInitialized) {\n      return this.masterGain.gain.value;\n    } else {\n      return -1;\n    }\n  }\n  /**\n   * Sets the global volume of your experience (sets on the master gain).\n   * @param newVolume Defines the new global volume of the application\n   */\n  setGlobalVolume(newVolume) {\n    if (this.canUseWebAudio && this._audioContextInitialized) {\n      this.masterGain.gain.value = newVolume;\n    }\n  }\n  /**\n   * Connect the audio engine to an audio analyser allowing some amazing\n   * synchronization between the sounds/music and your visualization (VuMeter for instance).\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\n   * @param analyser The analyser to connect to the engine\n   */\n  connectToAnalyser(analyser) {\n    if (this._connectedAnalyser) {\n      this._connectedAnalyser.stopDebugCanvas();\n    }\n    if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {\n      this._connectedAnalyser = analyser;\n      this.masterGain.disconnect();\n      this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","Logger","Engine","IsWindowObjectExist","AudioEngineFactory","hostElement","audioContext","audioDestination","AudioEngine","constructor","_moveButtonToTopLeft","window","AudioContext","canUseWebAudio","audioElem","document","createElement","_hostElement","_audioContext","_audioDestination","canPlayType","replace","isMP3supported","e","isOGGsupported","_audioContextInitialized","_initializeAudioContext","unlocked","_muteButton","_displayMuteButton","lock","_triggerSuspendedState","unlock","_triggerRunningState","_resumeAudioContext","result","resume","undefined","Promise","resolve","masterGain","createGain","gain","value","destination","connect","state","Error","message","_tryToRun","then","_hideMuteButton","onAudioUnlockedObservable","notifyObservers","catch","onAudioLockedObservable","useCustomUnlockedButton","className","id","title","imageUrl","SVGSVGElement","css","style","appendChild","createTextNode","getElementsByTagName","body","addEventListener","_onResize","top","offsetTop","left","offsetLeft","removeChild","dispose","_connectedAnalyser","stopDebugCanvas","disconnect","WarnedWebAudioUnsupported","removeEventListener","clear","getGlobalVolume","setGlobalVolume","newVolume","connectToAnalyser","analyser","connectAudioNodes"],"sourceRoot":"","sources":["../../../../lts/core/generated/Audio/audioEngine.ts"],"sourcesContent":["import type { Analyser } from \"./analyser\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\n\r\n// Sets the default audio engine to Babylon.js\r\nEngine.AudioEngineFactory = (\r\n    hostElement: Nullable<HTMLElement>,\r\n    audioContext: Nullable<AudioContext>,\r\n    audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n) => {\r\n    return new AudioEngine(hostElement, audioContext, audioDestination);\r\n};\r\n\r\n/**\r\n * This represents the default audio engine used in babylon.\r\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class AudioEngine implements IAudioEngine {\r\n    private _audioContext: Nullable<AudioContext> = null;\r\n    private _audioContextInitialized = false;\r\n    private _muteButton: Nullable<HTMLButtonElement> = null;\r\n    private _hostElement: Nullable<HTMLElement>;\r\n    private _audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null;\r\n\r\n    /**\r\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\r\n     */\r\n    public canUseWebAudio: boolean = false;\r\n\r\n    /**\r\n     * The master gain node defines the global audio volume of your audio engine.\r\n     */\r\n    public masterGain: GainNode;\r\n\r\n    /**\r\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\r\n     * @ignoreNaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public WarnedWebAudioUnsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not mp3 are supported by your browser.\r\n     */\r\n    public isMP3supported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not ogg are supported by your browser.\r\n     */\r\n    public isOGGsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether audio has been unlocked on the device.\r\n     * Some Browsers have strong restrictions about Audio and won t autoplay unless\r\n     * a user interaction has happened.\r\n     */\r\n    public unlocked: boolean = true;\r\n\r\n    /**\r\n     * Defines if the audio engine relies on a custom unlocked button.\r\n     * In this case, the embedded button will not be displayed.\r\n     */\r\n    public useCustomUnlockedButton: boolean = false;\r\n\r\n    /**\r\n     * Event raised when audio has been unlocked on the browser.\r\n     */\r\n    public onAudioUnlockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Event raised when audio has been locked on the browser.\r\n     */\r\n    public onAudioLockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Gets the current AudioContext if available.\r\n     */\r\n    public get audioContext(): Nullable<AudioContext> {\r\n        if (!this._audioContextInitialized) {\r\n            this._initializeAudioContext();\r\n        } else {\r\n            if (!this.unlocked && !this._muteButton) {\r\n                this._displayMuteButton();\r\n            }\r\n        }\r\n        return this._audioContext;\r\n    }\r\n\r\n    private _connectedAnalyser: Nullable<Analyser>;\r\n\r\n    /**\r\n     * Instantiates a new audio engine.\r\n     *\r\n     * There should be only one per page as some browsers restrict the number\r\n     * of audio contexts you can create.\r\n     * @param hostElement defines the host element where to display the mute icon if necessary\r\n     * @param audioContext defines the audio context to be used by the audio engine\r\n     * @param audioDestination defines the audio destination node to be used by audio engine\r\n     */\r\n    constructor(\r\n        hostElement: Nullable<HTMLElement> = null,\r\n        audioContext: Nullable<AudioContext> = null,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null\r\n    ) {\r\n        if (!IsWindowObjectExist()) {\r\n            return;\r\n        }\r\n        if (typeof window.AudioContext !== \"undefined\") {\r\n            this.canUseWebAudio = true;\r\n        }\r\n\r\n        const audioElem = document.createElement(\"audio\");\r\n        this._hostElement = hostElement;\r\n        this._audioContext = audioContext;\r\n        this._audioDestination = audioDestination;\r\n\r\n        try {\r\n            if (\r\n                audioElem &&\r\n                !!audioElem.canPlayType &&\r\n                (audioElem.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, \"\") || audioElem.canPlayType(\"audio/mp3\").replace(/^no$/, \"\"))\r\n            ) {\r\n                this.isMP3supported = true;\r\n            }\r\n        } catch (e) {\r\n            // protect error during capability check.\r\n        }\r\n\r\n        try {\r\n            if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, \"\")) {\r\n                this.isOGGsupported = true;\r\n            }\r\n        } catch (e) {\r\n            // protect error during capability check.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Flags the audio engine in Locked state.\r\n     * This happens due to new browser policies preventing audio to autoplay.\r\n     */\r\n    public lock() {\r\n        this._triggerSuspendedState();\r\n    }\r\n\r\n    /**\r\n     * Unlocks the audio engine once a user action has been done on the dom.\r\n     * This is helpful to resume play once browser policies have been satisfied.\r\n     */\r\n    public unlock() {\r\n        this._triggerRunningState();\r\n    }\r\n\r\n    private _resumeAudioContext(): Promise<void> {\r\n        let result: Promise<void>;\r\n        if (this._audioContext!.resume !== undefined) {\r\n            result = this._audioContext!.resume();\r\n        }\r\n        return result! || Promise.resolve();\r\n    }\r\n\r\n    private _initializeAudioContext() {\r\n        try {\r\n            if (this.canUseWebAudio) {\r\n                if (!this._audioContext) {\r\n                    this._audioContext = new AudioContext();\r\n                }\r\n                // create a global volume gain node\r\n                this.masterGain = this._audioContext.createGain();\r\n                this.masterGain.gain.value = 1;\r\n                if (!this._audioDestination) {\r\n                    this._audioDestination = this._audioContext.destination;\r\n                }\r\n                this.masterGain.connect(this._audioDestination);\r\n                this._audioContextInitialized = true;\r\n                if (this._audioContext.state === \"running\") {\r\n                    // Do not wait for the promise to unlock.\r\n                    this._triggerRunningState();\r\n                }\r\n            }\r\n        } catch (e) {\r\n            this.canUseWebAudio = false;\r\n            Logger.Error(\"Web Audio: \" + e.message);\r\n        }\r\n    }\r\n\r\n    private _tryToRun = false;\r\n    private _triggerRunningState() {\r\n        if (this._tryToRun) {\r\n            return;\r\n        }\r\n        this._tryToRun = true;\r\n\r\n        this._resumeAudioContext()\r\n            .then(() => {\r\n                this._tryToRun = false;\r\n                if (this._muteButton) {\r\n                    this._hideMuteButton();\r\n                }\r\n                // Notify users that the audio stack is unlocked/unmuted\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            })\r\n            .catch(() => {\r\n                this._tryToRun = false;\r\n                this.unlocked = false;\r\n            });\r\n    }\r\n\r\n    private _triggerSuspendedState() {\r\n        this.unlocked = false;\r\n        this.onAudioLockedObservable.notifyObservers(this);\r\n        this._displayMuteButton();\r\n    }\r\n\r\n    private _displayMuteButton() {\r\n        if (this.useCustomUnlockedButton || this._muteButton) {\r\n            return;\r\n        }\r\n\r\n        this._muteButton = <HTMLButtonElement>document.createElement(\"BUTTON\");\r\n        this._muteButton.className = \"babylonUnmuteIcon\";\r\n        this._muteButton.id = \"babylonUnmuteIconBtn\";\r\n        this._muteButton.title = \"Unmute\";\r\n        const imageUrl = !window.SVGSVGElement\r\n            ? \"https://cdn.babylonjs.com/Assets/audio.png\"\r\n            : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\";\r\n\r\n        const css =\r\n            \".babylonUnmuteIcon { position: absolute; left: 20px; top: 20px; height: 40px; width: 60px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n            imageUrl +\r\n            \");  background-size: 80%; background-repeat:no-repeat; background-position: center; background-position-y: 4px; border: none; outline: none; transition: transform 0.125s ease-out; cursor: pointer; z-index: 9999; } .babylonUnmuteIcon:hover { transform: scale(1.05) } .babylonUnmuteIcon:active { background-color: rgba(51,51,51,1) }\";\r\n\r\n        const style = document.createElement(\"style\");\r\n        style.appendChild(document.createTextNode(css));\r\n        document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n\r\n        document.body.appendChild(this._muteButton);\r\n\r\n        this._moveButtonToTopLeft();\r\n\r\n        this._muteButton.addEventListener(\r\n            \"touchend\",\r\n            () => {\r\n                this._triggerRunningState();\r\n            },\r\n            true\r\n        );\r\n        this._muteButton.addEventListener(\r\n            \"click\",\r\n            () => {\r\n                this._triggerRunningState();\r\n            },\r\n            true\r\n        );\r\n\r\n        window.addEventListener(\"resize\", this._onResize);\r\n    }\r\n\r\n    private _moveButtonToTopLeft() {\r\n        if (this._hostElement && this._muteButton) {\r\n            this._muteButton.style.top = this._hostElement.offsetTop + 20 + \"px\";\r\n            this._muteButton.style.left = this._hostElement.offsetLeft + 20 + \"px\";\r\n        }\r\n    }\r\n\r\n    private _onResize = () => {\r\n        this._moveButtonToTopLeft();\r\n    };\r\n\r\n    private _hideMuteButton() {\r\n        if (this._muteButton) {\r\n            document.body.removeChild(this._muteButton);\r\n            this._muteButton = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy and release the resources associated with the audio context.\r\n     */\r\n    public dispose(): void {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            if (this._connectedAnalyser && this._audioContext) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n                this._connectedAnalyser.dispose();\r\n                this.masterGain.disconnect();\r\n                this.masterGain.connect(this._audioContext.destination);\r\n                this._connectedAnalyser = null;\r\n            }\r\n            this.masterGain.gain.value = 1;\r\n        }\r\n        this.WarnedWebAudioUnsupported = false;\r\n        this._hideMuteButton();\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n\r\n        this.onAudioUnlockedObservable.clear();\r\n        this.onAudioLockedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the global volume sets on the master gain.\r\n     * @returns the global volume if set or -1 otherwise\r\n     */\r\n    public getGlobalVolume(): number {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            return this.masterGain.gain.value;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the global volume of your experience (sets on the master gain).\r\n     * @param newVolume Defines the new global volume of the application\r\n     */\r\n    public setGlobalVolume(newVolume: number): void {\r\n        if (this.canUseWebAudio && this._audioContextInitialized) {\r\n            this.masterGain.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the audio engine to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        if (this.canUseWebAudio && this._audioContextInitialized && this._audioContext) {\r\n            this._connectedAnalyser = analyser;\r\n            this.masterGain.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}