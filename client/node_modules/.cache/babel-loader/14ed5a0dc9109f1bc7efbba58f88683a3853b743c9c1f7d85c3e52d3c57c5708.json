{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { Tools } from \"../../Misc/tools.js\";\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nfunction createDecoderAsync(wasmBinary) {\n  return new Promise(resolve => {\n    DracoDecoderModule({\n      wasmBinary: wasmBinary\n    }).then(module => {\n      resolve({\n        module: module\n      });\n    });\n  });\n}\nfunction decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData, dividers) {\n  const buffer = new decoderModule.DecoderBuffer();\n  buffer.Init(dataView, dataView.byteLength);\n  const decoder = new decoderModule.Decoder();\n  let geometry;\n  let status;\n  try {\n    const type = decoder.GetEncodedGeometryType(buffer);\n    switch (type) {\n      case decoderModule.TRIANGULAR_MESH:\n        geometry = new decoderModule.Mesh();\n        status = decoder.DecodeBufferToMesh(buffer, geometry);\n        break;\n      case decoderModule.POINT_CLOUD:\n        geometry = new decoderModule.PointCloud();\n        status = decoder.DecodeBufferToPointCloud(buffer, geometry);\n        break;\n      default:\n        throw new Error(`Invalid geometry type ${type}`);\n    }\n    if (!status.ok() || !geometry.ptr) {\n      throw new Error(status.error_msg());\n    }\n    if (type === decoderModule.TRIANGULAR_MESH) {\n      const numFaces = geometry.num_faces();\n      const numIndices = numFaces * 3;\n      const byteLength = numIndices * 4;\n      const ptr = decoderModule._malloc(byteLength);\n      try {\n        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\n        const indices = new Uint32Array(numIndices);\n        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\n        onIndicesData(indices);\n      } finally {\n        decoderModule._free(ptr);\n      }\n    }\n    const processAttribute = (kind, attribute, divider = 1) => {\n      const numComponents = attribute.num_components();\n      const numPoints = geometry.num_points();\n      const numValues = numPoints * numComponents;\n      const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\n      const ptr = decoderModule._malloc(byteLength);\n      try {\n        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\n        const values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\n        if (kind === \"color\" && numComponents === 3) {\n          const babylonData = new Float32Array(numPoints * 4);\n          for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\n            babylonData[i + 0] = values[j + 0];\n            babylonData[i + 1] = values[j + 1];\n            babylonData[i + 2] = values[j + 2];\n            babylonData[i + 3] = 1;\n          }\n          onAttributeData(kind, babylonData);\n        } else {\n          const babylonData = new Float32Array(numValues);\n          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\n          if (divider !== 1) {\n            for (let i = 0; i < babylonData.length; i++) {\n              babylonData[i] = babylonData[i] / divider;\n            }\n          }\n          onAttributeData(kind, babylonData);\n        }\n      } finally {\n        decoderModule._free(ptr);\n      }\n    };\n    if (attributes) {\n      for (const kind in attributes) {\n        const id = attributes[kind];\n        const attribute = decoder.GetAttributeByUniqueId(geometry, id);\n        const divider = dividers && dividers[kind] || 1;\n        processAttribute(kind, attribute, divider);\n      }\n    } else {\n      const nativeAttributeTypes = {\n        position: \"POSITION\",\n        normal: \"NORMAL\",\n        color: \"COLOR\",\n        uv: \"TEX_COORD\"\n      };\n      for (const kind in nativeAttributeTypes) {\n        const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\n        if (id !== -1) {\n          const attribute = decoder.GetAttribute(geometry, id);\n          processAttribute(kind, attribute);\n        }\n      }\n    }\n  } finally {\n    if (geometry) {\n      decoderModule.destroy(geometry);\n    }\n    decoderModule.destroy(decoder);\n    decoderModule.destroy(buffer);\n  }\n}\n/**\n * The worker function that gets converted to a blob url to pass into a worker.\n */\nfunction worker() {\n  let decoderPromise;\n  onmessage = event => {\n    const data = event.data;\n    switch (data.id) {\n      case \"init\":\n        {\n          const decoder = data.decoder;\n          if (decoder.url) {\n            importScripts(decoder.url);\n            decoderPromise = DracoDecoderModule({\n              wasmBinary: decoder.wasmBinary\n            });\n          }\n          postMessage(\"done\");\n          break;\n        }\n      case \"decodeMesh\":\n        {\n          if (!decoderPromise) {\n            throw new Error(\"Draco decoder module is not available\");\n          }\n          decoderPromise.then(decoder => {\n            decodeMesh(decoder, data.dataView, data.attributes, indices => {\n              postMessage({\n                id: \"indices\",\n                value: indices\n              }, [indices.buffer]);\n            }, (kind, data) => {\n              postMessage({\n                id: kind,\n                value: data\n              }, [data.buffer]);\n            });\n            postMessage(\"done\");\n          });\n          break;\n        }\n    }\n  };\n}\n/**\n * Draco compression (https://google.github.io/draco/)\n *\n * This class wraps the Draco module.\n *\n * **Encoder**\n *\n * The encoder is not currently implemented.\n *\n * **Decoder**\n *\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\n *\n * To update the configuration, use the following code:\n * ```javascript\n *     DracoCompression.Configuration = {\n *         decoder: {\n *             wasmUrl: \"<url to the WebAssembly library>\",\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\n *         }\n *     };\n * ```\n *\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\n *\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\n * ```javascript\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\n * ```\n *\n * @see https://playground.babylonjs.com/#DMZIBD#0\n */\nexport class DracoCompression {\n  /**\n   * Constructor\n   * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\n   */\n  constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\n    const decoder = DracoCompression.Configuration.decoder;\n    const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" ? {\n      url: Tools.GetAbsoluteUrl(decoder.wasmUrl),\n      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl))\n    } : {\n      url: Tools.GetAbsoluteUrl(decoder.fallbackUrl),\n      wasmBinaryPromise: Promise.resolve(undefined)\n    };\n    if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\n      this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then(decoderWasmBinary => {\n        const workerContent = `${decodeMesh}(${worker})()`;\n        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], {\n          type: \"application/javascript\"\n        }));\n        return new AutoReleaseWorkerPool(numWorkers, () => {\n          return new Promise((resolve, reject) => {\n            const worker = new Worker(workerBlobUrl);\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n            };\n            const onMessage = message => {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(worker);\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            worker.postMessage({\n              id: \"init\",\n              decoder: {\n                url: decoderInfo.url,\n                wasmBinary: decoderWasmBinary\n              }\n            });\n          });\n        });\n      });\n    } else {\n      this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(decoderWasmBinary => {\n        if (!decoderInfo.url) {\n          throw new Error(\"Draco decoder module is not available\");\n        }\n        return Tools.LoadScriptAsync(decoderInfo.url).then(() => {\n          return createDecoderAsync(decoderWasmBinary);\n        });\n      });\n    }\n  }\n  /**\n   * Returns true if the decoder configuration is available.\n   */\n  static get DecoderAvailable() {\n    const decoder = DracoCompression.Configuration.decoder;\n    return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\" || decoder.fallbackUrl);\n  }\n  static GetDefaultNumWorkers() {\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\n      return 1;\n    }\n    // Use 50% of the available logical processors but capped at 4.\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\n  }\n  /**\n   * Default instance for the draco compression object.\n   */\n  static get Default() {\n    if (!DracoCompression._Default) {\n      DracoCompression._Default = new DracoCompression();\n    }\n    return DracoCompression._Default;\n  }\n  /**\n   * Stop all async operations and release resources.\n   */\n  dispose() {\n    if (this._workerPoolPromise) {\n      this._workerPoolPromise.then(workerPool => {\n        workerPool.dispose();\n      });\n    }\n    delete this._workerPoolPromise;\n    delete this._decoderModulePromise;\n  }\n  /**\n   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\n   * @returns a promise that resolves when ready\n   */\n  whenReadyAsync() {\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(() => {});\n    }\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(() => {});\n    }\n    return Promise.resolve();\n  }\n  /**\n   * Decode Draco compressed mesh data to vertex data.\n   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\n   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\n   * @param dividers a list of optional dividers for normalization\n   * @returns A promise that resolves with the decoded vertex data\n   */\n  decodeMeshAsync(data, attributes, dividers) {\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n    if (this._workerPoolPromise) {\n      return this._workerPoolPromise.then(workerPool => {\n        return new Promise((resolve, reject) => {\n          workerPool.push((worker, onComplete) => {\n            const vertexData = new VertexData();\n            const onError = error => {\n              worker.removeEventListener(\"error\", onError);\n              worker.removeEventListener(\"message\", onMessage);\n              reject(error);\n              onComplete();\n            };\n            const onMessage = message => {\n              if (message.data === \"done\") {\n                worker.removeEventListener(\"error\", onError);\n                worker.removeEventListener(\"message\", onMessage);\n                resolve(vertexData);\n                onComplete();\n              } else if (message.data.id === \"indices\") {\n                vertexData.indices = message.data.value;\n              } else {\n                // check normalization\n                const divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;\n                if (divider !== 1) {\n                  // normalize\n                  for (let i = 0; i < message.data.value.length; i++) {\n                    message.data.value[i] = message.data.value[i] / divider;\n                  }\n                }\n                vertexData.set(message.data.value, message.data.id);\n              }\n            };\n            worker.addEventListener(\"error\", onError);\n            worker.addEventListener(\"message\", onMessage);\n            const dataViewCopy = new Uint8Array(dataView.byteLength);\n            dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n            worker.postMessage({\n              id: \"decodeMesh\",\n              dataView: dataViewCopy,\n              attributes: attributes\n            }, [dataViewCopy.buffer]);\n          });\n        });\n      });\n    }\n    if (this._decoderModulePromise) {\n      return this._decoderModulePromise.then(decoder => {\n        const vertexData = new VertexData();\n        decodeMesh(decoder.module, dataView, attributes, indices => {\n          vertexData.indices = indices;\n        }, (kind, data) => {\n          vertexData.set(data, kind);\n        }, dividers);\n        return vertexData;\n      });\n    }\n    throw new Error(\"Draco decoder module is not available\");\n  }\n}\n/**\n * The configuration. Defaults to the following urls:\n * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\n * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\n * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n */\nDracoCompression.Configuration = {\n  decoder: {\n    wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\n    wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\n    fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\n  }\n};\n/**\n * Default number of workers to create when creating the draco compression object.\n */\nDracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\nDracoCompression._Default = null;","map":{"version":3,"mappings":"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","names":["Tools","AutoReleaseWorkerPool","VertexData","createDecoderAsync","wasmBinary","Promise","resolve","DracoDecoderModule","then","module","decodeMesh","decoderModule","dataView","attributes","onIndicesData","onAttributeData","dividers","buffer","DecoderBuffer","Init","byteLength","decoder","Decoder","geometry","status","type","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","error_msg","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","indices","Uint32Array","set","HEAPF32","_free","processAttribute","kind","attribute","divider","numComponents","num_components","numPoints","num_points","numValues","Float32Array","BYTES_PER_ELEMENT","GetAttributeDataArrayForAllPoints","DT_FLOAT32","values","babylonData","i","j","length","id","GetAttributeByUniqueId","nativeAttributeTypes","position","normal","color","uv","GetAttributeId","GetAttribute","destroy","worker","decoderPromise","onmessage","event","data","url","importScripts","postMessage","value","DracoCompression","constructor","numWorkers","DefaultNumWorkers","Configuration","decoderInfo","wasmUrl","wasmBinaryUrl","WebAssembly","GetAbsoluteUrl","wasmBinaryPromise","LoadFileAsync","fallbackUrl","undefined","Worker","URL","_workerPoolPromise","decoderWasmBinary","workerContent","workerBlobUrl","createObjectURL","Blob","reject","onError","error","removeEventListener","onMessage","message","addEventListener","_decoderModulePromise","LoadScriptAsync","DecoderAvailable","GetDefaultNumWorkers","navigator","hardwareConcurrency","Math","min","floor","Default","_Default","dispose","workerPool","whenReadyAsync","decodeMeshAsync","ArrayBuffer","Uint8Array","push","onComplete","vertexData","dataViewCopy","byteOffset"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Compression/dracoCompression.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\n\r\ndeclare let DracoDecoderModule: any;\r\ndeclare let WebAssembly: any;\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction createDecoderAsync(wasmBinary?: ArrayBuffer): Promise<any> {\r\n    return new Promise((resolve) => {\r\n        DracoDecoderModule({ wasmBinary: wasmBinary }).then((module: any) => {\r\n            resolve({ module: module });\r\n        });\r\n    });\r\n}\r\n\r\nfunction decodeMesh(\r\n    decoderModule: any,\r\n    dataView: ArrayBufferView,\r\n    attributes: { [kind: string]: number } | undefined,\r\n    onIndicesData: (data: Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: Float32Array) => void,\r\n    dividers?: { [kind: string]: number }\r\n): void {\r\n    const buffer = new decoderModule.DecoderBuffer();\r\n    buffer.Init(dataView, dataView.byteLength);\r\n\r\n    const decoder = new decoderModule.Decoder();\r\n    let geometry: any;\r\n    let status: any;\r\n\r\n    try {\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH:\r\n                geometry = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, geometry);\r\n                break;\r\n            case decoderModule.POINT_CLOUD:\r\n                geometry = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, geometry);\r\n                break;\r\n            default:\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n        }\r\n\r\n        if (!status.ok() || !geometry.ptr) {\r\n            throw new Error(status.error_msg());\r\n        }\r\n\r\n        if (type === decoderModule.TRIANGULAR_MESH) {\r\n            const numFaces = geometry.num_faces();\r\n            const numIndices = numFaces * 3;\r\n            const byteLength = numIndices * 4;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);\r\n                const indices = new Uint32Array(numIndices);\r\n                indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                onIndicesData(indices);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        }\r\n\r\n        const processAttribute = (kind: string, attribute: any, divider = 1) => {\r\n            const numComponents = attribute.num_components();\r\n            const numPoints = geometry.num_points();\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);\r\n                const values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);\r\n                if (kind === \"color\" && numComponents === 3) {\r\n                    const babylonData = new Float32Array(numPoints * 4);\r\n                    for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {\r\n                        babylonData[i + 0] = values[j + 0];\r\n                        babylonData[i + 1] = values[j + 1];\r\n                        babylonData[i + 2] = values[j + 2];\r\n                        babylonData[i + 3] = 1;\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                } else {\r\n                    const babylonData = new Float32Array(numValues);\r\n                    babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));\r\n                    if (divider !== 1) {\r\n                        for (let i = 0; i < babylonData.length; i++) {\r\n                            babylonData[i] = babylonData[i] / divider;\r\n                        }\r\n                    }\r\n                    onAttributeData(kind, babylonData);\r\n                }\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributes) {\r\n            for (const kind in attributes) {\r\n                const id = attributes[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                const divider = (dividers && dividers[kind]) || 1;\r\n                processAttribute(kind, attribute, divider);\r\n            }\r\n        } else {\r\n            const nativeAttributeTypes: { [kind: string]: string } = {\r\n                position: \"POSITION\",\r\n                normal: \"NORMAL\",\r\n                color: \"COLOR\",\r\n                uv: \"TEX_COORD\",\r\n            };\r\n\r\n            for (const kind in nativeAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(kind, attribute);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        decoderModule.destroy(decoder);\r\n        decoderModule.destroy(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction worker(): void {\r\n    let decoderPromise: PromiseLike<any> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const data = event.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                const decoder = data.decoder;\r\n                if (decoder.url) {\r\n                    importScripts(decoder.url);\r\n                    decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });\r\n                }\r\n                postMessage(\"done\");\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                decoderPromise.then((decoder) => {\r\n                    decodeMesh(\r\n                        decoder,\r\n                        data.dataView,\r\n                        data.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", value: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data) => {\r\n                            postMessage({ id: kind, value: data }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage(\"done\");\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for Draco compression\r\n */\r\nexport interface IDracoCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the WebAssembly module.\r\n         */\r\n        wasmUrl?: string;\r\n\r\n        /**\r\n         * The url to the WebAssembly binary.\r\n         */\r\n        wasmBinaryUrl?: string;\r\n\r\n        /**\r\n         * The url to the fallback JavaScript module.\r\n         */\r\n        fallbackUrl?: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Draco compression (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco module.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the babylon.js preview cdn https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoCompression.Configuration = {\r\n *         decoder: {\r\n *             wasmUrl: \"<url to the WebAssembly library>\",\r\n *             wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *             fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *         }\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoCompression.DecoderAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoCompression object and call decodeMeshAsync:\r\n * ```javascript\r\n *     var vertexData = await DracoCompression.Default.decodeMeshAsync(data);\r\n * ```\r\n *\r\n * @see https://playground.babylonjs.com/#DMZIBD#0\r\n */\r\nexport class DracoCompression implements IDisposable {\r\n    private _workerPoolPromise?: Promise<AutoReleaseWorkerPool>;\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following urls:\r\n     * - wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\"\r\n     * - wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\"\r\n     * - fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\"\r\n     */\r\n    public static Configuration: IDracoCompressionConfiguration = {\r\n        decoder: {\r\n            wasmUrl: \"https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js\",\r\n            wasmBinaryUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.wasm\",\r\n            fallbackUrl: \"https://preview.babylonjs.com/draco_decoder_gltf.js\",\r\n        },\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder configuration is available.\r\n     */\r\n    public static get DecoderAvailable(): boolean {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n        return !!((decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\") || decoder.fallbackUrl);\r\n    }\r\n\r\n    /**\r\n     * Default number of workers to create when creating the draco compression object.\r\n     */\r\n    public static DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();\r\n\r\n    private static GetDefaultNumWorkers(): number {\r\n        if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n            return 1;\r\n        }\r\n\r\n        // Use 50% of the available logical processors but capped at 4.\r\n        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n    }\r\n\r\n    private static _Default: Nullable<DracoCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the draco compression object.\r\n     */\r\n    public static get Default(): DracoCompression {\r\n        if (!DracoCompression._Default) {\r\n            DracoCompression._Default = new DracoCompression();\r\n        }\r\n\r\n        return DracoCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     * @param numWorkers The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    constructor(numWorkers = DracoCompression.DefaultNumWorkers) {\r\n        const decoder = DracoCompression.Configuration.decoder;\r\n\r\n        const decoderInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | string | undefined> } =\r\n            decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: Tools.GetAbsoluteUrl(decoder.wasmUrl),\r\n                      wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl)),\r\n                  }\r\n                : {\r\n                      url: Tools.GetAbsoluteUrl(decoder.fallbackUrl!),\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n\r\n        if (numWorkers && typeof Worker === \"function\" && typeof URL === \"function\") {\r\n            this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                const workerContent = `${decodeMesh}(${worker})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                return new AutoReleaseWorkerPool(numWorkers, () => {\r\n                    return new Promise((resolve, reject) => {\r\n                        const worker = new Worker(workerBlobUrl);\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(worker);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        worker.postMessage({\r\n                            id: \"init\",\r\n                            decoder: {\r\n                                url: decoderInfo.url,\r\n                                wasmBinary: decoderWasmBinary,\r\n                            },\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        } else {\r\n            this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {\r\n                if (!decoderInfo.url) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n\r\n                return Tools.LoadScriptAsync(decoderInfo.url).then(() => {\r\n                    return createDecoderAsync(decoderWasmBinary as ArrayBuffer);\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then(() => {});\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then(() => {});\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to vertex data.\r\n     * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param dividers a list of optional dividers for normalization\r\n     * @returns A promise that resolves with the decoded vertex data\r\n     */\r\n    public decodeMeshAsync(data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }, dividers?: { [kind: string]: number }): Promise<VertexData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n        if (this._workerPoolPromise) {\r\n            return this._workerPoolPromise.then((workerPool) => {\r\n                return new Promise<VertexData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        const vertexData = new VertexData();\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (message: MessageEvent) => {\r\n                            if (message.data === \"done\") {\r\n                                worker.removeEventListener(\"error\", onError);\r\n                                worker.removeEventListener(\"message\", onMessage);\r\n                                resolve(vertexData);\r\n                                onComplete();\r\n                            } else if (message.data.id === \"indices\") {\r\n                                vertexData.indices = message.data.value;\r\n                            } else {\r\n                                // check normalization\r\n                                const divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;\r\n                                if (divider !== 1) {\r\n                                    // normalize\r\n                                    for (let i = 0; i < message.data.value.length; i++) {\r\n                                        message.data.value[i] = message.data.value[i] / divider;\r\n                                    }\r\n                                }\r\n                                vertexData.set(message.data.value, message.data.id);\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                        dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._decoderModulePromise) {\r\n            return this._decoderModulePromise.then((decoder) => {\r\n                const vertexData = new VertexData();\r\n                decodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        vertexData.indices = indices;\r\n                    },\r\n                    (kind, data) => {\r\n                        vertexData.set(data, kind);\r\n                    },\r\n                    dividers\r\n                );\r\n                return vertexData;\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}