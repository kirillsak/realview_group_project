{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Color4, Color3 } from \"../Maths/math.js\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n/** Defines the 4 color options */\nexport var PointColor;\n(function (PointColor) {\n  /** color value */\n  PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n  /** uv value */\n  PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n  /** random value */\n  PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n  /** stated value */\n  PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\nexport class PointsCloudSystem {\n  /**\n   * Creates a PCS (Points Cloud System) object\n   * @param name (String) is the PCS name, this will be the underlying mesh name\n   * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n   * @param scene (Scene) is the scene in which the PCS is added\n   * @param options defines the options of the PCS e.g.\n   * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n   * @param options.updatable\n   */\n  constructor(name, pointSize, scene, options) {\n    /**\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n     *  Example : var p = SPS.particles[i];\n     */\n    this.particles = new Array();\n    /**\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n     */\n    this.nbParticles = 0;\n    /**\n     * This a counter for your own usage. It's not set by any SPS functions.\n     */\n    this.counter = 0;\n    /**\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n     * Please read :\n     */\n    this.vars = {};\n    this._promises = [];\n    this._positions = new Array();\n    this._indices = new Array();\n    this._normals = new Array();\n    this._colors = new Array();\n    this._uvs = new Array();\n    this._updatable = true;\n    this._isVisibilityBoxLocked = false;\n    this._alwaysVisible = false;\n    this._groups = new Array(); //start indices for each group of particles\n    this._groupCounter = 0;\n    this._computeParticleColor = true;\n    this._computeParticleTexture = true;\n    this._computeParticleRotation = true;\n    this._computeBoundingBox = false;\n    this._isReady = false;\n    this.name = name;\n    this._size = pointSize;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (options && options.updatable !== undefined) {\n      this._updatable = options.updatable;\n    } else {\n      this._updatable = true;\n    }\n  }\n  /**\n   * Gets the particle positions computed by the Point Cloud System\n   */\n  get positions() {\n    return this._positions32;\n  }\n  /**\n   * Gets the particle colors computed by the Point Cloud System\n   */\n  get colors() {\n    return this._colors32;\n  }\n  /**\n   * Gets the particle uvs computed by the Point Cloud System\n   */\n  get uvs() {\n    return this._uvs32;\n  }\n  /**\n   * Builds the PCS underlying mesh. Returns a standard Mesh.\n   * If no points were added to the PCS, the returned mesh is just a single point.\n   * @param material The material to use to render the mesh. If not provided, will create a default one\n   * @returns a promise for the created mesh\n   */\n  buildMeshAsync(material) {\n    return Promise.all(this._promises).then(() => {\n      this._isReady = true;\n      return this._buildMesh(material);\n    });\n  }\n  /**\n   * @internal\n   */\n  _buildMesh(material) {\n    if (this.nbParticles === 0) {\n      this.addPoints(1);\n    }\n    this._positions32 = new Float32Array(this._positions);\n    this._uvs32 = new Float32Array(this._uvs);\n    this._colors32 = new Float32Array(this._colors);\n    const vertexData = new VertexData();\n    vertexData.set(this._positions32, VertexBuffer.PositionKind);\n    if (this._uvs32.length > 0) {\n      vertexData.set(this._uvs32, VertexBuffer.UVKind);\n    }\n    let ec = 0; //emissive color value 0 for UVs, 1 for color\n    if (this._colors32.length > 0) {\n      ec = 1;\n      vertexData.set(this._colors32, VertexBuffer.ColorKind);\n    }\n    const mesh = new Mesh(this.name, this._scene);\n    vertexData.applyToMesh(mesh, this._updatable);\n    this.mesh = mesh;\n    // free memory\n    this._positions = null;\n    this._uvs = null;\n    this._colors = null;\n    if (!this._updatable) {\n      this.particles.length = 0;\n    }\n    let mat = material;\n    if (!mat) {\n      mat = new StandardMaterial(\"point cloud material\", this._scene);\n      mat.emissiveColor = new Color3(ec, ec, ec);\n      mat.disableLighting = true;\n      mat.pointsCloud = true;\n      mat.pointSize = this._size;\n    }\n    mesh.material = mat;\n    return new Promise(resolve => resolve(mesh));\n  }\n  // adds a new particle object in the particles array\n  _addParticle(idx, group, groupId, idxInGroup) {\n    const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n    this.particles.push(cp);\n    return cp;\n  }\n  _randomUnitVector(particle) {\n    particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n    particle.color = new Color4(1, 1, 1, 1);\n  }\n  _getColorIndicesForCoord(pointsGroup, x, y, width) {\n    const imageData = pointsGroup._groupImageData;\n    const color = y * (width * 4) + x * 4;\n    const colorIndices = [color, color + 1, color + 2, color + 3];\n    const redIndex = colorIndices[0];\n    const greenIndex = colorIndices[1];\n    const blueIndex = colorIndices[2];\n    const alphaIndex = colorIndices[3];\n    const redForCoord = imageData[redIndex];\n    const greenForCoord = imageData[greenIndex];\n    const blueForCoord = imageData[blueIndex];\n    const alphaForCoord = imageData[alphaIndex];\n    return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n  }\n  _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range) {\n    if (isVolume) {\n      mesh.updateFacetData();\n    }\n    const boundInfo = mesh.getBoundingInfo();\n    const diameter = 2 * boundInfo.boundingSphere.radius;\n    let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    const meshUV = mesh.getVerticesData(VertexBuffer.UVKind);\n    const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const place = Vector3.Zero();\n    mesh.computeWorldMatrix();\n    const meshMatrix = mesh.getWorldMatrix();\n    if (!meshMatrix.isIdentity()) {\n      meshPos = meshPos.slice(0);\n      for (let p = 0; p < meshPos.length / 3; p++) {\n        Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n        meshPos[3 * p] = place.x;\n        meshPos[3 * p + 1] = place.y;\n        meshPos[3 * p + 2] = place.z;\n      }\n    }\n    let idxPoints = 0;\n    let id0 = 0;\n    let id1 = 0;\n    let id2 = 0;\n    let v0X = 0;\n    let v0Y = 0;\n    let v0Z = 0;\n    let v1X = 0;\n    let v1Y = 0;\n    let v1Z = 0;\n    let v2X = 0;\n    let v2Y = 0;\n    let v2Z = 0;\n    const vertex0 = Vector3.Zero();\n    const vertex1 = Vector3.Zero();\n    const vertex2 = Vector3.Zero();\n    const vec0 = Vector3.Zero();\n    const vec1 = Vector3.Zero();\n    let uv0X = 0;\n    let uv0Y = 0;\n    let uv1X = 0;\n    let uv1Y = 0;\n    let uv2X = 0;\n    let uv2Y = 0;\n    const uv0 = Vector2.Zero();\n    const uv1 = Vector2.Zero();\n    const uv2 = Vector2.Zero();\n    const uvec0 = Vector2.Zero();\n    const uvec1 = Vector2.Zero();\n    let col0X = 0;\n    let col0Y = 0;\n    let col0Z = 0;\n    let col0A = 0;\n    let col1X = 0;\n    let col1Y = 0;\n    let col1Z = 0;\n    let col1A = 0;\n    let col2X = 0;\n    let col2Y = 0;\n    let col2Z = 0;\n    let col2A = 0;\n    const col0 = Vector4.Zero();\n    const col1 = Vector4.Zero();\n    const col2 = Vector4.Zero();\n    const colvec0 = Vector4.Zero();\n    const colvec1 = Vector4.Zero();\n    let lamda = 0;\n    let mu = 0;\n    range = range ? range : 0;\n    let facetPoint;\n    let uvPoint;\n    let colPoint = new Vector4(0, 0, 0, 0);\n    let norm = Vector3.Zero();\n    let tang = Vector3.Zero();\n    let biNorm = Vector3.Zero();\n    let angle = 0;\n    let facetPlaneVec = Vector3.Zero();\n    let gap = 0;\n    let distance = 0;\n    const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n    let pickInfo;\n    let direction = Vector3.Zero();\n    for (let index = 0; index < meshInd.length / 3; index++) {\n      id0 = meshInd[3 * index];\n      id1 = meshInd[3 * index + 1];\n      id2 = meshInd[3 * index + 2];\n      v0X = meshPos[3 * id0];\n      v0Y = meshPos[3 * id0 + 1];\n      v0Z = meshPos[3 * id0 + 2];\n      v1X = meshPos[3 * id1];\n      v1Y = meshPos[3 * id1 + 1];\n      v1Z = meshPos[3 * id1 + 2];\n      v2X = meshPos[3 * id2];\n      v2Y = meshPos[3 * id2 + 1];\n      v2Z = meshPos[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      if (meshUV) {\n        uv0X = meshUV[2 * id0];\n        uv0Y = meshUV[2 * id0 + 1];\n        uv1X = meshUV[2 * id1];\n        uv1Y = meshUV[2 * id1 + 1];\n        uv2X = meshUV[2 * id2];\n        uv2Y = meshUV[2 * id2 + 1];\n        uv0.set(uv0X, uv0Y);\n        uv1.set(uv1X, uv1Y);\n        uv2.set(uv2X, uv2Y);\n        uv1.subtractToRef(uv0, uvec0);\n        uv2.subtractToRef(uv1, uvec1);\n      }\n      if (meshCol && colorFromTexture) {\n        col0X = meshCol[4 * id0];\n        col0Y = meshCol[4 * id0 + 1];\n        col0Z = meshCol[4 * id0 + 2];\n        col0A = meshCol[4 * id0 + 3];\n        col1X = meshCol[4 * id1];\n        col1Y = meshCol[4 * id1 + 1];\n        col1Z = meshCol[4 * id1 + 2];\n        col1A = meshCol[4 * id1 + 3];\n        col2X = meshCol[4 * id2];\n        col2Y = meshCol[4 * id2 + 1];\n        col2Z = meshCol[4 * id2 + 2];\n        col2A = meshCol[4 * id2 + 3];\n        col0.set(col0X, col0Y, col0Z, col0A);\n        col1.set(col1X, col1Y, col1Z, col1A);\n        col2.set(col2X, col2Y, col2Z, col2A);\n        col1.subtractToRef(col0, colvec0);\n        col2.subtractToRef(col1, colvec1);\n      }\n      let width;\n      let height;\n      let deltaS;\n      let deltaV;\n      let h;\n      let s;\n      let v;\n      let hsvCol;\n      const statedColor = new Color3(0, 0, 0);\n      const colPoint3 = new Color3(0, 0, 0);\n      let pointColors;\n      let particle;\n      for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\n        idxPoints = this.particles.length;\n        this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n        particle = this.particles[idxPoints];\n        //form a point inside the facet v0, v1, v2;\n        lamda = Scalar.RandomRange(0, 1);\n        mu = Scalar.RandomRange(0, 1);\n        facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n        if (isVolume) {\n          norm = mesh.getFacetNormal(index).normalize().scale(-1);\n          tang = vec0.clone().normalize();\n          biNorm = Vector3.Cross(norm, tang);\n          angle = Scalar.RandomRange(0, 2 * Math.PI);\n          facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n          angle = Scalar.RandomRange(0.1, Math.PI / 2);\n          direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n          ray.origin = facetPoint.add(direction.scale(0.00001));\n          ray.direction = direction;\n          ray.length = diameter;\n          pickInfo = ray.intersectsMesh(mesh);\n          if (pickInfo.hit) {\n            distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n            gap = Scalar.RandomRange(0, 1) * distance;\n            facetPoint.addInPlace(direction.scale(gap));\n          }\n        }\n        particle.position = facetPoint.clone();\n        this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n        if (colorFromTexture !== undefined) {\n          if (meshUV) {\n            uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n            if (colorFromTexture) {\n              //Set particle color to texture color\n              if (hasTexture && pointsGroup._groupImageData !== null) {\n                width = pointsGroup._groupImgWidth;\n                height = pointsGroup._groupImgHeight;\n                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                particle.color = pointColors;\n                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n              } else {\n                if (meshCol) {\n                  //failure in texture and colors available\n                  colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                } else {\n                  colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                  particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                  this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n              }\n            } else {\n              //Set particle uv based on a mesh uv\n              particle.uv = uvPoint.clone();\n              this._uvs.push(particle.uv.x, particle.uv.y);\n            }\n          }\n        } else {\n          if (color) {\n            statedColor.set(color.r, color.g, color.b);\n            deltaS = Scalar.RandomRange(-range, range);\n            deltaV = Scalar.RandomRange(-range, range);\n            hsvCol = statedColor.toHSV();\n            h = hsvCol.r;\n            s = hsvCol.g + deltaS;\n            v = hsvCol.b + deltaV;\n            if (s < 0) {\n              s = 0;\n            }\n            if (s > 1) {\n              s = 1;\n            }\n            if (v < 0) {\n              v = 0;\n            }\n            if (v > 1) {\n              v = 1;\n            }\n            Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n            colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n          } else {\n            colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n          }\n          particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n          this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n        }\n      }\n    }\n  }\n  // stores mesh texture in dynamic texture for color pixel retrieval\n  // when pointColor type is color for surface points\n  _colorFromTexture(mesh, pointsGroup, isVolume) {\n    if (mesh.material === null) {\n      Logger.Warn(mesh.name + \"has no material.\");\n      pointsGroup._groupImageData = null;\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n      return;\n    }\n    const mat = mesh.material;\n    const textureList = mat.getActiveTextures();\n    if (textureList.length === 0) {\n      Logger.Warn(mesh.name + \"has no usable texture.\");\n      pointsGroup._groupImageData = null;\n      this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n      return;\n    }\n    const clone = mesh.clone();\n    clone.setEnabled(false);\n    this._promises.push(new Promise(resolve => {\n      BaseTexture.WhenAllReady(textureList, () => {\n        let n = pointsGroup._textureNb;\n        if (n < 0) {\n          n = 0;\n        }\n        if (n > textureList.length - 1) {\n          n = textureList.length - 1;\n        }\n        const finalize = () => {\n          pointsGroup._groupImgWidth = textureList[n].getSize().width;\n          pointsGroup._groupImgHeight = textureList[n].getSize().height;\n          this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\n          clone.dispose();\n          resolve();\n        };\n        pointsGroup._groupImageData = null;\n        const dataPromise = textureList[n].readPixels();\n        if (!dataPromise) {\n          finalize();\n        } else {\n          dataPromise.then(data => {\n            pointsGroup._groupImageData = data;\n            finalize();\n          });\n        }\n      });\n    }));\n  }\n  // calculates the point density per facet of a mesh for surface points\n  _calculateDensity(nbPoints, positions, indices) {\n    let density = new Array();\n    let id0;\n    let id1;\n    let id2;\n    let v0X;\n    let v0Y;\n    let v0Z;\n    let v1X;\n    let v1Y;\n    let v1Z;\n    let v2X;\n    let v2Y;\n    let v2Z;\n    const vertex0 = Vector3.Zero();\n    const vertex1 = Vector3.Zero();\n    const vertex2 = Vector3.Zero();\n    const vec0 = Vector3.Zero();\n    const vec1 = Vector3.Zero();\n    const vec2 = Vector3.Zero();\n    let a; //length of side of triangle\n    let b; //length of side of triangle\n    let c; //length of side of triangle\n    let p; //perimeter of triangle\n    let area;\n    const areas = new Array();\n    let surfaceArea = 0;\n    const nbFacets = indices.length / 3;\n    //surface area\n    for (let index = 0; index < nbFacets; index++) {\n      id0 = indices[3 * index];\n      id1 = indices[3 * index + 1];\n      id2 = indices[3 * index + 2];\n      v0X = positions[3 * id0];\n      v0Y = positions[3 * id0 + 1];\n      v0Z = positions[3 * id0 + 2];\n      v1X = positions[3 * id1];\n      v1Y = positions[3 * id1 + 1];\n      v1Z = positions[3 * id1 + 2];\n      v2X = positions[3 * id2];\n      v2Y = positions[3 * id2 + 1];\n      v2Z = positions[3 * id2 + 2];\n      vertex0.set(v0X, v0Y, v0Z);\n      vertex1.set(v1X, v1Y, v1Z);\n      vertex2.set(v2X, v2Y, v2Z);\n      vertex1.subtractToRef(vertex0, vec0);\n      vertex2.subtractToRef(vertex1, vec1);\n      vertex2.subtractToRef(vertex0, vec2);\n      a = vec0.length();\n      b = vec1.length();\n      c = vec2.length();\n      p = (a + b + c) / 2;\n      area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\n      surfaceArea += area;\n      areas[index] = area;\n    }\n    let pointCount = 0;\n    for (let index = 0; index < nbFacets; index++) {\n      density[index] = Math.floor(nbPoints * areas[index] / surfaceArea);\n      pointCount += density[index];\n    }\n    const diff = nbPoints - pointCount;\n    const pointsPerFacet = Math.floor(diff / nbFacets);\n    const extraPoints = diff % nbFacets;\n    if (pointsPerFacet > 0) {\n      density = density.map(x => x + pointsPerFacet);\n    }\n    for (let index = 0; index < extraPoints; index++) {\n      density[index] += 1;\n    }\n    return density;\n  }\n  /**\n   * Adds points to the PCS in random positions within a unit sphere\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n   * @returns the number of groups in the system\n   */\n  addPoints(nb, pointFunction = this._randomUnitVector) {\n    const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n    let cp;\n    // particles\n    let idx = this.nbParticles;\n    for (let i = 0; i < nb; i++) {\n      cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n      if (pointsGroup && pointsGroup._positionFunction) {\n        pointsGroup._positionFunction(cp, idx, i);\n      }\n      this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n      if (cp.color) {\n        this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n      }\n      if (cp.uv) {\n        this._uvs.push(cp.uv.x, cp.uv.y);\n      }\n      idx++;\n    }\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter;\n  }\n  /**\n   * Adds points to the PCS from the surface of the model shape\n   * @param mesh is any Mesh object that will be used as a surface model for the points\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n   * @returns the number of groups in the system\n   */\n  addSurfacePoints(mesh, nb, colorWith, color, range) {\n    let colored = colorWith ? colorWith : PointColor.Random;\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    this._groups.push(this._groupCounter);\n    const pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, false);\n        break;\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n        break;\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, false);\n        break;\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n        break;\n    }\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  }\n  /**\n   * Adds points to the PCS inside the model shape\n   * @param mesh is any Mesh object that will be used as a surface model for the points\n   * @param nb (positive integer) the number of particles to be created from this model\n   * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n   * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n   * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n   * @returns the number of groups in the system\n   */\n  addVolumePoints(mesh, nb, colorWith, color, range) {\n    let colored = colorWith ? colorWith : PointColor.Random;\n    if (isNaN(colored) || colored < 0 || colored > 3) {\n      colored = PointColor.Random;\n    }\n    const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const meshInd = mesh.getIndices();\n    this._groups.push(this._groupCounter);\n    const pointsGroup = new PointsGroup(this._groupCounter, null);\n    pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n    if (colored === PointColor.Color) {\n      pointsGroup._textureNb = color ? color : 0;\n    } else {\n      color = color ? color : new Color4(1, 1, 1, 1);\n    }\n    switch (colored) {\n      case PointColor.Color:\n        this._colorFromTexture(mesh, pointsGroup, true);\n        break;\n      case PointColor.UV:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n        break;\n      case PointColor.Random:\n        this._setPointsColorOrUV(mesh, pointsGroup, true);\n        break;\n      case PointColor.Stated:\n        this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n        break;\n    }\n    this.nbParticles += nb;\n    this._groupCounter++;\n    return this._groupCounter - 1;\n  }\n  /**\n   *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n   *  This method calls `updateParticle()` for each particle of the SPS.\n   *  For an animated SPS, it is usually called within the render loop.\n   * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n   * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n   * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n   * @returns the PCS.\n   */\n  setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n    var _a, _b;\n    if (!this._updatable || !this._isReady) {\n      return this;\n    }\n    // custom beforeUpdate\n    this.beforeUpdateParticles(start, end, update);\n    const rotMatrix = TmpVectors.Matrix[0];\n    const mesh = this.mesh;\n    const colors32 = this._colors32;\n    const positions32 = this._positions32;\n    const uvs32 = this._uvs32;\n    const tempVectors = TmpVectors.Vector3;\n    const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n    const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n    const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n    const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n    const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n    Matrix.IdentityToRef(rotMatrix);\n    let idx = 0; // current index of the particle\n    if ((_a = this.mesh) === null || _a === void 0 ? void 0 : _a.isFacetDataEnabled) {\n      this._computeBoundingBox = true;\n    }\n    end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n    if (this._computeBoundingBox) {\n      if (start != 0 || end != this.nbParticles - 1) {\n        // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n        const boundingInfo = (_b = this.mesh) === null || _b === void 0 ? void 0 : _b.getBoundingInfo();\n        if (boundingInfo) {\n          minimum.copyFrom(boundingInfo.minimum);\n          maximum.copyFrom(boundingInfo.maximum);\n        }\n      }\n    }\n    idx = 0; // particle index\n    let pindex = 0; //index in positions array\n    let cindex = 0; //index in color array\n    let uindex = 0; //index in uv array\n    // particle loop\n    for (let p = start; p <= end; p++) {\n      const particle = this.particles[p];\n      idx = particle.idx;\n      pindex = 3 * idx;\n      cindex = 4 * idx;\n      uindex = 2 * idx;\n      // call to custom user function to update the particle properties\n      this.updateParticle(particle);\n      const particleRotationMatrix = particle._rotationMatrix;\n      const particlePosition = particle.position;\n      const particleGlobalPosition = particle._globalPosition;\n      if (this._computeParticleRotation) {\n        particle.getRotationMatrix(rotMatrix);\n      }\n      const particleHasParent = particle.parentId !== null;\n      if (particleHasParent) {\n        const parent = this.particles[particle.parentId];\n        const parentRotationMatrix = parent._rotationMatrix;\n        const parentGlobalPosition = parent._globalPosition;\n        const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n        const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n        const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n        particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n        particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n        particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n        if (this._computeParticleRotation) {\n          const rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n          particleRotationMatrix[1] = rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n          particleRotationMatrix[2] = rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n          particleRotationMatrix[3] = rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n          particleRotationMatrix[4] = rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n          particleRotationMatrix[5] = rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n          particleRotationMatrix[6] = rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n          particleRotationMatrix[7] = rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n          particleRotationMatrix[8] = rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n        }\n      } else {\n        particleGlobalPosition.x = 0;\n        particleGlobalPosition.y = 0;\n        particleGlobalPosition.z = 0;\n        if (this._computeParticleRotation) {\n          const rotMatrixValues = rotMatrix.m;\n          particleRotationMatrix[0] = rotMatrixValues[0];\n          particleRotationMatrix[1] = rotMatrixValues[1];\n          particleRotationMatrix[2] = rotMatrixValues[2];\n          particleRotationMatrix[3] = rotMatrixValues[4];\n          particleRotationMatrix[4] = rotMatrixValues[5];\n          particleRotationMatrix[5] = rotMatrixValues[6];\n          particleRotationMatrix[6] = rotMatrixValues[8];\n          particleRotationMatrix[7] = rotMatrixValues[9];\n          particleRotationMatrix[8] = rotMatrixValues[10];\n        }\n      }\n      const pivotBackTranslation = tempVectors[11];\n      if (particle.translateFromPivot) {\n        pivotBackTranslation.setAll(0.0);\n      } else {\n        pivotBackTranslation.copyFrom(particle.pivot);\n      }\n      // positions\n      const tmpVertex = tempVectors[0];\n      tmpVertex.copyFrom(particle.position);\n      const vertexX = tmpVertex.x - particle.pivot.x;\n      const vertexY = tmpVertex.y - particle.pivot.y;\n      const vertexZ = tmpVertex.z - particle.pivot.z;\n      let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n      let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n      let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n      rotatedX += pivotBackTranslation.x;\n      rotatedY += pivotBackTranslation.y;\n      rotatedZ += pivotBackTranslation.z;\n      const px = positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ;\n      const py = positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ;\n      const pz = positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ;\n      if (this._computeBoundingBox) {\n        minimum.minimizeInPlaceFromFloats(px, py, pz);\n        maximum.maximizeInPlaceFromFloats(px, py, pz);\n      }\n      if (this._computeParticleColor && particle.color) {\n        const color = particle.color;\n        const colors32 = this._colors32;\n        colors32[cindex] = color.r;\n        colors32[cindex + 1] = color.g;\n        colors32[cindex + 2] = color.b;\n        colors32[cindex + 3] = color.a;\n      }\n      if (this._computeParticleTexture && particle.uv) {\n        const uv = particle.uv;\n        const uvs32 = this._uvs32;\n        uvs32[uindex] = uv.x;\n        uvs32[uindex + 1] = uv.y;\n      }\n    }\n    // if the VBO must be updated\n    if (mesh) {\n      if (update) {\n        if (this._computeParticleColor) {\n          mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n        }\n        if (this._computeParticleTexture) {\n          mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n        }\n        mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n      }\n      if (this._computeBoundingBox) {\n        if (mesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n        } else {\n          mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n        }\n      }\n    }\n    this.afterUpdateParticles(start, end, update);\n    return this;\n  }\n  /**\n   * Disposes the PCS.\n   */\n  dispose() {\n    var _a;\n    (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.dispose();\n    this.vars = null;\n    // drop references to internal big arrays for the GC\n    this._positions = null;\n    this._indices = null;\n    this._normals = null;\n    this._uvs = null;\n    this._colors = null;\n    this._indices32 = null;\n    this._positions32 = null;\n    this._uvs32 = null;\n    this._colors32 = null;\n  }\n  /**\n   * Visibility helper : Recomputes the visible size according to the mesh bounding box\n   * doc :\n   * @returns the PCS.\n   */\n  refreshVisibleSize() {\n    var _a;\n    if (!this._isVisibilityBoxLocked) {\n      (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.refreshBoundingInfo();\n    }\n    return this;\n  }\n  /**\n   * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n   * @param size the size (float) of the visibility box\n   * note : this doesn't lock the PCS mesh bounding box.\n   * doc :\n   */\n  setVisibilityBox(size) {\n    if (!this.mesh) {\n      return;\n    }\n    const vis = size / 2;\n    this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n  }\n  /**\n   * Gets whether the PCS is always visible or not\n   * doc :\n   */\n  get isAlwaysVisible() {\n    return this._alwaysVisible;\n  }\n  /**\n   * Sets the PCS as always visible or not\n   * doc :\n   */\n  set isAlwaysVisible(val) {\n    if (!this.mesh) {\n      return;\n    }\n    this._alwaysVisible = val;\n    this.mesh.alwaysSelectAsActiveMesh = val;\n  }\n  /**\n   * Tells to `setParticles()` to compute the particle rotations or not\n   * Default value : false. The PCS is faster when it's set to false\n   * Note : particle rotations are only applied to parent particles\n   * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n   */\n  set computeParticleRotation(val) {\n    this._computeParticleRotation = val;\n  }\n  /**\n   * Tells to `setParticles()` to compute the particle colors or not.\n   * Default value : true. The PCS is faster when it's set to false.\n   * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n   */\n  set computeParticleColor(val) {\n    this._computeParticleColor = val;\n  }\n  set computeParticleTexture(val) {\n    this._computeParticleTexture = val;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle colors or not.\n   * Default value : false. The PCS is faster when it's set to false.\n   * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n   */\n  get computeParticleColor() {\n    return this._computeParticleColor;\n  }\n  /**\n   * Gets if `setParticles()` computes the particle textures or not.\n   * Default value : false. The PCS is faster when it's set to false.\n   * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n   */\n  get computeParticleTexture() {\n    return this._computeParticleTexture;\n  }\n  /**\n   * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n   */\n  set computeBoundingBox(val) {\n    this._computeBoundingBox = val;\n  }\n  /**\n   * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n   */\n  get computeBoundingBox() {\n    return this._computeBoundingBox;\n  }\n  // =======================================================================\n  // Particle behavior logic\n  // these following methods may be overwritten by users to fit their needs\n  /**\n   * This function does nothing. It may be overwritten to set all the particle first values.\n   * The PCS doesn't call this function, you may have to call it by your own.\n   * doc :\n   */\n  initParticles() {}\n  /**\n   * This function does nothing. It may be overwritten to recycle a particle\n   * The PCS doesn't call this function, you can to call it\n   * doc :\n   * @param particle The particle to recycle\n   * @returns the recycled particle\n   */\n  recycleParticle(particle) {\n    return particle;\n  }\n  /**\n   * Updates a particle : this function should  be overwritten by the user.\n   * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n   * doc :\n   * @example : just set a particle position or velocity and recycle conditions\n   * @param particle The particle to update\n   * @returns the updated particle\n   */\n  updateParticle(particle) {\n    return particle;\n  }\n  /**\n   * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  beforeUpdateParticles(start, stop, update) {}\n  /**\n   * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n   * This will be passed three parameters.\n   * This does nothing and may be overwritten by the user.\n   * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n   * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n   * @param update the boolean update value actually passed to setParticles()\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  afterUpdateParticles(start, stop, update) {}\n}","map":{"version":3,"mappings":";AACA,SAASA,MAAM,EAAEC,MAAM,QAAQ,kBAAgB;AAC/C,SAASC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAEC,UAAU,EAAEC,MAAM,QAAQ,yBAAuB;AACrF,SAASC,MAAM,QAAQ,mBAAiB;AACxC,SAASC,YAAY,QAAQ,sBAAoB;AACjD,SAASC,UAAU,QAAQ,8BAA4B;AACvD,SAASC,IAAI,QAAQ,mBAAiB;AACtC,SAASC,WAAW,QAAQ,2BAAyB;AAErD,SAASC,UAAU,EAAEC,WAAW,QAAQ,iBAAe;AACvD,SAASC,GAAG,QAAQ,mBAAiB;AAErC,SAASC,gBAAgB,QAAQ,kCAAgC;AACjE,SAASC,WAAW,QAAQ,wCAAsC;AAClE,SAASC,MAAM,QAAQ,yBAAuB;AAG9C;AACA,WAAYC,UASX;AATD,WAAYA,UAAU;EAClB;EACAA,6CAAS;EACT;EACAA,uCAAM;EACN;EACAA,+CAAU;EACV;EACAA,+CAAU;AACd,CAAC,EATWA,UAAU,KAAVA,UAAU;AAWtB;;;;;;;;;AASA,OAAM,MAAOC,iBAAiB;EA2E1B;;;;;;;;;EASAC,YAAYC,IAAY,EAAEC,SAAiB,EAAEC,KAAY,EAAEC,OAAiC;IAnF5F;;;;IAIO,cAAS,GAAiB,IAAIC,KAAK,EAAc;IACxD;;;IAGO,gBAAW,GAAW,CAAC;IAC9B;;;IAGO,YAAO,GAAW,CAAC;IAS1B;;;;IAIO,SAAI,GAAQ,EAAE;IAOb,cAAS,GAAwB,EAAE;IACnC,eAAU,GAAa,IAAIA,KAAK,EAAU;IAC1C,aAAQ,GAAa,IAAIA,KAAK,EAAU;IACxC,aAAQ,GAAa,IAAIA,KAAK,EAAU;IACxC,YAAO,GAAa,IAAIA,KAAK,EAAU;IACvC,SAAI,GAAa,IAAIA,KAAK,EAAU;IAKpC,eAAU,GAAY,IAAI;IAC1B,2BAAsB,GAAG,KAAK;IAC9B,mBAAc,GAAY,KAAK;IAC/B,YAAO,GAAa,IAAIA,KAAK,EAAU,CAAC,CAAC;IACzC,kBAAa,GAAW,CAAC;IACzB,0BAAqB,GAAY,IAAI;IACrC,4BAAuB,GAAY,IAAI;IACvC,6BAAwB,GAAY,IAAI;IACxC,wBAAmB,GAAY,KAAK;IACpC,aAAQ,GAAY,KAAK;IAiC7B,IAAI,CAACJ,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACK,KAAK,GAAGJ,SAAS;IACtB,IAAI,CAACK,MAAM,GAAGJ,KAAK,IAAIZ,WAAW,CAACiB,gBAAgB;IACnD,IAAIJ,OAAO,IAAIA,OAAO,CAACK,SAAS,KAAKC,SAAS,EAAE;MAC5C,IAAI,CAACC,UAAU,GAAGP,OAAO,CAACK,SAAS;KACtC,MAAM;MACH,IAAI,CAACE,UAAU,GAAG,IAAI;;EAE9B;EAvCA;;;EAGA,IAAWC,SAAS;IAChB,OAAO,IAAI,CAACC,YAAY;EAC5B;EAEA;;;EAGA,IAAWC,MAAM;IACb,OAAO,IAAI,CAACC,SAAS;EACzB;EAEA;;;EAGA,IAAWC,GAAG;IACV,OAAO,IAAI,CAACC,MAAM;EACtB;EAsBA;;;;;;EAMOC,cAAc,CAACC,QAAmB;IACrC,OAAOC,OAAO,CAACC,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC,CAACC,IAAI,CAAC,MAAK;MACzC,IAAI,CAACC,QAAQ,GAAG,IAAI;MACpB,OAAO,IAAI,CAACC,UAAU,CAACN,QAAQ,CAAC;IACpC,CAAC,CAAC;EACN;EAEA;;;EAGQM,UAAU,CAACN,QAAmB;IAClC,IAAI,IAAI,CAACO,WAAW,KAAK,CAAC,EAAE;MACxB,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC;;IAGrB,IAAI,CAACd,YAAY,GAAG,IAAIe,YAAY,CAAC,IAAI,CAACC,UAAU,CAAC;IACrD,IAAI,CAACZ,MAAM,GAAG,IAAIW,YAAY,CAAC,IAAI,CAACE,IAAI,CAAC;IACzC,IAAI,CAACf,SAAS,GAAG,IAAIa,YAAY,CAAC,IAAI,CAACG,OAAO,CAAC;IAE/C,MAAMC,UAAU,GAAG,IAAI3C,UAAU,EAAE;IACnC2C,UAAU,CAACC,GAAG,CAAC,IAAI,CAACpB,YAAY,EAAEzB,YAAY,CAAC8C,YAAY,CAAC;IAE5D,IAAI,IAAI,CAACjB,MAAM,CAACkB,MAAM,GAAG,CAAC,EAAE;MACxBH,UAAU,CAACC,GAAG,CAAC,IAAI,CAAChB,MAAM,EAAE7B,YAAY,CAACgD,MAAM,CAAC;;IAEpD,IAAIC,EAAE,GAAG,CAAC,CAAC,CAAC;IACZ,IAAI,IAAI,CAACtB,SAAS,CAACoB,MAAM,GAAG,CAAC,EAAE;MAC3BE,EAAE,GAAG,CAAC;MACNL,UAAU,CAACC,GAAG,CAAC,IAAI,CAAClB,SAAS,EAAE3B,YAAY,CAACkD,SAAS,CAAC;;IAE1D,MAAMC,IAAI,GAAG,IAAIjD,IAAI,CAAC,IAAI,CAACW,IAAI,EAAE,IAAI,CAACM,MAAM,CAAC;IAC7CyB,UAAU,CAACQ,WAAW,CAACD,IAAI,EAAE,IAAI,CAAC5B,UAAU,CAAC;IAC7C,IAAI,CAAC4B,IAAI,GAAGA,IAAI;IAEhB;IACM,IAAI,CAACV,UAAW,GAAG,IAAI;IACvB,IAAI,CAACC,IAAK,GAAG,IAAI;IACjB,IAAI,CAACC,OAAQ,GAAG,IAAI;IAE1B,IAAI,CAAC,IAAI,CAACpB,UAAU,EAAE;MAClB,IAAI,CAAC8B,SAAS,CAACN,MAAM,GAAG,CAAC;;IAG7B,IAAIO,GAAG,GAAGvB,QAAQ;IAElB,IAAI,CAACuB,GAAG,EAAE;MACNA,GAAG,GAAG,IAAI/C,gBAAgB,CAAC,sBAAsB,EAAE,IAAI,CAACY,MAAM,CAAC;MAC5CmC,GAAI,CAACC,aAAa,GAAG,IAAI9D,MAAM,CAACwD,EAAE,EAAEA,EAAE,EAAEA,EAAE,CAAC;MAC3CK,GAAI,CAACE,eAAe,GAAG,IAAI;MAC3BF,GAAI,CAACG,WAAW,GAAG,IAAI;MACvBH,GAAI,CAACxC,SAAS,GAAG,IAAI,CAACI,KAAK;;IAElDiC,IAAI,CAACpB,QAAQ,GAAGuB,GAAG;IAEnB,OAAO,IAAItB,OAAO,CAAE0B,OAAO,IAAKA,OAAO,CAACP,IAAI,CAAC,CAAC;EAClD;EAEA;EACQQ,YAAY,CAACC,GAAW,EAAEC,KAAkB,EAAEC,OAAe,EAAEC,UAAkB;IACrF,MAAMC,EAAE,GAAG,IAAI5D,UAAU,CAACwD,GAAG,EAAEC,KAAK,EAAEC,OAAO,EAAEC,UAAU,EAAE,IAAI,CAAC;IAChE,IAAI,CAACV,SAAS,CAACY,IAAI,CAACD,EAAE,CAAC;IACvB,OAAOA,EAAE;EACb;EAEQE,iBAAiB,CAACC,QAAoB;IAC1CA,QAAQ,CAACC,QAAQ,GAAG,IAAIzE,OAAO,CAAC0E,IAAI,CAACC,MAAM,EAAE,EAAED,IAAI,CAACC,MAAM,EAAE,EAAED,IAAI,CAACC,MAAM,EAAE,CAAC;IAC5EH,QAAQ,CAACI,KAAK,GAAG,IAAI/E,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC3C;EAEQgF,wBAAwB,CAACC,WAAwB,EAAEC,CAAS,EAAEC,CAAS,EAAEC,KAAa;IAC1F,MAAMC,SAAS,GAAeJ,WAAW,CAACK,eAAe;IACzD,MAAMP,KAAK,GAAGI,CAAC,IAAIC,KAAK,GAAG,CAAC,CAAC,GAAGF,CAAC,GAAG,CAAC;IACrC,MAAMK,YAAY,GAAG,CAACR,KAAK,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,CAAC,CAAC;IAC7D,MAAMS,QAAQ,GAAGD,YAAY,CAAC,CAAC,CAAC;IAChC,MAAME,UAAU,GAAGF,YAAY,CAAC,CAAC,CAAC;IAClC,MAAMG,SAAS,GAAGH,YAAY,CAAC,CAAC,CAAC;IACjC,MAAMI,UAAU,GAAGJ,YAAY,CAAC,CAAC,CAAC;IAClC,MAAMK,WAAW,GAAGP,SAAS,CAACG,QAAQ,CAAC;IACvC,MAAMK,aAAa,GAAGR,SAAS,CAACI,UAAU,CAAC;IAC3C,MAAMK,YAAY,GAAGT,SAAS,CAACK,SAAS,CAAC;IACzC,MAAMK,aAAa,GAAGV,SAAS,CAACM,UAAU,CAAC;IAC3C,OAAO,IAAI3F,MAAM,CAAC4F,WAAW,GAAG,GAAG,EAAEC,aAAa,GAAG,GAAG,EAAEC,YAAY,GAAG,GAAG,EAAEC,aAAa,CAAC;EAChG;EAEQC,mBAAmB,CAACrC,IAAU,EAAEsB,WAAwB,EAAEgB,QAAiB,EAAEC,gBAA0B,EAAEC,UAAoB,EAAEpB,KAAc,EAAEqB,KAAc;IACjK,IAAIH,QAAQ,EAAE;MACVtC,IAAI,CAAC0C,eAAe,EAAE;;IAG1B,MAAMC,SAAS,GAAG3C,IAAI,CAAC4C,eAAe,EAAE;IACxC,MAAMC,QAAQ,GAAG,CAAC,GAAGF,SAAS,CAACG,cAAc,CAACC,MAAM;IAEpD,IAAIC,OAAO,GAAehD,IAAI,CAACiD,eAAe,CAACpG,YAAY,CAAC8C,YAAY,CAAC;IACzE,MAAMuD,OAAO,GAAiBlD,IAAI,CAACmD,UAAU,EAAE;IAC/C,MAAMC,MAAM,GAAepD,IAAI,CAACiD,eAAe,CAACpG,YAAY,CAACgD,MAAM,CAAC;IACpE,MAAMwD,OAAO,GAAerD,IAAI,CAACiD,eAAe,CAACpG,YAAY,CAACkD,SAAS,CAAC;IAExE,MAAMuD,KAAK,GAAG9G,OAAO,CAAC+G,IAAI,EAAE;IAC5BvD,IAAI,CAACwD,kBAAkB,EAAE;IACzB,MAAMC,UAAU,GAAWzD,IAAI,CAAC0D,cAAc,EAAE;IAChD,IAAI,CAACD,UAAU,CAACE,UAAU,EAAE,EAAE;MAC1BX,OAAO,GAAGA,OAAO,CAACY,KAAK,CAAC,CAAC,CAAC;MAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,OAAO,CAACpD,MAAM,GAAG,CAAC,EAAEiE,CAAC,EAAE,EAAE;QACzCrH,OAAO,CAACsH,mCAAmC,CAACd,OAAO,CAAC,CAAC,GAAGa,CAAC,CAAC,EAAEb,OAAO,CAAC,CAAC,GAAGa,CAAC,GAAG,CAAC,CAAC,EAAEb,OAAO,CAAC,CAAC,GAAGa,CAAC,GAAG,CAAC,CAAC,EAAEJ,UAAU,EAAEH,KAAK,CAAC;QACtHN,OAAO,CAAC,CAAC,GAAGa,CAAC,CAAC,GAAGP,KAAK,CAAC/B,CAAC;QACxByB,OAAO,CAAC,CAAC,GAAGa,CAAC,GAAG,CAAC,CAAC,GAAGP,KAAK,CAAC9B,CAAC;QAC5BwB,OAAO,CAAC,CAAC,GAAGa,CAAC,GAAG,CAAC,CAAC,GAAGP,KAAK,CAACS,CAAC;;;IAIpC,IAAIC,SAAS,GAAW,CAAC;IAEzB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,IAAIC,GAAG,GAAW,CAAC;IACnB,MAAMC,OAAO,GAAGrI,OAAO,CAAC+G,IAAI,EAAE;IAC9B,MAAMuB,OAAO,GAAGtI,OAAO,CAAC+G,IAAI,EAAE;IAC9B,MAAMwB,OAAO,GAAGvI,OAAO,CAAC+G,IAAI,EAAE;IAC9B,MAAMyB,IAAI,GAAGxI,OAAO,CAAC+G,IAAI,EAAE;IAC3B,MAAM0B,IAAI,GAAGzI,OAAO,CAAC+G,IAAI,EAAE;IAE3B,IAAI2B,IAAI,GAAW,CAAC;IACpB,IAAIC,IAAI,GAAW,CAAC;IACpB,IAAIC,IAAI,GAAW,CAAC;IACpB,IAAIC,IAAI,GAAW,CAAC;IACpB,IAAIC,IAAI,GAAW,CAAC;IACpB,IAAIC,IAAI,GAAW,CAAC;IACpB,MAAMC,GAAG,GAAGjJ,OAAO,CAACgH,IAAI,EAAE;IAC1B,MAAMkC,GAAG,GAAGlJ,OAAO,CAACgH,IAAI,EAAE;IAC1B,MAAMmC,GAAG,GAAGnJ,OAAO,CAACgH,IAAI,EAAE;IAC1B,MAAMoC,KAAK,GAAGpJ,OAAO,CAACgH,IAAI,EAAE;IAC5B,MAAMqC,KAAK,GAAGrJ,OAAO,CAACgH,IAAI,EAAE;IAE5B,IAAIsC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,IAAIC,KAAK,GAAW,CAAC;IACrB,MAAMC,IAAI,GAAGhK,OAAO,CAAC8G,IAAI,EAAE;IAC3B,MAAMmD,IAAI,GAAGjK,OAAO,CAAC8G,IAAI,EAAE;IAC3B,MAAMoD,IAAI,GAAGlK,OAAO,CAAC8G,IAAI,EAAE;IAC3B,MAAMqD,OAAO,GAAGnK,OAAO,CAAC8G,IAAI,EAAE;IAC9B,MAAMsD,OAAO,GAAGpK,OAAO,CAAC8G,IAAI,EAAE;IAE9B,IAAIuD,KAAK,GAAW,CAAC;IACrB,IAAIC,EAAE,GAAW,CAAC;IAClBtE,KAAK,GAAGA,KAAK,GAAGA,KAAK,GAAG,CAAC;IAEzB,IAAIuE,UAAmB;IACvB,IAAIC,OAAgB;IACpB,IAAIC,QAAQ,GAAY,IAAIzK,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAE/C,IAAI0K,IAAI,GAAG3K,OAAO,CAAC+G,IAAI,EAAE;IACzB,IAAI6D,IAAI,GAAG5K,OAAO,CAAC+G,IAAI,EAAE;IACzB,IAAI8D,MAAM,GAAG7K,OAAO,CAAC+G,IAAI,EAAE;IAC3B,IAAI+D,KAAK,GAAG,CAAC;IACb,IAAIC,aAAa,GAAG/K,OAAO,CAAC+G,IAAI,EAAE;IAElC,IAAIiE,GAAG,GAAG,CAAC;IACX,IAAIC,QAAQ,GAAG,CAAC;IAChB,MAAMC,GAAG,GAAG,IAAIvK,GAAG,CAACX,OAAO,CAAC+G,IAAI,EAAE,EAAE,IAAI/G,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACzD,IAAImL,QAAqB;IACzB,IAAIC,SAAS,GAAGpL,OAAO,CAAC+G,IAAI,EAAE;IAE9B,KAAK,IAAIsE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG3E,OAAO,CAACtD,MAAM,GAAG,CAAC,EAAEiI,KAAK,EAAE,EAAE;MACrD5D,GAAG,GAAGf,OAAO,CAAC,CAAC,GAAG2E,KAAK,CAAC;MACxB3D,GAAG,GAAGhB,OAAO,CAAC,CAAC,GAAG2E,KAAK,GAAG,CAAC,CAAC;MAC5B1D,GAAG,GAAGjB,OAAO,CAAC,CAAC,GAAG2E,KAAK,GAAG,CAAC,CAAC;MAC5BzD,GAAG,GAAGpB,OAAO,CAAC,CAAC,GAAGiB,GAAG,CAAC;MACtBI,GAAG,GAAGrB,OAAO,CAAC,CAAC,GAAGiB,GAAG,GAAG,CAAC,CAAC;MAC1BK,GAAG,GAAGtB,OAAO,CAAC,CAAC,GAAGiB,GAAG,GAAG,CAAC,CAAC;MAC1BM,GAAG,GAAGvB,OAAO,CAAC,CAAC,GAAGkB,GAAG,CAAC;MACtBM,GAAG,GAAGxB,OAAO,CAAC,CAAC,GAAGkB,GAAG,GAAG,CAAC,CAAC;MAC1BO,GAAG,GAAGzB,OAAO,CAAC,CAAC,GAAGkB,GAAG,GAAG,CAAC,CAAC;MAC1BQ,GAAG,GAAG1B,OAAO,CAAC,CAAC,GAAGmB,GAAG,CAAC;MACtBQ,GAAG,GAAG3B,OAAO,CAAC,CAAC,GAAGmB,GAAG,GAAG,CAAC,CAAC;MAC1BS,GAAG,GAAG5B,OAAO,CAAC,CAAC,GAAGmB,GAAG,GAAG,CAAC,CAAC;MAC1BU,OAAO,CAACnF,GAAG,CAAC0E,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;MAC1BQ,OAAO,CAACpF,GAAG,CAAC6E,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;MAC1BM,OAAO,CAACrF,GAAG,CAACgF,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;MAC1BE,OAAO,CAACgD,aAAa,CAACjD,OAAO,EAAEG,IAAI,CAAC;MACpCD,OAAO,CAAC+C,aAAa,CAAChD,OAAO,EAAEG,IAAI,CAAC;MAEpC,IAAI7B,MAAM,EAAE;QACR8B,IAAI,GAAG9B,MAAM,CAAC,CAAC,GAAGa,GAAG,CAAC;QACtBkB,IAAI,GAAG/B,MAAM,CAAC,CAAC,GAAGa,GAAG,GAAG,CAAC,CAAC;QAC1BmB,IAAI,GAAGhC,MAAM,CAAC,CAAC,GAAGc,GAAG,CAAC;QACtBmB,IAAI,GAAGjC,MAAM,CAAC,CAAC,GAAGc,GAAG,GAAG,CAAC,CAAC;QAC1BoB,IAAI,GAAGlC,MAAM,CAAC,CAAC,GAAGe,GAAG,CAAC;QACtBoB,IAAI,GAAGnC,MAAM,CAAC,CAAC,GAAGe,GAAG,GAAG,CAAC,CAAC;QAC1BqB,GAAG,CAAC9F,GAAG,CAACwF,IAAI,EAAEC,IAAI,CAAC;QACnBM,GAAG,CAAC/F,GAAG,CAAC0F,IAAI,EAAEC,IAAI,CAAC;QACnBK,GAAG,CAAChG,GAAG,CAAC4F,IAAI,EAAEC,IAAI,CAAC;QACnBE,GAAG,CAACqC,aAAa,CAACtC,GAAG,EAAEG,KAAK,CAAC;QAC7BD,GAAG,CAACoC,aAAa,CAACrC,GAAG,EAAEG,KAAK,CAAC;;MAGjC,IAAIvC,OAAO,IAAId,gBAAgB,EAAE;QAC7BsD,KAAK,GAAGxC,OAAO,CAAC,CAAC,GAAGY,GAAG,CAAC;QACxB6B,KAAK,GAAGzC,OAAO,CAAC,CAAC,GAAGY,GAAG,GAAG,CAAC,CAAC;QAC5B8B,KAAK,GAAG1C,OAAO,CAAC,CAAC,GAAGY,GAAG,GAAG,CAAC,CAAC;QAC5B+B,KAAK,GAAG3C,OAAO,CAAC,CAAC,GAAGY,GAAG,GAAG,CAAC,CAAC;QAC5BgC,KAAK,GAAG5C,OAAO,CAAC,CAAC,GAAGa,GAAG,CAAC;QACxBgC,KAAK,GAAG7C,OAAO,CAAC,CAAC,GAAGa,GAAG,GAAG,CAAC,CAAC;QAC5BiC,KAAK,GAAG9C,OAAO,CAAC,CAAC,GAAGa,GAAG,GAAG,CAAC,CAAC;QAC5BkC,KAAK,GAAG/C,OAAO,CAAC,CAAC,GAAGa,GAAG,GAAG,CAAC,CAAC;QAC5BmC,KAAK,GAAGhD,OAAO,CAAC,CAAC,GAAGc,GAAG,CAAC;QACxBmC,KAAK,GAAGjD,OAAO,CAAC,CAAC,GAAGc,GAAG,GAAG,CAAC,CAAC;QAC5BoC,KAAK,GAAGlD,OAAO,CAAC,CAAC,GAAGc,GAAG,GAAG,CAAC,CAAC;QAC5BqC,KAAK,GAAGnD,OAAO,CAAC,CAAC,GAAGc,GAAG,GAAG,CAAC,CAAC;QAC5BsC,IAAI,CAAC/G,GAAG,CAACmG,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC;QACpCU,IAAI,CAAChH,GAAG,CAACuG,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC;QACpCO,IAAI,CAACjH,GAAG,CAAC2G,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC;QACpCE,IAAI,CAACoB,aAAa,CAACrB,IAAI,EAAEG,OAAO,CAAC;QACjCD,IAAI,CAACmB,aAAa,CAACpB,IAAI,EAAEG,OAAO,CAAC;;MAGrC,IAAIpF,KAAa;MACjB,IAAIsG,MAAc;MAClB,IAAIC,MAAc;MAClB,IAAIC,MAAc;MAClB,IAAIC,CAAS;MACb,IAAIC,CAAS;MACb,IAAIC,CAAS;MACb,IAAIC,MAAc;MAClB,MAAMC,WAAW,GAAW,IAAIhM,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC/C,MAAMiM,SAAS,GAAW,IAAIjM,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAC7C,IAAIkM,WAAmB;MACvB,IAAIxH,QAAoB;MAExB,KAAK,IAAIyH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnH,WAAW,CAACoH,aAAa,CAACb,KAAK,CAAC,EAAEY,CAAC,EAAE,EAAE;QACvDzE,SAAS,GAAG,IAAI,CAAC9D,SAAS,CAACN,MAAM;QACjC,IAAI,CAACY,YAAY,CAACwD,SAAS,EAAE1C,WAAW,EAAE,IAAI,CAACqH,aAAa,EAAEd,KAAK,GAAGY,CAAC,CAAC;QACxEzH,QAAQ,GAAG,IAAI,CAACd,SAAS,CAAC8D,SAAS,CAAC;QACpC;QACA8C,KAAK,GAAGxJ,MAAM,CAACsL,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC;QAChC7B,EAAE,GAAGzJ,MAAM,CAACsL,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC;QAC7B5B,UAAU,GAAGnC,OAAO,CAACgE,GAAG,CAAC7D,IAAI,CAAC8D,KAAK,CAAChC,KAAK,CAAC,CAAC,CAAC+B,GAAG,CAAC5D,IAAI,CAAC6D,KAAK,CAAChC,KAAK,GAAGC,EAAE,CAAC,CAAC;QACvE,IAAIzE,QAAQ,EAAE;UACV6E,IAAI,GAAGnH,IAAI,CAAC+I,cAAc,CAAClB,KAAK,CAAC,CAACmB,SAAS,EAAE,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;UACvD1B,IAAI,GAAGpC,IAAI,CAACiE,KAAK,EAAE,CAACD,SAAS,EAAE;UAC/B3B,MAAM,GAAG7K,OAAO,CAAC0M,KAAK,CAAC/B,IAAI,EAAEC,IAAI,CAAC;UAClCE,KAAK,GAAGhK,MAAM,CAACsL,WAAW,CAAC,CAAC,EAAE,CAAC,GAAG1H,IAAI,CAACiI,EAAE,CAAC;UAC1C5B,aAAa,GAAGH,IAAI,CAAC0B,KAAK,CAAC5H,IAAI,CAACkI,GAAG,CAAC9B,KAAK,CAAC,CAAC,CAACuB,GAAG,CAACxB,MAAM,CAACyB,KAAK,CAAC5H,IAAI,CAACmI,GAAG,CAAC/B,KAAK,CAAC,CAAC,CAAC;UAC9EA,KAAK,GAAGhK,MAAM,CAACsL,WAAW,CAAC,GAAG,EAAE1H,IAAI,CAACiI,EAAE,GAAG,CAAC,CAAC;UAC5CvB,SAAS,GAAGL,aAAa,CAACuB,KAAK,CAAC5H,IAAI,CAACkI,GAAG,CAAC9B,KAAK,CAAC,CAAC,CAACuB,GAAG,CAAC1B,IAAI,CAAC2B,KAAK,CAAC5H,IAAI,CAACmI,GAAG,CAAC/B,KAAK,CAAC,CAAC,CAAC;UAEjFI,GAAG,CAAC4B,MAAM,GAAGtC,UAAU,CAAC6B,GAAG,CAACjB,SAAS,CAACkB,KAAK,CAAC,OAAO,CAAC,CAAC;UACrDpB,GAAG,CAACE,SAAS,GAAGA,SAAS;UACzBF,GAAG,CAAC9H,MAAM,GAAGiD,QAAQ;UACrB8E,QAAQ,GAAGD,GAAG,CAAC6B,cAAc,CAACvJ,IAAI,CAAC;UACnC,IAAI2H,QAAQ,CAAC6B,GAAG,EAAE;YACd/B,QAAQ,GAAGE,QAAQ,CAAC8B,WAAY,CAACC,QAAQ,CAAC1C,UAAU,CAAC,CAACpH,MAAM,EAAE;YAC9D4H,GAAG,GAAGlK,MAAM,CAACsL,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGnB,QAAQ;YACzCT,UAAU,CAAC2C,UAAU,CAAC/B,SAAS,CAACkB,KAAK,CAACtB,GAAG,CAAC,CAAC;;;QAGnDxG,QAAQ,CAACC,QAAQ,GAAG+F,UAAU,CAACiC,KAAK,EAAE;QACtC,IAAI,CAAC3J,UAAU,CAACwB,IAAI,CAACE,QAAQ,CAACC,QAAQ,CAACM,CAAC,EAAEP,QAAQ,CAACC,QAAQ,CAACO,CAAC,EAAER,QAAQ,CAACC,QAAQ,CAAC8C,CAAC,CAAC;QACnF,IAAIxB,gBAAgB,KAAKpE,SAAS,EAAE;UAChC,IAAIiF,MAAM,EAAE;YACR6D,OAAO,GAAGzB,GAAG,CAACqD,GAAG,CAAClD,KAAK,CAACmD,KAAK,CAAChC,KAAK,CAAC,CAAC,CAAC+B,GAAG,CAACjD,KAAK,CAACkD,KAAK,CAAChC,KAAK,GAAGC,EAAE,CAAC,CAAC;YAClE,IAAIxE,gBAAgB,EAAE;cAClB;cACA,IAAIC,UAAU,IAAIlB,WAAW,CAACK,eAAe,KAAK,IAAI,EAAE;gBACpDF,KAAK,GAAGH,WAAW,CAACsI,cAAc;gBAClC7B,MAAM,GAAGzG,WAAW,CAACuI,eAAe;gBACpCrB,WAAW,GAAG,IAAI,CAACnH,wBAAwB,CAACC,WAAW,EAAEJ,IAAI,CAAC4I,KAAK,CAAC7C,OAAO,CAAC1F,CAAC,GAAGE,KAAK,CAAC,EAAEP,IAAI,CAAC4I,KAAK,CAAC7C,OAAO,CAACzF,CAAC,GAAGuG,MAAM,CAAC,EAAEtG,KAAK,CAAC;gBAC9HT,QAAQ,CAACI,KAAK,GAAGoH,WAAW;gBAC5B,IAAI,CAAChJ,OAAO,CAACsB,IAAI,CAAC0H,WAAW,CAACuB,CAAC,EAAEvB,WAAW,CAACwB,CAAC,EAAExB,WAAW,CAACyB,CAAC,EAAEzB,WAAW,CAAC0B,CAAC,CAAC;eAChF,MAAM;gBACH,IAAI7G,OAAO,EAAE;kBACT;kBACA6D,QAAQ,GAAGT,IAAI,CAACoC,GAAG,CAACjC,OAAO,CAACkC,KAAK,CAAChC,KAAK,CAAC,CAAC,CAAC+B,GAAG,CAAChC,OAAO,CAACiC,KAAK,CAAChC,KAAK,GAAGC,EAAE,CAAC,CAAC;kBACxE/F,QAAQ,CAACI,KAAK,GAAG,IAAI/E,MAAM,CAAC6K,QAAQ,CAAC3F,CAAC,EAAE2F,QAAQ,CAAC1F,CAAC,EAAE0F,QAAQ,CAACnD,CAAC,EAAEmD,QAAQ,CAACiD,CAAC,CAAC;kBAC3E,IAAI,CAAC3K,OAAO,CAACsB,IAAI,CAACoG,QAAQ,CAAC3F,CAAC,EAAE2F,QAAQ,CAAC1F,CAAC,EAAE0F,QAAQ,CAACnD,CAAC,EAAEmD,QAAQ,CAACiD,CAAC,CAAC;iBACpE,MAAM;kBACHjD,QAAQ,GAAGT,IAAI,CAAC/G,GAAG,CAACwB,IAAI,CAACC,MAAM,EAAE,EAAED,IAAI,CAACC,MAAM,EAAE,EAAED,IAAI,CAACC,MAAM,EAAE,EAAE,CAAC,CAAC;kBACnEH,QAAQ,CAACI,KAAK,GAAG,IAAI/E,MAAM,CAAC6K,QAAQ,CAAC3F,CAAC,EAAE2F,QAAQ,CAAC1F,CAAC,EAAE0F,QAAQ,CAACnD,CAAC,EAAEmD,QAAQ,CAACiD,CAAC,CAAC;kBAC3E,IAAI,CAAC3K,OAAO,CAACsB,IAAI,CAACoG,QAAQ,CAAC3F,CAAC,EAAE2F,QAAQ,CAAC1F,CAAC,EAAE0F,QAAQ,CAACnD,CAAC,EAAEmD,QAAQ,CAACiD,CAAC,CAAC;;;aAG5E,MAAM;cACH;cACAnJ,QAAQ,CAACoJ,EAAE,GAAGnD,OAAO,CAACgC,KAAK,EAAE;cAC7B,IAAI,CAAC1J,IAAI,CAACuB,IAAI,CAACE,QAAQ,CAACoJ,EAAE,CAAC7I,CAAC,EAAEP,QAAQ,CAACoJ,EAAE,CAAC5I,CAAC,CAAC;;;SAGvD,MAAM;UACH,IAAIJ,KAAK,EAAE;YACPkH,WAAW,CAAC5I,GAAG,CAAC0B,KAAK,CAAC2I,CAAC,EAAE3I,KAAK,CAAC4I,CAAC,EAAE5I,KAAK,CAAC6I,CAAC,CAAC;YAC1CjC,MAAM,GAAG1K,MAAM,CAACsL,WAAW,CAAC,CAACnG,KAAK,EAAEA,KAAK,CAAC;YAC1CwF,MAAM,GAAG3K,MAAM,CAACsL,WAAW,CAAC,CAACnG,KAAK,EAAEA,KAAK,CAAC;YAC1C4F,MAAM,GAAGC,WAAW,CAAC+B,KAAK,EAAE;YAC5BnC,CAAC,GAAGG,MAAM,CAAC0B,CAAC;YACZ5B,CAAC,GAAGE,MAAM,CAAC2B,CAAC,GAAGhC,MAAM;YACrBI,CAAC,GAAGC,MAAM,CAAC4B,CAAC,GAAGhC,MAAM;YACrB,IAAIE,CAAC,GAAG,CAAC,EAAE;cACPA,CAAC,GAAG,CAAC;;YAET,IAAIA,CAAC,GAAG,CAAC,EAAE;cACPA,CAAC,GAAG,CAAC;;YAET,IAAIC,CAAC,GAAG,CAAC,EAAE;cACPA,CAAC,GAAG,CAAC;;YAET,IAAIA,CAAC,GAAG,CAAC,EAAE;cACPA,CAAC,GAAG,CAAC;;YAET9L,MAAM,CAACgO,aAAa,CAACpC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEG,SAAS,CAAC;YACxCrB,QAAQ,CAACxH,GAAG,CAAC6I,SAAS,CAACwB,CAAC,EAAExB,SAAS,CAACyB,CAAC,EAAEzB,SAAS,CAAC0B,CAAC,EAAE,CAAC,CAAC;WACzD,MAAM;YACH/C,QAAQ,GAAGT,IAAI,CAAC/G,GAAG,CAACwB,IAAI,CAACC,MAAM,EAAE,EAAED,IAAI,CAACC,MAAM,EAAE,EAAED,IAAI,CAACC,MAAM,EAAE,EAAE,CAAC,CAAC;;UAEvEH,QAAQ,CAACI,KAAK,GAAG,IAAI/E,MAAM,CAAC6K,QAAQ,CAAC3F,CAAC,EAAE2F,QAAQ,CAAC1F,CAAC,EAAE0F,QAAQ,CAACnD,CAAC,EAAEmD,QAAQ,CAACiD,CAAC,CAAC;UAC3E,IAAI,CAAC3K,OAAO,CAACsB,IAAI,CAACoG,QAAQ,CAAC3F,CAAC,EAAE2F,QAAQ,CAAC1F,CAAC,EAAE0F,QAAQ,CAACnD,CAAC,EAAEmD,QAAQ,CAACiD,CAAC,CAAC;;;;EAIjF;EAEA;EACA;EACQI,iBAAiB,CAACvK,IAAU,EAAEsB,WAAwB,EAAEgB,QAAiB;IAC7E,IAAItC,IAAI,CAACpB,QAAQ,KAAK,IAAI,EAAE;MACxBhC,MAAM,CAAC4N,IAAI,CAACxK,IAAI,CAACtC,IAAI,GAAG,kBAAkB,CAAC;MAC3C4D,WAAW,CAACK,eAAe,GAAG,IAAI;MAClC,IAAI,CAACU,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAEgB,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC;MAClE;;IAGJ,MAAMnC,GAAG,GAAGH,IAAI,CAACpB,QAAQ;IACzB,MAAM6L,WAAW,GAAkBtK,GAAG,CAACuK,iBAAiB,EAAE;IAC1D,IAAID,WAAW,CAAC7K,MAAM,KAAK,CAAC,EAAE;MAC1BhD,MAAM,CAAC4N,IAAI,CAACxK,IAAI,CAACtC,IAAI,GAAG,wBAAwB,CAAC;MACjD4D,WAAW,CAACK,eAAe,GAAG,IAAI;MAClC,IAAI,CAACU,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAEgB,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC;MAClE;;IAGJ,MAAM2G,KAAK,GAASjJ,IAAI,CAACiJ,KAAK,EAAE;IAChCA,KAAK,CAAC0B,UAAU,CAAC,KAAK,CAAC;IACvB,IAAI,CAAC5L,SAAS,CAAC+B,IAAI,CACf,IAAIjC,OAAO,CAAE0B,OAA0B,IAAI;MACvClD,WAAW,CAACuN,YAAY,CAACH,WAAW,EAAE,MAAK;QACvC,IAAII,CAAC,GAAGvJ,WAAW,CAACwJ,UAAU;QAC9B,IAAID,CAAC,GAAG,CAAC,EAAE;UACPA,CAAC,GAAG,CAAC;;QAET,IAAIA,CAAC,GAAGJ,WAAW,CAAC7K,MAAM,GAAG,CAAC,EAAE;UAC5BiL,CAAC,GAAGJ,WAAW,CAAC7K,MAAM,GAAG,CAAC;;QAE9B,MAAMmL,QAAQ,GAAG,MAAK;UAClBzJ,WAAW,CAACsI,cAAc,GAAGa,WAAW,CAACI,CAAC,CAAC,CAACG,OAAO,EAAE,CAACvJ,KAAK;UAC3DH,WAAW,CAACuI,eAAe,GAAGY,WAAW,CAACI,CAAC,CAAC,CAACG,OAAO,EAAE,CAACjD,MAAM;UAC7D,IAAI,CAAC1F,mBAAmB,CAAC4G,KAAK,EAAE3H,WAAW,EAAEgB,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC;UAClE2G,KAAK,CAACgC,OAAO,EAAE;UACf1K,OAAO,EAAE;QACb,CAAC;QACDe,WAAW,CAACK,eAAe,GAAG,IAAI;QAClC,MAAMuJ,WAAW,GAAGT,WAAW,CAACI,CAAC,CAAC,CAACM,UAAU,EAAE;QAC/C,IAAI,CAACD,WAAW,EAAE;UACdH,QAAQ,EAAE;SACb,MAAM;UACHG,WAAW,CAAClM,IAAI,CAAEoM,IAAI,IAAI;YACtB9J,WAAW,CAACK,eAAe,GAAGyJ,IAAI;YAClCL,QAAQ,EAAE;UACd,CAAC,CAAC;;MAEV,CAAC,CAAC;IACN,CAAC,CAAC,CACL;EACL;EAEA;EACQM,iBAAiB,CAACC,QAAgB,EAAEjN,SAAqB,EAAEkN,OAAqB;IACpF,IAAIC,OAAO,GAAa,IAAI1N,KAAK,EAAU;IAC3C,IAAImG,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,IAAIC,GAAW;IACf,MAAMC,OAAO,GAAGrI,OAAO,CAAC+G,IAAI,EAAE;IAC9B,MAAMuB,OAAO,GAAGtI,OAAO,CAAC+G,IAAI,EAAE;IAC9B,MAAMwB,OAAO,GAAGvI,OAAO,CAAC+G,IAAI,EAAE;IAC9B,MAAMyB,IAAI,GAAGxI,OAAO,CAAC+G,IAAI,EAAE;IAC3B,MAAM0B,IAAI,GAAGzI,OAAO,CAAC+G,IAAI,EAAE;IAC3B,MAAMkI,IAAI,GAAGjP,OAAO,CAAC+G,IAAI,EAAE;IAE3B,IAAI2G,CAAS,CAAC,CAAC;IACf,IAAID,CAAS,CAAC,CAAC;IACf,IAAIyB,CAAS,CAAC,CAAC;IACf,IAAI7H,CAAS,CAAC,CAAC;IACf,IAAI8H,IAAY;IAChB,MAAMC,KAAK,GAAa,IAAI9N,KAAK,EAAU;IAC3C,IAAI+N,WAAW,GAAW,CAAC;IAE3B,MAAMC,QAAQ,GAAGP,OAAO,CAAC3L,MAAM,GAAG,CAAC;IAEnC;IACA,KAAK,IAAIiI,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGiE,QAAQ,EAAEjE,KAAK,EAAE,EAAE;MAC3C5D,GAAG,GAAGsH,OAAO,CAAC,CAAC,GAAG1D,KAAK,CAAC;MACxB3D,GAAG,GAAGqH,OAAO,CAAC,CAAC,GAAG1D,KAAK,GAAG,CAAC,CAAC;MAC5B1D,GAAG,GAAGoH,OAAO,CAAC,CAAC,GAAG1D,KAAK,GAAG,CAAC,CAAC;MAC5BzD,GAAG,GAAG/F,SAAS,CAAC,CAAC,GAAG4F,GAAG,CAAC;MACxBI,GAAG,GAAGhG,SAAS,CAAC,CAAC,GAAG4F,GAAG,GAAG,CAAC,CAAC;MAC5BK,GAAG,GAAGjG,SAAS,CAAC,CAAC,GAAG4F,GAAG,GAAG,CAAC,CAAC;MAC5BM,GAAG,GAAGlG,SAAS,CAAC,CAAC,GAAG6F,GAAG,CAAC;MACxBM,GAAG,GAAGnG,SAAS,CAAC,CAAC,GAAG6F,GAAG,GAAG,CAAC,CAAC;MAC5BO,GAAG,GAAGpG,SAAS,CAAC,CAAC,GAAG6F,GAAG,GAAG,CAAC,CAAC;MAC5BQ,GAAG,GAAGrG,SAAS,CAAC,CAAC,GAAG8F,GAAG,CAAC;MACxBQ,GAAG,GAAGtG,SAAS,CAAC,CAAC,GAAG8F,GAAG,GAAG,CAAC,CAAC;MAC5BS,GAAG,GAAGvG,SAAS,CAAC,CAAC,GAAG8F,GAAG,GAAG,CAAC,CAAC;MAC5BU,OAAO,CAACnF,GAAG,CAAC0E,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;MAC1BQ,OAAO,CAACpF,GAAG,CAAC6E,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;MAC1BM,OAAO,CAACrF,GAAG,CAACgF,GAAG,EAAEC,GAAG,EAAEC,GAAG,CAAC;MAC1BE,OAAO,CAACgD,aAAa,CAACjD,OAAO,EAAEG,IAAI,CAAC;MACpCD,OAAO,CAAC+C,aAAa,CAAChD,OAAO,EAAEG,IAAI,CAAC;MACpCF,OAAO,CAAC+C,aAAa,CAACjD,OAAO,EAAE4G,IAAI,CAAC;MACpCvB,CAAC,GAAGlF,IAAI,CAACpF,MAAM,EAAE;MACjBqK,CAAC,GAAGhF,IAAI,CAACrF,MAAM,EAAE;MACjB8L,CAAC,GAAGD,IAAI,CAAC7L,MAAM,EAAE;MACjBiE,CAAC,GAAG,CAACqG,CAAC,GAAGD,CAAC,GAAGyB,CAAC,IAAI,CAAC;MACnBC,IAAI,GAAGzK,IAAI,CAAC6K,IAAI,CAAClI,CAAC,IAAIA,CAAC,GAAGqG,CAAC,CAAC,IAAIrG,CAAC,GAAGoG,CAAC,CAAC,IAAIpG,CAAC,GAAG6H,CAAC,CAAC,CAAC;MACjDG,WAAW,IAAIF,IAAI;MACnBC,KAAK,CAAC/D,KAAK,CAAC,GAAG8D,IAAI;;IAEvB,IAAIK,UAAU,GAAW,CAAC;IAC1B,KAAK,IAAInE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGiE,QAAQ,EAAEjE,KAAK,EAAE,EAAE;MAC3C2D,OAAO,CAAC3D,KAAK,CAAC,GAAG3G,IAAI,CAAC+K,KAAK,CAAEX,QAAQ,GAAGM,KAAK,CAAC/D,KAAK,CAAC,GAAIgE,WAAW,CAAC;MACpEG,UAAU,IAAIR,OAAO,CAAC3D,KAAK,CAAC;;IAGhC,MAAMqE,IAAI,GAAWZ,QAAQ,GAAGU,UAAU;IAC1C,MAAMG,cAAc,GAAWjL,IAAI,CAAC+K,KAAK,CAACC,IAAI,GAAGJ,QAAQ,CAAC;IAC1D,MAAMM,WAAW,GAAWF,IAAI,GAAGJ,QAAQ;IAE3C,IAAIK,cAAc,GAAG,CAAC,EAAE;MACpBX,OAAO,GAAGA,OAAO,CAACa,GAAG,CAAE9K,CAAC,IAAKA,CAAC,GAAG4K,cAAc,CAAC;;IAGpD,KAAK,IAAItE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGuE,WAAW,EAAEvE,KAAK,EAAE,EAAE;MAC9C2D,OAAO,CAAC3D,KAAK,CAAC,IAAI,CAAC;;IAGvB,OAAO2D,OAAO;EAClB;EAEA;;;;;;EAMOpM,SAAS,CAACkN,EAAU,EAAEC,gBAAqB,IAAI,CAACxL,iBAAiB;IACpE,MAAMO,WAAW,GAAG,IAAIpE,WAAW,CAAC,IAAI,CAACyL,aAAa,EAAE4D,aAAa,CAAC;IACtE,IAAI1L,EAAc;IAElB;IACA,IAAIJ,GAAG,GAAG,IAAI,CAACtB,WAAW;IAC1B,KAAK,IAAIsJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG6D,EAAE,EAAE7D,CAAC,EAAE,EAAE;MACzB5H,EAAE,GAAG,IAAI,CAACL,YAAY,CAACC,GAAG,EAAEa,WAAW,EAAE,IAAI,CAACqH,aAAa,EAAEF,CAAC,CAAC;MAC/D,IAAInH,WAAW,IAAIA,WAAW,CAACkL,iBAAiB,EAAE;QAC9ClL,WAAW,CAACkL,iBAAiB,CAAC3L,EAAE,EAAEJ,GAAG,EAAEgI,CAAC,CAAC;;MAE7C,IAAI,CAACnJ,UAAU,CAACwB,IAAI,CAACD,EAAE,CAACI,QAAQ,CAACM,CAAC,EAAEV,EAAE,CAACI,QAAQ,CAACO,CAAC,EAAEX,EAAE,CAACI,QAAQ,CAAC8C,CAAC,CAAC;MACjE,IAAIlD,EAAE,CAACO,KAAK,EAAE;QACV,IAAI,CAAC5B,OAAO,CAACsB,IAAI,CAACD,EAAE,CAACO,KAAK,CAAC2I,CAAC,EAAElJ,EAAE,CAACO,KAAK,CAAC4I,CAAC,EAAEnJ,EAAE,CAACO,KAAK,CAAC6I,CAAC,EAAEpJ,EAAE,CAACO,KAAK,CAAC8I,CAAC,CAAC;;MAErE,IAAIrJ,EAAE,CAACuJ,EAAE,EAAE;QACP,IAAI,CAAC7K,IAAI,CAACuB,IAAI,CAACD,EAAE,CAACuJ,EAAE,CAAC7I,CAAC,EAAEV,EAAE,CAACuJ,EAAE,CAAC5I,CAAC,CAAC;;MAEpCf,GAAG,EAAE;;IAET,IAAI,CAACtB,WAAW,IAAImN,EAAE;IACtB,IAAI,CAAC3D,aAAa,EAAE;IACpB,OAAO,IAAI,CAACA,aAAa;EAC7B;EAEA;;;;;;;;;EASO8D,gBAAgB,CAACzM,IAAU,EAAEsM,EAAU,EAAEI,SAAkB,EAAEtL,KAAuB,EAAEqB,KAAc;IACvG,IAAIkK,OAAO,GAAGD,SAAS,GAAGA,SAAS,GAAGnP,UAAU,CAACqP,MAAM;IACvD,IAAIC,KAAK,CAACF,OAAO,CAAC,IAAIA,OAAO,GAAG,CAAC,IAAIA,OAAO,GAAG,CAAC,EAAE;MAC9CA,OAAO,GAAGpP,UAAU,CAACqP,MAAM;;IAG/B,MAAM5J,OAAO,GAAehD,IAAI,CAACiD,eAAe,CAACpG,YAAY,CAAC8C,YAAY,CAAC;IAC3E,MAAMuD,OAAO,GAAiBlD,IAAI,CAACmD,UAAU,EAAE;IAE/C,IAAI,CAAC2J,OAAO,CAAChM,IAAI,CAAC,IAAI,CAAC6H,aAAa,CAAC;IACrC,MAAMrH,WAAW,GAAG,IAAIpE,WAAW,CAAC,IAAI,CAACyL,aAAa,EAAE,IAAI,CAAC;IAE7DrH,WAAW,CAACoH,aAAa,GAAG,IAAI,CAAC2C,iBAAiB,CAACiB,EAAE,EAAEtJ,OAAO,EAAEE,OAAO,CAAC;IACxE,IAAIyJ,OAAO,KAAKpP,UAAU,CAACwP,KAAK,EAAE;MAC9BzL,WAAW,CAACwJ,UAAU,GAAW1J,KAAK,GAAWA,KAAK,GAAG,CAAC;KAC7D,MAAM;MACHA,KAAK,GAAWA,KAAK,GAAWA,KAAK,GAAG,IAAI/E,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAElE,QAAQsQ,OAAO;MACX,KAAKpP,UAAU,CAACwP,KAAK;QACjB,IAAI,CAACxC,iBAAiB,CAACvK,IAAI,EAAEsB,WAAW,EAAE,KAAK,CAAC;QAChD;MACJ,KAAK/D,UAAU,CAACyP,EAAE;QACd,IAAI,CAAC3K,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;QAChE;MACJ,KAAK/D,UAAU,CAACqP,MAAM;QAClB,IAAI,CAACvK,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAE,KAAK,CAAC;QAClD;MACJ,KAAK/D,UAAU,CAAC0P,MAAM;QAClB,IAAI,CAAC5K,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAE,KAAK,EAAEnD,SAAS,EAAEA,SAAS,EAAUiD,KAAK,EAAEqB,KAAK,CAAC;QAC9F;IAAM;IAEd,IAAI,CAACtD,WAAW,IAAImN,EAAE;IACtB,IAAI,CAAC3D,aAAa,EAAE;IACpB,OAAO,IAAI,CAACA,aAAa,GAAG,CAAC;EACjC;EAEA;;;;;;;;;EASOuE,eAAe,CAAClN,IAAU,EAAEsM,EAAU,EAAEI,SAAkB,EAAEtL,KAAuB,EAAEqB,KAAc;IACtG,IAAIkK,OAAO,GAAGD,SAAS,GAAGA,SAAS,GAAGnP,UAAU,CAACqP,MAAM;IACvD,IAAIC,KAAK,CAACF,OAAO,CAAC,IAAIA,OAAO,GAAG,CAAC,IAAIA,OAAO,GAAG,CAAC,EAAE;MAC9CA,OAAO,GAAGpP,UAAU,CAACqP,MAAM;;IAG/B,MAAM5J,OAAO,GAAehD,IAAI,CAACiD,eAAe,CAACpG,YAAY,CAAC8C,YAAY,CAAC;IAC3E,MAAMuD,OAAO,GAAiBlD,IAAI,CAACmD,UAAU,EAAE;IAE/C,IAAI,CAAC2J,OAAO,CAAChM,IAAI,CAAC,IAAI,CAAC6H,aAAa,CAAC;IACrC,MAAMrH,WAAW,GAAG,IAAIpE,WAAW,CAAC,IAAI,CAACyL,aAAa,EAAE,IAAI,CAAC;IAE7DrH,WAAW,CAACoH,aAAa,GAAG,IAAI,CAAC2C,iBAAiB,CAACiB,EAAE,EAAEtJ,OAAO,EAAEE,OAAO,CAAC;IACxE,IAAIyJ,OAAO,KAAKpP,UAAU,CAACwP,KAAK,EAAE;MAC9BzL,WAAW,CAACwJ,UAAU,GAAW1J,KAAK,GAAWA,KAAK,GAAG,CAAC;KAC7D,MAAM;MACHA,KAAK,GAAWA,KAAK,GAAWA,KAAK,GAAG,IAAI/E,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAElE,QAAQsQ,OAAO;MACX,KAAKpP,UAAU,CAACwP,KAAK;QACjB,IAAI,CAACxC,iBAAiB,CAACvK,IAAI,EAAEsB,WAAW,EAAE,IAAI,CAAC;QAC/C;MACJ,KAAK/D,UAAU,CAACyP,EAAE;QACd,IAAI,CAAC3K,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC;QAC/D;MACJ,KAAK/D,UAAU,CAACqP,MAAM;QAClB,IAAI,CAACvK,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAE,IAAI,CAAC;QACjD;MACJ,KAAK/D,UAAU,CAAC0P,MAAM;QAClB,IAAI,CAAC5K,mBAAmB,CAACrC,IAAI,EAAEsB,WAAW,EAAE,IAAI,EAAEnD,SAAS,EAAEA,SAAS,EAAUiD,KAAK,EAAEqB,KAAK,CAAC;QAC7F;IAAM;IAEd,IAAI,CAACtD,WAAW,IAAImN,EAAE;IACtB,IAAI,CAAC3D,aAAa,EAAE;IACpB,OAAO,IAAI,CAACA,aAAa,GAAG,CAAC;EACjC;EAEA;;;;;;;;;EASOwE,YAAY,CAACC,QAAgB,CAAC,EAAEC,MAAc,IAAI,CAAClO,WAAW,GAAG,CAAC,EAAEmO,SAAkB,IAAI;;IAC7F,IAAI,CAAC,IAAI,CAAClP,UAAU,IAAI,CAAC,IAAI,CAACa,QAAQ,EAAE;MACpC,OAAO,IAAI;;IAGf;IACA,IAAI,CAACsO,qBAAqB,CAACH,KAAK,EAAEC,GAAG,EAAEC,MAAM,CAAC;IAE9C,MAAME,SAAS,GAAG9Q,UAAU,CAACC,MAAM,CAAC,CAAC,CAAC;IACtC,MAAMqD,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMyN,QAAQ,GAAG,IAAI,CAACjP,SAAS;IAC/B,MAAMkP,WAAW,GAAG,IAAI,CAACpP,YAAY;IACrC,MAAMqP,KAAK,GAAG,IAAI,CAACjP,MAAM;IAEzB,MAAMkP,WAAW,GAAGlR,UAAU,CAACF,OAAO;IACtC,MAAMqR,QAAQ,GAAGD,WAAW,CAAC,CAAC,CAAC,CAACE,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAC7D,MAAMC,QAAQ,GAAGH,WAAW,CAAC,CAAC,CAAC,CAACE,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAC7D,MAAME,QAAQ,GAAGJ,WAAW,CAAC,CAAC,CAAC,CAACE,cAAc,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAC7D,MAAMG,OAAO,GAAGL,WAAW,CAAC,CAAC,CAAC,CAACM,MAAM,CAACC,MAAM,CAACC,SAAS,CAAC;IACvD,MAAMC,OAAO,GAAGT,WAAW,CAAC,CAAC,CAAC,CAACM,MAAM,CAAC,CAACC,MAAM,CAACC,SAAS,CAAC;IAExDzR,MAAM,CAAC2R,aAAa,CAACd,SAAS,CAAC;IAC/B,IAAI/M,GAAG,GAAG,CAAC,CAAC,CAAC;IAEb,IAAI,UAAI,CAACT,IAAI,0CAAEuO,kBAAkB,EAAE;MAC/B,IAAI,CAACC,mBAAmB,GAAG,IAAI;;IAGnCnB,GAAG,GAAGA,GAAG,IAAI,IAAI,CAAClO,WAAW,GAAG,IAAI,CAACA,WAAW,GAAG,CAAC,GAAGkO,GAAG;IAC1D,IAAI,IAAI,CAACmB,mBAAmB,EAAE;MAC1B,IAAIpB,KAAK,IAAI,CAAC,IAAIC,GAAG,IAAI,IAAI,CAAClO,WAAW,GAAG,CAAC,EAAE;QAC3C;QACA,MAAMsP,YAAY,GAAG,UAAI,CAACzO,IAAI,0CAAE4C,eAAe,EAAE;QACjD,IAAI6L,YAAY,EAAE;UACdR,OAAO,CAACS,QAAQ,CAACD,YAAY,CAACR,OAAO,CAAC;UACtCI,OAAO,CAACK,QAAQ,CAACD,YAAY,CAACJ,OAAO,CAAC;;;;IAKlD5N,GAAG,GAAG,CAAC,CAAC,CAAC;IACT,IAAIkO,MAAM,GAAG,CAAC,CAAC,CAAC;IAChB,IAAIC,MAAM,GAAG,CAAC,CAAC,CAAC;IAChB,IAAIC,MAAM,GAAG,CAAC,CAAC,CAAC;IAEhB;IACA,KAAK,IAAIhL,CAAC,GAAGuJ,KAAK,EAAEvJ,CAAC,IAAIwJ,GAAG,EAAExJ,CAAC,EAAE,EAAE;MAC/B,MAAM7C,QAAQ,GAAG,IAAI,CAACd,SAAS,CAAC2D,CAAC,CAAC;MAClCpD,GAAG,GAAGO,QAAQ,CAACP,GAAG;MAClBkO,MAAM,GAAG,CAAC,GAAGlO,GAAG;MAChBmO,MAAM,GAAG,CAAC,GAAGnO,GAAG;MAChBoO,MAAM,GAAG,CAAC,GAAGpO,GAAG;MAEhB;MACA,IAAI,CAACqO,cAAc,CAAC9N,QAAQ,CAAC;MAE7B,MAAM+N,sBAAsB,GAAG/N,QAAQ,CAACgO,eAAe;MACvD,MAAMC,gBAAgB,GAAGjO,QAAQ,CAACC,QAAQ;MAC1C,MAAMiO,sBAAsB,GAAGlO,QAAQ,CAACmO,eAAe;MAEvD,IAAI,IAAI,CAACC,wBAAwB,EAAE;QAC/BpO,QAAQ,CAACqO,iBAAiB,CAAC7B,SAAS,CAAC;;MAGzC,MAAM8B,iBAAiB,GAAGtO,QAAQ,CAACuO,QAAQ,KAAK,IAAI;MACpD,IAAID,iBAAiB,EAAE;QACnB,MAAME,MAAM,GAAG,IAAI,CAACtP,SAAS,CAACc,QAAQ,CAACuO,QAAS,CAAC;QACjD,MAAME,oBAAoB,GAAGD,MAAM,CAACR,eAAe;QACnD,MAAMU,oBAAoB,GAAGF,MAAM,CAACL,eAAe;QAEnD,MAAMQ,QAAQ,GAAGV,gBAAgB,CAAC1N,CAAC,GAAGkO,oBAAoB,CAAC,CAAC,CAAC,GAAGR,gBAAgB,CAACzN,CAAC,GAAGiO,oBAAoB,CAAC,CAAC,CAAC,GAAGR,gBAAgB,CAAClL,CAAC,GAAG0L,oBAAoB,CAAC,CAAC,CAAC;QAC3J,MAAMG,QAAQ,GAAGX,gBAAgB,CAAC1N,CAAC,GAAGkO,oBAAoB,CAAC,CAAC,CAAC,GAAGR,gBAAgB,CAACzN,CAAC,GAAGiO,oBAAoB,CAAC,CAAC,CAAC,GAAGR,gBAAgB,CAAClL,CAAC,GAAG0L,oBAAoB,CAAC,CAAC,CAAC;QAC3J,MAAMI,QAAQ,GAAGZ,gBAAgB,CAAC1N,CAAC,GAAGkO,oBAAoB,CAAC,CAAC,CAAC,GAAGR,gBAAgB,CAACzN,CAAC,GAAGiO,oBAAoB,CAAC,CAAC,CAAC,GAAGR,gBAAgB,CAAClL,CAAC,GAAG0L,oBAAoB,CAAC,CAAC,CAAC;QAE3JP,sBAAsB,CAAC3N,CAAC,GAAGmO,oBAAoB,CAACnO,CAAC,GAAGqO,QAAQ;QAC5DV,sBAAsB,CAAC1N,CAAC,GAAGkO,oBAAoB,CAAClO,CAAC,GAAGmO,QAAQ;QAC5DT,sBAAsB,CAACnL,CAAC,GAAG2L,oBAAoB,CAAC3L,CAAC,GAAG8L,QAAQ;QAE5D,IAAI,IAAI,CAACT,wBAAwB,EAAE;UAC/B,MAAMU,eAAe,GAAGtC,SAAS,CAACuC,CAAC;UACnChB,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC9IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC9IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC9IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC9IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC9IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC9IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,EAAE,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC/IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,EAAE,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;UAC/IV,sBAAsB,CAAC,CAAC,CAAC,GACrBe,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,CAAC,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC,GAAGK,eAAe,CAAC,EAAE,CAAC,GAAGL,oBAAoB,CAAC,CAAC,CAAC;;OAEtJ,MAAM;QACHP,sBAAsB,CAAC3N,CAAC,GAAG,CAAC;QAC5B2N,sBAAsB,CAAC1N,CAAC,GAAG,CAAC;QAC5B0N,sBAAsB,CAACnL,CAAC,GAAG,CAAC;QAE5B,IAAI,IAAI,CAACqL,wBAAwB,EAAE;UAC/B,MAAMU,eAAe,GAAGtC,SAAS,CAACuC,CAAC;UACnChB,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,CAAC,CAAC;UAC9Cf,sBAAsB,CAAC,CAAC,CAAC,GAAGe,eAAe,CAAC,EAAE,CAAC;;;MAIvD,MAAME,oBAAoB,GAAGpC,WAAW,CAAC,EAAE,CAAC;MAC5C,IAAI5M,QAAQ,CAACiP,kBAAkB,EAAE;QAC7BD,oBAAoB,CAAC9B,MAAM,CAAC,GAAG,CAAC;OACnC,MAAM;QACH8B,oBAAoB,CAACtB,QAAQ,CAAC1N,QAAQ,CAACkP,KAAK,CAAC;;MAGjD;MACA,MAAMC,SAAS,GAAGvC,WAAW,CAAC,CAAC,CAAC;MAChCuC,SAAS,CAACzB,QAAQ,CAAC1N,QAAQ,CAACC,QAAQ,CAAC;MACrC,MAAMmP,OAAO,GAAGD,SAAS,CAAC5O,CAAC,GAAGP,QAAQ,CAACkP,KAAK,CAAC3O,CAAC;MAC9C,MAAM8O,OAAO,GAAGF,SAAS,CAAC3O,CAAC,GAAGR,QAAQ,CAACkP,KAAK,CAAC1O,CAAC;MAC9C,MAAM8O,OAAO,GAAGH,SAAS,CAACpM,CAAC,GAAG/C,QAAQ,CAACkP,KAAK,CAACnM,CAAC;MAE9C,IAAI6L,QAAQ,GAAGQ,OAAO,GAAGrB,sBAAsB,CAAC,CAAC,CAAC,GAAGsB,OAAO,GAAGtB,sBAAsB,CAAC,CAAC,CAAC,GAAGuB,OAAO,GAAGvB,sBAAsB,CAAC,CAAC,CAAC;MAC9H,IAAIY,QAAQ,GAAGS,OAAO,GAAGrB,sBAAsB,CAAC,CAAC,CAAC,GAAGsB,OAAO,GAAGtB,sBAAsB,CAAC,CAAC,CAAC,GAAGuB,OAAO,GAAGvB,sBAAsB,CAAC,CAAC,CAAC;MAC9H,IAAIc,QAAQ,GAAGO,OAAO,GAAGrB,sBAAsB,CAAC,CAAC,CAAC,GAAGsB,OAAO,GAAGtB,sBAAsB,CAAC,CAAC,CAAC,GAAGuB,OAAO,GAAGvB,sBAAsB,CAAC,CAAC,CAAC;MAE9Ha,QAAQ,IAAII,oBAAoB,CAACzO,CAAC;MAClCoO,QAAQ,IAAIK,oBAAoB,CAACxO,CAAC;MAClCqO,QAAQ,IAAIG,oBAAoB,CAACjM,CAAC;MAElC,MAAMwM,EAAE,GAAI7C,WAAW,CAACiB,MAAM,CAAC,GAAGO,sBAAsB,CAAC3N,CAAC,GAAGsM,QAAQ,CAACtM,CAAC,GAAGqO,QAAQ,GAAG7B,QAAQ,CAACxM,CAAC,GAAGoO,QAAQ,GAAG3B,QAAQ,CAACzM,CAAC,GAAGsO,QAAS;MACnI,MAAMW,EAAE,GAAI9C,WAAW,CAACiB,MAAM,GAAG,CAAC,CAAC,GAAGO,sBAAsB,CAAC1N,CAAC,GAAGqM,QAAQ,CAACrM,CAAC,GAAGoO,QAAQ,GAAG7B,QAAQ,CAACvM,CAAC,GAAGmO,QAAQ,GAAG3B,QAAQ,CAACxM,CAAC,GAAGqO,QAAS;MACvI,MAAMY,EAAE,GAAI/C,WAAW,CAACiB,MAAM,GAAG,CAAC,CAAC,GAAGO,sBAAsB,CAACnL,CAAC,GAAG8J,QAAQ,CAAC9J,CAAC,GAAG6L,QAAQ,GAAG7B,QAAQ,CAAChK,CAAC,GAAG4L,QAAQ,GAAG3B,QAAQ,CAACjK,CAAC,GAAG8L,QAAS;MAEvI,IAAI,IAAI,CAACrB,mBAAmB,EAAE;QAC1BP,OAAO,CAACyC,yBAAyB,CAACH,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;QAC7CpC,OAAO,CAACsC,yBAAyB,CAACJ,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;;MAGjD,IAAI,IAAI,CAACG,qBAAqB,IAAI5P,QAAQ,CAACI,KAAK,EAAE;QAC9C,MAAMA,KAAK,GAAGJ,QAAQ,CAACI,KAAK;QAC5B,MAAMqM,QAAQ,GAAG,IAAI,CAACjP,SAAS;QAC/BiP,QAAQ,CAACmB,MAAM,CAAC,GAAGxN,KAAK,CAAC2I,CAAC;QAC1B0D,QAAQ,CAACmB,MAAM,GAAG,CAAC,CAAC,GAAGxN,KAAK,CAAC4I,CAAC;QAC9ByD,QAAQ,CAACmB,MAAM,GAAG,CAAC,CAAC,GAAGxN,KAAK,CAAC6I,CAAC;QAC9BwD,QAAQ,CAACmB,MAAM,GAAG,CAAC,CAAC,GAAGxN,KAAK,CAAC8I,CAAC;;MAElC,IAAI,IAAI,CAAC2G,uBAAuB,IAAI7P,QAAQ,CAACoJ,EAAE,EAAE;QAC7C,MAAMA,EAAE,GAAGpJ,QAAQ,CAACoJ,EAAE;QACtB,MAAMuD,KAAK,GAAG,IAAI,CAACjP,MAAM;QACzBiP,KAAK,CAACkB,MAAM,CAAC,GAAGzE,EAAE,CAAC7I,CAAC;QACpBoM,KAAK,CAACkB,MAAM,GAAG,CAAC,CAAC,GAAGzE,EAAE,CAAC5I,CAAC;;;IAIhC;IACA,IAAIxB,IAAI,EAAE;MACN,IAAIsN,MAAM,EAAE;QACR,IAAI,IAAI,CAACsD,qBAAqB,EAAE;UAC5B5Q,IAAI,CAAC8Q,kBAAkB,CAACjU,YAAY,CAACkD,SAAS,EAAE0N,QAAQ,EAAE,KAAK,EAAE,KAAK,CAAC;;QAE3E,IAAI,IAAI,CAACoD,uBAAuB,EAAE;UAC9B7Q,IAAI,CAAC8Q,kBAAkB,CAACjU,YAAY,CAACgD,MAAM,EAAE8N,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;;QAErE3N,IAAI,CAAC8Q,kBAAkB,CAACjU,YAAY,CAAC8C,YAAY,EAAE+N,WAAW,EAAE,KAAK,EAAE,KAAK,CAAC;;MAGjF,IAAI,IAAI,CAACc,mBAAmB,EAAE;QAC1B,IAAIxO,IAAI,CAAC+Q,eAAe,EAAE;UACtB/Q,IAAI,CAAC4C,eAAe,EAAE,CAACoO,WAAW,CAAC/C,OAAO,EAAEI,OAAO,EAAErO,IAAI,CAACiR,YAAY,CAAC;SAC1E,MAAM;UACHjR,IAAI,CAACkR,iBAAiB,CAACjD,OAAO,EAAEI,OAAO,EAAErO,IAAI,CAACiR,YAAY,CAAC;;;;IAIvE,IAAI,CAACE,oBAAoB,CAAC/D,KAAK,EAAEC,GAAG,EAAEC,MAAM,CAAC;IAC7C,OAAO,IAAI;EACf;EAEA;;;EAGOrC,OAAO;;IACV,UAAI,CAACjL,IAAI,0CAAEiL,OAAO,EAAE;IACpB,IAAI,CAACmG,IAAI,GAAG,IAAI;IAChB;IACM,IAAI,CAAC9R,UAAW,GAAG,IAAI;IACvB,IAAI,CAAC+R,QAAS,GAAG,IAAI;IACrB,IAAI,CAACC,QAAS,GAAG,IAAI;IACrB,IAAI,CAAC/R,IAAK,GAAG,IAAI;IACjB,IAAI,CAACC,OAAQ,GAAG,IAAI;IACpB,IAAI,CAAC+R,UAAW,GAAG,IAAI;IACvB,IAAI,CAACjT,YAAa,GAAG,IAAI;IACzB,IAAI,CAACI,MAAO,GAAG,IAAI;IACnB,IAAI,CAACF,SAAU,GAAG,IAAI;EAChC;EAEA;;;;;EAKOgT,kBAAkB;;IACrB,IAAI,CAAC,IAAI,CAACC,sBAAsB,EAAE;MAC9B,UAAI,CAACzR,IAAI,0CAAE0R,mBAAmB,EAAE;;IAEpC,OAAO,IAAI;EACf;EAEA;;;;;;EAMOC,gBAAgB,CAACC,IAAY;IAChC,IAAI,CAAC,IAAI,CAAC5R,IAAI,EAAE;MACZ;;IAGJ,MAAM6R,GAAG,GAAGD,IAAI,GAAG,CAAC;IACpB,IAAI,CAAC5R,IAAI,CAACkR,iBAAiB,CAAC,IAAI1U,OAAO,CAAC,CAACqV,GAAG,EAAE,CAACA,GAAG,EAAE,CAACA,GAAG,CAAC,EAAE,IAAIrV,OAAO,CAACqV,GAAG,EAAEA,GAAG,EAAEA,GAAG,CAAC,CAAC;EAC1F;EAEA;;;;EAIA,IAAWC,eAAe;IACtB,OAAO,IAAI,CAACC,cAAc;EAC9B;EAEA;;;;EAIA,IAAWD,eAAe,CAACE,GAAY;IACnC,IAAI,CAAC,IAAI,CAAChS,IAAI,EAAE;MACZ;;IAGJ,IAAI,CAAC+R,cAAc,GAAGC,GAAG;IACzB,IAAI,CAAChS,IAAI,CAACiS,wBAAwB,GAAGD,GAAG;EAC5C;EAEA;;;;;;EAMA,IAAWE,uBAAuB,CAACF,GAAY;IAC3C,IAAI,CAAC5C,wBAAwB,GAAG4C,GAAG;EACvC;EAEA;;;;;EAKA,IAAWG,oBAAoB,CAACH,GAAY;IACxC,IAAI,CAACpB,qBAAqB,GAAGoB,GAAG;EACpC;EAEA,IAAWI,sBAAsB,CAACJ,GAAY;IAC1C,IAAI,CAACnB,uBAAuB,GAAGmB,GAAG;EACtC;EACA;;;;;EAKA,IAAWG,oBAAoB;IAC3B,OAAO,IAAI,CAACvB,qBAAqB;EACrC;EACA;;;;;EAKA,IAAWwB,sBAAsB;IAC7B,OAAO,IAAI,CAACvB,uBAAuB;EACvC;EACA;;;EAGA,IAAWwB,kBAAkB,CAACL,GAAY;IACtC,IAAI,CAACxD,mBAAmB,GAAGwD,GAAG;EAClC;EACA;;;EAGA,IAAWK,kBAAkB;IACzB,OAAO,IAAI,CAAC7D,mBAAmB;EACnC;EAEA;EACA;EACA;EAEA;;;;;EAKO8D,aAAa,IAAU;EAE9B;;;;;;;EAOOC,eAAe,CAACvR,QAAoB;IACvC,OAAOA,QAAQ;EACnB;EAEA;;;;;;;;EAQO8N,cAAc,CAAC9N,QAAoB;IACtC,OAAOA,QAAQ;EACnB;EAEA;;;;;;;EAOA;EACOuM,qBAAqB,CAACH,KAAc,EAAEoF,IAAa,EAAElF,MAAgB,GAAS;EACrF;;;;;;;;EAQA;EACO6D,oBAAoB,CAAC/D,KAAc,EAAEoF,IAAa,EAAElF,MAAgB,GAAS","names":["Color4","Color3","Vector2","Vector3","Vector4","TmpVectors","Matrix","Logger","VertexBuffer","VertexData","Mesh","EngineStore","CloudPoint","PointsGroup","Ray","StandardMaterial","BaseTexture","Scalar","PointColor","PointsCloudSystem","constructor","name","pointSize","scene","options","Array","_size","_scene","LastCreatedScene","updatable","undefined","_updatable","positions","_positions32","colors","_colors32","uvs","_uvs32","buildMeshAsync","material","Promise","all","_promises","then","_isReady","_buildMesh","nbParticles","addPoints","Float32Array","_positions","_uvs","_colors","vertexData","set","PositionKind","length","UVKind","ec","ColorKind","mesh","applyToMesh","particles","mat","emissiveColor","disableLighting","pointsCloud","resolve","_addParticle","idx","group","groupId","idxInGroup","cp","push","_randomUnitVector","particle","position","Math","random","color","_getColorIndicesForCoord","pointsGroup","x","y","width","imageData","_groupImageData","colorIndices","redIndex","greenIndex","blueIndex","alphaIndex","redForCoord","greenForCoord","blueForCoord","alphaForCoord","_setPointsColorOrUV","isVolume","colorFromTexture","hasTexture","range","updateFacetData","boundInfo","getBoundingInfo","diameter","boundingSphere","radius","meshPos","getVerticesData","meshInd","getIndices","meshUV","meshCol","place","Zero","computeWorldMatrix","meshMatrix","getWorldMatrix","isIdentity","slice","p","TransformCoordinatesFromFloatsToRef","z","idxPoints","id0","id1","id2","v0X","v0Y","v0Z","v1X","v1Y","v1Z","v2X","v2Y","v2Z","vertex0","vertex1","vertex2","vec0","vec1","uv0X","uv0Y","uv1X","uv1Y","uv2X","uv2Y","uv0","uv1","uv2","uvec0","uvec1","col0X","col0Y","col0Z","col0A","col1X","col1Y","col1Z","col1A","col2X","col2Y","col2Z","col2A","col0","col1","col2","colvec0","colvec1","lamda","mu","facetPoint","uvPoint","colPoint","norm","tang","biNorm","angle","facetPlaneVec","gap","distance","ray","pickInfo","direction","index","subtractToRef","height","deltaS","deltaV","h","s","v","hsvCol","statedColor","colPoint3","pointColors","i","_groupDensity","_groupCounter","RandomRange","add","scale","getFacetNormal","normalize","clone","Cross","PI","cos","sin","origin","intersectsMesh","hit","pickedPoint","subtract","addInPlace","_groupImgWidth","_groupImgHeight","round","r","g","b","a","w","uv","toHSV","HSVtoRGBToRef","_colorFromTexture","Warn","textureList","getActiveTextures","setEnabled","WhenAllReady","n","_textureNb","finalize","getSize","dispose","dataPromise","readPixels","data","_calculateDensity","nbPoints","indices","density","vec2","c","area","areas","surfaceArea","nbFacets","sqrt","pointCount","floor","diff","pointsPerFacet","extraPoints","map","nb","pointFunction","_positionFunction","addSurfacePoints","colorWith","colored","Random","isNaN","_groups","Color","UV","Stated","addVolumePoints","setParticles","start","end","update","beforeUpdateParticles","rotMatrix","colors32","positions32","uvs32","tempVectors","camAxisX","copyFromFloats","camAxisY","camAxisZ","minimum","setAll","Number","MAX_VALUE","maximum","IdentityToRef","isFacetDataEnabled","_computeBoundingBox","boundingInfo","copyFrom","pindex","cindex","uindex","updateParticle","particleRotationMatrix","_rotationMatrix","particlePosition","particleGlobalPosition","_globalPosition","_computeParticleRotation","getRotationMatrix","particleHasParent","parentId","parent","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","m","pivotBackTranslation","translateFromPivot","pivot","tmpVertex","vertexX","vertexY","vertexZ","px","py","pz","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","_computeParticleColor","_computeParticleTexture","updateVerticesData","hasBoundingInfo","reConstruct","_worldMatrix","buildBoundingInfo","afterUpdateParticles","vars","_indices","_normals","_indices32","refreshVisibleSize","_isVisibilityBoxLocked","refreshBoundingInfo","setVisibilityBox","size","vis","isAlwaysVisible","_alwaysVisible","val","alwaysSelectAsActiveMesh","computeParticleRotation","computeParticleColor","computeParticleTexture","computeBoundingBox","initParticles","recycleParticle","stop"],"sourceRoot":"","sources":["../../../../lts/core/generated/Particles/pointsCloudSystem.ts"],"sourcesContent":["import type { IndicesArray, FloatArray } from \"../types\";\r\nimport { Color4, Color3 } from \"../Maths/math\";\r\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport type { Material } from \"../Materials/material\";\r\n\r\n/** Defines the 4 color options */\r\nexport enum PointColor {\r\n    /** color value */\r\n    Color = 2,\r\n    /** uv value */\r\n    UV = 1,\r\n    /** random value */\r\n    Random = 0,\r\n    /** stated value */\r\n    Stated = 3,\r\n}\r\n\r\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\r\nexport class PointsCloudSystem implements IDisposable {\r\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: CloudPoint[] = new Array<CloudPoint>();\r\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The PCS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are available.\r\n     */\r\n    public mesh?: Mesh;\r\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * @internal\r\n     */\r\n    public _size: number; //size of each point particle\r\n\r\n    private _scene: Scene;\r\n    private _promises: Array<Promise<any>> = [];\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray; // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array; // updated positions for the VBO\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _updatable: boolean = true;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _groups: number[] = new Array<number>(); //start indices for each group of particles\r\n    private _groupCounter: number = 0;\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _isReady: boolean = false;\r\n\r\n    /**\r\n     * Gets the particle positions computed by the Point Cloud System\r\n     */\r\n    public get positions() {\r\n        return this._positions32;\r\n    }\r\n\r\n    /**\r\n     * Gets the particle colors computed by the Point Cloud System\r\n     */\r\n    public get colors() {\r\n        return this._colors32;\r\n    }\r\n\r\n    /**\r\n     * Gets the particle uvs computed by the Point Cloud System\r\n     */\r\n    public get uvs() {\r\n        return this._uvs32;\r\n    }\r\n\r\n    /**\r\n     * Creates a PCS (Points Cloud System) object\r\n     * @param name (String) is the PCS name, this will be the underlying mesh name\r\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\r\n     * @param scene (Scene) is the scene in which the PCS is added\r\n     * @param options defines the options of the PCS e.g.\r\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n     * @param options.updatable\r\n     */\r\n    constructor(name: string, pointSize: number, scene: Scene, options?: { updatable?: boolean }) {\r\n        this.name = name;\r\n        this._size = pointSize;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n     * If no points were added to the PCS, the returned mesh is just a single point.\r\n     * @param material The material to use to render the mesh. If not provided, will create a default one\r\n     * @returns a promise for the created mesh\r\n     */\r\n    public buildMeshAsync(material?: Material): Promise<Mesh> {\r\n        return Promise.all(this._promises).then(() => {\r\n            this._isReady = true;\r\n            return this._buildMesh(material);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _buildMesh(material?: Material): Promise<Mesh> {\r\n        if (this.nbParticles === 0) {\r\n            this.addPoints(1);\r\n        }\r\n\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        const vertexData = new VertexData();\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\r\n        if (this._colors32.length > 0) {\r\n            ec = 1;\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n        const mesh = new Mesh(this.name, this._scene);\r\n        vertexData.applyToMesh(mesh, this._updatable);\r\n        this.mesh = mesh;\r\n\r\n        // free memory\r\n        (<any>this._positions) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n\r\n        if (!this._updatable) {\r\n            this.particles.length = 0;\r\n        }\r\n\r\n        let mat = material;\r\n\r\n        if (!mat) {\r\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\r\n            (<StandardMaterial>mat).emissiveColor = new Color3(ec, ec, ec);\r\n            (<StandardMaterial>mat).disableLighting = true;\r\n            (<StandardMaterial>mat).pointsCloud = true;\r\n            (<StandardMaterial>mat).pointSize = this._size;\r\n        }\r\n        mesh.material = mat;\r\n\r\n        return new Promise((resolve) => resolve(mesh));\r\n    }\r\n\r\n    // adds a new particle object in the particles array\r\n    private _addParticle(idx: number, group: PointsGroup, groupId: number, idxInGroup: number): CloudPoint {\r\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\r\n        this.particles.push(cp);\r\n        return cp;\r\n    }\r\n\r\n    private _randomUnitVector(particle: CloudPoint): void {\r\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\r\n        particle.color = new Color4(1, 1, 1, 1);\r\n    }\r\n\r\n    private _getColorIndicesForCoord(pointsGroup: PointsGroup, x: number, y: number, width: number): Color4 {\r\n        const imageData = <Uint8Array>pointsGroup._groupImageData;\r\n        const color = y * (width * 4) + x * 4;\r\n        const colorIndices = [color, color + 1, color + 2, color + 3];\r\n        const redIndex = colorIndices[0];\r\n        const greenIndex = colorIndices[1];\r\n        const blueIndex = colorIndices[2];\r\n        const alphaIndex = colorIndices[3];\r\n        const redForCoord = imageData[redIndex];\r\n        const greenForCoord = imageData[greenIndex];\r\n        const blueForCoord = imageData[blueIndex];\r\n        const alphaForCoord = imageData[alphaIndex];\r\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\r\n    }\r\n\r\n    private _setPointsColorOrUV(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean, colorFromTexture?: boolean, hasTexture?: boolean, color?: Color4, range?: number) {\r\n        if (isVolume) {\r\n            mesh.updateFacetData();\r\n        }\r\n\r\n        const boundInfo = mesh.getBoundingInfo();\r\n        const diameter = 2 * boundInfo.boundingSphere.radius;\r\n\r\n        let meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n        const meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind);\r\n        const meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const place = Vector3.Zero();\r\n        mesh.computeWorldMatrix();\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        if (!meshMatrix.isIdentity()) {\r\n            meshPos = meshPos.slice(0);\r\n            for (let p = 0; p < meshPos.length / 3; p++) {\r\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\r\n                meshPos[3 * p] = place.x;\r\n                meshPos[3 * p + 1] = place.y;\r\n                meshPos[3 * p + 2] = place.z;\r\n            }\r\n        }\r\n\r\n        let idxPoints: number = 0;\r\n\r\n        let id0: number = 0;\r\n        let id1: number = 0;\r\n        let id2: number = 0;\r\n        let v0X: number = 0;\r\n        let v0Y: number = 0;\r\n        let v0Z: number = 0;\r\n        let v1X: number = 0;\r\n        let v1Y: number = 0;\r\n        let v1Z: number = 0;\r\n        let v2X: number = 0;\r\n        let v2Y: number = 0;\r\n        let v2Z: number = 0;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n\r\n        let uv0X: number = 0;\r\n        let uv0Y: number = 0;\r\n        let uv1X: number = 0;\r\n        let uv1Y: number = 0;\r\n        let uv2X: number = 0;\r\n        let uv2Y: number = 0;\r\n        const uv0 = Vector2.Zero();\r\n        const uv1 = Vector2.Zero();\r\n        const uv2 = Vector2.Zero();\r\n        const uvec0 = Vector2.Zero();\r\n        const uvec1 = Vector2.Zero();\r\n\r\n        let col0X: number = 0;\r\n        let col0Y: number = 0;\r\n        let col0Z: number = 0;\r\n        let col0A: number = 0;\r\n        let col1X: number = 0;\r\n        let col1Y: number = 0;\r\n        let col1Z: number = 0;\r\n        let col1A: number = 0;\r\n        let col2X: number = 0;\r\n        let col2Y: number = 0;\r\n        let col2Z: number = 0;\r\n        let col2A: number = 0;\r\n        const col0 = Vector4.Zero();\r\n        const col1 = Vector4.Zero();\r\n        const col2 = Vector4.Zero();\r\n        const colvec0 = Vector4.Zero();\r\n        const colvec1 = Vector4.Zero();\r\n\r\n        let lamda: number = 0;\r\n        let mu: number = 0;\r\n        range = range ? range : 0;\r\n\r\n        let facetPoint: Vector3;\r\n        let uvPoint: Vector2;\r\n        let colPoint: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        let norm = Vector3.Zero();\r\n        let tang = Vector3.Zero();\r\n        let biNorm = Vector3.Zero();\r\n        let angle = 0;\r\n        let facetPlaneVec = Vector3.Zero();\r\n\r\n        let gap = 0;\r\n        let distance = 0;\r\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\r\n        let pickInfo: PickingInfo;\r\n        let direction = Vector3.Zero();\r\n\r\n        for (let index = 0; index < meshInd.length / 3; index++) {\r\n            id0 = meshInd[3 * index];\r\n            id1 = meshInd[3 * index + 1];\r\n            id2 = meshInd[3 * index + 2];\r\n            v0X = meshPos[3 * id0];\r\n            v0Y = meshPos[3 * id0 + 1];\r\n            v0Z = meshPos[3 * id0 + 2];\r\n            v1X = meshPos[3 * id1];\r\n            v1Y = meshPos[3 * id1 + 1];\r\n            v1Z = meshPos[3 * id1 + 2];\r\n            v2X = meshPos[3 * id2];\r\n            v2Y = meshPos[3 * id2 + 1];\r\n            v2Z = meshPos[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n\r\n            if (meshUV) {\r\n                uv0X = meshUV[2 * id0];\r\n                uv0Y = meshUV[2 * id0 + 1];\r\n                uv1X = meshUV[2 * id1];\r\n                uv1Y = meshUV[2 * id1 + 1];\r\n                uv2X = meshUV[2 * id2];\r\n                uv2Y = meshUV[2 * id2 + 1];\r\n                uv0.set(uv0X, uv0Y);\r\n                uv1.set(uv1X, uv1Y);\r\n                uv2.set(uv2X, uv2Y);\r\n                uv1.subtractToRef(uv0, uvec0);\r\n                uv2.subtractToRef(uv1, uvec1);\r\n            }\r\n\r\n            if (meshCol && colorFromTexture) {\r\n                col0X = meshCol[4 * id0];\r\n                col0Y = meshCol[4 * id0 + 1];\r\n                col0Z = meshCol[4 * id0 + 2];\r\n                col0A = meshCol[4 * id0 + 3];\r\n                col1X = meshCol[4 * id1];\r\n                col1Y = meshCol[4 * id1 + 1];\r\n                col1Z = meshCol[4 * id1 + 2];\r\n                col1A = meshCol[4 * id1 + 3];\r\n                col2X = meshCol[4 * id2];\r\n                col2Y = meshCol[4 * id2 + 1];\r\n                col2Z = meshCol[4 * id2 + 2];\r\n                col2A = meshCol[4 * id2 + 3];\r\n                col0.set(col0X, col0Y, col0Z, col0A);\r\n                col1.set(col1X, col1Y, col1Z, col1A);\r\n                col2.set(col2X, col2Y, col2Z, col2A);\r\n                col1.subtractToRef(col0, colvec0);\r\n                col2.subtractToRef(col1, colvec1);\r\n            }\r\n\r\n            let width: number;\r\n            let height: number;\r\n            let deltaS: number;\r\n            let deltaV: number;\r\n            let h: number;\r\n            let s: number;\r\n            let v: number;\r\n            let hsvCol: Color3;\r\n            const statedColor: Color3 = new Color3(0, 0, 0);\r\n            const colPoint3: Color3 = new Color3(0, 0, 0);\r\n            let pointColors: Color4;\r\n            let particle: CloudPoint;\r\n\r\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\r\n                idxPoints = this.particles.length;\r\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\r\n                particle = this.particles[idxPoints];\r\n                //form a point inside the facet v0, v1, v2;\r\n                lamda = Scalar.RandomRange(0, 1);\r\n                mu = Scalar.RandomRange(0, 1);\r\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\r\n                if (isVolume) {\r\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\r\n                    tang = vec0.clone().normalize();\r\n                    biNorm = Vector3.Cross(norm, tang);\r\n                    angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\r\n                    angle = Scalar.RandomRange(0.1, Math.PI / 2);\r\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\r\n\r\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\r\n                    ray.direction = direction;\r\n                    ray.length = diameter;\r\n                    pickInfo = ray.intersectsMesh(mesh);\r\n                    if (pickInfo.hit) {\r\n                        distance = pickInfo.pickedPoint!.subtract(facetPoint).length();\r\n                        gap = Scalar.RandomRange(0, 1) * distance;\r\n                        facetPoint.addInPlace(direction.scale(gap));\r\n                    }\r\n                }\r\n                particle.position = facetPoint.clone();\r\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\r\n                if (colorFromTexture !== undefined) {\r\n                    if (meshUV) {\r\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\r\n                        if (colorFromTexture) {\r\n                            //Set particle color to texture color\r\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\r\n                                width = pointsGroup._groupImgWidth;\r\n                                height = pointsGroup._groupImgHeight;\r\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\r\n                                particle.color = pointColors;\r\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\r\n                            } else {\r\n                                if (meshCol) {\r\n                                    //failure in texture and colors available\r\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                } else {\r\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            //Set particle uv based on a mesh uv\r\n                            particle.uv = uvPoint.clone();\r\n                            this._uvs.push(particle.uv.x, particle.uv.y);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (color) {\r\n                        statedColor.set(color.r, color.g, color.b);\r\n                        deltaS = Scalar.RandomRange(-range, range);\r\n                        deltaV = Scalar.RandomRange(-range, range);\r\n                        hsvCol = statedColor.toHSV();\r\n                        h = hsvCol.r;\r\n                        s = hsvCol.g + deltaS;\r\n                        v = hsvCol.b + deltaV;\r\n                        if (s < 0) {\r\n                            s = 0;\r\n                        }\r\n                        if (s > 1) {\r\n                            s = 1;\r\n                        }\r\n                        if (v < 0) {\r\n                            v = 0;\r\n                        }\r\n                        if (v > 1) {\r\n                            v = 1;\r\n                        }\r\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\r\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\r\n                    } else {\r\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                    }\r\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // stores mesh texture in dynamic texture for color pixel retrieval\r\n    // when pointColor type is color for surface points\r\n    private _colorFromTexture(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean): void {\r\n        if (mesh.material === null) {\r\n            Logger.Warn(mesh.name + \"has no material.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const mat = mesh.material;\r\n        const textureList: BaseTexture[] = mat.getActiveTextures();\r\n        if (textureList.length === 0) {\r\n            Logger.Warn(mesh.name + \"has no usable texture.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const clone = <Mesh>mesh.clone();\r\n        clone.setEnabled(false);\r\n        this._promises.push(\r\n            new Promise((resolve: (_: void) => void) => {\r\n                BaseTexture.WhenAllReady(textureList, () => {\r\n                    let n = pointsGroup._textureNb;\r\n                    if (n < 0) {\r\n                        n = 0;\r\n                    }\r\n                    if (n > textureList.length - 1) {\r\n                        n = textureList.length - 1;\r\n                    }\r\n                    const finalize = () => {\r\n                        pointsGroup._groupImgWidth = textureList[n].getSize().width;\r\n                        pointsGroup._groupImgHeight = textureList[n].getSize().height;\r\n                        this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true);\r\n                        clone.dispose();\r\n                        resolve();\r\n                    };\r\n                    pointsGroup._groupImageData = null;\r\n                    const dataPromise = textureList[n].readPixels();\r\n                    if (!dataPromise) {\r\n                        finalize();\r\n                    } else {\r\n                        dataPromise.then((data) => {\r\n                            pointsGroup._groupImageData = data;\r\n                            finalize();\r\n                        });\r\n                    }\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    // calculates the point density per facet of a mesh for surface points\r\n    private _calculateDensity(nbPoints: number, positions: FloatArray, indices: IndicesArray): number[] {\r\n        let density: number[] = new Array<number>();\r\n        let id0: number;\r\n        let id1: number;\r\n        let id2: number;\r\n        let v0X: number;\r\n        let v0Y: number;\r\n        let v0Z: number;\r\n        let v1X: number;\r\n        let v1Y: number;\r\n        let v1Z: number;\r\n        let v2X: number;\r\n        let v2Y: number;\r\n        let v2Z: number;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n        const vec2 = Vector3.Zero();\r\n\r\n        let a: number; //length of side of triangle\r\n        let b: number; //length of side of triangle\r\n        let c: number; //length of side of triangle\r\n        let p: number; //perimeter of triangle\r\n        let area: number;\r\n        const areas: number[] = new Array<number>();\r\n        let surfaceArea: number = 0;\r\n\r\n        const nbFacets = indices.length / 3;\r\n\r\n        //surface area\r\n        for (let index = 0; index < nbFacets; index++) {\r\n            id0 = indices[3 * index];\r\n            id1 = indices[3 * index + 1];\r\n            id2 = indices[3 * index + 2];\r\n            v0X = positions[3 * id0];\r\n            v0Y = positions[3 * id0 + 1];\r\n            v0Z = positions[3 * id0 + 2];\r\n            v1X = positions[3 * id1];\r\n            v1Y = positions[3 * id1 + 1];\r\n            v1Z = positions[3 * id1 + 2];\r\n            v2X = positions[3 * id2];\r\n            v2Y = positions[3 * id2 + 1];\r\n            v2Z = positions[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n            vertex2.subtractToRef(vertex0, vec2);\r\n            a = vec0.length();\r\n            b = vec1.length();\r\n            c = vec2.length();\r\n            p = (a + b + c) / 2;\r\n            area = Math.sqrt(p * (p - a) * (p - b) * (p - c));\r\n            surfaceArea += area;\r\n            areas[index] = area;\r\n        }\r\n        let pointCount: number = 0;\r\n        for (let index = 0; index < nbFacets; index++) {\r\n            density[index] = Math.floor((nbPoints * areas[index]) / surfaceArea);\r\n            pointCount += density[index];\r\n        }\r\n\r\n        const diff: number = nbPoints - pointCount;\r\n        const pointsPerFacet: number = Math.floor(diff / nbFacets);\r\n        const extraPoints: number = diff % nbFacets;\r\n\r\n        if (pointsPerFacet > 0) {\r\n            density = density.map((x) => x + pointsPerFacet);\r\n        }\r\n\r\n        for (let index = 0; index < extraPoints; index++) {\r\n            density[index] += 1;\r\n        }\r\n\r\n        return density;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS in random positions within a unit sphere\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addPoints(nb: number, pointFunction: any = this._randomUnitVector): number {\r\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\r\n        let cp: CloudPoint;\r\n\r\n        // particles\r\n        let idx = this.nbParticles;\r\n        for (let i = 0; i < nb; i++) {\r\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\r\n            if (pointsGroup && pointsGroup._positionFunction) {\r\n                pointsGroup._positionFunction(cp, idx, i);\r\n            }\r\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\r\n            if (cp.color) {\r\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\r\n            }\r\n            if (cp.uv) {\r\n                this._uvs.push(cp.uv.x, cp.uv.y);\r\n            }\r\n            idx++;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS from the surface of the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addSurfacePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS inside the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addVolumePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the PCS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): PointsCloudSystem {\r\n        if (!this._updatable || !this._isReady) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const uvs32 = this._uvs32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        let idx = 0; // current index of the particle\r\n\r\n        if (this.mesh?.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) {\r\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh?.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        idx = 0; // particle index\r\n        let pindex = 0; //index in positions array\r\n        let cindex = 0; //index in color array\r\n        let uindex = 0; //index in uv array\r\n\r\n        // particle loop\r\n        for (let p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n            idx = particle.idx;\r\n            pindex = 3 * idx;\r\n            cindex = 4 * idx;\r\n            uindex = 2 * idx;\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            if (this._computeParticleRotation) {\r\n                particle.getRotationMatrix(rotMatrix);\r\n            }\r\n\r\n            const particleHasParent = particle.parentId !== null;\r\n            if (particleHasParent) {\r\n                const parent = this.particles[particle.parentId!];\r\n                const parentRotationMatrix = parent._rotationMatrix;\r\n                const parentGlobalPosition = parent._globalPosition;\r\n\r\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[1] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[2] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[3] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[4] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[5] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[6] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[7] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[8] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                }\r\n            } else {\r\n                particleGlobalPosition.x = 0;\r\n                particleGlobalPosition.y = 0;\r\n                particleGlobalPosition.z = 0;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] = rotMatrixValues[0];\r\n                    particleRotationMatrix[1] = rotMatrixValues[1];\r\n                    particleRotationMatrix[2] = rotMatrixValues[2];\r\n                    particleRotationMatrix[3] = rotMatrixValues[4];\r\n                    particleRotationMatrix[4] = rotMatrixValues[5];\r\n                    particleRotationMatrix[5] = rotMatrixValues[6];\r\n                    particleRotationMatrix[6] = rotMatrixValues[8];\r\n                    particleRotationMatrix[7] = rotMatrixValues[9];\r\n                    particleRotationMatrix[8] = rotMatrixValues[10];\r\n                }\r\n            }\r\n\r\n            const pivotBackTranslation = tempVectors[11];\r\n            if (particle.translateFromPivot) {\r\n                pivotBackTranslation.setAll(0.0);\r\n            } else {\r\n                pivotBackTranslation.copyFrom(particle.pivot);\r\n            }\r\n\r\n            // positions\r\n            const tmpVertex = tempVectors[0];\r\n            tmpVertex.copyFrom(particle.position);\r\n            const vertexX = tmpVertex.x - particle.pivot.x;\r\n            const vertexY = tmpVertex.y - particle.pivot.y;\r\n            const vertexZ = tmpVertex.z - particle.pivot.z;\r\n\r\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n            rotatedX += pivotBackTranslation.x;\r\n            rotatedY += pivotBackTranslation.y;\r\n            rotatedZ += pivotBackTranslation.z;\r\n\r\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\r\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\r\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\r\n\r\n            if (this._computeBoundingBox) {\r\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n            }\r\n\r\n            if (this._computeParticleColor && particle.color) {\r\n                const color = particle.color;\r\n                const colors32 = this._colors32;\r\n                colors32[cindex] = color.r;\r\n                colors32[cindex + 1] = color.g;\r\n                colors32[cindex + 2] = color.b;\r\n                colors32[cindex + 3] = color.a;\r\n            }\r\n            if (this._computeParticleTexture && particle.uv) {\r\n                const uv = particle.uv;\r\n                const uvs32 = this._uvs32;\r\n                uvs32[uindex] = uv.x;\r\n                uvs32[uindex + 1] = uv.y;\r\n            }\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (mesh) {\r\n            if (update) {\r\n                if (this._computeParticleColor) {\r\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n                }\r\n                if (this._computeParticleTexture) {\r\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n                }\r\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n            }\r\n\r\n            if (this._computeBoundingBox) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\r\n                } else {\r\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n                }\r\n            }\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the PCS.\r\n     */\r\n    public dispose(): void {\r\n        this.mesh?.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc :\r\n     * @returns the PCS.\r\n     */\r\n    public refreshVisibleSize(): PointsCloudSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh?.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the PCS mesh bounding box.\r\n     * doc :\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        if (!this.mesh) {\r\n            return;\r\n        }\r\n\r\n        const vis = size / 2;\r\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        if (!this.mesh) {\r\n            return;\r\n        }\r\n\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by users to fit their needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The PCS doesn't call this function, you may have to call it by your own.\r\n     * doc :\r\n     */\r\n    public initParticles(): void {}\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle\r\n     * The PCS doesn't call this function, you can to call it\r\n     * doc :\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc :\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}