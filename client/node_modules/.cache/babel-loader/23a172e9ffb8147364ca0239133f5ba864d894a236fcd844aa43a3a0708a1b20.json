{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a hemisphere.\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\n */\nexport class HemisphericParticleEmitter {\n  /**\n   * Creates a new instance HemisphericParticleEmitter\n   * @param radius the radius of the emission hemisphere (1 by default)\n   * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  constructor(\n  /**\n   * The radius of the emission hemisphere.\n   */\n  radius = 1,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange = 1,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer = 0) {\n    this.radius = radius;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    const randX = Scalar.RandomRange(0, this.directionRandomizer);\n    const randY = Scalar.RandomRange(0, this.directionRandomizer);\n    const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    direction.x += randX;\n    direction.y += randY;\n    direction.z += randZ;\n    direction.normalize();\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n    const v = Scalar.RandomRange(0, 1.0);\n    const phi = Scalar.RandomRange(0, 2 * Math.PI);\n    const theta = Math.acos(2 * v - 1);\n    const randX = randRadius * Math.cos(phi) * Math.sin(theta);\n    const randY = randRadius * Math.cos(theta);\n    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define HEMISPHERICEMITTER\";\n  }\n  /**\n   * Returns the string \"HemisphericParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"HemisphericParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  }\n}","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","Scalar","HemisphericParticleEmitter","constructor","radius","radiusRange","directionRandomizer","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","direction","position","subtract","getTranslation","normalize","randX","RandomRange","randY","randZ","x","y","z","copyFrom","TransformNormalFromFloatsToRef","startPositionFunction","positionToUpdate","randRadius","v","phi","Math","PI","theta","acos","cos","sin","copyFromFloats","abs","TransformCoordinatesFromFloatsToRef","clone","newOne","DeepCopy","applyToShader","uboOrEffect","setFloat","buildUniformLayout","ubo","addUniform","getEffectDefines","getClassName","serialize","serializationObject","type","parse"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/EmitterTypes/hemisphericParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a hemisphere.\r\n * It emits the particles alongside the hemisphere radius. The emission direction might be randomized.\r\n */\r\nexport class HemisphericParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance HemisphericParticleEmitter\r\n     * @param radius the radius of the emission hemisphere (1 by default)\r\n     * @param radiusRange the range of the emission hemisphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission hemisphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): HemisphericParticleEmitter {\r\n        const newOne = new HemisphericParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define HEMISPHERICEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}