{"ast":null,"code":"import { SerializationHelper } from \"../../Misc/decorators.js\";\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools.js\";\nimport { InternalTextureSource } from \"./internalTexture.js\";\nimport { CubeTexture } from \"./cubeTexture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw cube texture where the raw buffers are passed in\n */\nexport class RawCubeTexture extends CubeTexture {\n  /**\n   * Creates a cube texture where the raw buffers are passed in.\n   * @param scene defines the scene the texture is attached to\n   * @param data defines the array of data to use to create each face\n   * @param size defines the size of the textures\n   * @param format defines the format of the data\n   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\n   * @param generateMipMaps  defines if the engine should generate the mip levels\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\n   * @param compression defines the compression used (null by default)\n   */\n  constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {\n    super(\"\", scene);\n    this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\n  }\n  /**\n   * Updates the raw cube texture.\n   * @param data defines the data to store\n   * @param format defines the data format\n   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param compression defines the compression used (null by default)\n   */\n  update(data, format, type, invertY, compression = null) {\n    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);\n  }\n  /**\n   * Updates a raw cube texture with RGBD encoded data.\n   * @param data defines the array of data [mipmap][face] to use to create each face\n   * @param sphericalPolynomial defines the spherical polynomial for irradiance\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @returns a promise that resolves when the operation is complete\n   */\n  updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {\n    return UpdateRGBDAsyncEnvTools(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => {});\n  }\n  /**\n   * Clones the raw cube texture.\n   * @returns a new cube texture\n   */\n  clone() {\n    return SerializationHelper.Clone(() => {\n      const scene = this.getScene();\n      const internalTexture = this._texture;\n      const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\n        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);\n      }\n      return texture;\n    }, this);\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,mBAAmB,QAAQ,0BAAwB;AAC5D,SAASC,gBAAgB,IAAIC,uBAAuB,QAAQ,uCAAqC;AAIjG,SAASC,qBAAqB,QAAQ,sBAAoB;AAC1D,SAASC,WAAW,QAAQ,kBAAgB;AAE5C,OAAO,+CAA6C;AAGpD;;;AAGA,OAAM,MAAOC,cAAe,SAAQD,WAAW;EAC3C;;;;;;;;;;;;EAYAE,YACIC,KAAY,EACZC,IAAiC,EACjCC,IAAY,EACZC,SAAiB,UAAU,kBAAkB,GAC7C,OAAeC,UAAU,uBAAwB,EACjDC,kBAA2B;IAK3B,KAAK,CAAC,EAAE,EAAEL,KAAK,CAAC;IAEhB,IAAI,CAACM,QAAQ,GAAGN,KAAK,CAACO,SAAS,EAAE,CAACC,oBAAoB,CAACP,IAAI,EAAEC,IAAI,EAAEC,MAAM,EAAEM,IAAI,EAAEC,eAAe,EAAEN,OAAO,EAAEO,YAAY,EAAEN,WAAW,CAAC;EACzI;EAEA;;;;;;;;EAQOO,MAAM,CAACX,IAAuB,EAAEE,MAAc,EAAEM,IAAY,EAAEL,OAAgB,EAAEC,cAAgC,IAAI;IACtH,IAAI,CAACC,QAAS,CAACC,SAAS,EAAa,CAACM,oBAAoB,CAAC,IAAI,CAACP,QAAS,EAAEL,IAAI,EAAEE,MAAM,EAAEM,IAAI,EAAEL,OAAO,EAAEC,WAAW,CAAC;EACzH;EAEA;;;;;;;;EAQOS,eAAe,CAACb,IAAyB,EAAEc,sBAAqD,IAAI,EAAEC,WAAmB,GAAG,EAAEC,YAAoB,CAAC;IACtJ,OAAOtB,uBAAuB,CAAC,IAAI,CAACW,QAAS,EAAEL,IAAI,EAAEc,mBAAmB,EAAEC,QAAQ,EAAEC,SAAS,CAAC,CAACC,IAAI,CAAC,MAAK,CAAE,CAAC,CAAC;EACjH;EAEA;;;;EAIOC,KAAK;IACR,OAAO1B,mBAAmB,CAAC2B,KAAK,CAAC,MAAK;MAClC,MAAMpB,KAAK,GAAG,IAAI,CAACqB,QAAQ,EAAG;MAC9B,MAAMC,eAAe,GAAG,IAAI,CAAChB,QAAS;MAEtC,MAAMiB,OAAO,GAAG,IAAIzB,cAAc,CAC9BE,KAAK,EACLsB,eAAe,CAACE,gBAAiB,EACjCF,eAAe,CAACG,KAAK,EACrBH,eAAe,CAACnB,MAAM,EACtBmB,eAAe,CAACb,IAAI,EACpBa,eAAe,CAACZ,eAAe,EAC/BY,eAAe,CAAClB,OAAO,EACvBkB,eAAe,CAACX,YAAY,EAC5BW,eAAe,CAACI,YAAY,CAC/B;MAED,IAAIJ,eAAe,CAACK,MAAM,KAAK/B,qBAAqB,CAACgC,WAAW,EAAE;QAC9DL,OAAO,CAACT,eAAe,CACnBQ,eAAe,CAACO,qBAAsB,EACtCP,eAAe,CAACQ,oBAAoB,EACpCR,eAAe,CAACS,mBAAmB,EACnCT,eAAe,CAACU,oBAAoB,CACvC;;MAGL,OAAOT,OAAO;IAClB,CAAC,EAAE,IAAI,CAAC;EACZ","names":["SerializationHelper","_UpdateRGBDAsync","UpdateRGBDAsyncEnvTools","InternalTextureSource","CubeTexture","RawCubeTexture","constructor","scene","data","size","format","invertY","compression","_texture","getEngine","createRawCubeTexture","type","generateMipMaps","samplingMode","update","updateRawCubeTexture","updateRGBDAsync","sphericalPolynomial","lodScale","lodOffset","then","clone","Clone","getScene","internalTexture","texture","_bufferViewArray","width","_compression","source","CubeRawRGBD","_bufferViewArrayArray","_sphericalPolynomial","_lodGenerationScale","_lodGenerationOffset"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/rawCubeTexture.ts"],"sourcesContent":["import { SerializationHelper } from \"../../Misc/decorators\";\r\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { InternalTextureSource } from \"./internalTexture\";\r\nimport { CubeTexture } from \"./cubeTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n\r\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\r\nexport class RawCubeTexture extends CubeTexture {\r\n    /**\r\n     * Creates a cube texture where the raw buffers are passed in.\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        generateMipMaps: boolean = false,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        compression: Nullable<string> = null\r\n    ) {\r\n        super(\"\", scene);\r\n\r\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates the raw cube texture.\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    public update(data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null): void {\r\n        (this._texture!.getEngine() as Engine).updateRawCubeTexture(this._texture!, data, format, type, invertY, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates a raw cube texture with RGBD encoded data.\r\n     * @param data defines the array of data [mipmap][face] to use to create each face\r\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n    public updateRGBDAsync(data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial> = null, lodScale: number = 0.8, lodOffset: number = 0): Promise<void> {\r\n        return UpdateRGBDAsyncEnvTools(this._texture!, data, sphericalPolynomial, lodScale, lodOffset).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Clones the raw cube texture.\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        return SerializationHelper.Clone(() => {\r\n            const scene = this.getScene()!;\r\n            const internalTexture = this._texture!;\r\n\r\n            const texture = new RawCubeTexture(\r\n                scene,\r\n                internalTexture._bufferViewArray!,\r\n                internalTexture.width,\r\n                internalTexture.format,\r\n                internalTexture.type,\r\n                internalTexture.generateMipMaps,\r\n                internalTexture.invertY,\r\n                internalTexture.samplingMode,\r\n                internalTexture._compression\r\n            );\r\n\r\n            if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\r\n                texture.updateRGBDAsync(\r\n                    internalTexture._bufferViewArrayArray!,\r\n                    internalTexture._sphericalPolynomial,\r\n                    internalTexture._lodGenerationScale,\r\n                    internalTexture._lodGenerationOffset\r\n                );\r\n            }\r\n\r\n            return texture;\r\n        }, this);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}