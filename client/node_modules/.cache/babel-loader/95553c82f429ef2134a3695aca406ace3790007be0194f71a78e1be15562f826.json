{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { DracoCompression } from \"@babylonjs/core/Meshes/Compression/dracoCompression.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"KHR_draco_mesh_compression\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    delete this.dracoCompression;\n    this._loader = null;\n  }\n  /**\n   * @internal\n   */\n  _loadVertexDataAsync(context, primitive, babylonMesh) {\n    return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, (extensionContext, extension) => {\n      if (primitive.mode != undefined) {\n        if (primitive.mode !== 5 /* TRIANGLE_STRIP */ && primitive.mode !== 4 /* TRIANGLES */) {\n          throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\n        }\n        // TODO: handle triangle strips\n        if (primitive.mode === 5 /* TRIANGLE_STRIP */) {\n          throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);\n        }\n      }\n      const attributes = {};\n      const dividers = {};\n      const loadAttribute = (name, kind) => {\n        const uniqueId = extension.attributes[name];\n        if (uniqueId === undefined || primitive.attributes[name] === undefined) {\n          return;\n        }\n        attributes[kind] = uniqueId;\n        const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._loader.gltf.accessors, primitive.attributes[name]);\n        if (accessor.normalized && accessor.componentType !== 5126 /* FLOAT */) {\n          let divider = 1;\n          switch (accessor.componentType) {\n            case 5120 /* BYTE */:\n              divider = 127.0;\n              break;\n            case 5121 /* UNSIGNED_BYTE */:\n              divider = 255.0;\n              break;\n            case 5122 /* SHORT */:\n              divider = 32767.0;\n              break;\n            case 5123 /* UNSIGNED_SHORT */:\n              divider = 65535.0;\n              break;\n          }\n          dividers[kind] = divider;\n        }\n        babylonMesh._delayInfo = babylonMesh._delayInfo || [];\n        if (babylonMesh._delayInfo.indexOf(kind) === -1) {\n          babylonMesh._delayInfo.push(kind);\n        }\n      };\n      loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\n      loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\n      loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\n      loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\n      loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\n      loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\n      loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\n      loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\n      loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\n      loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\n      loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\n      loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\n      const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);\n      if (!bufferView._dracoBabylonGeometry) {\n        bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(data => {\n          const dracoCompression = this.dracoCompression || DracoCompression.Default;\n          return dracoCompression.decodeMeshAsync(data, attributes, dividers).then(babylonVertexData => {\n            const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);\n            babylonVertexData.applyToGeometry(babylonGeometry);\n            return babylonGeometry;\n          }).catch(error => {\n            throw new Error(`${context}: ${error.message}`);\n          });\n        });\n      }\n      return bufferView._dracoBabylonGeometry;\n    });\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new KHR_draco_mesh_compression(loader));","map":{"version":3,"mappings":"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","names":["DracoCompression","VertexBuffer","Geometry","GLTFLoader","ArrayItem","NAME","KHR_draco_mesh_compression","constructor","loader","_loader","enabled","DecoderAvailable","isExtensionUsed","dispose","dracoCompression","_loadVertexDataAsync","context","primitive","babylonMesh","LoadExtensionAsync","name","extensionContext","extension","mode","undefined","Error","attributes","dividers","loadAttribute","kind","uniqueId","accessor","Get","gltf","accessors","normalized","componentType","divider","_delayInfo","indexOf","push","PositionKind","NormalKind","TangentKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","MatricesIndicesKind","MatricesWeightsKind","ColorKind","bufferView","bufferViews","_dracoBabylonGeometry","loadBufferViewAsync","index","then","data","Default","decodeMeshAsync","babylonVertexData","babylonGeometry","babylonScene","applyToGeometry","catch","error","message","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts"],"sourcesContent":["import { DracoCompression } from \"core/Meshes/Compression/dracoCompression\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport { MeshPrimitiveMode, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IKHRDracoMeshCompression } from \"babylonjs-gltf2interface\";\r\nimport type { IMeshPrimitive, IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_draco_mesh_compression\";\r\n\r\ninterface IBufferViewDraco extends IBufferView {\r\n    _dracoBabylonGeometry?: Promise<Geometry>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_draco_mesh_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * The draco compression used to decode vertex data or DracoCompression.Default if not defined\r\n     */\r\n    public dracoCompression?: DracoCompression;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        delete this.dracoCompression;\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRDracoMeshCompression, Geometry>(context, primitive, this.name, (extensionContext, extension) => {\r\n            if (primitive.mode != undefined) {\r\n                if (primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP && primitive.mode !== MeshPrimitiveMode.TRIANGLES) {\r\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\r\n                }\r\n\r\n                // TODO: handle triangle strips\r\n                if (primitive.mode === MeshPrimitiveMode.TRIANGLE_STRIP) {\r\n                    throw new Error(`${context}: Mode ${primitive.mode} is not currently supported`);\r\n                }\r\n            }\r\n\r\n            const attributes: {\r\n                [kind: string]: number;\r\n            } = {};\r\n            const dividers: {\r\n                [kind: string]: number;\r\n            } = {};\r\n            const loadAttribute = (name: string, kind: string) => {\r\n                const uniqueId = extension.attributes[name];\r\n                if (uniqueId === undefined || primitive.attributes[name] === undefined) {\r\n                    return;\r\n                }\r\n\r\n                attributes[kind] = uniqueId;\r\n                const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._loader.gltf.accessors, primitive.attributes[name]);\r\n                if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n                    let divider = 1;\r\n                    switch (accessor.componentType) {\r\n                        case AccessorComponentType.BYTE:\r\n                            divider = 127.0;\r\n                            break;\r\n                        case AccessorComponentType.UNSIGNED_BYTE:\r\n                            divider = 255.0;\r\n                            break;\r\n                        case AccessorComponentType.SHORT:\r\n                            divider = 32767.0;\r\n                            break;\r\n                        case AccessorComponentType.UNSIGNED_SHORT:\r\n                            divider = 65535.0;\r\n                            break;\r\n                    }\r\n                    dividers[kind] = divider;\r\n                }\r\n\r\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                    babylonMesh._delayInfo.push(kind);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\r\n\r\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView) as IBufferViewDraco;\r\n            if (!bufferView._dracoBabylonGeometry) {\r\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                    const dracoCompression = this.dracoCompression || DracoCompression.Default;\r\n                    return dracoCompression\r\n                        .decodeMeshAsync(data, attributes, dividers)\r\n                        .then((babylonVertexData) => {\r\n                            const babylonGeometry = new Geometry(babylonMesh.name, this._loader.babylonScene);\r\n                            babylonVertexData.applyToGeometry(babylonGeometry);\r\n                            return babylonGeometry;\r\n                        })\r\n                        .catch((error) => {\r\n                            throw new Error(`${context}: ${error.message}`);\r\n                        });\r\n                });\r\n            }\r\n\r\n            return bufferView._dracoBabylonGeometry;\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_draco_mesh_compression(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}