{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh.js\";\nimport { GoldbergMesh } from \"../goldbergMesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the Mesh for a Goldberg Polyhedron\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\n * @returns GoldbergSphere mesh\n */\nexport function CreateGoldbergVertexData(options, goldbergData) {\n  const size = options.size;\n  const sizeX = options.sizeX || size || 1;\n  const sizeY = options.sizeY || size || 1;\n  const sizeZ = options.sizeZ || size || 1;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const positions = new Array();\n  const indices = new Array();\n  const normals = new Array();\n  const uvs = new Array();\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n  for (let v = 0; v < goldbergData.vertex.length; v++) {\n    minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\n    maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\n    minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\n    maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\n  }\n  let index = 0;\n  for (let f = 0; f < goldbergData.face.length; f++) {\n    const verts = goldbergData.face[f];\n    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n    const ba = b.subtract(a);\n    const ca = c.subtract(a);\n    const norm = Vector3.Cross(ca, ba).normalize();\n    for (let v = 0; v < verts.length; v++) {\n      normals.push(norm.x, norm.y, norm.z);\n      const pdata = goldbergData.vertex[verts[v]];\n      positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\n      const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\n      uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\n    }\n    for (let v = 0; v < verts.length - 2; v++) {\n      indices.push(index, index + v + 2, index + v + 1);\n    }\n    index += verts.length;\n  }\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n  const vertexData = new VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n * @param scene defines the hosting scene\n * @returns Goldberg mesh\n */\nexport function CreateGoldberg(name, options, scene = null) {\n  const size = options.size;\n  const sizeX = options.sizeX || size || 1;\n  const sizeY = options.sizeY || size || 1;\n  const sizeZ = options.sizeZ || size || 1;\n  let m = options.m || 1;\n  if (m !== Math.floor(m)) {\n    m === Math.floor(m);\n    Logger.Warn(\"m not an integer only floor(m) used\");\n  }\n  let n = options.n || 0;\n  if (n !== Math.floor(n)) {\n    n === Math.floor(n);\n    Logger.Warn(\"n not an integer only floor(n) used\");\n  }\n  if (n > m) {\n    const temp = n;\n    n = m;\n    m = temp;\n    Logger.Warn(\"n > m therefore m and n swapped\");\n  }\n  const primTri = new _PrimaryIsoTriangle();\n  primTri.build(m, n);\n  const geodesicData = GeodesicData.BuildGeodesicData(primTri);\n  const goldbergData = geodesicData.toGoldbergPolyhedronData();\n  const goldberg = new GoldbergMesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  goldberg._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateGoldbergVertexData(options, goldbergData);\n  vertexData.applyToMesh(goldberg, options.updatable);\n  goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\n  goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\n  goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\n  goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\n  goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\n  for (let f = 0; f < geodesicData.vertex.length; f++) {\n    goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\n    goldberg.goldbergData.faceCenters[f].x *= sizeX;\n    goldberg.goldbergData.faceCenters[f].y *= sizeY;\n    goldberg.goldbergData.faceCenters[f].z *= sizeZ;\n    goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\n  }\n  for (let f = 0; f < goldbergData.face.length; f++) {\n    const verts = goldbergData.face[f];\n    const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\n    const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\n    const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\n    const ba = b.subtract(a);\n    const ca = c.subtract(a);\n    const norm = Vector3.Cross(ca, ba).normalize();\n    const z = Vector3.Cross(ca, norm).normalize();\n    goldberg.goldbergData.faceXaxis.push(ca.normalize());\n    goldberg.goldbergData.faceYaxis.push(norm);\n    goldberg.goldbergData.faceZaxis.push(z);\n  }\n  return goldberg;\n}\nMesh.CreateGoldberg = CreateGoldberg;","map":{"version":3,"mappings":"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","names":["Vector3","Color4","Mesh","VertexData","Logger","_PrimaryIsoTriangle","GeodesicData","GoldbergMesh","CompatibilityOptions","CreateGoldbergVertexData","options","goldbergData","size","sizeX","sizeY","sizeZ","sideOrientation","DEFAULTSIDE","positions","Array","indices","normals","uvs","minX","Infinity","maxX","minY","maxY","v","vertex","length","Math","min","max","index","f","face","verts","a","FromArray","b","c","ba","subtract","ca","norm","Cross","normalize","push","x","y","z","pdata","vCoord","UseOpenGLOrientationForUV","_ComputeSides","vertexData","CreateGoldberg","name","scene","m","floor","Warn","n","temp","primTri","build","geodesicData","BuildGeodesicData","toGoldbergPolyhedronData","goldberg","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","nbSharedFaces","sharedNodes","nbUnsharedFaces","poleNodes","adjacentFaces","nbFaces","nbFacesAtPole","faceCenters","faceColors","faceXaxis","faceYaxis","faceZaxis"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/goldbergBuilder.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { PolyhedronData } from \"../geodesicMesh\";\r\nimport { _PrimaryIsoTriangle, GeodesicData } from \"../geodesicMesh\";\r\nimport { GoldbergMesh } from \"../goldbergMesh\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Defines the set of data required to create goldberg vertex data.\r\n */\r\nexport type GoldbergVertexDataOption = {\r\n    /**\r\n     * the size of the Goldberg, optional default 1\r\n     */\r\n    size?: number;\r\n    /**\r\n     * allows stretching in the x direction, optional, default size\r\n     */\r\n    sizeX?: number;\r\n    /**\r\n     * allows stretching in the y direction, optional, default size\r\n     */\r\n    sizeY?: number;\r\n    /**\r\n     * allows stretching in the z direction, optional, default size\r\n     */\r\n    sizeZ?: number;\r\n    /**\r\n     * optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     */\r\n    sideOrientation?: number;\r\n};\r\n\r\n/**\r\n * Defines the set of data required to create a goldberg mesh.\r\n */\r\nexport type GoldbergCreationOption = {\r\n    /**\r\n     * number of horizontal steps along an isogrid\r\n     */\r\n    m?: number;\r\n    /**\r\n     * number of angled steps along an isogrid\r\n     */\r\n    n?: number;\r\n    /**\r\n     * defines if the mesh must be flagged as updatable\r\n     */\r\n    updatable?: boolean;\r\n} & GoldbergVertexDataOption;\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param goldbergData polyhedronData defining the Goldberg polyhedron\r\n * @returns GoldbergSphere mesh\r\n */\r\nexport function CreateGoldbergVertexData(options: GoldbergVertexDataOption, goldbergData: PolyhedronData): VertexData {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const positions = new Array<number>();\r\n    const indices = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    let minX = Infinity;\r\n    let maxX = -Infinity;\r\n    let minY = Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    for (let v = 0; v < goldbergData.vertex.length; v++) {\r\n        minX = Math.min(minX, goldbergData.vertex[v][0] * sizeX);\r\n        maxX = Math.max(maxX, goldbergData.vertex[v][0] * sizeX);\r\n        minY = Math.min(minY, goldbergData.vertex[v][1] * sizeY);\r\n        maxY = Math.max(maxY, goldbergData.vertex[v][1] * sizeY);\r\n    }\r\n\r\n    let index: number = 0;\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        for (let v = 0; v < verts.length; v++) {\r\n            normals.push(norm.x, norm.y, norm.z);\r\n            const pdata = goldbergData.vertex[verts[v]];\r\n            positions.push(pdata[0] * sizeX, pdata[1] * sizeY, pdata[2] * sizeZ);\r\n            const vCoord = (pdata[1] * sizeY - minY) / (maxY - minY);\r\n            uvs.push((pdata[0] * sizeX - minX) / (maxX - minX), CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - vCoord : vCoord);\r\n        }\r\n        for (let v = 0; v < verts.length - 2; v++) {\r\n            indices.push(index, index + v + 2, index + v + 1);\r\n        }\r\n        index += verts.length;\r\n    }\r\n\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/polyhedra/goldberg_poly\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n * @param scene defines the hosting scene\r\n * @returns Goldberg mesh\r\n */\r\nexport function CreateGoldberg(name: string, options: GoldbergCreationOption, scene: Nullable<Scene> = null): GoldbergMesh {\r\n    const size = options.size;\r\n    const sizeX: number = options.sizeX || size || 1;\r\n    const sizeY: number = options.sizeY || size || 1;\r\n    const sizeZ: number = options.sizeZ || size || 1;\r\n    let m: number = options.m || 1;\r\n    if (m !== Math.floor(m)) {\r\n        m === Math.floor(m);\r\n        Logger.Warn(\"m not an integer only floor(m) used\");\r\n    }\r\n    let n: number = options.n || 0;\r\n    if (n !== Math.floor(n)) {\r\n        n === Math.floor(n);\r\n        Logger.Warn(\"n not an integer only floor(n) used\");\r\n    }\r\n    if (n > m) {\r\n        const temp = n;\r\n        n = m;\r\n        m = temp;\r\n        Logger.Warn(\"n > m therefore m and n swapped\");\r\n    }\r\n    const primTri: _PrimaryIsoTriangle = new _PrimaryIsoTriangle();\r\n    primTri.build(m, n);\r\n    const geodesicData = GeodesicData.BuildGeodesicData(primTri);\r\n    const goldbergData = geodesicData.toGoldbergPolyhedronData();\r\n\r\n    const goldberg = new GoldbergMesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    goldberg._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateGoldbergVertexData(options, goldbergData);\r\n\r\n    vertexData.applyToMesh(goldberg, options.updatable);\r\n\r\n    goldberg.goldbergData.nbSharedFaces = geodesicData.sharedNodes;\r\n    goldberg.goldbergData.nbUnsharedFaces = geodesicData.poleNodes;\r\n    goldberg.goldbergData.adjacentFaces = geodesicData.adjacentFaces;\r\n    goldberg.goldbergData.nbFaces = goldberg.goldbergData.nbSharedFaces + goldberg.goldbergData.nbUnsharedFaces;\r\n    goldberg.goldbergData.nbFacesAtPole = (goldberg.goldbergData.nbUnsharedFaces - 12) / 12;\r\n    for (let f = 0; f < geodesicData.vertex.length; f++) {\r\n        goldberg.goldbergData.faceCenters.push(Vector3.FromArray(geodesicData.vertex[f]));\r\n        goldberg.goldbergData.faceCenters[f].x *= sizeX;\r\n        goldberg.goldbergData.faceCenters[f].y *= sizeY;\r\n        goldberg.goldbergData.faceCenters[f].z *= sizeZ;\r\n        goldberg.goldbergData.faceColors.push(new Color4(1, 1, 1, 1));\r\n    }\r\n\r\n    for (let f = 0; f < goldbergData.face.length; f++) {\r\n        const verts = goldbergData.face[f];\r\n        const a = Vector3.FromArray(goldbergData.vertex[verts[0]]);\r\n        const b = Vector3.FromArray(goldbergData.vertex[verts[2]]);\r\n        const c = Vector3.FromArray(goldbergData.vertex[verts[1]]);\r\n        const ba = b.subtract(a);\r\n        const ca = c.subtract(a);\r\n        const norm = Vector3.Cross(ca, ba).normalize();\r\n        const z = Vector3.Cross(ca, norm).normalize();\r\n        goldberg.goldbergData.faceXaxis.push(ca.normalize());\r\n        goldberg.goldbergData.faceYaxis.push(norm);\r\n        goldberg.goldbergData.faceZaxis.push(z);\r\n    }\r\n\r\n    return goldberg;\r\n}\r\n\r\n(Mesh as any).CreateGoldberg = CreateGoldberg;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}