{"ast":null,"code":"import { PostProcess } from \"./postProcess.js\";\nimport \"../Shaders/tonemap.fragment.js\";\n/** Defines operator used for tonemapping */\nexport var TonemappingOperator;\n(function (TonemappingOperator) {\n  /** Hable */\n  TonemappingOperator[TonemappingOperator[\"Hable\"] = 0] = \"Hable\";\n  /** Reinhard */\n  TonemappingOperator[TonemappingOperator[\"Reinhard\"] = 1] = \"Reinhard\";\n  /** HejiDawson */\n  TonemappingOperator[TonemappingOperator[\"HejiDawson\"] = 2] = \"HejiDawson\";\n  /** Photographic */\n  TonemappingOperator[TonemappingOperator[\"Photographic\"] = 3] = \"Photographic\";\n})(TonemappingOperator || (TonemappingOperator = {}));\n/**\n * Defines a post process to apply tone mapping\n */\nexport class TonemapPostProcess extends PostProcess {\n  /**\n   * Creates a new TonemapPostProcess\n   * @param name defines the name of the postprocess\n   * @param _operator defines the operator to use\n   * @param exposureAdjustment defines the required exposure adjustment\n   * @param camera defines the camera to use (can be null)\n   * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)\n   * @param engine defines the hosting engine (can be ignore if camera is set)\n   * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   */\n  constructor(name, _operator, /** Defines the required exposure adjustment */\n  exposureAdjustment, camera, samplingMode = 2, engine, textureFormat = 0, reusable) {\n    super(name, \"tonemap\", [\"_ExposureAdjustment\"], null, 1.0, camera, samplingMode, engine, reusable, null, textureFormat);\n    this._operator = _operator;\n    this.exposureAdjustment = exposureAdjustment;\n    let defines = \"#define \";\n    if (this._operator === TonemappingOperator.Hable) {\n      defines += \"HABLE_TONEMAPPING\";\n    } else if (this._operator === TonemappingOperator.Reinhard) {\n      defines += \"REINHARD_TONEMAPPING\";\n    } else if (this._operator === TonemappingOperator.HejiDawson) {\n      defines += \"OPTIMIZED_HEJIDAWSON_TONEMAPPING\";\n    } else if (this._operator === TonemappingOperator.Photographic) {\n      defines += \"PHOTOGRAPHIC_TONEMAPPING\";\n    }\n    //sadly a second call to create the effect.\n    this.updateEffect(defines);\n    this.onApply = effect => {\n      effect.setFloat(\"_ExposureAdjustment\", this.exposureAdjustment);\n    };\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"TonemapPostProcess\" string\n   */\n  getClassName() {\n    return \"TonemapPostProcess\";\n  }\n}","map":{"version":3,"mappings":"AAEA,SAASA,WAAW,QAAQ,kBAAgB;AAG5C,OAAO,gCAA8B;AAKrC;AACA,WAAYC,mBASX;AATD,WAAYA,mBAAmB;EAC3B;EACAA,+DAAS;EACT;EACAA,qEAAY;EACZ;EACAA,yEAAc;EACd;EACAA,6EAAgB;AACpB,CAAC,EATWA,mBAAmB,KAAnBA,mBAAmB;AAW/B;;;AAGA,OAAM,MAAOC,kBAAmB,SAAQF,WAAW;EAS/C;;;;;;;;;;;EAWAG,YACIC,IAAY,EACJC,SAA8B,EACtC;EACOC,kBAA0B,EACjCC,MAAwB,EACxBC,eAAuB,SAAS,EAACC,6BAA6B;IAK9D,KAAK,CAACL,IAAI,EAAE,SAAS,EAAE,CAAC,qBAAqB,CAAC,EAAE,IAAI,EAAE,GAAG,EAAEG,MAAM,EAAEC,YAAY,EAAEE,MAAM,EAAEC,QAAQ,EAAE,IAAI,EAAEF,aAAa,CAAC;IAT/G,cAAS,GAATJ,SAAS;IAEV,uBAAkB,GAAlBC,kBAAkB;IASzB,IAAIM,OAAO,GAAG,UAAU;IAExB,IAAI,IAAI,CAACP,SAAS,KAAKJ,mBAAmB,CAACY,KAAK,EAAE;MAC9CD,OAAO,IAAI,mBAAmB;KACjC,MAAM,IAAI,IAAI,CAACP,SAAS,KAAKJ,mBAAmB,CAACa,QAAQ,EAAE;MACxDF,OAAO,IAAI,sBAAsB;KACpC,MAAM,IAAI,IAAI,CAACP,SAAS,KAAKJ,mBAAmB,CAACc,UAAU,EAAE;MAC1DH,OAAO,IAAI,kCAAkC;KAChD,MAAM,IAAI,IAAI,CAACP,SAAS,KAAKJ,mBAAmB,CAACe,YAAY,EAAE;MAC5DJ,OAAO,IAAI,0BAA0B;;IAGzC;IACA,IAAI,CAACK,YAAY,CAACL,OAAO,CAAC;IAE1B,IAAI,CAACM,OAAO,GAAIC,MAAc,IAAI;MAC9BA,MAAM,CAACC,QAAQ,CAAC,qBAAqB,EAAE,IAAI,CAACd,kBAAkB,CAAC;IACnE,CAAC;EACL;EAlDA;;;;EAIOe,YAAY;IACf,OAAO,oBAAoB;EAC/B","names":["PostProcess","TonemappingOperator","TonemapPostProcess","constructor","name","_operator","exposureAdjustment","camera","samplingMode","textureFormat","engine","reusable","defines","Hable","Reinhard","HejiDawson","Photographic","updateEffect","onApply","effect","setFloat","getClassName"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/tonemapPostProcess.ts"],"sourcesContent":["import type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/tonemap.fragment\";\r\nimport type { Nullable } from \"../types\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/** Defines operator used for tonemapping */\r\nexport enum TonemappingOperator {\r\n    /** Hable */\r\n    Hable = 0,\r\n    /** Reinhard */\r\n    Reinhard = 1,\r\n    /** HejiDawson */\r\n    HejiDawson = 2,\r\n    /** Photographic */\r\n    Photographic = 3,\r\n}\r\n\r\n/**\r\n * Defines a post process to apply tone mapping\r\n */\r\nexport class TonemapPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"TonemapPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"TonemapPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new TonemapPostProcess\r\n     * @param name defines the name of the postprocess\r\n     * @param _operator defines the operator to use\r\n     * @param exposureAdjustment defines the required exposure adjustment\r\n     * @param camera defines the camera to use (can be null)\r\n     * @param samplingMode defines the required sampling mode (BABYLON.Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param engine defines the hosting engine (can be ignore if camera is set)\r\n     * @param textureFormat defines the texture format to use (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        private _operator: TonemappingOperator,\r\n        /** Defines the required exposure adjustment */\r\n        public exposureAdjustment: number,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        textureFormat = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        reusable?: boolean\r\n    ) {\r\n        super(name, \"tonemap\", [\"_ExposureAdjustment\"], null, 1.0, camera, samplingMode, engine, reusable, null, textureFormat);\r\n\r\n        let defines = \"#define \";\r\n\r\n        if (this._operator === TonemappingOperator.Hable) {\r\n            defines += \"HABLE_TONEMAPPING\";\r\n        } else if (this._operator === TonemappingOperator.Reinhard) {\r\n            defines += \"REINHARD_TONEMAPPING\";\r\n        } else if (this._operator === TonemappingOperator.HejiDawson) {\r\n            defines += \"OPTIMIZED_HEJIDAWSON_TONEMAPPING\";\r\n        } else if (this._operator === TonemappingOperator.Photographic) {\r\n            defines += \"PHOTOGRAPHIC_TONEMAPPING\";\r\n        }\r\n\r\n        //sadly a second call to create the effect.\r\n        this.updateEffect(defines);\r\n\r\n        this.onApply = (effect: Effect) => {\r\n            effect.setFloat(\"_ExposureAdjustment\", this.exposureAdjustment);\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}