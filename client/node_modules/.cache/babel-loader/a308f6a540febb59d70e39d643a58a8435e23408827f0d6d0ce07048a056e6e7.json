{"ast":null,"code":"import { PointerDragBehavior } from \"./pointerDragBehavior.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that when attached to a mesh will allow the mesh to be scaled\n */\nexport class MultiPointerScaleBehavior {\n  /**\n   * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\n   */\n  constructor() {\n    this._startDistance = 0;\n    this._initialScale = new Vector3(0, 0, 0);\n    this._targetScale = new Vector3(0, 0, 0);\n    this._sceneRenderObserver = null;\n    this._dragBehaviorA = new PointerDragBehavior({});\n    this._dragBehaviorA.moveAttached = false;\n    this._dragBehaviorB = new PointerDragBehavior({});\n    this._dragBehaviorB.moveAttached = false;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"MultiPointerScale\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  _getCurrentDistance() {\n    return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\n  }\n  /**\n   * Attaches the scale behavior the passed in mesh\n   * @param ownerNode The mesh that will be scaled around once attached\n   */\n  attach(ownerNode) {\n    this._ownerNode = ownerNode;\n    // Create 2 drag behaviors such that each will only be triggered by a separate pointer\n    this._dragBehaviorA.onDragStartObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n          this._dragBehaviorA.releaseDrag();\n        } else {\n          this._initialScale.copyFrom(ownerNode.scaling);\n          this._startDistance = this._getCurrentDistance();\n        }\n      }\n    });\n    this._dragBehaviorB.onDragStartObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\n          this._dragBehaviorB.releaseDrag();\n        } else {\n          this._initialScale.copyFrom(ownerNode.scaling);\n          this._startDistance = this._getCurrentDistance();\n        }\n      }\n    });\n    // Once both drag behaviors are active scale based on the distance between the two pointers\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(behavior => {\n      behavior.onDragObservable.add(() => {\n        if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n          const ratio = this._getCurrentDistance() / this._startDistance;\n          this._initialScale.scaleToRef(ratio, this._targetScale);\n        }\n      });\n    });\n    ownerNode.addBehavior(this._dragBehaviorA);\n    ownerNode.addBehavior(this._dragBehaviorB);\n    // On every frame move towards target scaling to avoid jitter caused by vr controllers\n    this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\n      if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\n        const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\n        if (change.length() > 0.01) {\n          ownerNode.scaling.addInPlace(change);\n        }\n      }\n    });\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\n    [this._dragBehaviorA, this._dragBehaviorB].forEach(behavior => {\n      behavior.onDragStartObservable.clear();\n      behavior.onDragObservable.clear();\n      this._ownerNode.removeBehavior(behavior);\n    });\n  }\n}","map":{"version":3,"mappings":"AAEA,SAASA,mBAAmB,QAAQ,0BAAwB;AAC5D,SAASC,OAAO,QAAQ,4BAA0B;AAKlD;;;AAGA,OAAM,MAAOC,yBAAyB;EASlC;;;EAGAC;IATQ,mBAAc,GAAG,CAAC;IAClB,kBAAa,GAAG,IAAIF,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IACpC,iBAAY,GAAG,IAAIA,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAEnC,yBAAoB,GAA8B,IAAI;IAM1D,IAAI,CAACG,cAAc,GAAG,IAAIJ,mBAAmB,CAAC,EAAE,CAAC;IACjD,IAAI,CAACI,cAAc,CAACC,YAAY,GAAG,KAAK;IACxC,IAAI,CAACC,cAAc,GAAG,IAAIN,mBAAmB,CAAC,EAAE,CAAC;IACjD,IAAI,CAACM,cAAc,CAACD,YAAY,GAAG,KAAK;EAC5C;EAEA;;;EAGA,IAAWE,IAAI;IACX,OAAO,mBAAmB;EAC9B;EAEA;;;EAGOC,IAAI,IAAI;EAEPC,mBAAmB;IACvB,OAAO,IAAI,CAACL,cAAc,CAACM,gBAAgB,CAACC,QAAQ,CAAC,IAAI,CAACL,cAAc,CAACI,gBAAgB,CAAC,CAACE,MAAM,EAAE;EACvG;EAEA;;;;EAIOC,MAAM,CAACC,SAAe;IACzB,IAAI,CAACC,UAAU,GAAGD,SAAS;IAE3B;IACA,IAAI,CAACV,cAAc,CAACY,qBAAqB,CAACC,GAAG,CAAC,MAAK;MAC/C,IAAI,IAAI,CAACb,cAAc,CAACc,QAAQ,IAAI,IAAI,CAACZ,cAAc,CAACY,QAAQ,EAAE;QAC9D,IAAI,IAAI,CAACd,cAAc,CAACe,wBAAwB,IAAI,IAAI,CAACb,cAAc,CAACa,wBAAwB,EAAE;UAC9F,IAAI,CAACf,cAAc,CAACgB,WAAW,EAAE;SACpC,MAAM;UACH,IAAI,CAACC,aAAa,CAACC,QAAQ,CAACR,SAAS,CAACS,OAAO,CAAC;UAC9C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACf,mBAAmB,EAAE;;;IAG5D,CAAC,CAAC;IACF,IAAI,CAACH,cAAc,CAACU,qBAAqB,CAACC,GAAG,CAAC,MAAK;MAC/C,IAAI,IAAI,CAACb,cAAc,CAACc,QAAQ,IAAI,IAAI,CAACZ,cAAc,CAACY,QAAQ,EAAE;QAC9D,IAAI,IAAI,CAACd,cAAc,CAACe,wBAAwB,IAAI,IAAI,CAACb,cAAc,CAACa,wBAAwB,EAAE;UAC9F,IAAI,CAACb,cAAc,CAACc,WAAW,EAAE;SACpC,MAAM;UACH,IAAI,CAACC,aAAa,CAACC,QAAQ,CAACR,SAAS,CAACS,OAAO,CAAC;UAC9C,IAAI,CAACC,cAAc,GAAG,IAAI,CAACf,mBAAmB,EAAE;;;IAG5D,CAAC,CAAC;IAEF;IACA,CAAC,IAAI,CAACL,cAAc,EAAE,IAAI,CAACE,cAAc,CAAC,CAACmB,OAAO,CAAEC,QAAQ,IAAI;MAC5DA,QAAQ,CAACC,gBAAgB,CAACV,GAAG,CAAC,MAAK;QAC/B,IAAI,IAAI,CAACb,cAAc,CAACc,QAAQ,IAAI,IAAI,CAACZ,cAAc,CAACY,QAAQ,EAAE;UAC9D,MAAMU,KAAK,GAAG,IAAI,CAACnB,mBAAmB,EAAE,GAAG,IAAI,CAACe,cAAc;UAC9D,IAAI,CAACH,aAAa,CAACQ,UAAU,CAACD,KAAK,EAAE,IAAI,CAACE,YAAY,CAAC;;MAE/D,CAAC,CAAC;IACN,CAAC,CAAC;IAEFhB,SAAS,CAACiB,WAAW,CAAC,IAAI,CAAC3B,cAAc,CAAC;IAC1CU,SAAS,CAACiB,WAAW,CAAC,IAAI,CAACzB,cAAc,CAAC;IAE1C;IACA,IAAI,CAAC0B,oBAAoB,GAAGlB,SAAS,CAACmB,QAAQ,EAAE,CAACC,wBAAwB,CAACjB,GAAG,CAAC,MAAK;MAC/E,IAAI,IAAI,CAACb,cAAc,CAACc,QAAQ,IAAI,IAAI,CAACZ,cAAc,CAACY,QAAQ,EAAE;QAC9D,MAAMiB,MAAM,GAAG,IAAI,CAACL,YAAY,CAACnB,QAAQ,CAACG,SAAS,CAACS,OAAO,CAAC,CAACa,YAAY,CAAC,GAAG,CAAC;QAC9E,IAAID,MAAM,CAACvB,MAAM,EAAE,GAAG,IAAI,EAAE;UACxBE,SAAS,CAACS,OAAO,CAACc,UAAU,CAACF,MAAM,CAAC;;;IAGhD,CAAC,CAAC;EACN;EACA;;;EAGOG,MAAM;IACT,IAAI,CAACvB,UAAU,CAACkB,QAAQ,EAAE,CAACC,wBAAwB,CAACK,MAAM,CAAC,IAAI,CAACP,oBAAoB,CAAC;IACrF,CAAC,IAAI,CAAC5B,cAAc,EAAE,IAAI,CAACE,cAAc,CAAC,CAACmB,OAAO,CAAEC,QAAQ,IAAI;MAC5DA,QAAQ,CAACV,qBAAqB,CAACwB,KAAK,EAAE;MACtCd,QAAQ,CAACC,gBAAgB,CAACa,KAAK,EAAE;MACjC,IAAI,CAACzB,UAAU,CAAC0B,cAAc,CAACf,QAAQ,CAAC;IAC5C,CAAC,CAAC;EACN","names":["PointerDragBehavior","Vector3","MultiPointerScaleBehavior","constructor","_dragBehaviorA","moveAttached","_dragBehaviorB","name","init","_getCurrentDistance","lastDragPosition","subtract","length","attach","ownerNode","_ownerNode","onDragStartObservable","add","dragging","currentDraggingPointerId","releaseDrag","_initialScale","copyFrom","scaling","_startDistance","forEach","behavior","onDragObservable","ratio","scaleToRef","_targetScale","addBehavior","_sceneRenderObserver","getScene","onBeforeRenderObservable","change","scaleInPlace","addInPlace","detach","remove","clear","removeBehavior"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/multiPointerScaleBehavior.ts"],"sourcesContent":["import type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Behavior } from \"../behavior\";\r\nimport { PointerDragBehavior } from \"./pointerDragBehavior\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to be scaled\r\n */\r\nexport class MultiPointerScaleBehavior implements Behavior<Mesh> {\r\n    private _dragBehaviorA: PointerDragBehavior;\r\n    private _dragBehaviorB: PointerDragBehavior;\r\n    private _startDistance = 0;\r\n    private _initialScale = new Vector3(0, 0, 0);\r\n    private _targetScale = new Vector3(0, 0, 0);\r\n    private _ownerNode: Mesh;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Instantiate a new behavior that when attached to a mesh will allow the mesh to be scaled\r\n     */\r\n    constructor() {\r\n        this._dragBehaviorA = new PointerDragBehavior({});\r\n        this._dragBehaviorA.moveAttached = false;\r\n        this._dragBehaviorB = new PointerDragBehavior({});\r\n        this._dragBehaviorB.moveAttached = false;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"MultiPointerScale\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    private _getCurrentDistance() {\r\n        return this._dragBehaviorA.lastDragPosition.subtract(this._dragBehaviorB.lastDragPosition).length();\r\n    }\r\n\r\n    /**\r\n     * Attaches the scale behavior the passed in mesh\r\n     * @param ownerNode The mesh that will be scaled around once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n\r\n        // Create 2 drag behaviors such that each will only be triggered by a separate pointer\r\n        this._dragBehaviorA.onDragStartObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\r\n                    this._dragBehaviorA.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n        this._dragBehaviorB.onDragStartObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                if (this._dragBehaviorA.currentDraggingPointerId == this._dragBehaviorB.currentDraggingPointerId) {\r\n                    this._dragBehaviorB.releaseDrag();\r\n                } else {\r\n                    this._initialScale.copyFrom(ownerNode.scaling);\r\n                    this._startDistance = this._getCurrentDistance();\r\n                }\r\n            }\r\n        });\r\n\r\n        // Once both drag behaviors are active scale based on the distance between the two pointers\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragObservable.add(() => {\r\n                if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                    const ratio = this._getCurrentDistance() / this._startDistance;\r\n                    this._initialScale.scaleToRef(ratio, this._targetScale);\r\n                }\r\n            });\r\n        });\r\n\r\n        ownerNode.addBehavior(this._dragBehaviorA);\r\n        ownerNode.addBehavior(this._dragBehaviorB);\r\n\r\n        // On every frame move towards target scaling to avoid jitter caused by vr controllers\r\n        this._sceneRenderObserver = ownerNode.getScene().onBeforeRenderObservable.add(() => {\r\n            if (this._dragBehaviorA.dragging && this._dragBehaviorB.dragging) {\r\n                const change = this._targetScale.subtract(ownerNode.scaling).scaleInPlace(0.1);\r\n                if (change.length() > 0.01) {\r\n                    ownerNode.scaling.addInPlace(change);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode.getScene().onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        [this._dragBehaviorA, this._dragBehaviorB].forEach((behavior) => {\r\n            behavior.onDragStartObservable.clear();\r\n            behavior.onDragObservable.clear();\r\n            this._ownerNode.removeBehavior(behavior);\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}