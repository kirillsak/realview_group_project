{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { Ray } from \"../../Culling/ray.js\";\n/**\n * A helper for physics simulations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsHelper {\n  /**\n   * Initializes the Physics helper\n   * @param scene Babylon.js scene\n   */\n  constructor(scene) {\n    this._scene = scene;\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\n      return;\n    }\n  }\n  /**\n   * Applies a radial explosion impulse\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n  applyRadialExplosionImpulse(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\n      return null;\n    }\n    const impostors = this._physicsEngine.getImpostors();\n    if (impostors.length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    const affectedImpostorsWithData = Array();\n    impostors.forEach(impostor => {\n      const impostorHitData = event.getImpostorHitData(impostor, origin);\n      if (!impostorHitData) {\n        return;\n      }\n      impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Applies a radial explosion force\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics radial explosion event, or null\n   */\n  applyRadialExplosionForce(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    const impostors = this._physicsEngine.getImpostors();\n    if (impostors.length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n    const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\n    const affectedImpostorsWithData = Array();\n    impostors.forEach(impostor => {\n      const impostorHitData = event.getImpostorHitData(impostor, origin);\n      if (!impostorHitData) {\n        return;\n      }\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n      affectedImpostorsWithData.push({\n        impostor: impostor,\n        hitData: impostorHitData\n      });\n    });\n    event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a gravitational field\n   * @param origin the origin of the explosion\n   * @param radiusOrEventOptions the radius or the options of radial explosion\n   * @param strength the explosion strength\n   * @param falloff possible options: Constant & Linear. Defaults to Constant\n   * @returns A physics gravitational field event, or null\n   */\n  gravitationalField(origin, radiusOrEventOptions, strength, falloff) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    const impostors = this._physicsEngine.getImpostors();\n    if (impostors.length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\n    }\n    const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a physics updraft event\n   * @param origin the origin of the updraft\n   * @param radiusOrEventOptions the radius or the options of the updraft\n   * @param strength the strength of the updraft\n   * @param height the height of the updraft\n   * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\n   * @returns A physics updraft event, or null\n   */\n  updraft(origin, radiusOrEventOptions, strength, height, updraftMode) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsUpdraftEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n      radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\n    }\n    const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n  /**\n   * Creates a physics vortex event\n   * @param origin the of the vortex\n   * @param radiusOrEventOptions the radius or the options of the vortex\n   * @param strength the strength of the vortex\n   * @param height   the height of the vortex\n   * @returns a Physics vortex event, or null\n   * A physics vortex event or null\n   */\n  vortex(origin, radiusOrEventOptions, strength, height) {\n    if (!this._physicsEngine) {\n      Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\n      return null;\n    }\n    if (this._physicsEngine.getImpostors().length === 0) {\n      return null;\n    }\n    if (typeof radiusOrEventOptions === \"number\") {\n      radiusOrEventOptions = new PhysicsVortexEventOptions();\n      radiusOrEventOptions.radius = radiusOrEventOptions;\n      radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\n      radiusOrEventOptions.height = height || radiusOrEventOptions.height;\n    }\n    const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\n    event.dispose(false);\n    return event;\n  }\n}\n/**\n * Represents a physics radial explosion event\n */\nclass PhysicsRadialExplosionEvent {\n  /**\n   * Initializes a radial explosion event\n   * @param _scene BabylonJS scene\n   * @param _options The options for the vortex event\n   */\n  constructor(_scene, _options) {\n    this._scene = _scene;\n    this._options = _options;\n    this._dataFetched = false; // check if the data has been fetched. If not, do cleanup\n    this._options = {\n      ...new PhysicsRadialExplosionEventOptions(),\n      ...this._options\n    };\n  }\n  /**\n   * Returns the data related to the radial explosion event (sphere).\n   * @returns The radial explosion event data\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  }\n  /**\n   * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\n   * @param impostor A physics imposter\n   * @param origin the origin of the explosion\n   * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\n   */\n  getImpostorHitData(impostor, origin) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n    if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\n      return null;\n    }\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return null;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    const direction = impostorObjectCenter.subtract(origin);\n    const ray = new Ray(origin, direction, this._options.radius);\n    const hit = ray.intersectsMesh(impostor.object);\n    const contactPoint = hit.pickedPoint;\n    if (!contactPoint) {\n      return null;\n    }\n    const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\n    if (distanceFromOrigin > this._options.radius) {\n      return null;\n    }\n    const multiplier = this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\n    const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: contactPoint,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  }\n  /**\n   * Triggers affected impostors callbacks\n   * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\n   */\n  triggerAffectedImpostorsCallback(affectedImpostorsWithData) {\n    if (this._options.affectedImpostorsCallback) {\n      this._options.affectedImpostorsCallback(affectedImpostorsWithData);\n    }\n  }\n  /**\n   * Disposes the sphere.\n   * @param force Specifies if the sphere should be disposed by force\n   */\n  dispose(force = true) {\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._sphere.dispose();\n        }\n      }, 0);\n    }\n  }\n  /*** Helpers ***/\n  _prepareSphere() {\n    if (!this._sphere) {\n      this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\n      this._sphere.isVisible = false;\n    }\n  }\n  _intersectsWithSphere(impostor, origin, radius) {\n    const impostorObject = impostor.object;\n    this._prepareSphere();\n    this._sphere.position = origin;\n    this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\n    this._sphere._updateBoundingInfo();\n    this._sphere.computeWorldMatrix(true);\n    return this._sphere.intersectsMesh(impostorObject, true);\n  }\n}\n/**\n * Represents a gravitational field event\n */\nclass PhysicsGravitationalFieldEvent {\n  /**\n   * Initializes the physics gravitational field event\n   * @param _physicsHelper A physics helper\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the gravitational field event\n   * @param _options The options for the vortex event\n   */\n  constructor(_physicsHelper, _scene, _origin, _options) {\n    this._physicsHelper = _physicsHelper;\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._options = {\n      ...new PhysicsRadialExplosionEventOptions(),\n      ...this._options\n    };\n    this._tickCallback = this._tick.bind(this);\n    this._options.strength = this._options.strength * -1;\n  }\n  /**\n   * Returns the data related to the gravitational field event (sphere).\n   * @returns A gravitational field event\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      sphere: this._sphere\n    };\n  }\n  /**\n   * Enables the gravitational field.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the gravitational field.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the sphere.\n   * @param force The force to dispose from the gravitational field event\n   */\n  dispose(force = true) {\n    if (force) {\n      this._sphere.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._sphere.dispose();\n        }\n      }, 0);\n    }\n  }\n  _tick() {\n    // Since the params won't change, we fetch the event only once\n    if (this._sphere) {\n      this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n    } else {\n      const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\n      if (radialExplosionEvent) {\n        this._sphere = radialExplosionEvent.getData().sphere.clone(\"radialExplosionEventSphereClone\");\n      }\n    }\n  }\n}\n/**\n * Represents a physics updraft event\n */\nclass PhysicsUpdraftEvent {\n  /**\n   * Initializes the physics updraft event\n   * @param _scene BabylonJS scene\n   * @param _origin The origin position of the updraft\n   * @param _options The options for the updraft event\n   */\n  constructor(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n    this._originDirection = Vector3.Zero(); // used if the updraftMode is perpendicular\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = {\n      ...new PhysicsUpdraftEventOptions(),\n      ...this._options\n    };\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      this._originDirection = this._origin.subtract(this._originTop).normalize();\n    }\n    this._tickCallback = this._tick.bind(this);\n    this._prepareCylinder();\n  }\n  /**\n   * Returns the data related to the updraft event (cylinder).\n   * @returns A physics updraft event\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  }\n  /**\n   * Enables the updraft.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the updraft.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the cylinder.\n   * @param force Specifies if the updraft should be disposed by force\n   */\n  dispose(force = true) {\n    if (!this._cylinder) {\n      return;\n    }\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  }\n  _getImpostorHitData(impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    let direction;\n    if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\n      direction = this._originDirection;\n    } else {\n      direction = impostorObjectCenter.subtract(this._originTop);\n    }\n    const distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\n    const multiplier = this._options.strength * -1;\n    const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: distanceFromOrigin\n    };\n  }\n  _tick() {\n    this._physicsEngine.getImpostors().forEach(impostor => {\n      const impostorHitData = this._getImpostorHitData(impostor);\n      if (!impostorHitData) {\n        return;\n      }\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  }\n  /*** Helpers ***/\n  _prepareCylinder() {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"updraftEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  }\n  _intersectsWithCylinder(impostor) {\n    const impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  }\n}\n/**\n * Represents a physics vortex event\n */\nclass PhysicsVortexEvent {\n  /**\n   * Initializes the physics vortex event\n   * @param _scene The BabylonJS scene\n   * @param _origin The origin position of the vortex\n   * @param _options The options for the vortex event\n   */\n  constructor(_scene, _origin, _options) {\n    this._scene = _scene;\n    this._origin = _origin;\n    this._options = _options;\n    this._originTop = Vector3.Zero(); // the most upper part of the cylinder\n    this._cylinderPosition = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\n    this._dataFetched = false; // check if the has been fetched the data. If not, do cleanup\n    this._physicsEngine = this._scene.getPhysicsEngine();\n    this._options = {\n      ...new PhysicsVortexEventOptions(),\n      ...this._options\n    };\n    this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\n    this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\n    this._tickCallback = this._tick.bind(this);\n    this._prepareCylinder();\n  }\n  /**\n   * Returns the data related to the vortex event (cylinder).\n   * @returns The physics vortex event data\n   */\n  getData() {\n    this._dataFetched = true;\n    return {\n      cylinder: this._cylinder\n    };\n  }\n  /**\n   * Enables the vortex.\n   */\n  enable() {\n    this._tickCallback.call(this);\n    this._scene.registerBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disables the cortex.\n   */\n  disable() {\n    this._scene.unregisterBeforeRender(this._tickCallback);\n  }\n  /**\n   * Disposes the sphere.\n   * @param force\n   */\n  dispose(force = true) {\n    if (force) {\n      this._cylinder.dispose();\n    } else {\n      setTimeout(() => {\n        if (!this._dataFetched) {\n          this._cylinder.dispose();\n        }\n      }, 0);\n    }\n  }\n  _getImpostorHitData(impostor) {\n    if (impostor.mass === 0) {\n      return null;\n    }\n    if (!this._intersectsWithCylinder(impostor)) {\n      return null;\n    }\n    if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\n      return null;\n    }\n    const impostorObjectCenter = impostor.getObjectCenter();\n    const originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\n    const originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\n    const ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\n    const hit = ray.intersectsMesh(impostor.object);\n    const contactPoint = hit.pickedPoint;\n    if (!contactPoint) {\n      return null;\n    }\n    const absoluteDistanceFromOrigin = hit.distance / this._options.radius;\n    let directionToOrigin = contactPoint.normalize();\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      directionToOrigin = directionToOrigin.negate();\n    }\n    let forceX;\n    let forceY;\n    let forceZ;\n    if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\n      forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\n      forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\n      forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\n    } else {\n      const perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\n      forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\n      forceY = this._originTop.y * this._options.updraftForceMultiplier;\n      forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\n    }\n    let force = new Vector3(forceX, forceY, forceZ);\n    force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\n    return {\n      force: force,\n      contactPoint: impostorObjectCenter,\n      distanceFromOrigin: absoluteDistanceFromOrigin\n    };\n  }\n  _tick() {\n    this._physicsEngine.getImpostors().forEach(impostor => {\n      const impostorHitData = this._getImpostorHitData(impostor);\n      if (!impostorHitData) {\n        return;\n      }\n      impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\n    });\n  }\n  /*** Helpers ***/\n  _prepareCylinder() {\n    if (!this._cylinder) {\n      this._cylinder = CreateCylinder(\"vortexEventCylinder\", {\n        height: this._options.height,\n        diameter: this._options.radius * 2\n      }, this._scene);\n      this._cylinder.isVisible = false;\n    }\n  }\n  _intersectsWithCylinder(impostor) {\n    const impostorObject = impostor.object;\n    this._cylinder.position = this._cylinderPosition;\n    return this._cylinder.intersectsMesh(impostorObject, true);\n  }\n}\n/**\n * Options fot the radial explosion event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsRadialExplosionEventOptions {\n  constructor() {\n    /**\n     * The radius of the sphere for the radial explosion.\n     */\n    this.radius = 5;\n    /**\n     * The strength of the explosion.\n     */\n    this.strength = 10;\n    /**\n     * The strength of the force in correspondence to the distance of the affected object\n     */\n    this.falloff = PhysicsRadialImpulseFalloff.Constant;\n    /**\n     * Sphere options for the radial explosion.\n     */\n    this.sphere = {\n      segments: 32,\n      diameter: 1\n    };\n  }\n}\n/**\n * Options fot the updraft event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsUpdraftEventOptions {\n  constructor() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the updraft.\n     */\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the updraft.\n     */\n    this.height = 10;\n    /**\n     * The mode for the the updraft.\n     */\n    this.updraftMode = PhysicsUpdraftMode.Center;\n  }\n}\n/**\n * Options fot the vortex event\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport class PhysicsVortexEventOptions {\n  constructor() {\n    /**\n     * The radius of the cylinder for the vortex\n     */\n    this.radius = 5;\n    /**\n     * The strength of the vortex.\n     */\n    this.strength = 10;\n    /**\n     * The height of the cylinder for the vortex.\n     */\n    this.height = 10;\n    /**\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\n     */\n    this.centripetalForceThreshold = 0.7;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\n     */\n    this.centripetalForceMultiplier = 5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\n     */\n    this.centrifugalForceMultiplier = 0.5;\n    /**\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\n     */\n    this.updraftForceMultiplier = 0.02;\n  }\n}\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsRadialImpulseFalloff;\n(function (PhysicsRadialImpulseFalloff) {\n  /** Defines that impulse is constant in strength across it's whole radius */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Constant\"] = 0] = \"Constant\";\n  /** Defines that impulse gets weaker if it's further from the origin */\n  PhysicsRadialImpulseFalloff[PhysicsRadialImpulseFalloff[\"Linear\"] = 1] = \"Linear\";\n})(PhysicsRadialImpulseFalloff || (PhysicsRadialImpulseFalloff = {}));\n/**\n * The strength of the force in correspondence to the distance of the affected object\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\n */\nexport var PhysicsUpdraftMode;\n(function (PhysicsUpdraftMode) {\n  /** Defines that the upstream forces will pull towards the top center of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Center\"] = 0] = \"Center\";\n  /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\n  PhysicsUpdraftMode[PhysicsUpdraftMode[\"Perpendicular\"] = 1] = \"Perpendicular\";\n})(PhysicsUpdraftMode || (PhysicsUpdraftMode = {}));","map":{"version":3,"mappings":"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","names":["Logger","Vector3","CreateSphere","CreateCylinder","Ray","PhysicsHelper","constructor","scene","_scene","_physicsEngine","getPhysicsEngine","Warn","applyRadialExplosionImpulse","origin","radiusOrEventOptions","strength","falloff","impostors","getImpostors","length","PhysicsRadialExplosionEventOptions","radius","event","PhysicsRadialExplosionEvent","affectedImpostorsWithData","Array","forEach","impostor","impostorHitData","getImpostorHitData","applyImpulse","force","contactPoint","push","hitData","triggerAffectedImpostorsCallback","dispose","applyRadialExplosionForce","applyForce","gravitationalField","PhysicsGravitationalFieldEvent","updraft","height","updraftMode","PhysicsUpdraftEventOptions","PhysicsUpdraftEvent","vortex","PhysicsVortexEventOptions","PhysicsVortexEvent","_options","getData","_dataFetched","sphere","_sphere","mass","_intersectsWithSphere","object","getClassName","impostorObjectCenter","getObjectCenter","direction","subtract","ray","hit","intersectsMesh","pickedPoint","distanceFromOrigin","Distance","multiplier","PhysicsRadialImpulseFalloff","Constant","multiplyByFloats","affectedImpostorsCallback","setTimeout","_prepareSphere","isVisible","impostorObject","position","scaling","_updateBoundingInfo","computeWorldMatrix","_physicsHelper","_origin","_tickCallback","_tick","bind","enable","call","registerBeforeRender","disable","unregisterBeforeRender","radialExplosionEvent","clone","Zero","addToRef","_cylinderPosition","_originTop","PhysicsUpdraftMode","Perpendicular","_originDirection","normalize","_prepareCylinder","cylinder","_cylinder","_getImpostorHitData","_intersectsWithCylinder","diameter","originOnPlane","x","y","z","originToImpostorDirection","absoluteDistanceFromOrigin","distance","directionToOrigin","centripetalForceThreshold","negate","forceX","forceY","forceZ","centripetalForceMultiplier","updraftForceMultiplier","perpendicularDirection","Cross","centrifugalForceMultiplier","segments","Center"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/v1/physicsHelper.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { PhysicsEngine } from \"./physicsEngine\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\n\r\n/**\r\n * A helper for physics simulations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsHelper {\r\n    private _scene: Scene;\r\n    private _physicsEngine: Nullable<PhysicsEngine>;\r\n\r\n    /**\r\n     * Initializes the Physics helper\r\n     * @param scene Babylon.js scene\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n        this._physicsEngine = this._scene.getPhysicsEngine() as any;\r\n\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you can use the methods.\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion impulse\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionImpulse(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call this method.\");\r\n            return null;\r\n        }\r\n\r\n        const impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n        const affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n\r\n        impostors.forEach((impostor) => {\r\n            const impostorHitData = event.getImpostorHitData(impostor, origin);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyImpulse(impostorHitData.force, impostorHitData.contactPoint);\r\n\r\n            affectedImpostorsWithData.push({\r\n                impostor: impostor,\r\n                hitData: impostorHitData,\r\n            });\r\n        });\r\n\r\n        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Applies a radial explosion force\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics radial explosion event, or null\r\n     */\r\n    public applyRadialExplosionForce(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsRadialExplosionEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        const impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsRadialExplosionEvent(this._scene, radiusOrEventOptions);\r\n        const affectedImpostorsWithData = Array<PhysicsAffectedImpostorWithData>();\r\n\r\n        impostors.forEach((impostor) => {\r\n            const impostorHitData = event.getImpostorHitData(impostor, origin);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n\r\n            affectedImpostorsWithData.push({\r\n                impostor: impostor,\r\n                hitData: impostorHitData,\r\n            });\r\n        });\r\n\r\n        event.triggerAffectedImpostorsCallback(affectedImpostorsWithData);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a gravitational field\r\n     * @param origin the origin of the explosion\r\n     * @param radiusOrEventOptions the radius or the options of radial explosion\r\n     * @param strength the explosion strength\r\n     * @param falloff possible options: Constant & Linear. Defaults to Constant\r\n     * @returns A physics gravitational field event, or null\r\n     */\r\n    public gravitationalField(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsRadialExplosionEventOptions,\r\n        strength?: number,\r\n        falloff?: PhysicsRadialImpulseFalloff\r\n    ): Nullable<PhysicsGravitationalFieldEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        const impostors = this._physicsEngine.getImpostors();\r\n        if (impostors.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsRadialExplosionEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.falloff = falloff || radiusOrEventOptions.falloff;\r\n        }\r\n\r\n        const event = new PhysicsGravitationalFieldEvent(this, this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics updraft event\r\n     * @param origin the origin of the updraft\r\n     * @param radiusOrEventOptions the radius or the options of the updraft\r\n     * @param strength the strength of the updraft\r\n     * @param height the height of the updraft\r\n     * @param updraftMode possible options: Center & Perpendicular. Defaults to Center\r\n     * @returns A physics updraft event, or null\r\n     */\r\n    public updraft(\r\n        origin: Vector3,\r\n        radiusOrEventOptions: number | PhysicsUpdraftEventOptions,\r\n        strength?: number,\r\n        height?: number,\r\n        updraftMode?: PhysicsUpdraftMode\r\n    ): Nullable<PhysicsUpdraftEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsUpdraftEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height || radiusOrEventOptions.height;\r\n            radiusOrEventOptions.updraftMode = updraftMode || radiusOrEventOptions.updraftMode;\r\n        }\r\n\r\n        const event = new PhysicsUpdraftEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n\r\n    /**\r\n     * Creates a physics vortex event\r\n     * @param origin the of the vortex\r\n     * @param radiusOrEventOptions the radius or the options of the vortex\r\n     * @param strength the strength of the vortex\r\n     * @param height   the height of the vortex\r\n     * @returns a Physics vortex event, or null\r\n     * A physics vortex event or null\r\n     */\r\n    public vortex(origin: Vector3, radiusOrEventOptions: number | PhysicsVortexEventOptions, strength?: number, height?: number): Nullable<PhysicsVortexEvent> {\r\n        if (!this._physicsEngine) {\r\n            Logger.Warn(\"Physics engine not enabled. Please enable the physics before you call the PhysicsHelper.\");\r\n            return null;\r\n        }\r\n\r\n        if (this._physicsEngine.getImpostors().length === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (typeof radiusOrEventOptions === \"number\") {\r\n            radiusOrEventOptions = new PhysicsVortexEventOptions();\r\n            radiusOrEventOptions.radius = <number>(<any>radiusOrEventOptions);\r\n            radiusOrEventOptions.strength = strength || radiusOrEventOptions.strength;\r\n            radiusOrEventOptions.height = height || radiusOrEventOptions.height;\r\n        }\r\n\r\n        const event = new PhysicsVortexEvent(this._scene, origin, radiusOrEventOptions);\r\n\r\n        event.dispose(false);\r\n\r\n        return event;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics radial explosion event\r\n */\r\nclass PhysicsRadialExplosionEvent {\r\n    private _sphere: Mesh; // create a sphere, so we can get the intersecting meshes inside\r\n    private _dataFetched: boolean = false; // check if the data has been fetched. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes a radial explosion event\r\n     * @param _scene BabylonJS scene\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the radial explosion event (sphere).\r\n     * @returns The radial explosion event data\r\n     */\r\n    public getData(): PhysicsRadialExplosionEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.\r\n     * @param impostor A physics imposter\r\n     * @param origin the origin of the explosion\r\n     * @returns {Nullable<PhysicsHitData>} A physics force and contact point, or null\r\n     */\r\n    public getImpostorHitData(impostor: PhysicsImpostor, origin: Vector3): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithSphere(impostor, origin, this._options.radius)) {\r\n            return null;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\r\n            return null;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n        const direction = impostorObjectCenter.subtract(origin);\r\n\r\n        const ray = new Ray(origin, direction, this._options.radius);\r\n        const hit = ray.intersectsMesh(<AbstractMesh>impostor.object);\r\n\r\n        const contactPoint = hit.pickedPoint;\r\n        if (!contactPoint) {\r\n            return null;\r\n        }\r\n\r\n        const distanceFromOrigin = Vector3.Distance(origin, contactPoint);\r\n\r\n        if (distanceFromOrigin > this._options.radius) {\r\n            return null;\r\n        }\r\n\r\n        const multiplier =\r\n            this._options.falloff === PhysicsRadialImpulseFalloff.Constant ? this._options.strength : this._options.strength * (1 - distanceFromOrigin / this._options.radius);\r\n\r\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        return { force: force, contactPoint: contactPoint, distanceFromOrigin: distanceFromOrigin };\r\n    }\r\n\r\n    /**\r\n     * Triggers affected impostors callbacks\r\n     * @param affectedImpostorsWithData defines the list of affected impostors (including associated data)\r\n     */\r\n    public triggerAffectedImpostorsCallback(affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) {\r\n        if (this._options.affectedImpostorsCallback) {\r\n            this._options.affectedImpostorsCallback(affectedImpostorsWithData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force Specifies if the sphere should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareSphere(): void {\r\n        if (!this._sphere) {\r\n            this._sphere = CreateSphere(\"radialExplosionEventSphere\", this._options.sphere, this._scene);\r\n            this._sphere.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithSphere(impostor: PhysicsImpostor, origin: Vector3, radius: number): boolean {\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._prepareSphere();\r\n\r\n        this._sphere.position = origin;\r\n        this._sphere.scaling = new Vector3(radius * 2, radius * 2, radius * 2);\r\n        this._sphere._updateBoundingInfo();\r\n        this._sphere.computeWorldMatrix(true);\r\n\r\n        return this._sphere.intersectsMesh(impostorObject, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a gravitational field event\r\n */\r\nclass PhysicsGravitationalFieldEvent {\r\n    private _tickCallback: any;\r\n    private _sphere: Mesh;\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics gravitational field event\r\n     * @param _physicsHelper A physics helper\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the gravitational field event\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _physicsHelper: PhysicsHelper, private _scene: Scene, private _origin: Vector3, private _options: PhysicsRadialExplosionEventOptions) {\r\n        this._options = { ...new PhysicsRadialExplosionEventOptions(), ...this._options };\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._options.strength = this._options.strength * -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the gravitational field event (sphere).\r\n     * @returns A gravitational field event\r\n     */\r\n    public getData(): PhysicsGravitationalFieldEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            sphere: this._sphere,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the gravitational field.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the gravitational field.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force The force to dispose from the gravitational field event\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._sphere.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._sphere.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _tick() {\r\n        // Since the params won't change, we fetch the event only once\r\n        if (this._sphere) {\r\n            this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n        } else {\r\n            const radialExplosionEvent = this._physicsHelper.applyRadialExplosionForce(this._origin, this._options);\r\n            if (radialExplosionEvent) {\r\n                this._sphere = <Mesh>radialExplosionEvent.getData().sphere.clone(\"radialExplosionEventSphereClone\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics updraft event\r\n */\r\nclass PhysicsUpdraftEvent {\r\n    private _physicsEngine: PhysicsEngine;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _originDirection: Vector3 = Vector3.Zero(); // used if the updraftMode is perpendicular\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics updraft event\r\n     * @param _scene BabylonJS scene\r\n     * @param _origin The origin position of the updraft\r\n     * @param _options The options for the updraft event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsUpdraftEventOptions) {\r\n        this._physicsEngine = <PhysicsEngine>this._scene.getPhysicsEngine();\r\n        this._options = { ...new PhysicsUpdraftEventOptions(), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            this._originDirection = this._origin.subtract(this._originTop).normalize();\r\n        }\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._prepareCylinder();\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the updraft event (cylinder).\r\n     * @returns A physics updraft event\r\n     */\r\n    public getData(): PhysicsUpdraftEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the updraft.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the updraft.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the cylinder.\r\n     * @param force Specifies if the updraft should be disposed by force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (!this._cylinder) {\r\n            return;\r\n        }\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _getImpostorHitData(impostor: PhysicsImpostor): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithCylinder(impostor)) {\r\n            return null;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n\r\n        let direction: Vector3;\r\n        if (this._options.updraftMode === PhysicsUpdraftMode.Perpendicular) {\r\n            direction = this._originDirection;\r\n        } else {\r\n            direction = impostorObjectCenter.subtract(this._originTop);\r\n        }\r\n\r\n        const distanceFromOrigin = Vector3.Distance(this._origin, impostorObjectCenter);\r\n\r\n        const multiplier = this._options.strength * -1;\r\n\r\n        const force = direction.multiplyByFloats(multiplier, multiplier, multiplier);\r\n\r\n        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: distanceFromOrigin };\r\n    }\r\n\r\n    private _tick() {\r\n        this._physicsEngine.getImpostors().forEach((impostor) => {\r\n            const impostorHitData = this._getImpostorHitData(impostor);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n        });\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CreateCylinder(\r\n                \"updraftEventCylinder\",\r\n                {\r\n                    height: this._options.height,\r\n                    diameter: this._options.radius * 2,\r\n                },\r\n                this._scene\r\n            );\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(impostor: PhysicsImpostor): boolean {\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(impostorObject, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a physics vortex event\r\n */\r\nclass PhysicsVortexEvent {\r\n    private _physicsEngine: PhysicsEngine;\r\n    private _originTop: Vector3 = Vector3.Zero(); // the most upper part of the cylinder\r\n    private _tickCallback: any;\r\n    private _cylinder: Mesh;\r\n    private _cylinderPosition: Vector3 = Vector3.Zero(); // to keep the cylinders position, because normally the origin is in the center and not on the bottom\r\n    private _dataFetched: boolean = false; // check if the has been fetched the data. If not, do cleanup\r\n\r\n    /**\r\n     * Initializes the physics vortex event\r\n     * @param _scene The BabylonJS scene\r\n     * @param _origin The origin position of the vortex\r\n     * @param _options The options for the vortex event\r\n     */\r\n    constructor(private _scene: Scene, private _origin: Vector3, private _options: PhysicsVortexEventOptions) {\r\n        this._physicsEngine = <PhysicsEngine>this._scene.getPhysicsEngine();\r\n        this._options = { ...new PhysicsVortexEventOptions(), ...this._options };\r\n\r\n        this._origin.addToRef(new Vector3(0, this._options.height / 2, 0), this._cylinderPosition);\r\n        this._origin.addToRef(new Vector3(0, this._options.height, 0), this._originTop);\r\n\r\n        this._tickCallback = this._tick.bind(this);\r\n\r\n        this._prepareCylinder();\r\n    }\r\n\r\n    /**\r\n     * Returns the data related to the vortex event (cylinder).\r\n     * @returns The physics vortex event data\r\n     */\r\n    public getData(): PhysicsVortexEventData {\r\n        this._dataFetched = true;\r\n\r\n        return {\r\n            cylinder: this._cylinder,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enables the vortex.\r\n     */\r\n    public enable() {\r\n        this._tickCallback.call(this);\r\n        this._scene.registerBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disables the cortex.\r\n     */\r\n    public disable() {\r\n        this._scene.unregisterBeforeRender(this._tickCallback);\r\n    }\r\n\r\n    /**\r\n     * Disposes the sphere.\r\n     * @param force\r\n     */\r\n    public dispose(force: boolean = true) {\r\n        if (force) {\r\n            this._cylinder.dispose();\r\n        } else {\r\n            setTimeout(() => {\r\n                if (!this._dataFetched) {\r\n                    this._cylinder.dispose();\r\n                }\r\n            }, 0);\r\n        }\r\n    }\r\n\r\n    private _getImpostorHitData(impostor: PhysicsImpostor): Nullable<PhysicsHitData> {\r\n        if (impostor.mass === 0) {\r\n            return null;\r\n        }\r\n\r\n        if (!this._intersectsWithCylinder(impostor)) {\r\n            return null;\r\n        }\r\n\r\n        if (impostor.object.getClassName() !== \"Mesh\" && impostor.object.getClassName() !== \"InstancedMesh\") {\r\n            return null;\r\n        }\r\n\r\n        const impostorObjectCenter = impostor.getObjectCenter();\r\n        const originOnPlane = new Vector3(this._origin.x, impostorObjectCenter.y, this._origin.z); // the distance to the origin as if both objects were on a plane (Y-axis)\r\n        const originToImpostorDirection = impostorObjectCenter.subtract(originOnPlane);\r\n\r\n        const ray = new Ray(originOnPlane, originToImpostorDirection, this._options.radius);\r\n        const hit = ray.intersectsMesh(<AbstractMesh>impostor.object);\r\n        const contactPoint = hit.pickedPoint;\r\n        if (!contactPoint) {\r\n            return null;\r\n        }\r\n        const absoluteDistanceFromOrigin = hit.distance / this._options.radius;\r\n\r\n        let directionToOrigin = contactPoint.normalize();\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            directionToOrigin = directionToOrigin.negate();\r\n        }\r\n\r\n        let forceX: number;\r\n        let forceY: number;\r\n        let forceZ: number;\r\n\r\n        if (absoluteDistanceFromOrigin > this._options.centripetalForceThreshold) {\r\n            forceX = directionToOrigin.x * this._options.centripetalForceMultiplier;\r\n            forceY = directionToOrigin.y * this._options.updraftForceMultiplier;\r\n            forceZ = directionToOrigin.z * this._options.centripetalForceMultiplier;\r\n        } else {\r\n            const perpendicularDirection = Vector3.Cross(originOnPlane, impostorObjectCenter).normalize();\r\n\r\n            forceX = (perpendicularDirection.x + directionToOrigin.x) * this._options.centrifugalForceMultiplier;\r\n            forceY = this._originTop.y * this._options.updraftForceMultiplier;\r\n            forceZ = (perpendicularDirection.z + directionToOrigin.z) * this._options.centrifugalForceMultiplier;\r\n        }\r\n\r\n        let force = new Vector3(forceX, forceY, forceZ);\r\n        force = force.multiplyByFloats(this._options.strength, this._options.strength, this._options.strength);\r\n\r\n        return { force: force, contactPoint: impostorObjectCenter, distanceFromOrigin: absoluteDistanceFromOrigin };\r\n    }\r\n\r\n    private _tick() {\r\n        this._physicsEngine.getImpostors().forEach((impostor) => {\r\n            const impostorHitData = this._getImpostorHitData(impostor);\r\n            if (!impostorHitData) {\r\n                return;\r\n            }\r\n\r\n            impostor.applyForce(impostorHitData.force, impostorHitData.contactPoint);\r\n        });\r\n    }\r\n\r\n    /*** Helpers ***/\r\n\r\n    private _prepareCylinder(): void {\r\n        if (!this._cylinder) {\r\n            this._cylinder = CreateCylinder(\r\n                \"vortexEventCylinder\",\r\n                {\r\n                    height: this._options.height,\r\n                    diameter: this._options.radius * 2,\r\n                },\r\n                this._scene\r\n            );\r\n            this._cylinder.isVisible = false;\r\n        }\r\n    }\r\n\r\n    private _intersectsWithCylinder(impostor: PhysicsImpostor): boolean {\r\n        const impostorObject = <AbstractMesh>impostor.object;\r\n\r\n        this._cylinder.position = this._cylinderPosition;\r\n\r\n        return this._cylinder.intersectsMesh(impostorObject, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Options fot the radial explosion event\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsRadialExplosionEventOptions {\r\n    /**\r\n     * The radius of the sphere for the radial explosion.\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the explosion.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The strength of the force in correspondence to the distance of the affected object\r\n     */\r\n    falloff: PhysicsRadialImpulseFalloff = PhysicsRadialImpulseFalloff.Constant;\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    sphere: { segments: number; diameter: number } = { segments: 32, diameter: 1 };\r\n\r\n    /**\r\n     * Sphere options for the radial explosion.\r\n     */\r\n    affectedImpostorsCallback: (affectedImpostorsWithData: Array<PhysicsAffectedImpostorWithData>) => void;\r\n}\r\n\r\n/**\r\n * Options fot the updraft event\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsUpdraftEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the updraft.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the updraft.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * The mode for the the updraft.\r\n     */\r\n    updraftMode: PhysicsUpdraftMode = PhysicsUpdraftMode.Center;\r\n}\r\n\r\n/**\r\n * Options fot the vortex event\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport class PhysicsVortexEventOptions {\r\n    /**\r\n     * The radius of the cylinder for the vortex\r\n     */\r\n    radius: number = 5;\r\n\r\n    /**\r\n     * The strength of the vortex.\r\n     */\r\n    strength: number = 10;\r\n\r\n    /**\r\n     * The height of the cylinder for the vortex.\r\n     */\r\n    height: number = 10;\r\n\r\n    /**\r\n     * At which distance, relative to the radius the centripetal forces should kick in? Range: 0-1\r\n     */\r\n    centripetalForceThreshold: number = 0.7;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when below the threshold.\r\n     */\r\n    centripetalForceMultiplier: number = 5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed sideways/around the vortex, when above the threshold.\r\n     */\r\n    centrifugalForceMultiplier: number = 0.5;\r\n\r\n    /**\r\n     * This multiplier determines with how much force the objects will be pushed upwards, when in the vortex.\r\n     */\r\n    updraftForceMultiplier: number = 0.02;\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsRadialImpulseFalloff {\r\n    /** Defines that impulse is constant in strength across it's whole radius */\r\n    Constant,\r\n    /** Defines that impulse gets weaker if it's further from the origin */\r\n    Linear,\r\n}\r\n\r\n/**\r\n * The strength of the force in correspondence to the distance of the affected object\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport enum PhysicsUpdraftMode {\r\n    /** Defines that the upstream forces will pull towards the top center of the cylinder */\r\n    Center,\r\n    /** Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder */\r\n    Perpendicular,\r\n}\r\n\r\n/**\r\n * Interface for a physics hit data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsHitData {\r\n    /**\r\n     * The force applied at the contact point\r\n     */\r\n    force: Vector3;\r\n    /**\r\n     * The contact point\r\n     */\r\n    contactPoint: Vector3;\r\n    /**\r\n     * The distance from the origin to the contact point\r\n     */\r\n    distanceFromOrigin: number;\r\n}\r\n\r\n/**\r\n * Interface for radial explosion event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsRadialExplosionEventData {\r\n    /**\r\n     * A sphere used for the radial explosion event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for gravitational field event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsGravitationalFieldEventData {\r\n    /**\r\n     * A sphere mesh used for the gravitational field event\r\n     */\r\n    sphere: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for updraft event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsUpdraftEventData {\r\n    /**\r\n     * A cylinder used for the updraft event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for vortex event data\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsVortexEventData {\r\n    /**\r\n     * A cylinder used for the vortex event\r\n     */\r\n    cylinder: Mesh;\r\n}\r\n\r\n/**\r\n * Interface for an affected physics impostor\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine#further-functionality-of-the-impostor-class\r\n */\r\nexport interface PhysicsAffectedImpostorWithData {\r\n    /**\r\n     * The impostor affected by the effect\r\n     */\r\n    impostor: PhysicsImpostor;\r\n\r\n    /**\r\n     * The data about the hit/force from the explosion\r\n     */\r\n    hitData: PhysicsHitData;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}