{"ast":null,"code":"import { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nMesh._GroundMeshParser = (parsedMesh, scene) => {\n  return GroundMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh representing the ground\n */\nexport class GroundMesh extends Mesh {\n  constructor(name, scene) {\n    super(name, scene);\n    /** If octree should be generated */\n    this.generateOctree = false;\n  }\n  /**\n   * \"GroundMesh\"\n   * @returns \"GroundMesh\"\n   */\n  getClassName() {\n    return \"GroundMesh\";\n  }\n  /**\n   * The minimum of x and y subdivisions\n   */\n  get subdivisions() {\n    return Math.min(this._subdivisionsX, this._subdivisionsY);\n  }\n  /**\n   * X subdivisions\n   */\n  get subdivisionsX() {\n    return this._subdivisionsX;\n  }\n  /**\n   * Y subdivisions\n   */\n  get subdivisionsY() {\n    return this._subdivisionsY;\n  }\n  /**\n   * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\n   * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\n   * to get performance improvements when using an octree.\n   * @param chunksCount the number of submeshes the mesh will be divided into\n   * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\n   */\n  optimize(chunksCount, octreeBlocksSize = 32) {\n    this._subdivisionsX = chunksCount;\n    this._subdivisionsY = chunksCount;\n    this.subdivide(chunksCount);\n    // Call the octree system optimization if it is defined.\n    const thisAsAny = this;\n    if (thisAsAny.createOrUpdateSubmeshesOctree) {\n      thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n    }\n  }\n  /**\n   * Returns a height (y) value in the World system :\n   * the ground altitude at the coordinates (x, z) expressed in the World system.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @returns the ground y position if (x, z) are outside the ground surface.\n   */\n  getHeightAtCoordinates(x, z) {\n    const world = this.getWorldMatrix();\n    const invMat = TmpVectors.Matrix[5];\n    world.invertToRef(invMat);\n    const tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n    x = tmpVect.x;\n    z = tmpVect.z;\n    if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\n      return this.position.y;\n    }\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n      this._computeHeightQuads();\n    }\n    const facet = this._getFacetAt(x, z);\n    const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\n    // return y in the World system\n    Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n    return tmpVect.y;\n  }\n  /**\n   * Returns a normalized vector (Vector3) orthogonal to the ground\n   * at the ground coordinates (x, z) expressed in the World system.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\n   */\n  getNormalAtCoordinates(x, z) {\n    const normal = new Vector3(0.0, 1.0, 0.0);\n    this.getNormalAtCoordinatesToRef(x, z, normal);\n    return normal;\n  }\n  /**\n   * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\n   * at the ground coordinates (x, z) expressed in the World system.\n   * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\n   * @param x x coordinate\n   * @param z z coordinate\n   * @param ref vector to store the result\n   * @returns the GroundMesh.\n   */\n  getNormalAtCoordinatesToRef(x, z, ref) {\n    const world = this.getWorldMatrix();\n    const tmpMat = TmpVectors.Matrix[5];\n    world.invertToRef(tmpMat);\n    const tmpVect = TmpVectors.Vector3[8];\n    Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n    x = tmpVect.x;\n    z = tmpVect.z;\n    if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n      return this;\n    }\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n      this._computeHeightQuads();\n    }\n    const facet = this._getFacetAt(x, z);\n    Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n    return this;\n  }\n  /**\n   * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\n   * if the ground has been updated.\n   * This can be used in the render loop.\n   * @returns the GroundMesh.\n   */\n  updateCoordinateHeights() {\n    if (!this._heightQuads || this._heightQuads.length == 0) {\n      this._initHeightQuads();\n    }\n    this._computeHeightQuads();\n    return this;\n  }\n  // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n  _getFacetAt(x, z) {\n    // retrieve col and row from x, z coordinates in the ground local system\n    const col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\n    const row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\n    const quad = this._heightQuads[row * this._subdivisionsX + col];\n    let facet;\n    if (z < quad.slope.x * x + quad.slope.y) {\n      facet = quad.facet1;\n    } else {\n      facet = quad.facet2;\n    }\n    return facet;\n  }\n  //  Creates and populates the heightMap array with \"facet\" elements :\n  // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n  _initHeightQuads() {\n    const subdivisionsX = this._subdivisionsX;\n    const subdivisionsY = this._subdivisionsY;\n    this._heightQuads = new Array();\n    for (let row = 0; row < subdivisionsY; row++) {\n      for (let col = 0; col < subdivisionsX; col++) {\n        const quad = {\n          slope: Vector2.Zero(),\n          facet1: new Vector4(0.0, 0.0, 0.0, 0.0),\n          facet2: new Vector4(0.0, 0.0, 0.0, 0.0)\n        };\n        this._heightQuads[row * subdivisionsX + col] = quad;\n      }\n    }\n    return this;\n  }\n  // Compute each quad element values and update the the heightMap array :\n  // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\n  // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n  // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\n  // Returns the GroundMesh.\n  _computeHeightQuads() {\n    const positions = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!positions) {\n      return this;\n    }\n    const v1 = TmpVectors.Vector3[3];\n    const v2 = TmpVectors.Vector3[2];\n    const v3 = TmpVectors.Vector3[1];\n    const v4 = TmpVectors.Vector3[0];\n    const v1v2 = TmpVectors.Vector3[4];\n    const v1v3 = TmpVectors.Vector3[5];\n    const v1v4 = TmpVectors.Vector3[6];\n    const norm1 = TmpVectors.Vector3[7];\n    const norm2 = TmpVectors.Vector3[8];\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    let cd = 0; // 2D slope coefficient : z = cd * x + h\n    let h = 0;\n    let d1 = 0; // facet plane equation : ax + by + cz + d = 0\n    let d2 = 0;\n    const subdivisionsX = this._subdivisionsX;\n    const subdivisionsY = this._subdivisionsY;\n    for (let row = 0; row < subdivisionsY; row++) {\n      for (let col = 0; col < subdivisionsX; col++) {\n        i = col * 3;\n        j = row * (subdivisionsX + 1) * 3;\n        k = (row + 1) * (subdivisionsX + 1) * 3;\n        v1.x = positions[j + i];\n        v1.y = positions[j + i + 1];\n        v1.z = positions[j + i + 2];\n        v2.x = positions[j + i + 3];\n        v2.y = positions[j + i + 4];\n        v2.z = positions[j + i + 5];\n        v3.x = positions[k + i];\n        v3.y = positions[k + i + 1];\n        v3.z = positions[k + i + 2];\n        v4.x = positions[k + i + 3];\n        v4.y = positions[k + i + 4];\n        v4.z = positions[k + i + 5];\n        // 2D slope V1V4\n        cd = (v4.z - v1.z) / (v4.x - v1.x);\n        h = v1.z - cd * v1.x; // v1 belongs to the slope\n        // facet equations :\n        // we compute each facet normal vector\n        // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n        // we compute the value d by applying the equation to v1 which belongs to the plane\n        // then we store the facet equation in a Vector4\n        v2.subtractToRef(v1, v1v2);\n        v3.subtractToRef(v1, v1v3);\n        v4.subtractToRef(v1, v1v4);\n        Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n        Vector3.CrossToRef(v1v2, v1v4, norm2);\n        norm1.normalize();\n        norm2.normalize();\n        d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n        d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n        const quad = this._heightQuads[row * subdivisionsX + col];\n        quad.slope.copyFromFloats(cd, h);\n        quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n        quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n      }\n    }\n    return this;\n  }\n  /**\n   * Serializes this ground mesh\n   * @param serializationObject object to write serialization to\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.subdivisionsX = this._subdivisionsX;\n    serializationObject.subdivisionsY = this._subdivisionsY;\n    serializationObject.minX = this._minX;\n    serializationObject.maxX = this._maxX;\n    serializationObject.minZ = this._minZ;\n    serializationObject.maxZ = this._maxZ;\n    serializationObject.width = this._width;\n    serializationObject.height = this._height;\n  }\n  /**\n   * Parses a serialized ground mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the ground mesh in\n   * @returns the created ground mesh\n   */\n  static Parse(parsedMesh, scene) {\n    const result = new GroundMesh(parsedMesh.name, scene);\n    result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n    result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n    result._minX = parsedMesh.minX;\n    result._maxX = parsedMesh.maxX;\n    result._minZ = parsedMesh.minZ;\n    result._maxZ = parsedMesh.maxZ;\n    result._width = parsedMesh.width;\n    result._height = parsedMesh.height;\n    return result;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Vector2","TmpVectors","Vector4","VertexBuffer","Mesh","_GroundMeshParser","parsedMesh","scene","GroundMesh","Parse","constructor","name","getClassName","subdivisions","Math","min","_subdivisionsX","_subdivisionsY","subdivisionsX","subdivisionsY","optimize","chunksCount","octreeBlocksSize","subdivide","thisAsAny","createOrUpdateSubmeshesOctree","getHeightAtCoordinates","x","z","world","getWorldMatrix","invMat","Matrix","invertToRef","tmpVect","TransformCoordinatesFromFloatsToRef","_minX","_maxX","_minZ","_maxZ","position","y","_heightQuads","length","_initHeightQuads","_computeHeightQuads","facet","_getFacetAt","w","getNormalAtCoordinates","normal","getNormalAtCoordinatesToRef","ref","tmpMat","TransformNormalFromFloatsToRef","updateCoordinateHeights","col","floor","_width","row","_height","quad","slope","facet1","facet2","Array","Zero","positions","getVerticesData","PositionKind","v1","v2","v3","v4","v1v2","v1v3","v1v4","norm1","norm2","i","j","k","cd","h","d1","d2","subtractToRef","CrossToRef","normalize","copyFromFloats","serialize","serializationObject","minX","maxX","minZ","maxZ","width","height","result"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/groundMesh.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the ground\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @internal */\r\n    public _subdivisionsX: number;\r\n    /** @internal */\r\n    public _subdivisionsY: number;\r\n    /** @internal */\r\n    public _width: number;\r\n    /** @internal */\r\n    public _height: number;\r\n    /** @internal */\r\n    public _minX: number;\r\n    /** @internal */\r\n    public _maxX: number;\r\n    /** @internal */\r\n    public _minZ: number;\r\n    /** @internal */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\r\n     * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\r\n     * to get performance improvements when using an octree.\r\n     * @param chunksCount the number of submeshes the mesh will be divided into\r\n     * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the World system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        const normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        const world = this.getWorldMatrix();\r\n        const tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n     * if the ground has been updated.\r\n     * This can be used in the render loop.\r\n     * @returns the GroundMesh.\r\n     */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        const col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\r\n        const row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\r\n        const quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        let facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                const quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        const v1 = TmpVectors.Vector3[3];\r\n        const v2 = TmpVectors.Vector3[2];\r\n        const v3 = TmpVectors.Vector3[1];\r\n        const v4 = TmpVectors.Vector3[0];\r\n        const v1v2 = TmpVectors.Vector3[4];\r\n        const v1v3 = TmpVectors.Vector3[5];\r\n        const v1v4 = TmpVectors.Vector3[6];\r\n        const norm1 = TmpVectors.Vector3[7];\r\n        const norm2 = TmpVectors.Vector3[8];\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        let cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        let h = 0;\r\n        let d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        let d2 = 0;\r\n\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                const quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        const result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}