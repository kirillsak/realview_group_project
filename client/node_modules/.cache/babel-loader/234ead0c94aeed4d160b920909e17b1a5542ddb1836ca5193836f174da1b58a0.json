{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { renderableTextureFormatToIndex, WebGPUTextureHelper } from \"./webgpuTextureHelper.js\";\nvar StatePosition;\n(function (StatePosition) {\n  StatePosition[StatePosition[\"StencilReadMask\"] = 0] = \"StencilReadMask\";\n  StatePosition[StatePosition[\"StencilWriteMask\"] = 1] = \"StencilWriteMask\";\n  //DepthBiasClamp = 1, // not used, so remove it to improve perf\n  StatePosition[StatePosition[\"DepthBias\"] = 2] = \"DepthBias\";\n  StatePosition[StatePosition[\"DepthBiasSlopeScale\"] = 3] = \"DepthBiasSlopeScale\";\n  StatePosition[StatePosition[\"DepthStencilState\"] = 4] = \"DepthStencilState\";\n  StatePosition[StatePosition[\"MRTAttachments1\"] = 5] = \"MRTAttachments1\";\n  StatePosition[StatePosition[\"MRTAttachments2\"] = 6] = \"MRTAttachments2\";\n  StatePosition[StatePosition[\"RasterizationState\"] = 7] = \"RasterizationState\";\n  StatePosition[StatePosition[\"ColorStates\"] = 8] = \"ColorStates\";\n  StatePosition[StatePosition[\"ShaderStage\"] = 9] = \"ShaderStage\";\n  StatePosition[StatePosition[\"TextureStage\"] = 10] = \"TextureStage\";\n  StatePosition[StatePosition[\"VertexState\"] = 11] = \"VertexState\";\n  StatePosition[StatePosition[\"NumStates\"] = 12] = \"NumStates\";\n})(StatePosition || (StatePosition = {}));\nconst alphaBlendFactorToIndex = {\n  0: 1,\n  1: 2,\n  0x0300: 3,\n  0x0301: 4,\n  0x0302: 5,\n  0x0303: 6,\n  0x0304: 7,\n  0x0305: 8,\n  0x0306: 9,\n  0x0307: 10,\n  0x0308: 11,\n  0x8001: 12,\n  0x8002: 13,\n  0x8003: 12,\n  0x8004: 13 // OneMinusBlendColor (alpha)\n};\n\nconst stencilOpToIndex = {\n  0x0000: 0,\n  0x1e00: 1,\n  0x1e01: 2,\n  0x1e02: 3,\n  0x1e03: 4,\n  0x150a: 5,\n  0x8507: 6,\n  0x8508: 7 // DECR_WRAP\n};\n/** @internal */\nexport class WebGPUCacheRenderPipeline {\n  constructor(device, emptyVertexBuffer, useTextureStage) {\n    this.mrtTextureCount = 0;\n    this._device = device;\n    this._useTextureStage = useTextureStage;\n    this._states = new Array(30); // pre-allocate enough room so that no new allocation will take place afterwards\n    this._statesLength = 0;\n    this._stateDirtyLowestIndex = 0;\n    this._emptyVertexBuffer = emptyVertexBuffer;\n    this._mrtFormats = [];\n    this._parameter = {\n      token: undefined,\n      pipeline: null\n    };\n    this.disabled = false;\n    this.vertexBuffers = [];\n    this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;\n    this.reset();\n  }\n  reset() {\n    this._isDirty = true;\n    this.vertexBuffers.length = 0;\n    this.setAlphaToCoverage(false);\n    this.resetDepthCullingState();\n    this.setClampDepth(false);\n    this.setDepthBias(0);\n    //this.setDepthBiasClamp(0);\n    this._webgpuColorFormat = [WebGPUConstants.TextureFormat.BGRA8Unorm];\n    this.setColorFormat(WebGPUConstants.TextureFormat.BGRA8Unorm);\n    this.setMRT([]);\n    this.setAlphaBlendEnabled(false);\n    this.setAlphaBlendFactors([null, null, null, null], [null, null]);\n    this.setWriteMask(0xf);\n    this.setDepthStencilFormat(WebGPUConstants.TextureFormat.Depth24PlusStencil8);\n    this.setStencilEnabled(false);\n    this.resetStencilState();\n    this.setBuffers(null, null, null);\n    this._setTextureState(0);\n  }\n  get colorFormats() {\n    return this._mrtAttachments1 > 0 ? this._mrtFormats : this._webgpuColorFormat;\n  }\n  getRenderPipeline(fillMode, effect, sampleCount, textureState = 0) {\n    if (sampleCount > 1) {\n      // WebGPU only supports 1 or 4\n      sampleCount = 4;\n    }\n    if (this.disabled) {\n      const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\n      this._setVertexState(effect); // to fill this.vertexBuffers with correct data\n      this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\n      WebGPUCacheRenderPipeline.NumCacheMiss++;\n      WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\n      return this._parameter.pipeline;\n    }\n    this._setShaderStage(effect.uniqueId);\n    this._setRasterizationState(fillMode, sampleCount);\n    this._setColorStates();\n    this._setDepthStencilState();\n    this._setVertexState(effect);\n    this._setTextureState(textureState);\n    this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;\n    if (!this._isDirty && this._parameter.pipeline) {\n      this._stateDirtyLowestIndex = this._statesLength;\n      WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;\n      return this._parameter.pipeline;\n    }\n    this._getRenderPipeline(this._parameter);\n    this._isDirty = false;\n    this._stateDirtyLowestIndex = this._statesLength;\n    if (this._parameter.pipeline) {\n      WebGPUCacheRenderPipeline.NumCacheHitWithHash++;\n      return this._parameter.pipeline;\n    }\n    const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\n    this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\n    this._setRenderPipeline(this._parameter);\n    WebGPUCacheRenderPipeline.NumCacheMiss++;\n    WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\n    return this._parameter.pipeline;\n  }\n  endFrame() {\n    WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;\n    WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\n  }\n  setAlphaToCoverage(enabled) {\n    this._alphaToCoverageEnabled = enabled;\n  }\n  setFrontFace(frontFace) {\n    this._frontFace = frontFace;\n  }\n  setCullEnabled(enabled) {\n    this._cullEnabled = enabled;\n  }\n  setCullFace(cullFace) {\n    this._cullFace = cullFace;\n  }\n  setClampDepth(clampDepth) {\n    this._clampDepth = clampDepth;\n  }\n  resetDepthCullingState() {\n    this.setDepthCullingState(false, 2, 1, 0, 0, true, true, 519);\n  }\n  setDepthCullingState(cullEnabled, frontFace, cullFace, zOffset, zOffsetUnits, depthTestEnabled, depthWriteEnabled, depthCompare) {\n    this._depthWriteEnabled = depthWriteEnabled;\n    this._depthTestEnabled = depthTestEnabled;\n    this._depthCompare = (depthCompare !== null && depthCompare !== void 0 ? depthCompare : 519) - 0x0200;\n    this._cullFace = cullFace;\n    this._cullEnabled = cullEnabled;\n    this._frontFace = frontFace;\n    this.setDepthBiasSlopeScale(zOffset);\n    this.setDepthBias(zOffsetUnits);\n  }\n  setDepthBias(depthBias) {\n    if (this._depthBias !== depthBias) {\n      this._depthBias = depthBias;\n      this._states[StatePosition.DepthBias] = depthBias;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);\n    }\n  }\n  /*public setDepthBiasClamp(depthBiasClamp: number): void {\n      if (this._depthBiasClamp !== depthBiasClamp) {\n          this._depthBiasClamp = depthBiasClamp;\n          this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();\n          this._isDirty = true;\n      }\n  }*/\n  setDepthBiasSlopeScale(depthBiasSlopeScale) {\n    if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {\n      this._depthBiasSlopeScale = depthBiasSlopeScale;\n      this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);\n    }\n  }\n  setColorFormat(format) {\n    this._webgpuColorFormat[0] = format;\n    this._colorFormat = renderableTextureFormatToIndex[format !== null && format !== void 0 ? format : \"\"];\n  }\n  setMRTAttachments(attachments) {\n    this.mrtAttachments = attachments;\n    let mask = 0;\n    for (let i = 0; i < attachments.length; ++i) {\n      if (attachments[i] !== 0) {\n        mask += 1 << i;\n      }\n    }\n    if (this._mrtEnabledMask !== mask) {\n      this._mrtEnabledMask = mask;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\n    }\n  }\n  setMRT(textureArray, textureCount) {\n    var _a, _b;\n    textureCount = textureCount !== null && textureCount !== void 0 ? textureCount : textureArray.length;\n    if (textureCount > 10) {\n      // If we want more than 10 attachments we need to change this method (and the StatePosition enum) but 10 seems plenty: note that WebGPU only supports 8 at the time (2021/12/13)!\n      // As we need 39 different values we are using 6 bits to encode a texture format, meaning we can encode 5 texture formats in 32 bits\n      // We are using 2x32 bit values to handle 10 textures\n      throw \"Can't handle more than 10 attachments for a MRT in cache render pipeline!\";\n    }\n    this.mrtTextureArray = textureArray;\n    this.mrtTextureCount = textureCount;\n    this._mrtEnabledMask = 0xffff; // all textures are enabled at start (meaning we can write to them). Calls to setMRTAttachments may disable some\n    const bits = [0, 0];\n    let indexBits = 0,\n      mask = 0,\n      numRT = 0;\n    for (let i = 0; i < textureCount; ++i) {\n      const texture = textureArray[i];\n      const gpuWrapper = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture;\n      this._mrtFormats[numRT] = (_a = gpuWrapper === null || gpuWrapper === void 0 ? void 0 : gpuWrapper.format) !== null && _a !== void 0 ? _a : this._webgpuColorFormat[0];\n      bits[indexBits] += renderableTextureFormatToIndex[(_b = this._mrtFormats[numRT]) !== null && _b !== void 0 ? _b : \"\"] << mask;\n      mask += 6;\n      numRT++;\n      if (mask >= 32) {\n        mask = 0;\n        indexBits++;\n      }\n    }\n    this._mrtFormats.length = numRT;\n    if (this._mrtAttachments1 !== bits[0] || this._mrtAttachments2 !== bits[1]) {\n      this._mrtAttachments1 = bits[0];\n      this._mrtAttachments2 = bits[1];\n      this._states[StatePosition.MRTAttachments1] = bits[0];\n      this._states[StatePosition.MRTAttachments2] = bits[1];\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\n    }\n  }\n  setAlphaBlendEnabled(enabled) {\n    this._alphaBlendEnabled = enabled;\n  }\n  setAlphaBlendFactors(factors, operations) {\n    this._alphaBlendFuncParams = factors;\n    this._alphaBlendEqParams = operations;\n  }\n  setWriteMask(mask) {\n    this._writeMask = mask;\n  }\n  setDepthStencilFormat(format) {\n    this._webgpuDepthStencilFormat = format;\n    this._depthStencilFormat = format === undefined ? 0 : renderableTextureFormatToIndex[format];\n  }\n  setDepthTestEnabled(enabled) {\n    this._depthTestEnabled = enabled;\n  }\n  setDepthWriteEnabled(enabled) {\n    this._depthWriteEnabled = enabled;\n  }\n  setDepthCompare(func) {\n    this._depthCompare = (func !== null && func !== void 0 ? func : 519) - 0x0200;\n  }\n  setStencilEnabled(enabled) {\n    this._stencilEnabled = enabled;\n  }\n  setStencilCompare(func) {\n    this._stencilFrontCompare = (func !== null && func !== void 0 ? func : 519) - 0x0200;\n  }\n  setStencilDepthFailOp(op) {\n    this._stencilFrontDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\n  }\n  setStencilPassOp(op) {\n    this._stencilFrontPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\n  }\n  setStencilFailOp(op) {\n    this._stencilFrontFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\n  }\n  setStencilReadMask(mask) {\n    if (this._stencilReadMask !== mask) {\n      this._stencilReadMask = mask;\n      this._states[StatePosition.StencilReadMask] = mask;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);\n    }\n  }\n  setStencilWriteMask(mask) {\n    if (this._stencilWriteMask !== mask) {\n      this._stencilWriteMask = mask;\n      this._states[StatePosition.StencilWriteMask] = mask;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);\n    }\n  }\n  resetStencilState() {\n    this.setStencilState(false, 519, 7680, 7681, 7680, 0xff, 0xff);\n  }\n  setStencilState(stencilEnabled, compare, depthFailOp, passOp, failOp, readMask, writeMask) {\n    this._stencilEnabled = stencilEnabled;\n    this._stencilFrontCompare = (compare !== null && compare !== void 0 ? compare : 519) - 0x0200;\n    this._stencilFrontDepthFailOp = depthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[depthFailOp];\n    this._stencilFrontPassOp = passOp === null ? 2 /* REPLACE */ : stencilOpToIndex[passOp];\n    this._stencilFrontFailOp = failOp === null ? 1 /* KEEP */ : stencilOpToIndex[failOp];\n    this.setStencilReadMask(readMask);\n    this.setStencilWriteMask(writeMask);\n  }\n  setBuffers(vertexBuffers, indexBuffer, overrideVertexBuffers) {\n    this._vertexBuffers = vertexBuffers;\n    this._overrideVertexBuffers = overrideVertexBuffers;\n    this._indexBuffer = indexBuffer;\n  }\n  static _GetTopology(fillMode) {\n    switch (fillMode) {\n      // Triangle views\n      case 0:\n        return WebGPUConstants.PrimitiveTopology.TriangleList;\n      case 2:\n        return WebGPUConstants.PrimitiveTopology.PointList;\n      case 1:\n        return WebGPUConstants.PrimitiveTopology.LineList;\n      // Draw modes\n      case 3:\n        return WebGPUConstants.PrimitiveTopology.PointList;\n      case 4:\n        return WebGPUConstants.PrimitiveTopology.LineList;\n      case 5:\n        // return this._gl.LINE_LOOP;\n        // TODO WEBGPU. Line Loop Mode Fallback at buffer load time.\n        throw \"LineLoop is an unsupported fillmode in WebGPU\";\n      case 6:\n        return WebGPUConstants.PrimitiveTopology.LineStrip;\n      case 7:\n        return WebGPUConstants.PrimitiveTopology.TriangleStrip;\n      case 8:\n        // return this._gl.TRIANGLE_FAN;\n        // TODO WEBGPU. Triangle Fan Mode Fallback at buffer load time.\n        throw \"TriangleFan is an unsupported fillmode in WebGPU\";\n      default:\n        return WebGPUConstants.PrimitiveTopology.TriangleList;\n    }\n  }\n  static _GetAphaBlendOperation(operation) {\n    switch (operation) {\n      case 32774:\n        return WebGPUConstants.BlendOperation.Add;\n      case 32778:\n        return WebGPUConstants.BlendOperation.Subtract;\n      case 32779:\n        return WebGPUConstants.BlendOperation.ReverseSubtract;\n      case 32775:\n        return WebGPUConstants.BlendOperation.Min;\n      case 32776:\n        return WebGPUConstants.BlendOperation.Max;\n      default:\n        return WebGPUConstants.BlendOperation.Add;\n    }\n  }\n  static _GetAphaBlendFactor(factor) {\n    switch (factor) {\n      case 0:\n        return WebGPUConstants.BlendFactor.Zero;\n      case 1:\n        return WebGPUConstants.BlendFactor.One;\n      case 768:\n        return WebGPUConstants.BlendFactor.Src;\n      case 769:\n        return WebGPUConstants.BlendFactor.OneMinusSrc;\n      case 770:\n        return WebGPUConstants.BlendFactor.SrcAlpha;\n      case 771:\n        return WebGPUConstants.BlendFactor.OneMinusSrcAlpha;\n      case 772:\n        return WebGPUConstants.BlendFactor.DstAlpha;\n      case 773:\n        return WebGPUConstants.BlendFactor.OneMinusDstAlpha;\n      case 774:\n        return WebGPUConstants.BlendFactor.Dst;\n      case 775:\n        return WebGPUConstants.BlendFactor.OneMinusDst;\n      case 776:\n        return WebGPUConstants.BlendFactor.SrcAlphaSaturated;\n      case 32769:\n        return WebGPUConstants.BlendFactor.Constant;\n      case 32770:\n        return WebGPUConstants.BlendFactor.OneMinusConstant;\n      case 32771:\n        return WebGPUConstants.BlendFactor.Constant;\n      case 32772:\n        return WebGPUConstants.BlendFactor.OneMinusConstant;\n      default:\n        return WebGPUConstants.BlendFactor.One;\n    }\n  }\n  static _GetCompareFunction(compareFunction) {\n    switch (compareFunction) {\n      case 0:\n        // NEVER\n        return WebGPUConstants.CompareFunction.Never;\n      case 1:\n        // LESS\n        return WebGPUConstants.CompareFunction.Less;\n      case 2:\n        // EQUAL\n        return WebGPUConstants.CompareFunction.Equal;\n      case 3:\n        // LEQUAL\n        return WebGPUConstants.CompareFunction.LessEqual;\n      case 4:\n        // GREATER\n        return WebGPUConstants.CompareFunction.Greater;\n      case 5:\n        // NOTEQUAL\n        return WebGPUConstants.CompareFunction.NotEqual;\n      case 6:\n        // GEQUAL\n        return WebGPUConstants.CompareFunction.GreaterEqual;\n      case 7:\n        // ALWAYS\n        return WebGPUConstants.CompareFunction.Always;\n    }\n    return WebGPUConstants.CompareFunction.Never;\n  }\n  static _GetStencilOpFunction(operation) {\n    switch (operation) {\n      case 0:\n        return WebGPUConstants.StencilOperation.Zero;\n      case 1:\n        return WebGPUConstants.StencilOperation.Keep;\n      case 2:\n        return WebGPUConstants.StencilOperation.Replace;\n      case 3:\n        return WebGPUConstants.StencilOperation.IncrementClamp;\n      case 4:\n        return WebGPUConstants.StencilOperation.DecrementClamp;\n      case 5:\n        return WebGPUConstants.StencilOperation.Invert;\n      case 6:\n        return WebGPUConstants.StencilOperation.IncrementWrap;\n      case 7:\n        return WebGPUConstants.StencilOperation.DecrementWrap;\n    }\n    return WebGPUConstants.StencilOperation.Keep;\n  }\n  static _GetVertexInputDescriptorFormat(vertexBuffer) {\n    const type = vertexBuffer.type;\n    const normalized = vertexBuffer.normalized;\n    const size = vertexBuffer.getSize();\n    switch (type) {\n      case VertexBuffer.BYTE:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm8x2 : WebGPUConstants.VertexFormat.Sint8x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm8x4 : WebGPUConstants.VertexFormat.Sint8x4;\n        }\n        break;\n      case VertexBuffer.UNSIGNED_BYTE:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm8x2 : WebGPUConstants.VertexFormat.Uint8x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm8x4 : WebGPUConstants.VertexFormat.Uint8x4;\n        }\n        break;\n      case VertexBuffer.SHORT:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm16x2 : WebGPUConstants.VertexFormat.Sint16x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Snorm16x4 : WebGPUConstants.VertexFormat.Sint16x4;\n        }\n        break;\n      case VertexBuffer.UNSIGNED_SHORT:\n        switch (size) {\n          case 1:\n          case 2:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm16x2 : WebGPUConstants.VertexFormat.Uint16x2;\n          case 3:\n          case 4:\n            return normalized ? WebGPUConstants.VertexFormat.Unorm16x4 : WebGPUConstants.VertexFormat.Uint16x4;\n        }\n        break;\n      case VertexBuffer.INT:\n        switch (size) {\n          case 1:\n            return WebGPUConstants.VertexFormat.Sint32;\n          case 2:\n            return WebGPUConstants.VertexFormat.Sint32x2;\n          case 3:\n            return WebGPUConstants.VertexFormat.Sint32x3;\n          case 4:\n            return WebGPUConstants.VertexFormat.Sint32x4;\n        }\n        break;\n      case VertexBuffer.UNSIGNED_INT:\n        switch (size) {\n          case 1:\n            return WebGPUConstants.VertexFormat.Uint32;\n          case 2:\n            return WebGPUConstants.VertexFormat.Uint32x2;\n          case 3:\n            return WebGPUConstants.VertexFormat.Uint32x3;\n          case 4:\n            return WebGPUConstants.VertexFormat.Uint32x4;\n        }\n        break;\n      case VertexBuffer.FLOAT:\n        switch (size) {\n          case 1:\n            return WebGPUConstants.VertexFormat.Float32;\n          case 2:\n            return WebGPUConstants.VertexFormat.Float32x2;\n          case 3:\n            return WebGPUConstants.VertexFormat.Float32x3;\n          case 4:\n            return WebGPUConstants.VertexFormat.Float32x4;\n        }\n        break;\n    }\n    throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);\n  }\n  _getAphaBlendState() {\n    if (!this._alphaBlendEnabled) {\n      return null;\n    }\n    return {\n      srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),\n      dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),\n      operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[1])\n    };\n  }\n  _getColorBlendState() {\n    if (!this._alphaBlendEnabled) {\n      return null;\n    }\n    return {\n      srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),\n      dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),\n      operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[0])\n    };\n  }\n  _setShaderStage(id) {\n    if (this._shaderId !== id) {\n      this._shaderId = id;\n      this._states[StatePosition.ShaderStage] = id;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);\n    }\n  }\n  _setRasterizationState(topology, sampleCount) {\n    const frontFace = this._frontFace;\n    const cullMode = this._cullEnabled ? this._cullFace : 0;\n    const clampDepth = this._clampDepth ? 1 : 0;\n    const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;\n    const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);\n    if (this._rasterizationState !== rasterizationState) {\n      this._rasterizationState = rasterizationState;\n      this._states[StatePosition.RasterizationState] = this._rasterizationState;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);\n    }\n  }\n  _setColorStates() {\n    let colorStates = ((this._writeMask ? 1 : 0) << 22) + (this._colorFormat << 23) + ((this._depthWriteEnabled ? 1 : 0) << 29); // this state has been moved from depthStencilState here because alpha and depth are related (generally when alpha is on, depth write is off and the other way around)\n    if (this._alphaBlendEnabled) {\n      colorStates += ((this._alphaBlendFuncParams[0] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[0]]) << 0) + ((this._alphaBlendFuncParams[1] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[1]]) << 4) + ((this._alphaBlendFuncParams[2] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[2]]) << 8) + ((this._alphaBlendFuncParams[3] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[3]]) << 12) + ((this._alphaBlendEqParams[0] === null ? 1 : this._alphaBlendEqParams[0] - 0x8005) << 16) + ((this._alphaBlendEqParams[1] === null ? 1 : this._alphaBlendEqParams[1] - 0x8005) << 19);\n    }\n    if (colorStates !== this._colorStates) {\n      this._colorStates = colorStates;\n      this._states[StatePosition.ColorStates] = this._colorStates;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates);\n    }\n  }\n  _setDepthStencilState() {\n    const stencilState = !this._stencilEnabled ? 7 /* ALWAYS */ + (1 /* KEEP */ << 3) + (1 /* KEEP */ << 6) + (1 /* KEEP */ << 9) : this._stencilFrontCompare + (this._stencilFrontDepthFailOp << 3) + (this._stencilFrontPassOp << 6) + (this._stencilFrontFailOp << 9);\n    const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7 /* ALWAYS */) << 6) + (stencilState << 10); // stencil front - stencil back is the same\n    if (this._depthStencilState !== depthStencilState) {\n      this._depthStencilState = depthStencilState;\n      this._states[StatePosition.DepthStencilState] = this._depthStencilState;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);\n    }\n  }\n  _setVertexState(effect) {\n    var _a, _b;\n    const currStateLen = this._statesLength;\n    let newNumStates = StatePosition.VertexState;\n    const webgpuPipelineContext = effect._pipelineContext;\n    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\n    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\n    let currentGPUBuffer;\n    let numVertexBuffers = 0;\n    for (let index = 0; index < attributes.length; index++) {\n      const location = locations[index];\n      let vertexBuffer = (_a = this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) !== null && _a !== void 0 ? _a : this._vertexBuffers[attributes[index]];\n      if (!vertexBuffer) {\n        // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\n        // So we must bind a dummy buffer when we are not given one for a specific attribute\n        vertexBuffer = this._emptyVertexBuffer;\n      }\n      const buffer = (_b = vertexBuffer.getBuffer()) === null || _b === void 0 ? void 0 : _b.underlyingResource;\n      // We optimize usage of GPUVertexBufferLayout: we will create a single GPUVertexBufferLayout for all the attributes which follow each other and which use the same GPU buffer\n      // However, there are some constraints in the attribute.offset value range, so we must check for them before being able to reuse the same GPUVertexBufferLayout\n      // See _getVertexInputDescriptor() below\n      if (vertexBuffer._validOffsetRange === undefined) {\n        const offset = vertexBuffer.byteOffset;\n        const formatSize = vertexBuffer.getSize(true);\n        const byteStride = vertexBuffer.byteStride;\n        vertexBuffer._validOffsetRange = offset <= this._kMaxVertexBufferStride - formatSize && (byteStride === 0 || offset + formatSize <= byteStride);\n      }\n      if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {\n        // we can't combine the previous vertexBuffer with the current one\n        this.vertexBuffers[numVertexBuffers++] = vertexBuffer;\n        currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;\n      }\n      const vid = vertexBuffer.hashCode + (location << 7);\n      this._isDirty = this._isDirty || this._states[newNumStates] !== vid;\n      this._states[newNumStates++] = vid;\n    }\n    this.vertexBuffers.length = numVertexBuffers;\n    this._statesLength = newNumStates;\n    this._isDirty = this._isDirty || newNumStates !== currStateLen;\n    if (this._isDirty) {\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);\n    }\n  }\n  _setTextureState(textureState) {\n    if (this._textureState !== textureState) {\n      this._textureState = textureState;\n      this._states[StatePosition.TextureStage] = this._textureState;\n      this._isDirty = true;\n      this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);\n    }\n  }\n  _createPipelineLayout(webgpuPipelineContext) {\n    if (this._useTextureStage) {\n      return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);\n    }\n    const bindGroupLayouts = [];\n    const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;\n    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\n      const setDefinition = bindGroupLayoutEntries[i];\n      bindGroupLayouts[i] = this._device.createBindGroupLayout({\n        entries: setDefinition\n      });\n    }\n    webgpuPipelineContext.bindGroupLayouts = bindGroupLayouts;\n    return this._device.createPipelineLayout({\n      bindGroupLayouts\n    });\n  }\n  _createPipelineLayoutWithTextureStage(webgpuPipelineContext) {\n    var _a;\n    const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;\n    const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;\n    let bitVal = 1;\n    for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\n      const setDefinition = bindGroupLayoutEntries[i];\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = bindGroupLayoutEntries[i][j];\n        if (entry.texture) {\n          const name = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\n          const textureInfo = shaderProcessingContext.availableTextures[name];\n          const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name + WebGPUShaderProcessor.AutoSamplerSuffix] : null;\n          let sampleType = textureInfo.sampleType;\n          let samplerType = (_a = samplerInfo === null || samplerInfo === void 0 ? void 0 : samplerInfo.type) !== null && _a !== void 0 ? _a : WebGPUConstants.SamplerBindingType.Filtering;\n          if (this._textureState & bitVal && sampleType !== WebGPUConstants.TextureSampleType.Depth) {\n            // The texture is a 32 bits float texture but the system does not support linear filtering for them:\n            // we set the sampler to \"non-filtering\" and the texture sample type to \"unfilterable-float\"\n            if (textureInfo.autoBindSampler) {\n              samplerType = WebGPUConstants.SamplerBindingType.NonFiltering;\n            }\n            sampleType = WebGPUConstants.TextureSampleType.UnfilterableFloat;\n          }\n          entry.texture.sampleType = sampleType;\n          if (samplerInfo) {\n            const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;\n            bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler.type = samplerType;\n          }\n          bitVal = bitVal << 1;\n        }\n      }\n    }\n    const bindGroupLayouts = [];\n    for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {\n      bindGroupLayouts[i] = this._device.createBindGroupLayout({\n        entries: bindGroupLayoutEntries[i]\n      });\n    }\n    webgpuPipelineContext.bindGroupLayouts = bindGroupLayouts;\n    return this._device.createPipelineLayout({\n      bindGroupLayouts\n    });\n  }\n  _getVertexInputDescriptor(effect) {\n    var _a, _b;\n    const descriptors = [];\n    const webgpuPipelineContext = effect._pipelineContext;\n    const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\n    const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\n    let currentGPUBuffer;\n    let currentGPUAttributes;\n    for (let index = 0; index < attributes.length; index++) {\n      const location = locations[index];\n      let vertexBuffer = (_a = this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) !== null && _a !== void 0 ? _a : this._vertexBuffers[attributes[index]];\n      if (!vertexBuffer) {\n        // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\n        // So we must bind a dummy buffer when we are not given one for a specific attribute\n        vertexBuffer = this._emptyVertexBuffer;\n      }\n      let buffer = (_b = vertexBuffer.getBuffer()) === null || _b === void 0 ? void 0 : _b.underlyingResource;\n      // We reuse the same GPUVertexBufferLayout for all attributes that use the same underlying GPU buffer (and for attributes that follow each other in the attributes array)\n      let offset = vertexBuffer.byteOffset;\n      const invalidOffsetRange = !vertexBuffer._validOffsetRange;\n      if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {\n        const vertexBufferDescriptor = {\n          arrayStride: vertexBuffer.byteStride,\n          stepMode: vertexBuffer.getIsInstanced() ? WebGPUConstants.InputStepMode.Instance : WebGPUConstants.InputStepMode.Vertex,\n          attributes: []\n        };\n        descriptors.push(vertexBufferDescriptor);\n        currentGPUAttributes = vertexBufferDescriptor.attributes;\n        if (invalidOffsetRange) {\n          offset = 0; // the offset will be set directly in the setVertexBuffer call\n          buffer = null; // buffer can't be reused\n        }\n      }\n\n      currentGPUAttributes.push({\n        shaderLocation: location,\n        offset,\n        format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer)\n      });\n      currentGPUBuffer = buffer;\n    }\n    return descriptors;\n  }\n  _createRenderPipeline(effect, topology, sampleCount) {\n    var _a, _b, _c;\n    const webgpuPipelineContext = effect._pipelineContext;\n    const inputStateDescriptor = this._getVertexInputDescriptor(effect);\n    const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);\n    const colorStates = [];\n    const alphaBlend = this._getAphaBlendState();\n    const colorBlend = this._getColorBlendState();\n    if (this._mrtAttachments1 > 0) {\n      for (let i = 0; i < this._mrtFormats.length; ++i) {\n        const format = this._mrtFormats[i];\n        if (format) {\n          const descr = {\n            format,\n            writeMask: (this._mrtEnabledMask & 1 << i) !== 0 ? this._writeMask : 0\n          };\n          if (alphaBlend && colorBlend) {\n            descr.blend = {\n              alpha: alphaBlend,\n              color: colorBlend\n            };\n          }\n          colorStates.push(descr);\n        } else {\n          colorStates.push(null);\n        }\n      }\n    } else {\n      if (this._webgpuColorFormat[0]) {\n        const descr = {\n          format: this._webgpuColorFormat[0],\n          writeMask: this._writeMask\n        };\n        if (alphaBlend && colorBlend) {\n          descr.blend = {\n            alpha: alphaBlend,\n            color: colorBlend\n          };\n        }\n        colorStates.push(descr);\n      } else {\n        colorStates.push(null);\n      }\n    }\n    const stencilFrontBack = {\n      compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7 /* ALWAYS */),\n      depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1 /* KEEP */),\n      failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1 /* KEEP */),\n      passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1 /* KEEP */)\n    };\n\n    let stripIndexFormat = undefined;\n    if (topology === WebGPUConstants.PrimitiveTopology.LineStrip || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip) {\n      stripIndexFormat = !this._indexBuffer || this._indexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16;\n    }\n    const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;\n    return this._device.createRenderPipeline({\n      label: `RenderPipeline_${(_b = (_a = colorStates[0]) === null || _a === void 0 ? void 0 : _a.format) !== null && _b !== void 0 ? _b : \"nooutput\"}_${(_c = this._webgpuDepthStencilFormat) !== null && _c !== void 0 ? _c : \"nodepth\"}_samples${sampleCount}`,\n      layout: pipelineLayout,\n      vertex: {\n        module: webgpuPipelineContext.stages.vertexStage.module,\n        entryPoint: webgpuPipelineContext.stages.vertexStage.entryPoint,\n        buffers: inputStateDescriptor\n      },\n      primitive: {\n        topology,\n        stripIndexFormat,\n        frontFace: this._frontFace === 1 ? WebGPUConstants.FrontFace.CCW : WebGPUConstants.FrontFace.CW,\n        cullMode: !this._cullEnabled ? WebGPUConstants.CullMode.None : this._cullFace === 2 ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back\n      },\n      fragment: !webgpuPipelineContext.stages.fragmentStage ? undefined : {\n        module: webgpuPipelineContext.stages.fragmentStage.module,\n        entryPoint: webgpuPipelineContext.stages.fragmentStage.entryPoint,\n        targets: colorStates\n      },\n      multisample: {\n        count: sampleCount\n        /*mask,\n        alphaToCoverageEnabled,*/\n      },\n\n      depthStencil: this._webgpuDepthStencilFormat === undefined ? undefined : {\n        depthWriteEnabled: this._depthWriteEnabled,\n        depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : WebGPUConstants.CompareFunction.Always,\n        format: this._webgpuDepthStencilFormat,\n        stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\n        stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\n        stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : undefined,\n        stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : undefined,\n        depthBias: this._depthBias,\n        depthBiasClamp: this._depthBiasClamp,\n        depthBiasSlopeScale: this._depthBiasSlopeScale\n      }\n    });\n  }\n}\nWebGPUCacheRenderPipeline.NumCacheHitWithoutHash = 0;\nWebGPUCacheRenderPipeline.NumCacheHitWithHash = 0;\nWebGPUCacheRenderPipeline.NumCacheMiss = 0;\nWebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = 0;\nWebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;","map":{"version":3,"mappings":"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","names":["WebGPUConstants","VertexBuffer","WebGPUShaderProcessor","renderableTextureFormatToIndex","WebGPUTextureHelper","StatePosition","alphaBlendFactorToIndex","stencilOpToIndex","WebGPUCacheRenderPipeline","constructor","device","emptyVertexBuffer","useTextureStage","_device","_useTextureStage","_states","Array","_statesLength","_stateDirtyLowestIndex","_emptyVertexBuffer","_mrtFormats","_parameter","token","undefined","pipeline","disabled","vertexBuffers","_kMaxVertexBufferStride","limits","maxVertexBufferArrayStride","reset","_isDirty","length","setAlphaToCoverage","resetDepthCullingState","setClampDepth","setDepthBias","_webgpuColorFormat","TextureFormat","BGRA8Unorm","setColorFormat","setMRT","setAlphaBlendEnabled","setAlphaBlendFactors","setWriteMask","setDepthStencilFormat","Depth24PlusStencil8","setStencilEnabled","resetStencilState","setBuffers","_setTextureState","colorFormats","_mrtAttachments1","getRenderPipeline","fillMode","effect","sampleCount","textureState","topology","_GetTopology","_setVertexState","_createRenderPipeline","NumCacheMiss","_NumPipelineCreationCurrentFrame","_setShaderStage","uniqueId","_setRasterizationState","_setColorStates","_setDepthStencilState","lastStateDirtyLowestIndex","NumCacheHitWithoutHash","_getRenderPipeline","NumCacheHitWithHash","_setRenderPipeline","endFrame","NumPipelineCreationLastFrame","enabled","_alphaToCoverageEnabled","setFrontFace","frontFace","_frontFace","setCullEnabled","_cullEnabled","setCullFace","cullFace","_cullFace","clampDepth","_clampDepth","setDepthCullingState","cullEnabled","zOffset","zOffsetUnits","depthTestEnabled","depthWriteEnabled","depthCompare","_depthWriteEnabled","_depthTestEnabled","_depthCompare","setDepthBiasSlopeScale","depthBias","_depthBias","DepthBias","Math","min","depthBiasSlopeScale","_depthBiasSlopeScale","DepthBiasSlopeScale","format","_colorFormat","setMRTAttachments","attachments","mrtAttachments","mask","i","_mrtEnabledMask","MRTAttachments1","textureArray","textureCount","mrtTextureArray","mrtTextureCount","bits","indexBits","numRT","texture","gpuWrapper","_hardwareTexture","_mrtAttachments2","MRTAttachments2","_alphaBlendEnabled","factors","operations","_alphaBlendFuncParams","_alphaBlendEqParams","_writeMask","_webgpuDepthStencilFormat","_depthStencilFormat","setDepthTestEnabled","setDepthWriteEnabled","setDepthCompare","func","_stencilEnabled","setStencilCompare","_stencilFrontCompare","setStencilDepthFailOp","op","_stencilFrontDepthFailOp","setStencilPassOp","_stencilFrontPassOp","setStencilFailOp","_stencilFrontFailOp","setStencilReadMask","_stencilReadMask","StencilReadMask","setStencilWriteMask","_stencilWriteMask","StencilWriteMask","setStencilState","stencilEnabled","compare","depthFailOp","passOp","failOp","readMask","writeMask","indexBuffer","overrideVertexBuffers","_vertexBuffers","_overrideVertexBuffers","_indexBuffer","PrimitiveTopology","TriangleList","PointList","LineList","LineStrip","TriangleStrip","_GetAphaBlendOperation","operation","BlendOperation","Add","Subtract","ReverseSubtract","Min","Max","_GetAphaBlendFactor","factor","BlendFactor","Zero","One","Src","OneMinusSrc","SrcAlpha","OneMinusSrcAlpha","DstAlpha","OneMinusDstAlpha","Dst","OneMinusDst","SrcAlphaSaturated","Constant","OneMinusConstant","_GetCompareFunction","compareFunction","CompareFunction","Never","Less","Equal","LessEqual","Greater","NotEqual","GreaterEqual","Always","_GetStencilOpFunction","StencilOperation","Keep","Replace","IncrementClamp","DecrementClamp","Invert","IncrementWrap","DecrementWrap","_GetVertexInputDescriptorFormat","vertexBuffer","type","normalized","size","getSize","BYTE","VertexFormat","Snorm8x2","Sint8x2","Snorm8x4","Sint8x4","UNSIGNED_BYTE","Unorm8x2","Uint8x2","Unorm8x4","Uint8x4","SHORT","Snorm16x2","Sint16x2","Snorm16x4","Sint16x4","UNSIGNED_SHORT","Unorm16x2","Uint16x2","Unorm16x4","Uint16x4","INT","Sint32","Sint32x2","Sint32x3","Sint32x4","UNSIGNED_INT","Uint32","Uint32x2","Uint32x3","Uint32x4","FLOAT","Float32","Float32x2","Float32x3","Float32x4","Error","getKind","_getAphaBlendState","srcFactor","dstFactor","_getColorBlendState","id","_shaderId","ShaderStage","cullMode","alphaToCoverage","rasterizationState","_rasterizationState","RasterizationState","colorStates","_colorStates","ColorStates","stencilState","depthStencilState","_depthStencilState","DepthStencilState","currStateLen","newNumStates","VertexState","webgpuPipelineContext","_pipelineContext","attributes","shaderProcessingContext","attributeNamesFromEffect","locations","attributeLocationsFromEffect","currentGPUBuffer","numVertexBuffers","index","location","buffer","getBuffer","underlyingResource","_validOffsetRange","offset","byteOffset","formatSize","byteStride","vid","hashCode","_textureState","TextureStage","_createPipelineLayout","_createPipelineLayoutWithTextureStage","bindGroupLayouts","bindGroupLayoutEntries","setDefinition","createBindGroupLayout","entries","createPipelineLayout","bitVal","j","entry","name","bindGroupLayoutEntryInfo","binding","textureInfo","availableTextures","samplerInfo","autoBindSampler","availableSamplers","AutoSamplerSuffix","sampleType","samplerType","SamplerBindingType","Filtering","TextureSampleType","Depth","NonFiltering","UnfilterableFloat","groupIndex","bindingIndex","sampler","_getVertexInputDescriptor","descriptors","currentGPUAttributes","invalidOffsetRange","vertexBufferDescriptor","arrayStride","stepMode","getIsInstanced","InputStepMode","Instance","Vertex","push","shaderLocation","inputStateDescriptor","pipelineLayout","alphaBlend","colorBlend","descr","blend","alpha","color","stencilFrontBack","stripIndexFormat","is32Bits","IndexFormat","Uint16","depthStencilFormatHasStencil","HasStencilAspect","createRenderPipeline","label","layout","vertex","module","stages","vertexStage","entryPoint","buffers","primitive","FrontFace","CCW","CW","CullMode","None","Front","Back","fragment","fragmentStage","targets","multisample","count","depthStencil","stencilFront","stencilBack","stencilReadMask","stencilWriteMask","depthBiasClamp","_depthBiasClamp"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuCacheRenderPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Constants } from \"../constants\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { DataBuffer } from \"../../Buffers/dataBuffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { renderableTextureFormatToIndex, WebGPUTextureHelper } from \"./webgpuTextureHelper\";\r\n\r\nenum StatePosition {\r\n    StencilReadMask = 0,\r\n    StencilWriteMask = 1,\r\n    //DepthBiasClamp = 1, // not used, so remove it to improve perf\r\n    DepthBias = 2,\r\n    DepthBiasSlopeScale = 3,\r\n    DepthStencilState = 4,\r\n    MRTAttachments1 = 5,\r\n    MRTAttachments2 = 6,\r\n    RasterizationState = 7,\r\n    ColorStates = 8,\r\n    ShaderStage = 9,\r\n    TextureStage = 10,\r\n    VertexState = 11, // vertex state will consume positions 11, 12, ... depending on the number of vertex inputs\r\n\r\n    NumStates = 12,\r\n}\r\n\r\nconst alphaBlendFactorToIndex: { [name: number]: number } = {\r\n    0: 1, // Zero\r\n    1: 2, // One\r\n    0x0300: 3, // SrcColor\r\n    0x0301: 4, // OneMinusSrcColor\r\n    0x0302: 5, // SrcAlpha\r\n    0x0303: 6, // OneMinusSrcAlpha\r\n    0x0304: 7, // DstAlpha\r\n    0x0305: 8, // OneMinusDstAlpha\r\n    0x0306: 9, // DstColor\r\n    0x0307: 10, // OneMinusDstColor\r\n    0x0308: 11, // SrcAlphaSaturated\r\n    0x8001: 12, // BlendColor\r\n    0x8002: 13, // OneMinusBlendColor\r\n    0x8003: 12, // BlendColor (alpha)\r\n    0x8004: 13, // OneMinusBlendColor (alpha)\r\n};\r\n\r\nconst stencilOpToIndex: { [name: number]: number } = {\r\n    0x0000: 0, // ZERO\r\n    0x1e00: 1, // KEEP\r\n    0x1e01: 2, // REPLACE\r\n    0x1e02: 3, // INCR\r\n    0x1e03: 4, // DECR\r\n    0x150a: 5, // INVERT\r\n    0x8507: 6, // INCR_WRAP\r\n    0x8508: 7, // DECR_WRAP\r\n};\r\n\r\n/** @internal */\r\nexport abstract class WebGPUCacheRenderPipeline {\r\n    public static NumCacheHitWithoutHash = 0;\r\n    public static NumCacheHitWithHash = 0;\r\n    public static NumCacheMiss = 0;\r\n    public static NumPipelineCreationLastFrame = 0;\r\n\r\n    public disabled: boolean;\r\n\r\n    private static _NumPipelineCreationCurrentFrame = 0;\r\n\r\n    protected _states: number[];\r\n    protected _statesLength: number;\r\n    protected _stateDirtyLowestIndex: number;\r\n    public lastStateDirtyLowestIndex: number; // for stats only\r\n\r\n    private _device: GPUDevice;\r\n    private _isDirty: boolean;\r\n    private _emptyVertexBuffer: VertexBuffer;\r\n    private _parameter: { token: any; pipeline: Nullable<GPURenderPipeline> };\r\n    private _kMaxVertexBufferStride;\r\n\r\n    private _shaderId: number;\r\n    private _alphaToCoverageEnabled: boolean;\r\n    private _frontFace: number;\r\n    private _cullEnabled: boolean;\r\n    private _cullFace: number;\r\n    private _clampDepth: boolean;\r\n    private _rasterizationState: number;\r\n    private _depthBias: number;\r\n    private _depthBiasClamp: number;\r\n    private _depthBiasSlopeScale: number;\r\n    private _colorFormat: number;\r\n    private _webgpuColorFormat: (GPUTextureFormat | null)[];\r\n    private _mrtAttachments1: number;\r\n    private _mrtAttachments2: number;\r\n    private _mrtFormats: (GPUTextureFormat | null)[];\r\n    private _mrtEnabledMask: number;\r\n    private _alphaBlendEnabled: boolean;\r\n    private _alphaBlendFuncParams: Array<Nullable<number>>;\r\n    private _alphaBlendEqParams: Array<Nullable<number>>;\r\n    private _writeMask: number;\r\n    private _colorStates: number;\r\n    private _depthStencilFormat: number;\r\n    private _webgpuDepthStencilFormat: GPUTextureFormat | undefined;\r\n    private _depthTestEnabled: boolean;\r\n    private _depthWriteEnabled: boolean;\r\n    private _depthCompare: number;\r\n    private _stencilEnabled: boolean;\r\n    private _stencilFrontCompare: number;\r\n    private _stencilFrontDepthFailOp: number;\r\n    private _stencilFrontPassOp: number;\r\n    private _stencilFrontFailOp: number;\r\n    private _stencilReadMask: number;\r\n    private _stencilWriteMask: number;\r\n    private _depthStencilState: number;\r\n    private _vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _textureState: number;\r\n    private _useTextureStage: boolean;\r\n\r\n    constructor(device: GPUDevice, emptyVertexBuffer: VertexBuffer, useTextureStage: boolean) {\r\n        this._device = device;\r\n        this._useTextureStage = useTextureStage;\r\n        this._states = new Array(30); // pre-allocate enough room so that no new allocation will take place afterwards\r\n        this._statesLength = 0;\r\n        this._stateDirtyLowestIndex = 0;\r\n        this._emptyVertexBuffer = emptyVertexBuffer;\r\n        this._mrtFormats = [];\r\n        this._parameter = { token: undefined, pipeline: null };\r\n        this.disabled = false;\r\n        this.vertexBuffers = [];\r\n        this._kMaxVertexBufferStride = device.limits.maxVertexBufferArrayStride || 2048;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this._isDirty = true;\r\n        this.vertexBuffers.length = 0;\r\n        this.setAlphaToCoverage(false);\r\n        this.resetDepthCullingState();\r\n        this.setClampDepth(false);\r\n        this.setDepthBias(0);\r\n        //this.setDepthBiasClamp(0);\r\n        this._webgpuColorFormat = [WebGPUConstants.TextureFormat.BGRA8Unorm];\r\n        this.setColorFormat(WebGPUConstants.TextureFormat.BGRA8Unorm);\r\n        this.setMRT([]);\r\n        this.setAlphaBlendEnabled(false);\r\n        this.setAlphaBlendFactors([null, null, null, null], [null, null]);\r\n        this.setWriteMask(0xf);\r\n        this.setDepthStencilFormat(WebGPUConstants.TextureFormat.Depth24PlusStencil8);\r\n        this.setStencilEnabled(false);\r\n        this.resetStencilState();\r\n        this.setBuffers(null, null, null);\r\n        this._setTextureState(0);\r\n    }\r\n\r\n    protected abstract _getRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n    protected abstract _setRenderPipeline(param: { token: any; pipeline: Nullable<GPURenderPipeline> }): void;\r\n\r\n    public readonly vertexBuffers: VertexBuffer[];\r\n\r\n    public get colorFormats(): (GPUTextureFormat | null)[] {\r\n        return this._mrtAttachments1 > 0 ? this._mrtFormats : this._webgpuColorFormat;\r\n    }\r\n\r\n    public readonly mrtAttachments: number[];\r\n    public readonly mrtTextureArray: InternalTexture[];\r\n    public readonly mrtTextureCount: number = 0;\r\n\r\n    public getRenderPipeline(fillMode: number, effect: Effect, sampleCount: number, textureState = 0): GPURenderPipeline {\r\n        if (sampleCount > 1) {\r\n            // WebGPU only supports 1 or 4\r\n            sampleCount = 4;\r\n        }\r\n        if (this.disabled) {\r\n            const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n            this._setVertexState(effect); // to fill this.vertexBuffers with correct data\r\n\r\n            this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n\r\n            WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n            WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._setShaderStage(effect.uniqueId);\r\n        this._setRasterizationState(fillMode, sampleCount);\r\n        this._setColorStates();\r\n        this._setDepthStencilState();\r\n        this._setVertexState(effect);\r\n        this._setTextureState(textureState);\r\n\r\n        this.lastStateDirtyLowestIndex = this._stateDirtyLowestIndex;\r\n\r\n        if (!this._isDirty && this._parameter.pipeline) {\r\n            this._stateDirtyLowestIndex = this._statesLength;\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithoutHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        this._getRenderPipeline(this._parameter);\r\n\r\n        this._isDirty = false;\r\n        this._stateDirtyLowestIndex = this._statesLength;\r\n\r\n        if (this._parameter.pipeline) {\r\n            WebGPUCacheRenderPipeline.NumCacheHitWithHash++;\r\n            return this._parameter.pipeline;\r\n        }\r\n\r\n        const topology = WebGPUCacheRenderPipeline._GetTopology(fillMode);\r\n\r\n        this._parameter.pipeline = this._createRenderPipeline(effect, topology, sampleCount);\r\n        this._setRenderPipeline(this._parameter);\r\n\r\n        WebGPUCacheRenderPipeline.NumCacheMiss++;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame++;\r\n\r\n        return this._parameter.pipeline;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheRenderPipeline.NumPipelineCreationLastFrame = WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame;\r\n        WebGPUCacheRenderPipeline._NumPipelineCreationCurrentFrame = 0;\r\n    }\r\n\r\n    public setAlphaToCoverage(enabled: boolean): void {\r\n        this._alphaToCoverageEnabled = enabled;\r\n    }\r\n\r\n    public setFrontFace(frontFace: number): void {\r\n        this._frontFace = frontFace;\r\n    }\r\n\r\n    public setCullEnabled(enabled: boolean): void {\r\n        this._cullEnabled = enabled;\r\n    }\r\n\r\n    public setCullFace(cullFace: number): void {\r\n        this._cullFace = cullFace;\r\n    }\r\n\r\n    public setClampDepth(clampDepth: boolean): void {\r\n        this._clampDepth = clampDepth;\r\n    }\r\n\r\n    public resetDepthCullingState(): void {\r\n        this.setDepthCullingState(false, 2, 1, 0, 0, true, true, Constants.ALWAYS);\r\n    }\r\n\r\n    public setDepthCullingState(\r\n        cullEnabled: boolean,\r\n        frontFace: number,\r\n        cullFace: number,\r\n        zOffset: number,\r\n        zOffsetUnits: number,\r\n        depthTestEnabled: boolean,\r\n        depthWriteEnabled: boolean,\r\n        depthCompare: Nullable<number>\r\n    ): void {\r\n        this._depthWriteEnabled = depthWriteEnabled;\r\n        this._depthTestEnabled = depthTestEnabled;\r\n        this._depthCompare = (depthCompare ?? Constants.ALWAYS) - 0x0200;\r\n        this._cullFace = cullFace;\r\n        this._cullEnabled = cullEnabled;\r\n        this._frontFace = frontFace;\r\n        this.setDepthBiasSlopeScale(zOffset);\r\n        this.setDepthBias(zOffsetUnits);\r\n    }\r\n\r\n    public setDepthBias(depthBias: number): void {\r\n        if (this._depthBias !== depthBias) {\r\n            this._depthBias = depthBias;\r\n            this._states[StatePosition.DepthBias] = depthBias;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBias);\r\n        }\r\n    }\r\n\r\n    /*public setDepthBiasClamp(depthBiasClamp: number): void {\r\n        if (this._depthBiasClamp !== depthBiasClamp) {\r\n            this._depthBiasClamp = depthBiasClamp;\r\n            this._states[StatePosition.DepthBiasClamp] = depthBiasClamp.toString();\r\n            this._isDirty = true;\r\n        }\r\n    }*/\r\n\r\n    public setDepthBiasSlopeScale(depthBiasSlopeScale: number): void {\r\n        if (this._depthBiasSlopeScale !== depthBiasSlopeScale) {\r\n            this._depthBiasSlopeScale = depthBiasSlopeScale;\r\n            this._states[StatePosition.DepthBiasSlopeScale] = depthBiasSlopeScale;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthBiasSlopeScale);\r\n        }\r\n    }\r\n\r\n    public setColorFormat(format: GPUTextureFormat | null): void {\r\n        this._webgpuColorFormat[0] = format;\r\n        this._colorFormat = renderableTextureFormatToIndex[format ?? \"\"];\r\n    }\r\n\r\n    public setMRTAttachments(attachments: number[]): void {\r\n        (this.mrtAttachments as any) = attachments;\r\n        let mask = 0;\r\n        for (let i = 0; i < attachments.length; ++i) {\r\n            if (attachments[i] !== 0) {\r\n                mask += 1 << i;\r\n            }\r\n        }\r\n        if (this._mrtEnabledMask !== mask) {\r\n            this._mrtEnabledMask = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\r\n        }\r\n    }\r\n\r\n    public setMRT(textureArray: InternalTexture[], textureCount?: number): void {\r\n        textureCount = textureCount ?? textureArray.length;\r\n        if (textureCount > 10) {\r\n            // If we want more than 10 attachments we need to change this method (and the StatePosition enum) but 10 seems plenty: note that WebGPU only supports 8 at the time (2021/12/13)!\r\n            // As we need 39 different values we are using 6 bits to encode a texture format, meaning we can encode 5 texture formats in 32 bits\r\n            // We are using 2x32 bit values to handle 10 textures\r\n            throw \"Can't handle more than 10 attachments for a MRT in cache render pipeline!\";\r\n        }\r\n        (this.mrtTextureArray as any) = textureArray;\r\n        (this.mrtTextureCount as any) = textureCount;\r\n\r\n        this._mrtEnabledMask = 0xffff; // all textures are enabled at start (meaning we can write to them). Calls to setMRTAttachments may disable some\r\n\r\n        const bits: number[] = [0, 0];\r\n        let indexBits = 0,\r\n            mask = 0,\r\n            numRT = 0;\r\n        for (let i = 0; i < textureCount; ++i) {\r\n            const texture = textureArray[i];\r\n            const gpuWrapper = texture?._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n            this._mrtFormats[numRT] = gpuWrapper?.format ?? this._webgpuColorFormat[0];\r\n\r\n            bits[indexBits] += renderableTextureFormatToIndex[this._mrtFormats[numRT] ?? \"\"] << mask;\r\n            mask += 6;\r\n            numRT++;\r\n\r\n            if (mask >= 32) {\r\n                mask = 0;\r\n                indexBits++;\r\n            }\r\n        }\r\n        this._mrtFormats.length = numRT;\r\n        if (this._mrtAttachments1 !== bits[0] || this._mrtAttachments2 !== bits[1]) {\r\n            this._mrtAttachments1 = bits[0];\r\n            this._mrtAttachments2 = bits[1];\r\n            this._states[StatePosition.MRTAttachments1] = bits[0];\r\n            this._states[StatePosition.MRTAttachments2] = bits[1];\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.MRTAttachments1);\r\n        }\r\n    }\r\n\r\n    public setAlphaBlendEnabled(enabled: boolean): void {\r\n        this._alphaBlendEnabled = enabled;\r\n    }\r\n\r\n    public setAlphaBlendFactors(factors: Array<Nullable<number>>, operations: Array<Nullable<number>>): void {\r\n        this._alphaBlendFuncParams = factors;\r\n        this._alphaBlendEqParams = operations;\r\n    }\r\n\r\n    public setWriteMask(mask: number): void {\r\n        this._writeMask = mask;\r\n    }\r\n\r\n    public setDepthStencilFormat(format: GPUTextureFormat | undefined): void {\r\n        this._webgpuDepthStencilFormat = format;\r\n        this._depthStencilFormat = format === undefined ? 0 : renderableTextureFormatToIndex[format];\r\n    }\r\n\r\n    public setDepthTestEnabled(enabled: boolean): void {\r\n        this._depthTestEnabled = enabled;\r\n    }\r\n\r\n    public setDepthWriteEnabled(enabled: boolean): void {\r\n        this._depthWriteEnabled = enabled;\r\n    }\r\n\r\n    public setDepthCompare(func: Nullable<number>): void {\r\n        this._depthCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilEnabled(enabled: boolean): void {\r\n        this._stencilEnabled = enabled;\r\n    }\r\n\r\n    public setStencilCompare(func: Nullable<number>): void {\r\n        this._stencilFrontCompare = (func ?? Constants.ALWAYS) - 0x0200;\r\n    }\r\n\r\n    public setStencilDepthFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontDepthFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilPassOp(op: Nullable<number>): void {\r\n        this._stencilFrontPassOp = op === null ? 2 /* REPLACE */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilFailOp(op: Nullable<number>): void {\r\n        this._stencilFrontFailOp = op === null ? 1 /* KEEP */ : stencilOpToIndex[op];\r\n    }\r\n\r\n    public setStencilReadMask(mask: number): void {\r\n        if (this._stencilReadMask !== mask) {\r\n            this._stencilReadMask = mask;\r\n            this._states[StatePosition.StencilReadMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilReadMask);\r\n        }\r\n    }\r\n\r\n    public setStencilWriteMask(mask: number): void {\r\n        if (this._stencilWriteMask !== mask) {\r\n            this._stencilWriteMask = mask;\r\n            this._states[StatePosition.StencilWriteMask] = mask;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.StencilWriteMask);\r\n        }\r\n    }\r\n\r\n    public resetStencilState(): void {\r\n        this.setStencilState(false, Constants.ALWAYS, Constants.KEEP, Constants.REPLACE, Constants.KEEP, 0xff, 0xff);\r\n    }\r\n\r\n    public setStencilState(\r\n        stencilEnabled: boolean,\r\n        compare: Nullable<number>,\r\n        depthFailOp: Nullable<number>,\r\n        passOp: Nullable<number>,\r\n        failOp: Nullable<number>,\r\n        readMask: number,\r\n        writeMask: number\r\n    ): void {\r\n        this._stencilEnabled = stencilEnabled;\r\n        this._stencilFrontCompare = (compare ?? Constants.ALWAYS) - 0x0200;\r\n        this._stencilFrontDepthFailOp = depthFailOp === null ? 1 /* KEEP */ : stencilOpToIndex[depthFailOp];\r\n        this._stencilFrontPassOp = passOp === null ? 2 /* REPLACE */ : stencilOpToIndex[passOp];\r\n        this._stencilFrontFailOp = failOp === null ? 1 /* KEEP */ : stencilOpToIndex[failOp];\r\n        this.setStencilReadMask(readMask);\r\n        this.setStencilWriteMask(writeMask);\r\n    }\r\n\r\n    public setBuffers(\r\n        vertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>,\r\n        indexBuffer: Nullable<DataBuffer>,\r\n        overrideVertexBuffers: Nullable<{ [key: string]: Nullable<VertexBuffer> }>\r\n    ): void {\r\n        this._vertexBuffers = vertexBuffers;\r\n        this._overrideVertexBuffers = overrideVertexBuffers;\r\n        this._indexBuffer = indexBuffer;\r\n    }\r\n\r\n    private static _GetTopology(fillMode: number): GPUPrimitiveTopology {\r\n        switch (fillMode) {\r\n            // Triangle views\r\n            case Constants.MATERIAL_TriangleFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n            case Constants.MATERIAL_PointFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_WireFrameFillMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            // Draw modes\r\n            case Constants.MATERIAL_PointListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.PointList;\r\n            case Constants.MATERIAL_LineListDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineList;\r\n            case Constants.MATERIAL_LineLoopDrawMode:\r\n                // return this._gl.LINE_LOOP;\r\n                // TODO WEBGPU. Line Loop Mode Fallback at buffer load time.\r\n                throw \"LineLoop is an unsupported fillmode in WebGPU\";\r\n            case Constants.MATERIAL_LineStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.LineStrip;\r\n            case Constants.MATERIAL_TriangleStripDrawMode:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleStrip;\r\n            case Constants.MATERIAL_TriangleFanDrawMode:\r\n                // return this._gl.TRIANGLE_FAN;\r\n                // TODO WEBGPU. Triangle Fan Mode Fallback at buffer load time.\r\n                throw \"TriangleFan is an unsupported fillmode in WebGPU\";\r\n            default:\r\n                return WebGPUConstants.PrimitiveTopology.TriangleList;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendOperation(operation: Nullable<number>): GPUBlendOperation {\r\n        switch (operation) {\r\n            case Constants.GL_ALPHA_EQUATION_ADD:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n            case Constants.GL_ALPHA_EQUATION_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.Subtract;\r\n            case Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT:\r\n                return WebGPUConstants.BlendOperation.ReverseSubtract;\r\n            case Constants.GL_ALPHA_EQUATION_MIN:\r\n                return WebGPUConstants.BlendOperation.Min;\r\n            case Constants.GL_ALPHA_EQUATION_MAX:\r\n                return WebGPUConstants.BlendOperation.Max;\r\n            default:\r\n                return WebGPUConstants.BlendOperation.Add;\r\n        }\r\n    }\r\n\r\n    private static _GetAphaBlendFactor(factor: Nullable<number>): GPUBlendFactor {\r\n        switch (factor) {\r\n            case 0:\r\n                return WebGPUConstants.BlendFactor.Zero;\r\n            case 1:\r\n                return WebGPUConstants.BlendFactor.One;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC:\r\n                return WebGPUConstants.BlendFactor.Src;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrc;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.SrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusSrcAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.DstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusDstAlpha;\r\n            case Constants.GL_ALPHA_FUNCTION_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.Dst;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusDst;\r\n            case Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED:\r\n                return WebGPUConstants.BlendFactor.SrcAlphaSaturated;\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR:\r\n                return WebGPUConstants.BlendFactor.Constant;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR:\r\n                return WebGPUConstants.BlendFactor.OneMinusConstant;\r\n            case Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.Constant;\r\n            case Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA:\r\n                return WebGPUConstants.BlendFactor.OneMinusConstant;\r\n            default:\r\n                return WebGPUConstants.BlendFactor.One;\r\n        }\r\n    }\r\n\r\n    private static _GetCompareFunction(compareFunction: number): GPUCompareFunction {\r\n        switch (compareFunction) {\r\n            case 0: // NEVER\r\n                return WebGPUConstants.CompareFunction.Never;\r\n            case 1: // LESS\r\n                return WebGPUConstants.CompareFunction.Less;\r\n            case 2: // EQUAL\r\n                return WebGPUConstants.CompareFunction.Equal;\r\n            case 3: // LEQUAL\r\n                return WebGPUConstants.CompareFunction.LessEqual;\r\n            case 4: // GREATER\r\n                return WebGPUConstants.CompareFunction.Greater;\r\n            case 5: // NOTEQUAL\r\n                return WebGPUConstants.CompareFunction.NotEqual;\r\n            case 6: // GEQUAL\r\n                return WebGPUConstants.CompareFunction.GreaterEqual;\r\n            case 7: // ALWAYS\r\n                return WebGPUConstants.CompareFunction.Always;\r\n        }\r\n        return WebGPUConstants.CompareFunction.Never;\r\n    }\r\n\r\n    private static _GetStencilOpFunction(operation: number): GPUStencilOperation {\r\n        switch (operation) {\r\n            case 0:\r\n                return WebGPUConstants.StencilOperation.Zero;\r\n            case 1:\r\n                return WebGPUConstants.StencilOperation.Keep;\r\n            case 2:\r\n                return WebGPUConstants.StencilOperation.Replace;\r\n            case 3:\r\n                return WebGPUConstants.StencilOperation.IncrementClamp;\r\n            case 4:\r\n                return WebGPUConstants.StencilOperation.DecrementClamp;\r\n            case 5:\r\n                return WebGPUConstants.StencilOperation.Invert;\r\n            case 6:\r\n                return WebGPUConstants.StencilOperation.IncrementWrap;\r\n            case 7:\r\n                return WebGPUConstants.StencilOperation.DecrementWrap;\r\n        }\r\n        return WebGPUConstants.StencilOperation.Keep;\r\n    }\r\n\r\n    private static _GetVertexInputDescriptorFormat(vertexBuffer: VertexBuffer): GPUVertexFormat {\r\n        const type = vertexBuffer.type;\r\n        const normalized = vertexBuffer.normalized;\r\n        const size = vertexBuffer.getSize();\r\n\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x2 : WebGPUConstants.VertexFormat.Sint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm8x4 : WebGPUConstants.VertexFormat.Sint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x2 : WebGPUConstants.VertexFormat.Uint8x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm8x4 : WebGPUConstants.VertexFormat.Uint8x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x2 : WebGPUConstants.VertexFormat.Sint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Snorm16x4 : WebGPUConstants.VertexFormat.Sint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                switch (size) {\r\n                    case 1:\r\n                    case 2:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x2 : WebGPUConstants.VertexFormat.Uint16x2;\r\n                    case 3:\r\n                    case 4:\r\n                        return normalized ? WebGPUConstants.VertexFormat.Unorm16x4 : WebGPUConstants.VertexFormat.Uint16x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Sint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Sint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Sint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Sint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.UNSIGNED_INT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Uint32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Uint32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Uint32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Uint32x4;\r\n                }\r\n                break;\r\n            case VertexBuffer.FLOAT:\r\n                switch (size) {\r\n                    case 1:\r\n                        return WebGPUConstants.VertexFormat.Float32;\r\n                    case 2:\r\n                        return WebGPUConstants.VertexFormat.Float32x2;\r\n                    case 3:\r\n                        return WebGPUConstants.VertexFormat.Float32x3;\r\n                    case 4:\r\n                        return WebGPUConstants.VertexFormat.Float32x4;\r\n                }\r\n                break;\r\n        }\r\n\r\n        throw new Error(`Invalid Format '${vertexBuffer.getKind()}' - type=${type}, normalized=${normalized}, size=${size}`);\r\n    }\r\n\r\n    private _getAphaBlendState(): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[2]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[3]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[1]),\r\n        };\r\n    }\r\n\r\n    private _getColorBlendState(): Nullable<GPUBlendComponent> {\r\n        if (!this._alphaBlendEnabled) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            srcFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[0]),\r\n            dstFactor: WebGPUCacheRenderPipeline._GetAphaBlendFactor(this._alphaBlendFuncParams[1]),\r\n            operation: WebGPUCacheRenderPipeline._GetAphaBlendOperation(this._alphaBlendEqParams[0]),\r\n        };\r\n    }\r\n\r\n    private _setShaderStage(id: number): void {\r\n        if (this._shaderId !== id) {\r\n            this._shaderId = id;\r\n            this._states[StatePosition.ShaderStage] = id;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ShaderStage);\r\n        }\r\n    }\r\n\r\n    private _setRasterizationState(topology: number, sampleCount: number): void {\r\n        const frontFace = this._frontFace;\r\n        const cullMode = this._cullEnabled ? this._cullFace : 0;\r\n        const clampDepth = this._clampDepth ? 1 : 0;\r\n        const alphaToCoverage = this._alphaToCoverageEnabled ? 1 : 0;\r\n        const rasterizationState = frontFace - 1 + (cullMode << 1) + (clampDepth << 3) + (alphaToCoverage << 4) + (topology << 5) + (sampleCount << 8);\r\n\r\n        if (this._rasterizationState !== rasterizationState) {\r\n            this._rasterizationState = rasterizationState;\r\n            this._states[StatePosition.RasterizationState] = this._rasterizationState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.RasterizationState);\r\n        }\r\n    }\r\n\r\n    private _setColorStates(): void {\r\n        let colorStates = ((this._writeMask ? 1 : 0) << 22) + (this._colorFormat << 23) + ((this._depthWriteEnabled ? 1 : 0) << 29); // this state has been moved from depthStencilState here because alpha and depth are related (generally when alpha is on, depth write is off and the other way around)\r\n\r\n        if (this._alphaBlendEnabled) {\r\n            colorStates +=\r\n                ((this._alphaBlendFuncParams[0] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[0]]) << 0) +\r\n                ((this._alphaBlendFuncParams[1] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[1]]) << 4) +\r\n                ((this._alphaBlendFuncParams[2] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[2]]) << 8) +\r\n                ((this._alphaBlendFuncParams[3] === null ? 2 : alphaBlendFactorToIndex[this._alphaBlendFuncParams[3]]) << 12) +\r\n                ((this._alphaBlendEqParams[0] === null ? 1 : this._alphaBlendEqParams[0] - 0x8005) << 16) +\r\n                ((this._alphaBlendEqParams[1] === null ? 1 : this._alphaBlendEqParams[1] - 0x8005) << 19);\r\n        }\r\n\r\n        if (colorStates !== this._colorStates) {\r\n            this._colorStates = colorStates;\r\n            this._states[StatePosition.ColorStates] = this._colorStates;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.ColorStates);\r\n        }\r\n    }\r\n\r\n    private _setDepthStencilState(): void {\r\n        const stencilState = !this._stencilEnabled\r\n            ? 7 /* ALWAYS */ + (1 /* KEEP */ << 3) + (1 /* KEEP */ << 6) + (1 /* KEEP */ << 9)\r\n            : this._stencilFrontCompare + (this._stencilFrontDepthFailOp << 3) + (this._stencilFrontPassOp << 6) + (this._stencilFrontFailOp << 9);\r\n\r\n        const depthStencilState = this._depthStencilFormat + ((this._depthTestEnabled ? this._depthCompare : 7) /* ALWAYS */ << 6) + (stencilState << 10); // stencil front - stencil back is the same\r\n\r\n        if (this._depthStencilState !== depthStencilState) {\r\n            this._depthStencilState = depthStencilState;\r\n            this._states[StatePosition.DepthStencilState] = this._depthStencilState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.DepthStencilState);\r\n        }\r\n    }\r\n\r\n    private _setVertexState(effect: Effect): void {\r\n        const currStateLen = this._statesLength;\r\n        let newNumStates = StatePosition.VertexState;\r\n\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let numVertexBuffers = 0;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n            }\r\n\r\n            const buffer = vertexBuffer.getBuffer()?.underlyingResource;\r\n\r\n            // We optimize usage of GPUVertexBufferLayout: we will create a single GPUVertexBufferLayout for all the attributes which follow each other and which use the same GPU buffer\r\n            // However, there are some constraints in the attribute.offset value range, so we must check for them before being able to reuse the same GPUVertexBufferLayout\r\n            // See _getVertexInputDescriptor() below\r\n            if (vertexBuffer._validOffsetRange === undefined) {\r\n                const offset = vertexBuffer.byteOffset;\r\n                const formatSize = vertexBuffer.getSize(true);\r\n                const byteStride = vertexBuffer.byteStride;\r\n                vertexBuffer._validOffsetRange = offset <= this._kMaxVertexBufferStride - formatSize && (byteStride === 0 || offset + formatSize <= byteStride);\r\n            }\r\n\r\n            if (!(currentGPUBuffer && currentGPUBuffer === buffer && vertexBuffer._validOffsetRange)) {\r\n                // we can't combine the previous vertexBuffer with the current one\r\n                this.vertexBuffers[numVertexBuffers++] = vertexBuffer;\r\n                currentGPUBuffer = vertexBuffer._validOffsetRange ? buffer : null;\r\n            }\r\n\r\n            const vid = vertexBuffer.hashCode + (location << 7);\r\n\r\n            this._isDirty = this._isDirty || this._states[newNumStates] !== vid;\r\n            this._states[newNumStates++] = vid;\r\n        }\r\n\r\n        this.vertexBuffers.length = numVertexBuffers;\r\n\r\n        this._statesLength = newNumStates;\r\n        this._isDirty = this._isDirty || newNumStates !== currStateLen;\r\n        if (this._isDirty) {\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.VertexState);\r\n        }\r\n    }\r\n\r\n    private _setTextureState(textureState: number): void {\r\n        if (this._textureState !== textureState) {\r\n            this._textureState = textureState;\r\n            this._states[StatePosition.TextureStage] = this._textureState;\r\n            this._isDirty = true;\r\n            this._stateDirtyLowestIndex = Math.min(this._stateDirtyLowestIndex, StatePosition.TextureStage);\r\n        }\r\n    }\r\n\r\n    private _createPipelineLayout(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        if (this._useTextureStage) {\r\n            return this._createPipelineLayoutWithTextureStage(webgpuPipelineContext);\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n        const bindGroupLayoutEntries = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: setDefinition,\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _createPipelineLayoutWithTextureStage(webgpuPipelineContext: WebGPUPipelineContext): GPUPipelineLayout {\r\n        const shaderProcessingContext = webgpuPipelineContext.shaderProcessingContext;\r\n        const bindGroupLayoutEntries = shaderProcessingContext.bindGroupLayoutEntries;\r\n\r\n        let bitVal = 1;\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = bindGroupLayoutEntries[i];\r\n\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = bindGroupLayoutEntries[i][j];\r\n\r\n                if (entry.texture) {\r\n                    const name = shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding].name;\r\n                    const textureInfo = shaderProcessingContext.availableTextures[name];\r\n                    const samplerInfo = textureInfo.autoBindSampler ? shaderProcessingContext.availableSamplers[name + WebGPUShaderProcessor.AutoSamplerSuffix] : null;\r\n\r\n                    let sampleType = textureInfo.sampleType;\r\n                    let samplerType = samplerInfo?.type ?? WebGPUConstants.SamplerBindingType.Filtering;\r\n\r\n                    if (this._textureState & bitVal && sampleType !== WebGPUConstants.TextureSampleType.Depth) {\r\n                        // The texture is a 32 bits float texture but the system does not support linear filtering for them:\r\n                        // we set the sampler to \"non-filtering\" and the texture sample type to \"unfilterable-float\"\r\n                        if (textureInfo.autoBindSampler) {\r\n                            samplerType = WebGPUConstants.SamplerBindingType.NonFiltering;\r\n                        }\r\n                        sampleType = WebGPUConstants.TextureSampleType.UnfilterableFloat;\r\n                    }\r\n\r\n                    entry.texture!.sampleType = sampleType;\r\n\r\n                    if (samplerInfo) {\r\n                        const binding = shaderProcessingContext.bindGroupLayoutEntryInfo[samplerInfo.binding.groupIndex][samplerInfo.binding.bindingIndex].index;\r\n                        bindGroupLayoutEntries[samplerInfo.binding.groupIndex][binding].sampler!.type = samplerType;\r\n                    }\r\n\r\n                    bitVal = bitVal << 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        const bindGroupLayouts: GPUBindGroupLayout[] = [];\r\n\r\n        for (let i = 0; i < bindGroupLayoutEntries.length; ++i) {\r\n            bindGroupLayouts[i] = this._device.createBindGroupLayout({\r\n                entries: bindGroupLayoutEntries[i],\r\n            });\r\n        }\r\n\r\n        webgpuPipelineContext.bindGroupLayouts = bindGroupLayouts;\r\n\r\n        return this._device.createPipelineLayout({ bindGroupLayouts });\r\n    }\r\n\r\n    private _getVertexInputDescriptor(effect: Effect): GPUVertexBufferLayout[] {\r\n        const descriptors: GPUVertexBufferLayout[] = [];\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const attributes = webgpuPipelineContext.shaderProcessingContext.attributeNamesFromEffect;\r\n        const locations = webgpuPipelineContext.shaderProcessingContext.attributeLocationsFromEffect;\r\n\r\n        let currentGPUBuffer;\r\n        let currentGPUAttributes: GPUVertexAttribute[] | undefined;\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = locations[index];\r\n            let vertexBuffer = (this._overrideVertexBuffers && this._overrideVertexBuffers[attributes[index]]) ?? this._vertexBuffers![attributes[index]];\r\n            if (!vertexBuffer) {\r\n                // In WebGL it's valid to not bind a vertex buffer to an attribute, but it's not valid in WebGPU\r\n                // So we must bind a dummy buffer when we are not given one for a specific attribute\r\n                vertexBuffer = this._emptyVertexBuffer;\r\n            }\r\n\r\n            let buffer = vertexBuffer.getBuffer()?.underlyingResource;\r\n\r\n            // We reuse the same GPUVertexBufferLayout for all attributes that use the same underlying GPU buffer (and for attributes that follow each other in the attributes array)\r\n            let offset = vertexBuffer.byteOffset;\r\n            const invalidOffsetRange = !vertexBuffer._validOffsetRange;\r\n            if (!(currentGPUBuffer && currentGPUAttributes && currentGPUBuffer === buffer) || invalidOffsetRange) {\r\n                const vertexBufferDescriptor: GPUVertexBufferLayout = {\r\n                    arrayStride: vertexBuffer.byteStride,\r\n                    stepMode: vertexBuffer.getIsInstanced() ? WebGPUConstants.InputStepMode.Instance : WebGPUConstants.InputStepMode.Vertex,\r\n                    attributes: [],\r\n                };\r\n\r\n                descriptors.push(vertexBufferDescriptor);\r\n                currentGPUAttributes = vertexBufferDescriptor.attributes;\r\n                if (invalidOffsetRange) {\r\n                    offset = 0; // the offset will be set directly in the setVertexBuffer call\r\n                    buffer = null; // buffer can't be reused\r\n                }\r\n            }\r\n\r\n            currentGPUAttributes.push({\r\n                shaderLocation: location,\r\n                offset,\r\n                format: WebGPUCacheRenderPipeline._GetVertexInputDescriptorFormat(vertexBuffer),\r\n            });\r\n\r\n            currentGPUBuffer = buffer;\r\n        }\r\n\r\n        return descriptors;\r\n    }\r\n\r\n    private _createRenderPipeline(effect: Effect, topology: GPUPrimitiveTopology, sampleCount: number): GPURenderPipeline {\r\n        const webgpuPipelineContext = effect._pipelineContext as WebGPUPipelineContext;\r\n        const inputStateDescriptor = this._getVertexInputDescriptor(effect);\r\n        const pipelineLayout = this._createPipelineLayout(webgpuPipelineContext);\r\n\r\n        const colorStates: Array<GPUColorTargetState | null> = [];\r\n        const alphaBlend = this._getAphaBlendState();\r\n        const colorBlend = this._getColorBlendState();\r\n\r\n        if (this._mrtAttachments1 > 0) {\r\n            for (let i = 0; i < this._mrtFormats.length; ++i) {\r\n                const format = this._mrtFormats[i];\r\n                if (format) {\r\n                    const descr: GPUColorTargetState = {\r\n                        format,\r\n                        writeMask: (this._mrtEnabledMask & (1 << i)) !== 0 ? this._writeMask : 0,\r\n                    };\r\n                    if (alphaBlend && colorBlend) {\r\n                        descr.blend = {\r\n                            alpha: alphaBlend,\r\n                            color: colorBlend,\r\n                        };\r\n                    }\r\n                    colorStates.push(descr);\r\n                } else {\r\n                    colorStates.push(null);\r\n                }\r\n            }\r\n        } else {\r\n            if (this._webgpuColorFormat[0]) {\r\n                const descr: GPUColorTargetState = {\r\n                    format: this._webgpuColorFormat[0],\r\n                    writeMask: this._writeMask,\r\n                };\r\n                if (alphaBlend && colorBlend) {\r\n                    descr.blend = {\r\n                        alpha: alphaBlend,\r\n                        color: colorBlend,\r\n                    };\r\n                }\r\n                colorStates.push(descr);\r\n            } else {\r\n                colorStates.push(null);\r\n            }\r\n        }\r\n\r\n        const stencilFrontBack: GPUStencilStateFace = {\r\n            compare: WebGPUCacheRenderPipeline._GetCompareFunction(this._stencilEnabled ? this._stencilFrontCompare : 7 /* ALWAYS */),\r\n            depthFailOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontDepthFailOp : 1 /* KEEP */),\r\n            failOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontFailOp : 1 /* KEEP */),\r\n            passOp: WebGPUCacheRenderPipeline._GetStencilOpFunction(this._stencilEnabled ? this._stencilFrontPassOp : 1 /* KEEP */),\r\n        };\r\n\r\n        let stripIndexFormat: GPUIndexFormat | undefined = undefined;\r\n        if (topology === WebGPUConstants.PrimitiveTopology.LineStrip || topology === WebGPUConstants.PrimitiveTopology.TriangleStrip) {\r\n            stripIndexFormat = !this._indexBuffer || this._indexBuffer.is32Bits ? WebGPUConstants.IndexFormat.Uint32 : WebGPUConstants.IndexFormat.Uint16;\r\n        }\r\n\r\n        const depthStencilFormatHasStencil = this._webgpuDepthStencilFormat ? WebGPUTextureHelper.HasStencilAspect(this._webgpuDepthStencilFormat) : false;\r\n\r\n        return this._device.createRenderPipeline({\r\n            label: `RenderPipeline_${colorStates[0]?.format ?? \"nooutput\"}_${this._webgpuDepthStencilFormat ?? \"nodepth\"}_samples${sampleCount}`,\r\n            layout: pipelineLayout,\r\n            vertex: {\r\n                module: webgpuPipelineContext.stages!.vertexStage.module,\r\n                entryPoint: webgpuPipelineContext.stages!.vertexStage.entryPoint,\r\n                buffers: inputStateDescriptor,\r\n            },\r\n            primitive: {\r\n                topology,\r\n                stripIndexFormat,\r\n                frontFace: this._frontFace === 1 ? WebGPUConstants.FrontFace.CCW : WebGPUConstants.FrontFace.CW,\r\n                cullMode: !this._cullEnabled ? WebGPUConstants.CullMode.None : this._cullFace === 2 ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back,\r\n            },\r\n            fragment: !webgpuPipelineContext.stages!.fragmentStage\r\n                ? undefined\r\n                : {\r\n                      module: webgpuPipelineContext.stages!.fragmentStage.module,\r\n                      entryPoint: webgpuPipelineContext.stages!.fragmentStage.entryPoint,\r\n                      targets: colorStates,\r\n                  },\r\n\r\n            multisample: {\r\n                count: sampleCount,\r\n                /*mask,\r\n                alphaToCoverageEnabled,*/\r\n            },\r\n            depthStencil:\r\n                this._webgpuDepthStencilFormat === undefined\r\n                    ? undefined\r\n                    : {\r\n                          depthWriteEnabled: this._depthWriteEnabled,\r\n                          depthCompare: this._depthTestEnabled ? WebGPUCacheRenderPipeline._GetCompareFunction(this._depthCompare) : WebGPUConstants.CompareFunction.Always,\r\n                          format: this._webgpuDepthStencilFormat,\r\n                          stencilFront: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\r\n                          stencilBack: this._stencilEnabled && depthStencilFormatHasStencil ? stencilFrontBack : undefined,\r\n                          stencilReadMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilReadMask : undefined,\r\n                          stencilWriteMask: this._stencilEnabled && depthStencilFormatHasStencil ? this._stencilWriteMask : undefined,\r\n                          depthBias: this._depthBias,\r\n                          depthBiasClamp: this._depthBiasClamp,\r\n                          depthBiasSlopeScale: this._depthBiasSlopeScale,\r\n                      },\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}