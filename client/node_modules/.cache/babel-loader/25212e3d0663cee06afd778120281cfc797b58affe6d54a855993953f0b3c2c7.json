{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Shaders/outline.fragment.js\";\nimport \"../Shaders/outline.vertex.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * Gets the outline renderer associated with the scene\n * @returns a OutlineRenderer\n */\nScene.prototype.getOutlineRenderer = function () {\n  if (!this._outlineRenderer) {\n    this._outlineRenderer = new OutlineRenderer(this);\n  }\n  return this._outlineRenderer;\n};\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\n  get: function () {\n    return this._renderOutline;\n  },\n  set: function (value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n    this._renderOutline = value;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\n  get: function () {\n    return this._renderOverlay;\n  },\n  set: function (value) {\n    if (value) {\n      // Lazy Load the component.\n      this.getScene().getOutlineRenderer();\n    }\n    this._renderOverlay = value;\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * This class is responsible to draw the outline/overlay of meshes.\n * It should not be used directly but through the available method on mesh.\n */\nexport class OutlineRenderer {\n  /**\n   * Instantiates a new outline renderer. (There could be only one per scene).\n   * @param scene Defines the scene it belongs to\n   */\n  constructor(scene) {\n    /**\n     * The name of the component. Each component must have a unique name.\n     */\n    this.name = SceneComponentConstants.NAME_OUTLINERENDERER;\n    /**\n     * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\n     */\n    this.zOffset = 1;\n    /**\n     * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\n     */\n    this.zOffsetUnits = 4; // 4 to account for projection a bit by default\n    this.scene = scene;\n    this._engine = scene.getEngine();\n    this.scene._addComponent(this);\n    this._passIdForDrawWrapper = [];\n    for (let i = 0; i < 4; ++i) {\n      this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);\n    }\n  }\n  /**\n   * Register the component to one instance of a scene.\n   */\n  register() {\n    this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\n    this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do here.\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {\n      this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\n    }\n  }\n  /**\n   * Renders the outline in the canvas.\n   * @param subMesh Defines the sumesh to render\n   * @param batch Defines the batch of meshes in case of instances\n   * @param useOverlay Defines if the rendering is for the overlay or the outline\n   * @param renderPassId Render pass id to use to render the mesh\n   */\n  render(subMesh, batch, useOverlay = false, renderPassId) {\n    renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n    const scene = this.scene;\n    const engine = scene.getEngine();\n    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || subMesh.getRenderingMesh().hasThinInstances);\n    if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\n      return;\n    }\n    const ownerMesh = subMesh.getMesh();\n    const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\n    const renderingMesh = subMesh.getRenderingMesh();\n    const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\n    const material = subMesh.getMaterial();\n    if (!material || !scene.activeCamera) {\n      return;\n    }\n    const drawWrapper = subMesh._getDrawWrapper(renderPassId);\n    const effect = DrawWrapper.GetEffect(drawWrapper);\n    engine.enableEffect(drawWrapper);\n    // Logarithmic depth\n    if (material.useLogarithmicDepth) {\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n    }\n    effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\n    effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\n    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n    // Bones\n    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n      effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n    }\n    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n      renderingMesh.morphTargetManager._bind(effect);\n    }\n    // Morph targets\n    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n    if (!hardwareInstancedRendering) {\n      renderingMesh._bind(subMesh, effect, material.fillMode);\n    }\n    // Alpha test\n    if (material && material.needAlphaTesting()) {\n      const alphaTexture = material.getAlphaTestTexture();\n      if (alphaTexture) {\n        effect.setTexture(\"diffuseSampler\", alphaTexture);\n        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n      }\n    }\n    // Clip plane\n    bindClipPlane(effect, material, scene);\n    engine.setZOffset(-this.zOffset);\n    engine.setZOffsetUnits(-this.zOffsetUnits);\n    renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\n      effect.setMatrix(\"world\", world);\n    });\n    engine.setZOffset(0);\n    engine.setZOffsetUnits(0);\n  }\n  /**\n   * Returns whether or not the outline renderer is ready for a given submesh.\n   * All the dependencies e.g. submeshes, texture, effect... mus be ready\n   * @param subMesh Defines the submesh to check readiness for\n   * @param useInstances Defines whether wee are trying to render instances or not\n   * @param renderPassId Render pass id to use to render the mesh\n   * @returns true if ready otherwise false\n   */\n  isReady(subMesh, useInstances, renderPassId) {\n    renderPassId = renderPassId !== null && renderPassId !== void 0 ? renderPassId : this._passIdForDrawWrapper[0];\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\n    const mesh = subMesh.getMesh();\n    const material = subMesh.getMaterial();\n    if (!material) {\n      return false;\n    }\n    const scene = mesh.getScene();\n    // Alpha test\n    if (material.needAlphaTesting()) {\n      defines.push(\"#define ALPHATEST\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    //Logarithmic depth\n    if (material.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    // Clip planes\n    prepareDefinesForClipPlanes(material, scene, defines);\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const morphTargetManager = mesh.morphTargetManager;\n    let numMorphInfluencers = 0;\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(renderPassId, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\", \"logarithmicDepthConstant\", \"morphTargetInfluences\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(this.scene.getEngine().createEffect(\"outline\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  _beforeRenderingMesh(mesh, subMesh, batch) {\n    // Outline - step 1\n    this._savedDepthWrite = this._engine.getDepthWrite();\n    if (mesh.renderOutline) {\n      const material = subMesh.getMaterial();\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.cacheStencilState();\n        // Draw only to stencil buffer for the original mesh\n        // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\n        this._engine.setDepthWrite(false);\n        this._engine.setColorWrite(false);\n        this._engine.setStencilBuffer(true);\n        this._engine.setStencilOperationPass(7681);\n        this._engine.setStencilFunction(519);\n        this._engine.setStencilMask(OutlineRenderer._StencilReference);\n        this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\n        this._engine.stencilStateComposer.useStencilGlobalOnly = true;\n        this.render(subMesh, batch, /* This sets offset to 0 */true, this._passIdForDrawWrapper[1]);\n        this._engine.setColorWrite(true);\n        this._engine.setStencilFunction(517);\n      }\n      // Draw the outline using the above stencil if needed to avoid drawing within the mesh\n      this._engine.setDepthWrite(false);\n      this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\n      this._engine.setDepthWrite(this._savedDepthWrite);\n      if (material && material.needAlphaBlendingForMesh(mesh)) {\n        this._engine.stencilStateComposer.useStencilGlobalOnly = false;\n        this._engine.restoreStencilState();\n      }\n    }\n  }\n  _afterRenderingMesh(mesh, subMesh, batch) {\n    // Overlay\n    if (mesh.renderOverlay) {\n      const currentMode = this._engine.getAlphaMode();\n      const alphaBlendState = this._engine.alphaState.alphaBlend;\n      this._engine.setAlphaMode(2);\n      this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\n      this._engine.setAlphaMode(currentMode);\n      this._engine.setDepthWrite(this._savedDepthWrite);\n      this._engine.alphaState.alphaBlend = alphaBlendState;\n    }\n    // Outline - step 2\n    if (mesh.renderOutline && this._savedDepthWrite) {\n      this._engine.setDepthWrite(true);\n      this._engine.setColorWrite(false);\n      this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\n      this._engine.setColorWrite(true);\n    }\n  }\n}\n/**\n * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\n */\nOutlineRenderer._StencilReference = 0x04;","map":{"version":3,"mappings":";AAAA,SAASA,YAAY,QAAQ,sBAAoB;AAGjD,SAASC,IAAI,QAAQ,mBAAiB;AACtC,SAASC,KAAK,QAAQ,aAAW;AAIjC,SAASC,uBAAuB,QAAQ,sBAAoB;AAC5D,SAASC,WAAW,QAAQ,6BAA2B;AACvD,SAASC,cAAc,QAAQ,gCAA8B;AAE7D,OAAO,gCAA8B;AACrC,OAAO,8BAA4B;AACnC,SAASC,oBAAoB,EAAEC,aAAa,EAAEC,2BAA2B,QAAE;AAe3E;;;;AAIAN,KAAK,CAACO,SAAS,CAACC,kBAAkB,GAAG;EACjC,IAAI,CAAC,IAAI,CAACC,gBAAgB,EAAE;IACxB,IAAI,CAACA,gBAAgB,GAAG,IAAIC,eAAe,CAAC,IAAI,CAAC;;EAErD,OAAO,IAAI,CAACD,gBAAgB;AAChC,CAAC;AAsBDE,MAAM,CAACC,cAAc,CAACb,IAAI,CAACQ,SAAS,EAAE,eAAe,EAAE;EACnDM,GAAG,EAAE;IACD,OAAO,IAAI,CAACC,cAAc;EAC9B,CAAC;EACDC,GAAG,EAAE,UAAsBC,KAAc;IACrC,IAAIA,KAAK,EAAE;MACP;MACA,IAAI,CAACC,QAAQ,EAAE,CAACT,kBAAkB,EAAE;;IAExC,IAAI,CAACM,cAAc,GAAGE,KAAK;EAC/B,CAAC;EACDE,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE;CACjB,CAAC;AAEFR,MAAM,CAACC,cAAc,CAACb,IAAI,CAACQ,SAAS,EAAE,eAAe,EAAE;EACnDM,GAAG,EAAE;IACD,OAAO,IAAI,CAACO,cAAc;EAC9B,CAAC;EACDL,GAAG,EAAE,UAAsBC,KAAc;IACrC,IAAIA,KAAK,EAAE;MACP;MACA,IAAI,CAACC,QAAQ,EAAE,CAACT,kBAAkB,EAAE;;IAExC,IAAI,CAACY,cAAc,GAAGJ,KAAK;EAC/B,CAAC;EACDE,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE;CACjB,CAAC;AAEF;;;;AAIA,OAAM,MAAOT,eAAe;EA6BxB;;;;EAIAW,YAAYC,KAAY;IA5BxB;;;IAGO,SAAI,GAAGrB,uBAAuB,CAACsB,oBAAoB;IAO1D;;;IAGO,YAAO,GAAG,CAAC;IAElB;;;IAGO,iBAAY,GAAG,CAAC,CAAC,CAAC;IAWrB,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,OAAO,GAAGF,KAAK,CAACG,SAAS,EAAE;IAChC,IAAI,CAACH,KAAK,CAACI,aAAa,CAAC,IAAI,CAAC;IAC9B,IAAI,CAACC,qBAAqB,GAAG,EAAE;IAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAE,EAAEA,CAAC,EAAE;MACxB,IAAI,CAACD,qBAAqB,CAACC,CAAC,CAAC,GAAG,IAAI,CAACJ,OAAO,CAACK,kBAAkB,CAAC,qBAAqBD,CAAC,GAAG,CAAC;;EAElG;EAEA;;;EAGOE,QAAQ;IACX,IAAI,CAACR,KAAK,CAACS,yBAAyB,CAACC,YAAY,CAAC/B,uBAAuB,CAACgC,gCAAgC,EAAE,IAAI,EAAE,IAAI,CAACC,oBAAoB,CAAC;IAC5I,IAAI,CAACZ,KAAK,CAACa,wBAAwB,CAACH,YAAY,CAAC/B,uBAAuB,CAACmC,+BAA+B,EAAE,IAAI,EAAE,IAAI,CAACC,mBAAmB,CAAC;EAC7I;EAEA;;;;EAIOC,OAAO;IACV;EAAA;EAGJ;;;EAGOC,OAAO;IACV,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACD,qBAAqB,CAACa,MAAM,EAAE,EAAEZ,CAAC,EAAE;MACxD,IAAI,CAACJ,OAAO,CAACiB,mBAAmB,CAAC,IAAI,CAACd,qBAAqB,CAACC,CAAC,CAAC,CAAC;;EAEvE;EAEA;;;;;;;EAOOc,MAAM,CAACC,OAAgB,EAAEC,KAAsB,EAAEC,aAAsB,KAAK,EAAEC,YAAqB;IACtGA,YAAY,GAAGA,YAAY,aAAZA,YAAY,cAAZA,YAAY,GAAI,IAAI,CAACnB,qBAAqB,CAAC,CAAC,CAAC;IAE5D,MAAML,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB,MAAMyB,MAAM,GAAGzB,KAAK,CAACG,SAAS,EAAE;IAEhC,MAAMuB,0BAA0B,GAC5BD,MAAM,CAACE,OAAO,EAAE,CAACC,eAAe,KAC9BN,KAAK,CAACO,gBAAgB,CAACR,OAAO,CAACS,GAAG,CAAC,KAAK,IAAI,IAAIR,KAAK,CAACO,gBAAgB,CAACR,OAAO,CAACS,GAAG,CAAC,KAAKC,SAAS,IAAKV,OAAO,CAACW,gBAAgB,EAAE,CAACC,gBAAgB,CAAC;IAExJ,IAAI,CAAC,IAAI,CAACC,OAAO,CAACb,OAAO,EAAEK,0BAA0B,EAAEF,YAAY,CAAC,EAAE;MAClE;;IAGJ,MAAMW,SAAS,GAAGd,OAAO,CAACe,OAAO,EAAE;IACnC,MAAMC,eAAe,GAAGF,SAAS,CAACG,6BAA6B,CAACC,iBAAiB,GAAGJ,SAAS,GAAG,IAAI;IACpG,MAAMK,aAAa,GAAGnB,OAAO,CAACW,gBAAgB,EAAE;IAChD,MAAMS,aAAa,GAAGJ,eAAe,GAAGA,eAAe,GAAGG,aAAa;IACvE,MAAME,QAAQ,GAAGrB,OAAO,CAACsB,WAAW,EAAE;IAEtC,IAAI,CAACD,QAAQ,IAAI,CAAC1C,KAAK,CAAC4C,YAAY,EAAE;MAClC;;IAGJ,MAAMC,WAAW,GAAGxB,OAAO,CAACyB,eAAe,CAACtB,YAAY,CAAE;IAC1D,MAAMuB,MAAM,GAAGnE,WAAW,CAACoE,SAAS,CAACH,WAAW,CAAE;IAElDpB,MAAM,CAACwB,YAAY,CAACJ,WAAW,CAAC;IAEhC;IACA,IAAUH,QAAS,CAACQ,mBAAmB,EAAE;MACrCH,MAAM,CAACI,QAAQ,CAAC,0BAA0B,EAAE,GAAG,IAAIC,IAAI,CAACC,GAAG,CAACrD,KAAK,CAAC4C,YAAY,CAACU,IAAI,GAAG,GAAG,CAAC,GAAGF,IAAI,CAACG,GAAG,CAAC,CAAC;;IAG3GR,MAAM,CAACI,QAAQ,CAAC,QAAQ,EAAE5B,UAAU,GAAG,CAAC,GAAGiB,aAAa,CAACgB,YAAY,CAAC;IACtET,MAAM,CAACU,SAAS,CAAC,OAAO,EAAElC,UAAU,GAAGiB,aAAa,CAACkB,YAAY,GAAGlB,aAAa,CAACmB,YAAY,EAAEpC,UAAU,GAAGiB,aAAa,CAACoB,YAAY,GAAGlB,QAAQ,CAACmB,KAAK,CAAC;IACzJd,MAAM,CAACe,SAAS,CAAC,gBAAgB,EAAE9D,KAAK,CAAC+D,kBAAkB,EAAE,CAAC;IAC9DhB,MAAM,CAACe,SAAS,CAAC,OAAO,EAAErB,aAAa,CAACuB,cAAc,EAAE,CAAC;IAEzD;IACA,IAAIxB,aAAa,CAACyB,QAAQ,IAAIzB,aAAa,CAAC0B,wBAAwB,IAAI1B,aAAa,CAAC2B,QAAQ,EAAE;MAC5FpB,MAAM,CAACqB,WAAW,CAAC,QAAQ,EAAE5B,aAAa,CAAC2B,QAAQ,CAACE,oBAAoB,CAAC7B,aAAa,CAAC,CAAC;;IAG5F,IAAIA,aAAa,CAAC8B,kBAAkB,IAAI9B,aAAa,CAAC8B,kBAAkB,CAACC,wBAAwB,EAAE;MAC/F/B,aAAa,CAAC8B,kBAAkB,CAACE,KAAK,CAACzB,MAAM,CAAC;;IAGlD;IACAlE,cAAc,CAAC4F,yBAAyB,CAACjC,aAAa,EAAEO,MAAM,CAAC;IAE/D,IAAI,CAACrB,0BAA0B,EAAE;MAC7Bc,aAAa,CAACgC,KAAK,CAACnD,OAAO,EAAE0B,MAAM,EAAEL,QAAQ,CAACgC,QAAQ,CAAC;;IAG3D;IACA,IAAIhC,QAAQ,IAAIA,QAAQ,CAACiC,gBAAgB,EAAE,EAAE;MACzC,MAAMC,YAAY,GAAGlC,QAAQ,CAACmC,mBAAmB,EAAE;MACnD,IAAID,YAAY,EAAE;QACd7B,MAAM,CAAC+B,UAAU,CAAC,gBAAgB,EAAEF,YAAY,CAAC;QACjD7B,MAAM,CAACe,SAAS,CAAC,eAAe,EAAEc,YAAY,CAACG,gBAAgB,EAAE,CAAC;;;IAI1E;IACAhG,aAAa,CAACgE,MAAM,EAAEL,QAAQ,EAAE1C,KAAK,CAAC;IAEtCyB,MAAM,CAACuD,UAAU,CAAC,CAAC,IAAI,CAACC,OAAO,CAAC;IAChCxD,MAAM,CAACyD,eAAe,CAAC,CAAC,IAAI,CAACC,YAAY,CAAC;IAE1C3C,aAAa,CAAC4C,iBAAiB,CAAC3C,aAAa,EAAEpB,OAAO,EAAE0B,MAAM,EAAEL,QAAQ,CAACgC,QAAQ,EAAEpD,KAAK,EAAEI,0BAA0B,EAAE,CAAC2D,UAAU,EAAEC,KAAK,KAAI;MACxIvC,MAAM,CAACe,SAAS,CAAC,OAAO,EAAEwB,KAAK,CAAC;IACpC,CAAC,CAAC;IAEF7D,MAAM,CAACuD,UAAU,CAAC,CAAC,CAAC;IACpBvD,MAAM,CAACyD,eAAe,CAAC,CAAC,CAAC;EAC7B;EAEA;;;;;;;;EAQOhD,OAAO,CAACb,OAAgB,EAAEkE,YAAqB,EAAE/D,YAAqB;IACzEA,YAAY,GAAGA,YAAY,aAAZA,YAAY,cAAZA,YAAY,GAAI,IAAI,CAACnB,qBAAqB,CAAC,CAAC,CAAC;IAE5D,MAAMmF,OAAO,GAAG,EAAE;IAClB,MAAMC,OAAO,GAAG,CAACjH,YAAY,CAACkH,YAAY,EAAElH,YAAY,CAACmH,UAAU,CAAC;IAEpE,MAAMC,IAAI,GAAGvE,OAAO,CAACe,OAAO,EAAE;IAC9B,MAAMM,QAAQ,GAAGrB,OAAO,CAACsB,WAAW,EAAE;IAEtC,IAAI,CAACD,QAAQ,EAAE;MACX,OAAO,KAAK;;IAGhB,MAAM1C,KAAK,GAAG4F,IAAI,CAACjG,QAAQ,EAAE;IAE7B;IACA,IAAI+C,QAAQ,CAACiC,gBAAgB,EAAE,EAAE;MAC7Ba,OAAO,CAACK,IAAI,CAAC,mBAAmB,CAAC;MACjC,IAAID,IAAI,CAACE,qBAAqB,CAACtH,YAAY,CAACuH,MAAM,CAAC,EAAE;QACjDN,OAAO,CAACI,IAAI,CAACrH,YAAY,CAACuH,MAAM,CAAC;QACjCP,OAAO,CAACK,IAAI,CAAC,aAAa,CAAC;;MAE/B,IAAID,IAAI,CAACE,qBAAqB,CAACtH,YAAY,CAACwH,OAAO,CAAC,EAAE;QAClDP,OAAO,CAACI,IAAI,CAACrH,YAAY,CAACwH,OAAO,CAAC;QAClCR,OAAO,CAACK,IAAI,CAAC,aAAa,CAAC;;;IAGnC;IACA,IAAUnD,QAAS,CAACQ,mBAAmB,EAAE;MACrCsC,OAAO,CAACK,IAAI,CAAC,0BAA0B,CAAC;;IAE5C;IACA7G,2BAA2B,CAAC0D,QAAQ,EAAE1C,KAAK,EAAEwF,OAAO,CAAC;IAErD;IACA,IAAII,IAAI,CAAC3B,QAAQ,IAAI2B,IAAI,CAAC1B,wBAAwB,EAAE;MAChDuB,OAAO,CAACI,IAAI,CAACrH,YAAY,CAACyH,mBAAmB,CAAC;MAC9CR,OAAO,CAACI,IAAI,CAACrH,YAAY,CAAC0H,mBAAmB,CAAC;MAC9C,IAAIN,IAAI,CAACO,kBAAkB,GAAG,CAAC,EAAE;QAC7BV,OAAO,CAACI,IAAI,CAACrH,YAAY,CAAC4H,wBAAwB,CAAC;QACnDX,OAAO,CAACI,IAAI,CAACrH,YAAY,CAAC6H,wBAAwB,CAAC;;MAEvDb,OAAO,CAACK,IAAI,CAAC,+BAA+B,GAAGD,IAAI,CAACO,kBAAkB,CAAC;MACvEX,OAAO,CAACK,IAAI,CAAC,uBAAuB,IAAID,IAAI,CAACzB,QAAQ,GAAGyB,IAAI,CAACzB,QAAQ,CAACmC,KAAK,CAACpF,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;KAC/F,MAAM;MACHsE,OAAO,CAACK,IAAI,CAAC,gCAAgC,CAAC;;IAGlD;IACA,MAAMvB,kBAAkB,GAAIsB,IAAa,CAACtB,kBAAkB;IAC5D,IAAIiC,mBAAmB,GAAG,CAAC;IAC3B,IAAIjC,kBAAkB,EAAE;MACpB,IAAIA,kBAAkB,CAACkC,cAAc,GAAG,CAAC,EAAE;QACvCD,mBAAmB,GAAGjC,kBAAkB,CAACkC,cAAc;QAEvDhB,OAAO,CAACK,IAAI,CAAC,sBAAsB,CAAC;QACpCL,OAAO,CAACK,IAAI,CAAC,gCAAgC,GAAGU,mBAAmB,CAAC;QAEpE,IAAIjC,kBAAkB,CAACC,wBAAwB,EAAE;UAC7CiB,OAAO,CAACK,IAAI,CAAC,8BAA8B,CAAC;;QAGhDhH,cAAc,CAAC4H,2CAA2C,CAAChB,OAAO,EAAEG,IAAI,EAAEW,mBAAmB,CAAC;;;IAItG;IACA,IAAIhB,YAAY,EAAE;MACdC,OAAO,CAACK,IAAI,CAAC,mBAAmB,CAAC;MACjChH,cAAc,CAAC6H,0BAA0B,CAACjB,OAAO,CAAC;MAClD,IAAIpE,OAAO,CAACW,gBAAgB,EAAE,CAACC,gBAAgB,EAAE;QAC7CuD,OAAO,CAACK,IAAI,CAAC,wBAAwB,CAAC;;;IAI9C;IACA,MAAMhD,WAAW,GAAGxB,OAAO,CAACyB,eAAe,CAACtB,YAAY,EAAE,IAAI,CAAE;IAChE,MAAMmF,aAAa,GAAG9D,WAAW,CAAC2C,OAAO;IACzC,MAAMoB,IAAI,GAAGpB,OAAO,CAACoB,IAAI,CAAC,IAAI,CAAC;IAE/B,IAAID,aAAa,KAAKC,IAAI,EAAE;MACxB,MAAMC,QAAQ,GAAG,CACb,OAAO,EACP,QAAQ,EACR,gBAAgB,EAChB,eAAe,EACf,QAAQ,EACR,OAAO,EACP,0BAA0B,EAC1B,uBAAuB,EACvB,wBAAwB,EACxB,2BAA2B,CAC9B;MACD/H,oBAAoB,CAAC+H,QAAQ,CAAC;MAE9BhE,WAAW,CAACiE,SAAS,CACjB,IAAI,CAAC9G,KAAK,CAACG,SAAS,EAAE,CAAC4G,YAAY,CAAC,SAAS,EAAEtB,OAAO,EAAEoB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,cAAc,CAAC,EAAED,IAAI,EAAE7E,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE;QACzIiF,2BAA2B,EAAET;OAChC,CAAC,EACFK,IAAI,CACP;;IAGL,OAAO/D,WAAW,CAACE,MAAO,CAACb,OAAO,EAAE;EACxC;EAEQtB,oBAAoB,CAACgF,IAAU,EAAEvE,OAAgB,EAAEC,KAAsB;IAC7E;IACA,IAAI,CAAC2F,gBAAgB,GAAG,IAAI,CAAC/G,OAAO,CAACgH,aAAa,EAAE;IACpD,IAAItB,IAAI,CAACuB,aAAa,EAAE;MACpB,MAAMzE,QAAQ,GAAGrB,OAAO,CAACsB,WAAW,EAAE;MACtC,IAAID,QAAQ,IAAIA,QAAQ,CAAC0E,wBAAwB,CAACxB,IAAI,CAAC,EAAE;QACrD,IAAI,CAAC1F,OAAO,CAACmH,iBAAiB,EAAE;QAChC;QACA;QACA,IAAI,CAACnH,OAAO,CAACoH,aAAa,CAAC,KAAK,CAAC;QACjC,IAAI,CAACpH,OAAO,CAACqH,aAAa,CAAC,KAAK,CAAC;QACjC,IAAI,CAACrH,OAAO,CAACsH,gBAAgB,CAAC,IAAI,CAAC;QACnC,IAAI,CAACtH,OAAO,CAACuH,uBAAuB,CAAC;QACrC,IAAI,CAACvH,OAAO,CAACwH,kBAAkB,CAAC;QAChC,IAAI,CAACxH,OAAO,CAACyH,cAAc,CAACvI,eAAe,CAACwI,iBAAiB,CAAC;QAC9D,IAAI,CAAC1H,OAAO,CAAC2H,2BAA2B,CAACzI,eAAe,CAACwI,iBAAiB,CAAC;QAC3E,IAAI,CAAC1H,OAAO,CAAC4H,oBAAoB,CAACC,oBAAoB,GAAG,IAAI;QAC7D,IAAI,CAAC3G,MAAM,CAACC,OAAO,EAAEC,KAAK,EAAE,2BAA4B,IAAI,EAAE,IAAI,CAACjB,qBAAqB,CAAC,CAAC,CAAC,CAAC;QAE5F,IAAI,CAACH,OAAO,CAACqH,aAAa,CAAC,IAAI,CAAC;QAChC,IAAI,CAACrH,OAAO,CAACwH,kBAAkB,CAAC;;MAGpC;MACA,IAAI,CAACxH,OAAO,CAACoH,aAAa,CAAC,KAAK,CAAC;MACjC,IAAI,CAAClG,MAAM,CAACC,OAAO,EAAEC,KAAK,EAAE,KAAK,EAAE,IAAI,CAACjB,qBAAqB,CAAC,CAAC,CAAC,CAAC;MACjE,IAAI,CAACH,OAAO,CAACoH,aAAa,CAAC,IAAI,CAACL,gBAAgB,CAAC;MAEjD,IAAIvE,QAAQ,IAAIA,QAAQ,CAAC0E,wBAAwB,CAACxB,IAAI,CAAC,EAAE;QACrD,IAAI,CAAC1F,OAAO,CAAC4H,oBAAoB,CAACC,oBAAoB,GAAG,KAAK;QAC9D,IAAI,CAAC7H,OAAO,CAAC8H,mBAAmB,EAAE;;;EAG9C;EAEQjH,mBAAmB,CAAC6E,IAAU,EAAEvE,OAAgB,EAAEC,KAAsB;IAC5E;IACA,IAAIsE,IAAI,CAACqC,aAAa,EAAE;MACpB,MAAMC,WAAW,GAAG,IAAI,CAAChI,OAAO,CAACiI,YAAY,EAAE;MAC/C,MAAMC,eAAe,GAAG,IAAI,CAAClI,OAAO,CAACmI,UAAU,CAACC,UAAU;MAC1D,IAAI,CAACpI,OAAO,CAACqI,YAAY,CAAC;MAC1B,IAAI,CAACnH,MAAM,CAACC,OAAO,EAAEC,KAAK,EAAE,IAAI,EAAE,IAAI,CAACjB,qBAAqB,CAAC,CAAC,CAAC,CAAC;MAChE,IAAI,CAACH,OAAO,CAACqI,YAAY,CAACL,WAAW,CAAC;MACtC,IAAI,CAAChI,OAAO,CAACoH,aAAa,CAAC,IAAI,CAACL,gBAAgB,CAAC;MACjD,IAAI,CAAC/G,OAAO,CAACmI,UAAU,CAACC,UAAU,GAAGF,eAAe;;IAGxD;IACA,IAAIxC,IAAI,CAACuB,aAAa,IAAI,IAAI,CAACF,gBAAgB,EAAE;MAC7C,IAAI,CAAC/G,OAAO,CAACoH,aAAa,CAAC,IAAI,CAAC;MAChC,IAAI,CAACpH,OAAO,CAACqH,aAAa,CAAC,KAAK,CAAC;MACjC,IAAI,CAACnG,MAAM,CAACC,OAAO,EAAEC,KAAK,EAAE,KAAK,EAAE,IAAI,CAACjB,qBAAqB,CAAC,CAAC,CAAC,CAAC;MACjE,IAAI,CAACH,OAAO,CAACqH,aAAa,CAAC,IAAI,CAAC;;EAExC;;AAhUA;;;AAGenI,iCAAiB,GAAG,IAAI","names":["VertexBuffer","Mesh","Scene","SceneComponentConstants","DrawWrapper","MaterialHelper","addClipPlaneUniforms","bindClipPlane","prepareDefinesForClipPlanes","prototype","getOutlineRenderer","_outlineRenderer","OutlineRenderer","Object","defineProperty","get","_renderOutline","set","value","getScene","enumerable","configurable","_renderOverlay","constructor","scene","NAME_OUTLINERENDERER","_engine","getEngine","_addComponent","_passIdForDrawWrapper","i","createRenderPassId","register","_beforeRenderingMeshStage","registerStep","STEP_BEFORERENDERINGMESH_OUTLINE","_beforeRenderingMesh","_afterRenderingMeshStage","STEP_AFTERRENDERINGMESH_OUTLINE","_afterRenderingMesh","rebuild","dispose","length","releaseRenderPassId","render","subMesh","batch","useOverlay","renderPassId","engine","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","_id","undefined","getRenderingMesh","hasThinInstances","isReady","ownerMesh","getMesh","replacementMesh","_internalAbstractMeshDataInfo","_actAsRegularMesh","renderingMesh","effectiveMesh","material","getMaterial","activeCamera","drawWrapper","_getDrawWrapper","effect","GetEffect","enableEffect","useLogarithmicDepth","setFloat","Math","log","maxZ","LN2","outlineWidth","setColor4","overlayColor","outlineColor","overlayAlpha","alpha","setMatrix","getTransformMatrix","getWorldMatrix","useBones","computeBonesUsingShaders","skeleton","setMatrices","getTransformMatrices","morphTargetManager","isUsingTextureForTargets","_bind","BindMorphTargetParameters","fillMode","needAlphaTesting","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","setZOffset","zOffset","setZOffsetUnits","zOffsetUnits","_processRendering","isInstance","world","useInstances","defines","attribs","PositionKind","NormalKind","mesh","push","isVerticesDataPresent","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","bones","numMorphInfluencers","numInfluencers","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","cachedDefines","join","uniforms","setEffect","createEffect","maxSimultaneousMorphTargets","_savedDepthWrite","getDepthWrite","renderOutline","needAlphaBlendingForMesh","cacheStencilState","setDepthWrite","setColorWrite","setStencilBuffer","setStencilOperationPass","setStencilFunction","setStencilMask","_StencilReference","setStencilFunctionReference","stencilStateComposer","useStencilGlobalOnly","restoreStencilState","renderOverlay","currentMode","getAlphaMode","alphaBlendState","alphaState","alphaBlend","setAlphaMode"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/outlineRenderer.ts"],"sourcesContent":["import { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { _InstancesBatch } from \"../Meshes/mesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\nimport \"../Shaders/outline.fragment\";\r\nimport \"../Shaders/outline.vertex\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"core/Materials/clipPlaneMaterialHelper\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _outlineRenderer: OutlineRenderer;\r\n\r\n        /**\r\n         * Gets the outline renderer associated with the scene\r\n         * @returns a OutlineRenderer\r\n         */\r\n        getOutlineRenderer(): OutlineRenderer;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the outline renderer associated with the scene\r\n * @returns a OutlineRenderer\r\n */\r\nScene.prototype.getOutlineRenderer = function (): OutlineRenderer {\r\n    if (!this._outlineRenderer) {\r\n        this._outlineRenderer = new OutlineRenderer(this);\r\n    }\r\n    return this._outlineRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @internal (Backing field) */\r\n        _renderOutline: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the outline must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#3\r\n         */\r\n        renderOutline: boolean;\r\n\r\n        /** @internal (Backing field) */\r\n        _renderOverlay: boolean;\r\n        /**\r\n         * Gets or sets a boolean indicating if the overlay must be rendered as well\r\n         * @see https://www.babylonjs-playground.com/#10WJ5S#2\r\n         */\r\n        renderOverlay: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Mesh.prototype, \"renderOutline\", {\r\n    get: function (this: Mesh) {\r\n        return this._renderOutline;\r\n    },\r\n    set: function (this: Mesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOutline = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Mesh.prototype, \"renderOverlay\", {\r\n    get: function (this: Mesh) {\r\n        return this._renderOverlay;\r\n    },\r\n    set: function (this: Mesh, value: boolean) {\r\n        if (value) {\r\n            // Lazy Load the component.\r\n            this.getScene().getOutlineRenderer();\r\n        }\r\n        this._renderOverlay = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * This class is responsible to draw the outline/overlay of meshes.\r\n * It should not be used directly but through the available method on mesh.\r\n */\r\nexport class OutlineRenderer implements ISceneComponent {\r\n    /**\r\n     * Stencil value used to avoid outline being seen within the mesh when the mesh is transparent\r\n     */\r\n    private static _StencilReference = 0x04;\r\n    /**\r\n     * The name of the component. Each component must have a unique name.\r\n     */\r\n    public name = SceneComponentConstants.NAME_OUTLINERENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Defines a zOffset default Factor to prevent zFighting between the overlay and the mesh.\r\n     */\r\n    public zOffset = 1;\r\n\r\n    /**\r\n     * Defines a zOffset default Unit to prevent zFighting between the overlay and the mesh.\r\n     */\r\n    public zOffsetUnits = 4; // 4 to account for projection a bit by default\r\n\r\n    private _engine: Engine;\r\n    private _savedDepthWrite: boolean;\r\n    private _passIdForDrawWrapper: number[];\r\n\r\n    /**\r\n     * Instantiates a new outline renderer. (There could be only one per scene).\r\n     * @param scene Defines the scene it belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this.scene._addComponent(this);\r\n        this._passIdForDrawWrapper = [];\r\n        for (let i = 0; i < 4; ++i) {\r\n            this._passIdForDrawWrapper[i] = this._engine.createRenderPassId(`Outline Renderer (${i})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Register the component to one instance of a scene.\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE, this, this._beforeRenderingMesh);\r\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE, this, this._afterRenderingMesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        for (let i = 0; i < this._passIdForDrawWrapper.length; ++i) {\r\n            this._engine.releaseRenderPassId(this._passIdForDrawWrapper[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the outline in the canvas.\r\n     * @param subMesh Defines the sumesh to render\r\n     * @param batch Defines the batch of meshes in case of instances\r\n     * @param useOverlay Defines if the rendering is for the overlay or the outline\r\n     * @param renderPassId Render pass id to use to render the mesh\r\n     */\r\n    public render(subMesh: SubMesh, batch: _InstancesBatch, useOverlay: boolean = false, renderPassId?: number): void {\r\n        renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];\r\n\r\n        const scene = this.scene;\r\n        const engine = scene.getEngine();\r\n\r\n        const hardwareInstancedRendering =\r\n            engine.getCaps().instancedArrays &&\r\n            ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        if (!this.isReady(subMesh, hardwareInstancedRendering, renderPassId)) {\r\n            return;\r\n        }\r\n\r\n        const ownerMesh = subMesh.getMesh();\r\n        const replacementMesh = ownerMesh._internalAbstractMeshDataInfo._actAsRegularMesh ? ownerMesh : null;\r\n        const renderingMesh = subMesh.getRenderingMesh();\r\n        const effectiveMesh = replacementMesh ? replacementMesh : renderingMesh;\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material || !scene.activeCamera) {\r\n            return;\r\n        }\r\n\r\n        const drawWrapper = subMesh._getDrawWrapper(renderPassId)!;\r\n        const effect = DrawWrapper.GetEffect(drawWrapper)!;\r\n\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        // Logarithmic depth\r\n        if ((<any>material).useLogarithmicDepth) {\r\n            effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\r\n        }\r\n\r\n        effect.setFloat(\"offset\", useOverlay ? 0 : renderingMesh.outlineWidth);\r\n        effect.setColor4(\"color\", useOverlay ? renderingMesh.overlayColor : renderingMesh.outlineColor, useOverlay ? renderingMesh.overlayAlpha : material.alpha);\r\n        effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n        effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n\r\n        // Bones\r\n        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n        }\r\n\r\n        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n            renderingMesh.morphTargetManager._bind(effect);\r\n        }\r\n\r\n        // Morph targets\r\n        MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n\r\n        if (!hardwareInstancedRendering) {\r\n            renderingMesh._bind(subMesh, effect, material.fillMode);\r\n        }\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting()) {\r\n            const alphaTexture = material.getAlphaTestTexture();\r\n            if (alphaTexture) {\r\n                effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n            }\r\n        }\r\n\r\n        // Clip plane\r\n        bindClipPlane(effect, material, scene);\r\n\r\n        engine.setZOffset(-this.zOffset);\r\n        engine.setZOffsetUnits(-this.zOffsetUnits);\r\n\r\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\r\n            effect.setMatrix(\"world\", world);\r\n        });\r\n\r\n        engine.setZOffset(0);\r\n        engine.setZOffsetUnits(0);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the outline renderer is ready for a given submesh.\r\n     * All the dependencies e.g. submeshes, texture, effect... mus be ready\r\n     * @param subMesh Defines the submesh to check readiness for\r\n     * @param useInstances Defines whether wee are trying to render instances or not\r\n     * @param renderPassId Render pass id to use to render the mesh\r\n     * @returns true if ready otherwise false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean, renderPassId?: number): boolean {\r\n        renderPassId = renderPassId ?? this._passIdForDrawWrapper[0];\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind, VertexBuffer.NormalKind];\r\n\r\n        const mesh = subMesh.getMesh();\r\n        const material = subMesh.getMaterial();\r\n\r\n        if (!material) {\r\n            return false;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        // Alpha test\r\n        if (material.needAlphaTesting()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n        //Logarithmic depth\r\n        if ((<any>material).useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n        // Clip planes\r\n        prepareDefinesForClipPlanes(material, scene, defines);\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                if (morphTargetManager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(renderPassId, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"viewProjection\",\r\n                \"diffuseMatrix\",\r\n                \"offset\",\r\n                \"color\",\r\n                \"logarithmicDepthConstant\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                this.scene.getEngine().createEffect(\"outline\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\"], join, undefined, undefined, undefined, {\r\n                    maxSimultaneousMorphTargets: numMorphInfluencers,\r\n                }),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    private _beforeRenderingMesh(mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Outline - step 1\r\n        this._savedDepthWrite = this._engine.getDepthWrite();\r\n        if (mesh.renderOutline) {\r\n            const material = subMesh.getMaterial();\r\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\r\n                this._engine.cacheStencilState();\r\n                // Draw only to stencil buffer for the original mesh\r\n                // The resulting stencil buffer will be used so the outline is not visible inside the mesh when the mesh is transparent\r\n                this._engine.setDepthWrite(false);\r\n                this._engine.setColorWrite(false);\r\n                this._engine.setStencilBuffer(true);\r\n                this._engine.setStencilOperationPass(Constants.REPLACE);\r\n                this._engine.setStencilFunction(Constants.ALWAYS);\r\n                this._engine.setStencilMask(OutlineRenderer._StencilReference);\r\n                this._engine.setStencilFunctionReference(OutlineRenderer._StencilReference);\r\n                this._engine.stencilStateComposer.useStencilGlobalOnly = true;\r\n                this.render(subMesh, batch, /* This sets offset to 0 */ true, this._passIdForDrawWrapper[1]);\r\n\r\n                this._engine.setColorWrite(true);\r\n                this._engine.setStencilFunction(Constants.NOTEQUAL);\r\n            }\r\n\r\n            // Draw the outline using the above stencil if needed to avoid drawing within the mesh\r\n            this._engine.setDepthWrite(false);\r\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[0]);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n\r\n            if (material && material.needAlphaBlendingForMesh(mesh)) {\r\n                this._engine.stencilStateComposer.useStencilGlobalOnly = false;\r\n                this._engine.restoreStencilState();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _afterRenderingMesh(mesh: Mesh, subMesh: SubMesh, batch: _InstancesBatch): void {\r\n        // Overlay\r\n        if (mesh.renderOverlay) {\r\n            const currentMode = this._engine.getAlphaMode();\r\n            const alphaBlendState = this._engine.alphaState.alphaBlend;\r\n            this._engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n            this.render(subMesh, batch, true, this._passIdForDrawWrapper[3]);\r\n            this._engine.setAlphaMode(currentMode);\r\n            this._engine.setDepthWrite(this._savedDepthWrite);\r\n            this._engine.alphaState.alphaBlend = alphaBlendState;\r\n        }\r\n\r\n        // Outline - step 2\r\n        if (mesh.renderOutline && this._savedDepthWrite) {\r\n            this._engine.setDepthWrite(true);\r\n            this._engine.setColorWrite(false);\r\n            this.render(subMesh, batch, false, this._passIdForDrawWrapper[2]);\r\n            this._engine.setColorWrite(true);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}