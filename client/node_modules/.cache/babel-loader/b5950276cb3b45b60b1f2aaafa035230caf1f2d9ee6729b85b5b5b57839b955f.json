{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\n// This implementation was based on the original MIT-licensed TRACE repository\n// from https://github.com/septagon/TRACE.\n/**\n * Generic implementation of Levenshtein distance.\n */\nvar Levenshtein;\n(function (Levenshtein) {\n  /**\n   * Alphabet from which to construct sequences to be compared using Levenshtein\n   * distance.\n   */\n  class Alphabet {\n    /**\n     * Create a new Alphabet.\n     * @param characters characters of the alphabet\n     * @param charToInsertionCost function mapping characters to insertion costs\n     * @param charToDeletionCost function mapping characters to deletion costs\n     * @param charsToSubstitutionCost function mapping character pairs to substitution costs\n     */\n    constructor(characters, charToInsertionCost = null, charToDeletionCost = null, charsToSubstitutionCost = null) {\n      charToInsertionCost = charToInsertionCost !== null && charToInsertionCost !== void 0 ? charToInsertionCost : () => 1;\n      charToDeletionCost = charToDeletionCost !== null && charToDeletionCost !== void 0 ? charToDeletionCost : () => 1;\n      charsToSubstitutionCost = charsToSubstitutionCost !== null && charsToSubstitutionCost !== void 0 ? charsToSubstitutionCost : (a, b) => a === b ? 0 : 1;\n      this._characterToIdx = new Map();\n      this._insertionCosts = new Array(characters.length);\n      this._deletionCosts = new Array(characters.length);\n      this._substitutionCosts = new Array(characters.length);\n      let c;\n      for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\n        c = characters[outerIdx];\n        this._characterToIdx.set(c, outerIdx);\n        this._insertionCosts[outerIdx] = charToInsertionCost(c);\n        this._deletionCosts[outerIdx] = charToDeletionCost(c);\n        this._substitutionCosts[outerIdx] = new Array(characters.length);\n        for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\n          this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\n        }\n      }\n    }\n    /**\n     * Serialize the Alphabet to JSON string.\n     * @returns JSON serialization\n     */\n    serialize() {\n      const jsonObject = {};\n      const characters = new Array(this._characterToIdx.size);\n      this._characterToIdx.forEach((v, k) => {\n        characters[v] = k;\n      });\n      jsonObject[\"characters\"] = characters;\n      jsonObject[\"insertionCosts\"] = this._insertionCosts;\n      jsonObject[\"deletionCosts\"] = this._deletionCosts;\n      jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\n      return JSON.stringify(jsonObject);\n    }\n    /**\n     * Parse an Alphabet from a JSON serialization.\n     * @param json JSON string to deserialize\n     * @returns deserialized Alphabet\n     */\n    static Deserialize(json) {\n      const jsonObject = JSON.parse(json);\n      const alphabet = new Alphabet(jsonObject[\"characters\"]);\n      alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\n      alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\n      alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\n      return alphabet;\n    }\n    /**\n     * Get the index (internally-assigned number) for a character.\n     * @param char character\n     * @returns index\n     */\n    getCharacterIdx(char) {\n      return this._characterToIdx.get(char);\n    }\n    /**\n     * Get the insertion cost of a character from its index.\n     * @param idx character index\n     * @returns insertion cost\n     */\n    getInsertionCost(idx) {\n      return this._insertionCosts[idx];\n    }\n    /**\n     * Get the deletion cost of a character from its index.\n     * @param idx character index\n     * @returns deletion cost\n     */\n    getDeletionCost(idx) {\n      return this._deletionCosts[idx];\n    }\n    /**\n     * Gets the cost to substitute two characters. NOTE: this cost is\n     * required to be bi-directional, meaning it cannot matter which of\n     * the provided characters is being removed and which is being inserted.\n     * @param idx1 the first character index\n     * @param idx2 the second character index\n     * @returns substitution cost\n     */\n    getSubstitutionCost(idx1, idx2) {\n      const min = Math.min(idx1, idx2);\n      const max = Math.max(idx1, idx2);\n      return this._substitutionCosts[min][max];\n    }\n  }\n  Levenshtein.Alphabet = Alphabet;\n  /**\n   * Character sequence intended to be compared against other Sequences created\n   * with the same Alphabet in order to compute Levenshtein distance.\n   */\n  class Sequence {\n    /**\n     * Create a new Sequence.\n     * @param characters characters in the new Sequence\n     * @param alphabet Alphabet, which must include all used characters\n     */\n    constructor(characters, alphabet) {\n      if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\n        throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\n      }\n      this._alphabet = alphabet;\n      this._characters = characters.map(c => this._alphabet.getCharacterIdx(c));\n    }\n    /**\n     * Serialize to JSON string. JSON representation does NOT include the Alphabet\n     * from which this Sequence was created; Alphabet must be independently\n     * serialized.\n     * @returns JSON string\n     */\n    serialize() {\n      return JSON.stringify(this._characters);\n    }\n    /**\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n     * from which the Sequence was originally created, which must be serialized and\n     * deserialized independently so that it can be passed in here.\n     * @param json JSON string representation of Sequence\n     * @param alphabet Alphabet from which Sequence was originally created\n     * @returns Sequence\n     */\n    static Deserialize(json, alphabet) {\n      const sequence = new Sequence([], alphabet);\n      sequence._characters = JSON.parse(json);\n      return sequence;\n    }\n    /**\n     * Get the distance between this Sequence and another.\n     * @param other sequence to compare to\n     * @returns Levenshtein distance\n     */\n    distance(other) {\n      return Sequence._Distance(this, other);\n    }\n    /**\n     * Compute the Levenshtein distance between two Sequences.\n     * @param a first Sequence\n     * @param b second Sequence\n     * @returns Levenshtein distance\n     */\n    static _Distance(a, b) {\n      const alphabet = a._alphabet;\n      if (alphabet !== b._alphabet) {\n        throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\n      }\n      const aChars = a._characters;\n      const bChars = b._characters;\n      const aLength = aChars.length;\n      const bLength = bChars.length;\n      const costMatrix = Sequence._CostMatrix;\n      costMatrix[0][0] = 0;\n      for (let idx = 0; idx < aLength; ++idx) {\n        costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\n      }\n      for (let idx = 0; idx < bLength; ++idx) {\n        costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\n      }\n      for (let aIdx = 0; aIdx < aLength; ++aIdx) {\n        for (let bIdx = 0; bIdx < bLength; ++bIdx) {\n          Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\n          Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\n          Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\n          costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\n        }\n      }\n      return costMatrix[aLength][bLength];\n    }\n  }\n  // Scratch values\n  Sequence._MAX_SEQUENCE_LENGTH = 256;\n  Sequence._CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array(Sequence._MAX_SEQUENCE_LENGTH + 1));\n  Levenshtein.Sequence = Sequence;\n})(Levenshtein || (Levenshtein = {}));\n/**\n * A 3D trajectory consisting of an order list of vectors describing a\n * path of motion through 3D space.\n */\nexport class Trajectory {\n  /**\n   * Create a new empty Trajectory.\n   * @param segmentLength radius of discretization for Trajectory points\n   */\n  constructor(segmentLength = 0.01) {\n    this._points = [];\n    this._segmentLength = segmentLength;\n  }\n  /**\n   * Serialize to JSON.\n   * @returns serialized JSON string\n   */\n  serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json serialized JSON string\n   * @returns deserialized Trajectory\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\n    trajectory._points = jsonObject[\"_points\"].map(pt => {\n      return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\n    });\n    return trajectory;\n  }\n  /**\n   * Get the length of the Trajectory.\n   * @returns length of the Trajectory\n   */\n  getLength() {\n    return this._points.length * this._segmentLength;\n  }\n  /**\n   * Append a new point to the Trajectory.\n   * NOTE: This implementation has many allocations.\n   * @param point point to append to the Trajectory\n   */\n  add(point) {\n    let numPoints = this._points.length;\n    if (numPoints === 0) {\n      this._points.push(point.clone());\n    } else {\n      const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\n      for (let t = getT(); t <= 1.0; t = getT()) {\n        const newPoint = this._points[numPoints - 1].scale(1.0 - t);\n        point.scaleAndAddToRef(t, newPoint);\n        this._points.push(newPoint);\n        ++numPoints;\n      }\n    }\n  }\n  /**\n   * Create a new Trajectory with a segment length chosen to make it\n   * probable that the new Trajectory will have a specified number of\n   * segments. This operation is imprecise.\n   * @param targetResolution number of segments desired\n   * @returns new Trajectory with approximately the requested number of segments\n   */\n  resampleAtTargetResolution(targetResolution) {\n    const resampled = new Trajectory(this.getLength() / targetResolution);\n    this._points.forEach(pt => {\n      resampled.add(pt);\n    });\n    return resampled;\n  }\n  /**\n   * Convert Trajectory segments into tokenized representation. This\n   * representation is an array of numbers where each nth number is the\n   * index of the token which is most similar to the nth segment of the\n   * Trajectory.\n   * @param tokens list of vectors which serve as discrete tokens\n   * @returns list of indices of most similar token per segment\n   */\n  tokenize(tokens) {\n    const tokenization = [];\n    const segmentDir = new Vector3();\n    for (let idx = 2; idx < this._points.length; ++idx) {\n      if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\n        tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\n      }\n    }\n    return tokenization;\n  }\n  /**\n   * Transform the rotation (i.e., direction) of a segment to isolate\n   * the relative transformation represented by the segment. This operation\n   * may or may not succeed due to singularities in the equations that define\n   * motion relativity in this context.\n   * @param priorVec the origin of the prior segment\n   * @param fromVec the origin of the current segment\n   * @param toVec the destination of the current segment\n   * @param result reference to output variable\n   * @returns whether or not transformation was successful\n   */\n  static _TransformSegmentDirToRef(priorVec, fromVec, toVec, result) {\n    const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\n    fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\n    Trajectory._ForwardDir.normalize();\n    fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\n    Trajectory._InverseFromVec.normalize();\n    if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\n      return false;\n    }\n    Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\n    Trajectory._UpDir.normalize();\n    Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\n    toVec.subtractToRef(fromVec, Trajectory._FromToVec);\n    Trajectory._FromToVec.normalize();\n    Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\n    return true;\n  }\n  /**\n   * Determine which token vector is most similar to the\n   * segment vector.\n   * @param segment segment vector\n   * @param tokens token vector list\n   * @returns index of the most similar token to the segment\n   */\n  static _TokenizeSegment(segment, tokens) {\n    Trajectory._BestMatch = 0;\n    Trajectory._Score = Vector3.Dot(segment, tokens[0]);\n    Trajectory._BestScore = Trajectory._Score;\n    for (let idx = 1; idx < tokens.length; ++idx) {\n      Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\n      if (Trajectory._Score > Trajectory._BestScore) {\n        Trajectory._BestMatch = idx;\n        Trajectory._BestScore = Trajectory._Score;\n      }\n    }\n    return Trajectory._BestMatch;\n  }\n}\nTrajectory._ForwardDir = new Vector3();\nTrajectory._InverseFromVec = new Vector3();\nTrajectory._UpDir = new Vector3();\nTrajectory._FromToVec = new Vector3();\nTrajectory._LookMatrix = new Matrix();\n/**\n * Collection of vectors intended to be used as the basis of Trajectory\n * tokenization for Levenshtein distance comparison. Canonically, a\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\n * roughly evenly over the surface of the unit sphere.\n */\nclass Vector3Alphabet {\n  constructor(size) {\n    this.chars = new Array(size);\n  }\n  /**\n   * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\n   * optimize-from-random strategy to space points around the unit sphere\n   * surface as a simple alternative to really doing the math to tile the\n   * sphere.\n   * @param alphabetSize size of the desired alphabet\n   * @param iterations number of iterations over which to optimize the \"spikeball\"\n   * @param startingStepSize distance factor to move points in early optimization iterations\n   * @param endingStepSize distance factor to move points in late optimization iterations\n   * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\n   * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\n   */\n  static Generate(alphabetSize = 64, iterations = 256, startingStepSize = 0.1, endingStepSize = 0.001, fixedValues = []) {\n    const EPSILON = 0.001;\n    const EPSILON_SQUARED = EPSILON * EPSILON;\n    const alphabet = new Vector3Alphabet(alphabetSize);\n    for (let idx = 0; idx < alphabetSize; ++idx) {\n      alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n      alphabet.chars[idx].normalize();\n    }\n    for (let idx = 0; idx < fixedValues.length; ++idx) {\n      alphabet.chars[idx].copyFrom(fixedValues[idx]);\n    }\n    let stepSize;\n    let distSq;\n    const force = new Vector3();\n    const scratch = new Vector3();\n    const lerp = (l, r, t) => (1.0 - t) * l + t * r;\n    for (let iteration = 0; iteration < iterations; ++iteration) {\n      stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\n      for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\n        force.copyFromFloats(0, 0, 0);\n        alphabet.chars.forEach(pt => {\n          alphabet.chars[idx].subtractToRef(pt, scratch);\n          distSq = scratch.lengthSquared();\n          if (distSq > EPSILON_SQUARED) {\n            scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\n          }\n        });\n        force.scaleInPlace(stepSize);\n        alphabet.chars[idx].addInPlace(force);\n        alphabet.chars[idx].normalize();\n      }\n    }\n    return alphabet;\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    return JSON.stringify(this.chars);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized Vector3Alphabet\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const alphabet = new Vector3Alphabet(jsonObject.length);\n    for (let idx = 0; idx < jsonObject.length; ++idx) {\n      alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\n    }\n    return alphabet;\n  }\n}\n/**\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\n * describe a Trajectory. This class houses the functionality which determines what\n * attributes of Trajectories are and are not considered important, such as scale.\n */\nclass TrajectoryDescriptor {\n  constructor() {\n    this._sequences = [];\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    return JSON.stringify(this._sequences.map(sequence => sequence.serialize()));\n  }\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptor was originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON serialization\n   * @param alphabet Alphabet from which descriptor was originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n  static Deserialize(json, alphabet) {\n    const descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = JSON.parse(json).map(s => Levenshtein.Sequence.Deserialize(s, alphabet));\n    return descriptor;\n  }\n  /**\n   * Create a new TrajectoryDescriptor to describe a provided Trajectory according\n   * to the provided alphabets.\n   * @param trajectory Trajectory to be described\n   * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing provided Trajectory\n   */\n  static CreateFromTrajectory(trajectory, vector3Alphabet, levenshteinAlphabet) {\n    return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\n  }\n  /**\n   * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\n   * NOTE: This function exists to support an outdated serialization mechanism and should\n   * be deleted if it is no longer useful.\n   * @param pyramid tokenization pyramid\n   * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\n   * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\n   */\n  static CreateFromTokenizationPyramid(pyramid, levenshteinAlphabet) {\n    const descriptor = new TrajectoryDescriptor();\n    descriptor._sequences = pyramid.map(tokens => new Levenshtein.Sequence(tokens, levenshteinAlphabet));\n    return descriptor;\n  }\n  /**\n   * Create the tokenization pyramid for the provided Trajectory according to the given\n   * Vector3Alphabet.\n   * @param trajectory Trajectory to be tokenized\n   * @param alphabet Vector3Alphabet containing tokens\n   * @param targetResolution finest resolution of descriptor\n   * @returns tokenization pyramid for Trajectory\n   */\n  static _GetTokenizationPyramid(trajectory, alphabet, targetResolution = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION) {\n    const pyramid = [];\n    for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\n      pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\n    }\n    return pyramid;\n  }\n  /**\n   * Calculate a distance metric between this TrajectoryDescriptor and another. This is\n   * essentially a similarity score and does not directly represent Euclidean distance,\n   * edit distance, or any other formal distance metric.\n   * @param other TrajectoryDescriptor from which to determine distance\n   * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\n   */\n  distance(other) {\n    let totalDistance = 0;\n    let weight;\n    for (let idx = 0; idx < this._sequences.length; ++idx) {\n      weight = Math.pow(2, idx);\n      totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\n    }\n    return totalDistance;\n  }\n}\nTrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION = 32;\n/**\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\n * class to facilitate methods of Trajectory clustering.\n */\nclass TrajectoryClass {\n  /**\n   * Create a new DescribedTrajectory.\n   * @param descriptors currently-known TrajectoryDescriptors, if any\n   */\n  constructor(descriptors = []) {\n    this._descriptors = descriptors;\n    this._centroidIdx = -1;\n    this._averageDistance = 0;\n    this._refreshDescription();\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    const jsonObject = {};\n    jsonObject.descriptors = this._descriptors.map(desc => desc.serialize());\n    jsonObject.centroidIdx = this._centroidIdx;\n    jsonObject.averageDistance = this._averageDistance;\n    return JSON.stringify(jsonObject);\n  }\n  /**\n   * Deserialize from JSON string and Alphabet. This should be the same Alphabet\n   * from which the descriptors were originally created, which must be serialized and\n   * deserialized independently so that it can be passed in here.\n   * @param json JSON string representation\n   * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\n   * @returns deserialized TrajectoryDescriptor\n   */\n  static Deserialize(json, alphabet) {\n    const jsonObject = JSON.parse(json);\n    const described = new TrajectoryClass();\n    described._descriptors = jsonObject.descriptors.map(s => TrajectoryDescriptor.Deserialize(s, alphabet));\n    described._centroidIdx = jsonObject.centroidIdx;\n    described._averageDistance = jsonObject.averageDistance;\n    return described;\n  }\n  /**\n   * Add a new TrajectoryDescriptor to the list of descriptors known to describe\n   * this same DescribedTrajectory.\n   * @param descriptor descriptor to be added\n   */\n  add(descriptor) {\n    this._descriptors.push(descriptor);\n    this._refreshDescription();\n  }\n  /**\n   * Compute the cost, which is inversely related to the likelihood that the provided\n   * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\n   * the class represented by this DescribedTrajectory.\n   * @param descriptor the descriptor to be costed\n   * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\n   */\n  getMatchCost(descriptor) {\n    return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\n  }\n  /**\n   * Compute the minimum distance between the queried TrajectoryDescriptor and a\n   * descriptor which is a member of this collection. This is an alternative way of\n   * conceptualizing match cost from getMatchCost(), and it serves a different function.\n   * @param descriptor the descriptor to find the minimum distance to\n   * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\n   */\n  getMatchMinimumDistance(descriptor) {\n    return Math.min(...this._descriptors.map(desc => desc.distance(descriptor)));\n  }\n  /**\n   * Refreshes the internal representation of this DescribedTrajectory.\n   */\n  _refreshDescription() {\n    this._centroidIdx = -1;\n    let sum;\n    const distances = this._descriptors.map(a => {\n      sum = 0;\n      this._descriptors.forEach(b => {\n        sum += a.distance(b);\n      });\n      return sum;\n    });\n    for (let idx = 0; idx < distances.length; ++idx) {\n      if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\n        this._centroidIdx = idx;\n      }\n    }\n    this._averageDistance = 0;\n    this._descriptors.forEach(desc => {\n      this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\n    });\n    if (this._descriptors.length > 0) {\n      this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\n    }\n  }\n}\nTrajectoryClass._MIN_AVERAGE_DISTANCE = 1;\n/**\n * Class representing a set of known, named trajectories to which Trajectories can be\n * added and using which Trajectories can be recognized.\n */\nexport class TrajectoryClassifier {\n  constructor() {\n    this._maximumAllowableMatchCost = 4;\n    this._nameToDescribedTrajectory = new Map();\n  }\n  /**\n   * Serialize to JSON.\n   * @returns JSON serialization\n   */\n  serialize() {\n    const jsonObject = {};\n    jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\n    jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\n    jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\n    jsonObject.nameToDescribedTrajectory = [];\n    this._nameToDescribedTrajectory.forEach((described, name) => {\n      jsonObject.nameToDescribedTrajectory.push(name);\n      jsonObject.nameToDescribedTrajectory.push(described.serialize());\n    });\n    return JSON.stringify(jsonObject);\n  }\n  /**\n   * Deserialize from JSON.\n   * @param json JSON serialization\n   * @returns deserialized TrajectorySet\n   */\n  static Deserialize(json) {\n    const jsonObject = JSON.parse(json);\n    const classifier = new TrajectoryClassifier();\n    classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\n    classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\n    classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize(jsonObject.levenshteinAlphabet);\n    for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\n      classifier._nameToDescribedTrajectory.set(jsonObject.nameToDescribedTrajectory[idx], TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet));\n    }\n    return classifier;\n  }\n  /**\n   * Initialize a new empty TrajectorySet with auto-generated Alphabets.\n   * VERY naive, need to be generating these things from known\n   * sets. Better version later, probably eliminating this one.\n   * @returns auto-generated TrajectorySet\n   */\n  static Generate() {\n    const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\n    const charIdxs = new Array(vecs.chars.length);\n    for (let idx = 0; idx < charIdxs.length; ++idx) {\n      charIdxs[idx] = idx;\n    }\n    const alphabet = new Levenshtein.Alphabet(charIdxs, idx => idx === 0 ? 0 : 1, idx => idx === 0 ? 0 : 1, (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1));\n    const trajectorySet = new TrajectoryClassifier();\n    trajectorySet._vector3Alphabet = vecs;\n    trajectorySet._levenshteinAlphabet = alphabet;\n    return trajectorySet;\n  }\n  /**\n   * Add a new Trajectory to the set with a given name.\n   * @param trajectory new Trajectory to be added\n   * @param classification name to which to add the Trajectory\n   */\n  addTrajectoryToClassification(trajectory, classification) {\n    if (!this._nameToDescribedTrajectory.has(classification)) {\n      this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\n    }\n    this._nameToDescribedTrajectory.get(classification).add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\n  }\n  /**\n   * Remove a known named trajectory and all Trajectories associated with it.\n   * @param classification name to remove\n   * @returns whether anything was removed\n   */\n  deleteClassification(classification) {\n    return this._nameToDescribedTrajectory.delete(classification);\n  }\n  /**\n   * Attempt to recognize a Trajectory from among all the classifications\n   * already known to the classifier.\n   * @param trajectory Trajectory to be recognized\n   * @returns classification of Trajectory if recognized, null otherwise\n   */\n  classifyTrajectory(trajectory) {\n    const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\n    const allowableMatches = [];\n    this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\n      if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\n        allowableMatches.push(classification);\n      }\n    });\n    if (allowableMatches.length === 0) {\n      return null;\n    }\n    let bestIdx = 0;\n    let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx]).getMatchMinimumDistance(descriptor);\n    let match;\n    for (let idx = 0; idx < allowableMatches.length; ++idx) {\n      match = this._nameToDescribedTrajectory.get(allowableMatches[idx]).getMatchMinimumDistance(descriptor);\n      if (match < bestMatch) {\n        bestMatch = match;\n        bestIdx = idx;\n      }\n    }\n    return allowableMatches[bestIdx];\n  }\n}","map":{"version":3,"mappings":"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","names":["Matrix","Vector3","Levenshtein","Alphabet","constructor","characters","charToInsertionCost","charToDeletionCost","charsToSubstitutionCost","a","b","_characterToIdx","Map","_insertionCosts","Array","length","_deletionCosts","_substitutionCosts","c","outerIdx","set","innerIdx","serialize","jsonObject","size","forEach","v","k","JSON","stringify","Deserialize","json","parse","alphabet","getCharacterIdx","char","get","getInsertionCost","idx","getDeletionCost","getSubstitutionCost","idx1","idx2","min","Math","max","Sequence","_MAX_SEQUENCE_LENGTH","Error","_alphabet","_characters","map","sequence","distance","other","_Distance","aChars","bChars","aLength","bLength","costMatrix","_CostMatrix","aIdx","bIdx","_InsertionCost","_DeletionCost","_SubstitutionCost","Trajectory","segmentLength","_points","_segmentLength","trajectory","pt","getLength","add","point","numPoints","push","clone","getT","Distance","t","newPoint","scale","scaleAndAddToRef","resampleAtTargetResolution","targetResolution","resampled","tokenize","tokens","tokenization","segmentDir","_TransformSegmentDirToRef","_TokenizeSegment","priorVec","fromVec","toVec","result","DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD","subtractToRef","_ForwardDir","normalize","scaleToRef","_InverseFromVec","abs","Dot","CrossToRef","_UpDir","LookAtLHToRef","_LookMatrix","_FromToVec","TransformNormalToRef","segment","_BestMatch","_Score","_BestScore","Vector3Alphabet","chars","Generate","alphabetSize","iterations","startingStepSize","endingStepSize","fixedValues","EPSILON","EPSILON_SQUARED","random","copyFrom","stepSize","distSq","force","scratch","lerp","l","r","iteration","copyFromFloats","lengthSquared","scaleInPlace","addInPlace","TrajectoryDescriptor","_sequences","descriptor","s","CreateFromTrajectory","vector3Alphabet","levenshteinAlphabet","CreateFromTokenizationPyramid","_GetTokenizationPyramid","pyramid","_FINEST_DESCRIPTOR_RESOLUTION","res","floor","totalDistance","weight","pow","TrajectoryClass","descriptors","_descriptors","_centroidIdx","_averageDistance","_refreshDescription","desc","centroidIdx","averageDistance","described","getMatchCost","getMatchMinimumDistance","sum","distances","_MIN_AVERAGE_DISTANCE","TrajectoryClassifier","_nameToDescribedTrajectory","maximumAllowableMatchCost","_maximumAllowableMatchCost","_vector3Alphabet","_levenshteinAlphabet","nameToDescribedTrajectory","name","classifier","vecs","Forward","charIdxs","trajectorySet","addTrajectoryToClassification","classification","has","deleteClassification","delete","classifyTrajectory","allowableMatches","trajectoryClass","bestIdx","bestMatch","match"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/trajectoryClassifier.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\n\r\n// This implementation was based on the original MIT-licensed TRACE repository\r\n// from https://github.com/septagon/TRACE.\r\n\r\n/**\r\n * Generic implementation of Levenshtein distance.\r\n */\r\nnamespace Levenshtein {\r\n    /**\r\n     * Alphabet from which to construct sequences to be compared using Levenshtein\r\n     * distance.\r\n     */\r\n    export class Alphabet<T> {\r\n        private _characterToIdx: Map<T, number>;\r\n        private _insertionCosts: number[];\r\n        private _deletionCosts: number[];\r\n        private _substitutionCosts: number[][];\r\n\r\n        /**\r\n         * Serialize the Alphabet to JSON string.\r\n         * @returns JSON serialization\r\n         */\r\n        public serialize(): string {\r\n            const jsonObject: any = {};\r\n\r\n            const characters = new Array<T>(this._characterToIdx.size);\r\n            this._characterToIdx.forEach((v, k) => {\r\n                characters[v] = k;\r\n            });\r\n            jsonObject[\"characters\"] = characters;\r\n\r\n            jsonObject[\"insertionCosts\"] = this._insertionCosts;\r\n            jsonObject[\"deletionCosts\"] = this._deletionCosts;\r\n            jsonObject[\"substitutionCosts\"] = this._substitutionCosts;\r\n\r\n            return JSON.stringify(jsonObject);\r\n        }\r\n\r\n        /**\r\n         * Parse an Alphabet from a JSON serialization.\r\n         * @param json JSON string to deserialize\r\n         * @returns deserialized Alphabet\r\n         */\r\n        public static Deserialize<T>(json: string): Alphabet<T> {\r\n            const jsonObject = JSON.parse(json);\r\n            const alphabet = new Alphabet(jsonObject[\"characters\"] as T[]);\r\n            alphabet._insertionCosts = jsonObject[\"insertionCosts\"];\r\n            alphabet._deletionCosts = jsonObject[\"deletionCosts\"];\r\n            alphabet._substitutionCosts = jsonObject[\"substitutionCosts\"];\r\n            return alphabet;\r\n        }\r\n\r\n        /**\r\n         * Create a new Alphabet.\r\n         * @param characters characters of the alphabet\r\n         * @param charToInsertionCost function mapping characters to insertion costs\r\n         * @param charToDeletionCost function mapping characters to deletion costs\r\n         * @param charsToSubstitutionCost function mapping character pairs to substitution costs\r\n         */\r\n        public constructor(\r\n            characters: Array<T>,\r\n            charToInsertionCost: Nullable<(char: T) => number> = null,\r\n            charToDeletionCost: Nullable<(char: T) => number> = null,\r\n            charsToSubstitutionCost: Nullable<(outChar: T, inChar: T) => number> = null\r\n        ) {\r\n            charToInsertionCost = charToInsertionCost ?? (() => 1);\r\n            charToDeletionCost = charToDeletionCost ?? (() => 1);\r\n            charsToSubstitutionCost = charsToSubstitutionCost ?? ((a: T, b: T) => (a === b ? 0 : 1));\r\n\r\n            this._characterToIdx = new Map<T, number>();\r\n            this._insertionCosts = new Array<number>(characters.length);\r\n            this._deletionCosts = new Array<number>(characters.length);\r\n            this._substitutionCosts = new Array<Array<number>>(characters.length);\r\n\r\n            let c: T;\r\n            for (let outerIdx = 0; outerIdx < characters.length; ++outerIdx) {\r\n                c = characters[outerIdx];\r\n                this._characterToIdx.set(c, outerIdx);\r\n                this._insertionCosts[outerIdx] = charToInsertionCost(c);\r\n                this._deletionCosts[outerIdx] = charToDeletionCost(c);\r\n\r\n                this._substitutionCosts[outerIdx] = new Array<number>(characters.length);\r\n                for (let innerIdx = outerIdx; innerIdx < characters.length; ++innerIdx) {\r\n                    this._substitutionCosts[outerIdx][innerIdx] = charsToSubstitutionCost(c, characters[innerIdx]);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Get the index (internally-assigned number) for a character.\r\n         * @param char character\r\n         * @returns index\r\n         */\r\n        public getCharacterIdx(char: T): number {\r\n            return this._characterToIdx.get(char)!;\r\n        }\r\n\r\n        /**\r\n         * Get the insertion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns insertion cost\r\n         */\r\n        public getInsertionCost(idx: number): number {\r\n            return this._insertionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Get the deletion cost of a character from its index.\r\n         * @param idx character index\r\n         * @returns deletion cost\r\n         */\r\n        public getDeletionCost(idx: number): number {\r\n            return this._deletionCosts[idx];\r\n        }\r\n\r\n        /**\r\n         * Gets the cost to substitute two characters. NOTE: this cost is\r\n         * required to be bi-directional, meaning it cannot matter which of\r\n         * the provided characters is being removed and which is being inserted.\r\n         * @param idx1 the first character index\r\n         * @param idx2 the second character index\r\n         * @returns substitution cost\r\n         */\r\n        public getSubstitutionCost(idx1: number, idx2: number): number {\r\n            const min = Math.min(idx1, idx2);\r\n            const max = Math.max(idx1, idx2);\r\n\r\n            return this._substitutionCosts[min][max];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Character sequence intended to be compared against other Sequences created\r\n     * with the same Alphabet in order to compute Levenshtein distance.\r\n     */\r\n    export class Sequence<T> {\r\n        private _alphabet: Alphabet<T>;\r\n        private _characters: number[];\r\n\r\n        // Scratch values\r\n        private static readonly _MAX_SEQUENCE_LENGTH = 256;\r\n        private static _CostMatrix = [...Array(Sequence._MAX_SEQUENCE_LENGTH + 1)].map(() => new Array<number>(Sequence._MAX_SEQUENCE_LENGTH + 1));\r\n        private static _InsertionCost: number;\r\n        private static _DeletionCost: number;\r\n        private static _SubstitutionCost: number;\r\n\r\n        /**\r\n         * Serialize to JSON string. JSON representation does NOT include the Alphabet\r\n         * from which this Sequence was created; Alphabet must be independently\r\n         * serialized.\r\n         * @returns JSON string\r\n         */\r\n        public serialize(): string {\r\n            return JSON.stringify(this._characters);\r\n        }\r\n\r\n        /**\r\n         * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n         * from which the Sequence was originally created, which must be serialized and\r\n         * deserialized independently so that it can be passed in here.\r\n         * @param json JSON string representation of Sequence\r\n         * @param alphabet Alphabet from which Sequence was originally created\r\n         * @returns Sequence\r\n         */\r\n        public static Deserialize<T>(json: string, alphabet: Alphabet<T>): Sequence<T> {\r\n            const sequence = new Sequence([], alphabet);\r\n            sequence._characters = JSON.parse(json);\r\n            return sequence;\r\n        }\r\n\r\n        /**\r\n         * Create a new Sequence.\r\n         * @param characters characters in the new Sequence\r\n         * @param alphabet Alphabet, which must include all used characters\r\n         */\r\n        public constructor(characters: T[], alphabet: Alphabet<T>) {\r\n            if (characters.length > Sequence._MAX_SEQUENCE_LENGTH) {\r\n                throw new Error(\"Sequences longer than \" + Sequence._MAX_SEQUENCE_LENGTH + \" not supported.\");\r\n            }\r\n            this._alphabet = alphabet;\r\n            this._characters = characters.map((c) => this._alphabet.getCharacterIdx(c));\r\n        }\r\n\r\n        /**\r\n         * Get the distance between this Sequence and another.\r\n         * @param other sequence to compare to\r\n         * @returns Levenshtein distance\r\n         */\r\n        public distance(other: Sequence<T>): number {\r\n            return Sequence._Distance<T>(this, other);\r\n        }\r\n\r\n        /**\r\n         * Compute the Levenshtein distance between two Sequences.\r\n         * @param a first Sequence\r\n         * @param b second Sequence\r\n         * @returns Levenshtein distance\r\n         */\r\n        private static _Distance<T>(a: Sequence<T>, b: Sequence<T>): number {\r\n            const alphabet = a._alphabet;\r\n            if (alphabet !== b._alphabet) {\r\n                throw new Error(\"Cannot Levenshtein compare Sequences built from different alphabets.\");\r\n            }\r\n            const aChars = a._characters;\r\n            const bChars = b._characters;\r\n            const aLength = aChars.length;\r\n            const bLength = bChars.length;\r\n\r\n            const costMatrix = Sequence._CostMatrix;\r\n            costMatrix[0][0] = 0;\r\n            for (let idx = 0; idx < aLength; ++idx) {\r\n                costMatrix[idx + 1][0] = costMatrix[idx][0] + alphabet.getInsertionCost(aChars[idx]);\r\n            }\r\n            for (let idx = 0; idx < bLength; ++idx) {\r\n                costMatrix[0][idx + 1] = costMatrix[0][idx] + alphabet.getInsertionCost(bChars[idx]);\r\n            }\r\n\r\n            for (let aIdx = 0; aIdx < aLength; ++aIdx) {\r\n                for (let bIdx = 0; bIdx < bLength; ++bIdx) {\r\n                    Sequence._InsertionCost = costMatrix[aIdx + 1][bIdx] + alphabet.getInsertionCost(bChars[bIdx]);\r\n                    Sequence._DeletionCost = costMatrix[aIdx][bIdx + 1] + alphabet.getDeletionCost(aChars[aIdx]);\r\n                    Sequence._SubstitutionCost = costMatrix[aIdx][bIdx] + alphabet.getSubstitutionCost(aChars[aIdx], bChars[bIdx]);\r\n\r\n                    costMatrix[aIdx + 1][bIdx + 1] = Math.min(Sequence._InsertionCost, Sequence._DeletionCost, Sequence._SubstitutionCost);\r\n                }\r\n            }\r\n\r\n            return costMatrix[aLength][bLength];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A 3D trajectory consisting of an order list of vectors describing a\r\n * path of motion through 3D space.\r\n */\r\nexport class Trajectory {\r\n    private _points: Vector3[];\r\n    private readonly _segmentLength: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns serialized JSON string\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json serialized JSON string\r\n     * @returns deserialized Trajectory\r\n     */\r\n    public static Deserialize(json: string): Trajectory {\r\n        const jsonObject = JSON.parse(json);\r\n        const trajectory = new Trajectory(jsonObject[\"_segmentLength\"]);\r\n        trajectory._points = jsonObject[\"_points\"].map((pt: any) => {\r\n            return new Vector3(pt[\"_x\"], pt[\"_y\"], pt[\"_z\"]);\r\n        });\r\n        return trajectory;\r\n    }\r\n\r\n    /**\r\n     * Create a new empty Trajectory.\r\n     * @param segmentLength radius of discretization for Trajectory points\r\n     */\r\n    public constructor(segmentLength: number = 0.01) {\r\n        this._points = [];\r\n        this._segmentLength = segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Get the length of the Trajectory.\r\n     * @returns length of the Trajectory\r\n     */\r\n    public getLength(): number {\r\n        return this._points.length * this._segmentLength;\r\n    }\r\n\r\n    /**\r\n     * Append a new point to the Trajectory.\r\n     * NOTE: This implementation has many allocations.\r\n     * @param point point to append to the Trajectory\r\n     */\r\n    public add(point: DeepImmutable<Vector3>): void {\r\n        let numPoints = this._points.length;\r\n        if (numPoints === 0) {\r\n            this._points.push(point.clone());\r\n        } else {\r\n            const getT = () => this._segmentLength / Vector3.Distance(this._points[numPoints - 1], point);\r\n            for (let t = getT(); t <= 1.0; t = getT()) {\r\n                const newPoint = this._points[numPoints - 1].scale(1.0 - t);\r\n                point.scaleAndAddToRef(t, newPoint);\r\n                this._points.push(newPoint);\r\n                ++numPoints;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new Trajectory with a segment length chosen to make it\r\n     * probable that the new Trajectory will have a specified number of\r\n     * segments. This operation is imprecise.\r\n     * @param targetResolution number of segments desired\r\n     * @returns new Trajectory with approximately the requested number of segments\r\n     */\r\n    public resampleAtTargetResolution(targetResolution: number): Trajectory {\r\n        const resampled = new Trajectory(this.getLength() / targetResolution);\r\n        this._points.forEach((pt) => {\r\n            resampled.add(pt);\r\n        });\r\n        return resampled;\r\n    }\r\n\r\n    /**\r\n     * Convert Trajectory segments into tokenized representation. This\r\n     * representation is an array of numbers where each nth number is the\r\n     * index of the token which is most similar to the nth segment of the\r\n     * Trajectory.\r\n     * @param tokens list of vectors which serve as discrete tokens\r\n     * @returns list of indices of most similar token per segment\r\n     */\r\n    public tokenize(tokens: DeepImmutable<Vector3[]>): number[] {\r\n        const tokenization: number[] = [];\r\n\r\n        const segmentDir = new Vector3();\r\n        for (let idx = 2; idx < this._points.length; ++idx) {\r\n            if (Trajectory._TransformSegmentDirToRef(this._points[idx - 2], this._points[idx - 1], this._points[idx], segmentDir)) {\r\n                tokenization.push(Trajectory._TokenizeSegment(segmentDir, tokens));\r\n            }\r\n        }\r\n\r\n        return tokenization;\r\n    }\r\n\r\n    private static _ForwardDir = new Vector3();\r\n    private static _InverseFromVec = new Vector3();\r\n    private static _UpDir = new Vector3();\r\n    private static _FromToVec = new Vector3();\r\n    private static _LookMatrix = new Matrix();\r\n\r\n    /**\r\n     * Transform the rotation (i.e., direction) of a segment to isolate\r\n     * the relative transformation represented by the segment. This operation\r\n     * may or may not succeed due to singularities in the equations that define\r\n     * motion relativity in this context.\r\n     * @param priorVec the origin of the prior segment\r\n     * @param fromVec the origin of the current segment\r\n     * @param toVec the destination of the current segment\r\n     * @param result reference to output variable\r\n     * @returns whether or not transformation was successful\r\n     */\r\n    private static _TransformSegmentDirToRef(priorVec: DeepImmutable<Vector3>, fromVec: DeepImmutable<Vector3>, toVec: DeepImmutable<Vector3>, result: Vector3): boolean {\r\n        const DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD = 0.98;\r\n\r\n        fromVec.subtractToRef(priorVec, Trajectory._ForwardDir);\r\n        Trajectory._ForwardDir.normalize();\r\n        fromVec.scaleToRef(-1, Trajectory._InverseFromVec);\r\n        Trajectory._InverseFromVec.normalize();\r\n\r\n        if (Math.abs(Vector3.Dot(Trajectory._ForwardDir, Trajectory._InverseFromVec)) > DOT_PRODUCT_SAMPLE_REJECTION_THRESHOLD) {\r\n            return false;\r\n        }\r\n\r\n        Vector3.CrossToRef(Trajectory._ForwardDir, Trajectory._InverseFromVec, Trajectory._UpDir);\r\n        Trajectory._UpDir.normalize();\r\n        Matrix.LookAtLHToRef(priorVec, fromVec, Trajectory._UpDir, Trajectory._LookMatrix);\r\n        toVec.subtractToRef(fromVec, Trajectory._FromToVec);\r\n        Trajectory._FromToVec.normalize();\r\n        Vector3.TransformNormalToRef(Trajectory._FromToVec, Trajectory._LookMatrix, result);\r\n        return true;\r\n    }\r\n\r\n    private static _BestMatch: number;\r\n    private static _Score: number;\r\n    private static _BestScore: number;\r\n\r\n    /**\r\n     * Determine which token vector is most similar to the\r\n     * segment vector.\r\n     * @param segment segment vector\r\n     * @param tokens token vector list\r\n     * @returns index of the most similar token to the segment\r\n     */\r\n    private static _TokenizeSegment(segment: DeepImmutable<Vector3>, tokens: DeepImmutable<Vector3[]>): number {\r\n        Trajectory._BestMatch = 0;\r\n        Trajectory._Score = Vector3.Dot(segment, tokens[0]);\r\n        Trajectory._BestScore = Trajectory._Score;\r\n        for (let idx = 1; idx < tokens.length; ++idx) {\r\n            Trajectory._Score = Vector3.Dot(segment, tokens[idx]);\r\n            if (Trajectory._Score > Trajectory._BestScore) {\r\n                Trajectory._BestMatch = idx;\r\n                Trajectory._BestScore = Trajectory._Score;\r\n            }\r\n        }\r\n\r\n        return Trajectory._BestMatch;\r\n    }\r\n}\r\n\r\n/**\r\n * Collection of vectors intended to be used as the basis of Trajectory\r\n * tokenization for Levenshtein distance comparison. Canonically, a\r\n * Vector3Alphabet will resemble a \"spikeball\" of vectors distributed\r\n * roughly evenly over the surface of the unit sphere.\r\n */\r\nclass Vector3Alphabet {\r\n    /**\r\n     * Characters in the alphabet.\r\n     * NOTE: There is no reason for this property to exist and this class should just extend\r\n     * Array<Vector3>, except that doing so produces bizarre build-time errors indicating that\r\n     * the ES5 library itself fails its own TypeDoc validation.\r\n     */\r\n    public chars: Vector3[];\r\n\r\n    /**\r\n     * Helper method to create new \"spikeball\" Vector3Alphabets. Uses a naive\r\n     * optimize-from-random strategy to space points around the unit sphere\r\n     * surface as a simple alternative to really doing the math to tile the\r\n     * sphere.\r\n     * @param alphabetSize size of the desired alphabet\r\n     * @param iterations number of iterations over which to optimize the \"spikeball\"\r\n     * @param startingStepSize distance factor to move points in early optimization iterations\r\n     * @param endingStepSize distance factor to move points in late optimization iterations\r\n     * @param fixedValues alphabet \"characters\" that are required and cannot be moved by optimization\r\n     * @returns a new randomly generated and optimized Vector3Alphabet of the specified size\r\n     */\r\n    public static Generate(\r\n        alphabetSize: number = 64,\r\n        iterations: number = 256,\r\n        startingStepSize: number = 0.1,\r\n        endingStepSize: number = 0.001,\r\n        fixedValues: DeepImmutable<Vector3[]> = []\r\n    ): Vector3Alphabet {\r\n        const EPSILON = 0.001;\r\n        const EPSILON_SQUARED = EPSILON * EPSILON;\r\n\r\n        const alphabet = new Vector3Alphabet(alphabetSize);\r\n        for (let idx = 0; idx < alphabetSize; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\r\n            alphabet.chars[idx].normalize();\r\n        }\r\n\r\n        for (let idx = 0; idx < fixedValues.length; ++idx) {\r\n            alphabet.chars[idx].copyFrom(fixedValues[idx]);\r\n        }\r\n\r\n        let stepSize: number;\r\n        let distSq: number;\r\n        const force = new Vector3();\r\n        const scratch = new Vector3();\r\n        const lerp = (l: number, r: number, t: number) => (1.0 - t) * l + t * r;\r\n        for (let iteration = 0; iteration < iterations; ++iteration) {\r\n            stepSize = lerp(startingStepSize, endingStepSize, iteration / (iterations - 1));\r\n            for (let idx = fixedValues.length; idx < alphabet.chars.length; ++idx) {\r\n                force.copyFromFloats(0, 0, 0);\r\n                alphabet.chars.forEach((pt) => {\r\n                    alphabet.chars[idx].subtractToRef(pt, scratch);\r\n                    distSq = scratch.lengthSquared();\r\n                    if (distSq > EPSILON_SQUARED) {\r\n                        scratch.scaleAndAddToRef(1 / (scratch.lengthSquared() * distSq), force);\r\n                    }\r\n                });\r\n                force.scaleInPlace(stepSize);\r\n                alphabet.chars[idx].addInPlace(force);\r\n                alphabet.chars[idx].normalize();\r\n            }\r\n        }\r\n\r\n        return alphabet;\r\n    }\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this.chars);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized Vector3Alphabet\r\n     */\r\n    public static Deserialize(json: string): Vector3Alphabet {\r\n        const jsonObject = JSON.parse(json);\r\n        const alphabet = new Vector3Alphabet(jsonObject.length);\r\n        for (let idx = 0; idx < jsonObject.length; ++idx) {\r\n            alphabet.chars[idx] = new Vector3(jsonObject[idx][\"_x\"], jsonObject[idx][\"_y\"], jsonObject[idx][\"_z\"]);\r\n        }\r\n        return alphabet;\r\n    }\r\n\r\n    private constructor(size: number) {\r\n        this.chars = new Array(size);\r\n    }\r\n}\r\n\r\n/**\r\n * Class which formalizes the manner in which a Vector3Alphabet is used to tokenize and\r\n * describe a Trajectory. This class houses the functionality which determines what\r\n * attributes of Trajectories are and are not considered important, such as scale.\r\n */\r\nclass TrajectoryDescriptor {\r\n    private static readonly _FINEST_DESCRIPTOR_RESOLUTION = 32;\r\n\r\n    private _sequences: Levenshtein.Sequence<number>[];\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        return JSON.stringify(this._sequences.map((sequence) => sequence.serialize()));\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptor was originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON serialization\r\n     * @param alphabet Alphabet from which descriptor was originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        const descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = (JSON.parse(json) as string[]).map((s) => Levenshtein.Sequence.Deserialize(s, alphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor to describe a provided Trajectory according\r\n     * to the provided alphabets.\r\n     * @param trajectory Trajectory to be described\r\n     * @param vector3Alphabet Vector3Alphabet to be used to tokenize the Trajectory\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be used as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing provided Trajectory\r\n     */\r\n    public static CreateFromTrajectory(trajectory: Trajectory, vector3Alphabet: Vector3Alphabet, levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        return TrajectoryDescriptor.CreateFromTokenizationPyramid(TrajectoryDescriptor._GetTokenizationPyramid(trajectory, vector3Alphabet), levenshteinAlphabet);\r\n    }\r\n\r\n    /**\r\n     * Create a new TrajectoryDescriptor from a pre-existing pyramid of tokens.\r\n     * NOTE: This function exists to support an outdated serialization mechanism and should\r\n     * be deleted if it is no longer useful.\r\n     * @param pyramid tokenization pyramid\r\n     * @param levenshteinAlphabet Levenshtein.Alphabet to be uses as basis for comparison with other descriptors\r\n     * @returns TrajectoryDescriptor describing the Trajectory from which the pyramid was built\r\n     */\r\n    public static CreateFromTokenizationPyramid(pyramid: number[][], levenshteinAlphabet: Levenshtein.Alphabet<number>): TrajectoryDescriptor {\r\n        const descriptor = new TrajectoryDescriptor();\r\n        descriptor._sequences = pyramid.map((tokens) => new Levenshtein.Sequence<number>(tokens, levenshteinAlphabet));\r\n        return descriptor;\r\n    }\r\n\r\n    private constructor() {\r\n        this._sequences = [];\r\n    }\r\n\r\n    /**\r\n     * Create the tokenization pyramid for the provided Trajectory according to the given\r\n     * Vector3Alphabet.\r\n     * @param trajectory Trajectory to be tokenized\r\n     * @param alphabet Vector3Alphabet containing tokens\r\n     * @param targetResolution finest resolution of descriptor\r\n     * @returns tokenization pyramid for Trajectory\r\n     */\r\n    private static _GetTokenizationPyramid(\r\n        trajectory: Trajectory,\r\n        alphabet: Vector3Alphabet,\r\n        targetResolution: number = TrajectoryDescriptor._FINEST_DESCRIPTOR_RESOLUTION\r\n    ): number[][] {\r\n        const pyramid: number[][] = [];\r\n        for (let res = targetResolution; res > 4; res = Math.floor(res / 2)) {\r\n            pyramid.push(trajectory.resampleAtTargetResolution(res).tokenize(alphabet.chars));\r\n        }\r\n        return pyramid;\r\n    }\r\n\r\n    /**\r\n     * Calculate a distance metric between this TrajectoryDescriptor and another. This is\r\n     * essentially a similarity score and does not directly represent Euclidean distance,\r\n     * edit distance, or any other formal distance metric.\r\n     * @param other TrajectoryDescriptor from which to determine distance\r\n     * @returns distance, a nonnegative similarity score where larger values indicate dissimilarity\r\n     */\r\n    public distance(other: TrajectoryDescriptor): number {\r\n        let totalDistance = 0;\r\n        let weight: number;\r\n        for (let idx = 0; idx < this._sequences.length; ++idx) {\r\n            weight = Math.pow(2, idx);\r\n            totalDistance += weight * this._sequences[idx].distance(other._sequences[idx]);\r\n        }\r\n        return totalDistance;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of TrajectoryDescriptors defined to be \"the same.\" This is essentially a helper\r\n * class to facilitate methods of Trajectory clustering.\r\n */\r\nclass TrajectoryClass {\r\n    private static readonly _MIN_AVERAGE_DISTANCE = 1;\r\n\r\n    private _descriptors: TrajectoryDescriptor[];\r\n    private _centroidIdx: number;\r\n    private _averageDistance: number;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        const jsonObject: any = {};\r\n        jsonObject.descriptors = this._descriptors.map((desc) => desc.serialize());\r\n        jsonObject.centroidIdx = this._centroidIdx;\r\n        jsonObject.averageDistance = this._averageDistance;\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON string and Alphabet. This should be the same Alphabet\r\n     * from which the descriptors were originally created, which must be serialized and\r\n     * deserialized independently so that it can be passed in here.\r\n     * @param json JSON string representation\r\n     * @param alphabet Alphabet from which TrajectoryDescriptors were originally created\r\n     * @returns deserialized TrajectoryDescriptor\r\n     */\r\n    public static Deserialize(json: string, alphabet: Levenshtein.Alphabet<number>): TrajectoryClass {\r\n        const jsonObject = JSON.parse(json);\r\n        const described = new TrajectoryClass();\r\n        described._descriptors = jsonObject.descriptors.map((s: string) => TrajectoryDescriptor.Deserialize(s, alphabet));\r\n        described._centroidIdx = jsonObject.centroidIdx;\r\n        described._averageDistance = jsonObject.averageDistance;\r\n        return described;\r\n    }\r\n\r\n    /**\r\n     * Create a new DescribedTrajectory.\r\n     * @param descriptors currently-known TrajectoryDescriptors, if any\r\n     */\r\n    public constructor(descriptors: TrajectoryDescriptor[] = []) {\r\n        this._descriptors = descriptors;\r\n        this._centroidIdx = -1;\r\n        this._averageDistance = 0;\r\n\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Add a new TrajectoryDescriptor to the list of descriptors known to describe\r\n     * this same DescribedTrajectory.\r\n     * @param descriptor descriptor to be added\r\n     */\r\n    public add(descriptor: TrajectoryDescriptor): void {\r\n        this._descriptors.push(descriptor);\r\n        this._refreshDescription();\r\n    }\r\n\r\n    /**\r\n     * Compute the cost, which is inversely related to the likelihood that the provided\r\n     * TrajectoryDescriptor describes a Trajectory that is considered to be the same as\r\n     * the class represented by this DescribedTrajectory.\r\n     * @param descriptor the descriptor to be costed\r\n     * @returns cost of the match, which is a nonnegative similarity metric where larger values indicate dissimilarity\r\n     */\r\n    public getMatchCost(descriptor: TrajectoryDescriptor): number {\r\n        return descriptor.distance(this._descriptors[this._centroidIdx]) / this._averageDistance;\r\n    }\r\n\r\n    /**\r\n     * Compute the minimum distance between the queried TrajectoryDescriptor and a\r\n     * descriptor which is a member of this collection. This is an alternative way of\r\n     * conceptualizing match cost from getMatchCost(), and it serves a different function.\r\n     * @param descriptor the descriptor to find the minimum distance to\r\n     * @returns minimum descriptor distance to a member descriptor of this DescribedTrajectory\r\n     */\r\n    public getMatchMinimumDistance(descriptor: TrajectoryDescriptor): number {\r\n        return Math.min(...this._descriptors.map((desc) => desc.distance(descriptor)));\r\n    }\r\n\r\n    /**\r\n     * Refreshes the internal representation of this DescribedTrajectory.\r\n     */\r\n    private _refreshDescription(): void {\r\n        this._centroidIdx = -1;\r\n        let sum: number;\r\n        const distances = this._descriptors.map((a) => {\r\n            sum = 0;\r\n            this._descriptors.forEach((b) => {\r\n                sum += a.distance(b);\r\n            });\r\n            return sum;\r\n        });\r\n        for (let idx = 0; idx < distances.length; ++idx) {\r\n            if (this._centroidIdx < 0 || distances[idx] < distances[this._centroidIdx]) {\r\n                this._centroidIdx = idx;\r\n            }\r\n        }\r\n\r\n        this._averageDistance = 0;\r\n        this._descriptors.forEach((desc) => {\r\n            this._averageDistance += desc.distance(this._descriptors[this._centroidIdx]);\r\n        });\r\n        if (this._descriptors.length > 0) {\r\n            this._averageDistance = Math.max(this._averageDistance / this._descriptors.length, TrajectoryClass._MIN_AVERAGE_DISTANCE);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class representing a set of known, named trajectories to which Trajectories can be\r\n * added and using which Trajectories can be recognized.\r\n */\r\nexport class TrajectoryClassifier {\r\n    private _maximumAllowableMatchCost: number = 4;\r\n    private _vector3Alphabet: Vector3Alphabet;\r\n    private _levenshteinAlphabet: Levenshtein.Alphabet<number>;\r\n    private _nameToDescribedTrajectory: Map<string, TrajectoryClass>;\r\n\r\n    /**\r\n     * Serialize to JSON.\r\n     * @returns JSON serialization\r\n     */\r\n    public serialize(): string {\r\n        const jsonObject: any = {};\r\n        jsonObject.maximumAllowableMatchCost = this._maximumAllowableMatchCost;\r\n        jsonObject.vector3Alphabet = this._vector3Alphabet.serialize();\r\n        jsonObject.levenshteinAlphabet = this._levenshteinAlphabet.serialize();\r\n        jsonObject.nameToDescribedTrajectory = [];\r\n        this._nameToDescribedTrajectory.forEach((described, name) => {\r\n            jsonObject.nameToDescribedTrajectory.push(name);\r\n            jsonObject.nameToDescribedTrajectory.push(described.serialize());\r\n        });\r\n        return JSON.stringify(jsonObject);\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON.\r\n     * @param json JSON serialization\r\n     * @returns deserialized TrajectorySet\r\n     */\r\n    public static Deserialize(json: string): TrajectoryClassifier {\r\n        const jsonObject = JSON.parse(json);\r\n        const classifier = new TrajectoryClassifier();\r\n        classifier._maximumAllowableMatchCost = jsonObject.maximumAllowableMatchCost;\r\n        classifier._vector3Alphabet = Vector3Alphabet.Deserialize(jsonObject.vector3Alphabet);\r\n        classifier._levenshteinAlphabet = Levenshtein.Alphabet.Deserialize<number>(jsonObject.levenshteinAlphabet);\r\n        for (let idx = 0; idx < jsonObject.nameToDescribedTrajectory.length; idx += 2) {\r\n            classifier._nameToDescribedTrajectory.set(\r\n                jsonObject.nameToDescribedTrajectory[idx],\r\n                TrajectoryClass.Deserialize(jsonObject.nameToDescribedTrajectory[idx + 1], classifier._levenshteinAlphabet)\r\n            );\r\n        }\r\n        return classifier;\r\n    }\r\n\r\n    /**\r\n     * Initialize a new empty TrajectorySet with auto-generated Alphabets.\r\n     * VERY naive, need to be generating these things from known\r\n     * sets. Better version later, probably eliminating this one.\r\n     * @returns auto-generated TrajectorySet\r\n     */\r\n    public static Generate(): TrajectoryClassifier {\r\n        const vecs = Vector3Alphabet.Generate(64, 256, 0.1, 0.001, [Vector3.Forward()]);\r\n\r\n        const charIdxs = new Array(vecs.chars.length);\r\n        for (let idx = 0; idx < charIdxs.length; ++idx) {\r\n            charIdxs[idx] = idx;\r\n        }\r\n\r\n        const alphabet = new Levenshtein.Alphabet<number>(\r\n            charIdxs,\r\n            (idx) => (idx === 0 ? 0 : 1),\r\n            (idx) => (idx === 0 ? 0 : 1),\r\n            (a, b) => Math.min(1 - Vector3.Dot(vecs.chars[a], vecs.chars[b]), 1)\r\n        );\r\n\r\n        const trajectorySet = new TrajectoryClassifier();\r\n        trajectorySet._vector3Alphabet = vecs;\r\n        trajectorySet._levenshteinAlphabet = alphabet;\r\n        return trajectorySet;\r\n    }\r\n\r\n    private constructor() {\r\n        this._nameToDescribedTrajectory = new Map<string, TrajectoryClass>();\r\n    }\r\n\r\n    /**\r\n     * Add a new Trajectory to the set with a given name.\r\n     * @param trajectory new Trajectory to be added\r\n     * @param classification name to which to add the Trajectory\r\n     */\r\n    public addTrajectoryToClassification(trajectory: Trajectory, classification: string): void {\r\n        if (!this._nameToDescribedTrajectory.has(classification)) {\r\n            this._nameToDescribedTrajectory.set(classification, new TrajectoryClass());\r\n        }\r\n\r\n        this._nameToDescribedTrajectory.get(classification)!.add(TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet));\r\n    }\r\n\r\n    /**\r\n     * Remove a known named trajectory and all Trajectories associated with it.\r\n     * @param classification name to remove\r\n     * @returns whether anything was removed\r\n     */\r\n    public deleteClassification(classification: string): boolean {\r\n        return this._nameToDescribedTrajectory.delete(classification);\r\n    }\r\n\r\n    /**\r\n     * Attempt to recognize a Trajectory from among all the classifications\r\n     * already known to the classifier.\r\n     * @param trajectory Trajectory to be recognized\r\n     * @returns classification of Trajectory if recognized, null otherwise\r\n     */\r\n    public classifyTrajectory(trajectory: Trajectory): Nullable<string> {\r\n        const descriptor = TrajectoryDescriptor.CreateFromTrajectory(trajectory, this._vector3Alphabet, this._levenshteinAlphabet);\r\n\r\n        const allowableMatches: string[] = [];\r\n        this._nameToDescribedTrajectory.forEach((trajectoryClass, classification) => {\r\n            if (trajectoryClass.getMatchCost(descriptor) < this._maximumAllowableMatchCost) {\r\n                allowableMatches.push(classification);\r\n            }\r\n        });\r\n\r\n        if (allowableMatches.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        let bestIdx = 0;\r\n        let bestMatch = this._nameToDescribedTrajectory.get(allowableMatches[bestIdx])!.getMatchMinimumDistance(descriptor);\r\n        let match: number;\r\n        for (let idx = 0; idx < allowableMatches.length; ++idx) {\r\n            match = this._nameToDescribedTrajectory.get(allowableMatches[idx])!.getMatchMinimumDistance(descriptor);\r\n            if (match < bestMatch) {\r\n                bestMatch = match;\r\n                bestIdx = idx;\r\n            }\r\n        }\r\n        return allowableMatches[bestIdx];\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}