{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Enum that describes the state of the image trackability score status for this session.\n */\nvar ImageTrackingScoreStatus;\n(function (ImageTrackingScoreStatus) {\n  // AR Session has not yet assessed image trackability scores.\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"NotReceived\"] = 0] = \"NotReceived\";\n  // A request to retrieve trackability scores has been sent, but no response has been received.\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Waiting\"] = 1] = \"Waiting\";\n  // Image trackability scores have been received for this session\n  ImageTrackingScoreStatus[ImageTrackingScoreStatus[\"Received\"] = 2] = \"Received\";\n})(ImageTrackingScoreStatus || (ImageTrackingScoreStatus = {}));\n/**\n * Image tracking for immersive AR sessions.\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\n */\nexport class WebXRImageTracking extends WebXRAbstractFeature {\n  /**\n   * constructs the image tracking feature\n   * @param _xrSessionManager the session manager for this module\n   * @param options read-only options to be used in this module\n   */\n  constructor(_xrSessionManager,\n  /**\n   * read-only options to be used in this module\n   */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    /**\n     * This will be triggered if the underlying system deems an image untrackable.\n     * The index is the index of the image from the array used to initialize the feature.\n     */\n    this.onUntrackableImageFoundObservable = new Observable();\n    /**\n     * An image was deemed trackable, and the system will start tracking it.\n     */\n    this.onTrackableImageFoundObservable = new Observable();\n    /**\n     * The image was found and its state was updated.\n     */\n    this.onTrackedImageUpdatedObservable = new Observable();\n    this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n    this._trackedImages = [];\n    this.xrNativeFeatureName = \"image-tracking\";\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    return super.attach();\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    return super.detach();\n  }\n  /**\n   * Get a tracked image by its ID.\n   *\n   * @param id the id of the image to load (position in the init array)\n   * @returns a trackable image, if exists in this location\n   */\n  getTrackedImageById(id) {\n    return this._trackedImages[id] || null;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this._trackedImages.forEach(trackedImage => {\n      trackedImage.originalBitmap.close();\n    });\n    this._trackedImages.length = 0;\n    this.onTrackableImageFoundObservable.clear();\n    this.onUntrackableImageFoundObservable.clear();\n    this.onTrackedImageUpdatedObservable.clear();\n  }\n  /**\n   * Extends the session init object if needed\n   * @returns augmentation object fo the xr session init object.\n   */\n  async getXRSessionInitExtension() {\n    if (!this.options.images || !this.options.images.length) {\n      return {};\n    }\n    const promises = this.options.images.map(image => {\n      if (typeof image.src === \"string\") {\n        return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\n      } else {\n        return Promise.resolve(image.src); // resolve is probably unneeded\n      }\n    });\n\n    try {\n      const images = await Promise.all(promises);\n      this._originalTrackingRequest = images.map((image, idx) => {\n        return {\n          image,\n          widthInMeters: this.options.images[idx].estimatedRealWorldWidth\n        };\n      });\n      return {\n        trackedImages: this._originalTrackingRequest\n      };\n    } catch (ex) {\n      Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\n      return {};\n    }\n  }\n  _onXRFrame(_xrFrame) {\n    if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\n      return;\n    }\n    // Image tracking scores may be generated a few frames after the XR Session initializes.\n    // If we haven't received scores yet, then kick off the task to check scores and return immediately.\n    if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\n      this._checkScoresAsync();\n      return;\n    }\n    const imageTrackedResults = _xrFrame.getImageTrackingResults();\n    for (const result of imageTrackedResults) {\n      let changed = false;\n      const imageIndex = result.index;\n      const imageObject = this._trackedImages[imageIndex];\n      if (!imageObject) {\n        // something went wrong!\n        continue;\n      }\n      imageObject.xrTrackingResult = result;\n      if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\n        imageObject.realWorldWidth = result.measuredWidthInMeters;\n        changed = true;\n      }\n      // Get the pose of the image relative to a reference space.\n      const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\n      if (pose) {\n        const mat = imageObject.transformationMatrix;\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n        changed = true;\n      }\n      const state = result.trackingState;\n      const emulated = state === \"emulated\";\n      if (imageObject.emulated !== emulated) {\n        imageObject.emulated = emulated;\n        changed = true;\n      }\n      if (changed) {\n        this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\n      }\n    }\n  }\n  async _checkScoresAsync() {\n    if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\n      return;\n    }\n    this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\n    const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\n    if (!imageScores || imageScores.length === 0) {\n      this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\n      return;\n    }\n    // check the scores for all\n    for (let idx = 0; idx < imageScores.length; ++idx) {\n      if (imageScores[idx] == \"untrackable\") {\n        this.onUntrackableImageFoundObservable.notifyObservers(idx);\n      } else {\n        const originalBitmap = this._originalTrackingRequest[idx].image;\n        const imageObject = {\n          id: idx,\n          originalBitmap,\n          transformationMatrix: new Matrix(),\n          ratio: originalBitmap.width / originalBitmap.height\n        };\n        this._trackedImages[idx] = imageObject;\n        this.onTrackableImageFoundObservable.notifyObservers(imageObject);\n      }\n    }\n    this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\n  }\n}\n/**\n * The module's name\n */\nWebXRImageTracking.Name = WebXRFeatureName.IMAGE_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRImageTracking.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRImageTracking.Name, (xrSessionManager, options) => {\n  return () => new WebXRImageTracking(xrSessionManager, options);\n}, WebXRImageTracking.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","WebXRAbstractFeature","Matrix","Tools","ImageTrackingScoreStatus","WebXRImageTracking","constructor","_xrSessionManager","options","NotReceived","xrNativeFeatureName","attach","detach","getTrackedImageById","id","_trackedImages","dispose","forEach","trackedImage","originalBitmap","close","length","onTrackableImageFoundObservable","clear","onUntrackableImageFoundObservable","onTrackedImageUpdatedObservable","getXRSessionInitExtension","images","promises","map","image","src","scene","getEngine","_createImageBitmapFromSource","Promise","resolve","all","_originalTrackingRequest","idx","widthInMeters","estimatedRealWorldWidth","trackedImages","ex","Error","_onXRFrame","_xrFrame","getImageTrackingResults","_trackableScoreStatus","Waiting","_checkScoresAsync","imageTrackedResults","result","changed","imageIndex","index","imageObject","xrTrackingResult","realWorldWidth","measuredWidthInMeters","pose","getPose","imageSpace","referenceSpace","mat","transformationMatrix","FromArrayToRef","transform","matrix","useRightHandedSystem","toggleModelMatrixHandInPlace","state","trackingState","emulated","notifyObservers","session","getTrackedImageScores","imageScores","ratio","width","height","Received","IMAGE_TRACKING","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRImageTracking.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Options interface for the background remover plugin\r\n */\r\nexport interface IWebXRImageTrackingOptions {\r\n    /**\r\n     * A required array with images to track\r\n     */\r\n    images: {\r\n        /**\r\n         * The source of the image. can be a URL or an image bitmap\r\n         */\r\n        src: string | ImageBitmap;\r\n        /**\r\n         * The estimated width in the real world (in meters)\r\n         */\r\n        estimatedRealWorldWidth: number; // In meters!\r\n    }[];\r\n}\r\n\r\n/**\r\n * An object representing an image tracked by the system\r\n */\r\nexport interface IWebXRTrackedImage {\r\n    /**\r\n     * The ID of this image (which is the same as the position in the array that was used to initialize the feature)\r\n     */\r\n    id: number;\r\n    /**\r\n     * Is the transformation provided emulated. If it is, the system \"guesses\" its real position. Otherwise it can be considered as exact position.\r\n     */\r\n    emulated?: boolean;\r\n    /**\r\n     * Just in case it is needed - the image bitmap that is being tracked\r\n     */\r\n    originalBitmap: ImageBitmap;\r\n    /**\r\n     * The native XR result image tracking result, untouched\r\n     */\r\n    xrTrackingResult?: XRImageTrackingResult;\r\n    /**\r\n     * Width in real world (meters)\r\n     */\r\n    realWorldWidth?: number;\r\n    /**\r\n     * A transformation matrix of this current image in the current reference space.\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The width/height ratio of this image. can be used to calculate the size of the detected object/image\r\n     */\r\n    ratio?: number;\r\n}\r\n\r\n/**\r\n * Enum that describes the state of the image trackability score status for this session.\r\n */\r\nenum ImageTrackingScoreStatus {\r\n    // AR Session has not yet assessed image trackability scores.\r\n    NotReceived,\r\n    // A request to retrieve trackability scores has been sent, but no response has been received.\r\n    Waiting,\r\n    // Image trackability scores have been received for this session\r\n    Received,\r\n}\r\n\r\n/**\r\n * Image tracking for immersive AR sessions.\r\n * Providing a list of images and their estimated widths will enable tracking those images in the real world.\r\n */\r\nexport class WebXRImageTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.IMAGE_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * This will be triggered if the underlying system deems an image untrackable.\r\n     * The index is the index of the image from the array used to initialize the feature.\r\n     */\r\n    public onUntrackableImageFoundObservable: Observable<number> = new Observable();\r\n    /**\r\n     * An image was deemed trackable, and the system will start tracking it.\r\n     */\r\n    public onTrackableImageFoundObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n    /**\r\n     * The image was found and its state was updated.\r\n     */\r\n    public onTrackedImageUpdatedObservable: Observable<IWebXRTrackedImage> = new Observable();\r\n\r\n    private _trackableScoreStatus: ImageTrackingScoreStatus = ImageTrackingScoreStatus.NotReceived;\r\n    private _trackedImages: IWebXRTrackedImage[] = [];\r\n\r\n    private _originalTrackingRequest: XRTrackedImageInit[];\r\n\r\n    /**\r\n     * constructs the image tracking feature\r\n     * @param _xrSessionManager the session manager for this module\r\n     * @param options read-only options to be used in this module\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * read-only options to be used in this module\r\n         */\r\n        public readonly options: IWebXRImageTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"image-tracking\";\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        return super.attach();\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        return super.detach();\r\n    }\r\n\r\n    /**\r\n     * Get a tracked image by its ID.\r\n     *\r\n     * @param id the id of the image to load (position in the init array)\r\n     * @returns a trackable image, if exists in this location\r\n     */\r\n    public getTrackedImageById(id: number): Nullable<IWebXRTrackedImage> {\r\n        return this._trackedImages[id] || null;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this._trackedImages.forEach((trackedImage) => {\r\n            trackedImage.originalBitmap.close();\r\n        });\r\n        this._trackedImages.length = 0;\r\n        this.onTrackableImageFoundObservable.clear();\r\n        this.onUntrackableImageFoundObservable.clear();\r\n        this.onTrackedImageUpdatedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Extends the session init object if needed\r\n     * @returns augmentation object fo the xr session init object.\r\n     */\r\n    public async getXRSessionInitExtension(): Promise<Partial<XRSessionInit>> {\r\n        if (!this.options.images || !this.options.images.length) {\r\n            return {};\r\n        }\r\n        const promises = this.options.images.map((image) => {\r\n            if (typeof image.src === \"string\") {\r\n                return this._xrSessionManager.scene.getEngine()._createImageBitmapFromSource(image.src);\r\n            } else {\r\n                return Promise.resolve(image.src); // resolve is probably unneeded\r\n            }\r\n        });\r\n\r\n        try {\r\n            const images = await Promise.all(promises);\r\n\r\n            this._originalTrackingRequest = images.map((image, idx) => {\r\n                return {\r\n                    image,\r\n                    widthInMeters: this.options.images[idx].estimatedRealWorldWidth,\r\n                };\r\n            });\r\n\r\n            return {\r\n                trackedImages: this._originalTrackingRequest,\r\n            };\r\n        } catch (ex) {\r\n            Tools.Error(\"Error loading images for tracking, WebXRImageTracking disabled for this session.\");\r\n            return {};\r\n        }\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame) {\r\n        if (!_xrFrame.getImageTrackingResults || this._trackableScoreStatus === ImageTrackingScoreStatus.Waiting) {\r\n            return;\r\n        }\r\n\r\n        // Image tracking scores may be generated a few frames after the XR Session initializes.\r\n        // If we haven't received scores yet, then kick off the task to check scores and return immediately.\r\n        if (this._trackableScoreStatus === ImageTrackingScoreStatus.NotReceived) {\r\n            this._checkScoresAsync();\r\n            return;\r\n        }\r\n\r\n        const imageTrackedResults = _xrFrame.getImageTrackingResults();\r\n        for (const result of imageTrackedResults) {\r\n            let changed = false;\r\n            const imageIndex = result.index;\r\n\r\n            const imageObject = this._trackedImages[imageIndex];\r\n            if (!imageObject) {\r\n                // something went wrong!\r\n                continue;\r\n            }\r\n\r\n            imageObject.xrTrackingResult = result;\r\n            if (imageObject.realWorldWidth !== result.measuredWidthInMeters) {\r\n                imageObject.realWorldWidth = result.measuredWidthInMeters;\r\n                changed = true;\r\n            }\r\n\r\n            // Get the pose of the image relative to a reference space.\r\n            const pose = _xrFrame.getPose(result.imageSpace, this._xrSessionManager.referenceSpace);\r\n\r\n            if (pose) {\r\n                const mat = imageObject.transformationMatrix;\r\n                Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n                if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                    mat.toggleModelMatrixHandInPlace();\r\n                }\r\n                changed = true;\r\n            }\r\n\r\n            const state = result.trackingState;\r\n            const emulated = state === \"emulated\";\r\n\r\n            if (imageObject.emulated !== emulated) {\r\n                imageObject.emulated = emulated;\r\n                changed = true;\r\n            }\r\n            if (changed) {\r\n                this.onTrackedImageUpdatedObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _checkScoresAsync(): Promise<void> {\r\n        if (!this._xrSessionManager.session.getTrackedImageScores || this._trackableScoreStatus !== ImageTrackingScoreStatus.NotReceived) {\r\n            return;\r\n        }\r\n\r\n        this._trackableScoreStatus = ImageTrackingScoreStatus.Waiting;\r\n        const imageScores = await this._xrSessionManager.session.getTrackedImageScores();\r\n        if (!imageScores || imageScores.length === 0) {\r\n            this._trackableScoreStatus = ImageTrackingScoreStatus.NotReceived;\r\n            return;\r\n        }\r\n\r\n        // check the scores for all\r\n        for (let idx = 0; idx < imageScores.length; ++idx) {\r\n            if (imageScores[idx] == \"untrackable\") {\r\n                this.onUntrackableImageFoundObservable.notifyObservers(idx);\r\n            } else {\r\n                const originalBitmap = this._originalTrackingRequest[idx].image;\r\n                const imageObject: IWebXRTrackedImage = {\r\n                    id: idx,\r\n                    originalBitmap,\r\n                    transformationMatrix: new Matrix(),\r\n                    ratio: originalBitmap.width / originalBitmap.height,\r\n                };\r\n                this._trackedImages[idx] = imageObject;\r\n                this.onTrackableImageFoundObservable.notifyObservers(imageObject);\r\n            }\r\n        }\r\n\r\n        this._trackableScoreStatus = imageScores.length > 0 ? ImageTrackingScoreStatus.Received : ImageTrackingScoreStatus.NotReceived;\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRImageTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRImageTracking(xrSessionManager, options);\r\n    },\r\n    WebXRImageTracking.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}