{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\n/**\n * Gizmo that enables rotating a mesh along 3 axis\n */\nexport class RotationGizmo extends Gizmo {\n  /**\n   * Creates a RotationGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param tessellation Amount of tessellation to be used when creating rotation circles\n   * @param useEulerRotation Use and update Euler angle instead of quaternion\n   * @param thickness display gizmo axis thickness\n   * @param gizmoManager Gizmo manager\n   * @param options More options\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer, tessellation = 32, useEulerRotation = false, thickness = 1, gizmoManager, options) {\n    super(gizmoLayer);\n    /** Fires an event when any of it's sub gizmos are dragged */\n    this.onDragStartObservable = new Observable();\n    /** Fires an event when any of it's sub gizmos are released from dragging */\n    this.onDragEndObservable = new Observable();\n    this._observables = [];\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\n    const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\n    const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\n    this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n    this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n    this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\n    // Relay drag events and set update scale\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\n      //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\n      if (options && options.updateScale != undefined) {\n        gizmo.updateScale = options.updateScale;\n      }\n      gizmo.dragBehavior.onDragStartObservable.add(() => {\n        this.onDragStartObservable.notifyObservers({});\n      });\n      gizmo.dragBehavior.onDragEndObservable.add(() => {\n        this.onDragEndObservable.notifyObservers({});\n      });\n    });\n    this.attachedMesh = null;\n    this.attachedNode = null;\n    if (gizmoManager) {\n      gizmoManager.addToAxisCache(this._gizmoAxisCache);\n    } else {\n      // Only subscribe to pointer event if gizmoManager isnt\n      Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\n    }\n  }\n  get attachedMesh() {\n    return this._meshAttached;\n  }\n  set attachedMesh(mesh) {\n    this._meshAttached = mesh;\n    this._nodeAttached = mesh;\n    this._checkBillboardTransform();\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedMesh = mesh;\n      } else {\n        gizmo.attachedMesh = null;\n      }\n    });\n  }\n  get attachedNode() {\n    return this._nodeAttached;\n  }\n  set attachedNode(node) {\n    this._meshAttached = null;\n    this._nodeAttached = node;\n    this._checkBillboardTransform();\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      if (gizmo.isEnabled) {\n        gizmo.attachedNode = node;\n      } else {\n        gizmo.attachedNode = null;\n      }\n    });\n  }\n  _checkBillboardTransform() {\n    if (this._nodeAttached && this._nodeAttached.billboardMode) {\n      console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\n    }\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    let hovered = false;\n    [this.xGizmo, this.yGizmo, this.zGizmo].forEach(gizmo => {\n      hovered = hovered || gizmo.isHovered;\n    });\n    return hovered;\n  }\n  /**\n   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n   */\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n      this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\n    }\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\n  }\n  set updateGizmoPositionToMatchAttachedMesh(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n      this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n      this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;\n    }\n  }\n  get updateGizmoPositionToMatchAttachedMesh() {\n    return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;\n  }\n  set updateScale(value) {\n    if (this.xGizmo) {\n      this.xGizmo.updateScale = value;\n      this.yGizmo.updateScale = value;\n      this.zGizmo.updateScale = value;\n    }\n  }\n  get updateScale() {\n    return this.xGizmo.updateScale;\n  }\n  /**\n   * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\n   */\n  set snapDistance(value) {\n    if (this.xGizmo) {\n      this.xGizmo.snapDistance = value;\n      this.yGizmo.snapDistance = value;\n      this.zGizmo.snapDistance = value;\n    }\n  }\n  get snapDistance() {\n    return this.xGizmo.snapDistance;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    if (this.xGizmo) {\n      this.xGizmo.scaleRatio = value;\n      this.yGizmo.scaleRatio = value;\n      this.zGizmo.scaleRatio = value;\n    }\n  }\n  get scaleRatio() {\n    return this.xGizmo.scaleRatio;\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param mesh Axis gizmo mesh\n   * @param cache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(mesh, cache) {\n    this._gizmoAxisCache.set(mesh, cache);\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this.xGizmo.dispose();\n    this.yGizmo.dispose();\n    this.zGizmo.dispose();\n    this.onDragStartObservable.clear();\n    this.onDragEndObservable.clear();\n    this._observables.forEach(obs => {\n      this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\n    });\n  }\n  /**\n   * CustomMeshes are not supported by this gizmo\n   */\n  setCustomMesh() {\n    Logger.Error(\"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\");\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","Observable","Vector3","Color3","Gizmo","PlaneRotationGizmo","UtilityLayerRenderer","RotationGizmo","constructor","gizmoLayer","DefaultUtilityLayer","tessellation","useEulerRotation","thickness","gizmoManager","options","Map","xColor","xOptions","color","Red","scale","yColor","yOptions","Green","zColor","zOptions","Blue","xGizmo","yGizmo","zGizmo","forEach","gizmo","updateScale","undefined","dragBehavior","onDragStartObservable","add","notifyObservers","onDragEndObservable","attachedMesh","attachedNode","addToAxisCache","_gizmoAxisCache","GizmoAxisPointerObserver","_meshAttached","mesh","_nodeAttached","_checkBillboardTransform","isEnabled","node","billboardMode","console","log","isHovered","hovered","updateGizmoRotationToMatchAttachedMesh","value","updateGizmoPositionToMatchAttachedMesh","snapDistance","scaleRatio","cache","set","dispose","clear","_observables","obs","utilityLayerScene","onPointerObservable","remove","setCustomMesh","Error"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/rotationGizmo.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { GizmoAxisCache, IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport type { IPlaneRotationGizmo } from \"./planeRotationGizmo\";\r\nimport { PlaneRotationGizmo } from \"./planeRotationGizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { Node } from \"../node\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { GizmoManager } from \"./gizmoManager\";\r\n\r\n/**\r\n * Interface for rotation gizmo\r\n */\r\nexport interface IRotationGizmo extends IGizmo {\r\n    /** Internal gizmo used for interactions on the x axis */\r\n    xGizmo: IPlaneRotationGizmo;\r\n    /** Internal gizmo used for interactions on the y axis */\r\n    yGizmo: IPlaneRotationGizmo;\r\n    /** Internal gizmo used for interactions on the z axis */\r\n    zGizmo: IPlaneRotationGizmo;\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    onDragStartObservable: Observable<unknown>;\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    onDragEndObservable: Observable<unknown>;\r\n    /** Drag distance in babylon units that the gizmo will snap to when dragged */\r\n    snapDistance: number;\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    addToAxisCache(mesh: Mesh, cache: GizmoAxisCache): void;\r\n}\r\n\r\n/**\r\n * Options for each individual plane rotation gizmo contained within RotationGizmo\r\n * @since 5.0.0\r\n */\r\nexport interface PlaneRotationGizmoOptions {\r\n    /**\r\n     * Color to use for the plane rotation gizmo\r\n     */\r\n    color?: Color3;\r\n}\r\n\r\n/**\r\n * Additional options for each rotation gizmo\r\n */\r\nexport interface RotationGizmoOptions {\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale?: boolean;\r\n\r\n    /**\r\n     * Specific options for xGizmo\r\n     */\r\n    xOptions?: PlaneRotationGizmoOptions;\r\n\r\n    /**\r\n     * Specific options for yGizmo\r\n     */\r\n    yOptions?: PlaneRotationGizmoOptions;\r\n\r\n    /**\r\n     * Specific options for zGizmo\r\n     */\r\n    zOptions?: PlaneRotationGizmoOptions;\r\n}\r\n\r\n/**\r\n * Gizmo that enables rotating a mesh along 3 axis\r\n */\r\nexport class RotationGizmo extends Gizmo implements IRotationGizmo {\r\n    /**\r\n     * Internal gizmo used for interactions on the x axis\r\n     */\r\n    public xGizmo: IPlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the y axis\r\n     */\r\n    public yGizmo: IPlaneRotationGizmo;\r\n    /**\r\n     * Internal gizmo used for interactions on the z axis\r\n     */\r\n    public zGizmo: IPlaneRotationGizmo;\r\n\r\n    /** Fires an event when any of it's sub gizmos are dragged */\r\n    public onDragStartObservable = new Observable();\r\n    /** Fires an event when any of it's sub gizmos are released from dragging */\r\n    public onDragEndObservable = new Observable();\r\n\r\n    protected _meshAttached: Nullable<AbstractMesh>;\r\n    protected _nodeAttached: Nullable<Node>;\r\n    protected _observables: Observer<PointerInfo>[] = [];\r\n\r\n    /** Node Caching for quick lookup */\r\n    protected _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n\r\n    public get attachedMesh() {\r\n        return this._meshAttached;\r\n    }\r\n    public set attachedMesh(mesh: Nullable<AbstractMesh>) {\r\n        this._meshAttached = mesh;\r\n        this._nodeAttached = mesh;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedMesh = mesh;\r\n            } else {\r\n                gizmo.attachedMesh = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    public get attachedNode() {\r\n        return this._nodeAttached;\r\n    }\r\n    public set attachedNode(node: Nullable<Node>) {\r\n        this._meshAttached = null;\r\n        this._nodeAttached = node;\r\n        this._checkBillboardTransform();\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            if (gizmo.isEnabled) {\r\n                gizmo.attachedNode = node;\r\n            } else {\r\n                gizmo.attachedNode = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _checkBillboardTransform() {\r\n        if (this._nodeAttached && (<TransformNode>this._nodeAttached).billboardMode) {\r\n            console.log(\"Rotation Gizmo will not work with transforms in billboard mode.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            hovered = hovered || gizmo.isHovered;\r\n        });\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Creates a RotationGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param tessellation Amount of tessellation to be used when creating rotation circles\r\n     * @param useEulerRotation Use and update Euler angle instead of quaternion\r\n     * @param thickness display gizmo axis thickness\r\n     * @param gizmoManager Gizmo manager\r\n     * @param options More options\r\n     */\r\n    constructor(\r\n        gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        tessellation = 32,\r\n        useEulerRotation = false,\r\n        thickness: number = 1,\r\n        gizmoManager?: GizmoManager,\r\n        options?: RotationGizmoOptions\r\n    ) {\r\n        super(gizmoLayer);\r\n        const xColor = options && options.xOptions && options.xOptions.color ? options.xOptions.color : Color3.Red().scale(0.5);\r\n        const yColor = options && options.yOptions && options.yOptions.color ? options.yOptions.color : Color3.Green().scale(0.5);\r\n        const zColor = options && options.zOptions && options.zOptions.color ? options.zOptions.color : Color3.Blue().scale(0.5);\r\n        this.xGizmo = new PlaneRotationGizmo(new Vector3(1, 0, 0), xColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.yGizmo = new PlaneRotationGizmo(new Vector3(0, 1, 0), yColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        this.zGizmo = new PlaneRotationGizmo(new Vector3(0, 0, 1), zColor, gizmoLayer, tessellation, this, useEulerRotation, thickness);\r\n        // Relay drag events and set update scale\r\n        [this.xGizmo, this.yGizmo, this.zGizmo].forEach((gizmo) => {\r\n            //must set updateScale on each gizmo, as setting it on root RotationGizmo doesnt prevent individual gizmos from updating\r\n            //currently updateScale is a property with no getter/setter, so no good way to override behavior at runtime, so we will at least set it on startup\r\n            if (options && options.updateScale != undefined) {\r\n                gizmo.updateScale = options.updateScale;\r\n            }\r\n            gizmo.dragBehavior.onDragStartObservable.add(() => {\r\n                this.onDragStartObservable.notifyObservers({});\r\n            });\r\n            gizmo.dragBehavior.onDragEndObservable.add(() => {\r\n                this.onDragEndObservable.notifyObservers({});\r\n            });\r\n        });\r\n\r\n        this.attachedMesh = null;\r\n        this.attachedNode = null;\r\n\r\n        if (gizmoManager) {\r\n            gizmoManager.addToAxisCache(this._gizmoAxisCache);\r\n        } else {\r\n            // Only subscribe to pointer event if gizmoManager isnt\r\n            Gizmo.GizmoAxisPointerObserver(gizmoLayer, this._gizmoAxisCache);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.yGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n            this.zGizmo.updateGizmoRotationToMatchAttachedMesh = value;\r\n        }\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this.xGizmo.updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n            this.yGizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n            this.zGizmo.updateGizmoPositionToMatchAttachedMesh = value;\r\n        }\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this.xGizmo.updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n\r\n    public set updateScale(value: boolean) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.updateScale = value;\r\n            this.yGizmo.updateScale = value;\r\n            this.zGizmo.updateScale = value;\r\n        }\r\n    }\r\n    public get updateScale() {\r\n        return this.xGizmo.updateScale;\r\n    }\r\n    /**\r\n     * Drag distance in babylon units that the gizmo will snap to when dragged (Default: 0)\r\n     */\r\n    public set snapDistance(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.snapDistance = value;\r\n            this.yGizmo.snapDistance = value;\r\n            this.zGizmo.snapDistance = value;\r\n        }\r\n    }\r\n    public get snapDistance() {\r\n        return this.xGizmo.snapDistance;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        if (this.xGizmo) {\r\n            this.xGizmo.scaleRatio = value;\r\n            this.yGizmo.scaleRatio = value;\r\n            this.zGizmo.scaleRatio = value;\r\n        }\r\n    }\r\n    public get scaleRatio() {\r\n        return this.xGizmo.scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param mesh Axis gizmo mesh\r\n     * @param cache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(mesh: Mesh, cache: GizmoAxisCache) {\r\n        this._gizmoAxisCache.set(mesh, cache);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this.xGizmo.dispose();\r\n        this.yGizmo.dispose();\r\n        this.zGizmo.dispose();\r\n        this.onDragStartObservable.clear();\r\n        this.onDragEndObservable.clear();\r\n        this._observables.forEach((obs) => {\r\n            this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(obs);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * CustomMeshes are not supported by this gizmo\r\n     */\r\n    public setCustomMesh() {\r\n        Logger.Error(\r\n            \"Custom meshes are not supported on this gizmo, please set the custom meshes on the gizmos contained within this one (gizmo.xGizmo, gizmo.yGizmo, gizmo.zGizmo)\"\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}