{"ast":null,"code":"import { Camera } from \"../../Cameras/camera.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { Scene } from \"../../scene.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { UniformBuffer } from \"../../Materials/uniformBuffer.js\";\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget.js\";\nimport { Frustum } from \"../../Maths/math.frustum.js\";\nEngine.prototype.createMultiviewRenderTargetTexture = function (width, height) {\n  const gl = this._gl;\n  if (!this.getCaps().multiview) {\n    throw \"Multiview is not supported\";\n  }\n  const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, {\n    width,\n    height\n  });\n  rtWrapper._framebuffer = gl.createFramebuffer();\n  const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n  internalTexture.width = width;\n  internalTexture.height = height;\n  internalTexture.isMultiview = true;\n  rtWrapper._colorTextureArray = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._colorTextureArray);\n  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\n  rtWrapper._depthStencilTextureArray = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._depthStencilTextureArray);\n  gl.texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.DEPTH24_STENCIL8, width, height, 2);\n  internalTexture.isReady = true;\n  rtWrapper.setTextures(internalTexture);\n  rtWrapper._depthStencilTexture = internalTexture;\n  return rtWrapper;\n};\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture) {\n  const multiviewTexture = _multiviewTexture;\n  const gl = this._gl;\n  const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\n  this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\n  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\n  if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\n    if (this.getCaps().oculusMultiview) {\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\n      ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, multiviewTexture.samples, 0, 2);\n    } else {\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\n      ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\n    }\n  } else {\n    throw \"Invalid multiview frame buffer\";\n  }\n};\nCamera.prototype._useMultiviewToSingleView = false;\nCamera.prototype._multiviewTexture = null;\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width, height) {\n  if (!this._multiviewTexture) {\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\n    this._multiviewTexture.dispose();\n    this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), {\n      width: width,\n      height: height\n    });\n  }\n};\nfunction createMultiviewUbo(engine, name) {\n  const ubo = new UniformBuffer(engine, undefined, true, name);\n  ubo.addUniform(\"viewProjection\", 16);\n  ubo.addUniform(\"viewProjectionR\", 16);\n  ubo.addUniform(\"view\", 16);\n  ubo.addUniform(\"projection\", 16);\n  ubo.addUniform(\"vEyePosition\", 4);\n  return ubo;\n}\nconst currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\nScene.prototype._transformMatrixR = Matrix.Zero();\nScene.prototype._multiviewSceneUbo = null;\nScene.prototype._createMultiviewUbo = function () {\n  this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\n};\nScene.prototype.createSceneUniformBuffer = function (name) {\n  if (this._multiviewSceneUbo) {\n    return createMultiviewUbo(this.getEngine(), name);\n  }\n  return currentCreateSceneUniformBuffer.bind(this)(name);\n};\nScene.prototype._updateMultiviewUbo = function (viewR, projectionR) {\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, this._transformMatrixR);\n  }\n  if (viewR && projectionR) {\n    viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\n    Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\n  }\n\n  if (this._multiviewSceneUbo) {\n    this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\n    this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\n    this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\n    this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n  }\n};\nScene.prototype._renderMultiviewToSingleView = function (camera) {\n  // Multiview is only able to be displayed directly for API's such as webXR\n  // This displays a multiview image by rendering to the multiview image and then\n  // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\n  // Render to a multiview texture\n  camera._resizeOrCreateMultiviewTexture(camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true), camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true));\n  if (!this._multiviewSceneUbo) {\n    this._createMultiviewUbo();\n  }\n  camera.outputRenderTarget = camera._multiviewTexture;\n  this._renderForCamera(camera);\n  camera.outputRenderTarget = null;\n  // Consume the multiview texture through a shader for each eye\n  for (let index = 0; index < camera._rigCameras.length; index++) {\n    const engine = this.getEngine();\n    this._activeCamera = camera._rigCameras[index];\n    engine.setViewport(this._activeCamera.viewport);\n    if (this.postProcessManager) {\n      this.postProcessManager._prepareFrame();\n      this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\n    }\n  }\n};","map":{"version":3,"mappings":"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","names":["Camera","Engine","Scene","InternalTexture","InternalTextureSource","Matrix","TmpVectors","UniformBuffer","MultiviewRenderTarget","Frustum","prototype","createMultiviewRenderTargetTexture","width","height","gl","_gl","getCaps","multiview","rtWrapper","_createHardwareRenderTargetWrapper","_framebuffer","createFramebuffer","internalTexture","Unknown","isMultiview","_colorTextureArray","createTexture","bindTexture","TEXTURE_2D_ARRAY","texStorage3D","RGBA8","_depthStencilTextureArray","DEPTH24_STENCIL8","isReady","setTextures","_depthStencilTexture","bindMultiviewFramebuffer","_multiviewTexture","multiviewTexture","ext","oculusMultiview","bindFramebuffer","undefined","DRAW_FRAMEBUFFER","framebufferTextureMultisampleMultiviewOVR","COLOR_ATTACHMENT0","samples","DEPTH_STENCIL_ATTACHMENT","framebufferTextureMultiviewOVR","_useMultiviewToSingleView","_resizeOrCreateMultiviewTexture","getScene","getRenderWidth","getRenderHeight","dispose","createMultiviewUbo","engine","name","ubo","addUniform","currentCreateSceneUniformBuffer","createSceneUniformBuffer","_transformMatrixR","Zero","_multiviewSceneUbo","_createMultiviewUbo","getEngine","bind","_updateMultiviewUbo","viewR","projectionR","multiplyToRef","GetRightPlaneToRef","_frustumPlanes","updateMatrix","getTransformMatrix","_viewMatrix","_projectionMatrix","_renderMultiviewToSingleView","camera","_rigPostProcess","outputRenderTarget","_renderForCamera","index","_rigCameras","length","_activeCamera","setViewport","viewport","postProcessManager","_prepareFrame","_finalizeFrame","isIntermediate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.multiview.ts"],"sourcesContent":["import { Camera } from \"../../Cameras/camera\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { Scene } from \"../../scene\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MultiviewRenderTarget } from \"../../Materials/Textures/MultiviewRenderTarget\";\r\nimport { Frustum } from \"../../Maths/math.frustum\";\r\nimport type { WebGLRenderTargetWrapper } from \"../WebGL/webGLRenderTargetWrapper\";\r\nimport type { RenderTargetWrapper } from \"../renderTargetWrapper\";\r\n\r\ndeclare module \"../../Engines/engine\" {\r\n    export interface Engine {\r\n        /**\r\n         * Creates a new multiview render target\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @returns the created multiview render target wrapper\r\n         */\r\n        createMultiviewRenderTargetTexture(width: number, height: number): RenderTargetWrapper;\r\n\r\n        /**\r\n         * Binds a multiview render target wrapper to be drawn to\r\n         * @param multiviewTexture render target wrapper to bind\r\n         */\r\n        bindMultiviewFramebuffer(multiviewTexture: RenderTargetWrapper): void;\r\n    }\r\n}\r\n\r\nEngine.prototype.createMultiviewRenderTargetTexture = function (width: number, height: number) {\r\n    const gl = this._gl;\r\n\r\n    if (!this.getCaps().multiview) {\r\n        throw \"Multiview is not supported\";\r\n    }\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, { width, height }) as WebGLRenderTargetWrapper;\r\n\r\n    rtWrapper._framebuffer = gl.createFramebuffer();\r\n\r\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n    internalTexture.width = width;\r\n    internalTexture.height = height;\r\n    internalTexture.isMultiview = true;\r\n\r\n    rtWrapper._colorTextureArray = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._colorTextureArray);\r\n    (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, gl.RGBA8, width, height, 2);\r\n\r\n    rtWrapper._depthStencilTextureArray = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D_ARRAY, rtWrapper._depthStencilTextureArray);\r\n    (gl as any).texStorage3D(gl.TEXTURE_2D_ARRAY, 1, (gl as any).DEPTH24_STENCIL8, width, height, 2);\r\n\r\n    internalTexture.isReady = true;\r\n\r\n    rtWrapper.setTextures(internalTexture);\r\n    rtWrapper._depthStencilTexture = internalTexture;\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nEngine.prototype.bindMultiviewFramebuffer = function (_multiviewTexture: RenderTargetWrapper) {\r\n    const multiviewTexture = _multiviewTexture as WebGLRenderTargetWrapper;\r\n\r\n    const gl: any = this._gl;\r\n    const ext = this.getCaps().oculusMultiview || this.getCaps().multiview;\r\n\r\n    this.bindFramebuffer(multiviewTexture, undefined, undefined, undefined, true);\r\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, multiviewTexture._framebuffer);\r\n    if (multiviewTexture._colorTextureArray && multiviewTexture._depthStencilTextureArray) {\r\n        if (this.getCaps().oculusMultiview) {\r\n            ext.framebufferTextureMultisampleMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, multiviewTexture.samples, 0, 2);\r\n            ext.framebufferTextureMultisampleMultiviewOVR(\r\n                gl.DRAW_FRAMEBUFFER,\r\n                gl.DEPTH_STENCIL_ATTACHMENT,\r\n                multiviewTexture._depthStencilTextureArray,\r\n                0,\r\n                multiviewTexture.samples,\r\n                0,\r\n                2\r\n            );\r\n        } else {\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, multiviewTexture._colorTextureArray, 0, 0, 2);\r\n            ext.framebufferTextureMultiviewOVR(gl.DRAW_FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, multiviewTexture._depthStencilTextureArray, 0, 0, 2);\r\n        }\r\n    } else {\r\n        throw \"Invalid multiview frame buffer\";\r\n    }\r\n};\r\n\r\ndeclare module \"../../Cameras/camera\" {\r\n    export interface Camera {\r\n        /**\r\n         * @internal\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _useMultiviewToSingleView: boolean;\r\n        /**\r\n         * @internal\r\n         * For cameras that cannot use multiview images to display directly. (e.g. webVR camera will render to multiview texture, then copy to each eye texture and go from there)\r\n         */\r\n        _multiviewTexture: Nullable<RenderTargetTexture>;\r\n\r\n        /**\r\n         * @internal\r\n         * For WebXR cameras that are rendering to multiview texture arrays.\r\n         */\r\n        _renderingMultiview: boolean;\r\n\r\n        /**\r\n         * @internal\r\n         * ensures the multiview texture of the camera exists and has the specified width/height\r\n         * @param width height to set on the multiview texture\r\n         * @param height width to set on the multiview texture\r\n         */\r\n        _resizeOrCreateMultiviewTexture(width: number, height: number): void;\r\n    }\r\n}\r\n\r\nCamera.prototype._useMultiviewToSingleView = false;\r\n\r\nCamera.prototype._multiviewTexture = null;\r\n\r\nCamera.prototype._resizeOrCreateMultiviewTexture = function (width: number, height: number) {\r\n    if (!this._multiviewTexture) {\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    } else if (this._multiviewTexture.getRenderWidth() != width || this._multiviewTexture.getRenderHeight() != height) {\r\n        this._multiviewTexture.dispose();\r\n        this._multiviewTexture = new MultiviewRenderTarget(this.getScene(), { width: width, height: height });\r\n    }\r\n};\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _transformMatrixR: Matrix;\r\n        /** @internal */\r\n        _multiviewSceneUbo: Nullable<UniformBuffer>;\r\n        /** @internal */\r\n        _createMultiviewUbo(): void;\r\n        /** @internal */\r\n        _updateMultiviewUbo(viewR?: Matrix, projectionR?: Matrix): void;\r\n        /** @internal */\r\n        _renderMultiviewToSingleView(camera: Camera): void;\r\n    }\r\n}\r\n\r\nfunction createMultiviewUbo(engine: Engine, name?: string) {\r\n    const ubo = new UniformBuffer(engine, undefined, true, name);\r\n    ubo.addUniform(\"viewProjection\", 16);\r\n    ubo.addUniform(\"viewProjectionR\", 16);\r\n    ubo.addUniform(\"view\", 16);\r\n    ubo.addUniform(\"projection\", 16);\r\n    ubo.addUniform(\"vEyePosition\", 4);\r\n    return ubo;\r\n}\r\n\r\nconst currentCreateSceneUniformBuffer = Scene.prototype.createSceneUniformBuffer;\r\n\r\nScene.prototype._transformMatrixR = Matrix.Zero();\r\nScene.prototype._multiviewSceneUbo = null;\r\nScene.prototype._createMultiviewUbo = function () {\r\n    this._multiviewSceneUbo = createMultiviewUbo(this.getEngine(), \"scene_multiview\");\r\n};\r\nScene.prototype.createSceneUniformBuffer = function (name?: string): UniformBuffer {\r\n    if (this._multiviewSceneUbo) {\r\n        return createMultiviewUbo(this.getEngine(), name);\r\n    }\r\n    return currentCreateSceneUniformBuffer.bind(this)(name);\r\n};\r\nScene.prototype._updateMultiviewUbo = function (viewR?: Matrix, projectionR?: Matrix) {\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, this._transformMatrixR);\r\n    }\r\n\r\n    if (viewR && projectionR) {\r\n        viewR.multiplyToRef(projectionR, TmpVectors.Matrix[0]);\r\n        Frustum.GetRightPlaneToRef(TmpVectors.Matrix[0], this._frustumPlanes[3]); // Replace right plane by second camera right plane\r\n    }\r\n\r\n    if (this._multiviewSceneUbo) {\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjection\", this.getTransformMatrix());\r\n        this._multiviewSceneUbo.updateMatrix(\"viewProjectionR\", this._transformMatrixR);\r\n        this._multiviewSceneUbo.updateMatrix(\"view\", this._viewMatrix);\r\n        this._multiviewSceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\r\n    }\r\n};\r\nScene.prototype._renderMultiviewToSingleView = function (camera: Camera) {\r\n    // Multiview is only able to be displayed directly for API's such as webXR\r\n    // This displays a multiview image by rendering to the multiview image and then\r\n    // copying the result into the sub cameras instead of rendering them and proceeding as normal from there\r\n\r\n    // Render to a multiview texture\r\n    camera._resizeOrCreateMultiviewTexture(\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.width > 0 ? camera._rigPostProcess.width : this.getEngine().getRenderWidth(true),\r\n        camera._rigPostProcess && camera._rigPostProcess && camera._rigPostProcess.height > 0 ? camera._rigPostProcess.height : this.getEngine().getRenderHeight(true)\r\n    );\r\n    if (!this._multiviewSceneUbo) {\r\n        this._createMultiviewUbo();\r\n    }\r\n    camera.outputRenderTarget = camera._multiviewTexture;\r\n    this._renderForCamera(camera);\r\n    camera.outputRenderTarget = null;\r\n\r\n    // Consume the multiview texture through a shader for each eye\r\n    for (let index = 0; index < camera._rigCameras.length; index++) {\r\n        const engine = this.getEngine();\r\n        this._activeCamera = camera._rigCameras[index];\r\n        engine.setViewport(this._activeCamera.viewport);\r\n        if (this.postProcessManager) {\r\n            this.postProcessManager._prepareFrame();\r\n            this.postProcessManager._finalizeFrame(this._activeCamera.isIntermediate);\r\n        }\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}