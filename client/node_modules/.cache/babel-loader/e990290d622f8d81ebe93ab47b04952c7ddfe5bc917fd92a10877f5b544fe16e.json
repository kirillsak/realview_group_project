{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { DomManagement } from \"../Misc/domManagement.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { DeviceEventFactory } from \"./eventFactory.js\";\nimport { DeviceType, PointerInput } from \"./InputDevices/deviceEnums.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst MAX_KEYCODES = 255;\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\n/** @internal */\nexport class WebDeviceInputSystem {\n  constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {\n    // Private Members\n    this._inputs = [];\n    this._keyboardActive = false;\n    this._pointerActive = false;\n    this._usingSafari = Tools.IsSafari();\n    // Found solution for determining if MacOS is being used here:\n    // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery\n    this._usingMacOS = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardDownEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardUpEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._keyboardBlurEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerMoveEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerDownEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerUpEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerCancelEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerWheelEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._pointerBlurEvent = evt => {};\n    this._eventsAttached = false;\n    this._mouseId = -1;\n    this._isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\n    this._maxTouchPoints = 0;\n    this._pointerInputClearObserver = null;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._gamepadConnectedEvent = evt => {};\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    this._gamepadDisconnectedEvent = evt => {};\n    this._eventPrefix = Tools.GetPointerPrefix(engine);\n    this._engine = engine;\n    this._onDeviceConnected = onDeviceConnected;\n    this._onDeviceDisconnected = onDeviceDisconnected;\n    this._onInputChanged = onInputChanged;\n    this._enableEvents();\n    if (this._usingMacOS) {\n      this._metaKeys = [];\n    }\n    // Set callback to enable event handler switching when inputElement changes\n    if (!this._engine._onEngineViewChanged) {\n      this._engine._onEngineViewChanged = () => {\n        this._enableEvents();\n      };\n    }\n  }\n  // Public functions\n  /**\n   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   * @returns Current value of input\n   */\n  pollInput(deviceType, deviceSlot, inputIndex) {\n    const device = this._inputs[deviceType][deviceSlot];\n    if (!device) {\n      throw `Unable to find device ${DeviceType[deviceType]}`;\n    }\n    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {\n      this._updateDevice(deviceType, deviceSlot, inputIndex);\n    }\n    const currentValue = device[inputIndex];\n    if (currentValue === undefined) {\n      throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;\n    }\n    if (inputIndex === PointerInput.Move) {\n      Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);\n    }\n    return currentValue;\n  }\n  /**\n   * Check for a specific device in the DeviceInputSystem\n   * @param deviceType Type of device to check for\n   * @returns bool with status of device's existence\n   */\n  isDeviceAvailable(deviceType) {\n    return this._inputs[deviceType] !== undefined;\n  }\n  /**\n   * Dispose of all the eventlisteners\n   */\n  dispose() {\n    // Callbacks\n    this._onDeviceConnected = () => {};\n    this._onDeviceDisconnected = () => {};\n    this._onInputChanged = () => {};\n    delete this._engine._onEngineViewChanged;\n    if (this._elementToAttachTo) {\n      this._disableEvents();\n    }\n  }\n  /**\n   * Enable listening for user input events\n   */\n  _enableEvents() {\n    const inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();\n    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\n      // Remove events before adding to avoid double events or simultaneous events on multiple canvases\n      this._disableEvents();\n      // If the inputs array has already been created, zero it out to before setting up events\n      if (this._inputs) {\n        for (const inputs of this._inputs) {\n          if (inputs) {\n            for (const deviceSlotKey in inputs) {\n              const deviceSlot = +deviceSlotKey;\n              const device = inputs[deviceSlot];\n              if (device) {\n                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {\n                  device[inputIndex] = 0;\n                }\n              }\n            }\n          }\n        }\n      }\n      this._elementToAttachTo = inputElement;\n      // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\n      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\n      this._handleKeyActions();\n      this._handlePointerActions();\n      this._handleGamepadActions();\n      this._eventsAttached = true;\n      // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\n      this._checkForConnectedDevices();\n    }\n  }\n  /**\n   * Disable listening for user input events\n   */\n  _disableEvents() {\n    if (this._elementToAttachTo) {\n      // Blur Events\n      this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\n      this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent);\n      // Keyboard Events\n      this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\n      this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent);\n      // Pointer Events\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n      this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);\n      // Gamepad Events\n      window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n      window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n    }\n    if (this._pointerInputClearObserver) {\n      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\n    }\n    this._eventsAttached = false;\n  }\n  /**\n   * Checks for existing connections to devices and register them, if necessary\n   * Currently handles gamepads and mouse\n   */\n  _checkForConnectedDevices() {\n    if (navigator.getGamepads) {\n      const gamepads = navigator.getGamepads();\n      for (const gamepad of gamepads) {\n        if (gamepad) {\n          this._addGamePad(gamepad);\n        }\n      }\n    }\n    // If the device in use has mouse capabilities, pre-register mouse\n    if (typeof matchMedia === \"function\" && matchMedia(\"(pointer:fine)\").matches) {\n      // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\n      // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\n      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\n    }\n  }\n  // Private functions\n  /**\n   * Add a gamepad to the DeviceInputSystem\n   * @param gamepad A single DOM Gamepad object\n   */\n  _addGamePad(gamepad) {\n    const deviceType = this._getGamepadDeviceType(gamepad.id);\n    const deviceSlot = gamepad.index;\n    this._gamepads = this._gamepads || new Array(gamepad.index + 1);\n    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\n    this._gamepads[deviceSlot] = deviceType;\n  }\n  /**\n   * Add pointer device to DeviceInputSystem\n   * @param deviceType Type of Pointer to add\n   * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\n   * @param currentX Current X at point of adding\n   * @param currentY Current Y at point of adding\n   */\n  _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {\n    if (!this._pointerActive) {\n      this._pointerActive = true;\n    }\n    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n    const pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */\n    pointer[0] = currentX;\n    pointer[1] = currentY;\n  }\n  /**\n   * Add device and inputs to device array\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param numberOfInputs Number of input entries to create for given device\n   */\n  _registerDevice(deviceType, deviceSlot, numberOfInputs) {\n    if (deviceSlot === undefined) {\n      throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;\n    }\n    if (!this._inputs[deviceType]) {\n      this._inputs[deviceType] = {};\n    }\n    if (!this._inputs[deviceType][deviceSlot]) {\n      const device = new Array(numberOfInputs);\n      device.fill(0);\n      this._inputs[deviceType][deviceSlot] = device;\n      this._onDeviceConnected(deviceType, deviceSlot);\n    }\n  }\n  /**\n   * Given a specific device name, remove that device from the device map\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   */\n  _unregisterDevice(deviceType, deviceSlot) {\n    if (this._inputs[deviceType][deviceSlot]) {\n      delete this._inputs[deviceType][deviceSlot];\n      this._onDeviceDisconnected(deviceType, deviceSlot);\n    }\n  }\n  /**\n   * Handle all actions that come from keyboard interaction\n   */\n  _handleKeyActions() {\n    this._keyboardDownEvent = evt => {\n      if (!this._keyboardActive) {\n        this._keyboardActive = true;\n        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n      const kbKey = this._inputs[DeviceType.Keyboard][0];\n      if (kbKey) {\n        kbKey[evt.keyCode] = 1;\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n        if (this._usingMacOS && evt.metaKey && evt.key !== \"Meta\") {\n          if (!this._metaKeys.includes(evt.keyCode)) {\n            this._metaKeys.push(evt.keyCode);\n          }\n        }\n        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n    this._keyboardUpEvent = evt => {\n      if (!this._keyboardActive) {\n        this._keyboardActive = true;\n        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\n      }\n      const kbKey = this._inputs[DeviceType.Keyboard][0];\n      if (kbKey) {\n        kbKey[evt.keyCode] = 0;\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = evt.keyCode;\n        if (this._usingMacOS && evt.key === \"Meta\" && this._metaKeys.length > 0) {\n          for (const keyCode of this._metaKeys) {\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);\n            kbKey[keyCode] = 0;\n            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n          this._metaKeys.splice(0, this._metaKeys.length);\n        }\n        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n      }\n    };\n    this._keyboardBlurEvent = () => {\n      if (this._keyboardActive) {\n        const kbKey = this._inputs[DeviceType.Keyboard][0];\n        for (let i = 0; i < kbKey.length; i++) {\n          if (kbKey[i] !== 0) {\n            kbKey[i] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\n          }\n        }\n        if (this._usingMacOS) {\n          this._metaKeys.splice(0, this._metaKeys.length);\n        }\n      }\n    };\n    this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\n    this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\n    this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\n  }\n  /**\n   * Handle all actions that come from pointer interaction\n   */\n  _handlePointerActions() {\n    // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\n    this._maxTouchPoints = DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints || 2;\n    if (!this._activeTouchIds) {\n      this._activeTouchIds = new Array(this._maxTouchPoints);\n    }\n    for (let i = 0; i < this._maxTouchPoints; i++) {\n      this._activeTouchIds[i] = -1;\n    }\n    this._pointerMoveEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = {};\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        const deviceEvent = evt;\n        deviceEvent.inputIndex = PointerInput.Move;\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        // Lets Propagate the event for move with same position.\n        if (!this._usingSafari && evt.button !== -1) {\n          deviceEvent.inputIndex = evt.button + 2;\n          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._pointerDownEvent = evt => {\n      const deviceType = this._getPointerType(evt);\n      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\n      if (deviceType === DeviceType.Touch) {\n        const idx = this._activeTouchIds.indexOf(-1);\n        if (idx >= 0) {\n          deviceSlot = idx;\n          this._activeTouchIds[idx] = evt.pointerId;\n        } else {\n          // We can't find an open slot to store new pointer so just return (can only support max number of touches)\n          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\n          return;\n        }\n      }\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = {};\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\n      } else if (deviceType === DeviceType.Touch) {\n        this._onDeviceConnected(deviceType, deviceSlot);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        const previousHorizontal = pointer[PointerInput.Horizontal];\n        const previousVertical = pointer[PointerInput.Vertical];\n        if (deviceType === DeviceType.Mouse) {\n          // Mouse; Among supported browsers, value is either 1 or 0 for mouse\n          if (this._mouseId === -1) {\n            if (evt.pointerId === undefined) {\n              // If there is no pointerId (eg. manually dispatched MouseEvent)\n              this._mouseId = this._isUsingFirefox ? 0 : 1;\n            } else {\n              this._mouseId = evt.pointerId;\n            }\n          }\n          if (!document.pointerLockElement) {\n            try {\n              this._elementToAttachTo.setPointerCapture(this._mouseId);\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n        } else {\n          // Touch; Since touches are dynamically assigned, only set capture if we have an id\n          if (evt.pointerId && !document.pointerLockElement) {\n            try {\n              this._elementToAttachTo.setPointerCapture(evt.pointerId);\n            } catch (e) {\n              // DO NOTHING\n            }\n          }\n        }\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 1;\n        const deviceEvent = evt;\n        // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n        deviceEvent.inputIndex = evt.button + 2;\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._pointerUpEvent = evt => {\n      var _a, _b, _c, _d, _e;\n      const deviceType = this._getPointerType(evt);\n      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\n      if (deviceType === DeviceType.Touch) {\n        if (deviceSlot === -1) {\n          return;\n        } else {\n          this._activeTouchIds[deviceSlot] = -1;\n        }\n      }\n      const pointer = (_a = this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];\n      if (pointer && pointer[evt.button + 2] !== 0) {\n        const previousHorizontal = pointer[PointerInput.Horizontal];\n        const previousVertical = pointer[PointerInput.Vertical];\n        pointer[PointerInput.Horizontal] = evt.clientX;\n        pointer[PointerInput.Vertical] = evt.clientY;\n        pointer[evt.button + 2] = 0;\n        const deviceEvent = evt;\n        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\n          deviceEvent.inputIndex = PointerInput.Move;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\n        // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\n        // EG. ([X, Y, Left-click], Middle-click, etc...)\n        deviceEvent.inputIndex = evt.button + 2;\n        if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && ((_c = (_b = this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, this._mouseId))) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        } else if (evt.pointerId && ((_e = (_d = this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {\n          this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n        this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        if (deviceType === DeviceType.Touch) {\n          this._onDeviceDisconnected(deviceType, deviceSlot);\n        }\n      }\n    };\n    this._pointerCancelEvent = evt => {\n      var _a, _b, _c, _d;\n      if (evt.pointerType === \"mouse\") {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        }\n        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      } else {\n        const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);\n        if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {\n          this._elementToAttachTo.releasePointerCapture(evt.pointerId);\n        }\n        this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\n        const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);\n        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n        this._activeTouchIds[deviceSlot] = -1;\n        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n      }\n    };\n    // Set Wheel Event Name, code originally from scene.inputManager\n    this._wheelEventName = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" // Modern browsers support \"wheel\"\n    : document.onmousewheel !== undefined ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\n    : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n    // Code originally in scene.inputManager.ts\n    // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\n    // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\n    // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\n    let passiveSupported = false;\n    const noop = function () {};\n    try {\n      const options = Object.defineProperty({}, \"passive\", {\n        get: function () {\n          passiveSupported = true;\n        }\n      });\n      this._elementToAttachTo.addEventListener(\"test\", noop, options);\n      this._elementToAttachTo.removeEventListener(\"test\", noop, options);\n    } catch (e) {\n      /* */\n    }\n    this._pointerBlurEvent = () => {\n      var _a, _b, _c, _d, _e;\n      // Handle mouse buttons\n      if (this.isDeviceAvailable(DeviceType.Mouse)) {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {\n          this._elementToAttachTo.releasePointerCapture(this._mouseId);\n        }\n        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\n          if (pointer[inputIndex] === 1) {\n            pointer[inputIndex] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\n          }\n        }\n      }\n      // Handle Active Touches\n      if (this.isDeviceAvailable(DeviceType.Touch)) {\n        const pointer = this._inputs[DeviceType.Touch];\n        for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {\n          const pointerId = this._activeTouchIds[deviceSlot];\n          if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {\n            this._elementToAttachTo.releasePointerCapture(pointerId);\n          }\n          if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {\n            pointer[deviceSlot][PointerInput.LeftClick] = 0;\n            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);\n            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\n            this._activeTouchIds[deviceSlot] = -1;\n            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\n          }\n        }\n      }\n    };\n    this._pointerWheelEvent = evt => {\n      const deviceType = DeviceType.Mouse;\n      const deviceSlot = 0;\n      if (!this._inputs[deviceType]) {\n        this._inputs[deviceType] = [];\n      }\n      if (!this._inputs[deviceType][deviceSlot]) {\n        this._pointerActive = true;\n        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\n      }\n      const pointer = this._inputs[deviceType][deviceSlot];\n      if (pointer) {\n        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\n        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\n        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\n        const deviceEvent = evt;\n        if (pointer[PointerInput.MouseWheelX] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelX;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        if (pointer[PointerInput.MouseWheelY] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelY;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n        if (pointer[PointerInput.MouseWheelZ] !== 0) {\n          deviceEvent.inputIndex = PointerInput.MouseWheelZ;\n          this._onInputChanged(deviceType, deviceSlot, deviceEvent);\n        }\n      }\n    };\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\n    this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\n    this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\n    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? {\n      passive: false\n    } : false);\n    // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\n    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {\n      if (this.isDeviceAvailable(DeviceType.Mouse)) {\n        const pointer = this._inputs[DeviceType.Mouse][0];\n        pointer[PointerInput.MouseWheelX] = 0;\n        pointer[PointerInput.MouseWheelY] = 0;\n        pointer[PointerInput.MouseWheelZ] = 0;\n      }\n    });\n  }\n  /**\n   * Handle all actions that come from gamepad interaction\n   */\n  _handleGamepadActions() {\n    this._gamepadConnectedEvent = evt => {\n      this._addGamePad(evt.gamepad);\n    };\n    this._gamepadDisconnectedEvent = evt => {\n      if (this._gamepads) {\n        const deviceType = this._getGamepadDeviceType(evt.gamepad.id);\n        const deviceSlot = evt.gamepad.index;\n        this._unregisterDevice(deviceType, deviceSlot);\n        delete this._gamepads[deviceSlot];\n      }\n    };\n    window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\n    window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\n  }\n  /**\n   * Update all non-event based devices with each frame\n   * @param deviceType Enum specifying device type\n   * @param deviceSlot \"Slot\" or index that device is referenced in\n   * @param inputIndex Id of input to be checked\n   */\n  _updateDevice(deviceType, deviceSlot, inputIndex) {\n    // Gamepads\n    const gp = navigator.getGamepads()[deviceSlot];\n    if (gp && deviceType === this._gamepads[deviceSlot]) {\n      const device = this._inputs[deviceType][deviceSlot];\n      if (inputIndex >= gp.buttons.length) {\n        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\n      } else {\n        device[inputIndex] = gp.buttons[inputIndex].value;\n      }\n    }\n  }\n  /**\n   * Gets DeviceType from the device name\n   * @param deviceName Name of Device from DeviceInputSystem\n   * @returns DeviceType enum value\n   */\n  _getGamepadDeviceType(deviceName) {\n    if (deviceName.indexOf(\"054c\") !== -1) {\n      // DualShock 4 Gamepad\n      return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\n    } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\n      // Xbox Gamepad\n      return DeviceType.Xbox;\n    } else if (deviceName.indexOf(\"057e\") !== -1) {\n      // Switch Gamepad\n      return DeviceType.Switch;\n    }\n    return DeviceType.Generic;\n  }\n  /**\n   * Get DeviceType from a given pointer/mouse/touch event.\n   * @param evt PointerEvent to evaluate\n   * @returns DeviceType interpreted from event\n   */\n  _getPointerType(evt) {\n    let deviceType = DeviceType.Mouse;\n    if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\n      deviceType = DeviceType.Touch;\n    }\n    return deviceType;\n  }\n}","map":{"version":3,"mappings":"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","names":["DomManagement","Tools","DeviceEventFactory","DeviceType","PointerInput","MAX_KEYCODES","MAX_POINTER_INPUTS","Object","keys","length","WebDeviceInputSystem","constructor","engine","onDeviceConnected","onDeviceDisconnected","onInputChanged","IsSafari","test","navigator","platform","evt","IsNavigatorAvailable","userAgent","indexOf","_eventPrefix","GetPointerPrefix","_engine","_onDeviceConnected","_onDeviceDisconnected","_onInputChanged","_enableEvents","_usingMacOS","_metaKeys","_onEngineViewChanged","pollInput","deviceType","deviceSlot","inputIndex","device","_inputs","DualShock","DualSense","_updateDevice","currentValue","undefined","Move","Warn","isDeviceAvailable","dispose","_elementToAttachTo","_disableEvents","inputElement","getInputElement","_eventsAttached","inputs","deviceSlotKey","tabIndex","canvasTabIndex","_handleKeyActions","_handlePointerActions","_handleGamepadActions","_checkForConnectedDevices","removeEventListener","_keyboardBlurEvent","_pointerBlurEvent","_keyboardDownEvent","_keyboardUpEvent","_pointerMoveEvent","_pointerDownEvent","_pointerUpEvent","_pointerCancelEvent","_wheelEventName","_pointerWheelEvent","window","_gamepadConnectedEvent","_gamepadDisconnectedEvent","_pointerInputClearObserver","onEndFrameObservable","remove","getGamepads","gamepads","gamepad","_addGamePad","matchMedia","matches","_addPointerDevice","Mouse","_getGamepadDeviceType","id","index","_gamepads","Array","_registerDevice","buttons","axes","currentX","currentY","_pointerActive","pointer","numberOfInputs","fill","_unregisterDevice","_keyboardActive","Keyboard","kbKey","keyCode","deviceEvent","metaKey","key","includes","push","CreateDeviceEvent","splice","i","addEventListener","_maxTouchPoints","maxTouchPoints","_activeTouchIds","_getPointerType","pointerId","clientX","clientY","Horizontal","Vertical","_usingSafari","button","Touch","idx","previousHorizontal","previousVertical","_mouseId","_isUsingFirefox","document","pointerLockElement","setPointerCapture","e","hasPointerCapture","releasePointerCapture","pointerType","LeftClick","BrowserForward","createElement","onmousewheel","passiveSupported","noop","options","defineProperty","get","MouseWheelX","deltaX","MouseWheelY","deltaY","wheelDelta","MouseWheelZ","deltaZ","passive","add","gp","valueOf","value","deviceName","search","Xbox","Switch","Generic","touches"],"sourceRoot":"","sources":["../../../../lts/core/generated/DeviceInput/webDeviceInputSystem.ts"],"sourcesContent":["import type { Engine } from \"../Engines/engine\";\r\nimport type { IPointerEvent, IUIEvent } from \"../Events/deviceInputEvents\";\r\nimport { DomManagement } from \"../Misc/domManagement\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport { DeviceEventFactory } from \"./eventFactory\";\r\nimport { DeviceType, PointerInput } from \"./InputDevices/deviceEnums\";\r\nimport type { IDeviceInputSystem } from \"./inputInterfaces\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst MAX_KEYCODES = 255;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;\r\n\r\n/** @internal */\r\nexport class WebDeviceInputSystem implements IDeviceInputSystem {\r\n    // Private Members\r\n    private _inputs: Array<{ [deviceSlot: number]: Array<number> }> = [];\r\n    private _gamepads: Array<DeviceType>;\r\n    private _keyboardActive: boolean = false;\r\n    private _pointerActive: boolean = false;\r\n    private _elementToAttachTo: HTMLElement;\r\n    private _metaKeys: Array<number>;\r\n    private readonly _engine: Engine;\r\n    private readonly _usingSafari: boolean = Tools.IsSafari();\r\n    // Found solution for determining if MacOS is being used here:\r\n    // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery\r\n    private readonly _usingMacOS: boolean = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n\r\n    private _onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void;\r\n    private _onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void;\r\n    private _onInputChanged: (deviceType: DeviceType, deviceSlot: number, eventData: IUIEvent) => void;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardDownEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardUpEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _keyboardBlurEvent = (evt: any) => {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerMoveEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerDownEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerUpEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerCancelEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerWheelEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _pointerBlurEvent = (evt: any) => {};\r\n    private _wheelEventName: string;\r\n    private _eventsAttached: boolean = false;\r\n\r\n    private _mouseId = -1;\r\n    private readonly _isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf(\"Firefox\") !== -1;\r\n\r\n    // Array to store active Pointer ID values; prevents issues with negative pointerIds\r\n    private _activeTouchIds: Array<number>;\r\n    private _maxTouchPoints: number = 0;\r\n\r\n    private _pointerInputClearObserver: Nullable<Observer<Engine>> = null;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _gamepadConnectedEvent = (evt: any) => {};\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _gamepadDisconnectedEvent = (evt: any) => {};\r\n\r\n    private _eventPrefix: string;\r\n\r\n    constructor(\r\n        engine: Engine,\r\n        onDeviceConnected: (deviceType: DeviceType, deviceSlot: number) => void,\r\n        onDeviceDisconnected: (deviceType: DeviceType, deviceSlot: number) => void,\r\n        onInputChanged: (deviceType: DeviceType, deviceSlot: number, eventData: IUIEvent) => void\r\n    ) {\r\n        this._eventPrefix = Tools.GetPointerPrefix(engine);\r\n        this._engine = engine;\r\n\r\n        this._onDeviceConnected = onDeviceConnected;\r\n        this._onDeviceDisconnected = onDeviceDisconnected;\r\n        this._onInputChanged = onInputChanged;\r\n\r\n        this._enableEvents();\r\n\r\n        if (this._usingMacOS) {\r\n            this._metaKeys = [];\r\n        }\r\n\r\n        // Set callback to enable event handler switching when inputElement changes\r\n        if (!this._engine._onEngineViewChanged) {\r\n            this._engine._onEngineViewChanged = () => {\r\n                this._enableEvents();\r\n            };\r\n        }\r\n    }\r\n\r\n    // Public functions\r\n    /**\r\n     * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param inputIndex Id of input to be checked\r\n     * @returns Current value of input\r\n     */\r\n    public pollInput(deviceType: DeviceType, deviceSlot: number, inputIndex: number): number {\r\n        const device = this._inputs[deviceType][deviceSlot];\r\n\r\n        if (!device) {\r\n            throw `Unable to find device ${DeviceType[deviceType]}`;\r\n        }\r\n\r\n        if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {\r\n            this._updateDevice(deviceType, deviceSlot, inputIndex);\r\n        }\r\n\r\n        const currentValue = device[inputIndex];\r\n        if (currentValue === undefined) {\r\n            throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;\r\n        }\r\n\r\n        if (inputIndex === PointerInput.Move) {\r\n            Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);\r\n        }\r\n\r\n        return currentValue;\r\n    }\r\n\r\n    /**\r\n     * Check for a specific device in the DeviceInputSystem\r\n     * @param deviceType Type of device to check for\r\n     * @returns bool with status of device's existence\r\n     */\r\n    public isDeviceAvailable(deviceType: DeviceType): boolean {\r\n        return this._inputs[deviceType] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Dispose of all the eventlisteners\r\n     */\r\n    public dispose(): void {\r\n        // Callbacks\r\n        this._onDeviceConnected = () => {};\r\n        this._onDeviceDisconnected = () => {};\r\n        this._onInputChanged = () => {};\r\n        delete this._engine._onEngineViewChanged;\r\n\r\n        if (this._elementToAttachTo) {\r\n            this._disableEvents();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable listening for user input events\r\n     */\r\n    private _enableEvents(): void {\r\n        const inputElement = this?._engine.getInputElement();\r\n        if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {\r\n            // Remove events before adding to avoid double events or simultaneous events on multiple canvases\r\n            this._disableEvents();\r\n\r\n            // If the inputs array has already been created, zero it out to before setting up events\r\n            if (this._inputs) {\r\n                for (const inputs of this._inputs) {\r\n                    if (inputs) {\r\n                        for (const deviceSlotKey in inputs) {\r\n                            const deviceSlot = +deviceSlotKey;\r\n                            const device = inputs[deviceSlot];\r\n                            if (device) {\r\n                                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {\r\n                                    device[inputIndex] = 0;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._elementToAttachTo = inputElement;\r\n            // Set tab index for the inputElement to the engine's canvasTabIndex, if and only if the element's tab index is -1\r\n            this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;\r\n            this._handleKeyActions();\r\n            this._handlePointerActions();\r\n            this._handleGamepadActions();\r\n            this._eventsAttached = true;\r\n\r\n            // Check for devices that are already connected but aren't registered. Currently, only checks for gamepads and mouse\r\n            this._checkForConnectedDevices();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable listening for user input events\r\n     */\r\n    private _disableEvents(): void {\r\n        if (this._elementToAttachTo) {\r\n            // Blur Events\r\n            this._elementToAttachTo.removeEventListener(\"blur\", this._keyboardBlurEvent);\r\n            this._elementToAttachTo.removeEventListener(\"blur\", this._pointerBlurEvent);\r\n\r\n            // Keyboard Events\r\n            this._elementToAttachTo.removeEventListener(\"keydown\", this._keyboardDownEvent);\r\n            this._elementToAttachTo.removeEventListener(\"keyup\", this._keyboardUpEvent);\r\n\r\n            // Pointer Events\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\r\n            this._elementToAttachTo.removeEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\r\n            this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);\r\n\r\n            // Gamepad Events\r\n            window.removeEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\r\n            window.removeEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\r\n        }\r\n\r\n        if (this._pointerInputClearObserver) {\r\n            this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);\r\n        }\r\n\r\n        this._eventsAttached = false;\r\n    }\r\n\r\n    /**\r\n     * Checks for existing connections to devices and register them, if necessary\r\n     * Currently handles gamepads and mouse\r\n     */\r\n    private _checkForConnectedDevices(): void {\r\n        if (navigator.getGamepads) {\r\n            const gamepads = navigator.getGamepads();\r\n\r\n            for (const gamepad of gamepads) {\r\n                if (gamepad) {\r\n                    this._addGamePad(gamepad);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If the device in use has mouse capabilities, pre-register mouse\r\n        if (typeof matchMedia === \"function\" && matchMedia(\"(pointer:fine)\").matches) {\r\n            // This will provide a dummy value for the cursor position and is expected to be overridden when the first mouse event happens.\r\n            // There isn't any good way to get the current position outside of a pointer event so that's why this was done.\r\n            this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);\r\n        }\r\n    }\r\n\r\n    // Private functions\r\n    /**\r\n     * Add a gamepad to the DeviceInputSystem\r\n     * @param gamepad A single DOM Gamepad object\r\n     */\r\n    private _addGamePad(gamepad: any): void {\r\n        const deviceType = this._getGamepadDeviceType(gamepad.id);\r\n        const deviceSlot = gamepad.index;\r\n\r\n        this._gamepads = this._gamepads || new Array<DeviceType>(gamepad.index + 1);\r\n        this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);\r\n\r\n        this._gamepads[deviceSlot] = deviceType;\r\n    }\r\n\r\n    /**\r\n     * Add pointer device to DeviceInputSystem\r\n     * @param deviceType Type of Pointer to add\r\n     * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)\r\n     * @param currentX Current X at point of adding\r\n     * @param currentY Current Y at point of adding\r\n     */\r\n    private _addPointerDevice(deviceType: DeviceType, deviceSlot: number, currentX: number, currentY: number): void {\r\n        if (!this._pointerActive) {\r\n            this._pointerActive = true;\r\n        }\r\n        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\r\n        const pointer = this._inputs[deviceType][deviceSlot]; /* initialize our pointer position immediately after registration */\r\n        pointer[0] = currentX;\r\n        pointer[1] = currentY;\r\n    }\r\n\r\n    /**\r\n     * Add device and inputs to device array\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param numberOfInputs Number of input entries to create for given device\r\n     */\r\n    private _registerDevice(deviceType: DeviceType, deviceSlot: number, numberOfInputs: number): void {\r\n        if (deviceSlot === undefined) {\r\n            throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;\r\n        }\r\n\r\n        if (!this._inputs[deviceType]) {\r\n            this._inputs[deviceType] = {};\r\n        }\r\n\r\n        if (!this._inputs[deviceType][deviceSlot]) {\r\n            const device = new Array<number>(numberOfInputs);\r\n\r\n            device.fill(0);\r\n\r\n            this._inputs[deviceType][deviceSlot] = device;\r\n            this._onDeviceConnected(deviceType, deviceSlot);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a specific device name, remove that device from the device map\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     */\r\n    private _unregisterDevice(deviceType: DeviceType, deviceSlot: number): void {\r\n        if (this._inputs[deviceType][deviceSlot]) {\r\n            delete this._inputs[deviceType][deviceSlot];\r\n            this._onDeviceDisconnected(deviceType, deviceSlot);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from keyboard interaction\r\n     */\r\n    private _handleKeyActions(): void {\r\n        this._keyboardDownEvent = (evt) => {\r\n            if (!this._keyboardActive) {\r\n                this._keyboardActive = true;\r\n                this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\r\n            }\r\n\r\n            const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n            if (kbKey) {\r\n                kbKey[evt.keyCode] = 1;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = evt.keyCode;\r\n\r\n                if (this._usingMacOS && evt.metaKey && evt.key !== \"Meta\") {\r\n                    if (!this._metaKeys.includes(evt.keyCode)) {\r\n                        this._metaKeys.push(evt.keyCode);\r\n                    }\r\n                }\r\n\r\n                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n            }\r\n        };\r\n\r\n        this._keyboardUpEvent = (evt) => {\r\n            if (!this._keyboardActive) {\r\n                this._keyboardActive = true;\r\n                this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);\r\n            }\r\n\r\n            const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n            if (kbKey) {\r\n                kbKey[evt.keyCode] = 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n                deviceEvent.inputIndex = evt.keyCode;\r\n\r\n                if (this._usingMacOS && evt.key === \"Meta\" && this._metaKeys.length > 0) {\r\n                    for (const keyCode of this._metaKeys) {\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);\r\n                        kbKey[keyCode] = 0;\r\n                        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n                    }\r\n                    this._metaKeys.splice(0, this._metaKeys.length);\r\n                }\r\n\r\n                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n            }\r\n        };\r\n\r\n        this._keyboardBlurEvent = () => {\r\n            if (this._keyboardActive) {\r\n                const kbKey = this._inputs[DeviceType.Keyboard][0];\r\n\r\n                for (let i = 0; i < kbKey.length; i++) {\r\n                    if (kbKey[i] !== 0) {\r\n                        kbKey[i] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);\r\n                    }\r\n                }\r\n                if (this._usingMacOS) {\r\n                    this._metaKeys.splice(0, this._metaKeys.length);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._elementToAttachTo.addEventListener(\"keydown\", this._keyboardDownEvent);\r\n        this._elementToAttachTo.addEventListener(\"keyup\", this._keyboardUpEvent);\r\n        this._elementToAttachTo.addEventListener(\"blur\", this._keyboardBlurEvent);\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from pointer interaction\r\n     */\r\n    private _handlePointerActions(): void {\r\n        // If maxTouchPoints is defined, use that value.  Otherwise, allow for a minimum for supported gestures like pinch\r\n        this._maxTouchPoints = (DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints) || 2;\r\n        if (!this._activeTouchIds) {\r\n            this._activeTouchIds = new Array<number>(this._maxTouchPoints);\r\n        }\r\n\r\n        for (let i = 0; i < this._maxTouchPoints; i++) {\r\n            this._activeTouchIds[i] = -1;\r\n        }\r\n\r\n        this._pointerMoveEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = {};\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                const deviceEvent = evt as IPointerEvent;\r\n                deviceEvent.inputIndex = PointerInput.Move;\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                // Lets Propagate the event for move with same position.\r\n                if (!this._usingSafari && evt.button !== -1) {\r\n                    deviceEvent.inputIndex = evt.button + 2;\r\n                    pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1; // Reverse state of button if evt.button has value\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerDownEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;\r\n\r\n            if (deviceType === DeviceType.Touch) {\r\n                const idx = this._activeTouchIds.indexOf(-1);\r\n\r\n                if (idx >= 0) {\r\n                    deviceSlot = idx;\r\n                    this._activeTouchIds[idx] = evt.pointerId;\r\n                } else {\r\n                    // We can't find an open slot to store new pointer so just return (can only support max number of touches)\r\n                    Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = {};\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);\r\n            } else if (deviceType === DeviceType.Touch) {\r\n                this._onDeviceConnected(deviceType, deviceSlot);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                const previousHorizontal = pointer[PointerInput.Horizontal];\r\n                const previousVertical = pointer[PointerInput.Vertical];\r\n\r\n                if (deviceType === DeviceType.Mouse) {\r\n                    // Mouse; Among supported browsers, value is either 1 or 0 for mouse\r\n                    if (this._mouseId === -1) {\r\n                        if (evt.pointerId === undefined) {\r\n                            // If there is no pointerId (eg. manually dispatched MouseEvent)\r\n                            this._mouseId = this._isUsingFirefox ? 0 : 1;\r\n                        } else {\r\n                            this._mouseId = evt.pointerId;\r\n                        }\r\n                    }\r\n\r\n                    if (!document.pointerLockElement) {\r\n                        try {\r\n                            this._elementToAttachTo.setPointerCapture(this._mouseId);\r\n                        } catch (e) {\r\n                            // DO NOTHING\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Touch; Since touches are dynamically assigned, only set capture if we have an id\r\n                    if (evt.pointerId && !document.pointerLockElement) {\r\n                        try {\r\n                            this._elementToAttachTo.setPointerCapture(evt.pointerId);\r\n                        } catch (e) {\r\n                            // DO NOTHING\r\n                        }\r\n                    }\r\n                }\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n                pointer[evt.button + 2] = 1;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\r\n                // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\r\n                // EG. ([X, Y, Left-click], Middle-click, etc...)\r\n                deviceEvent.inputIndex = evt.button + 2;\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\r\n                    deviceEvent.inputIndex = PointerInput.Move;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerUpEvent = (evt) => {\r\n            const deviceType = this._getPointerType(evt);\r\n            const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n            if (deviceType === DeviceType.Touch) {\r\n                if (deviceSlot === -1) {\r\n                    return;\r\n                } else {\r\n                    this._activeTouchIds[deviceSlot] = -1;\r\n                }\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType]?.[deviceSlot];\r\n            if (pointer && pointer[evt.button + 2] !== 0) {\r\n                const previousHorizontal = pointer[PointerInput.Horizontal];\r\n                const previousVertical = pointer[PointerInput.Vertical];\r\n\r\n                pointer[PointerInput.Horizontal] = evt.clientX;\r\n                pointer[PointerInput.Vertical] = evt.clientY;\r\n                pointer[evt.button + 2] = 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {\r\n                    deviceEvent.inputIndex = PointerInput.Move;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n\r\n                // NOTE: The +2 used here to is because PointerInput has the same value progression for its mouse buttons as PointerEvent.button\r\n                // However, we have our X and Y values front-loaded to group together the touch inputs but not break this progression\r\n                // EG. ([X, Y, Left-click], Middle-click, etc...)\r\n                deviceEvent.inputIndex = evt.button + 2;\r\n\r\n                if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                } else if (evt.pointerId && this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(evt.pointerId);\r\n                }\r\n\r\n                this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n\r\n                if (deviceType === DeviceType.Touch) {\r\n                    this._onDeviceDisconnected(deviceType, deviceSlot);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerCancelEvent = (evt) => {\r\n            if (evt.pointerType === \"mouse\") {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n\r\n                if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                }\r\n\r\n                for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\r\n                    if (pointer[inputIndex] === 1) {\r\n                        pointer[inputIndex] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\r\n                    }\r\n                }\r\n            } else {\r\n                const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);\r\n\r\n                if (this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(evt.pointerId);\r\n                }\r\n\r\n                this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;\r\n\r\n                const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);\r\n\r\n                this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\r\n\r\n                this._activeTouchIds[deviceSlot] = -1;\r\n                this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\r\n            }\r\n        };\r\n\r\n        // Set Wheel Event Name, code originally from scene.inputManager\r\n        this._wheelEventName =\r\n            \"onwheel\" in document.createElement(\"div\")\r\n                ? \"wheel\" // Modern browsers support \"wheel\"\r\n                : (<any>document).onmousewheel !== undefined\r\n                ? \"mousewheel\" // Webkit and IE support at least \"mousewheel\"\r\n                : \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\n        // Code originally in scene.inputManager.ts\r\n        // Chrome reports warning in console if wheel listener doesn't set an explicit passive option.\r\n        // IE11 only supports captureEvent:boolean, not options:object, and it defaults to false.\r\n        // Feature detection technique copied from: https://github.com/github/eventlistener-polyfill (MIT license)\r\n        let passiveSupported = false;\r\n        const noop = function () {};\r\n\r\n        try {\r\n            const options = Object.defineProperty({}, \"passive\", {\r\n                get: function () {\r\n                    passiveSupported = true;\r\n                },\r\n            });\r\n\r\n            this._elementToAttachTo.addEventListener(\"test\", noop, options);\r\n            this._elementToAttachTo.removeEventListener(\"test\", noop, options);\r\n        } catch (e) {\r\n            /* */\r\n        }\r\n\r\n        this._pointerBlurEvent = () => {\r\n            // Handle mouse buttons\r\n            if (this.isDeviceAvailable(DeviceType.Mouse)) {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n\r\n                if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {\r\n                    this._elementToAttachTo.releasePointerCapture(this._mouseId);\r\n                }\r\n\r\n                for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {\r\n                    if (pointer[inputIndex] === 1) {\r\n                        pointer[inputIndex] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Handle Active Touches\r\n            if (this.isDeviceAvailable(DeviceType.Touch)) {\r\n                const pointer = this._inputs[DeviceType.Touch];\r\n\r\n                for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {\r\n                    const pointerId = this._activeTouchIds[deviceSlot];\r\n\r\n                    if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {\r\n                        this._elementToAttachTo.releasePointerCapture(pointerId);\r\n                    }\r\n\r\n                    if (pointerId !== -1 && pointer[deviceSlot]?.[PointerInput.LeftClick] === 1) {\r\n                        pointer[deviceSlot][PointerInput.LeftClick] = 0;\r\n\r\n                        const deviceEvent: IUIEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo);\r\n\r\n                        this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);\r\n\r\n                        this._activeTouchIds[deviceSlot] = -1;\r\n                        this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this._pointerWheelEvent = (evt) => {\r\n            const deviceType = DeviceType.Mouse;\r\n            const deviceSlot = 0;\r\n\r\n            if (!this._inputs[deviceType]) {\r\n                this._inputs[deviceType] = [];\r\n            }\r\n\r\n            if (!this._inputs[deviceType][deviceSlot]) {\r\n                this._pointerActive = true;\r\n                this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);\r\n            }\r\n\r\n            const pointer = this._inputs[deviceType][deviceSlot];\r\n            if (pointer) {\r\n                pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;\r\n                pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;\r\n                pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;\r\n\r\n                const deviceEvent = evt as IUIEvent;\r\n\r\n                if (pointer[PointerInput.MouseWheelX] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelX;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n                if (pointer[PointerInput.MouseWheelY] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelY;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n                if (pointer[PointerInput.MouseWheelZ] !== 0) {\r\n                    deviceEvent.inputIndex = PointerInput.MouseWheelZ;\r\n                    this._onInputChanged(deviceType, deviceSlot, deviceEvent);\r\n                }\r\n            }\r\n        };\r\n\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"move\", this._pointerMoveEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"down\", this._pointerDownEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"up\", this._pointerUpEvent);\r\n        this._elementToAttachTo.addEventListener(this._eventPrefix + \"cancel\", this._pointerCancelEvent);\r\n        this._elementToAttachTo.addEventListener(\"blur\", this._pointerBlurEvent);\r\n        this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);\r\n\r\n        // Since there's no up or down event for mouse wheel or delta x/y, clear mouse values at end of frame\r\n        this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {\r\n            if (this.isDeviceAvailable(DeviceType.Mouse)) {\r\n                const pointer = this._inputs[DeviceType.Mouse][0];\r\n                pointer[PointerInput.MouseWheelX] = 0;\r\n                pointer[PointerInput.MouseWheelY] = 0;\r\n                pointer[PointerInput.MouseWheelZ] = 0;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Handle all actions that come from gamepad interaction\r\n     */\r\n    private _handleGamepadActions(): void {\r\n        this._gamepadConnectedEvent = (evt: any) => {\r\n            this._addGamePad(evt.gamepad);\r\n        };\r\n\r\n        this._gamepadDisconnectedEvent = (evt: any) => {\r\n            if (this._gamepads) {\r\n                const deviceType = this._getGamepadDeviceType(evt.gamepad.id);\r\n                const deviceSlot = evt.gamepad.index;\r\n\r\n                this._unregisterDevice(deviceType, deviceSlot);\r\n                delete this._gamepads[deviceSlot];\r\n            }\r\n        };\r\n\r\n        window.addEventListener(\"gamepadconnected\", this._gamepadConnectedEvent);\r\n        window.addEventListener(\"gamepaddisconnected\", this._gamepadDisconnectedEvent);\r\n    }\r\n\r\n    /**\r\n     * Update all non-event based devices with each frame\r\n     * @param deviceType Enum specifying device type\r\n     * @param deviceSlot \"Slot\" or index that device is referenced in\r\n     * @param inputIndex Id of input to be checked\r\n     */\r\n    private _updateDevice(deviceType: DeviceType, deviceSlot: number, inputIndex: number): void {\r\n        // Gamepads\r\n        const gp = navigator.getGamepads()[deviceSlot];\r\n\r\n        if (gp && deviceType === this._gamepads[deviceSlot]) {\r\n            const device = this._inputs[deviceType][deviceSlot];\r\n\r\n            if (inputIndex >= gp.buttons.length) {\r\n                device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();\r\n            } else {\r\n                device[inputIndex] = gp.buttons[inputIndex].value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets DeviceType from the device name\r\n     * @param deviceName Name of Device from DeviceInputSystem\r\n     * @returns DeviceType enum value\r\n     */\r\n    private _getGamepadDeviceType(deviceName: string): DeviceType {\r\n        if (deviceName.indexOf(\"054c\") !== -1) {\r\n            // DualShock 4 Gamepad\r\n            return deviceName.indexOf(\"0ce6\") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;\r\n        } else if (deviceName.indexOf(\"Xbox One\") !== -1 || deviceName.search(\"Xbox 360\") !== -1 || deviceName.search(\"xinput\") !== -1) {\r\n            // Xbox Gamepad\r\n            return DeviceType.Xbox;\r\n        } else if (deviceName.indexOf(\"057e\") !== -1) {\r\n            // Switch Gamepad\r\n            return DeviceType.Switch;\r\n        }\r\n\r\n        return DeviceType.Generic;\r\n    }\r\n\r\n    /**\r\n     * Get DeviceType from a given pointer/mouse/touch event.\r\n     * @param evt PointerEvent to evaluate\r\n     * @returns DeviceType interpreted from event\r\n     */\r\n    private _getPointerType(evt: any): DeviceType {\r\n        let deviceType = DeviceType.Mouse;\r\n\r\n        if (evt.pointerType === \"touch\" || evt.pointerType === \"pen\" || evt.touches) {\r\n            deviceType = DeviceType.Touch;\r\n        }\r\n\r\n        return deviceType;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}