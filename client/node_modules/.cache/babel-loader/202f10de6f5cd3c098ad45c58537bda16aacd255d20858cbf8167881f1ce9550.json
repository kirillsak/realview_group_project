{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Defines the layer scene component responsible to manage any layers\n * in a given scene.\n */\nexport class LayerSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_LAYER;\n    this.scene = scene || EngineStore.LastCreatedScene;\n    if (!this.scene) {\n      return;\n    }\n    this._engine = this.scene.getEngine();\n    this.scene.layers = new Array();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);\n    this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);\n    this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\n    this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);\n    this.scene._afterRenderTargetPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER, this, this._drawRenderTargetForegroundWithoutPostProcessing);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const layers = this.scene.layers;\n    for (const layer of layers) {\n      layer._rebuild();\n    }\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    const layers = this.scene.layers;\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  }\n  _draw(predicate) {\n    const layers = this.scene.layers;\n    if (layers.length) {\n      this._engine.setDepthBuffer(false);\n      for (const layer of layers) {\n        if (predicate(layer)) {\n          layer.render();\n        }\n      }\n      this._engine.setDepthBuffer(true);\n    }\n  }\n  _drawCameraPredicate(layer, isBackground, applyPostProcess, cameraLayerMask) {\n    return !layer.renderOnlyInRenderTargetTextures && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && (layer.layerMask & cameraLayerMask) !== 0;\n  }\n  _drawCameraBackground(camera) {\n    this._draw(layer => {\n      return this._drawCameraPredicate(layer, true, true, camera.layerMask);\n    });\n  }\n  _drawCameraForegroundWithPostProcessing(camera) {\n    this._draw(layer => {\n      return this._drawCameraPredicate(layer, false, true, camera.layerMask);\n    });\n  }\n  _drawCameraForegroundWithoutPostProcessing(camera) {\n    this._draw(layer => {\n      return this._drawCameraPredicate(layer, false, false, camera.layerMask);\n    });\n  }\n  _drawRenderTargetPredicate(layer, isBackground, applyPostProcess, cameraLayerMask, renderTargetTexture) {\n    return layer.renderTargetTextures.length > 0 && layer.isBackground === isBackground && layer.applyPostProcess === applyPostProcess && layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 && (layer.layerMask & cameraLayerMask) !== 0;\n  }\n  _drawRenderTargetBackground(renderTarget) {\n    this._draw(layer => {\n      return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera.layerMask, renderTarget);\n    });\n  }\n  _drawRenderTargetForegroundWithPostProcessing(renderTarget) {\n    this._draw(layer => {\n      return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera.layerMask, renderTarget);\n    });\n  }\n  _drawRenderTargetForegroundWithoutPostProcessing(renderTarget) {\n    this._draw(layer => {\n      return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera.layerMask, renderTarget);\n    });\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  addFromContainer(container) {\n    if (!container.layers) {\n      return;\n    }\n    container.layers.forEach(layer => {\n      this.scene.layers.push(layer);\n    });\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  removeFromContainer(container, dispose = false) {\n    if (!container.layers) {\n      return;\n    }\n    container.layers.forEach(layer => {\n      const index = this.scene.layers.indexOf(layer);\n      if (index !== -1) {\n        this.scene.layers.splice(index, 1);\n      }\n      if (dispose) {\n        layer.dispose();\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["SceneComponentConstants","EngineStore","LayerSceneComponent","constructor","scene","NAME_LAYER","LastCreatedScene","_engine","getEngine","layers","Array","register","_beforeCameraDrawStage","registerStep","STEP_BEFORECAMERADRAW_LAYER","_drawCameraBackground","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_LAYER","_drawCameraForegroundWithPostProcessing","_afterCameraPostProcessStage","STEP_AFTERCAMERAPOSTPROCESS_LAYER","_drawCameraForegroundWithoutPostProcessing","_beforeRenderTargetDrawStage","STEP_BEFORERENDERTARGETDRAW_LAYER","_drawRenderTargetBackground","_afterRenderTargetDrawStage","STEP_AFTERRENDERTARGETDRAW_LAYER","_drawRenderTargetForegroundWithPostProcessing","_afterRenderTargetPostProcessStage","STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER","_drawRenderTargetForegroundWithoutPostProcessing","rebuild","layer","_rebuild","dispose","length","_draw","predicate","setDepthBuffer","render","_drawCameraPredicate","isBackground","applyPostProcess","cameraLayerMask","renderOnlyInRenderTargetTextures","layerMask","camera","_drawRenderTargetPredicate","renderTargetTexture","renderTargetTextures","indexOf","renderTarget","activeCamera","addFromContainer","container","forEach","push","removeFromContainer","index","splice"],"sourceRoot":"","sources":["../../../../lts/core/generated/Layers/layerSceneComponent.ts"],"sourcesContent":["import type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { Layer } from \"./layer\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of layers (background and foreground) of the scene\r\n         */\r\n        layers: Array<Layer>;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any layers\r\n * in a given scene.\r\n */\r\nexport class LayerSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_LAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.layers = new Array<Layer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER, this, this._drawCameraBackground);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER, this, this._drawCameraForegroundWithPostProcessing);\r\n        this.scene._afterCameraPostProcessStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER, this, this._drawCameraForegroundWithoutPostProcessing);\r\n\r\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER, this, this._drawRenderTargetBackground);\r\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER, this, this._drawRenderTargetForegroundWithPostProcessing);\r\n        this.scene._afterRenderTargetPostProcessStage.registerStep(\r\n            SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,\r\n            this,\r\n            this._drawRenderTargetForegroundWithoutPostProcessing\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        for (const layer of layers) {\r\n            layer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.layers;\r\n\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _draw(predicate: (layer: Layer) => boolean): void {\r\n        const layers = this.scene.layers;\r\n\r\n        if (layers.length) {\r\n            this._engine.setDepthBuffer(false);\r\n            for (const layer of layers) {\r\n                if (predicate(layer)) {\r\n                    layer.render();\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCameraPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number): boolean {\r\n        return (\r\n            !layer.renderOnlyInRenderTargetTextures &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawCameraBackground(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, true, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, true, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawCameraForegroundWithoutPostProcessing(camera: Camera): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawCameraPredicate(layer, false, false, camera.layerMask);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetPredicate(layer: Layer, isBackground: boolean, applyPostProcess: boolean, cameraLayerMask: number, renderTargetTexture: RenderTargetTexture): boolean {\r\n        return (\r\n            layer.renderTargetTextures.length > 0 &&\r\n            layer.isBackground === isBackground &&\r\n            layer.applyPostProcess === applyPostProcess &&\r\n            layer.renderTargetTextures.indexOf(renderTargetTexture) > -1 &&\r\n            (layer.layerMask & cameraLayerMask) !== 0\r\n        );\r\n    }\r\n\r\n    private _drawRenderTargetBackground(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, true, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, true, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    private _drawRenderTargetForegroundWithoutPostProcessing(renderTarget: RenderTargetTexture): void {\r\n        this._draw((layer: Layer) => {\r\n            return this._drawRenderTargetPredicate(layer, false, false, this.scene.activeCamera!.layerMask, renderTarget);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            this.scene.layers.push(layer);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose = false): void {\r\n        if (!container.layers) {\r\n            return;\r\n        }\r\n        container.layers.forEach((layer) => {\r\n            const index = this.scene.layers.indexOf(layer);\r\n            if (index !== -1) {\r\n                this.scene.layers.splice(index, 1);\r\n            }\r\n            if (dispose) {\r\n                layer.dispose();\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}