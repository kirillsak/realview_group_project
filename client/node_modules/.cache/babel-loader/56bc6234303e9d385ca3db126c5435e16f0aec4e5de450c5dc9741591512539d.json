{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { TargetCamera } from \"../../Cameras/targetCamera.js\";\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera.js\";\nimport { VRDeviceOrientationFreeCamera } from \"../../Cameras/VR/vrDeviceOrientationFreeCamera.js\";\nimport { WebVRFreeCamera } from \"../../Cameras/VR/webVRCamera.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\nimport { PoseEnabledController, PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController.js\";\nimport { WebVRController } from \"../../Gamepads/Controllers/webVRController.js\";\nimport { Xbox360Button } from \"../../Gamepads/xboxGamepad.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Ray } from \"../../Culling/ray.js\";\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration.js\";\nimport { StandardMaterial } from \"../../Materials/standardMaterial.js\";\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture.js\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess.js\";\nimport { SineEase, EasingFunction, CircleEase } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\nimport { VRCameraMetrics } from \"../../Cameras/VR/vrCameraMetrics.js\";\nimport \"../../Gamepads/gamepadSceneComponent.js\";\nimport \"../../Animations/animatable.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { WebXRSessionManager } from \"../../XR/webXRSessionManager.js\";\nimport { WebXRState } from \"../../XR/webXRTypes.js\";\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder.js\";\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder.js\";\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder.js\";\nclass VRExperienceHelperGazer {\n  constructor(scene, gazeTrackerToClone = null) {\n    this.scene = scene;\n    /** @internal */\n    this._pointerDownOnMeshAsked = false;\n    /** @internal */\n    this._isActionableMesh = false;\n    /** @internal */\n    this._teleportationRequestInitiated = false;\n    /** @internal */\n    this._teleportationBackRequestInitiated = false;\n    /** @internal */\n    this._rotationRightAsked = false;\n    /** @internal */\n    this._rotationLeftAsked = false;\n    /** @internal */\n    this._dpadPressed = true;\n    /** @internal */\n    this._activePointer = false;\n    this._id = VRExperienceHelperGazer._IdCounter++;\n    // Gaze tracker\n    if (!gazeTrackerToClone) {\n      this._gazeTracker = CreateTorus(\"gazeTracker\", {\n        diameter: 0.0035,\n        thickness: 0.0025,\n        tessellation: 20,\n        updatable: false\n      }, scene);\n      this._gazeTracker.bakeCurrentTransformIntoVertices();\n      this._gazeTracker.isPickable = false;\n      this._gazeTracker.isVisible = false;\n      const targetMat = new StandardMaterial(\"targetMat\", scene);\n      targetMat.specularColor = Color3.Black();\n      targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\n      targetMat.backFaceCulling = false;\n      this._gazeTracker.material = targetMat;\n    } else {\n      this._gazeTracker = gazeTrackerToClone.clone(\"gazeTracker\");\n    }\n  }\n  /**\n   * @internal\n   */\n  _getForwardRay(length) {\n    return new Ray(Vector3.Zero(), new Vector3(0, 0, length));\n  }\n  /** @internal */\n  _selectionPointerDown() {\n    this._pointerDownOnMeshAsked = true;\n    if (this._currentHit) {\n      this.scene.simulatePointerDown(this._currentHit, {\n        pointerId: this._id\n      });\n    }\n  }\n  /** @internal */\n  _selectionPointerUp() {\n    if (this._currentHit) {\n      this.scene.simulatePointerUp(this._currentHit, {\n        pointerId: this._id\n      });\n    }\n    this._pointerDownOnMeshAsked = false;\n  }\n  /** @internal */\n  _activatePointer() {\n    this._activePointer = true;\n  }\n  /** @internal */\n  _deactivatePointer() {\n    this._activePointer = false;\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _updatePointerDistance(distance = 100) {}\n  dispose() {\n    this._interactionsEnabled = false;\n    this._teleportationEnabled = false;\n    if (this._gazeTracker) {\n      this._gazeTracker.dispose();\n    }\n  }\n}\nVRExperienceHelperGazer._IdCounter = 0;\nclass VRExperienceHelperControllerGazer extends VRExperienceHelperGazer {\n  constructor(webVRController, scene, gazeTrackerToClone) {\n    super(scene, gazeTrackerToClone);\n    this.webVRController = webVRController;\n    // Laser pointer\n    this._laserPointer = CreateCylinder(\"laserPointer\", {\n      updatable: false,\n      height: 1,\n      diameterTop: 0.004,\n      diameterBottom: 0.0002,\n      tessellation: 20,\n      subdivisions: 1\n    }, scene);\n    const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", scene);\n    laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);\n    laserPointerMaterial.alpha = 0.6;\n    this._laserPointer.material = laserPointerMaterial;\n    this._laserPointer.rotation.x = Math.PI / 2;\n    this._laserPointer.position.z = -0.5;\n    this._laserPointer.isVisible = false;\n    this._laserPointer.isPickable = false;\n    if (!webVRController.mesh) {\n      // Create an empty mesh that is used prior to loading the high quality model\n      const preloadMesh = new Mesh(\"preloadControllerMesh\", scene);\n      const preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);\n      preloadPointerPose.rotation.x = -0.7;\n      preloadMesh.addChild(preloadPointerPose);\n      webVRController.attachToMesh(preloadMesh);\n    }\n    this._setLaserPointerParent(webVRController.mesh);\n    this._meshAttachedObserver = webVRController._meshAttachedObservable.add(mesh => {\n      this._setLaserPointerParent(mesh);\n    });\n  }\n  _getForwardRay(length) {\n    return this.webVRController.getForwardRay(length);\n  }\n  /** @internal */\n  _activatePointer() {\n    super._activatePointer();\n    this._laserPointer.isVisible = true;\n  }\n  /** @internal */\n  _deactivatePointer() {\n    super._deactivatePointer();\n    this._laserPointer.isVisible = false;\n  }\n  /**\n   * @internal\n   */\n  _setLaserPointerColor(color) {\n    this._laserPointer.material.emissiveColor = color;\n  }\n  /**\n   * @internal\n   */\n  _setLaserPointerLightingDisabled(disabled) {\n    this._laserPointer.material.disableLighting = disabled;\n  }\n  /**\n   * @internal\n   */\n  _setLaserPointerParent(mesh) {\n    const makeNotPick = root => {\n      root.isPickable = false;\n      root.getChildMeshes().forEach(c => {\n        makeNotPick(c);\n      });\n    };\n    makeNotPick(mesh);\n    const meshChildren = mesh.getChildren(undefined, false);\n    let laserParent = mesh;\n    this.webVRController._pointingPoseNode = null;\n    for (let i = 0; i < meshChildren.length; i++) {\n      if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {\n        laserParent = meshChildren[i];\n        this.webVRController._pointingPoseNode = laserParent;\n        break;\n      }\n    }\n    this._laserPointer.parent = laserParent;\n  }\n  _updatePointerDistance(distance = 100) {\n    this._laserPointer.scaling.y = distance;\n    this._laserPointer.position.z = -distance / 2;\n  }\n  dispose() {\n    super.dispose();\n    this._laserPointer.dispose();\n    if (this._meshAttachedObserver) {\n      this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);\n    }\n  }\n}\nclass VRExperienceHelperCameraGazer extends VRExperienceHelperGazer {\n  constructor(_getCamera, scene) {\n    super(scene);\n    this._getCamera = _getCamera;\n  }\n  _getForwardRay(length) {\n    const camera = this._getCamera();\n    if (camera) {\n      return camera.getForwardRay(length);\n    } else {\n      return new Ray(Vector3.Zero(), Vector3.Forward());\n    }\n  }\n}\n/**\n * Event containing information after VR has been entered\n */\nexport class OnAfterEnteringVRObservableEvent {}\n/**\n * Helps to quickly add VR support to an existing scene.\n * See https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRHelper\n * @deprecated\n */\nexport class VRExperienceHelper {\n  /**\n   * Instantiates a VRExperienceHelper.\n   * Helps to quickly add VR support to an existing scene.\n   * @param scene The scene the VRExperienceHelper belongs to.\n   * @param webVROptions Options to modify the vr experience helper's behavior.\n   */\n  constructor(scene, /** Options to modify the vr experience helper's behavior. */\n  webVROptions = {}) {\n    this.webVROptions = webVROptions;\n    // Can the system support WebVR, even if a headset isn't plugged in?\n    this._webVRsupported = false;\n    // If WebVR is supported, is a headset plugged in and are we ready to present?\n    this._webVRready = false;\n    // Are we waiting for the requestPresent callback to complete?\n    this._webVRrequesting = false;\n    // Are we presenting to the headset right now? (this is the vrDevice state)\n    this._webVRpresenting = false;\n    // Are we presenting in the fullscreen fallback?\n    this._fullscreenVRpresenting = false;\n    /**\n     * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)\n     */\n    this.enableGazeEvenWhenNoPointerLock = false;\n    /**\n     * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected\n     */\n    this.exitVROnDoubleTap = true;\n    /**\n     * Observable raised right before entering VR.\n     */\n    this.onEnteringVRObservable = new Observable();\n    /**\n     * Observable raised when entering VR has completed.\n     */\n    this.onAfterEnteringVRObservable = new Observable();\n    /**\n     * Observable raised when exiting VR.\n     */\n    this.onExitingVRObservable = new Observable();\n    /**\n     * Observable raised when controller mesh is loaded.\n     */\n    this.onControllerMeshLoadedObservable = new Observable();\n    this._useCustomVRButton = false;\n    this._teleportationRequested = false;\n    this._teleportActive = false;\n    this._floorMeshesCollection = [];\n    this._teleportationMode = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;\n    this._teleportationTime = 122;\n    this._teleportationSpeed = 20;\n    this._rotationAllowed = true;\n    this._teleportBackwardsVector = new Vector3(0, -1, -1);\n    this._isDefaultTeleportationTarget = true;\n    this._teleportationFillColor = \"#444444\";\n    this._teleportationBorderColor = \"#FFFFFF\";\n    this._rotationAngle = 0;\n    this._haloCenter = new Vector3(0, 0, 0);\n    this._padSensibilityUp = 0.65;\n    this._padSensibilityDown = 0.35;\n    this._leftController = null;\n    this._rightController = null;\n    this._gazeColor = new Color3(0.7, 0.7, 0.7);\n    this._laserColor = new Color3(0.7, 0.7, 0.7);\n    this._pickedLaserColor = new Color3(0.2, 0.2, 1);\n    this._pickedGazeColor = new Color3(0, 0, 1);\n    /**\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate\n     */\n    this.onNewMeshSelected = new Observable();\n    /**\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate.\n     * This observable will provide the mesh and the controller used to select the mesh\n     */\n    this.onMeshSelectedWithController = new Observable();\n    /**\n     * Observable raised when a new mesh is picked based on meshSelectionPredicate\n     */\n    this.onNewMeshPicked = new Observable();\n    /**\n     * Observable raised before camera teleportation\n     */\n    this.onBeforeCameraTeleport = new Observable();\n    /**\n     *  Observable raised after camera teleportation\n     */\n    this.onAfterCameraTeleport = new Observable();\n    /**\n     * Observable raised when current selected mesh gets unselected\n     */\n    this.onSelectedMeshUnselected = new Observable();\n    /**\n     * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.\n     */\n    this.teleportationEnabled = true;\n    this._teleportationInitialized = false;\n    this._interactionsEnabled = false;\n    this._interactionsRequested = false;\n    this._displayGaze = true;\n    this._displayLaserPointer = true;\n    /**\n     * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes\n     */\n    this.updateGazeTrackerScale = true;\n    /**\n     * If the gaze trackers color should be updated when selecting meshes\n     */\n    this.updateGazeTrackerColor = true;\n    /**\n     * If the controller laser color should be updated when selecting meshes\n     */\n    this.updateControllerLaserColor = true;\n    /**\n     * Defines whether or not Pointer lock should be requested when switching to\n     * full screen.\n     */\n    this.requestPointerLockOnFullScreen = true;\n    /**\n     * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.\n     * If this is true and no this.xr, xr exists but is not supported, using WebVR.\n     */\n    this.xrTestDone = false;\n    this._onResize = () => {\n      this._moveButtonToBottomRight();\n      if (this._fullscreenVRpresenting && this._webVRready) {\n        this.exitVR();\n      }\n    };\n    this._onFullscreenChange = () => {\n      this._fullscreenVRpresenting = !!document.fullscreenElement;\n      if (!this._fullscreenVRpresenting && this._inputElement) {\n        this.exitVR();\n        if (!this._useCustomVRButton && this._btnVR) {\n          this._btnVR.style.top = this._inputElement.offsetTop + this._inputElement.offsetHeight - 70 + \"px\";\n          this._btnVR.style.left = this._inputElement.offsetLeft + this._inputElement.offsetWidth - 100 + \"px\";\n          // make sure the button is visible after setting its position\n          this._updateButtonVisibility();\n        }\n      }\n    };\n    this._cachedAngularSensibility = {\n      angularSensibilityX: null,\n      angularSensibilityY: null,\n      angularSensibility: null\n    };\n    this._beforeRender = () => {\n      if (this._leftController && this._leftController._activePointer) {\n        this._castRayAndSelectObject(this._leftController);\n      }\n      if (this._rightController && this._rightController._activePointer) {\n        this._castRayAndSelectObject(this._rightController);\n      }\n      if (this._noControllerIsActive && (this._scene.getEngine().isPointerLock || this.enableGazeEvenWhenNoPointerLock)) {\n        this._castRayAndSelectObject(this._cameraGazer);\n      } else {\n        this._cameraGazer._gazeTracker.isVisible = false;\n      }\n    };\n    this._onNewGamepadConnected = gamepad => {\n      if (gamepad.type !== Gamepad.POSE_ENABLED) {\n        if (gamepad.leftStick) {\n          gamepad.onleftstickchanged(stickValues => {\n            if (this._teleportationInitialized && this.teleportationEnabled) {\n              // Listening to classic/xbox gamepad only if no VR controller is active\n              if (!this._leftController && !this._rightController || this._leftController && !this._leftController._activePointer && this._rightController && !this._rightController._activePointer) {\n                this._checkTeleportWithRay(stickValues, this._cameraGazer);\n                this._checkTeleportBackwards(stickValues, this._cameraGazer);\n              }\n            }\n          });\n        }\n        if (gamepad.rightStick) {\n          gamepad.onrightstickchanged(stickValues => {\n            if (this._teleportationInitialized) {\n              this._checkRotate(stickValues, this._cameraGazer);\n            }\n          });\n        }\n        if (gamepad.type === Gamepad.XBOX) {\n          gamepad.onbuttondown(buttonPressed => {\n            if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n              this._cameraGazer._selectionPointerDown();\n            }\n          });\n          gamepad.onbuttonup(buttonPressed => {\n            if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\n              this._cameraGazer._selectionPointerUp();\n            }\n          });\n        }\n      } else {\n        const webVRController = gamepad;\n        const controller = new VRExperienceHelperControllerGazer(webVRController, this._scene, this._cameraGazer._gazeTracker);\n        if (webVRController.hand === \"right\" || this._leftController && this._leftController.webVRController != webVRController) {\n          this._rightController = controller;\n        } else {\n          this._leftController = controller;\n        }\n        this._tryEnableInteractionOnController(controller);\n      }\n    };\n    // This only succeeds if the controller's mesh exists for the controller so this must be called whenever new controller is connected or when mesh is loaded\n    this._tryEnableInteractionOnController = controller => {\n      if (this._interactionsRequested && !controller._interactionsEnabled) {\n        this._enableInteractionOnController(controller);\n      }\n      if (this._teleportationRequested && !controller._teleportationEnabled) {\n        this._enableTeleportationOnController(controller);\n      }\n    };\n    this._onNewGamepadDisconnected = gamepad => {\n      if (gamepad instanceof WebVRController) {\n        if (gamepad.hand === \"left\" && this._leftController != null) {\n          this._leftController.dispose();\n          this._leftController = null;\n        }\n        if (gamepad.hand === \"right\" && this._rightController != null) {\n          this._rightController.dispose();\n          this._rightController = null;\n        }\n      }\n    };\n    this._workingVector = Vector3.Zero();\n    this._workingQuaternion = Quaternion.Identity();\n    this._workingMatrix = Matrix.Identity();\n    Logger.Warn(\"WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead\");\n    this._scene = scene;\n    this._inputElement = scene.getEngine().getInputElement();\n    // check for VR support:\n    const vrSupported = (\"getVRDisplays\" in navigator);\n    // no VR support? force XR but only when it is not set because web vr can work without the getVRDisplays\n    if (!vrSupported && webVROptions.useXR === undefined) {\n      webVROptions.useXR = true;\n    }\n    // Parse options\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {\n      webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;\n    }\n    if (webVROptions.createDeviceOrientationCamera === undefined) {\n      webVROptions.createDeviceOrientationCamera = true;\n    }\n    if (webVROptions.laserToggle === undefined) {\n      webVROptions.laserToggle = true;\n    }\n    if (webVROptions.defaultHeight === undefined) {\n      webVROptions.defaultHeight = 1.7;\n    }\n    if (webVROptions.useCustomVRButton) {\n      this._useCustomVRButton = true;\n      if (webVROptions.customVRButton) {\n        this._btnVR = webVROptions.customVRButton;\n      }\n    }\n    if (webVROptions.rayLength) {\n      this._rayLength = webVROptions.rayLength;\n    }\n    this._defaultHeight = webVROptions.defaultHeight;\n    if (webVROptions.positionScale) {\n      this._rayLength *= webVROptions.positionScale;\n      this._defaultHeight *= webVROptions.positionScale;\n    }\n    this._hasEnteredVR = false;\n    // Set position\n    if (this._scene.activeCamera) {\n      this._position = this._scene.activeCamera.position.clone();\n    } else {\n      this._position = new Vector3(0, this._defaultHeight, 0);\n    }\n    // Set non-vr camera\n    if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {\n      this._deviceOrientationCamera = new DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), scene);\n      // Copy data from existing camera\n      if (this._scene.activeCamera) {\n        this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n        this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;\n        // Set rotation from previous camera\n        if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {\n          const targetCamera = this._scene.activeCamera;\n          if (targetCamera.rotationQuaternion) {\n            this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);\n          } else {\n            this._deviceOrientationCamera.rotationQuaternion.copyFrom(Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z));\n          }\n          this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();\n        }\n      }\n      this._scene.activeCamera = this._deviceOrientationCamera;\n      if (this._inputElement) {\n        this._scene.activeCamera.attachControl();\n      }\n    } else {\n      this._existingCamera = this._scene.activeCamera;\n    }\n    if (this.webVROptions.useXR && navigator.xr) {\n      // force-check XR session support\n      WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\").then(supported => {\n        if (supported) {\n          Logger.Log(\"Using WebXR. It is recommended to use the WebXRDefaultExperience directly\");\n          // it is possible to use XR, let's do it!\n          scene.createDefaultXRExperienceAsync({\n            floorMeshes: webVROptions.floorMeshes || []\n          }).then(xr => {\n            this.xr = xr;\n            // connect observables\n            this.xrTestDone = true;\n            this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\n              return this.xr.baseExperience.camera;\n            }, scene);\n            this.xr.baseExperience.onStateChangedObservable.add(state => {\n              // support for entering / exiting\n              switch (state) {\n                case WebXRState.ENTERING_XR:\n                  this.onEnteringVRObservable.notifyObservers(this);\n                  if (!this._interactionsEnabled) {\n                    this.xr.pointerSelection.detach();\n                  }\n                  this.xr.pointerSelection.displayLaserPointer = this._displayLaserPointer;\n                  break;\n                case WebXRState.EXITING_XR:\n                  this.onExitingVRObservable.notifyObservers(this);\n                  // resize to update width and height when exiting vr exits fullscreen\n                  this._scene.getEngine().resize();\n                  break;\n                case WebXRState.IN_XR:\n                  this._hasEnteredVR = true;\n                  break;\n                case WebXRState.NOT_IN_XR:\n                  this._hasEnteredVR = false;\n                  break;\n              }\n            });\n          });\n        } else {\n          // XR not supported (thou exists), continue WebVR init\n          this._completeVRInit(scene, webVROptions);\n        }\n      });\n    } else {\n      // no XR, continue init synchronous\n      this._completeVRInit(scene, webVROptions);\n    }\n  }\n  /** Return this.onEnteringVRObservable\n   * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly\n   */\n  get onEnteringVR() {\n    return this.onEnteringVRObservable;\n  }\n  /** Return this.onExitingVRObservable\n   * Note: This one is for backward compatibility. Please use onExitingVRObservable directly\n   */\n  get onExitingVR() {\n    return this.onExitingVRObservable;\n  }\n  /** Return this.onControllerMeshLoadedObservable\n   * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly\n   */\n  get onControllerMeshLoaded() {\n    return this.onControllerMeshLoadedObservable;\n  }\n  /**\n   * The mesh used to display where the user is going to teleport.\n   */\n  get teleportationTarget() {\n    return this._teleportationTarget;\n  }\n  /**\n   * Sets the mesh to be used to display where the user is going to teleport.\n   */\n  set teleportationTarget(value) {\n    if (value) {\n      value.name = \"teleportationTarget\";\n      this._isDefaultTeleportationTarget = false;\n      this._teleportationTarget = value;\n    }\n  }\n  /**\n   * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller\n   * when set bakeCurrentTransformIntoVertices will be called on the mesh.\n   * See https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\n   */\n  get gazeTrackerMesh() {\n    return this._cameraGazer._gazeTracker;\n  }\n  set gazeTrackerMesh(value) {\n    if (value) {\n      // Dispose of existing meshes\n      if (this._cameraGazer._gazeTracker) {\n        this._cameraGazer._gazeTracker.dispose();\n      }\n      if (this._leftController && this._leftController._gazeTracker) {\n        this._leftController._gazeTracker.dispose();\n      }\n      if (this._rightController && this._rightController._gazeTracker) {\n        this._rightController._gazeTracker.dispose();\n      }\n      // Set and create gaze trackers on head and controllers\n      this._cameraGazer._gazeTracker = value;\n      this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();\n      this._cameraGazer._gazeTracker.isPickable = false;\n      this._cameraGazer._gazeTracker.isVisible = false;\n      this._cameraGazer._gazeTracker.name = \"gazeTracker\";\n      if (this._leftController) {\n        this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\");\n      }\n      if (this._rightController) {\n        this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\");\n      }\n    }\n  }\n  /**\n   * The gaze tracking mesh corresponding to the left controller\n   */\n  get leftControllerGazeTrackerMesh() {\n    if (this._leftController) {\n      return this._leftController._gazeTracker;\n    }\n    return null;\n  }\n  /**\n   * The gaze tracking mesh corresponding to the right controller\n   */\n  get rightControllerGazeTrackerMesh() {\n    if (this._rightController) {\n      return this._rightController._gazeTracker;\n    }\n    return null;\n  }\n  /**\n   * If the ray of the gaze should be displayed.\n   */\n  get displayGaze() {\n    return this._displayGaze;\n  }\n  /**\n   * Sets if the ray of the gaze should be displayed.\n   */\n  set displayGaze(value) {\n    this._displayGaze = value;\n    if (!value) {\n      this._cameraGazer._gazeTracker.isVisible = false;\n      if (this._leftController) {\n        this._leftController._gazeTracker.isVisible = false;\n      }\n      if (this._rightController) {\n        this._rightController._gazeTracker.isVisible = false;\n      }\n    }\n  }\n  /**\n   * If the ray of the LaserPointer should be displayed.\n   */\n  get displayLaserPointer() {\n    return this._displayLaserPointer;\n  }\n  /**\n   * Sets if the ray of the LaserPointer should be displayed.\n   */\n  set displayLaserPointer(value) {\n    this._displayLaserPointer = value;\n    if (!value) {\n      if (this._rightController) {\n        this._rightController._deactivatePointer();\n        this._rightController._gazeTracker.isVisible = false;\n      }\n      if (this._leftController) {\n        this._leftController._deactivatePointer();\n        this._leftController._gazeTracker.isVisible = false;\n      }\n    } else {\n      if (this._rightController) {\n        this._rightController._activatePointer();\n      }\n      if (this._leftController) {\n        this._leftController._activatePointer();\n      }\n    }\n  }\n  /**\n   * The deviceOrientationCamera used as the camera when not in VR.\n   */\n  get deviceOrientationCamera() {\n    return this._deviceOrientationCamera;\n  }\n  /**\n   * Based on the current WebVR support, returns the current VR camera used.\n   */\n  get currentVRCamera() {\n    if (this._webVRready) {\n      return this._webVRCamera;\n    } else {\n      return this._scene.activeCamera;\n    }\n  }\n  /**\n   * The webVRCamera which is used when in VR.\n   */\n  get webVRCamera() {\n    return this._webVRCamera;\n  }\n  /**\n   * The deviceOrientationCamera that is used as a fallback when vr device is not connected.\n   */\n  get vrDeviceOrientationCamera() {\n    return this._vrDeviceOrientationCamera;\n  }\n  /**\n   * The html button that is used to trigger entering into VR.\n   */\n  get vrButton() {\n    return this._btnVR;\n  }\n  get _teleportationRequestInitiated() {\n    const result = this._cameraGazer._teleportationRequestInitiated || this._leftController !== null && this._leftController._teleportationRequestInitiated || this._rightController !== null && this._rightController._teleportationRequestInitiated;\n    return result;\n  }\n  _completeVRInit(scene, webVROptions) {\n    this.xrTestDone = true;\n    // Create VR cameras\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n      if (webVROptions.useMultiview) {\n        if (!webVROptions.vrDeviceOrientationCameraMetrics) {\n          webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();\n        }\n        webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;\n      }\n      this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera(\"VRDeviceOrientationVRHelper\", this._position, this._scene, true, webVROptions.vrDeviceOrientationCameraMetrics);\n      this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n    }\n    this._webVRCamera = new WebVRFreeCamera(\"WebVRHelper\", this._position, this._scene, webVROptions);\n    this._webVRCamera.useStandingMatrix();\n    this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\n      return this.currentVRCamera;\n    }, scene);\n    // Create default button\n    if (!this._useCustomVRButton) {\n      this._btnVR = document.createElement(\"BUTTON\");\n      this._btnVR.className = \"babylonVRicon\";\n      this._btnVR.id = \"babylonVRiconbtn\";\n      this._btnVR.title = \"Click to switch to VR\";\n      const url = !window.SVGSVGElement ? \"https://cdn.babylonjs.com/Assets/vrButton.png\" : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\n      let css = \".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" + url + \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\n      css += \".babylonVRicon.vrdisplaypresenting { display: none; }\";\n      // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)\n      // css += \".babylonVRicon.vrdisplaysupported { }\";\n      // css += \".babylonVRicon.vrdisplayready { }\";\n      // css += \".babylonVRicon.vrdisplayrequesting { }\";\n      const style = document.createElement(\"style\");\n      style.appendChild(document.createTextNode(css));\n      document.getElementsByTagName(\"head\")[0].appendChild(style);\n      this._moveButtonToBottomRight();\n    }\n    // VR button click event\n    if (this._btnVR) {\n      this._btnVR.addEventListener(\"click\", () => {\n        if (!this.isInVRMode) {\n          this.enterVR();\n        } else {\n          this._scene.getEngine().disableVR();\n        }\n      });\n    }\n    // Window events\n    const hostWindow = this._scene.getEngine().getHostWindow();\n    if (!hostWindow) {\n      return;\n    }\n    hostWindow.addEventListener(\"resize\", this._onResize);\n    document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\n    // Display vr button when headset is connected\n    if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\n      this._displayVRButton();\n    } else {\n      this._scene.getEngine().onVRDisplayChangedObservable.add(e => {\n        if (e.vrDisplay) {\n          this._displayVRButton();\n        }\n      });\n    }\n    // Exiting VR mode using 'ESC' key on desktop\n    this._onKeyDown = event => {\n      if (event.keyCode === 27 && this.isInVRMode) {\n        this.exitVR();\n      }\n    };\n    document.addEventListener(\"keydown\", this._onKeyDown);\n    // Exiting VR mode double tapping the touch screen\n    this._scene.onPrePointerObservable.add(() => {\n      if (this._hasEnteredVR && this.exitVROnDoubleTap) {\n        this.exitVR();\n        if (this._fullscreenVRpresenting) {\n          this._scene.getEngine().exitFullscreen();\n        }\n      }\n    }, PointerEventTypes.POINTERDOUBLETAP, false);\n    // Listen for WebVR display changes\n    this._onVRDisplayChangedBind = eventArgs => this._onVRDisplayChanged(eventArgs);\n    this._onVrDisplayPresentChangeBind = () => this._onVrDisplayPresentChange();\n    this._onVRRequestPresentStart = () => {\n      this._webVRrequesting = true;\n      this._updateButtonVisibility();\n    };\n    this._onVRRequestPresentComplete = () => {\n      this._webVRrequesting = false;\n      this._updateButtonVisibility();\n    };\n    scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChangedBind);\n    scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);\n    scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);\n    hostWindow.addEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\n    scene.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n    // Gamepad connection events\n    this._webVRCamera.onControllerMeshLoadedObservable.add(webVRController => this._onDefaultMeshLoaded(webVRController));\n    this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);\n    this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);\n    this._updateButtonVisibility();\n    //create easing functions\n    this._circleEase = new CircleEase();\n    this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    this._teleportationEasing = this._circleEase;\n    // Allow clicking in the vrDeviceOrientationCamera\n    scene.onPointerObservable.add(e => {\n      if (this._interactionsEnabled) {\n        if (scene.activeCamera === this.vrDeviceOrientationCamera && e.event.pointerType === \"mouse\") {\n          if (e.type === PointerEventTypes.POINTERDOWN) {\n            this._cameraGazer._selectionPointerDown();\n          } else if (e.type === PointerEventTypes.POINTERUP) {\n            this._cameraGazer._selectionPointerUp();\n          }\n        }\n      }\n    });\n    if (this.webVROptions.floorMeshes) {\n      this.enableTeleportation({\n        floorMeshes: this.webVROptions.floorMeshes\n      });\n    }\n  }\n  // Raised when one of the controller has loaded successfully its associated default mesh\n  _onDefaultMeshLoaded(webVRController) {\n    if (this._leftController && this._leftController.webVRController == webVRController) {\n      if (webVRController.mesh) {\n        this._leftController._setLaserPointerParent(webVRController.mesh);\n      }\n    }\n    if (this._rightController && this._rightController.webVRController == webVRController) {\n      if (webVRController.mesh) {\n        this._rightController._setLaserPointerParent(webVRController.mesh);\n      }\n    }\n    try {\n      this.onControllerMeshLoadedObservable.notifyObservers(webVRController);\n    } catch (err) {\n      Logger.Warn(\"Error in your custom logic onControllerMeshLoaded: \" + err);\n    }\n  }\n  /**\n   * Gets a value indicating if we are currently in VR mode.\n   */\n  get isInVRMode() {\n    return this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR || this._webVRpresenting || this._fullscreenVRpresenting;\n  }\n  _onVrDisplayPresentChange() {\n    const vrDisplay = this._scene.getEngine().getVRDevice();\n    if (vrDisplay) {\n      const wasPresenting = this._webVRpresenting;\n      this._webVRpresenting = vrDisplay.isPresenting;\n      if (wasPresenting && !this._webVRpresenting) {\n        this.exitVR();\n      }\n    } else {\n      Logger.Warn(\"Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?\");\n    }\n    this._updateButtonVisibility();\n  }\n  _onVRDisplayChanged(eventArgs) {\n    this._webVRsupported = eventArgs.vrSupported;\n    this._webVRready = !!eventArgs.vrDisplay;\n    this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;\n    this._updateButtonVisibility();\n  }\n  _moveButtonToBottomRight() {\n    if (this._inputElement && !this._useCustomVRButton && this._btnVR) {\n      const rect = this._inputElement.getBoundingClientRect();\n      this._btnVR.style.top = rect.top + rect.height - 70 + \"px\";\n      this._btnVR.style.left = rect.left + rect.width - 100 + \"px\";\n    }\n  }\n  _displayVRButton() {\n    if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {\n      document.body.appendChild(this._btnVR);\n      this._btnVRDisplayed = true;\n    }\n  }\n  _updateButtonVisibility() {\n    if (!this._btnVR || this._useCustomVRButton) {\n      return;\n    }\n    this._btnVR.className = \"babylonVRicon\";\n    if (this.isInVRMode) {\n      this._btnVR.className += \" vrdisplaypresenting\";\n    } else {\n      if (this._webVRready) {\n        this._btnVR.className += \" vrdisplayready\";\n      }\n      if (this._webVRsupported) {\n        this._btnVR.className += \" vrdisplaysupported\";\n      }\n      if (this._webVRrequesting) {\n        this._btnVR.className += \" vrdisplayrequesting\";\n      }\n    }\n  }\n  /**\n   * Attempt to enter VR. If a headset is connected and ready, will request present on that.\n   * Otherwise, will use the fullscreen API.\n   */\n  enterVR() {\n    if (this.xr) {\n      this.xr.baseExperience.enterXRAsync(\"immersive-vr\", \"local-floor\", this.xr.renderTarget);\n      return;\n    }\n    if (this.onEnteringVRObservable) {\n      try {\n        this.onEnteringVRObservable.notifyObservers(this);\n      } catch (err) {\n        Logger.Warn(\"Error in your custom logic onEnteringVR: \" + err);\n      }\n    }\n    if (this._scene.activeCamera) {\n      this._position = this._scene.activeCamera.position.clone();\n      if (this.vrDeviceOrientationCamera) {\n        this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();\n        this.vrDeviceOrientationCamera.angularSensibility = 2000;\n      }\n      if (this.webVRCamera) {\n        const currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;\n        const desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;\n        const delta = desiredYRotation - currentYRotation;\n        const currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;\n        this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);\n      }\n      // make sure that we return to the last active camera\n      this._existingCamera = this._scene.activeCamera;\n      // Remove and cache angular sensability to avoid camera rotation when in VR\n      if (this._existingCamera.angularSensibilityX) {\n        this._cachedAngularSensibility.angularSensibilityX = this._existingCamera.angularSensibilityX;\n        this._existingCamera.angularSensibilityX = Number.MAX_VALUE;\n      }\n      if (this._existingCamera.angularSensibilityY) {\n        this._cachedAngularSensibility.angularSensibilityY = this._existingCamera.angularSensibilityY;\n        this._existingCamera.angularSensibilityY = Number.MAX_VALUE;\n      }\n      if (this._existingCamera.angularSensibility) {\n        this._cachedAngularSensibility.angularSensibility = this._existingCamera.angularSensibility;\n        this._existingCamera.angularSensibility = Number.MAX_VALUE;\n      }\n    }\n    if (this._webVRrequesting) {\n      return;\n    }\n    // If WebVR is supported and a headset is connected\n    if (this._webVRready) {\n      if (!this._webVRpresenting) {\n        this._scene.getEngine().onVRRequestPresentComplete.addOnce(result => {\n          this.onAfterEnteringVRObservable.notifyObservers({\n            success: result\n          });\n        });\n        this._webVRCamera.position = this._position;\n        this._scene.activeCamera = this._webVRCamera;\n      }\n    } else if (this._vrDeviceOrientationCamera) {\n      this._vrDeviceOrientationCamera.position = this._position;\n      if (this._scene.activeCamera) {\n        this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\n      }\n      this._scene.activeCamera = this._vrDeviceOrientationCamera;\n      this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);\n      this._updateButtonVisibility();\n      this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(() => {\n        this.onAfterEnteringVRObservable.notifyObservers({\n          success: true\n        });\n      });\n    }\n    if (this._scene.activeCamera && this._inputElement) {\n      this._scene.activeCamera.attachControl();\n    }\n    if (this._interactionsEnabled) {\n      this._scene.registerBeforeRender(this._beforeRender);\n    }\n    if (this._displayLaserPointer) {\n      [this._leftController, this._rightController].forEach(controller => {\n        if (controller) {\n          controller._activatePointer();\n        }\n      });\n    }\n    this._hasEnteredVR = true;\n  }\n  /**\n   * Attempt to exit VR, or fullscreen.\n   */\n  exitVR() {\n    if (this.xr) {\n      this.xr.baseExperience.exitXRAsync();\n      return;\n    }\n    if (this._hasEnteredVR) {\n      if (this.onExitingVRObservable) {\n        try {\n          this.onExitingVRObservable.notifyObservers(this);\n        } catch (err) {\n          Logger.Warn(\"Error in your custom logic onExitingVR: \" + err);\n        }\n      }\n      if (this._webVRpresenting) {\n        this._scene.getEngine().disableVR();\n      }\n      if (this._scene.activeCamera) {\n        this._position = this._scene.activeCamera.position.clone();\n      }\n      if (this.vrDeviceOrientationCamera) {\n        this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\n      }\n      if (this._deviceOrientationCamera) {\n        this._deviceOrientationCamera.position = this._position;\n        this._scene.activeCamera = this._deviceOrientationCamera;\n        // Restore angular sensibility\n        if (this._cachedAngularSensibility.angularSensibilityX) {\n          this._deviceOrientationCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n          this._cachedAngularSensibility.angularSensibilityX = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibilityY) {\n          this._deviceOrientationCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n          this._cachedAngularSensibility.angularSensibilityY = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibility) {\n          this._deviceOrientationCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n          this._cachedAngularSensibility.angularSensibility = null;\n        }\n      } else if (this._existingCamera) {\n        this._existingCamera.position = this._position;\n        this._scene.activeCamera = this._existingCamera;\n        if (this._inputElement) {\n          this._scene.activeCamera.attachControl();\n        }\n        // Restore angular sensibility\n        if (this._cachedAngularSensibility.angularSensibilityX) {\n          this._existingCamera.angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\n          this._cachedAngularSensibility.angularSensibilityX = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibilityY) {\n          this._existingCamera.angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\n          this._cachedAngularSensibility.angularSensibilityY = null;\n        }\n        if (this._cachedAngularSensibility.angularSensibility) {\n          this._existingCamera.angularSensibility = this._cachedAngularSensibility.angularSensibility;\n          this._cachedAngularSensibility.angularSensibility = null;\n        }\n      }\n      this._updateButtonVisibility();\n      if (this._interactionsEnabled) {\n        this._scene.unregisterBeforeRender(this._beforeRender);\n        this._cameraGazer._gazeTracker.isVisible = false;\n        if (this._leftController) {\n          this._leftController._gazeTracker.isVisible = false;\n        }\n        if (this._rightController) {\n          this._rightController._gazeTracker.isVisible = false;\n        }\n      }\n      // resize to update width and height when exiting vr exits fullscreen\n      this._scene.getEngine().resize();\n      [this._leftController, this._rightController].forEach(controller => {\n        if (controller) {\n          controller._deactivatePointer();\n        }\n      });\n      this._hasEnteredVR = false;\n      // Update engine state to re enable non-vr camera input\n      const engine = this._scene.getEngine();\n      if (engine._onVrDisplayPresentChange) {\n        engine._onVrDisplayPresentChange();\n      }\n    }\n  }\n  /**\n   * The position of the vr experience helper.\n   */\n  get position() {\n    return this._position;\n  }\n  /**\n   * Sets the position of the vr experience helper.\n   */\n  set position(value) {\n    this._position = value;\n    if (this._scene.activeCamera) {\n      this._scene.activeCamera.position = value;\n    }\n  }\n  /**\n   * Enables controllers and user interactions such as selecting and object or clicking on an object.\n   */\n  enableInteractions() {\n    if (!this._interactionsEnabled) {\n      this._interactionsRequested = true;\n      // in XR it is enabled by default, but just to make sure, re-attach\n      if (this.xr) {\n        if (this.xr.baseExperience.state === WebXRState.IN_XR) {\n          this.xr.pointerSelection.attach();\n        }\n        return;\n      }\n      if (this._leftController) {\n        this._enableInteractionOnController(this._leftController);\n      }\n      if (this._rightController) {\n        this._enableInteractionOnController(this._rightController);\n      }\n      this.raySelectionPredicate = mesh => {\n        return mesh.isVisible && (mesh.isPickable || mesh.name === this._floorMeshName);\n      };\n      this.meshSelectionPredicate = () => {\n        return true;\n      };\n      this._raySelectionPredicate = mesh => {\n        if (this._isTeleportationFloor(mesh) || mesh.name.indexOf(\"gazeTracker\") === -1 && mesh.name.indexOf(\"teleportationTarget\") === -1 && mesh.name.indexOf(\"torusTeleportation\") === -1) {\n          return this.raySelectionPredicate(mesh);\n        }\n        return false;\n      };\n      this._interactionsEnabled = true;\n    }\n  }\n  get _noControllerIsActive() {\n    return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);\n  }\n  _isTeleportationFloor(mesh) {\n    for (let i = 0; i < this._floorMeshesCollection.length; i++) {\n      if (this._floorMeshesCollection[i].id === mesh.id) {\n        return true;\n      }\n    }\n    if (this._floorMeshName && mesh.name === this._floorMeshName) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Adds a floor mesh to be used for teleportation.\n   * @param floorMesh the mesh to be used for teleportation.\n   */\n  addFloorMesh(floorMesh) {\n    if (!this._floorMeshesCollection) {\n      return;\n    }\n    if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {\n      return;\n    }\n    this._floorMeshesCollection.push(floorMesh);\n  }\n  /**\n   * Removes a floor mesh from being used for teleportation.\n   * @param floorMesh the mesh to be removed.\n   */\n  removeFloorMesh(floorMesh) {\n    if (!this._floorMeshesCollection) {\n      return;\n    }\n    const meshIndex = this._floorMeshesCollection.indexOf(floorMesh);\n    if (meshIndex !== -1) {\n      this._floorMeshesCollection.splice(meshIndex, 1);\n    }\n  }\n  /**\n   * Enables interactions and teleportation using the VR controllers and gaze.\n   * @param vrTeleportationOptions options to modify teleportation behavior.\n   */\n  enableTeleportation(vrTeleportationOptions = {}) {\n    if (!this._teleportationInitialized) {\n      this._teleportationRequested = true;\n      this.enableInteractions();\n      if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {\n        const floorMeshes = vrTeleportationOptions.floorMeshes || [];\n        if (!floorMeshes.length) {\n          const floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName);\n          if (floorMesh) {\n            floorMeshes.push(floorMesh);\n          }\n        }\n        if (this.xr) {\n          floorMeshes.forEach(mesh => {\n            this.xr.teleportation.addFloorMesh(mesh);\n          });\n          if (!this.xr.teleportation.attached) {\n            this.xr.teleportation.attach();\n          }\n          return;\n        } else if (!this.xrTestDone) {\n          const waitForXr = () => {\n            if (this.xrTestDone) {\n              this._scene.unregisterBeforeRender(waitForXr);\n              if (this.xr) {\n                if (!this.xr.teleportation.attached) {\n                  this.xr.teleportation.attach();\n                }\n              } else {\n                this.enableTeleportation(vrTeleportationOptions);\n              }\n            }\n          };\n          this._scene.registerBeforeRender(waitForXr);\n          return;\n        }\n      }\n      if (vrTeleportationOptions.floorMeshName) {\n        this._floorMeshName = vrTeleportationOptions.floorMeshName;\n      }\n      if (vrTeleportationOptions.floorMeshes) {\n        this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;\n      }\n      if (vrTeleportationOptions.teleportationMode) {\n        this._teleportationMode = vrTeleportationOptions.teleportationMode;\n      }\n      if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {\n        this._teleportationTime = vrTeleportationOptions.teleportationTime;\n      }\n      if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {\n        this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;\n      }\n      if (vrTeleportationOptions.easingFunction !== undefined) {\n        this._teleportationEasing = vrTeleportationOptions.easingFunction;\n      }\n      if (this._leftController != null) {\n        this._enableTeleportationOnController(this._leftController);\n      }\n      if (this._rightController != null) {\n        this._enableTeleportationOnController(this._rightController);\n      }\n      // Creates an image processing post process for the vignette not relying\n      // on the main scene configuration for image processing to reduce setup and spaces\n      // (gamma/linear) conflicts.\n      const imageProcessingConfiguration = new ImageProcessingConfiguration();\n      imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);\n      imageProcessingConfiguration.vignetteEnabled = true;\n      this._postProcessMove = new ImageProcessingPostProcess(\"postProcessMove\", 1.0, this._webVRCamera, undefined, undefined, undefined, undefined, imageProcessingConfiguration);\n      this._webVRCamera.detachPostProcess(this._postProcessMove);\n      this._teleportationInitialized = true;\n      if (this._isDefaultTeleportationTarget) {\n        this._createTeleportationCircles();\n        this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);\n      }\n    }\n  }\n  _enableInteractionOnController(controller) {\n    const controllerMesh = controller.webVRController.mesh;\n    if (controllerMesh) {\n      controller._interactionsEnabled = true;\n      if (this.isInVRMode && this._displayLaserPointer) {\n        controller._activatePointer();\n      }\n      if (this.webVROptions.laserToggle) {\n        controller.webVRController.onMainButtonStateChangedObservable.add(stateObject => {\n          // Enabling / disabling laserPointer\n          if (this._displayLaserPointer && stateObject.value === 1) {\n            if (controller._activePointer) {\n              controller._deactivatePointer();\n            } else {\n              controller._activatePointer();\n            }\n            if (this.displayGaze) {\n              controller._gazeTracker.isVisible = controller._activePointer;\n            }\n          }\n        });\n      }\n      controller.webVRController.onTriggerStateChangedObservable.add(stateObject => {\n        let gazer = controller;\n        if (this._noControllerIsActive) {\n          gazer = this._cameraGazer;\n        }\n        if (!gazer._pointerDownOnMeshAsked) {\n          if (stateObject.value > this._padSensibilityUp) {\n            gazer._selectionPointerDown();\n          }\n        } else if (stateObject.value < this._padSensibilityDown) {\n          gazer._selectionPointerUp();\n        }\n      });\n    }\n  }\n  _checkTeleportWithRay(stateObject, gazer) {\n    // Dont teleport if another gaze already requested teleportation\n    if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {\n      return;\n    }\n    if (!gazer._teleportationRequestInitiated) {\n      if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._activatePointer();\n        gazer._teleportationRequestInitiated = true;\n      }\n    } else {\n      // Listening to the proper controller values changes to confirm teleportation\n      if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {\n        if (this._teleportActive) {\n          this.teleportCamera(this._haloCenter);\n        }\n        gazer._teleportationRequestInitiated = false;\n      }\n    }\n  }\n  _checkRotate(stateObject, gazer) {\n    // Only rotate when user is not currently selecting a teleportation location\n    if (gazer._teleportationRequestInitiated) {\n      return;\n    }\n    if (!gazer._rotationLeftAsked) {\n      if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._rotationLeftAsked = true;\n        if (this._rotationAllowed) {\n          this._rotateCamera(false);\n        }\n      }\n    } else {\n      if (stateObject.x > -this._padSensibilityDown) {\n        gazer._rotationLeftAsked = false;\n      }\n    }\n    if (!gazer._rotationRightAsked) {\n      if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {\n        gazer._rotationRightAsked = true;\n        if (this._rotationAllowed) {\n          this._rotateCamera(true);\n        }\n      }\n    } else {\n      if (stateObject.x < this._padSensibilityDown) {\n        gazer._rotationRightAsked = false;\n      }\n    }\n  }\n  _checkTeleportBackwards(stateObject, gazer) {\n    // Only teleport backwards when user is not currently selecting a teleportation location\n    if (gazer._teleportationRequestInitiated) {\n      return;\n    }\n    // Teleport backwards\n    if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {\n      if (!gazer._teleportationBackRequestInitiated) {\n        if (!this.currentVRCamera) {\n          return;\n        }\n        // Get rotation and position of the current camera\n        let rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());\n        let position = this.currentVRCamera.position;\n        // If the camera has device position, use that instead\n        if (this.currentVRCamera.devicePosition && this.currentVRCamera.deviceRotationQuaternion) {\n          rotation = this.currentVRCamera.deviceRotationQuaternion;\n          position = this.currentVRCamera.devicePosition;\n        }\n        // Get matrix with only the y rotation of the device rotation\n        rotation.toEulerAnglesToRef(this._workingVector);\n        this._workingVector.z = 0;\n        this._workingVector.x = 0;\n        Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);\n        this._workingQuaternion.toRotationMatrix(this._workingMatrix);\n        // Rotate backwards ray by device rotation to cast at the ground behind the user\n        Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);\n        // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff\n        const ray = new Ray(position, this._workingVector);\n        const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n        if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {\n          this.teleportCamera(hit.pickedPoint);\n        }\n        gazer._teleportationBackRequestInitiated = true;\n      }\n    } else {\n      gazer._teleportationBackRequestInitiated = false;\n    }\n  }\n  _enableTeleportationOnController(controller) {\n    const controllerMesh = controller.webVRController.mesh;\n    if (controllerMesh) {\n      if (!controller._interactionsEnabled) {\n        this._enableInteractionOnController(controller);\n      }\n      controller._interactionsEnabled = true;\n      controller._teleportationEnabled = true;\n      if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {\n        controller._dpadPressed = false;\n        controller.webVRController.onPadStateChangedObservable.add(stateObject => {\n          controller._dpadPressed = stateObject.pressed;\n          if (!controller._dpadPressed) {\n            controller._rotationLeftAsked = false;\n            controller._rotationRightAsked = false;\n            controller._teleportationBackRequestInitiated = false;\n          }\n        });\n      }\n      controller.webVRController.onPadValuesChangedObservable.add(stateObject => {\n        if (this.teleportationEnabled) {\n          this._checkTeleportBackwards(stateObject, controller);\n          this._checkTeleportWithRay(stateObject, controller);\n        }\n        this._checkRotate(stateObject, controller);\n      });\n    }\n  }\n  _createTeleportationCircles() {\n    this._teleportationTarget = CreateGround(\"teleportationTarget\", {\n      width: 2,\n      height: 2,\n      subdivisions: 2\n    }, this._scene);\n    this._teleportationTarget.isPickable = false;\n    const length = 512;\n    const dynamicTexture = new DynamicTexture(\"DynamicTexture\", length, this._scene, true);\n    dynamicTexture.hasAlpha = true;\n    const context = dynamicTexture.getContext();\n    const centerX = length / 2;\n    const centerY = length / 2;\n    const radius = 200;\n    context.beginPath();\n    context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\n    context.fillStyle = this._teleportationFillColor;\n    context.fill();\n    context.lineWidth = 10;\n    context.strokeStyle = this._teleportationBorderColor;\n    context.stroke();\n    context.closePath();\n    dynamicTexture.update();\n    const teleportationCircleMaterial = new StandardMaterial(\"TextPlaneMaterial\", this._scene);\n    teleportationCircleMaterial.diffuseTexture = dynamicTexture;\n    this._teleportationTarget.material = teleportationCircleMaterial;\n    const torus = CreateTorus(\"torusTeleportation\", {\n      diameter: 0.75,\n      thickness: 0.1,\n      tessellation: 25,\n      updatable: false\n    }, this._scene);\n    torus.isPickable = false;\n    torus.parent = this._teleportationTarget;\n    const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\n    const keys = [];\n    keys.push({\n      frame: 0,\n      value: 0\n    });\n    keys.push({\n      frame: 30,\n      value: 0.4\n    });\n    keys.push({\n      frame: 60,\n      value: 0\n    });\n    animationInnerCircle.setKeys(keys);\n    const easingFunction = new SineEase();\n    easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\n    animationInnerCircle.setEasingFunction(easingFunction);\n    torus.animations = [];\n    torus.animations.push(animationInnerCircle);\n    this._scene.beginAnimation(torus, 0, 60, true);\n    this._hideTeleportationTarget();\n  }\n  _displayTeleportationTarget() {\n    this._teleportActive = true;\n    if (this._teleportationInitialized) {\n      this._teleportationTarget.isVisible = true;\n      if (this._isDefaultTeleportationTarget) {\n        this._teleportationTarget.getChildren()[0].isVisible = true;\n      }\n    }\n  }\n  _hideTeleportationTarget() {\n    this._teleportActive = false;\n    if (this._teleportationInitialized) {\n      this._teleportationTarget.isVisible = false;\n      if (this._isDefaultTeleportationTarget) {\n        this._teleportationTarget.getChildren()[0].isVisible = false;\n      }\n    }\n  }\n  _rotateCamera(right) {\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n    if (right) {\n      this._rotationAngle++;\n    } else {\n      this._rotationAngle--;\n    }\n    this.currentVRCamera.animations = [];\n    const target = Quaternion.FromRotationMatrix(Matrix.RotationY(Math.PI / 4 * this._rotationAngle));\n    const animationRotation = new Animation(\"animationRotation\", \"rotationQuaternion\", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const animationRotationKeys = [];\n    animationRotationKeys.push({\n      frame: 0,\n      value: this.currentVRCamera.rotationQuaternion\n    });\n    animationRotationKeys.push({\n      frame: 6,\n      value: target\n    });\n    animationRotation.setKeys(animationRotationKeys);\n    animationRotation.setEasingFunction(this._circleEase);\n    this.currentVRCamera.animations.push(animationRotation);\n    this._postProcessMove.animations = [];\n    const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteWeightKeys = [];\n    vignetteWeightKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteWeightKeys.push({\n      frame: 3,\n      value: 4\n    });\n    vignetteWeightKeys.push({\n      frame: 6,\n      value: 0\n    });\n    animationPP.setKeys(vignetteWeightKeys);\n    animationPP.setEasingFunction(this._circleEase);\n    this._postProcessMove.animations.push(animationPP);\n    const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteStretchKeys = [];\n    vignetteStretchKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteStretchKeys.push({\n      frame: 3,\n      value: 10\n    });\n    vignetteStretchKeys.push({\n      frame: 6,\n      value: 0\n    });\n    animationPP2.setKeys(vignetteStretchKeys);\n    animationPP2.setEasingFunction(this._circleEase);\n    this._postProcessMove.animations.push(animationPP2);\n    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n    this._postProcessMove.samples = 4;\n    this._webVRCamera.attachPostProcess(this._postProcessMove);\n    this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, () => {\n      this._webVRCamera.detachPostProcess(this._postProcessMove);\n    });\n    this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);\n  }\n  _moveTeleportationSelectorTo(hit, gazer, ray) {\n    if (hit.pickedPoint) {\n      if (gazer._teleportationRequestInitiated) {\n        this._displayTeleportationTarget();\n        this._haloCenter.copyFrom(hit.pickedPoint);\n        this._teleportationTarget.position.copyFrom(hit.pickedPoint);\n      }\n      const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);\n      if (pickNormal) {\n        const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n        const axis2 = Vector3.Cross(pickNormal, axis1);\n        Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);\n      }\n      this._teleportationTarget.position.y += 0.1;\n    }\n  }\n  /**\n   * Teleports the users feet to the desired location\n   * @param location The location where the user's feet should be placed\n   */\n  teleportCamera(location) {\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n    // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the\n    // offset of the headset from the anchor.\n    if (this.webVRCamera.leftCamera) {\n      this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);\n      this._workingVector.subtractInPlace(this.webVRCamera.position);\n      location.subtractToRef(this._workingVector, this._workingVector);\n    } else {\n      this._workingVector.copyFrom(location);\n    }\n    // Add height to account for user's height offset\n    if (this.isInVRMode) {\n      this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;\n    } else {\n      this._workingVector.y += this._defaultHeight;\n    }\n    this.onBeforeCameraTeleport.notifyObservers(this._workingVector);\n    // Animations FPS\n    const FPS = 90;\n    let speedRatio, lastFrame;\n    if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {\n      lastFrame = FPS;\n      const dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);\n      speedRatio = this._teleportationSpeed / dist;\n    } else {\n      // teleportationMode is TELEPORTATIONMODE_CONSTANTTIME\n      lastFrame = Math.round(this._teleportationTime * FPS / 1000);\n      speedRatio = 1;\n    }\n    // Create animation from the camera's position to the new location\n    this.currentVRCamera.animations = [];\n    const animationCameraTeleportation = new Animation(\"animationCameraTeleportation\", \"position\", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const animationCameraTeleportationKeys = [{\n      frame: 0,\n      value: this.currentVRCamera.position\n    }, {\n      frame: lastFrame,\n      value: this._workingVector\n    }];\n    animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);\n    animationCameraTeleportation.setEasingFunction(this._teleportationEasing);\n    this.currentVRCamera.animations.push(animationCameraTeleportation);\n    this._postProcessMove.animations = [];\n    // Calculate the mid frame for vignette animations\n    const midFrame = Math.round(lastFrame / 2);\n    const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteWeightKeys = [];\n    vignetteWeightKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteWeightKeys.push({\n      frame: midFrame,\n      value: 8\n    });\n    vignetteWeightKeys.push({\n      frame: lastFrame,\n      value: 0\n    });\n    animationPP.setKeys(vignetteWeightKeys);\n    this._postProcessMove.animations.push(animationPP);\n    const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    const vignetteStretchKeys = [];\n    vignetteStretchKeys.push({\n      frame: 0,\n      value: 0\n    });\n    vignetteStretchKeys.push({\n      frame: midFrame,\n      value: 10\n    });\n    vignetteStretchKeys.push({\n      frame: lastFrame,\n      value: 0\n    });\n    animationPP2.setKeys(vignetteStretchKeys);\n    this._postProcessMove.animations.push(animationPP2);\n    this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\n    this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\n    this._webVRCamera.attachPostProcess(this._postProcessMove);\n    this._scene.beginAnimation(this._postProcessMove, 0, lastFrame, false, speedRatio, () => {\n      this._webVRCamera.detachPostProcess(this._postProcessMove);\n    });\n    this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, () => {\n      this.onAfterCameraTeleport.notifyObservers(this._workingVector);\n    });\n    this._hideTeleportationTarget();\n  }\n  _convertNormalToDirectionOfRay(normal, ray) {\n    if (normal) {\n      const angle = Math.acos(Vector3.Dot(normal, ray.direction));\n      if (angle < Math.PI / 2) {\n        normal.scaleInPlace(-1);\n      }\n    }\n    return normal;\n  }\n  _castRayAndSelectObject(gazer) {\n    if (!(this.currentVRCamera instanceof FreeCamera)) {\n      return;\n    }\n    const ray = gazer._getForwardRay(this._rayLength);\n    const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\n    if (hit) {\n      this._scene.simulatePointerMove(hit, {\n        pointerId: gazer._id\n      });\n    }\n    gazer._currentHit = hit;\n    // Moving the gazeTracker on the mesh face targetted\n    if (hit && hit.pickedPoint) {\n      if (this._displayGaze) {\n        let multiplier = 1;\n        gazer._gazeTracker.isVisible = true;\n        if (gazer._isActionableMesh) {\n          multiplier = 3;\n        }\n        if (this.updateGazeTrackerScale) {\n          gazer._gazeTracker.scaling.x = hit.distance * multiplier;\n          gazer._gazeTracker.scaling.y = hit.distance * multiplier;\n          gazer._gazeTracker.scaling.z = hit.distance * multiplier;\n        }\n        const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray);\n        // To avoid z-fighting\n        const deltaFighting = 0.002;\n        if (pickNormal) {\n          const axis1 = Vector3.Cross(Axis.Y, pickNormal);\n          const axis2 = Vector3.Cross(pickNormal, axis1);\n          Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);\n        }\n        gazer._gazeTracker.position.copyFrom(hit.pickedPoint);\n        if (gazer._gazeTracker.position.x < 0) {\n          gazer._gazeTracker.position.x += deltaFighting;\n        } else {\n          gazer._gazeTracker.position.x -= deltaFighting;\n        }\n        if (gazer._gazeTracker.position.y < 0) {\n          gazer._gazeTracker.position.y += deltaFighting;\n        } else {\n          gazer._gazeTracker.position.y -= deltaFighting;\n        }\n        if (gazer._gazeTracker.position.z < 0) {\n          gazer._gazeTracker.position.z += deltaFighting;\n        } else {\n          gazer._gazeTracker.position.z -= deltaFighting;\n        }\n      }\n      // Changing the size of the laser pointer based on the distance from the targetted point\n      gazer._updatePointerDistance(hit.distance);\n    } else {\n      gazer._updatePointerDistance();\n      gazer._gazeTracker.isVisible = false;\n    }\n    if (hit && hit.pickedMesh) {\n      // The object selected is the floor, we're in a teleportation scenario\n      if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {\n        // Moving the teleportation area to this targetted point\n        //Raise onSelectedMeshUnselected observable if ray collided floor mesh/meshes and a non floor mesh was previously selected\n        if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {\n          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n        }\n        gazer._currentMeshSelected = null;\n        if (gazer._teleportationRequestInitiated) {\n          this._moveTeleportationSelectorTo(hit, gazer, ray);\n        }\n        return;\n      }\n      // If not, we're in a selection scenario\n      //this._teleportationAllowed = false;\n      if (hit.pickedMesh !== gazer._currentMeshSelected) {\n        if (this.meshSelectionPredicate(hit.pickedMesh)) {\n          this.onNewMeshPicked.notifyObservers(hit);\n          gazer._currentMeshSelected = hit.pickedMesh;\n          if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {\n            this.changeGazeColor(this._pickedGazeColor);\n            this.changeLaserColor(this._pickedLaserColor);\n            gazer._isActionableMesh = true;\n          } else {\n            this.changeGazeColor(this._gazeColor);\n            this.changeLaserColor(this._laserColor);\n            gazer._isActionableMesh = false;\n          }\n          try {\n            this.onNewMeshSelected.notifyObservers(hit.pickedMesh);\n            const gazerAsControllerGazer = gazer;\n            if (gazerAsControllerGazer.webVRController) {\n              this.onMeshSelectedWithController.notifyObservers({\n                mesh: hit.pickedMesh,\n                controller: gazerAsControllerGazer.webVRController\n              });\n            }\n          } catch (err) {\n            Logger.Warn(\"Error while raising onNewMeshSelected or onMeshSelectedWithController: \" + err);\n          }\n        } else {\n          this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n          gazer._currentMeshSelected = null;\n          this.changeGazeColor(this._gazeColor);\n          this.changeLaserColor(this._laserColor);\n        }\n      }\n    } else {\n      this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\n      gazer._currentMeshSelected = null;\n      //this._teleportationAllowed = false;\n      this.changeGazeColor(this._gazeColor);\n      this.changeLaserColor(this._laserColor);\n    }\n  }\n  _notifySelectedMeshUnselected(mesh) {\n    if (mesh) {\n      this.onSelectedMeshUnselected.notifyObservers(mesh);\n    }\n  }\n  /**\n   * Permanently set new colors for the laser pointer\n   * @param color the new laser color\n   * @param pickedColor the new laser color when picked mesh detected\n   */\n  setLaserColor(color, pickedColor = this._pickedLaserColor) {\n    this._laserColor = color;\n    this._pickedLaserColor = pickedColor;\n  }\n  /**\n   * Set lighting enabled / disabled on the laser pointer of both controllers\n   * @param enabled should the lighting be enabled on the laser pointer\n   */\n  setLaserLightingState(enabled = true) {\n    if (this._leftController) {\n      this._leftController._setLaserPointerLightingDisabled(!enabled);\n    }\n    if (this._rightController) {\n      this._rightController._setLaserPointerLightingDisabled(!enabled);\n    }\n  }\n  /**\n   * Permanently set new colors for the gaze pointer\n   * @param color the new gaze color\n   * @param pickedColor the new gaze color when picked mesh detected\n   */\n  setGazeColor(color, pickedColor = this._pickedGazeColor) {\n    this._gazeColor = color;\n    this._pickedGazeColor = pickedColor;\n  }\n  /**\n   * Sets the color of the laser ray from the vr controllers.\n   * @param color new color for the ray.\n   */\n  changeLaserColor(color) {\n    if (!this.updateControllerLaserColor) {\n      return;\n    }\n    if (this._leftController) {\n      this._leftController._setLaserPointerColor(color);\n    }\n    if (this._rightController) {\n      this._rightController._setLaserPointerColor(color);\n    }\n  }\n  /**\n   * Sets the color of the ray from the vr headsets gaze.\n   * @param color new color for the ray.\n   */\n  changeGazeColor(color) {\n    if (!this.updateGazeTrackerColor) {\n      return;\n    }\n    if (!this._cameraGazer._gazeTracker.material) {\n      return;\n    }\n    this._cameraGazer._gazeTracker.material.emissiveColor = color;\n    if (this._leftController) {\n      this._leftController._gazeTracker.material.emissiveColor = color;\n    }\n    if (this._rightController) {\n      this._rightController._gazeTracker.material.emissiveColor = color;\n    }\n  }\n  /**\n   * Exits VR and disposes of the vr experience helper\n   */\n  dispose() {\n    if (this.isInVRMode) {\n      this.exitVR();\n    }\n    if (this._postProcessMove) {\n      this._postProcessMove.dispose();\n    }\n    if (this._webVRCamera) {\n      this._webVRCamera.dispose();\n    }\n    if (this._vrDeviceOrientationCamera) {\n      this._vrDeviceOrientationCamera.dispose();\n    }\n    if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {\n      document.body.removeChild(this._btnVR);\n    }\n    if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {\n      this._deviceOrientationCamera.dispose();\n    }\n    if (this._cameraGazer) {\n      this._cameraGazer.dispose();\n    }\n    if (this._leftController) {\n      this._leftController.dispose();\n    }\n    if (this._rightController) {\n      this._rightController.dispose();\n    }\n    if (this._teleportationTarget) {\n      this._teleportationTarget.dispose();\n    }\n    if (this.xr) {\n      this.xr.dispose();\n    }\n    this._floorMeshesCollection.length = 0;\n    document.removeEventListener(\"keydown\", this._onKeyDown);\n    window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\n    window.removeEventListener(\"resize\", this._onResize);\n    document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n    this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChangedBind);\n    this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);\n    this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);\n    this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);\n    this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);\n    this._scene.unregisterBeforeRender(this._beforeRender);\n  }\n  /**\n   * Gets the name of the VRExperienceHelper class\n   * @returns \"VRExperienceHelper\"\n   */\n  getClassName() {\n    return \"VRExperienceHelper\";\n  }\n}\n/**\n * Time Constant Teleportation Mode\n */\nVRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME = 0;\n/**\n * Speed Constant Teleportation Mode\n */\nVRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED = 1;","map":{"version":3,"mappings":"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","names":["Logger","Observable","FreeCamera","TargetCamera","DeviceOrientationCamera","VRDeviceOrientationFreeCamera","WebVRFreeCamera","PointerEventTypes","Quaternion","Matrix","Vector3","Color3","Color4","Gamepad","PoseEnabledController","PoseEnabledControllerType","WebVRController","Xbox360Button","Mesh","Ray","ImageProcessingConfiguration","StandardMaterial","DynamicTexture","ImageProcessingPostProcess","SineEase","EasingFunction","CircleEase","Animation","VRCameraMetrics","Axis","WebXRSessionManager","WebXRState","CreateCylinder","CreateTorus","CreateGround","VRExperienceHelperGazer","constructor","scene","gazeTrackerToClone","_id","_IdCounter","_gazeTracker","diameter","thickness","tessellation","updatable","bakeCurrentTransformIntoVertices","isPickable","isVisible","targetMat","specularColor","Black","emissiveColor","backFaceCulling","material","clone","_getForwardRay","length","Zero","_selectionPointerDown","_pointerDownOnMeshAsked","_currentHit","simulatePointerDown","pointerId","_selectionPointerUp","simulatePointerUp","_activatePointer","_activePointer","_deactivatePointer","_updatePointerDistance","distance","dispose","_interactionsEnabled","_teleportationEnabled","VRExperienceHelperControllerGazer","webVRController","_laserPointer","height","diameterTop","diameterBottom","subdivisions","laserPointerMaterial","alpha","rotation","x","Math","PI","position","z","mesh","preloadMesh","preloadPointerPose","POINTING_POSE","addChild","attachToMesh","_setLaserPointerParent","_meshAttachedObserver","_meshAttachedObservable","add","getForwardRay","_setLaserPointerColor","color","_setLaserPointerLightingDisabled","disabled","disableLighting","makeNotPick","root","getChildMeshes","forEach","c","meshChildren","getChildren","undefined","laserParent","_pointingPoseNode","i","name","indexOf","parent","scaling","y","remove","VRExperienceHelperCameraGazer","_getCamera","camera","Forward","OnAfterEnteringVRObservableEvent","VRExperienceHelper","webVROptions","TELEPORTATIONMODE_CONSTANTTIME","_moveButtonToBottomRight","_fullscreenVRpresenting","_webVRready","exitVR","document","fullscreenElement","_inputElement","_useCustomVRButton","_btnVR","style","top","offsetTop","offsetHeight","left","offsetLeft","offsetWidth","_updateButtonVisibility","angularSensibilityX","angularSensibilityY","angularSensibility","_leftController","_castRayAndSelectObject","_rightController","_noControllerIsActive","_scene","getEngine","isPointerLock","enableGazeEvenWhenNoPointerLock","_cameraGazer","gamepad","type","POSE_ENABLED","leftStick","onleftstickchanged","stickValues","_teleportationInitialized","teleportationEnabled","_checkTeleportWithRay","_checkTeleportBackwards","rightStick","onrightstickchanged","_checkRotate","XBOX","onbuttondown","buttonPressed","A","onbuttonup","controller","hand","_tryEnableInteractionOnController","_interactionsRequested","_enableInteractionOnController","_teleportationRequested","_enableTeleportationOnController","Identity","Warn","getInputElement","vrSupported","navigator","useXR","createFallbackVRDeviceOrientationFreeCamera","createDeviceOrientationCamera","laserToggle","defaultHeight","useCustomVRButton","customVRButton","rayLength","_rayLength","_defaultHeight","positionScale","_hasEnteredVR","activeCamera","_position","_deviceOrientationCamera","minZ","maxZ","targetCamera","rotationQuaternion","copyFrom","RotationYawPitchRoll","attachControl","_existingCamera","xr","IsSessionSupportedAsync","then","supported","Log","createDefaultXRExperienceAsync","floorMeshes","xrTestDone","baseExperience","onStateChangedObservable","state","ENTERING_XR","onEnteringVRObservable","notifyObservers","pointerSelection","detach","displayLaserPointer","_displayLaserPointer","EXITING_XR","onExitingVRObservable","resize","IN_XR","NOT_IN_XR","_completeVRInit","onEnteringVR","onExitingVR","onControllerMeshLoaded","onControllerMeshLoadedObservable","teleportationTarget","_teleportationTarget","value","_isDefaultTeleportationTarget","gazeTrackerMesh","leftControllerGazeTrackerMesh","rightControllerGazeTrackerMesh","displayGaze","_displayGaze","deviceOrientationCamera","currentVRCamera","_webVRCamera","webVRCamera","vrDeviceOrientationCamera","_vrDeviceOrientationCamera","vrButton","_teleportationRequestInitiated","result","useMultiview","vrDeviceOrientationCameraMetrics","GetDefault","multiviewEnabled","Number","MAX_VALUE","useStandingMatrix","createElement","className","id","title","url","window","SVGSVGElement","css","appendChild","createTextNode","getElementsByTagName","addEventListener","isInVRMode","enterVR","disableVR","hostWindow","getHostWindow","_onResize","_onFullscreenChange","_displayVRButton","onVRDisplayChangedObservable","e","vrDisplay","_onKeyDown","event","keyCode","onPrePointerObservable","exitVROnDoubleTap","exitFullscreen","POINTERDOUBLETAP","_onVRDisplayChangedBind","eventArgs","_onVRDisplayChanged","_onVrDisplayPresentChangeBind","_onVrDisplayPresentChange","_onVRRequestPresentStart","_webVRrequesting","_onVRRequestPresentComplete","onVRRequestPresentStart","onVRRequestPresentComplete","onDisposeObservable","_onDefaultMeshLoaded","gamepadManager","onGamepadConnectedObservable","_onNewGamepadConnected","onGamepadDisconnectedObservable","_onNewGamepadDisconnected","_circleEase","setEasingMode","EASINGMODE_EASEINOUT","_teleportationEasing","onPointerObservable","pointerType","POINTERDOWN","POINTERUP","enableTeleportation","err","_webVRpresenting","getVRDevice","wasPresenting","isPresenting","_webVRsupported","rect","getBoundingClientRect","width","_btnVRDisplayed","body","enterXRAsync","renderTarget","FromRotationMatrix","getWorldMatrix","getRotationMatrix","toEulerAngles","currentYRotation","deviceRotationQuaternion","desiredYRotation","delta","currentGlobalRotation","FromEulerAngles","_cachedAngularSensibility","addOnce","onAfterEnteringVRObservable","success","enterFullscreen","requestPointerLockOnFullScreen","onViewMatrixChangedObservable","registerBeforeRender","_beforeRender","exitXRAsync","unregisterBeforeRender","engine","enableInteractions","attach","raySelectionPredicate","_floorMeshName","meshSelectionPredicate","_raySelectionPredicate","_isTeleportationFloor","_floorMeshesCollection","addFloorMesh","floorMesh","push","removeFloorMesh","meshIndex","splice","vrTeleportationOptions","floorMeshName","getMeshByName","teleportation","attached","waitForXr","teleportationMode","_teleportationMode","teleportationTime","_teleportationTime","teleportationSpeed","_teleportationSpeed","easingFunction","imageProcessingConfiguration","vignetteColor","vignetteEnabled","_postProcessMove","detachPostProcess","_createTeleportationCircles","scaleInPlace","deviceScaleFactor","controllerMesh","onMainButtonStateChangedObservable","stateObject","onTriggerStateChangedObservable","gazer","_padSensibilityUp","_padSensibilityDown","_dpadPressed","sqrt","_teleportActive","teleportCamera","_haloCenter","_rotationLeftAsked","_rotationAllowed","_rotateCamera","_rotationRightAsked","_teleportationBackRequestInitiated","devicePosition","toEulerAnglesToRef","_workingVector","RotationYawPitchRollToRef","_workingQuaternion","toRotationMatrix","_workingMatrix","TransformCoordinatesToRef","_teleportBackwardsVector","ray","hit","pickWithRay","pickedPoint","pickedMesh","controllerType","VIVE","onPadStateChangedObservable","pressed","onPadValuesChangedObservable","dynamicTexture","hasAlpha","context","getContext","centerX","centerY","radius","beginPath","arc","fillStyle","_teleportationFillColor","fill","lineWidth","strokeStyle","_teleportationBorderColor","stroke","closePath","update","teleportationCircleMaterial","diffuseTexture","torus","animationInnerCircle","ANIMATIONTYPE_FLOAT","ANIMATIONLOOPMODE_CYCLE","keys","frame","setKeys","setEasingFunction","animations","beginAnimation","_hideTeleportationTarget","_displayTeleportationTarget","right","_rotationAngle","target","RotationY","animationRotation","ANIMATIONTYPE_QUATERNION","ANIMATIONLOOPMODE_CONSTANT","animationRotationKeys","animationPP","vignetteWeightKeys","animationPP2","vignetteStretchKeys","vignetteWeight","vignetteStretch","samples","attachPostProcess","_moveTeleportationSelectorTo","pickNormal","_convertNormalToDirectionOfRay","getNormal","axis1","Cross","Y","axis2","RotationFromAxisToRef","location","leftCamera","globalPosition","subtractInPlace","subtractToRef","deviceDistanceToRoomGround","onBeforeCameraTeleport","FPS","speedRatio","lastFrame","TELEPORTATIONMODE_CONSTANTSPEED","dist","Distance","round","animationCameraTeleportation","ANIMATIONTYPE_VECTOR3","animationCameraTeleportationKeys","midFrame","onAfterCameraTeleport","normal","angle","acos","Dot","direction","simulatePointerMove","multiplier","_isActionableMesh","updateGazeTrackerScale","deltaFighting","_currentMeshSelected","_notifySelectedMeshUnselected","onNewMeshPicked","actionManager","changeGazeColor","_pickedGazeColor","changeLaserColor","_pickedLaserColor","_gazeColor","_laserColor","onNewMeshSelected","gazerAsControllerGazer","onMeshSelectedWithController","onSelectedMeshUnselected","setLaserColor","pickedColor","setLaserLightingState","enabled","setGazeColor","updateControllerLaserColor","updateGazeTrackerColor","parentNode","removeChild","removeEventListener","removeCallback","getClassName"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/VR/vrExperienceHelper.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../../Cameras/targetCamera\";\r\nimport { DeviceOrientationCamera } from \"../../Cameras/deviceOrientationCamera\";\r\nimport { VRDeviceOrientationFreeCamera } from \"../../Cameras/VR/vrDeviceOrientationFreeCamera\";\r\nimport type { WebVROptions } from \"../../Cameras/VR/webVRCamera\";\r\nimport { WebVRFreeCamera } from \"../../Cameras/VR/webVRCamera\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { Scene, IDisposable } from \"../../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { StickValues } from \"../../Gamepads/gamepad\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport { PoseEnabledController, PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\r\nimport { WebVRController } from \"../../Gamepads/Controllers/webVRController\";\r\nimport type { Xbox360Pad } from \"../../Gamepads/xboxGamepad\";\r\nimport { Xbox360Button } from \"../../Gamepads/xboxGamepad\";\r\nimport type { IDisplayChangedEventArgs } from \"../../Engines/engine\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { ImageProcessingConfiguration } from \"../../Materials/imageProcessingConfiguration\";\r\nimport { StandardMaterial } from \"../../Materials/standardMaterial\";\r\nimport { DynamicTexture } from \"../../Materials/Textures/dynamicTexture\";\r\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\r\nimport { SineEase, EasingFunction, CircleEase } from \"../../Animations/easing\";\r\nimport { Animation } from \"../../Animations/animation\";\r\nimport { VRCameraMetrics } from \"../../Cameras/VR/vrCameraMetrics\";\r\nimport \"../../Gamepads/gamepadSceneComponent\";\r\nimport \"../../Animations/animatable\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { WebXRSessionManager } from \"../../XR/webXRSessionManager\";\r\nimport type { WebXRDefaultExperience } from \"../../XR/webXRDefaultExperience\";\r\nimport { WebXRState } from \"../../XR/webXRTypes\";\r\nimport { CreateCylinder } from \"../../Meshes/Builders/cylinderBuilder\";\r\nimport { CreateTorus } from \"../../Meshes/Builders/torusBuilder\";\r\nimport { CreateGround } from \"../../Meshes/Builders/groundBuilder\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Options to modify the vr teleportation behavior.\r\n */\r\nexport interface VRTeleportationOptions {\r\n    /**\r\n     * The name of the mesh which should be used as the teleportation floor. (default: null)\r\n     */\r\n    floorMeshName?: string;\r\n    /**\r\n     * A list of meshes to be used as the teleportation floor. (default: empty)\r\n     */\r\n    floorMeshes?: Mesh[];\r\n    /**\r\n     * The teleportation mode. (default: TELEPORTATIONMODE_CONSTANTTIME)\r\n     */\r\n    teleportationMode?: number;\r\n    /**\r\n     * The duration of the animation in ms, apply when animationMode is TELEPORTATIONMODE_CONSTANTTIME. (default 122ms)\r\n     */\r\n    teleportationTime?: number;\r\n    /**\r\n     * The speed of the animation in distance/sec, apply when animationMode is TELEPORTATIONMODE_CONSTANTSPEED. (default 20 units / sec)\r\n     */\r\n    teleportationSpeed?: number;\r\n    /**\r\n     * The easing function used in the animation or null for Linear. (default CircleEase)\r\n     */\r\n    easingFunction?: EasingFunction;\r\n}\r\n\r\n/**\r\n * Options to modify the vr experience helper's behavior.\r\n */\r\nexport interface VRExperienceHelperOptions extends WebVROptions {\r\n    /**\r\n     * Create a DeviceOrientationCamera to be used as your out of vr camera. (default: true)\r\n     */\r\n    createDeviceOrientationCamera?: boolean;\r\n    /**\r\n     * Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found. (default: true)\r\n     */\r\n    createFallbackVRDeviceOrientationFreeCamera?: boolean;\r\n    /**\r\n     * Uses the main button on the controller to toggle the laser casted. (default: true)\r\n     */\r\n    laserToggle?: boolean;\r\n    /**\r\n     * A list of meshes to be used as the teleportation floor. If specified, teleportation will be enabled (default: undefined)\r\n     */\r\n    floorMeshes?: Mesh[];\r\n    /**\r\n     * Distortion metrics for the fallback vrDeviceOrientationCamera (default: VRCameraMetrics.Default)\r\n     */\r\n    vrDeviceOrientationCameraMetrics?: VRCameraMetrics;\r\n    /**\r\n     * Defines if WebXR should be used instead of WebVR (if available)\r\n     */\r\n    useXR?: boolean;\r\n}\r\n\r\nclass VRExperienceHelperGazer implements IDisposable {\r\n    /** @internal */\r\n    public _gazeTracker: Mesh;\r\n\r\n    /** @internal */\r\n    public _currentMeshSelected: Nullable<AbstractMesh>;\r\n    /** @internal */\r\n    public _currentHit: Nullable<PickingInfo>;\r\n\r\n    public static _IdCounter = 0;\r\n    /** @internal */\r\n    public _id: number;\r\n\r\n    /** @internal */\r\n    public _pointerDownOnMeshAsked: boolean = false;\r\n    /** @internal */\r\n    public _isActionableMesh: boolean = false;\r\n\r\n    /** @internal */\r\n    public _interactionsEnabled: boolean;\r\n    /** @internal */\r\n    public _teleportationEnabled: boolean;\r\n    /** @internal */\r\n    public _teleportationRequestInitiated = false;\r\n    /** @internal */\r\n    public _teleportationBackRequestInitiated = false;\r\n    /** @internal */\r\n    public _rotationRightAsked = false;\r\n    /** @internal */\r\n    public _rotationLeftAsked = false;\r\n    /** @internal */\r\n    public _dpadPressed = true;\r\n\r\n    /** @internal */\r\n    public _activePointer = false;\r\n\r\n    constructor(public scene: Scene, gazeTrackerToClone: Nullable<Mesh> = null) {\r\n        this._id = VRExperienceHelperGazer._IdCounter++;\r\n\r\n        // Gaze tracker\r\n        if (!gazeTrackerToClone) {\r\n            this._gazeTracker = CreateTorus(\r\n                \"gazeTracker\",\r\n                {\r\n                    diameter: 0.0035,\r\n                    thickness: 0.0025,\r\n                    tessellation: 20,\r\n                    updatable: false,\r\n                },\r\n                scene\r\n            );\r\n            this._gazeTracker.bakeCurrentTransformIntoVertices();\r\n            this._gazeTracker.isPickable = false;\r\n            this._gazeTracker.isVisible = false;\r\n            const targetMat = new StandardMaterial(\"targetMat\", scene);\r\n            targetMat.specularColor = Color3.Black();\r\n            targetMat.emissiveColor = new Color3(0.7, 0.7, 0.7);\r\n            targetMat.backFaceCulling = false;\r\n            this._gazeTracker.material = targetMat;\r\n        } else {\r\n            this._gazeTracker = gazeTrackerToClone.clone(\"gazeTracker\") as Mesh;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getForwardRay(length: number): Ray {\r\n        return new Ray(Vector3.Zero(), new Vector3(0, 0, length));\r\n    }\r\n\r\n    /** @internal */\r\n    public _selectionPointerDown() {\r\n        this._pointerDownOnMeshAsked = true;\r\n        if (this._currentHit) {\r\n            this.scene.simulatePointerDown(this._currentHit, { pointerId: this._id });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _selectionPointerUp() {\r\n        if (this._currentHit) {\r\n            this.scene.simulatePointerUp(this._currentHit, { pointerId: this._id });\r\n        }\r\n        this._pointerDownOnMeshAsked = false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _activatePointer() {\r\n        this._activePointer = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _deactivatePointer() {\r\n        this._activePointer = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _updatePointerDistance(distance: number = 100) {}\r\n\r\n    public dispose() {\r\n        this._interactionsEnabled = false;\r\n        this._teleportationEnabled = false;\r\n        if (this._gazeTracker) {\r\n            this._gazeTracker.dispose();\r\n        }\r\n    }\r\n}\r\n\r\nclass VRExperienceHelperControllerGazer extends VRExperienceHelperGazer {\r\n    private _laserPointer: Mesh;\r\n    private _meshAttachedObserver: Nullable<Observer<AbstractMesh>>;\r\n    constructor(public webVRController: WebVRController, scene: Scene, gazeTrackerToClone: Mesh) {\r\n        super(scene, gazeTrackerToClone);\r\n        // Laser pointer\r\n        this._laserPointer = CreateCylinder(\r\n            \"laserPointer\",\r\n            {\r\n                updatable: false,\r\n                height: 1,\r\n                diameterTop: 0.004,\r\n                diameterBottom: 0.0002,\r\n                tessellation: 20,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        const laserPointerMaterial = new StandardMaterial(\"laserPointerMat\", scene);\r\n        laserPointerMaterial.emissiveColor = new Color3(0.7, 0.7, 0.7);\r\n        laserPointerMaterial.alpha = 0.6;\r\n        this._laserPointer.material = laserPointerMaterial;\r\n        this._laserPointer.rotation.x = Math.PI / 2;\r\n        this._laserPointer.position.z = -0.5;\r\n        this._laserPointer.isVisible = false;\r\n        this._laserPointer.isPickable = false;\r\n\r\n        if (!webVRController.mesh) {\r\n            // Create an empty mesh that is used prior to loading the high quality model\r\n            const preloadMesh = new Mesh(\"preloadControllerMesh\", scene);\r\n            const preloadPointerPose = new Mesh(PoseEnabledController.POINTING_POSE, scene);\r\n            preloadPointerPose.rotation.x = -0.7;\r\n            preloadMesh.addChild(preloadPointerPose);\r\n            webVRController.attachToMesh(preloadMesh);\r\n        }\r\n\r\n        this._setLaserPointerParent(webVRController.mesh!);\r\n\r\n        this._meshAttachedObserver = webVRController._meshAttachedObservable.add((mesh) => {\r\n            this._setLaserPointerParent(mesh);\r\n        });\r\n    }\r\n\r\n    _getForwardRay(length: number): Ray {\r\n        return this.webVRController.getForwardRay(length);\r\n    }\r\n\r\n    /** @internal */\r\n    public _activatePointer() {\r\n        super._activatePointer();\r\n        this._laserPointer.isVisible = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _deactivatePointer() {\r\n        super._deactivatePointer();\r\n        this._laserPointer.isVisible = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setLaserPointerColor(color: Color3) {\r\n        (<StandardMaterial>this._laserPointer.material).emissiveColor = color;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setLaserPointerLightingDisabled(disabled: boolean) {\r\n        (<StandardMaterial>this._laserPointer.material).disableLighting = disabled;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setLaserPointerParent(mesh: AbstractMesh) {\r\n        const makeNotPick = (root: AbstractMesh) => {\r\n            root.isPickable = false;\r\n            root.getChildMeshes().forEach((c) => {\r\n                makeNotPick(c);\r\n            });\r\n        };\r\n        makeNotPick(mesh);\r\n        const meshChildren = mesh.getChildren(undefined, false);\r\n\r\n        let laserParent: TransformNode = mesh;\r\n        this.webVRController._pointingPoseNode = null;\r\n        for (let i = 0; i < meshChildren.length; i++) {\r\n            if (meshChildren[i].name && meshChildren[i].name.indexOf(PoseEnabledController.POINTING_POSE) >= 0) {\r\n                laserParent = <TransformNode>meshChildren[i];\r\n                this.webVRController._pointingPoseNode = laserParent;\r\n                break;\r\n            }\r\n        }\r\n        this._laserPointer.parent = laserParent;\r\n    }\r\n\r\n    public _updatePointerDistance(distance: number = 100) {\r\n        this._laserPointer.scaling.y = distance;\r\n        this._laserPointer.position.z = -distance / 2;\r\n    }\r\n\r\n    dispose() {\r\n        super.dispose();\r\n        this._laserPointer.dispose();\r\n        if (this._meshAttachedObserver) {\r\n            this.webVRController._meshAttachedObservable.remove(this._meshAttachedObserver);\r\n        }\r\n    }\r\n}\r\n\r\nclass VRExperienceHelperCameraGazer extends VRExperienceHelperGazer {\r\n    constructor(private _getCamera: () => Nullable<Camera>, scene: Scene) {\r\n        super(scene);\r\n    }\r\n\r\n    _getForwardRay(length: number): Ray {\r\n        const camera = this._getCamera();\r\n        if (camera) {\r\n            return camera.getForwardRay(length);\r\n        } else {\r\n            return new Ray(Vector3.Zero(), Vector3.Forward());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Event containing information after VR has been entered\r\n */\r\nexport class OnAfterEnteringVRObservableEvent {\r\n    /**\r\n     * If entering vr was successful\r\n     */\r\n    public success: boolean;\r\n}\r\n\r\n/**\r\n * Helps to quickly add VR support to an existing scene.\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRHelper\r\n * @deprecated\r\n */\r\nexport class VRExperienceHelper {\r\n    private _scene: Scene;\r\n    private _position: Vector3;\r\n    private _btnVR: Nullable<HTMLButtonElement>;\r\n    private _btnVRDisplayed: boolean;\r\n\r\n    // Can the system support WebVR, even if a headset isn't plugged in?\r\n    private _webVRsupported = false;\r\n    // If WebVR is supported, is a headset plugged in and are we ready to present?\r\n    private _webVRready = false;\r\n    // Are we waiting for the requestPresent callback to complete?\r\n    private _webVRrequesting = false;\r\n    // Are we presenting to the headset right now? (this is the vrDevice state)\r\n    private _webVRpresenting = false;\r\n    // Have we entered VR? (this is the VRExperienceHelper state)\r\n    private _hasEnteredVR: boolean;\r\n\r\n    // Are we presenting in the fullscreen fallback?\r\n    private _fullscreenVRpresenting = false;\r\n\r\n    private _inputElement: Nullable<HTMLElement>;\r\n    private _webVRCamera: WebVRFreeCamera;\r\n    private _vrDeviceOrientationCamera: Nullable<VRDeviceOrientationFreeCamera>;\r\n    private _deviceOrientationCamera: Nullable<DeviceOrientationCamera>;\r\n    private _existingCamera: Camera;\r\n\r\n    private _onKeyDown: (event: KeyboardEvent) => void;\r\n    private _onVrDisplayPresentChangeBind: any;\r\n    private _onVRDisplayChangedBind: (eventArgs: IDisplayChangedEventArgs) => void;\r\n    private _onVRRequestPresentStart: () => void;\r\n    private _onVRRequestPresentComplete: (success: boolean) => void;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that gaze can be enabled even if pointer lock is not engage (useful on iOS where fullscreen mode and pointer lock are not supported)\r\n     */\r\n    public enableGazeEvenWhenNoPointerLock = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the VREXperienceHelper will exit VR if double tap is detected\r\n     */\r\n    public exitVROnDoubleTap = true;\r\n\r\n    /**\r\n     * Observable raised right before entering VR.\r\n     */\r\n    public onEnteringVRObservable = new Observable<VRExperienceHelper>();\r\n\r\n    /**\r\n     * Observable raised when entering VR has completed.\r\n     */\r\n    public onAfterEnteringVRObservable = new Observable<OnAfterEnteringVRObservableEvent>();\r\n\r\n    /**\r\n     * Observable raised when exiting VR.\r\n     */\r\n    public onExitingVRObservable = new Observable<VRExperienceHelper>();\r\n\r\n    /**\r\n     * Observable raised when controller mesh is loaded.\r\n     */\r\n    public onControllerMeshLoadedObservable = new Observable<WebVRController>();\r\n\r\n    /** Return this.onEnteringVRObservable\r\n     * Note: This one is for backward compatibility. Please use onEnteringVRObservable directly\r\n     */\r\n    public get onEnteringVR(): Observable<VRExperienceHelper> {\r\n        return this.onEnteringVRObservable;\r\n    }\r\n\r\n    /** Return this.onExitingVRObservable\r\n     * Note: This one is for backward compatibility. Please use onExitingVRObservable directly\r\n     */\r\n    public get onExitingVR(): Observable<VRExperienceHelper> {\r\n        return this.onExitingVRObservable;\r\n    }\r\n\r\n    /** Return this.onControllerMeshLoadedObservable\r\n     * Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly\r\n     */\r\n    public get onControllerMeshLoaded(): Observable<WebVRController> {\r\n        return this.onControllerMeshLoadedObservable;\r\n    }\r\n\r\n    private _rayLength: number;\r\n    private _useCustomVRButton: boolean = false;\r\n    private _teleportationRequested: boolean = false;\r\n    private _teleportActive = false;\r\n    private _floorMeshName: string;\r\n    private _floorMeshesCollection: Mesh[] = [];\r\n    private _teleportationMode: number = VRExperienceHelper.TELEPORTATIONMODE_CONSTANTTIME;\r\n    private _teleportationTime: number = 122;\r\n    private _teleportationSpeed: number = 20;\r\n    private _teleportationEasing: EasingFunction;\r\n    private _rotationAllowed: boolean = true;\r\n    private _teleportBackwardsVector = new Vector3(0, -1, -1);\r\n    private _teleportationTarget: Mesh;\r\n    private _isDefaultTeleportationTarget = true;\r\n    private _postProcessMove: ImageProcessingPostProcess;\r\n    private _teleportationFillColor: string = \"#444444\";\r\n    private _teleportationBorderColor: string = \"#FFFFFF\";\r\n    private _rotationAngle: number = 0;\r\n    private _haloCenter = new Vector3(0, 0, 0);\r\n    private _cameraGazer: VRExperienceHelperCameraGazer;\r\n    private _padSensibilityUp = 0.65;\r\n    private _padSensibilityDown = 0.35;\r\n\r\n    private _leftController: Nullable<VRExperienceHelperControllerGazer> = null;\r\n    private _rightController: Nullable<VRExperienceHelperControllerGazer> = null;\r\n\r\n    private _gazeColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    private _laserColor: Color3 = new Color3(0.7, 0.7, 0.7);\r\n    private _pickedLaserColor: Color3 = new Color3(0.2, 0.2, 1);\r\n    private _pickedGazeColor: Color3 = new Color3(0, 0, 1);\r\n\r\n    /**\r\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate\r\n     */\r\n    public onNewMeshSelected = new Observable<AbstractMesh>();\r\n\r\n    /**\r\n     * Observable raised when a new mesh is selected based on meshSelectionPredicate.\r\n     * This observable will provide the mesh and the controller used to select the mesh\r\n     */\r\n    public onMeshSelectedWithController = new Observable<{ mesh: AbstractMesh; controller: WebVRController }>();\r\n\r\n    /**\r\n     * Observable raised when a new mesh is picked based on meshSelectionPredicate\r\n     */\r\n    public onNewMeshPicked = new Observable<PickingInfo>();\r\n\r\n    private _circleEase: CircleEase;\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Observable raised when current selected mesh gets unselected\r\n     */\r\n    public onSelectedMeshUnselected = new Observable<AbstractMesh>();\r\n\r\n    private _raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * To be optionally changed by user to define custom ray selection\r\n     */\r\n    public raySelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * To be optionally changed by user to define custom selection logic (after ray selection)\r\n     */\r\n    public meshSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.\r\n     */\r\n    public teleportationEnabled: boolean = true;\r\n\r\n    private _defaultHeight: number;\r\n    private _teleportationInitialized = false;\r\n    private _interactionsEnabled = false;\r\n    private _interactionsRequested = false;\r\n    private _displayGaze = true;\r\n    private _displayLaserPointer = true;\r\n\r\n    /**\r\n     * The mesh used to display where the user is going to teleport.\r\n     */\r\n    public get teleportationTarget(): Mesh {\r\n        return this._teleportationTarget;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to be used to display where the user is going to teleport.\r\n     */\r\n    public set teleportationTarget(value: Mesh) {\r\n        if (value) {\r\n            value.name = \"teleportationTarget\";\r\n            this._isDefaultTeleportationTarget = false;\r\n            this._teleportationTarget = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The mesh used to display where the user is selecting, this mesh will be cloned and set as the gazeTracker for the left and right controller\r\n     * when set bakeCurrentTransformIntoVertices will be called on the mesh.\r\n     * See https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/bakingTransforms\r\n     */\r\n    public get gazeTrackerMesh(): Mesh {\r\n        return this._cameraGazer._gazeTracker;\r\n    }\r\n\r\n    public set gazeTrackerMesh(value: Mesh) {\r\n        if (value) {\r\n            // Dispose of existing meshes\r\n            if (this._cameraGazer._gazeTracker) {\r\n                this._cameraGazer._gazeTracker.dispose();\r\n            }\r\n            if (this._leftController && this._leftController._gazeTracker) {\r\n                this._leftController._gazeTracker.dispose();\r\n            }\r\n            if (this._rightController && this._rightController._gazeTracker) {\r\n                this._rightController._gazeTracker.dispose();\r\n            }\r\n\r\n            // Set and create gaze trackers on head and controllers\r\n            this._cameraGazer._gazeTracker = value;\r\n            this._cameraGazer._gazeTracker.bakeCurrentTransformIntoVertices();\r\n            this._cameraGazer._gazeTracker.isPickable = false;\r\n            this._cameraGazer._gazeTracker.isVisible = false;\r\n            this._cameraGazer._gazeTracker.name = \"gazeTracker\";\r\n            if (this._leftController) {\r\n                this._leftController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\") as Mesh;\r\n            }\r\n\r\n            if (this._rightController) {\r\n                this._rightController._gazeTracker = this._cameraGazer._gazeTracker.clone(\"gazeTracker\") as Mesh;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the gaze trackers scale should be updated to be constant size when pointing at near/far meshes\r\n     */\r\n    public updateGazeTrackerScale = true;\r\n    /**\r\n     * If the gaze trackers color should be updated when selecting meshes\r\n     */\r\n    public updateGazeTrackerColor = true;\r\n    /**\r\n     * If the controller laser color should be updated when selecting meshes\r\n     */\r\n    public updateControllerLaserColor = true;\r\n\r\n    /**\r\n     * The gaze tracking mesh corresponding to the left controller\r\n     */\r\n    public get leftControllerGazeTrackerMesh(): Nullable<Mesh> {\r\n        if (this._leftController) {\r\n            return this._leftController._gazeTracker;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * The gaze tracking mesh corresponding to the right controller\r\n     */\r\n    public get rightControllerGazeTrackerMesh(): Nullable<Mesh> {\r\n        if (this._rightController) {\r\n            return this._rightController._gazeTracker;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If the ray of the gaze should be displayed.\r\n     */\r\n    public get displayGaze(): boolean {\r\n        return this._displayGaze;\r\n    }\r\n\r\n    /**\r\n     * Sets if the ray of the gaze should be displayed.\r\n     */\r\n    public set displayGaze(value: boolean) {\r\n        this._displayGaze = value;\r\n        if (!value) {\r\n            this._cameraGazer._gazeTracker.isVisible = false;\r\n\r\n            if (this._leftController) {\r\n                this._leftController._gazeTracker.isVisible = false;\r\n            }\r\n\r\n            if (this._rightController) {\r\n                this._rightController._gazeTracker.isVisible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the ray of the LaserPointer should be displayed.\r\n     */\r\n    public get displayLaserPointer(): boolean {\r\n        return this._displayLaserPointer;\r\n    }\r\n\r\n    /**\r\n     * Sets if the ray of the LaserPointer should be displayed.\r\n     */\r\n    public set displayLaserPointer(value: boolean) {\r\n        this._displayLaserPointer = value;\r\n        if (!value) {\r\n            if (this._rightController) {\r\n                this._rightController._deactivatePointer();\r\n                this._rightController._gazeTracker.isVisible = false;\r\n            }\r\n            if (this._leftController) {\r\n                this._leftController._deactivatePointer();\r\n                this._leftController._gazeTracker.isVisible = false;\r\n            }\r\n        } else {\r\n            if (this._rightController) {\r\n                this._rightController._activatePointer();\r\n            }\r\n            if (this._leftController) {\r\n                this._leftController._activatePointer();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The deviceOrientationCamera used as the camera when not in VR.\r\n     */\r\n    public get deviceOrientationCamera(): Nullable<DeviceOrientationCamera> {\r\n        return this._deviceOrientationCamera;\r\n    }\r\n\r\n    /**\r\n     * Based on the current WebVR support, returns the current VR camera used.\r\n     */\r\n    public get currentVRCamera(): Nullable<Camera> {\r\n        if (this._webVRready) {\r\n            return this._webVRCamera;\r\n        } else {\r\n            return this._scene.activeCamera;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The webVRCamera which is used when in VR.\r\n     */\r\n    public get webVRCamera(): WebVRFreeCamera {\r\n        return this._webVRCamera;\r\n    }\r\n\r\n    /**\r\n     * The deviceOrientationCamera that is used as a fallback when vr device is not connected.\r\n     */\r\n    public get vrDeviceOrientationCamera(): Nullable<VRDeviceOrientationFreeCamera> {\r\n        return this._vrDeviceOrientationCamera;\r\n    }\r\n\r\n    /**\r\n     * The html button that is used to trigger entering into VR.\r\n     */\r\n    public get vrButton(): Nullable<HTMLButtonElement> {\r\n        return this._btnVR;\r\n    }\r\n\r\n    private get _teleportationRequestInitiated(): boolean {\r\n        const result =\r\n            this._cameraGazer._teleportationRequestInitiated ||\r\n            (this._leftController !== null && this._leftController._teleportationRequestInitiated) ||\r\n            (this._rightController !== null && this._rightController._teleportationRequestInitiated);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Defines whether or not Pointer lock should be requested when switching to\r\n     * full screen.\r\n     */\r\n    public requestPointerLockOnFullScreen = true;\r\n\r\n    // XR\r\n\r\n    /**\r\n     * If asking to force XR, this will be populated with the default xr experience\r\n     */\r\n    public xr: WebXRDefaultExperience;\r\n\r\n    /**\r\n     * Was the XR test done already. If this is true AND this.xr exists, xr is initialized.\r\n     * If this is true and no this.xr, xr exists but is not supported, using WebVR.\r\n     */\r\n    public xrTestDone: boolean = false;\r\n\r\n    /**\r\n     * Instantiates a VRExperienceHelper.\r\n     * Helps to quickly add VR support to an existing scene.\r\n     * @param scene The scene the VRExperienceHelper belongs to.\r\n     * @param webVROptions Options to modify the vr experience helper's behavior.\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** Options to modify the vr experience helper's behavior. */\r\n        public webVROptions: VRExperienceHelperOptions = {}\r\n    ) {\r\n        Logger.Warn(\"WebVR is deprecated. Please avoid using this experience helper and use the WebXR experience helper instead\");\r\n        this._scene = scene;\r\n        this._inputElement = scene.getEngine().getInputElement();\r\n\r\n        // check for VR support:\r\n\r\n        const vrSupported = \"getVRDisplays\" in navigator;\r\n        // no VR support? force XR but only when it is not set because web vr can work without the getVRDisplays\r\n        if (!vrSupported && webVROptions.useXR === undefined) {\r\n            webVROptions.useXR = true;\r\n        }\r\n\r\n        // Parse options\r\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera === undefined) {\r\n            webVROptions.createFallbackVRDeviceOrientationFreeCamera = true;\r\n        }\r\n        if (webVROptions.createDeviceOrientationCamera === undefined) {\r\n            webVROptions.createDeviceOrientationCamera = true;\r\n        }\r\n        if (webVROptions.laserToggle === undefined) {\r\n            webVROptions.laserToggle = true;\r\n        }\r\n        if (webVROptions.defaultHeight === undefined) {\r\n            webVROptions.defaultHeight = 1.7;\r\n        }\r\n        if (webVROptions.useCustomVRButton) {\r\n            this._useCustomVRButton = true;\r\n            if (webVROptions.customVRButton) {\r\n                this._btnVR = webVROptions.customVRButton;\r\n            }\r\n        }\r\n        if (webVROptions.rayLength) {\r\n            this._rayLength = webVROptions.rayLength;\r\n        }\r\n        this._defaultHeight = webVROptions.defaultHeight;\r\n\r\n        if (webVROptions.positionScale) {\r\n            this._rayLength *= webVROptions.positionScale;\r\n            this._defaultHeight *= webVROptions.positionScale;\r\n        }\r\n\r\n        this._hasEnteredVR = false;\r\n\r\n        // Set position\r\n        if (this._scene.activeCamera) {\r\n            this._position = this._scene.activeCamera.position.clone();\r\n        } else {\r\n            this._position = new Vector3(0, this._defaultHeight, 0);\r\n        }\r\n\r\n        // Set non-vr camera\r\n        if (webVROptions.createDeviceOrientationCamera || !this._scene.activeCamera) {\r\n            this._deviceOrientationCamera = new DeviceOrientationCamera(\"deviceOrientationVRHelper\", this._position.clone(), scene);\r\n\r\n            // Copy data from existing camera\r\n            if (this._scene.activeCamera) {\r\n                this._deviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\r\n                this._deviceOrientationCamera.maxZ = this._scene.activeCamera.maxZ;\r\n                // Set rotation from previous camera\r\n                if (this._scene.activeCamera instanceof TargetCamera && this._scene.activeCamera.rotation) {\r\n                    const targetCamera = this._scene.activeCamera;\r\n                    if (targetCamera.rotationQuaternion) {\r\n                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(targetCamera.rotationQuaternion);\r\n                    } else {\r\n                        this._deviceOrientationCamera.rotationQuaternion.copyFrom(\r\n                            Quaternion.RotationYawPitchRoll(targetCamera.rotation.y, targetCamera.rotation.x, targetCamera.rotation.z)\r\n                        );\r\n                    }\r\n                    this._deviceOrientationCamera.rotation = targetCamera.rotation.clone();\r\n                }\r\n            }\r\n\r\n            this._scene.activeCamera = this._deviceOrientationCamera;\r\n            if (this._inputElement) {\r\n                this._scene.activeCamera.attachControl();\r\n            }\r\n        } else {\r\n            this._existingCamera = this._scene.activeCamera;\r\n        }\r\n\r\n        if (this.webVROptions.useXR && (navigator as any).xr) {\r\n            // force-check XR session support\r\n            WebXRSessionManager.IsSessionSupportedAsync(\"immersive-vr\").then((supported) => {\r\n                if (supported) {\r\n                    Logger.Log(\"Using WebXR. It is recommended to use the WebXRDefaultExperience directly\");\r\n                    // it is possible to use XR, let's do it!\r\n                    scene\r\n                        .createDefaultXRExperienceAsync({\r\n                            floorMeshes: webVROptions.floorMeshes || [],\r\n                        })\r\n                        .then((xr) => {\r\n                            this.xr = xr;\r\n                            // connect observables\r\n                            this.xrTestDone = true;\r\n\r\n                            this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\r\n                                return this.xr.baseExperience.camera;\r\n                            }, scene);\r\n\r\n                            this.xr.baseExperience.onStateChangedObservable.add((state) => {\r\n                                // support for entering / exiting\r\n                                switch (state) {\r\n                                    case WebXRState.ENTERING_XR:\r\n                                        this.onEnteringVRObservable.notifyObservers(this);\r\n                                        if (!this._interactionsEnabled) {\r\n                                            this.xr.pointerSelection.detach();\r\n                                        }\r\n                                        this.xr.pointerSelection.displayLaserPointer = this._displayLaserPointer;\r\n                                        break;\r\n                                    case WebXRState.EXITING_XR:\r\n                                        this.onExitingVRObservable.notifyObservers(this);\r\n\r\n                                        // resize to update width and height when exiting vr exits fullscreen\r\n                                        this._scene.getEngine().resize();\r\n                                        break;\r\n                                    case WebXRState.IN_XR:\r\n                                        this._hasEnteredVR = true;\r\n                                        break;\r\n                                    case WebXRState.NOT_IN_XR:\r\n                                        this._hasEnteredVR = false;\r\n                                        break;\r\n                                }\r\n                            });\r\n                        });\r\n                } else {\r\n                    // XR not supported (thou exists), continue WebVR init\r\n                    this._completeVRInit(scene, webVROptions);\r\n                }\r\n            });\r\n        } else {\r\n            // no XR, continue init synchronous\r\n            this._completeVRInit(scene, webVROptions);\r\n        }\r\n    }\r\n\r\n    private _completeVRInit(scene: Scene, webVROptions: VRExperienceHelperOptions): void {\r\n        this.xrTestDone = true;\r\n        // Create VR cameras\r\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\r\n            if (webVROptions.useMultiview) {\r\n                if (!webVROptions.vrDeviceOrientationCameraMetrics) {\r\n                    webVROptions.vrDeviceOrientationCameraMetrics = VRCameraMetrics.GetDefault();\r\n                }\r\n                webVROptions.vrDeviceOrientationCameraMetrics.multiviewEnabled = true;\r\n            }\r\n            this._vrDeviceOrientationCamera = new VRDeviceOrientationFreeCamera(\r\n                \"VRDeviceOrientationVRHelper\",\r\n                this._position,\r\n                this._scene,\r\n                true,\r\n                webVROptions.vrDeviceOrientationCameraMetrics\r\n            );\r\n            this._vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\r\n        }\r\n        this._webVRCamera = new WebVRFreeCamera(\"WebVRHelper\", this._position, this._scene, webVROptions);\r\n        this._webVRCamera.useStandingMatrix();\r\n\r\n        this._cameraGazer = new VRExperienceHelperCameraGazer(() => {\r\n            return this.currentVRCamera;\r\n        }, scene);\r\n        // Create default button\r\n        if (!this._useCustomVRButton) {\r\n            this._btnVR = <HTMLButtonElement>document.createElement(\"BUTTON\");\r\n            this._btnVR.className = \"babylonVRicon\";\r\n            this._btnVR.id = \"babylonVRiconbtn\";\r\n            this._btnVR.title = \"Click to switch to VR\";\r\n            const url = !window.SVGSVGElement\r\n                ? \"https://cdn.babylonjs.com/Assets/vrButton.png\"\r\n                : \"data:image/svg+xml;charset=UTF-8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%222048%22%20height%3D%221152%22%20viewBox%3D%220%200%202048%201152%22%20version%3D%221.1%22%3E%3Cpath%20transform%3D%22rotate%28180%201024%2C576.0000000000001%29%22%20d%3D%22m1109%2C896q17%2C0%2030%2C-12t13%2C-30t-12.5%2C-30.5t-30.5%2C-12.5l-170%2C0q-18%2C0%20-30.5%2C12.5t-12.5%2C30.5t13%2C30t30%2C12l170%2C0zm-85%2C256q59%2C0%20132.5%2C-1.5t154.5%2C-5.5t164.5%2C-11.5t163%2C-20t150%2C-30t124.5%2C-41.5q23%2C-11%2042%2C-24t38%2C-30q27%2C-25%2041%2C-61.5t14%2C-72.5l0%2C-257q0%2C-123%20-47%2C-232t-128%2C-190t-190%2C-128t-232%2C-47l-81%2C0q-37%2C0%20-68.5%2C14t-60.5%2C34.5t-55.5%2C45t-53%2C45t-53%2C34.5t-55.5%2C14t-55.5%2C-14t-53%2C-34.5t-53%2C-45t-55.5%2C-45t-60.5%2C-34.5t-68.5%2C-14l-81%2C0q-123%2C0%20-232%2C47t-190%2C128t-128%2C190t-47%2C232l0%2C257q0%2C68%2038%2C115t97%2C73q54%2C24%20124.5%2C41.5t150%2C30t163%2C20t164.5%2C11.5t154.5%2C5.5t132.5%2C1.5zm939%2C-298q0%2C39%20-24.5%2C67t-58.5%2C42q-54%2C23%20-122%2C39.5t-143.5%2C28t-155.5%2C19t-157%2C11t-148.5%2C5t-129.5%2C1.5q-59%2C0%20-130%2C-1.5t-148%2C-5t-157%2C-11t-155.5%2C-19t-143.5%2C-28t-122%2C-39.5q-34%2C-14%20-58.5%2C-42t-24.5%2C-67l0%2C-257q0%2C-106%2040.5%2C-199t110%2C-162.5t162.5%2C-109.5t199%2C-40l81%2C0q27%2C0%2052%2C14t50%2C34.5t51%2C44.5t55.5%2C44.5t63.5%2C34.5t74%2C14t74%2C-14t63.5%2C-34.5t55.5%2C-44.5t51%2C-44.5t50%2C-34.5t52%2C-14l14%2C0q37%2C0%2070%2C0.5t64.5%2C4.5t63.5%2C12t68%2C23q71%2C30%20128.5%2C78.5t98.5%2C110t63.5%2C133.5t22.5%2C149l0%2C257z%22%20fill%3D%22white%22%20/%3E%3C/svg%3E%0A\";\r\n            let css =\r\n                \".babylonVRicon { position: absolute; right: 20px; height: 50px; width: 80px; background-color: rgba(51,51,51,0.7); background-image: url(\" +\r\n                url +\r\n                \"); background-size: 80%; background-repeat:no-repeat; background-position: center; border: none; outline: none; transition: transform 0.125s ease-out } .babylonVRicon:hover { transform: scale(1.05) } .babylonVRicon:active {background-color: rgba(51,51,51,1) } .babylonVRicon:focus {background-color: rgba(51,51,51,1) }\";\r\n            css += \".babylonVRicon.vrdisplaypresenting { display: none; }\";\r\n            // TODO: Add user feedback so that they know what state the VRDisplay is in (disconnected, connected, entering-VR)\r\n            // css += \".babylonVRicon.vrdisplaysupported { }\";\r\n            // css += \".babylonVRicon.vrdisplayready { }\";\r\n            // css += \".babylonVRicon.vrdisplayrequesting { }\";\r\n\r\n            const style = document.createElement(\"style\");\r\n            style.appendChild(document.createTextNode(css));\r\n            document.getElementsByTagName(\"head\")[0].appendChild(style);\r\n\r\n            this._moveButtonToBottomRight();\r\n        }\r\n\r\n        // VR button click event\r\n        if (this._btnVR) {\r\n            this._btnVR.addEventListener(\"click\", () => {\r\n                if (!this.isInVRMode) {\r\n                    this.enterVR();\r\n                } else {\r\n                    this._scene.getEngine().disableVR();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Window events\r\n\r\n        const hostWindow = this._scene.getEngine().getHostWindow();\r\n        if (!hostWindow) {\r\n            return;\r\n        }\r\n\r\n        hostWindow.addEventListener(\"resize\", this._onResize);\r\n        document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\r\n\r\n        // Display vr button when headset is connected\r\n        if (webVROptions.createFallbackVRDeviceOrientationFreeCamera) {\r\n            this._displayVRButton();\r\n        } else {\r\n            this._scene.getEngine().onVRDisplayChangedObservable.add((e) => {\r\n                if (e.vrDisplay) {\r\n                    this._displayVRButton();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Exiting VR mode using 'ESC' key on desktop\r\n        this._onKeyDown = (event: KeyboardEvent) => {\r\n            if (event.keyCode === 27 && this.isInVRMode) {\r\n                this.exitVR();\r\n            }\r\n        };\r\n        document.addEventListener(\"keydown\", this._onKeyDown);\r\n\r\n        // Exiting VR mode double tapping the touch screen\r\n        this._scene.onPrePointerObservable.add(\r\n            () => {\r\n                if (this._hasEnteredVR && this.exitVROnDoubleTap) {\r\n                    this.exitVR();\r\n                    if (this._fullscreenVRpresenting) {\r\n                        this._scene.getEngine().exitFullscreen();\r\n                    }\r\n                }\r\n            },\r\n            PointerEventTypes.POINTERDOUBLETAP,\r\n            false\r\n        );\r\n\r\n        // Listen for WebVR display changes\r\n        this._onVRDisplayChangedBind = (eventArgs: IDisplayChangedEventArgs) => this._onVRDisplayChanged(eventArgs);\r\n        this._onVrDisplayPresentChangeBind = () => this._onVrDisplayPresentChange();\r\n        this._onVRRequestPresentStart = () => {\r\n            this._webVRrequesting = true;\r\n            this._updateButtonVisibility();\r\n        };\r\n        this._onVRRequestPresentComplete = () => {\r\n            this._webVRrequesting = false;\r\n            this._updateButtonVisibility();\r\n        };\r\n        scene.getEngine().onVRDisplayChangedObservable.add(this._onVRDisplayChangedBind);\r\n        scene.getEngine().onVRRequestPresentStart.add(this._onVRRequestPresentStart);\r\n        scene.getEngine().onVRRequestPresentComplete.add(this._onVRRequestPresentComplete);\r\n        hostWindow.addEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        // Gamepad connection events\r\n        this._webVRCamera.onControllerMeshLoadedObservable.add((webVRController) => this._onDefaultMeshLoaded(webVRController));\r\n        this._scene.gamepadManager.onGamepadConnectedObservable.add(this._onNewGamepadConnected);\r\n        this._scene.gamepadManager.onGamepadDisconnectedObservable.add(this._onNewGamepadDisconnected);\r\n\r\n        this._updateButtonVisibility();\r\n\r\n        //create easing functions\r\n        this._circleEase = new CircleEase();\r\n        this._circleEase.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n        this._teleportationEasing = this._circleEase;\r\n\r\n        // Allow clicking in the vrDeviceOrientationCamera\r\n        scene.onPointerObservable.add((e) => {\r\n            if (this._interactionsEnabled) {\r\n                if (scene.activeCamera === this.vrDeviceOrientationCamera && (e.event as IPointerEvent).pointerType === \"mouse\") {\r\n                    if (e.type === PointerEventTypes.POINTERDOWN) {\r\n                        this._cameraGazer._selectionPointerDown();\r\n                    } else if (e.type === PointerEventTypes.POINTERUP) {\r\n                        this._cameraGazer._selectionPointerUp();\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this.webVROptions.floorMeshes) {\r\n            this.enableTeleportation({ floorMeshes: this.webVROptions.floorMeshes });\r\n        }\r\n    }\r\n\r\n    // Raised when one of the controller has loaded successfully its associated default mesh\r\n    private _onDefaultMeshLoaded(webVRController: WebVRController) {\r\n        if (this._leftController && this._leftController.webVRController == webVRController) {\r\n            if (webVRController.mesh) {\r\n                this._leftController._setLaserPointerParent(webVRController.mesh);\r\n            }\r\n        }\r\n        if (this._rightController && this._rightController.webVRController == webVRController) {\r\n            if (webVRController.mesh) {\r\n                this._rightController._setLaserPointerParent(webVRController.mesh);\r\n            }\r\n        }\r\n\r\n        try {\r\n            this.onControllerMeshLoadedObservable.notifyObservers(webVRController);\r\n        } catch (err) {\r\n            Logger.Warn(\"Error in your custom logic onControllerMeshLoaded: \" + err);\r\n        }\r\n    }\r\n\r\n    private _onResize = () => {\r\n        this._moveButtonToBottomRight();\r\n        if (this._fullscreenVRpresenting && this._webVRready) {\r\n            this.exitVR();\r\n        }\r\n    };\r\n\r\n    private _onFullscreenChange = () => {\r\n        this._fullscreenVRpresenting = !!document.fullscreenElement;\r\n        if (!this._fullscreenVRpresenting && this._inputElement) {\r\n            this.exitVR();\r\n            if (!this._useCustomVRButton && this._btnVR) {\r\n                this._btnVR.style.top = this._inputElement.offsetTop + this._inputElement.offsetHeight - 70 + \"px\";\r\n                this._btnVR.style.left = this._inputElement.offsetLeft + this._inputElement.offsetWidth - 100 + \"px\";\r\n                // make sure the button is visible after setting its position\r\n                this._updateButtonVisibility();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Gets a value indicating if we are currently in VR mode.\r\n     */\r\n    public get isInVRMode(): boolean {\r\n        return (this.xr && this.webVROptions.useXR && this.xr.baseExperience.state === WebXRState.IN_XR) || this._webVRpresenting || this._fullscreenVRpresenting;\r\n    }\r\n\r\n    private _onVrDisplayPresentChange() {\r\n        const vrDisplay = this._scene.getEngine().getVRDevice();\r\n        if (vrDisplay) {\r\n            const wasPresenting = this._webVRpresenting;\r\n            this._webVRpresenting = vrDisplay.isPresenting;\r\n\r\n            if (wasPresenting && !this._webVRpresenting) {\r\n                this.exitVR();\r\n            }\r\n        } else {\r\n            Logger.Warn(\"Detected VRDisplayPresentChange on an unknown VRDisplay. Did you can enterVR on the vrExperienceHelper?\");\r\n        }\r\n\r\n        this._updateButtonVisibility();\r\n    }\r\n\r\n    private _onVRDisplayChanged(eventArgs: IDisplayChangedEventArgs) {\r\n        this._webVRsupported = eventArgs.vrSupported;\r\n        this._webVRready = !!eventArgs.vrDisplay;\r\n        this._webVRpresenting = eventArgs.vrDisplay && eventArgs.vrDisplay.isPresenting;\r\n\r\n        this._updateButtonVisibility();\r\n    }\r\n\r\n    private _moveButtonToBottomRight() {\r\n        if (this._inputElement && !this._useCustomVRButton && this._btnVR) {\r\n            const rect: ClientRect = this._inputElement.getBoundingClientRect();\r\n            this._btnVR.style.top = rect.top + rect.height - 70 + \"px\";\r\n            this._btnVR.style.left = rect.left + rect.width - 100 + \"px\";\r\n        }\r\n    }\r\n\r\n    private _displayVRButton() {\r\n        if (!this._useCustomVRButton && !this._btnVRDisplayed && this._btnVR) {\r\n            document.body.appendChild(this._btnVR);\r\n            this._btnVRDisplayed = true;\r\n        }\r\n    }\r\n\r\n    private _updateButtonVisibility() {\r\n        if (!this._btnVR || this._useCustomVRButton) {\r\n            return;\r\n        }\r\n        this._btnVR.className = \"babylonVRicon\";\r\n        if (this.isInVRMode) {\r\n            this._btnVR.className += \" vrdisplaypresenting\";\r\n        } else {\r\n            if (this._webVRready) {\r\n                this._btnVR.className += \" vrdisplayready\";\r\n            }\r\n            if (this._webVRsupported) {\r\n                this._btnVR.className += \" vrdisplaysupported\";\r\n            }\r\n            if (this._webVRrequesting) {\r\n                this._btnVR.className += \" vrdisplayrequesting\";\r\n            }\r\n        }\r\n    }\r\n\r\n    private _cachedAngularSensibility = { angularSensibilityX: null, angularSensibilityY: null, angularSensibility: null };\r\n    /**\r\n     * Attempt to enter VR. If a headset is connected and ready, will request present on that.\r\n     * Otherwise, will use the fullscreen API.\r\n     */\r\n    public enterVR() {\r\n        if (this.xr) {\r\n            this.xr.baseExperience.enterXRAsync(\"immersive-vr\", \"local-floor\", this.xr.renderTarget);\r\n            return;\r\n        }\r\n        if (this.onEnteringVRObservable) {\r\n            try {\r\n                this.onEnteringVRObservable.notifyObservers(this);\r\n            } catch (err) {\r\n                Logger.Warn(\"Error in your custom logic onEnteringVR: \" + err);\r\n            }\r\n        }\r\n\r\n        if (this._scene.activeCamera) {\r\n            this._position = this._scene.activeCamera.position.clone();\r\n\r\n            if (this.vrDeviceOrientationCamera) {\r\n                this.vrDeviceOrientationCamera.rotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles();\r\n                this.vrDeviceOrientationCamera.angularSensibility = 2000;\r\n            }\r\n            if (this.webVRCamera) {\r\n                const currentYRotation = this.webVRCamera.deviceRotationQuaternion.toEulerAngles().y;\r\n                const desiredYRotation = Quaternion.FromRotationMatrix(this._scene.activeCamera.getWorldMatrix().getRotationMatrix()).toEulerAngles().y;\r\n                const delta = desiredYRotation - currentYRotation;\r\n                const currentGlobalRotation = this.webVRCamera.rotationQuaternion.toEulerAngles().y;\r\n                this.webVRCamera.rotationQuaternion = Quaternion.FromEulerAngles(0, currentGlobalRotation + delta, 0);\r\n            }\r\n\r\n            // make sure that we return to the last active camera\r\n            this._existingCamera = this._scene.activeCamera;\r\n\r\n            // Remove and cache angular sensability to avoid camera rotation when in VR\r\n            if ((<any>this._existingCamera).angularSensibilityX) {\r\n                this._cachedAngularSensibility.angularSensibilityX = (<any>this._existingCamera).angularSensibilityX;\r\n                (<any>this._existingCamera).angularSensibilityX = Number.MAX_VALUE;\r\n            }\r\n            if ((<any>this._existingCamera).angularSensibilityY) {\r\n                this._cachedAngularSensibility.angularSensibilityY = (<any>this._existingCamera).angularSensibilityY;\r\n                (<any>this._existingCamera).angularSensibilityY = Number.MAX_VALUE;\r\n            }\r\n            if ((<any>this._existingCamera).angularSensibility) {\r\n                this._cachedAngularSensibility.angularSensibility = (<any>this._existingCamera).angularSensibility;\r\n                (<any>this._existingCamera).angularSensibility = Number.MAX_VALUE;\r\n            }\r\n        }\r\n\r\n        if (this._webVRrequesting) {\r\n            return;\r\n        }\r\n\r\n        // If WebVR is supported and a headset is connected\r\n        if (this._webVRready) {\r\n            if (!this._webVRpresenting) {\r\n                this._scene.getEngine().onVRRequestPresentComplete.addOnce((result) => {\r\n                    this.onAfterEnteringVRObservable.notifyObservers({ success: result });\r\n                });\r\n                this._webVRCamera.position = this._position;\r\n                this._scene.activeCamera = this._webVRCamera;\r\n            }\r\n        } else if (this._vrDeviceOrientationCamera) {\r\n            this._vrDeviceOrientationCamera.position = this._position;\r\n            if (this._scene.activeCamera) {\r\n                this._vrDeviceOrientationCamera.minZ = this._scene.activeCamera.minZ;\r\n            }\r\n            this._scene.activeCamera = this._vrDeviceOrientationCamera;\r\n            this._scene.getEngine().enterFullscreen(this.requestPointerLockOnFullScreen);\r\n            this._updateButtonVisibility();\r\n            this._vrDeviceOrientationCamera.onViewMatrixChangedObservable.addOnce(() => {\r\n                this.onAfterEnteringVRObservable.notifyObservers({ success: true });\r\n            });\r\n        }\r\n\r\n        if (this._scene.activeCamera && this._inputElement) {\r\n            this._scene.activeCamera.attachControl();\r\n        }\r\n\r\n        if (this._interactionsEnabled) {\r\n            this._scene.registerBeforeRender(this._beforeRender);\r\n        }\r\n\r\n        if (this._displayLaserPointer) {\r\n            [this._leftController, this._rightController].forEach((controller) => {\r\n                if (controller) {\r\n                    controller._activatePointer();\r\n                }\r\n            });\r\n        }\r\n\r\n        this._hasEnteredVR = true;\r\n    }\r\n\r\n    /**\r\n     * Attempt to exit VR, or fullscreen.\r\n     */\r\n    public exitVR() {\r\n        if (this.xr) {\r\n            this.xr.baseExperience.exitXRAsync();\r\n            return;\r\n        }\r\n        if (this._hasEnteredVR) {\r\n            if (this.onExitingVRObservable) {\r\n                try {\r\n                    this.onExitingVRObservable.notifyObservers(this);\r\n                } catch (err) {\r\n                    Logger.Warn(\"Error in your custom logic onExitingVR: \" + err);\r\n                }\r\n            }\r\n            if (this._webVRpresenting) {\r\n                this._scene.getEngine().disableVR();\r\n            }\r\n            if (this._scene.activeCamera) {\r\n                this._position = this._scene.activeCamera.position.clone();\r\n            }\r\n\r\n            if (this.vrDeviceOrientationCamera) {\r\n                this.vrDeviceOrientationCamera.angularSensibility = Number.MAX_VALUE;\r\n            }\r\n\r\n            if (this._deviceOrientationCamera) {\r\n                this._deviceOrientationCamera.position = this._position;\r\n                this._scene.activeCamera = this._deviceOrientationCamera;\r\n\r\n                // Restore angular sensibility\r\n                if (this._cachedAngularSensibility.angularSensibilityX) {\r\n                    (<any>this._deviceOrientationCamera).angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\r\n                    this._cachedAngularSensibility.angularSensibilityX = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibilityY) {\r\n                    (<any>this._deviceOrientationCamera).angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\r\n                    this._cachedAngularSensibility.angularSensibilityY = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibility) {\r\n                    (<any>this._deviceOrientationCamera).angularSensibility = this._cachedAngularSensibility.angularSensibility;\r\n                    this._cachedAngularSensibility.angularSensibility = null;\r\n                }\r\n            } else if (this._existingCamera) {\r\n                this._existingCamera.position = this._position;\r\n                this._scene.activeCamera = this._existingCamera;\r\n                if (this._inputElement) {\r\n                    this._scene.activeCamera.attachControl();\r\n                }\r\n\r\n                // Restore angular sensibility\r\n                if (this._cachedAngularSensibility.angularSensibilityX) {\r\n                    (<any>this._existingCamera).angularSensibilityX = this._cachedAngularSensibility.angularSensibilityX;\r\n                    this._cachedAngularSensibility.angularSensibilityX = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibilityY) {\r\n                    (<any>this._existingCamera).angularSensibilityY = this._cachedAngularSensibility.angularSensibilityY;\r\n                    this._cachedAngularSensibility.angularSensibilityY = null;\r\n                }\r\n                if (this._cachedAngularSensibility.angularSensibility) {\r\n                    (<any>this._existingCamera).angularSensibility = this._cachedAngularSensibility.angularSensibility;\r\n                    this._cachedAngularSensibility.angularSensibility = null;\r\n                }\r\n            }\r\n\r\n            this._updateButtonVisibility();\r\n\r\n            if (this._interactionsEnabled) {\r\n                this._scene.unregisterBeforeRender(this._beforeRender);\r\n                this._cameraGazer._gazeTracker.isVisible = false;\r\n                if (this._leftController) {\r\n                    this._leftController._gazeTracker.isVisible = false;\r\n                }\r\n                if (this._rightController) {\r\n                    this._rightController._gazeTracker.isVisible = false;\r\n                }\r\n            }\r\n\r\n            // resize to update width and height when exiting vr exits fullscreen\r\n            this._scene.getEngine().resize();\r\n\r\n            [this._leftController, this._rightController].forEach((controller) => {\r\n                if (controller) {\r\n                    controller._deactivatePointer();\r\n                }\r\n            });\r\n\r\n            this._hasEnteredVR = false;\r\n\r\n            // Update engine state to re enable non-vr camera input\r\n            const engine = this._scene.getEngine();\r\n            if (engine._onVrDisplayPresentChange) {\r\n                engine._onVrDisplayPresentChange();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The position of the vr experience helper.\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the vr experience helper.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._position = value;\r\n\r\n        if (this._scene.activeCamera) {\r\n            this._scene.activeCamera.position = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables controllers and user interactions such as selecting and object or clicking on an object.\r\n     */\r\n    public enableInteractions() {\r\n        if (!this._interactionsEnabled) {\r\n            this._interactionsRequested = true;\r\n\r\n            // in XR it is enabled by default, but just to make sure, re-attach\r\n            if (this.xr) {\r\n                if (this.xr.baseExperience.state === WebXRState.IN_XR) {\r\n                    this.xr.pointerSelection.attach();\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (this._leftController) {\r\n                this._enableInteractionOnController(this._leftController);\r\n            }\r\n\r\n            if (this._rightController) {\r\n                this._enableInteractionOnController(this._rightController);\r\n            }\r\n\r\n            this.raySelectionPredicate = (mesh) => {\r\n                return mesh.isVisible && (mesh.isPickable || mesh.name === this._floorMeshName);\r\n            };\r\n\r\n            this.meshSelectionPredicate = () => {\r\n                return true;\r\n            };\r\n\r\n            this._raySelectionPredicate = (mesh) => {\r\n                if (\r\n                    this._isTeleportationFloor(mesh) ||\r\n                    (mesh.name.indexOf(\"gazeTracker\") === -1 && mesh.name.indexOf(\"teleportationTarget\") === -1 && mesh.name.indexOf(\"torusTeleportation\") === -1)\r\n                ) {\r\n                    return this.raySelectionPredicate(mesh);\r\n                }\r\n                return false;\r\n            };\r\n\r\n            this._interactionsEnabled = true;\r\n        }\r\n    }\r\n\r\n    private get _noControllerIsActive() {\r\n        return !(this._leftController && this._leftController._activePointer) && !(this._rightController && this._rightController._activePointer);\r\n    }\r\n\r\n    private _beforeRender = () => {\r\n        if (this._leftController && this._leftController._activePointer) {\r\n            this._castRayAndSelectObject(this._leftController);\r\n        }\r\n\r\n        if (this._rightController && this._rightController._activePointer) {\r\n            this._castRayAndSelectObject(this._rightController);\r\n        }\r\n\r\n        if (this._noControllerIsActive && (this._scene.getEngine().isPointerLock || this.enableGazeEvenWhenNoPointerLock)) {\r\n            this._castRayAndSelectObject(this._cameraGazer);\r\n        } else {\r\n            this._cameraGazer._gazeTracker.isVisible = false;\r\n        }\r\n    };\r\n\r\n    private _isTeleportationFloor(mesh: AbstractMesh): boolean {\r\n        for (let i = 0; i < this._floorMeshesCollection.length; i++) {\r\n            if (this._floorMeshesCollection[i].id === mesh.id) {\r\n                return true;\r\n            }\r\n        }\r\n        if (this._floorMeshName && mesh.name === this._floorMeshName) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Adds a floor mesh to be used for teleportation.\r\n     * @param floorMesh the mesh to be used for teleportation.\r\n     */\r\n    public addFloorMesh(floorMesh: Mesh): void {\r\n        if (!this._floorMeshesCollection) {\r\n            return;\r\n        }\r\n\r\n        if (this._floorMeshesCollection.indexOf(floorMesh) > -1) {\r\n            return;\r\n        }\r\n\r\n        this._floorMeshesCollection.push(floorMesh);\r\n    }\r\n\r\n    /**\r\n     * Removes a floor mesh from being used for teleportation.\r\n     * @param floorMesh the mesh to be removed.\r\n     */\r\n    public removeFloorMesh(floorMesh: Mesh): void {\r\n        if (!this._floorMeshesCollection) {\r\n            return;\r\n        }\r\n\r\n        const meshIndex = this._floorMeshesCollection.indexOf(floorMesh);\r\n        if (meshIndex !== -1) {\r\n            this._floorMeshesCollection.splice(meshIndex, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables interactions and teleportation using the VR controllers and gaze.\r\n     * @param vrTeleportationOptions options to modify teleportation behavior.\r\n     */\r\n    public enableTeleportation(vrTeleportationOptions: VRTeleportationOptions = {}) {\r\n        if (!this._teleportationInitialized) {\r\n            this._teleportationRequested = true;\r\n\r\n            this.enableInteractions();\r\n\r\n            if (this.webVROptions.useXR && (vrTeleportationOptions.floorMeshes || vrTeleportationOptions.floorMeshName)) {\r\n                const floorMeshes: AbstractMesh[] = vrTeleportationOptions.floorMeshes || [];\r\n                if (!floorMeshes.length) {\r\n                    const floorMesh = this._scene.getMeshByName(vrTeleportationOptions.floorMeshName!);\r\n                    if (floorMesh) {\r\n                        floorMeshes.push(floorMesh);\r\n                    }\r\n                }\r\n                if (this.xr) {\r\n                    floorMeshes.forEach((mesh) => {\r\n                        this.xr.teleportation.addFloorMesh(mesh);\r\n                    });\r\n                    if (!this.xr.teleportation.attached) {\r\n                        this.xr.teleportation.attach();\r\n                    }\r\n                    return;\r\n                } else if (!this.xrTestDone) {\r\n                    const waitForXr = () => {\r\n                        if (this.xrTestDone) {\r\n                            this._scene.unregisterBeforeRender(waitForXr);\r\n                            if (this.xr) {\r\n                                if (!this.xr.teleportation.attached) {\r\n                                    this.xr.teleportation.attach();\r\n                                }\r\n                            } else {\r\n                                this.enableTeleportation(vrTeleportationOptions);\r\n                            }\r\n                        }\r\n                    };\r\n                    this._scene.registerBeforeRender(waitForXr);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (vrTeleportationOptions.floorMeshName) {\r\n                this._floorMeshName = vrTeleportationOptions.floorMeshName;\r\n            }\r\n            if (vrTeleportationOptions.floorMeshes) {\r\n                this._floorMeshesCollection = vrTeleportationOptions.floorMeshes;\r\n            }\r\n\r\n            if (vrTeleportationOptions.teleportationMode) {\r\n                this._teleportationMode = vrTeleportationOptions.teleportationMode;\r\n            }\r\n            if (vrTeleportationOptions.teleportationTime && vrTeleportationOptions.teleportationTime > 0) {\r\n                this._teleportationTime = vrTeleportationOptions.teleportationTime;\r\n            }\r\n            if (vrTeleportationOptions.teleportationSpeed && vrTeleportationOptions.teleportationSpeed > 0) {\r\n                this._teleportationSpeed = vrTeleportationOptions.teleportationSpeed;\r\n            }\r\n            if (vrTeleportationOptions.easingFunction !== undefined) {\r\n                this._teleportationEasing = vrTeleportationOptions.easingFunction;\r\n            }\r\n\r\n            if (this._leftController != null) {\r\n                this._enableTeleportationOnController(this._leftController);\r\n            }\r\n            if (this._rightController != null) {\r\n                this._enableTeleportationOnController(this._rightController);\r\n            }\r\n\r\n            // Creates an image processing post process for the vignette not relying\r\n            // on the main scene configuration for image processing to reduce setup and spaces\r\n            // (gamma/linear) conflicts.\r\n            const imageProcessingConfiguration = new ImageProcessingConfiguration();\r\n            imageProcessingConfiguration.vignetteColor = new Color4(0, 0, 0, 0);\r\n            imageProcessingConfiguration.vignetteEnabled = true;\r\n            this._postProcessMove = new ImageProcessingPostProcess(\r\n                \"postProcessMove\",\r\n                1.0,\r\n                this._webVRCamera,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                imageProcessingConfiguration\r\n            );\r\n\r\n            this._webVRCamera.detachPostProcess(this._postProcessMove);\r\n            this._teleportationInitialized = true;\r\n            if (this._isDefaultTeleportationTarget) {\r\n                this._createTeleportationCircles();\r\n                this._teleportationTarget.scaling.scaleInPlace(this._webVRCamera.deviceScaleFactor);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onNewGamepadConnected = (gamepad: Gamepad) => {\r\n        if (gamepad.type !== Gamepad.POSE_ENABLED) {\r\n            if (gamepad.leftStick) {\r\n                gamepad.onleftstickchanged((stickValues) => {\r\n                    if (this._teleportationInitialized && this.teleportationEnabled) {\r\n                        // Listening to classic/xbox gamepad only if no VR controller is active\r\n                        if (\r\n                            (!this._leftController && !this._rightController) ||\r\n                            (this._leftController && !this._leftController._activePointer && this._rightController && !this._rightController._activePointer)\r\n                        ) {\r\n                            this._checkTeleportWithRay(stickValues, this._cameraGazer);\r\n                            this._checkTeleportBackwards(stickValues, this._cameraGazer);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            if (gamepad.rightStick) {\r\n                gamepad.onrightstickchanged((stickValues) => {\r\n                    if (this._teleportationInitialized) {\r\n                        this._checkRotate(stickValues, this._cameraGazer);\r\n                    }\r\n                });\r\n            }\r\n            if (gamepad.type === Gamepad.XBOX) {\r\n                (<Xbox360Pad>gamepad).onbuttondown((buttonPressed: Xbox360Button) => {\r\n                    if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\r\n                        this._cameraGazer._selectionPointerDown();\r\n                    }\r\n                });\r\n                (<Xbox360Pad>gamepad).onbuttonup((buttonPressed: Xbox360Button) => {\r\n                    if (this._interactionsEnabled && buttonPressed === Xbox360Button.A) {\r\n                        this._cameraGazer._selectionPointerUp();\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            const webVRController = <WebVRController>gamepad;\r\n            const controller = new VRExperienceHelperControllerGazer(webVRController, this._scene, this._cameraGazer._gazeTracker);\r\n\r\n            if (webVRController.hand === \"right\" || (this._leftController && this._leftController.webVRController != webVRController)) {\r\n                this._rightController = controller;\r\n            } else {\r\n                this._leftController = controller;\r\n            }\r\n\r\n            this._tryEnableInteractionOnController(controller);\r\n        }\r\n    };\r\n\r\n    // This only succeeds if the controller's mesh exists for the controller so this must be called whenever new controller is connected or when mesh is loaded\r\n    private _tryEnableInteractionOnController = (controller: VRExperienceHelperControllerGazer) => {\r\n        if (this._interactionsRequested && !controller._interactionsEnabled) {\r\n            this._enableInteractionOnController(controller);\r\n        }\r\n        if (this._teleportationRequested && !controller._teleportationEnabled) {\r\n            this._enableTeleportationOnController(controller);\r\n        }\r\n    };\r\n\r\n    private _onNewGamepadDisconnected = (gamepad: Gamepad) => {\r\n        if (gamepad instanceof WebVRController) {\r\n            if (gamepad.hand === \"left\" && this._leftController != null) {\r\n                this._leftController.dispose();\r\n                this._leftController = null;\r\n            }\r\n            if (gamepad.hand === \"right\" && this._rightController != null) {\r\n                this._rightController.dispose();\r\n                this._rightController = null;\r\n            }\r\n        }\r\n    };\r\n\r\n    private _enableInteractionOnController(controller: VRExperienceHelperControllerGazer) {\r\n        const controllerMesh = controller.webVRController.mesh;\r\n        if (controllerMesh) {\r\n            controller._interactionsEnabled = true;\r\n            if (this.isInVRMode && this._displayLaserPointer) {\r\n                controller._activatePointer();\r\n            }\r\n            if (this.webVROptions.laserToggle) {\r\n                controller.webVRController.onMainButtonStateChangedObservable.add((stateObject) => {\r\n                    // Enabling / disabling laserPointer\r\n                    if (this._displayLaserPointer && stateObject.value === 1) {\r\n                        if (controller._activePointer) {\r\n                            controller._deactivatePointer();\r\n                        } else {\r\n                            controller._activatePointer();\r\n                        }\r\n                        if (this.displayGaze) {\r\n                            controller._gazeTracker.isVisible = controller._activePointer;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            controller.webVRController.onTriggerStateChangedObservable.add((stateObject) => {\r\n                let gazer: VRExperienceHelperGazer = controller;\r\n                if (this._noControllerIsActive) {\r\n                    gazer = this._cameraGazer;\r\n                }\r\n                if (!gazer._pointerDownOnMeshAsked) {\r\n                    if (stateObject.value > this._padSensibilityUp) {\r\n                        gazer._selectionPointerDown();\r\n                    }\r\n                } else if (stateObject.value < this._padSensibilityDown) {\r\n                    gazer._selectionPointerUp();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    private _checkTeleportWithRay(stateObject: StickValues, gazer: VRExperienceHelperGazer) {\r\n        // Dont teleport if another gaze already requested teleportation\r\n        if (this._teleportationRequestInitiated && !gazer._teleportationRequestInitiated) {\r\n            return;\r\n        }\r\n        if (!gazer._teleportationRequestInitiated) {\r\n            if (stateObject.y < -this._padSensibilityUp && gazer._dpadPressed) {\r\n                gazer._activatePointer();\r\n                gazer._teleportationRequestInitiated = true;\r\n            }\r\n        } else {\r\n            // Listening to the proper controller values changes to confirm teleportation\r\n            if (Math.sqrt(stateObject.y * stateObject.y + stateObject.x * stateObject.x) < this._padSensibilityDown) {\r\n                if (this._teleportActive) {\r\n                    this.teleportCamera(this._haloCenter);\r\n                }\r\n\r\n                gazer._teleportationRequestInitiated = false;\r\n            }\r\n        }\r\n    }\r\n    private _checkRotate(stateObject: StickValues, gazer: VRExperienceHelperGazer) {\r\n        // Only rotate when user is not currently selecting a teleportation location\r\n        if (gazer._teleportationRequestInitiated) {\r\n            return;\r\n        }\r\n\r\n        if (!gazer._rotationLeftAsked) {\r\n            if (stateObject.x < -this._padSensibilityUp && gazer._dpadPressed) {\r\n                gazer._rotationLeftAsked = true;\r\n                if (this._rotationAllowed) {\r\n                    this._rotateCamera(false);\r\n                }\r\n            }\r\n        } else {\r\n            if (stateObject.x > -this._padSensibilityDown) {\r\n                gazer._rotationLeftAsked = false;\r\n            }\r\n        }\r\n\r\n        if (!gazer._rotationRightAsked) {\r\n            if (stateObject.x > this._padSensibilityUp && gazer._dpadPressed) {\r\n                gazer._rotationRightAsked = true;\r\n                if (this._rotationAllowed) {\r\n                    this._rotateCamera(true);\r\n                }\r\n            }\r\n        } else {\r\n            if (stateObject.x < this._padSensibilityDown) {\r\n                gazer._rotationRightAsked = false;\r\n            }\r\n        }\r\n    }\r\n    private _checkTeleportBackwards(stateObject: StickValues, gazer: VRExperienceHelperGazer) {\r\n        // Only teleport backwards when user is not currently selecting a teleportation location\r\n        if (gazer._teleportationRequestInitiated) {\r\n            return;\r\n        }\r\n        // Teleport backwards\r\n        if (stateObject.y > this._padSensibilityUp && gazer._dpadPressed) {\r\n            if (!gazer._teleportationBackRequestInitiated) {\r\n                if (!this.currentVRCamera) {\r\n                    return;\r\n                }\r\n\r\n                // Get rotation and position of the current camera\r\n                let rotation = Quaternion.FromRotationMatrix(this.currentVRCamera.getWorldMatrix().getRotationMatrix());\r\n                let position = this.currentVRCamera.position;\r\n\r\n                // If the camera has device position, use that instead\r\n                if ((<WebVRFreeCamera>this.currentVRCamera).devicePosition && (<WebVRFreeCamera>this.currentVRCamera).deviceRotationQuaternion) {\r\n                    rotation = (<WebVRFreeCamera>this.currentVRCamera).deviceRotationQuaternion;\r\n                    position = (<WebVRFreeCamera>this.currentVRCamera).devicePosition;\r\n                }\r\n\r\n                // Get matrix with only the y rotation of the device rotation\r\n                rotation.toEulerAnglesToRef(this._workingVector);\r\n                this._workingVector.z = 0;\r\n                this._workingVector.x = 0;\r\n                Quaternion.RotationYawPitchRollToRef(this._workingVector.y, this._workingVector.x, this._workingVector.z, this._workingQuaternion);\r\n                this._workingQuaternion.toRotationMatrix(this._workingMatrix);\r\n\r\n                // Rotate backwards ray by device rotation to cast at the ground behind the user\r\n                Vector3.TransformCoordinatesToRef(this._teleportBackwardsVector, this._workingMatrix, this._workingVector);\r\n\r\n                // Teleport if ray hit the ground and is not to far away eg. backwards off a cliff\r\n                const ray = new Ray(position, this._workingVector);\r\n                const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\r\n                if (hit && hit.pickedPoint && hit.pickedMesh && this._isTeleportationFloor(hit.pickedMesh) && hit.distance < 5) {\r\n                    this.teleportCamera(hit.pickedPoint);\r\n                }\r\n\r\n                gazer._teleportationBackRequestInitiated = true;\r\n            }\r\n        } else {\r\n            gazer._teleportationBackRequestInitiated = false;\r\n        }\r\n    }\r\n\r\n    private _enableTeleportationOnController(controller: VRExperienceHelperControllerGazer) {\r\n        const controllerMesh = controller.webVRController.mesh;\r\n        if (controllerMesh) {\r\n            if (!controller._interactionsEnabled) {\r\n                this._enableInteractionOnController(controller);\r\n            }\r\n            controller._interactionsEnabled = true;\r\n            controller._teleportationEnabled = true;\r\n            if (controller.webVRController.controllerType === PoseEnabledControllerType.VIVE) {\r\n                controller._dpadPressed = false;\r\n                controller.webVRController.onPadStateChangedObservable.add((stateObject) => {\r\n                    controller._dpadPressed = stateObject.pressed;\r\n                    if (!controller._dpadPressed) {\r\n                        controller._rotationLeftAsked = false;\r\n                        controller._rotationRightAsked = false;\r\n                        controller._teleportationBackRequestInitiated = false;\r\n                    }\r\n                });\r\n            }\r\n            controller.webVRController.onPadValuesChangedObservable.add((stateObject) => {\r\n                if (this.teleportationEnabled) {\r\n                    this._checkTeleportBackwards(stateObject, controller);\r\n                    this._checkTeleportWithRay(stateObject, controller);\r\n                }\r\n                this._checkRotate(stateObject, controller);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _createTeleportationCircles() {\r\n        this._teleportationTarget = CreateGround(\"teleportationTarget\", { width: 2, height: 2, subdivisions: 2 }, this._scene);\r\n        this._teleportationTarget.isPickable = false;\r\n\r\n        const length = 512;\r\n        const dynamicTexture = new DynamicTexture(\"DynamicTexture\", length, this._scene, true);\r\n        dynamicTexture.hasAlpha = true;\r\n        const context = dynamicTexture.getContext();\r\n\r\n        const centerX = length / 2;\r\n        const centerY = length / 2;\r\n        const radius = 200;\r\n\r\n        context.beginPath();\r\n        context.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);\r\n        context.fillStyle = this._teleportationFillColor;\r\n        context.fill();\r\n        context.lineWidth = 10;\r\n        context.strokeStyle = this._teleportationBorderColor;\r\n        context.stroke();\r\n        context.closePath();\r\n        dynamicTexture.update();\r\n\r\n        const teleportationCircleMaterial = new StandardMaterial(\"TextPlaneMaterial\", this._scene);\r\n        teleportationCircleMaterial.diffuseTexture = dynamicTexture;\r\n        this._teleportationTarget.material = teleportationCircleMaterial;\r\n\r\n        const torus = CreateTorus(\r\n            \"torusTeleportation\",\r\n            {\r\n                diameter: 0.75,\r\n                thickness: 0.1,\r\n                tessellation: 25,\r\n                updatable: false,\r\n            },\r\n            this._scene\r\n        );\r\n        torus.isPickable = false;\r\n        torus.parent = this._teleportationTarget;\r\n\r\n        const animationInnerCircle = new Animation(\"animationInnerCircle\", \"position.y\", 30, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n\r\n        const keys = [];\r\n        keys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        keys.push({\r\n            frame: 30,\r\n            value: 0.4,\r\n        });\r\n        keys.push({\r\n            frame: 60,\r\n            value: 0,\r\n        });\r\n\r\n        animationInnerCircle.setKeys(keys);\r\n\r\n        const easingFunction = new SineEase();\r\n        easingFunction.setEasingMode(EasingFunction.EASINGMODE_EASEINOUT);\r\n        animationInnerCircle.setEasingFunction(easingFunction);\r\n\r\n        torus.animations = [];\r\n        torus.animations.push(animationInnerCircle);\r\n\r\n        this._scene.beginAnimation(torus, 0, 60, true);\r\n\r\n        this._hideTeleportationTarget();\r\n    }\r\n\r\n    private _displayTeleportationTarget() {\r\n        this._teleportActive = true;\r\n        if (this._teleportationInitialized) {\r\n            this._teleportationTarget.isVisible = true;\r\n            if (this._isDefaultTeleportationTarget) {\r\n                (<Mesh>this._teleportationTarget.getChildren()[0]).isVisible = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _hideTeleportationTarget() {\r\n        this._teleportActive = false;\r\n        if (this._teleportationInitialized) {\r\n            this._teleportationTarget.isVisible = false;\r\n            if (this._isDefaultTeleportationTarget) {\r\n                (<Mesh>this._teleportationTarget.getChildren()[0]).isVisible = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _rotateCamera(right: boolean) {\r\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\r\n            return;\r\n        }\r\n\r\n        if (right) {\r\n            this._rotationAngle++;\r\n        } else {\r\n            this._rotationAngle--;\r\n        }\r\n\r\n        this.currentVRCamera.animations = [];\r\n\r\n        const target = Quaternion.FromRotationMatrix(Matrix.RotationY((Math.PI / 4) * this._rotationAngle));\r\n\r\n        const animationRotation = new Animation(\"animationRotation\", \"rotationQuaternion\", 90, Animation.ANIMATIONTYPE_QUATERNION, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const animationRotationKeys = [];\r\n        animationRotationKeys.push({\r\n            frame: 0,\r\n            value: this.currentVRCamera.rotationQuaternion,\r\n        });\r\n        animationRotationKeys.push({\r\n            frame: 6,\r\n            value: target,\r\n        });\r\n\r\n        animationRotation.setKeys(animationRotationKeys);\r\n\r\n        animationRotation.setEasingFunction(this._circleEase);\r\n\r\n        this.currentVRCamera.animations.push(animationRotation);\r\n\r\n        this._postProcessMove.animations = [];\r\n\r\n        const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteWeightKeys = [];\r\n        vignetteWeightKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: 3,\r\n            value: 4,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: 6,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP.setKeys(vignetteWeightKeys);\r\n        animationPP.setEasingFunction(this._circleEase);\r\n        this._postProcessMove.animations.push(animationPP);\r\n\r\n        const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", 90, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteStretchKeys = [];\r\n        vignetteStretchKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: 3,\r\n            value: 10,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: 6,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP2.setKeys(vignetteStretchKeys);\r\n        animationPP2.setEasingFunction(this._circleEase);\r\n        this._postProcessMove.animations.push(animationPP2);\r\n\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\r\n        this._postProcessMove.samples = 4;\r\n        this._webVRCamera.attachPostProcess(this._postProcessMove);\r\n        this._scene.beginAnimation(this._postProcessMove, 0, 6, false, 1, () => {\r\n            this._webVRCamera.detachPostProcess(this._postProcessMove);\r\n        });\r\n        this._scene.beginAnimation(this.currentVRCamera, 0, 6, false, 1);\r\n    }\r\n\r\n    private _moveTeleportationSelectorTo(hit: PickingInfo, gazer: VRExperienceHelperGazer, ray: Ray) {\r\n        if (hit.pickedPoint) {\r\n            if (gazer._teleportationRequestInitiated) {\r\n                this._displayTeleportationTarget();\r\n                this._haloCenter.copyFrom(hit.pickedPoint);\r\n                this._teleportationTarget.position.copyFrom(hit.pickedPoint);\r\n            }\r\n\r\n            const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(true, false), ray);\r\n            if (pickNormal) {\r\n                const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, this._teleportationTarget.rotation);\r\n            }\r\n            this._teleportationTarget.position.y += 0.1;\r\n        }\r\n    }\r\n    private _workingVector = Vector3.Zero();\r\n    private _workingQuaternion = Quaternion.Identity();\r\n    private _workingMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Time Constant Teleportation Mode\r\n     */\r\n    public static readonly TELEPORTATIONMODE_CONSTANTTIME = 0;\r\n    /**\r\n     * Speed Constant Teleportation Mode\r\n     */\r\n    public static readonly TELEPORTATIONMODE_CONSTANTSPEED = 1;\r\n\r\n    /**\r\n     * Teleports the users feet to the desired location\r\n     * @param location The location where the user's feet should be placed\r\n     */\r\n    public teleportCamera(location: Vector3) {\r\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\r\n            return;\r\n        }\r\n        // Teleport the hmd to where the user is looking by moving the anchor to where they are looking minus the\r\n        // offset of the headset from the anchor.\r\n        if (this.webVRCamera.leftCamera) {\r\n            this._workingVector.copyFrom(this.webVRCamera.leftCamera.globalPosition);\r\n            this._workingVector.subtractInPlace(this.webVRCamera.position);\r\n            location.subtractToRef(this._workingVector, this._workingVector);\r\n        } else {\r\n            this._workingVector.copyFrom(location);\r\n        }\r\n        // Add height to account for user's height offset\r\n        if (this.isInVRMode) {\r\n            this._workingVector.y += this.webVRCamera.deviceDistanceToRoomGround() * this._webVRCamera.deviceScaleFactor;\r\n        } else {\r\n            this._workingVector.y += this._defaultHeight;\r\n        }\r\n\r\n        this.onBeforeCameraTeleport.notifyObservers(this._workingVector);\r\n\r\n        // Animations FPS\r\n        const FPS = 90;\r\n        let speedRatio, lastFrame;\r\n        if (this._teleportationMode == VRExperienceHelper.TELEPORTATIONMODE_CONSTANTSPEED) {\r\n            lastFrame = FPS;\r\n            const dist = Vector3.Distance(this.currentVRCamera.position, this._workingVector);\r\n            speedRatio = this._teleportationSpeed / dist;\r\n        } else {\r\n            // teleportationMode is TELEPORTATIONMODE_CONSTANTTIME\r\n            lastFrame = Math.round((this._teleportationTime * FPS) / 1000);\r\n            speedRatio = 1;\r\n        }\r\n\r\n        // Create animation from the camera's position to the new location\r\n        this.currentVRCamera.animations = [];\r\n        const animationCameraTeleportation = new Animation(\"animationCameraTeleportation\", \"position\", FPS, Animation.ANIMATIONTYPE_VECTOR3, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n        const animationCameraTeleportationKeys = [\r\n            {\r\n                frame: 0,\r\n                value: this.currentVRCamera.position,\r\n            },\r\n            {\r\n                frame: lastFrame,\r\n                value: this._workingVector,\r\n            },\r\n        ];\r\n\r\n        animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);\r\n        animationCameraTeleportation.setEasingFunction(this._teleportationEasing);\r\n        this.currentVRCamera.animations.push(animationCameraTeleportation);\r\n\r\n        this._postProcessMove.animations = [];\r\n\r\n        // Calculate the mid frame for vignette animations\r\n        const midFrame = Math.round(lastFrame / 2);\r\n\r\n        const animationPP = new Animation(\"animationPP\", \"vignetteWeight\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteWeightKeys = [];\r\n        vignetteWeightKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: midFrame,\r\n            value: 8,\r\n        });\r\n        vignetteWeightKeys.push({\r\n            frame: lastFrame,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP.setKeys(vignetteWeightKeys);\r\n        this._postProcessMove.animations.push(animationPP);\r\n\r\n        const animationPP2 = new Animation(\"animationPP2\", \"vignetteStretch\", FPS, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        const vignetteStretchKeys = [];\r\n        vignetteStretchKeys.push({\r\n            frame: 0,\r\n            value: 0,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: midFrame,\r\n            value: 10,\r\n        });\r\n        vignetteStretchKeys.push({\r\n            frame: lastFrame,\r\n            value: 0,\r\n        });\r\n\r\n        animationPP2.setKeys(vignetteStretchKeys);\r\n        this._postProcessMove.animations.push(animationPP2);\r\n\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteWeight = 0;\r\n        this._postProcessMove.imageProcessingConfiguration.vignetteStretch = 0;\r\n\r\n        this._webVRCamera.attachPostProcess(this._postProcessMove);\r\n        this._scene.beginAnimation(this._postProcessMove, 0, lastFrame, false, speedRatio, () => {\r\n            this._webVRCamera.detachPostProcess(this._postProcessMove);\r\n        });\r\n        this._scene.beginAnimation(this.currentVRCamera, 0, lastFrame, false, speedRatio, () => {\r\n            this.onAfterCameraTeleport.notifyObservers(this._workingVector);\r\n        });\r\n\r\n        this._hideTeleportationTarget();\r\n    }\r\n\r\n    private _convertNormalToDirectionOfRay(normal: Nullable<Vector3>, ray: Ray) {\r\n        if (normal) {\r\n            const angle = Math.acos(Vector3.Dot(normal, ray.direction));\r\n            if (angle < Math.PI / 2) {\r\n                normal.scaleInPlace(-1);\r\n            }\r\n        }\r\n        return normal;\r\n    }\r\n\r\n    private _castRayAndSelectObject(gazer: VRExperienceHelperGazer) {\r\n        if (!(this.currentVRCamera instanceof FreeCamera)) {\r\n            return;\r\n        }\r\n\r\n        const ray = gazer._getForwardRay(this._rayLength);\r\n        const hit = this._scene.pickWithRay(ray, this._raySelectionPredicate);\r\n\r\n        if (hit) {\r\n            this._scene.simulatePointerMove(hit, { pointerId: gazer._id });\r\n        }\r\n        gazer._currentHit = hit;\r\n\r\n        // Moving the gazeTracker on the mesh face targetted\r\n        if (hit && hit.pickedPoint) {\r\n            if (this._displayGaze) {\r\n                let multiplier = 1;\r\n\r\n                gazer._gazeTracker.isVisible = true;\r\n\r\n                if (gazer._isActionableMesh) {\r\n                    multiplier = 3;\r\n                }\r\n                if (this.updateGazeTrackerScale) {\r\n                    gazer._gazeTracker.scaling.x = hit.distance * multiplier;\r\n                    gazer._gazeTracker.scaling.y = hit.distance * multiplier;\r\n                    gazer._gazeTracker.scaling.z = hit.distance * multiplier;\r\n                }\r\n\r\n                const pickNormal = this._convertNormalToDirectionOfRay(hit.getNormal(), ray);\r\n                // To avoid z-fighting\r\n                const deltaFighting = 0.002;\r\n\r\n                if (pickNormal) {\r\n                    const axis1 = Vector3.Cross(Axis.Y, pickNormal);\r\n                    const axis2 = Vector3.Cross(pickNormal, axis1);\r\n                    Vector3.RotationFromAxisToRef(axis2, pickNormal, axis1, gazer._gazeTracker.rotation);\r\n                }\r\n                gazer._gazeTracker.position.copyFrom(hit.pickedPoint);\r\n\r\n                if (gazer._gazeTracker.position.x < 0) {\r\n                    gazer._gazeTracker.position.x += deltaFighting;\r\n                } else {\r\n                    gazer._gazeTracker.position.x -= deltaFighting;\r\n                }\r\n                if (gazer._gazeTracker.position.y < 0) {\r\n                    gazer._gazeTracker.position.y += deltaFighting;\r\n                } else {\r\n                    gazer._gazeTracker.position.y -= deltaFighting;\r\n                }\r\n                if (gazer._gazeTracker.position.z < 0) {\r\n                    gazer._gazeTracker.position.z += deltaFighting;\r\n                } else {\r\n                    gazer._gazeTracker.position.z -= deltaFighting;\r\n                }\r\n            }\r\n\r\n            // Changing the size of the laser pointer based on the distance from the targetted point\r\n            gazer._updatePointerDistance(hit.distance);\r\n        } else {\r\n            gazer._updatePointerDistance();\r\n            gazer._gazeTracker.isVisible = false;\r\n        }\r\n\r\n        if (hit && hit.pickedMesh) {\r\n            // The object selected is the floor, we're in a teleportation scenario\r\n            if (this._teleportationInitialized && this._isTeleportationFloor(hit.pickedMesh) && hit.pickedPoint) {\r\n                // Moving the teleportation area to this targetted point\r\n\r\n                //Raise onSelectedMeshUnselected observable if ray collided floor mesh/meshes and a non floor mesh was previously selected\r\n                if (gazer._currentMeshSelected && !this._isTeleportationFloor(gazer._currentMeshSelected)) {\r\n                    this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\r\n                }\r\n\r\n                gazer._currentMeshSelected = null;\r\n                if (gazer._teleportationRequestInitiated) {\r\n                    this._moveTeleportationSelectorTo(hit, gazer, ray);\r\n                }\r\n                return;\r\n            }\r\n            // If not, we're in a selection scenario\r\n            //this._teleportationAllowed = false;\r\n            if (hit.pickedMesh !== gazer._currentMeshSelected) {\r\n                if (this.meshSelectionPredicate(hit.pickedMesh)) {\r\n                    this.onNewMeshPicked.notifyObservers(hit);\r\n                    gazer._currentMeshSelected = hit.pickedMesh;\r\n                    if (hit.pickedMesh.isPickable && hit.pickedMesh.actionManager) {\r\n                        this.changeGazeColor(this._pickedGazeColor);\r\n                        this.changeLaserColor(this._pickedLaserColor);\r\n                        gazer._isActionableMesh = true;\r\n                    } else {\r\n                        this.changeGazeColor(this._gazeColor);\r\n                        this.changeLaserColor(this._laserColor);\r\n                        gazer._isActionableMesh = false;\r\n                    }\r\n                    try {\r\n                        this.onNewMeshSelected.notifyObservers(hit.pickedMesh);\r\n                        const gazerAsControllerGazer = gazer as VRExperienceHelperControllerGazer;\r\n                        if (gazerAsControllerGazer.webVRController) {\r\n                            this.onMeshSelectedWithController.notifyObservers({ mesh: hit.pickedMesh, controller: gazerAsControllerGazer.webVRController });\r\n                        }\r\n                    } catch (err) {\r\n                        Logger.Warn(\"Error while raising onNewMeshSelected or onMeshSelectedWithController: \" + err);\r\n                    }\r\n                } else {\r\n                    this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\r\n                    gazer._currentMeshSelected = null;\r\n                    this.changeGazeColor(this._gazeColor);\r\n                    this.changeLaserColor(this._laserColor);\r\n                }\r\n            }\r\n        } else {\r\n            this._notifySelectedMeshUnselected(gazer._currentMeshSelected);\r\n            gazer._currentMeshSelected = null;\r\n            //this._teleportationAllowed = false;\r\n            this.changeGazeColor(this._gazeColor);\r\n            this.changeLaserColor(this._laserColor);\r\n        }\r\n    }\r\n\r\n    private _notifySelectedMeshUnselected(mesh: Nullable<AbstractMesh>) {\r\n        if (mesh) {\r\n            this.onSelectedMeshUnselected.notifyObservers(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Permanently set new colors for the laser pointer\r\n     * @param color the new laser color\r\n     * @param pickedColor the new laser color when picked mesh detected\r\n     */\r\n    public setLaserColor(color: Color3, pickedColor: Color3 = this._pickedLaserColor) {\r\n        this._laserColor = color;\r\n        this._pickedLaserColor = pickedColor;\r\n    }\r\n\r\n    /**\r\n     * Set lighting enabled / disabled on the laser pointer of both controllers\r\n     * @param enabled should the lighting be enabled on the laser pointer\r\n     */\r\n    public setLaserLightingState(enabled: boolean = true) {\r\n        if (this._leftController) {\r\n            this._leftController._setLaserPointerLightingDisabled(!enabled);\r\n        }\r\n        if (this._rightController) {\r\n            this._rightController._setLaserPointerLightingDisabled(!enabled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Permanently set new colors for the gaze pointer\r\n     * @param color the new gaze color\r\n     * @param pickedColor the new gaze color when picked mesh detected\r\n     */\r\n    public setGazeColor(color: Color3, pickedColor: Color3 = this._pickedGazeColor) {\r\n        this._gazeColor = color;\r\n        this._pickedGazeColor = pickedColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the laser ray from the vr controllers.\r\n     * @param color new color for the ray.\r\n     */\r\n    public changeLaserColor(color: Color3) {\r\n        if (!this.updateControllerLaserColor) {\r\n            return;\r\n        }\r\n\r\n        if (this._leftController) {\r\n            this._leftController._setLaserPointerColor(color);\r\n        }\r\n        if (this._rightController) {\r\n            this._rightController._setLaserPointerColor(color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the ray from the vr headsets gaze.\r\n     * @param color new color for the ray.\r\n     */\r\n    public changeGazeColor(color: Color3) {\r\n        if (!this.updateGazeTrackerColor) {\r\n            return;\r\n        }\r\n        if (!(<StandardMaterial>this._cameraGazer._gazeTracker.material)) {\r\n            return;\r\n        }\r\n        (<StandardMaterial>this._cameraGazer._gazeTracker.material).emissiveColor = color;\r\n        if (this._leftController) {\r\n            (<StandardMaterial>this._leftController._gazeTracker.material).emissiveColor = color;\r\n        }\r\n        if (this._rightController) {\r\n            (<StandardMaterial>this._rightController._gazeTracker.material).emissiveColor = color;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Exits VR and disposes of the vr experience helper\r\n     */\r\n    public dispose() {\r\n        if (this.isInVRMode) {\r\n            this.exitVR();\r\n        }\r\n\r\n        if (this._postProcessMove) {\r\n            this._postProcessMove.dispose();\r\n        }\r\n\r\n        if (this._webVRCamera) {\r\n            this._webVRCamera.dispose();\r\n        }\r\n        if (this._vrDeviceOrientationCamera) {\r\n            this._vrDeviceOrientationCamera.dispose();\r\n        }\r\n        if (!this._useCustomVRButton && this._btnVR && this._btnVR.parentNode) {\r\n            document.body.removeChild(this._btnVR);\r\n        }\r\n\r\n        if (this._deviceOrientationCamera && this._scene.activeCamera != this._deviceOrientationCamera) {\r\n            this._deviceOrientationCamera.dispose();\r\n        }\r\n\r\n        if (this._cameraGazer) {\r\n            this._cameraGazer.dispose();\r\n        }\r\n        if (this._leftController) {\r\n            this._leftController.dispose();\r\n        }\r\n        if (this._rightController) {\r\n            this._rightController.dispose();\r\n        }\r\n\r\n        if (this._teleportationTarget) {\r\n            this._teleportationTarget.dispose();\r\n        }\r\n\r\n        if (this.xr) {\r\n            this.xr.dispose();\r\n        }\r\n\r\n        this._floorMeshesCollection.length = 0;\r\n\r\n        document.removeEventListener(\"keydown\", this._onKeyDown);\r\n        window.removeEventListener(\"vrdisplaypresentchange\", this._onVrDisplayPresentChangeBind);\r\n\r\n        window.removeEventListener(\"resize\", this._onResize);\r\n        document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\r\n\r\n        this._scene.getEngine().onVRDisplayChangedObservable.removeCallback(this._onVRDisplayChangedBind);\r\n        this._scene.getEngine().onVRRequestPresentStart.removeCallback(this._onVRRequestPresentStart);\r\n        this._scene.getEngine().onVRRequestPresentComplete.removeCallback(this._onVRRequestPresentComplete);\r\n\r\n        this._scene.gamepadManager.onGamepadConnectedObservable.removeCallback(this._onNewGamepadConnected);\r\n        this._scene.gamepadManager.onGamepadDisconnectedObservable.removeCallback(this._onNewGamepadDisconnected);\r\n\r\n        this._scene.unregisterBeforeRender(this._beforeRender);\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the VRExperienceHelper class\r\n     * @returns \"VRExperienceHelper\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VRExperienceHelper\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}