{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Scene } from \"../../scene.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a cylinder, cone or prism\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * height sets the height (y direction) of the cylinder, optional, default 2\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the cylinder, cone or prism\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCylinderVertexData(options) {\n  const height = options.height || 2;\n  let diameterTop = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\n  let diameterBottom = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\n  diameterTop = diameterTop || 0.00001; // Prevent broken normals\n  diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\n  const tessellation = options.tessellation || 24;\n  const subdivisions = options.subdivisions || 1;\n  const hasRings = options.hasRings ? true : false;\n  const enclose = options.enclose ? true : false;\n  const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\n  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const faceUV = options.faceUV || new Array(3);\n  const faceColors = options.faceColors;\n  // default face colors and UV if undefined\n  const quadNb = arc !== 1 && enclose ? 2 : 0;\n  const ringNb = hasRings ? subdivisions : 1;\n  const surfaceNb = 2 + (1 + quadNb) * ringNb;\n  let f;\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  for (f = 0; f < surfaceNb; f++) {\n    if (faceUV && faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n  }\n  const indices = new Array();\n  const positions = new Array();\n  const normals = new Array();\n  const uvs = new Array();\n  const colors = new Array();\n  const angleStep = Math.PI * 2 * arc / tessellation;\n  let angle;\n  let h;\n  let radius;\n  const tan = (diameterBottom - diameterTop) / 2 / height;\n  const ringVertex = Vector3.Zero();\n  const ringNormal = Vector3.Zero();\n  const ringFirstVertex = Vector3.Zero();\n  const ringFirstNormal = Vector3.Zero();\n  const quadNormal = Vector3.Zero();\n  const Y = Axis.Y;\n  // positions, normals, uvs\n  let i;\n  let j;\n  let r;\n  let ringIdx = 1;\n  let s = 1; // surface index\n  let cs = 0;\n  let v = 0;\n  for (i = 0; i <= subdivisions; i++) {\n    h = i / subdivisions;\n    radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n    ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\n    for (r = 0; r < ringIdx; r++) {\n      if (hasRings) {\n        s += r;\n      }\n      if (enclose) {\n        s += 2 * r;\n      }\n      for (j = 0; j <= tessellation; j++) {\n        angle = j * angleStep;\n        // position\n        ringVertex.x = Math.cos(-angle) * radius;\n        ringVertex.y = -height / 2 + h * height;\n        ringVertex.z = Math.sin(-angle) * radius;\n        // normal\n        if (diameterTop === 0 && i === subdivisions) {\n          // if no top cap, reuse former normals\n          ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n          ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n          ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n        } else {\n          ringNormal.x = ringVertex.x;\n          ringNormal.z = ringVertex.z;\n          ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n          ringNormal.normalize();\n        }\n        // keep first ring vertex values for enclose\n        if (j === 0) {\n          ringFirstVertex.copyFrom(ringVertex);\n          ringFirstNormal.copyFrom(ringNormal);\n        }\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n        if (hasRings) {\n          v = cs !== s ? faceUV[s].y : faceUV[s].w;\n        } else {\n          v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n        }\n        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (faceColors) {\n          colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n        }\n      }\n      // if enclose, add four vertices and their dedicated normals\n      if (arc !== 1 && enclose) {\n        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(0, ringVertex.y, 0);\n        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n        Vector3.CrossToRef(Y, ringNormal, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n        quadNormal.normalize();\n        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\n        } else {\n          v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n        }\n        uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (hasRings) {\n          v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\n        } else {\n          v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n        }\n        uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n        if (faceColors) {\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n          colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n        }\n      }\n      if (cs !== s) {\n        cs = s;\n      }\n    }\n  }\n  // indices\n  const e = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n  i = 0;\n  for (s = 0; s < subdivisions; s++) {\n    let i0 = 0;\n    let i1 = 0;\n    let i2 = 0;\n    let i3 = 0;\n    for (j = 0; j < tessellation; j++) {\n      i0 = i * (e + 1) + j;\n      i1 = (i + 1) * (e + 1) + j;\n      i2 = i * (e + 1) + (j + 1);\n      i3 = (i + 1) * (e + 1) + (j + 1);\n      indices.push(i0, i1, i2);\n      indices.push(i3, i2, i1);\n    }\n    if (arc !== 1 && enclose) {\n      // if enclose, add two quads\n      indices.push(i0 + 2, i1 + 2, i2 + 2);\n      indices.push(i3 + 2, i2 + 2, i1 + 2);\n      indices.push(i0 + 4, i1 + 4, i2 + 4);\n      indices.push(i3 + 4, i2 + 4, i1 + 4);\n    }\n    i = hasRings ? i + 2 : i + 1;\n  }\n  // Caps\n  const createCylinderCap = isTop => {\n    const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n    if (radius === 0) {\n      return;\n    }\n    // Cap positions, normals & uvs\n    let angle;\n    let circleVector;\n    let i;\n    const u = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\n    let c = null;\n    if (faceColors) {\n      c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\n    }\n    // cap center\n    const vbase = positions.length / 3;\n    const offset = isTop ? height / 2 : -height / 2;\n    const center = new Vector3(0, offset, 0);\n    positions.push(center.x, center.y, center.z);\n    normals.push(0, isTop ? 1 : -1, 0);\n    const v = u.y + (u.w - u.y) * 0.5;\n    uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n    if (c) {\n      colors.push(c.r, c.g, c.b, c.a);\n    }\n    const textureScale = new Vector2(0.5, 0.5);\n    for (i = 0; i <= tessellation; i++) {\n      angle = Math.PI * 2 * i * arc / tessellation;\n      const cos = Math.cos(-angle);\n      const sin = Math.sin(-angle);\n      circleVector = new Vector3(cos * radius, offset, sin * radius);\n      const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n      positions.push(circleVector.x, circleVector.y, circleVector.z);\n      normals.push(0, isTop ? 1 : -1, 0);\n      const v = u.y + (u.w - u.y) * textureCoordinate.y;\n      uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n      if (c) {\n        colors.push(c.r, c.g, c.b, c.a);\n      }\n    }\n    // Cap indices\n    for (i = 0; i < tessellation; i++) {\n      if (!isTop) {\n        indices.push(vbase);\n        indices.push(vbase + (i + 1));\n        indices.push(vbase + (i + 2));\n      } else {\n        indices.push(vbase);\n        indices.push(vbase + (i + 2));\n        indices.push(vbase + (i + 1));\n      }\n    }\n  };\n  // add caps to geometry based on cap parameter\n  if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\n    createCylinderCap(false);\n  }\n  if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\n    createCylinderCap(true);\n  }\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    vertexData.colors = colors;\n  }\n  return vertexData;\n}\n/**\n * Creates a cylinder or a cone mesh\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n * * If `enclose` is false, a ring surface is one element.\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.height\n * @param options.diameterTop\n * @param options.diameterBottom\n * @param options.diameter\n * @param options.tessellation\n * @param options.subdivisions\n * @param options.arc\n * @param options.faceColors\n * @param options.faceUV\n * @param options.updatable\n * @param options.hasRings\n * @param options.enclose\n * @param options.cap\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the cylinder mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\n */\nexport function CreateCylinder(name, options = {}, scene) {\n  const cylinder = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  cylinder._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateCylinderVertexData(options);\n  vertexData.applyToMesh(cylinder, options.updatable);\n  return cylinder;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated Please use CreateCylinder directly\n */\nexport const CylinderBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateCylinder\n};\nVertexData.CreateCylinder = CreateCylinderVertexData;\nMesh.CreateCylinder = (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) => {\n  if (scene === undefined || !(scene instanceof Scene)) {\n    if (scene !== undefined) {\n      sideOrientation = updatable || Mesh.DEFAULTSIDE;\n      updatable = scene;\n    }\n    scene = subdivisions;\n    subdivisions = 1;\n  }\n  const options = {\n    height,\n    diameterTop,\n    diameterBottom,\n    tessellation,\n    subdivisions,\n    sideOrientation,\n    updatable\n  };\n  return CreateCylinder(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector4","Vector3","Vector2","Color4","Mesh","VertexData","Scene","Axis","CompatibilityOptions","CreateCylinderVertexData","options","height","diameterTop","diameter","diameterBottom","tessellation","subdivisions","hasRings","enclose","cap","CAP_ALL","arc","sideOrientation","DEFAULTSIDE","faceUV","Array","faceColors","quadNb","ringNb","surfaceNb","f","undefined","indices","positions","normals","uvs","colors","angleStep","Math","PI","angle","h","radius","tan","ringVertex","Zero","ringNormal","ringFirstVertex","ringFirstNormal","quadNormal","Y","i","j","r","ringIdx","s","cs","v","x","cos","y","z","sin","length","sqrt","normalize","copyFrom","push","w","UseOpenGLOrientationForUV","g","b","a","CrossToRef","e","i0","i1","i2","i3","createCylinderCap","isTop","circleVector","u","c","vbase","offset","center","textureScale","textureCoordinate","CAP_START","CAP_END","_ComputeSides","frontUVs","backUVs","vertexData","CreateCylinder","name","scene","cylinder","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","CylinderBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/cylinderBuilder.ts"],"sourcesContent":["import { Vector4, Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a cylinder, cone or prism\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * height sets the height (y direction) of the cylinder, optional, default 2\r\n * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the cylinder, cone or prism\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCylinderVertexData(options: {\r\n    height?: number;\r\n    diameterTop?: number;\r\n    diameterBottom?: number;\r\n    diameter?: number;\r\n    tessellation?: number;\r\n    subdivisions?: number;\r\n    arc?: number;\r\n    faceColors?: Color4[];\r\n    faceUV?: Vector4[];\r\n    hasRings?: boolean;\r\n    enclose?: boolean;\r\n    cap?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const height: number = options.height || 2;\r\n    let diameterTop: number = options.diameterTop === 0 ? 0 : options.diameterTop || options.diameter || 1;\r\n    let diameterBottom: number = options.diameterBottom === 0 ? 0 : options.diameterBottom || options.diameter || 1;\r\n    diameterTop = diameterTop || 0.00001; // Prevent broken normals\r\n    diameterBottom = diameterBottom || 0.00001; // Prevent broken normals\r\n    const tessellation: number = options.tessellation || 24;\r\n    const subdivisions: number = options.subdivisions || 1;\r\n    const hasRings: boolean = options.hasRings ? true : false;\r\n    const enclose: boolean = options.enclose ? true : false;\r\n    const cap = options.cap === 0 ? 0 : options.cap || Mesh.CAP_ALL;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation: number = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(3);\r\n    const faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    const quadNb: number = arc !== 1 && enclose ? 2 : 0;\r\n    const ringNb: number = hasRings ? subdivisions : 1;\r\n    const surfaceNb: number = 2 + (1 + quadNb) * ringNb;\r\n    let f: number;\r\n\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n    }\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    const colors = new Array<number>();\r\n\r\n    const angleStep = (Math.PI * 2 * arc) / tessellation;\r\n    let angle: number;\r\n    let h: number;\r\n    let radius: number;\r\n    const tan = (diameterBottom - diameterTop) / 2 / height;\r\n    const ringVertex: Vector3 = Vector3.Zero();\r\n    const ringNormal: Vector3 = Vector3.Zero();\r\n    const ringFirstVertex: Vector3 = Vector3.Zero();\r\n    const ringFirstNormal: Vector3 = Vector3.Zero();\r\n    const quadNormal: Vector3 = Vector3.Zero();\r\n    const Y: Vector3 = Axis.Y;\r\n\r\n    // positions, normals, uvs\r\n    let i: number;\r\n    let j: number;\r\n    let r: number;\r\n    let ringIdx: number = 1;\r\n    let s: number = 1; // surface index\r\n    let cs: number = 0;\r\n    let v: number = 0;\r\n\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = hasRings && i !== 0 && i !== subdivisions ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angleStep;\r\n\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                } else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s].y : faceUV[s].w;\r\n                } else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + ((faceUV[s].z - faceUV[s].x) * j) / tessellation, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                Vector3.CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                } else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 1].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (hasRings) {\r\n                    v = cs !== s ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                } else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                uvs.push(faceUV[s + 2].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n\r\n    // indices\r\n    const e: number = arc !== 1 && enclose ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        let i0: number = 0;\r\n        let i1: number = 0;\r\n        let i2: number = 0;\r\n        let i3: number = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) {\r\n            // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = hasRings ? i + 2 : i + 1;\r\n    }\r\n\r\n    // Caps\r\n    const createCylinderCap = (isTop: boolean) => {\r\n        const radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n\r\n        // Cap positions, normals & uvs\r\n        let angle;\r\n        let circleVector;\r\n        let i: number;\r\n        const u: Vector4 = isTop ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        let c: Nullable<Color4> = null;\r\n        if (faceColors) {\r\n            c = isTop ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        const vbase = positions.length / 3;\r\n        const offset = isTop ? height / 2 : -height / 2;\r\n        const center = new Vector3(0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        const v = u.y + (u.w - u.y) * 0.5;\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n\r\n        const textureScale = new Vector2(0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = (Math.PI * 2 * i * arc) / tessellation;\r\n            const cos = Math.cos(-angle);\r\n            const sin = Math.sin(-angle);\r\n            circleVector = new Vector3(cos * radius, offset, sin * radius);\r\n            const textureCoordinate = new Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            const v = u.y + (u.w - u.y) * textureCoordinate.y;\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            } else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n\r\n    // add caps to geometry based on cap parameter\r\n    if (cap === Mesh.CAP_START || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(false);\r\n    }\r\n    if (cap === Mesh.CAP_END || cap === Mesh.CAP_ALL) {\r\n        createCylinderCap(true);\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a cylinder or a cone mesh\r\n * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n * * The parameter `cap` sets the way the cylinder is capped. Possible values : BABYLON.Mesh.NO_CAP, BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL (default).\r\n * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n * * If `enclose` is false, a ring surface is one element.\r\n * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.height\r\n * @param options.diameterTop\r\n * @param options.diameterBottom\r\n * @param options.diameter\r\n * @param options.tessellation\r\n * @param options.subdivisions\r\n * @param options.arc\r\n * @param options.faceColors\r\n * @param options.faceUV\r\n * @param options.updatable\r\n * @param options.hasRings\r\n * @param options.enclose\r\n * @param options.cap\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the cylinder mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#cylinder-or-cone\r\n */\r\nexport function CreateCylinder(\r\n    name: string,\r\n    options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        updatable?: boolean;\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        cap?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Nullable<Scene>\r\n): Mesh {\r\n    const cylinder = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateCylinderVertexData(options);\r\n\r\n    vertexData.applyToMesh(cylinder, options.updatable);\r\n\r\n    return cylinder;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated Please use CreateCylinder directly\r\n */\r\nexport const CylinderBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCylinder,\r\n};\r\n\r\nVertexData.CreateCylinder = CreateCylinderVertexData;\r\n\r\n(Mesh as any).CreateCylinder = (\r\n    name: string,\r\n    height: number,\r\n    diameterTop: number,\r\n    diameterBottom: number,\r\n    tessellation: number,\r\n    subdivisions: any,\r\n    scene?: Scene,\r\n    updatable?: any,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    if (scene === undefined || !(scene instanceof Scene)) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || Mesh.DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = <Scene>subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n\r\n    const options = {\r\n        height,\r\n        diameterTop,\r\n        diameterBottom,\r\n        tessellation,\r\n        subdivisions,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateCylinder(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}