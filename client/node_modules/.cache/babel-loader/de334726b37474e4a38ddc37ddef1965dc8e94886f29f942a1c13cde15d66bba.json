{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport \"../Shaders/postprocess.vertex.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { serialize, serializeAsColor4, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage.js\";\n/**\n * PostProcess can be used to apply a shader to a texture after it has been rendered\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\n */\nexport class PostProcess {\n  /**\n   * Creates a new instance PostProcess\n   * @param name The name of the PostProcess.\n   * @param fragmentUrl The url of the fragment shader to be used.\n   * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\n   * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param defines String of defines that will be set when running the fragment shader. (default: null)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   */\n  constructor(name, fragmentUrl, parameters, samplers, options, camera, samplingMode = 1, engine, reusable, defines = null, textureType = 0, vertexUrl = \"postprocess\", indexParameters, blockCompilation = false, textureFormat = 5, shaderLanguage = ShaderLanguage.GLSL) {\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * Width of the texture to apply the post process on\n     */\n    this.width = -1;\n    /**\n     * Height of the texture to apply the post process on\n     */\n    this.height = -1;\n    /**\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\n     */\n    this.nodeMaterialSource = null;\n    /**\n     * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\n     * @internal\n     */\n    this._outputTexture = null;\n    /**\n     * If the buffer needs to be cleared before applying the post process. (default: true)\n     * Should be set to false if shader will overwrite all previous pixels.\n     */\n    this.autoClear = true;\n    /**\n     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\n     */\n    this.alphaMode = 0;\n    /**\n     * Animations to be used for the post processing\n     */\n    this.animations = new Array();\n    /**\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\n     */\n    this.enablePixelPerfectMode = false;\n    /**\n     * Force the postprocess to be applied without taking in account viewport\n     */\n    this.forceFullscreenViewport = true;\n    /**\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\n     *\n     * | Value | Type                                | Description |\n     * | ----- | ----------------------------------- | ----------- |\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\n     *\n     */\n    this.scaleMode = 1;\n    /**\n     * Force textures to be a power of two (default: false)\n     */\n    this.alwaysForcePOT = false;\n    this._samples = 1;\n    /**\n     * Modify the scale of the post process to be the same as the viewport (default: false)\n     */\n    this.adaptScaleToCurrentViewport = false;\n    this._reusable = false;\n    this._renderId = 0;\n    /**\n     * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\n     * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\n     * internal structures (materialContext) will be dirtified, which may impact performances\n     */\n    this.externalTextureSamplerBinding = false;\n    /**\n     * Smart array of input and output textures for the post process.\n     * @internal\n     */\n    this._textures = new SmartArray(2);\n    /**\n     * Smart array of input and output textures for the post process.\n     * @internal\n     */\n    this._textureCache = [];\n    /**\n     * The index in _textures that corresponds to the output texture.\n     * @internal\n     */\n    this._currentRenderTextureInd = 0;\n    this._scaleRatio = new Vector2(1, 1);\n    this._texelSize = Vector2.Zero();\n    // Events\n    /**\n     * An event triggered when the postprocess is activated.\n     */\n    this.onActivateObservable = new Observable();\n    /**\n     * An event triggered when the postprocess changes its size.\n     */\n    this.onSizeChangedObservable = new Observable();\n    /**\n     * An event triggered when the postprocess applies its effect.\n     */\n    this.onApplyObservable = new Observable();\n    /**\n     * An event triggered before rendering the postprocess\n     */\n    this.onBeforeRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the postprocess\n     */\n    this.onAfterRenderObservable = new Observable();\n    this.name = name;\n    if (camera != null) {\n      this._camera = camera;\n      this._scene = camera.getScene();\n      camera.attachPostProcess(this);\n      this._engine = this._scene.getEngine();\n      this._scene.postProcesses.push(this);\n      this.uniqueId = this._scene.getUniqueId();\n    } else if (engine) {\n      this._engine = engine;\n      this._engine.postProcesses.push(this);\n    }\n    this._options = options;\n    this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;\n    this._reusable = reusable || false;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._shaderLanguage = shaderLanguage;\n    this._samplers = samplers || [];\n    this._samplers.push(\"textureSampler\");\n    this._fragmentUrl = fragmentUrl;\n    this._vertexUrl = vertexUrl;\n    this._parameters = parameters || [];\n    this._parameters.push(\"scale\");\n    this._indexParameters = indexParameters;\n    this._drawWrapper = new DrawWrapper(this._engine);\n    if (!blockCompilation) {\n      this.updateEffect(defines);\n    }\n  }\n  /**\n   * Registers a shader code processing with a post process name.\n   * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name\n   * @param customShaderCodeProcessing shader code processing to associate to the post process name\n   * @returns\n   */\n  static RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing) {\n    if (!customShaderCodeProcessing) {\n      delete PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : \"\"];\n      return;\n    }\n    PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : \"\"] = customShaderCodeProcessing;\n  }\n  static _GetShaderCodeProcessing(postProcessName) {\n    var _a;\n    return (_a = PostProcess._CustomShaderCodeProcessing[postProcessName]) !== null && _a !== void 0 ? _a : PostProcess._CustomShaderCodeProcessing[\"\"];\n  }\n  /**\n   * Number of sample textures (default: 1)\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(n) {\n    this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\n    this._textures.forEach(texture => {\n      texture.setSamples(this._samples);\n    });\n  }\n  /**\n   * Returns the fragment url or shader name used in the post process.\n   * @returns the fragment url or name in the shader store.\n   */\n  getEffectName() {\n    return this._fragmentUrl;\n  }\n  /**\n   * A function that is added to the onActivateObservable\n   */\n  set onActivate(callback) {\n    if (this._onActivateObserver) {\n      this.onActivateObservable.remove(this._onActivateObserver);\n    }\n    if (callback) {\n      this._onActivateObserver = this.onActivateObservable.add(callback);\n    }\n  }\n  /**\n   * A function that is added to the onSizeChangedObservable\n   */\n  set onSizeChanged(callback) {\n    if (this._onSizeChangedObserver) {\n      this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\n    }\n    this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\n  }\n  /**\n   * A function that is added to the onApplyObservable\n   */\n  set onApply(callback) {\n    if (this._onApplyObserver) {\n      this.onApplyObservable.remove(this._onApplyObserver);\n    }\n    this._onApplyObserver = this.onApplyObservable.add(callback);\n  }\n  /**\n   * A function that is added to the onBeforeRenderObservable\n   */\n  set onBeforeRender(callback) {\n    if (this._onBeforeRenderObserver) {\n      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n    }\n    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n  }\n  /**\n   * A function that is added to the onAfterRenderObservable\n   */\n  set onAfterRender(callback) {\n    if (this._onAfterRenderObserver) {\n      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    }\n    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n  }\n  /**\n   * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\n   * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\n   */\n  get inputTexture() {\n    return this._textures.data[this._currentRenderTextureInd];\n  }\n  set inputTexture(value) {\n    this._forcedOutputTexture = value;\n  }\n  /**\n   * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\n   * the only way to unset it is to use this function to restore its internal state\n   */\n  restoreDefaultInputTexture() {\n    if (this._forcedOutputTexture) {\n      this._forcedOutputTexture = null;\n      this.markTextureDirty();\n    }\n  }\n  /**\n   * Gets the camera which post process is applied to.\n   * @returns The camera the post process is applied to.\n   */\n  getCamera() {\n    return this._camera;\n  }\n  /**\n   * Gets the texel size of the postprocess.\n   * See https://en.wikipedia.org/wiki/Texel_(graphics)\n   */\n  get texelSize() {\n    if (this._shareOutputWithPostProcess) {\n      return this._shareOutputWithPostProcess.texelSize;\n    }\n    if (this._forcedOutputTexture) {\n      this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\n    }\n    return this._texelSize;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"PostProcess\" string\n   */\n  getClassName() {\n    return \"PostProcess\";\n  }\n  /**\n   * Gets the engine which this post process belongs to.\n   * @returns The engine the post process was enabled with.\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * The effect that is created when initializing the post process.\n   * @returns The created effect corresponding the the postprocess.\n   */\n  getEffect() {\n    return this._drawWrapper.effect;\n  }\n  /**\n   * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\n   * @param postProcess The post process to share the output with.\n   * @returns This post process.\n   */\n  shareOutputWith(postProcess) {\n    this._disposeTextures();\n    this._shareOutputWithPostProcess = postProcess;\n    return this;\n  }\n  /**\n   * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\n   * This should be called if the post process that shares output with this post process is disabled/disposed.\n   */\n  useOwnOutput() {\n    if (this._textures.length == 0) {\n      this._textures = new SmartArray(2);\n    }\n    this._shareOutputWithPostProcess = null;\n  }\n  /**\n   * Updates the effect with the current post process compile time values and recompiles the shader.\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param onCompiled Called when the shader has been compiled.\n   * @param onError Called if there is an error when compiling a shader.\n   * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\n   * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\n   */\n  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {\n    var _a, _b;\n    const customShaderCodeProcessing = PostProcess._GetShaderCodeProcessing(this.name);\n    if (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.defineCustomBindings) {\n      const newUniforms = (_a = uniforms === null || uniforms === void 0 ? void 0 : uniforms.slice()) !== null && _a !== void 0 ? _a : [];\n      newUniforms.push(...this._parameters);\n      const newSamplers = (_b = samplers === null || samplers === void 0 ? void 0 : samplers.slice()) !== null && _b !== void 0 ? _b : [];\n      newSamplers.push(...this._samplers);\n      defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);\n      uniforms = newUniforms;\n      samplers = newSamplers;\n    }\n    this._postProcessDefines = defines;\n    this._drawWrapper.effect = this._engine.createEffect({\n      vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl,\n      fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl\n    }, {\n      attributes: [\"position\"],\n      uniformsNames: uniforms || this._parameters,\n      uniformBuffersNames: [],\n      samplers: samplers || this._samplers,\n      defines: defines !== null ? defines : \"\",\n      fallbacks: null,\n      onCompiled: onCompiled !== null && onCompiled !== void 0 ? onCompiled : null,\n      onError: onError !== null && onError !== void 0 ? onError : null,\n      indexParameters: indexParameters || this._indexParameters,\n      processCodeAfterIncludes: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processCodeAfterIncludes) ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code) : null,\n      processFinalCode: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processFinalCode) ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code) : null,\n      shaderLanguage: this._shaderLanguage\n    }, this._engine);\n  }\n  /**\n   * The post process is reusable if it can be used multiple times within one frame.\n   * @returns If the post process is reusable\n   */\n  isReusable() {\n    return this._reusable;\n  }\n  /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\n  markTextureDirty() {\n    this.width = -1;\n  }\n  _createRenderTargetTexture(textureSize, textureOptions, channel = 0) {\n    for (let i = 0; i < this._textureCache.length; i++) {\n      if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer && this._textureCache[i].texture.samples === textureOptions.samples) {\n        return this._textureCache[i].texture;\n      }\n    }\n    const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\n    this._textureCache.push({\n      texture: tex,\n      postProcessChannel: channel,\n      lastUsedRenderId: -1\n    });\n    return tex;\n  }\n  _flushTextureCache() {\n    const currentRenderId = this._renderId;\n    for (let i = this._textureCache.length - 1; i >= 0; i--) {\n      if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\n        let currentlyUsed = false;\n        for (let j = 0; j < this._textures.length; j++) {\n          if (this._textures.data[j] === this._textureCache[i].texture) {\n            currentlyUsed = true;\n            break;\n          }\n        }\n        if (!currentlyUsed) {\n          this._textureCache[i].texture.dispose();\n          this._textureCache.splice(i, 1);\n        }\n      }\n    }\n  }\n  _resize(width, height, camera, needMipMaps, forceDepthStencil) {\n    if (this._textures.length > 0) {\n      this._textures.reset();\n    }\n    this.width = width;\n    this.height = height;\n    let firstPP = null;\n    for (let i = 0; i < camera._postProcesses.length; i++) {\n      if (camera._postProcesses[i] !== null) {\n        firstPP = camera._postProcesses[i];\n        break;\n      }\n    }\n    const textureSize = {\n      width: this.width,\n      height: this.height\n    };\n    const textureOptions = {\n      generateMipMaps: needMipMaps,\n      generateDepthBuffer: forceDepthStencil || firstPP === this,\n      generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\n      samplingMode: this.renderTargetSamplingMode,\n      type: this._textureType,\n      format: this._textureFormat,\n      samples: this._samples\n    };\n    this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\n    if (this._reusable) {\n      this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\n    }\n    this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\n    this.onSizeChangedObservable.notifyObservers(this);\n  }\n  /**\n   * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\n   * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\n   * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\n   * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\n   * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\n   * @returns The render target wrapper that was bound to be written to.\n   */\n  activate(camera, sourceTexture = null, forceDepthStencil) {\n    var _a, _b;\n    camera = camera || this._camera;\n    const scene = camera.getScene();\n    const engine = scene.getEngine();\n    const maxSize = engine.getCaps().maxTextureSize;\n    let requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;\n    const requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;\n    // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\n    const webVRCamera = camera.parent;\n    if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\n      requiredWidth /= 2;\n    }\n    let desiredWidth = this._options.width || requiredWidth;\n    let desiredHeight = this._options.height || requiredHeight;\n    const needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;\n    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n      if (this.adaptScaleToCurrentViewport) {\n        const currentViewport = engine.currentViewport;\n        if (currentViewport) {\n          desiredWidth *= currentViewport.width;\n          desiredHeight *= currentViewport.height;\n        }\n      }\n      if (needMipMaps || this.alwaysForcePOT) {\n        if (!this._options.width) {\n          desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\n        }\n        if (!this._options.height) {\n          desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\n        }\n      }\n      if (this.width !== desiredWidth || this.height !== desiredHeight) {\n        this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\n      }\n      this._textures.forEach(texture => {\n        if (texture.samples !== this.samples) {\n          this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\n        }\n      });\n      this._flushTextureCache();\n      this._renderId++;\n    }\n    let target;\n    if (this._shareOutputWithPostProcess) {\n      target = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      target = this._forcedOutputTexture;\n      this.width = this._forcedOutputTexture.width;\n      this.height = this._forcedOutputTexture.height;\n    } else {\n      target = this.inputTexture;\n      let cache;\n      for (let i = 0; i < this._textureCache.length; i++) {\n        if (this._textureCache[i].texture === target) {\n          cache = this._textureCache[i];\n          break;\n        }\n      }\n      if (cache) {\n        cache.lastUsedRenderId = this._renderId;\n      }\n    }\n    // Bind the input of this post process to be used as the output of the previous post process.\n    if (this.enablePixelPerfectMode) {\n      this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\n      this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\n    } else {\n      this._scaleRatio.copyFromFloats(1, 1);\n      this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\n    }\n    (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, `post process ${this.name} input`);\n    this.onActivateObservable.notifyObservers(camera);\n    // Clear\n    if (this.autoClear && this.alphaMode === 0) {\n      this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\n    }\n    if (this._reusable) {\n      this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\n    }\n    return target;\n  }\n  /**\n   * If the post process is supported.\n   */\n  get isSupported() {\n    return this._drawWrapper.effect.isSupported;\n  }\n  /**\n   * The aspect ratio of the output texture.\n   */\n  get aspectRatio() {\n    if (this._shareOutputWithPostProcess) {\n      return this._shareOutputWithPostProcess.aspectRatio;\n    }\n    if (this._forcedOutputTexture) {\n      return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\n    }\n    return this.width / this.height;\n  }\n  /**\n   * Get a value indicating if the post-process is ready to be used\n   * @returns true if the post-process is ready (shader is compiled)\n   */\n  isReady() {\n    var _a, _b;\n    return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\n   * Binds all textures and uniforms to the shader, this will be run on every pass.\n   * @returns the effect corresponding to this post process. Null if not compiled or not ready.\n   */\n  apply() {\n    var _a, _b, _c;\n    // Check\n    if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {\n      return null;\n    }\n    // States\n    this._engine.enableEffect(this._drawWrapper);\n    this._engine.setState(false);\n    this._engine.setDepthBuffer(false);\n    this._engine.setDepthWrite(false);\n    // Alpha\n    this._engine.setAlphaMode(this.alphaMode);\n    if (this.alphaConstants) {\n      this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\n    }\n    // Bind the output texture of the preivous post process as the input to this post process.\n    let source;\n    if (this._shareOutputWithPostProcess) {\n      source = this._shareOutputWithPostProcess.inputTexture;\n    } else if (this._forcedOutputTexture) {\n      source = this._forcedOutputTexture;\n    } else {\n      source = this.inputTexture;\n    }\n    if (!this.externalTextureSamplerBinding) {\n      this._drawWrapper.effect._bindTexture(\"textureSampler\", source === null || source === void 0 ? void 0 : source.texture);\n    }\n    // Parameters\n    this._drawWrapper.effect.setVector2(\"scale\", this._scaleRatio);\n    this.onApplyObservable.notifyObservers(this._drawWrapper.effect);\n    (_c = (_b = PostProcess._GetShaderCodeProcessing(this.name)) === null || _b === void 0 ? void 0 : _b.bindCustomBindings) === null || _c === void 0 ? void 0 : _c.call(_b, this.name, this._drawWrapper.effect);\n    return this._drawWrapper.effect;\n  }\n  _disposeTextures() {\n    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\n      this._disposeTextureCache();\n      return;\n    }\n    this._disposeTextureCache();\n    this._textures.dispose();\n  }\n  _disposeTextureCache() {\n    for (let i = this._textureCache.length - 1; i >= 0; i--) {\n      this._textureCache[i].texture.dispose();\n    }\n    this._textureCache.length = 0;\n  }\n  /**\n   * Sets the required values to the prepass renderer.\n   * @param prePassRenderer defines the prepass renderer to setup.\n   * @returns true if the pre pass is needed.\n   */\n  setPrePassRenderer(prePassRenderer) {\n    if (this._prePassEffectConfiguration) {\n      this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\n      this._prePassEffectConfiguration.enabled = true;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Disposes the post process.\n   * @param camera The camera to dispose the post process on.\n   */\n  dispose(camera) {\n    camera = camera || this._camera;\n    this._disposeTextures();\n    let index;\n    if (this._scene) {\n      index = this._scene.postProcesses.indexOf(this);\n      if (index !== -1) {\n        this._scene.postProcesses.splice(index, 1);\n      }\n    }\n    if (this._parentContainer) {\n      const index = this._parentContainer.postProcesses.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.postProcesses.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    index = this._engine.postProcesses.indexOf(this);\n    if (index !== -1) {\n      this._engine.postProcesses.splice(index, 1);\n    }\n    if (!camera) {\n      return;\n    }\n    camera.detachPostProcess(this);\n    index = camera._postProcesses.indexOf(this);\n    if (index === 0 && camera._postProcesses.length > 0) {\n      const firstPostProcess = this._camera._getFirstPostProcess();\n      if (firstPostProcess) {\n        firstPostProcess.markTextureDirty();\n      }\n    }\n    this.onActivateObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onApplyObservable.clear();\n    this.onBeforeRenderObservable.clear();\n    this.onSizeChangedObservable.clear();\n  }\n  /**\n   * Serializes the post process to a JSON object\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    const camera = this.getCamera() || this._scene && this._scene.activeCamera;\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.cameraId = camera ? camera.id : null;\n    serializationObject.reusable = this._reusable;\n    serializationObject.textureType = this._textureType;\n    serializationObject.fragmentUrl = this._fragmentUrl;\n    serializationObject.parameters = this._parameters;\n    serializationObject.samplers = this._samplers;\n    serializationObject.options = this._options;\n    serializationObject.defines = this._postProcessDefines;\n    serializationObject.textureFormat = this._textureFormat;\n    serializationObject.vertexUrl = this._vertexUrl;\n    serializationObject.indexParameters = this._indexParameters;\n    return serializationObject;\n  }\n  /**\n   * Clones this post process\n   * @returns a new post process similar to this one\n   */\n  clone() {\n    const serializationObject = this.serialize();\n    serializationObject._engine = this._engine;\n    serializationObject.cameraId = null;\n    const result = PostProcess.Parse(serializationObject, this._scene, \"\");\n    if (!result) {\n      return null;\n    }\n    result.onActivateObservable = this.onActivateObservable.clone();\n    result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\n    result.onApplyObservable = this.onApplyObservable.clone();\n    result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\n    result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\n    result._prePassEffectConfiguration = this._prePassEffectConfiguration;\n    return result;\n  }\n  /**\n   * Creates a material from parsed material data\n   * @param parsedPostProcess defines parsed post process data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures\n   * @returns a new post process\n   */\n  static Parse(parsedPostProcess, scene, rootUrl) {\n    const postProcessType = GetClass(parsedPostProcess.customType);\n    if (!postProcessType || !postProcessType._Parse) {\n      return null;\n    }\n    const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\n    return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\nPostProcess._CustomShaderCodeProcessing = {};\n__decorate([serialize()], PostProcess.prototype, \"uniqueId\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"name\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"width\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"height\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"renderTargetSamplingMode\", void 0);\n__decorate([serializeAsColor4()], PostProcess.prototype, \"clearColor\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"autoClear\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"alphaMode\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"alphaConstants\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"enablePixelPerfectMode\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"forceFullscreenViewport\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"scaleMode\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"alwaysForcePOT\", void 0);\n__decorate([serialize(\"samples\")], PostProcess.prototype, \"_samples\", void 0);\n__decorate([serialize()], PostProcess.prototype, \"adaptScaleToCurrentViewport\", void 0);\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);","map":{"version":3,"mappings":"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","names":["SmartArray","Observable","Vector2","Engine","serialize","serializeAsColor4","SerializationHelper","GetClass","RegisterClass","DrawWrapper","ShaderLanguage","PostProcess","constructor","name","fragmentUrl","parameters","samplers","options","camera","samplingMode","reusable","blockCompilation","textureFormat","Array","Zero","_camera","_scene","getScene","attachPostProcess","_engine","getEngine","postProcesses","push","uniqueId","getUniqueId","engine","_options","renderTargetSamplingMode","_reusable","_textureType","textureType","_textureFormat","_shaderLanguage","shaderLanguage","_samplers","_fragmentUrl","_vertexUrl","vertexUrl","_parameters","_indexParameters","indexParameters","_drawWrapper","updateEffect","defines","RegisterShaderCodeProcessing","postProcessName","customShaderCodeProcessing","_CustomShaderCodeProcessing","_GetShaderCodeProcessing","samples","_samples","n","Math","min","getCaps","maxMSAASamples","_textures","forEach","texture","setSamples","getEffectName","onActivate","callback","_onActivateObserver","onActivateObservable","remove","add","onSizeChanged","_onSizeChangedObserver","onSizeChangedObservable","onApply","_onApplyObserver","onApplyObservable","onBeforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","onAfterRender","_onAfterRenderObserver","onAfterRenderObservable","inputTexture","data","_currentRenderTextureInd","value","_forcedOutputTexture","restoreDefaultInputTexture","markTextureDirty","getCamera","texelSize","_shareOutputWithPostProcess","_texelSize","copyFromFloats","width","height","getClassName","getEffect","effect","shareOutputWith","postProcess","_disposeTextures","useOwnOutput","length","uniforms","onCompiled","onError","defineCustomBindings","newUniforms","slice","newSamplers","_postProcessDefines","createEffect","vertex","fragment","attributes","uniformsNames","uniformBuffersNames","fallbacks","processCodeAfterIncludes","shaderType","code","processFinalCode","isReusable","_createRenderTargetTexture","textureSize","textureOptions","channel","i","_textureCache","postProcessChannel","_generateDepthBuffer","generateDepthBuffer","tex","createRenderTargetTexture","lastUsedRenderId","_flushTextureCache","currentRenderId","_renderId","currentlyUsed","j","dispose","splice","_resize","needMipMaps","forceDepthStencil","reset","firstPP","_postProcesses","generateMipMaps","generateStencilBuffer","isStencilEnable","type","format","notifyObservers","activate","sourceTexture","scene","maxSize","maxTextureSize","requiredWidth","getRenderWidth","requiredHeight","getRenderHeight","webVRCamera","parent","leftCamera","rightCamera","desiredWidth","desiredHeight","adaptScaleToCurrentViewport","currentViewport","alwaysForcePOT","needPOTTextures","GetExponentOfTwo","scaleMode","updateRenderTargetTextureSampleCount","target","cache","enablePixelPerfectMode","_scaleRatio","bindFramebuffer","forceFullscreenViewport","undefined","_debugInsertMarker","autoClear","alphaMode","clear","clearColor","_allowPostProcessClearColor","isSupported","aspectRatio","isReady","apply","enableEffect","setState","setDepthBuffer","setDepthWrite","setAlphaMode","alphaConstants","setAlphaConstants","r","g","b","a","source","externalTextureSamplerBinding","_bindTexture","setVector2","bindCustomBindings","_disposeTextureCache","setPrePassRenderer","prePassRenderer","_prePassEffectConfiguration","addEffectConfiguration","enabled","index","indexOf","_parentContainer","detachPostProcess","firstPostProcess","_getFirstPostProcess","serializationObject","Serialize","activeCamera","customType","cameraId","id","clone","result","Parse","parsedPostProcess","rootUrl","postProcessType","_Parse","getCameraById","targetCamera","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/postProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport \"../Shaders/postprocess.vertex\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { Color4 } from \"../Maths/math.color\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport type { NodeMaterial } from \"../Materials/Node/nodeMaterial\";\r\nimport { serialize, serializeAsColor4, SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass, RegisterClass } from \"../Misc/typeStore\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type WebVRFreeCamera = import(\"../Cameras/VR/webVRCamera\").WebVRFreeCamera;\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type PrePassRenderer = import(\"../Rendering/prePassRenderer\").PrePassRenderer;\r\ndeclare type PrePassEffectConfiguration = import(\"../Rendering/prePassEffectConfiguration\").PrePassEffectConfiguration;\r\n\r\n/**\r\n * Allows for custom processing of the shader code used by a post process\r\n */\r\nexport type PostProcessCustomShaderCodeProcessing = {\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated after the #include have been processed\r\n     */\r\n    processCodeAfterIncludes?: (postProcessName: string, shaderType: string, code: string) => string;\r\n    /**\r\n     * If provided, will be called two times with the vertex and fragment code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: (postProcessName: string, shaderType: string, code: string) => string;\r\n    /**\r\n     * If provided, will be called before creating the effect to collect additional custom bindings (defines, uniforms, samplers)\r\n     */\r\n    defineCustomBindings?: (postProcessName: string, defines: Nullable<string>, uniforms: string[], samplers: string[]) => Nullable<string>;\r\n    /**\r\n     * If provided, will be called when binding inputs to the shader code to allow the user to add custom bindings\r\n     */\r\n    bindCustomBindings?: (postProcessName: string, effect: Effect) => void;\r\n};\r\n\r\n/**\r\n * Size options for a post process\r\n */\r\nexport type PostProcessOptions = { width: number; height: number };\r\n\r\ntype TextureCache = { texture: RenderTargetWrapper; postProcessChannel: number; lastUsedRenderId: number };\r\n\r\n/**\r\n * PostProcess can be used to apply a shader to a texture after it has been rendered\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcess {\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    private static _CustomShaderCodeProcessing: { [postProcessName: string]: PostProcessCustomShaderCodeProcessing } = {};\r\n\r\n    /**\r\n     * Registers a shader code processing with a post process name.\r\n     * @param postProcessName name of the post process. Use null for the fallback shader code processing. This is the shader code processing that will be used in case no specific shader code processing has been associated to a post process name\r\n     * @param customShaderCodeProcessing shader code processing to associate to the post process name\r\n     * @returns\r\n     */\r\n    public static RegisterShaderCodeProcessing(postProcessName: Nullable<string>, customShaderCodeProcessing?: PostProcessCustomShaderCodeProcessing) {\r\n        if (!customShaderCodeProcessing) {\r\n            delete PostProcess._CustomShaderCodeProcessing[postProcessName ?? \"\"];\r\n            return;\r\n        }\r\n\r\n        PostProcess._CustomShaderCodeProcessing[postProcessName ?? \"\"] = customShaderCodeProcessing;\r\n    }\r\n\r\n    private static _GetShaderCodeProcessing(postProcessName: string) {\r\n        return PostProcess._CustomShaderCodeProcessing[postProcessName] ?? PostProcess._CustomShaderCodeProcessing[\"\"];\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the post process\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /** Name of the PostProcess. */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Width of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public width = -1;\r\n\r\n    /**\r\n     * Height of the texture to apply the post process on\r\n     */\r\n    @serialize()\r\n    public height = -1;\r\n\r\n    /**\r\n     * Gets the node material used to create this postprocess (null if the postprocess was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)\r\n     * @internal\r\n     */\r\n    public _outputTexture: Nullable<RenderTargetWrapper> = null;\r\n    /**\r\n     * Sampling mode used by the shader\r\n     * See https://doc.babylonjs.com/classes/3.1/texture\r\n     */\r\n    @serialize()\r\n    public renderTargetSamplingMode: number;\r\n    /**\r\n     * Clear color to use when screen clearing\r\n     */\r\n    @serializeAsColor4()\r\n    public clearColor: Color4;\r\n    /**\r\n     * If the buffer needs to be cleared before applying the post process. (default: true)\r\n     * Should be set to false if shader will overwrite all previous pixels.\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n    /**\r\n     * Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)\r\n     */\r\n    @serialize()\r\n    public alphaMode = Constants.ALPHA_DISABLE;\r\n    /**\r\n     * Sets the setAlphaBlendConstants of the babylon engine\r\n     */\r\n    @serialize()\r\n    public alphaConstants: Color4;\r\n    /**\r\n     * Animations to be used for the post processing\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Enable Pixel Perfect mode where texture is not scaled to be power of 2.\r\n     * Can only be used on a single postprocess or on the last one of a chain. (default: false)\r\n     */\r\n    @serialize()\r\n    public enablePixelPerfectMode = false;\r\n\r\n    /**\r\n     * Force the postprocess to be applied without taking in account viewport\r\n     */\r\n    @serialize()\r\n    public forceFullscreenViewport = true;\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    /**\r\n     * Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 1     | SCALEMODE_FLOOR                     | [engine.scalemode_floor](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_floor) |\r\n     * | 2     | SCALEMODE_NEAREST                   | [engine.scalemode_nearest](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_nearest) |\r\n     * | 3     | SCALEMODE_CEILING                   | [engine.scalemode_ceiling](https://doc.babylonjs.com/api/classes/babylon.engine#scalemode_ceiling) |\r\n     *\r\n     */\r\n    @serialize()\r\n    public scaleMode = Constants.SCALEMODE_FLOOR;\r\n    /**\r\n     * Force textures to be a power of two (default: false)\r\n     */\r\n    @serialize()\r\n    public alwaysForcePOT = false;\r\n\r\n    @serialize(\"samples\")\r\n    private _samples = 1;\r\n\r\n    /**\r\n     * Number of sample textures (default: 1)\r\n     */\r\n    public get samples() {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(n: number) {\r\n        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);\r\n\r\n        this._textures.forEach((texture) => {\r\n            texture.setSamples(this._samples);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Modify the scale of the post process to be the same as the viewport (default: false)\r\n     */\r\n    @serialize()\r\n    public adaptScaleToCurrentViewport = false;\r\n\r\n    private _camera: Camera;\r\n    protected _scene: Scene;\r\n    private _engine: Engine;\r\n\r\n    private _options: number | PostProcessOptions;\r\n    private _reusable = false;\r\n    private _renderId = 0;\r\n    private _textureType: number;\r\n    private _textureFormat: number;\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * if externalTextureSamplerBinding is true, the \"apply\" method won't bind the textureSampler texture, it is expected to be done by the \"outside\" (by the onApplyObservable observer most probably).\r\n     * counter-productive in some cases because if the texture bound by \"apply\" is different from the currently texture bound, (the one set by the onApplyObservable observer, for eg) some\r\n     * internal structures (materialContext) will be dirtified, which may impact performances\r\n     */\r\n    public externalTextureSamplerBinding = false;\r\n\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @internal\r\n     */\r\n    public _textures = new SmartArray<RenderTargetWrapper>(2);\r\n    /**\r\n     * Smart array of input and output textures for the post process.\r\n     * @internal\r\n     */\r\n    private _textureCache: TextureCache[] = [];\r\n    /**\r\n     * The index in _textures that corresponds to the output texture.\r\n     * @internal\r\n     */\r\n    public _currentRenderTextureInd = 0;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _samplers: string[];\r\n    private _fragmentUrl: string;\r\n    private _vertexUrl: string;\r\n    private _parameters: string[];\r\n    protected _postProcessDefines: Nullable<string>;\r\n    private _scaleRatio = new Vector2(1, 1);\r\n    protected _indexParameters: any;\r\n    private _shareOutputWithPostProcess: Nullable<PostProcess>;\r\n    private _texelSize = Vector2.Zero();\r\n\r\n    /** @internal */\r\n    public _forcedOutputTexture: Nullable<RenderTargetWrapper>;\r\n\r\n    /**\r\n     * Prepass configuration in case this post process needs a texture from prepass\r\n     * @internal\r\n     */\r\n    public _prePassEffectConfiguration: PrePassEffectConfiguration;\r\n\r\n    /**\r\n     * Returns the fragment url or shader name used in the post process.\r\n     * @returns the fragment url or name in the shader store.\r\n     */\r\n    public getEffectName(): string {\r\n        return this._fragmentUrl;\r\n    }\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An event triggered when the postprocess is activated.\r\n     */\r\n    public onActivateObservable = new Observable<Camera>();\r\n\r\n    private _onActivateObserver: Nullable<Observer<Camera>>;\r\n    /**\r\n     * A function that is added to the onActivateObservable\r\n     */\r\n    public set onActivate(callback: Nullable<(camera: Camera) => void>) {\r\n        if (this._onActivateObserver) {\r\n            this.onActivateObservable.remove(this._onActivateObserver);\r\n        }\r\n        if (callback) {\r\n            this._onActivateObserver = this.onActivateObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess changes its size.\r\n     */\r\n    public onSizeChangedObservable = new Observable<PostProcess>();\r\n\r\n    private _onSizeChangedObserver: Nullable<Observer<PostProcess>>;\r\n    /**\r\n     * A function that is added to the onSizeChangedObservable\r\n     */\r\n    public set onSizeChanged(callback: (postProcess: PostProcess) => void) {\r\n        if (this._onSizeChangedObserver) {\r\n            this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\r\n        }\r\n        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the postprocess applies its effect.\r\n     */\r\n    public onApplyObservable = new Observable<Effect>();\r\n\r\n    private _onApplyObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onApplyObservable\r\n     */\r\n    public set onApply(callback: (effect: Effect) => void) {\r\n        if (this._onApplyObserver) {\r\n            this.onApplyObservable.remove(this._onApplyObserver);\r\n        }\r\n        this._onApplyObserver = this.onApplyObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the postprocess\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Effect>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onBeforeRenderObservable\r\n     */\r\n    public set onBeforeRender(callback: (effect: Effect) => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the postprocess\r\n     */\r\n    public onAfterRenderObservable = new Observable<Effect>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Effect>>;\r\n    /**\r\n     * A function that is added to the onAfterRenderObservable\r\n     */\r\n    public set onAfterRender(callback: (efect: Effect) => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will\r\n     * render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.\r\n     */\r\n    public get inputTexture(): RenderTargetWrapper {\r\n        return this._textures.data[this._currentRenderTextureInd];\r\n    }\r\n\r\n    public set inputTexture(value: RenderTargetWrapper) {\r\n        this._forcedOutputTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Since inputTexture should always be defined, if we previously manually set `inputTexture`,\r\n     * the only way to unset it is to use this function to restore its internal state\r\n     */\r\n    public restoreDefaultInputTexture() {\r\n        if (this._forcedOutputTexture) {\r\n            this._forcedOutputTexture = null;\r\n            this.markTextureDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera which post process is applied to.\r\n     * @returns The camera the post process is applied to.\r\n     */\r\n    public getCamera(): Camera {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the texel size of the postprocess.\r\n     * See https://en.wikipedia.org/wiki/Texel_(graphics)\r\n     */\r\n    public get texelSize(): Vector2 {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.texelSize;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture.width, 1.0 / this._forcedOutputTexture.height);\r\n        }\r\n\r\n        return this._texelSize;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param name The name of the PostProcess.\r\n     * @param fragmentUrl The url of the fragment shader to be used.\r\n     * @param parameters Array of the names of uniform non-sampler2D variables that will be passed to the shader.\r\n     * @param samplers Array of the names of uniform sampler2D variables that will be passed to the shader.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param defines String of defines that will be set when running the fragment shader. (default: null)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param vertexUrl The url of the vertex shader to be used. (default: \"postprocess\")\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param blockCompilation If the shader should not be compiled immediatly. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        fragmentUrl: string,\r\n        parameters: Nullable<string[]>,\r\n        samplers: Nullable<string[]>,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        defines: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        vertexUrl: string = \"postprocess\",\r\n        indexParameters?: any,\r\n        blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA,\r\n        shaderLanguage = ShaderLanguage.GLSL\r\n    ) {\r\n        this.name = name;\r\n        if (camera != null) {\r\n            this._camera = camera;\r\n            this._scene = camera.getScene();\r\n            camera.attachPostProcess(this);\r\n            this._engine = this._scene.getEngine();\r\n\r\n            this._scene.postProcesses.push(this);\r\n            this.uniqueId = this._scene.getUniqueId();\r\n        } else if (engine) {\r\n            this._engine = engine;\r\n            this._engine.postProcesses.push(this);\r\n        }\r\n        this._options = options;\r\n        this.renderTargetSamplingMode = samplingMode ? samplingMode : Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        this._reusable = reusable || false;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._shaderLanguage = shaderLanguage;\r\n\r\n        this._samplers = samplers || [];\r\n        this._samplers.push(\"textureSampler\");\r\n\r\n        this._fragmentUrl = fragmentUrl;\r\n        this._vertexUrl = vertexUrl;\r\n        this._parameters = parameters || [];\r\n\r\n        this._parameters.push(\"scale\");\r\n\r\n        this._indexParameters = indexParameters;\r\n        this._drawWrapper = new DrawWrapper(this._engine);\r\n\r\n        if (!blockCompilation) {\r\n            this.updateEffect(defines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"PostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Gets the engine which this post process belongs to.\r\n     * @returns The engine the post process was enabled with.\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.\r\n     * @param postProcess The post process to share the output with.\r\n     * @returns This post process.\r\n     */\r\n    public shareOutputWith(postProcess: PostProcess): PostProcess {\r\n        this._disposeTextures();\r\n\r\n        this._shareOutputWithPostProcess = postProcess;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reverses the effect of calling shareOutputWith and returns the post process back to its original state.\r\n     * This should be called if the post process that shares output with this post process is disabled/disposed.\r\n     */\r\n    public useOwnOutput() {\r\n        if (this._textures.length == 0) {\r\n            this._textures = new SmartArray<RenderTargetWrapper>(2);\r\n        }\r\n\r\n        this._shareOutputWithPostProcess = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     * @param vertexUrl The url of the vertex shader to be used (default: the one given at construction time)\r\n     * @param fragmentUrl The url of the fragment shader to be used (default: the one given at construction time)\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        vertexUrl?: string,\r\n        fragmentUrl?: string\r\n    ) {\r\n        const customShaderCodeProcessing = PostProcess._GetShaderCodeProcessing(this.name);\r\n        if (customShaderCodeProcessing?.defineCustomBindings) {\r\n            const newUniforms = uniforms?.slice() ?? [];\r\n            newUniforms.push(...this._parameters);\r\n\r\n            const newSamplers = samplers?.slice() ?? [];\r\n            newSamplers.push(...this._samplers);\r\n\r\n            defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);\r\n            uniforms = newUniforms;\r\n            samplers = newSamplers;\r\n        }\r\n        this._postProcessDefines = defines;\r\n        this._drawWrapper.effect = this._engine.createEffect(\r\n            { vertex: vertexUrl ?? this._vertexUrl, fragment: fragmentUrl ?? this._fragmentUrl },\r\n            {\r\n                attributes: [\"position\"],\r\n                uniformsNames: uniforms || this._parameters,\r\n                uniformBuffersNames: [],\r\n                samplers: samplers || this._samplers,\r\n                defines: defines !== null ? defines : \"\",\r\n                fallbacks: null,\r\n                onCompiled: onCompiled ?? null,\r\n                onError: onError ?? null,\r\n                indexParameters: indexParameters || this._indexParameters,\r\n                processCodeAfterIncludes: customShaderCodeProcessing?.processCodeAfterIncludes\r\n                    ? (shaderType: string, code: string) => customShaderCodeProcessing!.processCodeAfterIncludes!(this.name, shaderType, code)\r\n                    : null,\r\n                processFinalCode: customShaderCodeProcessing?.processFinalCode\r\n                    ? (shaderType: string, code: string) => customShaderCodeProcessing!.processFinalCode!(this.name, shaderType, code)\r\n                    : null,\r\n                shaderLanguage: this._shaderLanguage,\r\n            },\r\n            this._engine\r\n        );\r\n    }\r\n\r\n    /**\r\n     * The post process is reusable if it can be used multiple times within one frame.\r\n     * @returns If the post process is reusable\r\n     */\r\n    public isReusable(): boolean {\r\n        return this._reusable;\r\n    }\r\n\r\n    /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\r\n    public markTextureDirty(): void {\r\n        this.width = -1;\r\n    }\r\n\r\n    private _createRenderTargetTexture(textureSize: { width: number; height: number }, textureOptions: RenderTargetCreationOptions, channel = 0) {\r\n        for (let i = 0; i < this._textureCache.length; i++) {\r\n            if (\r\n                this._textureCache[i].texture.width === textureSize.width &&\r\n                this._textureCache[i].texture.height === textureSize.height &&\r\n                this._textureCache[i].postProcessChannel === channel &&\r\n                this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer &&\r\n                this._textureCache[i].texture.samples === textureOptions.samples\r\n            ) {\r\n                return this._textureCache[i].texture;\r\n            }\r\n        }\r\n\r\n        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);\r\n        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });\r\n\r\n        return tex;\r\n    }\r\n\r\n    private _flushTextureCache() {\r\n        const currentRenderId = this._renderId;\r\n\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {\r\n                let currentlyUsed = false;\r\n                for (let j = 0; j < this._textures.length; j++) {\r\n                    if (this._textures.data[j] === this._textureCache[i].texture) {\r\n                        currentlyUsed = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!currentlyUsed) {\r\n                    this._textureCache[i].texture.dispose();\r\n                    this._textureCache.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _resize(width: number, height: number, camera: Camera, needMipMaps: boolean, forceDepthStencil?: boolean) {\r\n        if (this._textures.length > 0) {\r\n            this._textures.reset();\r\n        }\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        let firstPP = null;\r\n        for (let i = 0; i < camera._postProcesses.length; i++) {\r\n            if (camera._postProcesses[i] !== null) {\r\n                firstPP = camera._postProcesses[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        const textureSize = { width: this.width, height: this.height };\r\n        const textureOptions = {\r\n            generateMipMaps: needMipMaps,\r\n            generateDepthBuffer: forceDepthStencil || firstPP === this,\r\n            generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,\r\n            samplingMode: this.renderTargetSamplingMode,\r\n            type: this._textureType,\r\n            format: this._textureFormat,\r\n            samples: this._samples,\r\n        };\r\n\r\n        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));\r\n\r\n        if (this._reusable) {\r\n            this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));\r\n        }\r\n\r\n        this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\r\n\r\n        this.onSizeChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.\r\n     * When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.\r\n     * @param camera The camera that will be used in the post process. This camera will be used when calling onActivateObservable.\r\n     * @param sourceTexture The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)\r\n     * @param forceDepthStencil If true, a depth and stencil buffer will be generated. (default: false)\r\n     * @returns The render target wrapper that was bound to be written to.\r\n     */\r\n    public activate(camera: Nullable<Camera>, sourceTexture: Nullable<InternalTexture> = null, forceDepthStencil?: boolean): RenderTargetWrapper {\r\n        camera = camera || this._camera;\r\n\r\n        const scene = camera.getScene();\r\n        const engine = scene.getEngine();\r\n        const maxSize = engine.getCaps().maxTextureSize;\r\n\r\n        let requiredWidth = ((sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * <number>this._options) | 0;\r\n        const requiredHeight = ((sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * <number>this._options) | 0;\r\n\r\n        // If rendering to a webvr camera's left or right eye only half the width should be used to avoid resize when rendered to screen\r\n        const webVRCamera = <WebVRFreeCamera>camera.parent;\r\n        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {\r\n            requiredWidth /= 2;\r\n        }\r\n\r\n        let desiredWidth = (<PostProcessOptions>this._options).width || requiredWidth;\r\n        let desiredHeight = (<PostProcessOptions>this._options).height || requiredHeight;\r\n\r\n        const needMipMaps =\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_LINEAR &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_NEAREST_NEAREST &&\r\n            this.renderTargetSamplingMode !== Constants.TEXTURE_LINEAR_LINEAR;\r\n\r\n        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\r\n            if (this.adaptScaleToCurrentViewport) {\r\n                const currentViewport = engine.currentViewport;\r\n\r\n                if (currentViewport) {\r\n                    desiredWidth *= currentViewport.width;\r\n                    desiredHeight *= currentViewport.height;\r\n                }\r\n            }\r\n\r\n            if (needMipMaps || this.alwaysForcePOT) {\r\n                if (!(<PostProcessOptions>this._options).width) {\r\n                    desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;\r\n                }\r\n\r\n                if (!(<PostProcessOptions>this._options).height) {\r\n                    desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;\r\n                }\r\n            }\r\n\r\n            if (this.width !== desiredWidth || this.height !== desiredHeight) {\r\n                this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);\r\n            }\r\n\r\n            this._textures.forEach((texture) => {\r\n                if (texture.samples !== this.samples) {\r\n                    this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);\r\n                }\r\n            });\r\n\r\n            this._flushTextureCache();\r\n            this._renderId++;\r\n        }\r\n\r\n        let target: RenderTargetWrapper;\r\n\r\n        if (this._shareOutputWithPostProcess) {\r\n            target = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            target = this._forcedOutputTexture;\r\n\r\n            this.width = this._forcedOutputTexture.width;\r\n            this.height = this._forcedOutputTexture.height;\r\n        } else {\r\n            target = this.inputTexture;\r\n\r\n            let cache;\r\n            for (let i = 0; i < this._textureCache.length; i++) {\r\n                if (this._textureCache[i].texture === target) {\r\n                    cache = this._textureCache[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (cache) {\r\n                cache.lastUsedRenderId = this._renderId;\r\n            }\r\n        }\r\n\r\n        // Bind the input of this post process to be used as the output of the previous post process.\r\n        if (this.enablePixelPerfectMode) {\r\n            this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\r\n            this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);\r\n        } else {\r\n            this._scaleRatio.copyFromFloats(1, 1);\r\n            this._engine.bindFramebuffer(target, 0, undefined, undefined, this.forceFullscreenViewport);\r\n        }\r\n\r\n        this._engine._debugInsertMarker?.(`post process ${this.name} input`);\r\n\r\n        this.onActivateObservable.notifyObservers(camera);\r\n\r\n        // Clear\r\n        if (this.autoClear && this.alphaMode === Constants.ALPHA_DISABLE) {\r\n            this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);\r\n        }\r\n\r\n        if (this._reusable) {\r\n            this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * If the post process is supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._drawWrapper.effect!.isSupported;\r\n    }\r\n\r\n    /**\r\n     * The aspect ratio of the output texture.\r\n     */\r\n    public get aspectRatio(): number {\r\n        if (this._shareOutputWithPostProcess) {\r\n            return this._shareOutputWithPostProcess.aspectRatio;\r\n        }\r\n\r\n        if (this._forcedOutputTexture) {\r\n            return this._forcedOutputTexture.width / this._forcedOutputTexture.height;\r\n        }\r\n        return this.width / this.height;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the post-process is ready to be used\r\n     * @returns true if the post-process is ready (shader is compiled)\r\n     */\r\n    public isReady(): boolean {\r\n        return this._drawWrapper.effect?.isReady() ?? false;\r\n    }\r\n\r\n    /**\r\n     * Binds all textures and uniforms to the shader, this will be run on every pass.\r\n     * @returns the effect corresponding to this post process. Null if not compiled or not ready.\r\n     */\r\n    public apply(): Nullable<Effect> {\r\n        // Check\r\n        if (!this._drawWrapper.effect?.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        // States\r\n        this._engine.enableEffect(this._drawWrapper);\r\n        this._engine.setState(false);\r\n        this._engine.setDepthBuffer(false);\r\n        this._engine.setDepthWrite(false);\r\n\r\n        // Alpha\r\n        this._engine.setAlphaMode(this.alphaMode);\r\n        if (this.alphaConstants) {\r\n            this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\r\n        }\r\n\r\n        // Bind the output texture of the preivous post process as the input to this post process.\r\n        let source: RenderTargetWrapper;\r\n        if (this._shareOutputWithPostProcess) {\r\n            source = this._shareOutputWithPostProcess.inputTexture;\r\n        } else if (this._forcedOutputTexture) {\r\n            source = this._forcedOutputTexture;\r\n        } else {\r\n            source = this.inputTexture;\r\n        }\r\n\r\n        if (!this.externalTextureSamplerBinding) {\r\n            this._drawWrapper.effect._bindTexture(\"textureSampler\", source?.texture);\r\n        }\r\n\r\n        // Parameters\r\n        this._drawWrapper.effect.setVector2(\"scale\", this._scaleRatio);\r\n        this.onApplyObservable.notifyObservers(this._drawWrapper.effect);\r\n\r\n        PostProcess._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name, this._drawWrapper.effect);\r\n\r\n        return this._drawWrapper.effect;\r\n    }\r\n\r\n    private _disposeTextures() {\r\n        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\r\n            this._disposeTextureCache();\r\n            return;\r\n        }\r\n\r\n        this._disposeTextureCache();\r\n        this._textures.dispose();\r\n    }\r\n\r\n    private _disposeTextureCache() {\r\n        for (let i = this._textureCache.length - 1; i >= 0; i--) {\r\n            this._textureCache[i].texture.dispose();\r\n        }\r\n\r\n        this._textureCache.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * @param prePassRenderer defines the prepass renderer to setup.\r\n     * @returns true if the pre pass is needed.\r\n     */\r\n    public setPrePassRenderer(prePassRenderer: PrePassRenderer): boolean {\r\n        if (this._prePassEffectConfiguration) {\r\n            this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);\r\n            this._prePassEffectConfiguration.enabled = true;\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        camera = camera || this._camera;\r\n\r\n        this._disposeTextures();\r\n\r\n        let index;\r\n        if (this._scene) {\r\n            index = this._scene.postProcesses.indexOf(this);\r\n            if (index !== -1) {\r\n                this._scene.postProcesses.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.postProcesses.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.postProcesses.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        index = this._engine.postProcesses.indexOf(this);\r\n        if (index !== -1) {\r\n            this._engine.postProcesses.splice(index, 1);\r\n        }\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n        camera.detachPostProcess(this);\r\n\r\n        index = camera._postProcesses.indexOf(this);\r\n        if (index === 0 && camera._postProcesses.length > 0) {\r\n            const firstPostProcess = this._camera._getFirstPostProcess();\r\n            if (firstPostProcess) {\r\n                firstPostProcess.markTextureDirty();\r\n            }\r\n        }\r\n\r\n        this.onActivateObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onApplyObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n        this.onSizeChangedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the post process to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        const camera = this.getCamera() || (this._scene && this._scene.activeCamera);\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.cameraId = camera ? camera.id : null;\r\n        serializationObject.reusable = this._reusable;\r\n        serializationObject.textureType = this._textureType;\r\n        serializationObject.fragmentUrl = this._fragmentUrl;\r\n        serializationObject.parameters = this._parameters;\r\n        serializationObject.samplers = this._samplers;\r\n        serializationObject.options = this._options;\r\n        serializationObject.defines = this._postProcessDefines;\r\n        serializationObject.textureFormat = this._textureFormat;\r\n        serializationObject.vertexUrl = this._vertexUrl;\r\n        serializationObject.indexParameters = this._indexParameters;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clones this post process\r\n     * @returns a new post process similar to this one\r\n     */\r\n    public clone(): Nullable<PostProcess> {\r\n        const serializationObject = this.serialize();\r\n        serializationObject._engine = this._engine;\r\n        serializationObject.cameraId = null;\r\n\r\n        const result = PostProcess.Parse(serializationObject, this._scene, \"\");\r\n\r\n        if (!result) {\r\n            return null;\r\n        }\r\n\r\n        result.onActivateObservable = this.onActivateObservable.clone();\r\n        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();\r\n        result.onApplyObservable = this.onApplyObservable.clone();\r\n        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();\r\n        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();\r\n\r\n        result._prePassEffectConfiguration = this._prePassEffectConfiguration;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a material from parsed material data\r\n     * @param parsedPostProcess defines parsed post process data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns a new post process\r\n     */\r\n    public static Parse(parsedPostProcess: any, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        const postProcessType = GetClass(parsedPostProcess.customType);\r\n\r\n        if (!postProcessType || !postProcessType._Parse) {\r\n            return null;\r\n        }\r\n\r\n        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;\r\n        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<PostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.fragmentUrl,\r\n                    parsedPostProcess.parameters,\r\n                    parsedPostProcess.samplers,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.defines,\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.vertexUrl,\r\n                    parsedPostProcess.indexParameters,\r\n                    false,\r\n                    parsedPostProcess.textureFormat\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PostProcess\", PostProcess);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}