{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\n/**\n * Class used to control physics engine\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nexport class PhysicsEngine {\n  /**\n   * Creates a new Physics Engine\n   * @param gravity defines the gravity vector used by the simulation\n   * @param _physicsPlugin defines the plugin to use (CannonJS by default)\n   */\n  constructor(gravity, _physicsPlugin = PhysicsEngine.DefaultPluginFactory()) {\n    this._physicsPlugin = _physicsPlugin;\n    /**\n     * Global value used to control the smallest number supported by the simulation\n     */\n    this._impostors = [];\n    this._joints = [];\n    this._subTimeStep = 0;\n    this._uniqueIdCounter = 0;\n    if (!this._physicsPlugin.isSupported()) {\n      throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\n    }\n    gravity = gravity || new Vector3(0, -9.807, 0);\n    this.setGravity(gravity);\n    this.setTimeStep();\n  }\n  /**\n   *\n   * @returns version\n   */\n  getPluginVersion() {\n    return this._physicsPlugin.getPluginVersion();\n  }\n  /**\n   * Factory used to create the default physics plugin.\n   * @returns The default physics plugin\n   */\n  static DefaultPluginFactory() {\n    throw _WarnImport(\"CannonJSPlugin\");\n  }\n  /**\n   * Sets the gravity vector used by the simulation\n   * @param gravity defines the gravity vector to use\n   */\n  setGravity(gravity) {\n    this.gravity = gravity;\n    this._physicsPlugin.setGravity(this.gravity);\n  }\n  /**\n   * Set the time step of the physics engine.\n   * Default is 1/60.\n   * To slow it down, enter 1/600 for example.\n   * To speed it up, 1/30\n   * @param newTimeStep defines the new timestep to apply to this world.\n   */\n  setTimeStep(newTimeStep = 1 / 60) {\n    this._physicsPlugin.setTimeStep(newTimeStep);\n  }\n  /**\n   * Get the time step of the physics engine.\n   * @returns the current time step\n   */\n  getTimeStep() {\n    return this._physicsPlugin.getTimeStep();\n  }\n  /**\n   * Set the sub time step of the physics engine.\n   * Default is 0 meaning there is no sub steps\n   * To increase physics resolution precision, set a small value (like 1 ms)\n   * @param subTimeStep defines the new sub timestep used for physics resolution.\n   */\n  setSubTimeStep(subTimeStep = 0) {\n    this._subTimeStep = subTimeStep;\n  }\n  /**\n   * Get the sub time step of the physics engine.\n   * @returns the current sub time step\n   */\n  getSubTimeStep() {\n    return this._subTimeStep;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this._impostors.forEach(function (impostor) {\n      impostor.dispose();\n    });\n    this._physicsPlugin.dispose();\n  }\n  /**\n   * Gets the name of the current physics plugin\n   * @returns the name of the plugin\n   */\n  getPhysicsPluginName() {\n    return this._physicsPlugin.name;\n  }\n  /**\n   * Adding a new impostor for the impostor tracking.\n   * This will be done by the impostor itself.\n   * @param impostor the impostor to add\n   */\n  addImpostor(impostor) {\n    this._impostors.push(impostor);\n    impostor.uniqueId = this._uniqueIdCounter++;\n    //if no parent, generate the body\n    if (!impostor.parent) {\n      this._physicsPlugin.generatePhysicsBody(impostor);\n    }\n  }\n  /**\n   * Remove an impostor from the engine.\n   * This impostor and its mesh will not longer be updated by the physics engine.\n   * @param impostor the impostor to remove\n   */\n  removeImpostor(impostor) {\n    const index = this._impostors.indexOf(impostor);\n    if (index > -1) {\n      const removed = this._impostors.splice(index, 1);\n      //Is it needed?\n      if (removed.length) {\n        this.getPhysicsPlugin().removePhysicsBody(impostor);\n      }\n    }\n  }\n  /**\n   * Add a joint to the physics engine\n   * @param mainImpostor defines the main impostor to which the joint is added.\n   * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\n   * @param joint defines the joint that will connect both impostors.\n   */\n  addJoint(mainImpostor, connectedImpostor, joint) {\n    const impostorJoint = {\n      mainImpostor: mainImpostor,\n      connectedImpostor: connectedImpostor,\n      joint: joint\n    };\n    joint.physicsPlugin = this._physicsPlugin;\n    this._joints.push(impostorJoint);\n    this._physicsPlugin.generateJoint(impostorJoint);\n  }\n  /**\n   * Removes a joint from the simulation\n   * @param mainImpostor defines the impostor used with the joint\n   * @param connectedImpostor defines the other impostor connected to the main one by the joint\n   * @param joint defines the joint to remove\n   */\n  removeJoint(mainImpostor, connectedImpostor, joint) {\n    const matchingJoints = this._joints.filter(function (impostorJoint) {\n      return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\n    });\n    if (matchingJoints.length) {\n      this._physicsPlugin.removeJoint(matchingJoints[0]);\n      //TODO remove it from the list as well\n    }\n  }\n  /**\n   * Called by the scene. No need to call it.\n   * @param delta defines the timespan between frames\n   */\n  _step(delta) {\n    //check if any mesh has no body / requires an update\n    this._impostors.forEach(impostor => {\n      if (impostor.isBodyInitRequired()) {\n        this._physicsPlugin.generatePhysicsBody(impostor);\n      }\n    });\n    if (delta > 0.1) {\n      delta = 0.1;\n    } else if (delta <= 0) {\n      delta = 1.0 / 60.0;\n    }\n    this._physicsPlugin.executeStep(delta, this._impostors);\n  }\n  /**\n   * Gets the current plugin used to run the simulation\n   * @returns current plugin\n   */\n  getPhysicsPlugin() {\n    return this._physicsPlugin;\n  }\n  /**\n   * Gets the list of physic impostors\n   * @returns an array of PhysicsImpostor\n   */\n  getImpostors() {\n    return this._impostors;\n  }\n  /**\n   * Gets the impostor for a physics enabled object\n   * @param object defines the object impersonated by the impostor\n   * @returns the PhysicsImpostor or null if not found\n   */\n  getImpostorForPhysicsObject(object) {\n    for (let i = 0; i < this._impostors.length; ++i) {\n      if (this._impostors[i].object === object) {\n        return this._impostors[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the impostor for a physics body object\n   * @param body defines physics body used by the impostor\n   * @returns the PhysicsImpostor or null if not found\n   */\n  getImpostorWithPhysicsBody(body) {\n    for (let i = 0; i < this._impostors.length; ++i) {\n      if (this._impostors[i].physicsBody === body) {\n        return this._impostors[i];\n      }\n    }\n    return null;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    return this._physicsPlugin.raycast(from, to);\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    return this._physicsPlugin.raycastToRef(from, to, result);\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","_WarnImport","PhysicsEngine","constructor","gravity","_physicsPlugin","DefaultPluginFactory","isSupported","Error","name","setGravity","setTimeStep","getPluginVersion","newTimeStep","getTimeStep","setSubTimeStep","subTimeStep","_subTimeStep","getSubTimeStep","dispose","_impostors","forEach","impostor","getPhysicsPluginName","addImpostor","push","uniqueId","_uniqueIdCounter","parent","generatePhysicsBody","removeImpostor","index","indexOf","removed","splice","length","getPhysicsPlugin","removePhysicsBody","addJoint","mainImpostor","connectedImpostor","joint","impostorJoint","physicsPlugin","_joints","generateJoint","removeJoint","matchingJoints","filter","_step","delta","isBodyInitRequired","executeStep","getImpostors","getImpostorForPhysicsObject","object","i","getImpostorWithPhysicsBody","body","physicsBody","raycast","from","to","raycastToRef","result"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/v1/physicsEngine.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { PhysicsImpostorJoint, IPhysicsEnginePlugin } from \"./IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEngine } from \"../IPhysicsEngine\";\r\nimport type { PhysicsImpostor, IPhysicsEnabledObject } from \"./physicsImpostor\";\r\nimport type { PhysicsJoint } from \"./physicsJoint\";\r\nimport type { PhysicsRaycastResult } from \"../physicsRaycastResult\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\n\r\n/**\r\n * Class used to control physics engine\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nexport class PhysicsEngine implements IPhysicsEngine {\r\n    /**\r\n     * Global value used to control the smallest number supported by the simulation\r\n     */\r\n    private _impostors: Array<PhysicsImpostor> = [];\r\n    private _joints: Array<PhysicsImpostorJoint> = [];\r\n    private _subTimeStep: number = 0;\r\n    private _uniqueIdCounter = 0;\r\n\r\n    /**\r\n     * Gets the gravity vector used by the simulation\r\n     */\r\n    public gravity: Vector3;\r\n\r\n    /**\r\n     *\r\n     * @returns version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return this._physicsPlugin.getPluginVersion();\r\n    }\r\n    /**\r\n     * Factory used to create the default physics plugin.\r\n     * @returns The default physics plugin\r\n     */\r\n    public static DefaultPluginFactory(): IPhysicsEnginePlugin {\r\n        throw _WarnImport(\"CannonJSPlugin\");\r\n    }\r\n\r\n    /**\r\n     * Creates a new Physics Engine\r\n     * @param gravity defines the gravity vector used by the simulation\r\n     * @param _physicsPlugin defines the plugin to use (CannonJS by default)\r\n     */\r\n    constructor(gravity: Nullable<Vector3>, private _physicsPlugin: IPhysicsEnginePlugin = PhysicsEngine.DefaultPluginFactory()) {\r\n        if (!this._physicsPlugin.isSupported()) {\r\n            throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \" + \"Please make sure it is included.\");\r\n        }\r\n        gravity = gravity || new Vector3(0, -9.807, 0);\r\n        this.setGravity(gravity);\r\n        this.setTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity vector used by the simulation\r\n     * @param gravity defines the gravity vector to use\r\n     */\r\n    public setGravity(gravity: Vector3): void {\r\n        this.gravity = gravity;\r\n        this._physicsPlugin.setGravity(this.gravity);\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the physics engine.\r\n     * Default is 1/60.\r\n     * To slow it down, enter 1/600 for example.\r\n     * To speed it up, 1/30\r\n     * @param newTimeStep defines the new timestep to apply to this world.\r\n     */\r\n    public setTimeStep(newTimeStep: number = 1 / 60) {\r\n        this._physicsPlugin.setTimeStep(newTimeStep);\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the physics engine.\r\n     * @returns the current time step\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._physicsPlugin.getTimeStep();\r\n    }\r\n\r\n    /**\r\n     * Set the sub time step of the physics engine.\r\n     * Default is 0 meaning there is no sub steps\r\n     * To increase physics resolution precision, set a small value (like 1 ms)\r\n     * @param subTimeStep defines the new sub timestep used for physics resolution.\r\n     */\r\n    public setSubTimeStep(subTimeStep: number = 0) {\r\n        this._subTimeStep = subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the sub time step of the physics engine.\r\n     * @returns the current sub time step\r\n     */\r\n    public getSubTimeStep() {\r\n        return this._subTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this._impostors.forEach(function (impostor) {\r\n            impostor.dispose();\r\n        });\r\n        this._physicsPlugin.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the current physics plugin\r\n     * @returns the name of the plugin\r\n     */\r\n    public getPhysicsPluginName(): string {\r\n        return this._physicsPlugin.name;\r\n    }\r\n\r\n    /**\r\n     * Adding a new impostor for the impostor tracking.\r\n     * This will be done by the impostor itself.\r\n     * @param impostor the impostor to add\r\n     */\r\n    public addImpostor(impostor: PhysicsImpostor) {\r\n        this._impostors.push(impostor);\r\n        impostor.uniqueId = this._uniqueIdCounter++;\r\n        //if no parent, generate the body\r\n        if (!impostor.parent) {\r\n            this._physicsPlugin.generatePhysicsBody(impostor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an impostor from the engine.\r\n     * This impostor and its mesh will not longer be updated by the physics engine.\r\n     * @param impostor the impostor to remove\r\n     */\r\n    public removeImpostor(impostor: PhysicsImpostor) {\r\n        const index = this._impostors.indexOf(impostor);\r\n        if (index > -1) {\r\n            const removed = this._impostors.splice(index, 1);\r\n            //Is it needed?\r\n            if (removed.length) {\r\n                this.getPhysicsPlugin().removePhysicsBody(impostor);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a joint to the physics engine\r\n     * @param mainImpostor defines the main impostor to which the joint is added.\r\n     * @param connectedImpostor defines the impostor that is connected to the main impostor using this joint\r\n     * @param joint defines the joint that will connect both impostors.\r\n     */\r\n    public addJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const impostorJoint = {\r\n            mainImpostor: mainImpostor,\r\n            connectedImpostor: connectedImpostor,\r\n            joint: joint,\r\n        };\r\n        joint.physicsPlugin = this._physicsPlugin;\r\n        this._joints.push(impostorJoint);\r\n        this._physicsPlugin.generateJoint(impostorJoint);\r\n    }\r\n\r\n    /**\r\n     * Removes a joint from the simulation\r\n     * @param mainImpostor defines the impostor used with the joint\r\n     * @param connectedImpostor defines the other impostor connected to the main one by the joint\r\n     * @param joint defines the joint to remove\r\n     */\r\n    public removeJoint(mainImpostor: PhysicsImpostor, connectedImpostor: PhysicsImpostor, joint: PhysicsJoint) {\r\n        const matchingJoints = this._joints.filter(function (impostorJoint) {\r\n            return impostorJoint.connectedImpostor === connectedImpostor && impostorJoint.joint === joint && impostorJoint.mainImpostor === mainImpostor;\r\n        });\r\n        if (matchingJoints.length) {\r\n            this._physicsPlugin.removeJoint(matchingJoints[0]);\r\n            //TODO remove it from the list as well\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called by the scene. No need to call it.\r\n     * @param delta defines the timespan between frames\r\n     */\r\n    public _step(delta: number) {\r\n        //check if any mesh has no body / requires an update\r\n        this._impostors.forEach((impostor) => {\r\n            if (impostor.isBodyInitRequired()) {\r\n                this._physicsPlugin.generatePhysicsBody(impostor);\r\n            }\r\n        });\r\n\r\n        if (delta > 0.1) {\r\n            delta = 0.1;\r\n        } else if (delta <= 0) {\r\n            delta = 1.0 / 60.0;\r\n        }\r\n\r\n        this._physicsPlugin.executeStep(delta, this._impostors);\r\n    }\r\n\r\n    /**\r\n     * Gets the current plugin used to run the simulation\r\n     * @returns current plugin\r\n     */\r\n    public getPhysicsPlugin(): IPhysicsEnginePlugin {\r\n        return this._physicsPlugin;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of physic impostors\r\n     * @returns an array of PhysicsImpostor\r\n     */\r\n    public getImpostors(): Array<PhysicsImpostor> {\r\n        return this._impostors;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics enabled object\r\n     * @param object defines the object impersonated by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorForPhysicsObject(object: IPhysicsEnabledObject): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].object === object) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the impostor for a physics body object\r\n     * @param body defines physics body used by the impostor\r\n     * @returns the PhysicsImpostor or null if not found\r\n     */\r\n    public getImpostorWithPhysicsBody(body: any): Nullable<PhysicsImpostor> {\r\n        for (let i = 0; i < this._impostors.length; ++i) {\r\n            if (this._impostors[i].physicsBody === body) {\r\n                return this._impostors[i];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        return this._physicsPlugin.raycast(from, to);\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult) {\r\n        return this._physicsPlugin.raycastToRef(from, to, result);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}