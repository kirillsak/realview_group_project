{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\n/** @internal */\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\n  constructor() {\n    super(...arguments);\n    this._missingVaryings = [];\n    this._textureArrayProcessing = [];\n    this._vertexIsGLES3 = false;\n    this._fragmentIsGLES3 = false;\n    this.shaderLanguage = ShaderLanguage.GLSL;\n    this.parseGLES3 = true;\n  }\n  _getArraySize(name, type, preProcessors) {\n    let length = 0;\n    const startArray = name.indexOf(\"[\");\n    const endArray = name.indexOf(\"]\");\n    if (startArray > 0 && endArray > 0) {\n      const lengthInString = name.substring(startArray + 1, endArray);\n      length = +lengthInString;\n      if (isNaN(length)) {\n        length = +preProcessors[lengthInString.trim()];\n      }\n      name = name.substr(0, startArray);\n    }\n    return [name, type, length];\n  }\n  initializeShaders(processingContext) {\n    this._webgpuProcessingContext = processingContext;\n    this._missingVaryings.length = 0;\n    this._textureArrayProcessing.length = 0;\n    this.attributeKeywordName = undefined;\n    this.varyingVertexKeywordName = undefined;\n    this.varyingFragmentKeywordName = undefined;\n  }\n  preProcessShaderCode(code, isFragment) {\n    const ubDeclaration = `// Internals UBO\\r\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\n    const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\n    if (isFragment) {\n      this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\n      if (this._fragmentIsGLES3) {\n        this.varyingFragmentKeywordName = \"in\";\n      }\n      return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\n    }\n    this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\n    if (this._vertexIsGLES3) {\n      this.attributeKeywordName = \"in\";\n      this.varyingVertexKeywordName = \"out\";\n    }\n    return alreadyInjected ? code : ubDeclaration + code;\n  }\n  varyingProcessor(varying, isFragment, preProcessors) {\n    this._preProcessors = preProcessors;\n    const outRegex = /\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const inRegex = /\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\n    const match = regex.exec(varying);\n    if (match !== null) {\n      const varyingType = match[1];\n      const name = match[2];\n      let location;\n      if (isFragment) {\n        location = this._webgpuProcessingContext.availableVaryings[name];\n        this._missingVaryings[location] = \"\";\n        if (location === undefined) {\n          Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\n        }\n      } else {\n        location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\n        this._webgpuProcessingContext.availableVaryings[name] = location;\n        this._missingVaryings[location] = `layout(location = ${location}) in ${varyingType} ${name};`;\n      }\n      varying = varying.replace(match[0], location === undefined ? \"\" : `layout(location = ${location}) ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`);\n    }\n    return varying;\n  }\n  attributeProcessor(attribute, preProcessors) {\n    this._preProcessors = preProcessors;\n    const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\n    const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\n    const match = regex.exec(attribute);\n    if (match !== null) {\n      const attributeType = match[1];\n      const name = match[2];\n      const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\n      this._webgpuProcessingContext.availableAttributes[name] = location;\n      this._webgpuProcessingContext.orderedAttributes[location] = name;\n      attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\n    }\n    return attribute;\n  }\n  uniformProcessor(uniform, isFragment, preProcessors) {\n    var _a;\n    this._preProcessors = preProcessors;\n    const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\n    const match = uniformRegex.exec(uniform);\n    if (match !== null) {\n      let uniformType = match[1];\n      let name = match[2];\n      if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\n        let arraySize = 0; // 0 means the texture is not declared as an array\n        [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\n        let textureInfo = this._webgpuProcessingContext.availableTextures[name];\n        if (!textureInfo) {\n          textureInfo = {\n            autoBindSampler: true,\n            isTextureArray: arraySize > 0,\n            isStorageTexture: false,\n            textures: [],\n            sampleType: WebGPUConstants.TextureSampleType.Float\n          };\n          for (let i = 0; i < (arraySize || 1); ++i) {\n            textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\n          }\n        }\n        const samplerType = (_a = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType]) !== null && _a !== void 0 ? _a : \"sampler\";\n        const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\n        const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\n        const samplerName = name + WebGPUShaderProcessor.AutoSamplerSuffix;\n        let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\n        if (!samplerInfo) {\n          samplerInfo = {\n            binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\n            type: samplerBindingType\n          };\n        }\n        const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\n        if (componentType) {\n          uniformType = uniformType.substr(1);\n        }\n        const sampleType = isComparisonSampler ? WebGPUConstants.TextureSampleType.Depth : componentType === \"u\" ? WebGPUConstants.TextureSampleType.Uint : componentType === \"i\" ? WebGPUConstants.TextureSampleType.Sint : WebGPUConstants.TextureSampleType.Float;\n        textureInfo.sampleType = sampleType;\n        const isTextureArray = arraySize > 0;\n        const samplerGroupIndex = samplerInfo.binding.groupIndex;\n        const samplerBindingIndex = samplerInfo.binding.bindingIndex;\n        const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\n        const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\n        const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\n        // Manage textures and samplers.\n        if (!isTextureArray) {\n          arraySize = 1;\n          uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${textureType} ${name}Texture;\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\n        } else {\n          const layouts = [];\n          layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\n          uniform = `\\r\\n`;\n          for (let i = 0; i < arraySize; ++i) {\n            const textureSetIndex = textureInfo.textures[i].groupIndex;\n            const textureBindingIndex = textureInfo.textures[i].bindingIndex;\n            layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\n            uniform += `${i > 0 ? \"\\r\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\n          }\n          uniform = layouts.join(\"\\r\\n\") + uniform;\n          this._textureArrayProcessing.push(name);\n        }\n        this._webgpuProcessingContext.availableTextures[name] = textureInfo;\n        this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\n        this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\n        for (let i = 0; i < arraySize; ++i) {\n          this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\n        }\n      } else {\n        this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\n        uniform = \"\";\n      }\n    }\n    return uniform;\n  }\n  uniformBufferProcessor(uniformBuffer, isFragment) {\n    const uboRegex = /uniform\\s+(\\w+)/gm;\n    const match = uboRegex.exec(uniformBuffer);\n    if (match !== null) {\n      const name = match[1];\n      let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\n      if (!uniformBufferInfo) {\n        const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\n        let binding;\n        if (knownUBO && knownUBO.binding.groupIndex !== -1) {\n          binding = knownUBO.binding;\n        } else {\n          binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\n        }\n        uniformBufferInfo = {\n          binding\n        };\n        this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\n      }\n      this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\n      uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\n    }\n    return uniformBuffer;\n  }\n  postProcessor(code, defines, isFragment, processingContext, engine) {\n    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\n    // Remove extensions\n    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\n    code = code.replace(regex, \"\");\n    // Replace instructions\n    code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\n    if (isFragment) {\n      const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\n      const fragCoordCode = `\n                glFragCoord_ = gl_FragCoord;\n                if (yFactor_ == 1.) {\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\n                }\n            `;\n      const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\n      code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\n      code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\n      code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n      code = code.replace(/gl_FragColor/g, \"glFragColor\");\n      code = code.replace(/gl_FragData/g, \"glFragData\");\n      code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\n      if (!this._fragmentIsGLES3) {\n        code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\n      } else {\n        const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\n        if (match !== null) {\n          code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\n        }\n      }\n      code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\n      code = code.replace(\"##INJECTCODE##\", injectCode);\n      if (hasFragCoord) {\n        code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\n      }\n    } else {\n      code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\n      code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\n      const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\n      if (hasMultiviewExtension) {\n        return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\n      }\n    }\n    // Flip Y + convert z range from [-1,1] to [0,1]\n    if (!isFragment) {\n      const lastClosingCurly = code.lastIndexOf(\"}\");\n      code = code.substring(0, lastClosingCurly);\n      code += \"gl_Position.y *= yFactor_;\\n\";\n      if (!engine.isNDCHalfZRange) {\n        code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\n      }\n      code += \"}\";\n    }\n    return code;\n  }\n  _applyTextureArrayProcessing(code, name) {\n    // Replaces the occurrences of name[XX] by nameXX\n    const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\n    let match = regex.exec(code);\n    while (match !== null) {\n      const index = match[1];\n      let iindex = +index;\n      if (this._preProcessors && isNaN(iindex)) {\n        iindex = +this._preProcessors[index.trim()];\n      }\n      code = code.replace(match[0], name + iindex);\n      match = regex.exec(code);\n    }\n    return code;\n  }\n  _generateLeftOverUBOCode(name, uniformBufferDescription) {\n    let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\n    for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\n      if (leftOverUniform.length > 0) {\n        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\n      } else {\n        ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\n      }\n    }\n    ubo += \"};\\n\\n\";\n    return ubo;\n  }\n  finalizeShaders(vertexCode, fragmentCode) {\n    // make replacements for texture names in the texture array case\n    for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\n      const name = this._textureArrayProcessing[i];\n      vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\n      fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\n    }\n    // inject the missing varying in the fragment shader\n    for (let i = 0; i < this._missingVaryings.length; ++i) {\n      const decl = this._missingVaryings[i];\n      if (decl && decl.length > 0) {\n        fragmentCode = decl + \"\\n\" + fragmentCode;\n      }\n    }\n    // Builds the leftover UBOs.\n    const leftOverUBO = this._buildLeftOverUBO();\n    vertexCode = leftOverUBO + vertexCode;\n    fragmentCode = leftOverUBO + fragmentCode;\n    this._collectBindingNames();\n    this._preCreateBindGroupEntries();\n    this._preProcessors = null;\n    return {\n      vertexCode,\n      fragmentCode\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["WebGPUShaderProcessingContext","WebGPUConstants","Logger","WebGPUShaderProcessor","ShaderLanguage","WebGPUShaderProcessorGLSL","constructor","GLSL","_getArraySize","name","type","preProcessors","length","startArray","indexOf","endArray","lengthInString","substring","isNaN","trim","substr","initializeShaders","processingContext","_webgpuProcessingContext","_missingVaryings","_textureArrayProcessing","attributeKeywordName","undefined","varyingVertexKeywordName","varyingFragmentKeywordName","preProcessShaderCode","code","isFragment","ubDeclaration","InternalsUBOName","alreadyInjected","_fragmentIsGLES3","_vertexIsGLES3","varyingProcessor","varying","_preProcessors","outRegex","inRegex","varyingRegex","regex","match","exec","varyingType","location","availableVaryings","Warn","getVaryingNextLocation","replace","attributeProcessor","attribute","attribRegex","attributeType","getAttributeNextLocation","availableAttributes","orderedAttributes","uniformProcessor","uniform","uniformRegex","uniformType","arraySize","textureInfo","availableTextures","autoBindSampler","isTextureArray","isStorageTexture","textures","sampleType","TextureSampleType","Float","i","push","getNextFreeUBOBinding","samplerType","_SamplerTypeByWebGLSamplerType","isComparisonSampler","_IsComparisonSamplerByWebGPUSamplerType","samplerBindingType","SamplerBindingType","Comparison","Filtering","samplerName","AutoSamplerSuffix","samplerInfo","availableSamplers","binding","componentType","charAt","Depth","Uint","Sint","samplerGroupIndex","groupIndex","samplerBindingIndex","bindingIndex","samplerFunction","_SamplerFunctionByWebGLSamplerType","textureType","_TextureTypeByWebGLSamplerType","textureDimension","_GpuTextureViewDimensionByWebGPUTextureType","layouts","textureSetIndex","textureBindingIndex","join","_addSamplerBindingDescription","_addTextureBindingDescription","_addUniformToLeftOverUBO","uniformBufferProcessor","uniformBuffer","uboRegex","uniformBufferInfo","availableBuffers","knownUBO","KnownUBOs","_addBufferBindingDescription","BufferBindingType","Uniform","postProcessor","defines","engine","hasDrawBuffersExtension","search","hasFragCoord","fragCoordCode","injectCode","index","_injectStartingAndEndingCode","hasMultiviewExtension","lastClosingCurly","lastIndexOf","isNDCHalfZRange","_applyTextureArrayProcessing","RegExp","iindex","_generateLeftOverUBOCode","uniformBufferDescription","ubo","leftOverUniform","leftOverUniforms","finalizeShaders","vertexCode","fragmentCode","decl","leftOverUBO","_buildLeftOverUBO","_collectBindingNames","_preCreateBindGroupEntries"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuShaderProcessorsGLSL.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { ShaderProcessingContext } from \"../Processors/shaderProcessingOptions\";\r\nimport type { WebGPUBufferDescription } from \"./webgpuShaderProcessingContext\";\r\nimport { WebGPUShaderProcessingContext } from \"./webgpuShaderProcessingContext\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ThinEngine } from \"../thinEngine\";\r\nimport { WebGPUShaderProcessor } from \"./webgpuShaderProcessor\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\n/** @internal */\r\nexport class WebGPUShaderProcessorGLSL extends WebGPUShaderProcessor {\r\n    protected _missingVaryings: Array<string> = [];\r\n    protected _textureArrayProcessing: Array<string> = [];\r\n    protected _preProcessors: { [key: string]: string };\r\n    protected _vertexIsGLES3: boolean = false;\r\n    protected _fragmentIsGLES3: boolean = false;\r\n\r\n    public shaderLanguage = ShaderLanguage.GLSL;\r\n    public parseGLES3 = true;\r\n    public attributeKeywordName: string | undefined;\r\n    public varyingVertexKeywordName: string | undefined;\r\n    public varyingFragmentKeywordName: string | undefined;\r\n\r\n    protected _getArraySize(name: string, type: string, preProcessors: { [key: string]: string }): [string, string, number] {\r\n        let length = 0;\r\n        const startArray = name.indexOf(\"[\");\r\n        const endArray = name.indexOf(\"]\");\r\n        if (startArray > 0 && endArray > 0) {\r\n            const lengthInString = name.substring(startArray + 1, endArray);\r\n            length = +lengthInString;\r\n            if (isNaN(length)) {\r\n                length = +preProcessors[lengthInString.trim()];\r\n            }\r\n            name = name.substr(0, startArray);\r\n        }\r\n        return [name, type, length];\r\n    }\r\n\r\n    public initializeShaders(processingContext: Nullable<ShaderProcessingContext>): void {\r\n        this._webgpuProcessingContext = processingContext as WebGPUShaderProcessingContext;\r\n\r\n        this._missingVaryings.length = 0;\r\n        this._textureArrayProcessing.length = 0;\r\n        this.attributeKeywordName = undefined;\r\n        this.varyingVertexKeywordName = undefined;\r\n        this.varyingFragmentKeywordName = undefined;\r\n    }\r\n\r\n    public preProcessShaderCode(code: string, isFragment: boolean): string {\r\n        const ubDeclaration = `// Internals UBO\\r\\nuniform ${WebGPUShaderProcessor.InternalsUBOName} {\\nfloat yFactor_;\\nfloat textureOutputHeight_;\\n};\\n`;\r\n        const alreadyInjected = code.indexOf(\"// Internals UBO\") !== -1;\r\n\r\n        if (isFragment) {\r\n            this._fragmentIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n            if (this._fragmentIsGLES3) {\r\n                this.varyingFragmentKeywordName = \"in\";\r\n            }\r\n            return alreadyInjected ? code : ubDeclaration + \"##INJECTCODE##\\n\" + code;\r\n        }\r\n\r\n        this._vertexIsGLES3 = code.indexOf(\"#version 3\") !== -1;\r\n        if (this._vertexIsGLES3) {\r\n            this.attributeKeywordName = \"in\";\r\n            this.varyingVertexKeywordName = \"out\";\r\n        }\r\n        return alreadyInjected ? code : ubDeclaration + code;\r\n    }\r\n\r\n    public varyingProcessor(varying: string, isFragment: boolean, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const outRegex = /\\s*out\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const inRegex = /\\s*in\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const varyingRegex = /\\s*varying\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = isFragment && this._fragmentIsGLES3 ? inRegex : !isFragment && this._vertexIsGLES3 ? outRegex : varyingRegex;\r\n        const match = regex.exec(varying);\r\n        if (match !== null) {\r\n            const varyingType = match[1];\r\n            const name = match[2];\r\n            let location: number;\r\n            if (isFragment) {\r\n                location = this._webgpuProcessingContext.availableVaryings[name];\r\n                this._missingVaryings[location] = \"\";\r\n                if (location === undefined) {\r\n                    Logger.Warn(`Invalid fragment shader: The varying named \"${name}\" is not declared in the vertex shader! This declaration will be ignored.`);\r\n                }\r\n            } else {\r\n                location = this._webgpuProcessingContext.getVaryingNextLocation(varyingType, this._getArraySize(name, varyingType, preProcessors)[2]);\r\n                this._webgpuProcessingContext.availableVaryings[name] = location;\r\n                this._missingVaryings[location] = `layout(location = ${location}) in ${varyingType} ${name};`;\r\n            }\r\n\r\n            varying = varying.replace(match[0], location === undefined ? \"\" : `layout(location = ${location}) ${isFragment ? \"in\" : \"out\"} ${varyingType} ${name};`);\r\n        }\r\n        return varying;\r\n    }\r\n\r\n    public attributeProcessor(attribute: string, preProcessors: { [key: string]: string }) {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const inRegex = /\\s*in\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n        const attribRegex = /\\s*attribute\\s+(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const regex = this._vertexIsGLES3 ? inRegex : attribRegex;\r\n        const match = regex.exec(attribute);\r\n        if (match !== null) {\r\n            const attributeType = match[1];\r\n            const name = match[2];\r\n            const location = this._webgpuProcessingContext.getAttributeNextLocation(attributeType, this._getArraySize(name, attributeType, preProcessors)[2]);\r\n\r\n            this._webgpuProcessingContext.availableAttributes[name] = location;\r\n            this._webgpuProcessingContext.orderedAttributes[location] = name;\r\n\r\n            attribute = attribute.replace(match[0], `layout(location = ${location}) in ${attributeType} ${name};`);\r\n        }\r\n        return attribute;\r\n    }\r\n\r\n    public uniformProcessor(uniform: string, isFragment: boolean, preProcessors: { [key: string]: string }): string {\r\n        this._preProcessors = preProcessors;\r\n\r\n        const uniformRegex = /\\s*uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/gm;\r\n\r\n        const match = uniformRegex.exec(uniform);\r\n        if (match !== null) {\r\n            let uniformType = match[1];\r\n            let name = match[2];\r\n\r\n            if (uniformType.indexOf(\"sampler\") === 0 || uniformType.indexOf(\"sampler\") === 1) {\r\n                let arraySize = 0; // 0 means the texture is not declared as an array\r\n\r\n                [name, uniformType, arraySize] = this._getArraySize(name, uniformType, preProcessors);\r\n\r\n                let textureInfo = this._webgpuProcessingContext.availableTextures[name];\r\n                if (!textureInfo) {\r\n                    textureInfo = {\r\n                        autoBindSampler: true,\r\n                        isTextureArray: arraySize > 0,\r\n                        isStorageTexture: false,\r\n                        textures: [],\r\n                        sampleType: WebGPUConstants.TextureSampleType.Float,\r\n                    };\r\n                    for (let i = 0; i < (arraySize || 1); ++i) {\r\n                        textureInfo.textures.push(this._webgpuProcessingContext.getNextFreeUBOBinding());\r\n                    }\r\n                }\r\n\r\n                const samplerType = WebGPUShaderProcessor._SamplerTypeByWebGLSamplerType[uniformType] ?? \"sampler\";\r\n                const isComparisonSampler = !!WebGPUShaderProcessor._IsComparisonSamplerByWebGPUSamplerType[samplerType];\r\n                const samplerBindingType = isComparisonSampler ? WebGPUConstants.SamplerBindingType.Comparison : WebGPUConstants.SamplerBindingType.Filtering;\r\n                const samplerName = name + WebGPUShaderProcessor.AutoSamplerSuffix;\r\n\r\n                let samplerInfo = this._webgpuProcessingContext.availableSamplers[samplerName];\r\n                if (!samplerInfo) {\r\n                    samplerInfo = {\r\n                        binding: this._webgpuProcessingContext.getNextFreeUBOBinding(),\r\n                        type: samplerBindingType,\r\n                    };\r\n                }\r\n\r\n                const componentType = uniformType.charAt(0) === \"u\" ? \"u\" : uniformType.charAt(0) === \"i\" ? \"i\" : \"\";\r\n\r\n                if (componentType) {\r\n                    uniformType = uniformType.substr(1);\r\n                }\r\n\r\n                const sampleType = isComparisonSampler\r\n                    ? WebGPUConstants.TextureSampleType.Depth\r\n                    : componentType === \"u\"\r\n                    ? WebGPUConstants.TextureSampleType.Uint\r\n                    : componentType === \"i\"\r\n                    ? WebGPUConstants.TextureSampleType.Sint\r\n                    : WebGPUConstants.TextureSampleType.Float;\r\n\r\n                textureInfo.sampleType = sampleType;\r\n\r\n                const isTextureArray = arraySize > 0;\r\n                const samplerGroupIndex = samplerInfo.binding.groupIndex;\r\n                const samplerBindingIndex = samplerInfo.binding.bindingIndex;\r\n                const samplerFunction = WebGPUShaderProcessor._SamplerFunctionByWebGLSamplerType[uniformType];\r\n                const textureType = WebGPUShaderProcessor._TextureTypeByWebGLSamplerType[uniformType];\r\n                const textureDimension = WebGPUShaderProcessor._GpuTextureViewDimensionByWebGPUTextureType[textureType];\r\n\r\n                // Manage textures and samplers.\r\n                if (!isTextureArray) {\r\n                    arraySize = 1;\r\n                    uniform = `layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};\r\n                        layout(set = ${textureInfo.textures[0].groupIndex}, binding = ${textureInfo.textures[0].bindingIndex}) uniform ${textureType} ${name}Texture;\r\n                        #define ${name} ${componentType}${samplerFunction}(${name}Texture, ${samplerName})`;\r\n                } else {\r\n                    const layouts = [];\r\n                    layouts.push(`layout(set = ${samplerGroupIndex}, binding = ${samplerBindingIndex}) uniform ${componentType}${samplerType} ${samplerName};`);\r\n                    uniform = `\\r\\n`;\r\n                    for (let i = 0; i < arraySize; ++i) {\r\n                        const textureSetIndex = textureInfo.textures[i].groupIndex;\r\n                        const textureBindingIndex = textureInfo.textures[i].bindingIndex;\r\n\r\n                        layouts.push(`layout(set = ${textureSetIndex}, binding = ${textureBindingIndex}) uniform ${textureType} ${name}Texture${i};`);\r\n\r\n                        uniform += `${i > 0 ? \"\\r\\n\" : \"\"}#define ${name}${i} ${componentType}${samplerFunction}(${name}Texture${i}, ${samplerName})`;\r\n                    }\r\n                    uniform = layouts.join(\"\\r\\n\") + uniform;\r\n                    this._textureArrayProcessing.push(name);\r\n                }\r\n\r\n                this._webgpuProcessingContext.availableTextures[name] = textureInfo;\r\n                this._webgpuProcessingContext.availableSamplers[samplerName] = samplerInfo;\r\n\r\n                this._addSamplerBindingDescription(samplerName, samplerInfo, !isFragment);\r\n\r\n                for (let i = 0; i < arraySize; ++i) {\r\n                    this._addTextureBindingDescription(name, textureInfo, i, textureDimension, null, !isFragment);\r\n                }\r\n            } else {\r\n                this._addUniformToLeftOverUBO(name, uniformType, preProcessors);\r\n                uniform = \"\";\r\n            }\r\n        }\r\n        return uniform;\r\n    }\r\n\r\n    public uniformBufferProcessor(uniformBuffer: string, isFragment: boolean): string {\r\n        const uboRegex = /uniform\\s+(\\w+)/gm;\r\n\r\n        const match = uboRegex.exec(uniformBuffer);\r\n        if (match !== null) {\r\n            const name = match[1];\r\n\r\n            let uniformBufferInfo = this._webgpuProcessingContext.availableBuffers[name];\r\n            if (!uniformBufferInfo) {\r\n                const knownUBO = WebGPUShaderProcessingContext.KnownUBOs[name];\r\n\r\n                let binding;\r\n                if (knownUBO && knownUBO.binding.groupIndex !== -1) {\r\n                    binding = knownUBO.binding;\r\n                } else {\r\n                    binding = this._webgpuProcessingContext.getNextFreeUBOBinding();\r\n                }\r\n\r\n                uniformBufferInfo = { binding };\r\n                this._webgpuProcessingContext.availableBuffers[name] = uniformBufferInfo;\r\n            }\r\n\r\n            this._addBufferBindingDescription(name, uniformBufferInfo, WebGPUConstants.BufferBindingType.Uniform, !isFragment);\r\n\r\n            uniformBuffer = uniformBuffer.replace(\"uniform\", `layout(set = ${uniformBufferInfo.binding.groupIndex}, binding = ${uniformBufferInfo.binding.bindingIndex}) uniform`);\r\n        }\r\n        return uniformBuffer;\r\n    }\r\n\r\n    public postProcessor(code: string, defines: string[], isFragment: boolean, processingContext: Nullable<ShaderProcessingContext>, engine: ThinEngine) {\r\n        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;\r\n\r\n        // Remove extensions\r\n        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;\r\n        code = code.replace(regex, \"\");\r\n\r\n        // Replace instructions\r\n        code = code.replace(/texture2D\\s*\\(/g, \"texture(\");\r\n        if (isFragment) {\r\n            const hasFragCoord = code.indexOf(\"gl_FragCoord\") >= 0;\r\n            const fragCoordCode = `\r\n                glFragCoord_ = gl_FragCoord;\r\n                if (yFactor_ == 1.) {\r\n                    glFragCoord_.y = textureOutputHeight_ - glFragCoord_.y;\r\n                }\r\n            `;\r\n\r\n            const injectCode = hasFragCoord ? \"vec4 glFragCoord_;\\n\" : \"\";\r\n\r\n            code = code.replace(/texture2DLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCubeLodEXT\\s*\\(/g, \"textureLod(\");\r\n            code = code.replace(/textureCube\\s*\\(/g, \"texture(\");\r\n            code = code.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\r\n            code = code.replace(/gl_FragColor/g, \"glFragColor\");\r\n            code = code.replace(/gl_FragData/g, \"glFragData\");\r\n            code = code.replace(/gl_FragCoord/g, \"glFragCoord_\");\r\n            if (!this._fragmentIsGLES3) {\r\n                code = code.replace(/void\\s+?main\\s*\\(/g, (hasDrawBuffersExtension ? \"\" : \"layout(location = 0) out vec4 glFragColor;\\n\") + \"void main(\");\r\n            } else {\r\n                const match = /^\\s*out\\s+\\S+\\s+\\S+\\s*;/gm.exec(code);\r\n                if (match !== null) {\r\n                    code = code.substring(0, match.index) + \"layout(location = 0) \" + code.substring(match.index);\r\n                }\r\n            }\r\n            code = code.replace(/dFdy/g, \"(-yFactor_)*dFdy\"); // will also handle dFdyCoarse and dFdyFine\r\n            code = code.replace(\"##INJECTCODE##\", injectCode);\r\n\r\n            if (hasFragCoord) {\r\n                code = this._injectStartingAndEndingCode(code, \"void main\", fragCoordCode);\r\n            }\r\n        } else {\r\n            code = code.replace(/gl_InstanceID/g, \"gl_InstanceIndex\");\r\n            code = code.replace(/gl_VertexID/g, \"gl_VertexIndex\");\r\n            const hasMultiviewExtension = defines.indexOf(\"#define MULTIVIEW\") !== -1;\r\n            if (hasMultiviewExtension) {\r\n                return \"#extension GL_OVR_multiview2 : require\\nlayout (num_views = 2) in;\\n\" + code;\r\n            }\r\n        }\r\n\r\n        // Flip Y + convert z range from [-1,1] to [0,1]\r\n        if (!isFragment) {\r\n            const lastClosingCurly = code.lastIndexOf(\"}\");\r\n            code = code.substring(0, lastClosingCurly);\r\n            code += \"gl_Position.y *= yFactor_;\\n\";\r\n            if (!engine.isNDCHalfZRange) {\r\n                code += \"gl_Position.z = (gl_Position.z + gl_Position.w) / 2.0;\\n\";\r\n            }\r\n            code += \"}\";\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    private _applyTextureArrayProcessing(code: string, name: string): string {\r\n        // Replaces the occurrences of name[XX] by nameXX\r\n        const regex = new RegExp(name + \"\\\\s*\\\\[(.+)?\\\\]\", \"gm\");\r\n        let match = regex.exec(code);\r\n\r\n        while (match !== null) {\r\n            const index = match[1];\r\n            let iindex = +index;\r\n            if (this._preProcessors && isNaN(iindex)) {\r\n                iindex = +this._preProcessors[index.trim()];\r\n            }\r\n            code = code.replace(match[0], name + iindex);\r\n            match = regex.exec(code);\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _generateLeftOverUBOCode(name: string, uniformBufferDescription: WebGPUBufferDescription): string {\r\n        let ubo = `layout(set = ${uniformBufferDescription.binding.groupIndex}, binding = ${uniformBufferDescription.binding.bindingIndex}) uniform ${name} {\\n    `;\r\n        for (const leftOverUniform of this._webgpuProcessingContext.leftOverUniforms) {\r\n            if (leftOverUniform.length > 0) {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name}[${leftOverUniform.length}];\\n`;\r\n            } else {\r\n                ubo += `    ${leftOverUniform.type} ${leftOverUniform.name};\\n`;\r\n            }\r\n        }\r\n        ubo += \"};\\n\\n\";\r\n\r\n        return ubo;\r\n    }\r\n\r\n    public finalizeShaders(vertexCode: string, fragmentCode: string): { vertexCode: string; fragmentCode: string } {\r\n        // make replacements for texture names in the texture array case\r\n        for (let i = 0; i < this._textureArrayProcessing.length; ++i) {\r\n            const name = this._textureArrayProcessing[i];\r\n            vertexCode = this._applyTextureArrayProcessing(vertexCode, name);\r\n            fragmentCode = this._applyTextureArrayProcessing(fragmentCode, name);\r\n        }\r\n\r\n        // inject the missing varying in the fragment shader\r\n        for (let i = 0; i < this._missingVaryings.length; ++i) {\r\n            const decl = this._missingVaryings[i];\r\n            if (decl && decl.length > 0) {\r\n                fragmentCode = decl + \"\\n\" + fragmentCode;\r\n            }\r\n        }\r\n\r\n        // Builds the leftover UBOs.\r\n        const leftOverUBO = this._buildLeftOverUBO();\r\n\r\n        vertexCode = leftOverUBO + vertexCode;\r\n        fragmentCode = leftOverUBO + fragmentCode;\r\n\r\n        this._collectBindingNames();\r\n        this._preCreateBindGroupEntries();\r\n\r\n        this._preProcessors = null as any;\r\n\r\n        return { vertexCode, fragmentCode };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}