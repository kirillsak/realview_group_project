{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nlet anchorIdProvider = 0;\n/**\n * An implementation of the anchor system for WebXR.\n * For further information see https://github.com/immersive-web/anchors/\n */\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\n  /**\n   * constructs a new anchor system\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param _options configuration object for this feature\n   */\n  constructor(_xrSessionManager, _options = {}) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._lastFrameDetected = new Set();\n    this._trackedAnchors = [];\n    this._futureAnchors = [];\n    /**\n     * Observers registered here will be executed when a new anchor was added to the session\n     */\n    this.onAnchorAddedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an anchor was removed from the session\n     */\n    this.onAnchorRemovedObservable = new Observable();\n    /**\n     * Observers registered here will be executed when an existing anchor updates\n     * This can execute N times every frame\n     */\n    this.onAnchorUpdatedObservable = new Observable();\n    this._tmpVector = new Vector3();\n    this._tmpQuaternion = new Quaternion();\n    this.xrNativeFeatureName = \"anchors\";\n  }\n  /**\n   * Set the reference space to use for anchor creation, when not using a hit test.\n   * Will default to the session's reference space if not defined\n   */\n  set referenceSpaceForFrameAnchors(referenceSpace) {\n    this._referenceSpaceForFrameAnchors = referenceSpace;\n  }\n  _populateTmpTransformation(position, rotationQuaternion) {\n    this._tmpVector.copyFrom(position);\n    this._tmpQuaternion.copyFrom(rotationQuaternion);\n    if (!this._xrSessionManager.scene.useRightHandedSystem) {\n      this._tmpVector.z *= -1;\n      this._tmpQuaternion.z *= -1;\n      this._tmpQuaternion.w *= -1;\n    }\n    return {\n      position: this._tmpVector,\n      rotationQuaternion: this._tmpQuaternion\n    };\n  }\n  /**\n   * Create a new anchor point using a hit test result at a specific point in the scene\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param hitTestResult The hit test result to use for this anchor creation\n   * @param position an optional position offset for this anchor\n   * @param rotationQuaternion an optional rotation offset for this anchor\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n  async addAnchorPointUsingHitTestResultAsync(hitTestResult, position = new Vector3(), rotationQuaternion = new Quaternion()) {\n    // convert to XR space (right handed) if needed\n    this._populateTmpTransformation(position, rotationQuaternion);\n    // the matrix that we'll use\n    const m = new XRRigidTransform({\n      x: this._tmpVector.x,\n      y: this._tmpVector.y,\n      z: this._tmpVector.z\n    }, {\n      x: this._tmpQuaternion.x,\n      y: this._tmpQuaternion.y,\n      z: this._tmpQuaternion.z,\n      w: this._tmpQuaternion.w\n    });\n    if (!hitTestResult.xrHitResult.createAnchor) {\n      this.detach();\n      throw new Error(\"Anchors not enabled in this environment/browser\");\n    } else {\n      try {\n        const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\n        return new Promise((resolve, reject) => {\n          this._futureAnchors.push({\n            nativeAnchor,\n            resolved: false,\n            submitted: true,\n            xrTransformation: m,\n            resolve,\n            reject\n          });\n        });\n      } catch (error) {\n        throw new Error(error);\n      }\n    }\n  }\n  /**\n   * Add a new anchor at a specific position and rotation\n   * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\n   * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\n   * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\n   * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\n   *\n   * @param position the position in which to add an anchor\n   * @param rotationQuaternion an optional rotation for the anchor transformation\n   * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\n   * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\n   */\n  async addAnchorAtPositionAndRotationAsync(position, rotationQuaternion = new Quaternion(), forceCreateInCurrentFrame = false) {\n    // convert to XR space (right handed) if needed\n    this._populateTmpTransformation(position, rotationQuaternion);\n    // the matrix that we'll use\n    const xrTransformation = new XRRigidTransform({\n      x: this._tmpVector.x,\n      y: this._tmpVector.y,\n      z: this._tmpVector.z\n    }, {\n      x: this._tmpQuaternion.x,\n      y: this._tmpQuaternion.y,\n      z: this._tmpQuaternion.z,\n      w: this._tmpQuaternion.w\n    });\n    const xrAnchor = forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame) : undefined;\n    // add the transformation to the future anchors list\n    return new Promise((resolve, reject) => {\n      this._futureAnchors.push({\n        nativeAnchor: xrAnchor,\n        resolved: false,\n        submitted: false,\n        xrTransformation,\n        resolve,\n        reject\n      });\n    });\n  }\n  /**\n   * Get the list of anchors currently being tracked by the system\n   */\n  get anchors() {\n    return this._trackedAnchors;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\n      while (this._trackedAnchors.length) {\n        const toRemove = this._trackedAnchors.pop();\n        if (toRemove) {\n          try {\n            // try to natively remove it as well\n            toRemove.remove();\n          } catch (e) {\n            // no-op\n          }\n          // as the xr frame loop is removed, we need to notify manually\n          this.onAnchorRemovedObservable.notifyObservers(toRemove);\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    this._futureAnchors.length = 0;\n    super.dispose();\n    this.onAnchorAddedObservable.clear();\n    this.onAnchorRemovedObservable.clear();\n    this.onAnchorUpdatedObservable.clear();\n  }\n  _onXRFrame(frame) {\n    if (!this.attached || !frame) {\n      return;\n    }\n    const trackedAnchors = frame.trackedAnchors;\n    if (trackedAnchors) {\n      const toRemove = this._trackedAnchors.filter(anchor => !trackedAnchors.has(anchor.xrAnchor)).map(anchor => {\n        const index = this._trackedAnchors.indexOf(anchor);\n        return index;\n      });\n      let idxTracker = 0;\n      toRemove.forEach(index => {\n        const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\n        this.onAnchorRemovedObservable.notifyObservers(anchor);\n        idxTracker++;\n      });\n      // now check for new ones\n      trackedAnchors.forEach(xrAnchor => {\n        if (!this._lastFrameDetected.has(xrAnchor)) {\n          const newAnchor = {\n            id: anchorIdProvider++,\n            xrAnchor: xrAnchor,\n            remove: () => xrAnchor.delete()\n          };\n          const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\n          this._trackedAnchors.push(anchor);\n          this.onAnchorAddedObservable.notifyObservers(anchor);\n          // search for the future anchor promise that matches this\n          const results = this._futureAnchors.filter(futureAnchor => futureAnchor.nativeAnchor === xrAnchor);\n          const result = results[0];\n          if (result) {\n            result.resolve(anchor);\n            result.resolved = true;\n          }\n        } else {\n          const index = this._findIndexInAnchorArray(xrAnchor);\n          const anchor = this._trackedAnchors[index];\n          try {\n            // anchors update every frame\n            this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\n            if (anchor.attachedNode) {\n              anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\n              anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\n            }\n            this.onAnchorUpdatedObservable.notifyObservers(anchor);\n          } catch (e) {\n            Tools.Warn(`Anchor could not be updated`);\n          }\n        }\n      });\n      this._lastFrameDetected = trackedAnchors;\n    }\n    // process future anchors\n    this._futureAnchors.forEach(futureAnchor => {\n      if (!futureAnchor.resolved && !futureAnchor.submitted) {\n        this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(nativeAnchor => {\n          futureAnchor.nativeAnchor = nativeAnchor;\n        }, error => {\n          futureAnchor.resolved = true;\n          futureAnchor.reject(error);\n        });\n        futureAnchor.submitted = true;\n      }\n    });\n  }\n  /**\n   * avoiding using Array.find for global support.\n   * @param xrAnchor the plane to find in the array\n   */\n  _findIndexInAnchorArray(xrAnchor) {\n    for (let i = 0; i < this._trackedAnchors.length; ++i) {\n      if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  _updateAnchorWithXRFrame(xrAnchor, anchor, xrFrame) {\n    // matrix\n    const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\n    if (pose) {\n      const mat = anchor.transformationMatrix || new Matrix();\n      Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        mat.toggleModelMatrixHandInPlace();\n      }\n      anchor.transformationMatrix = mat;\n      if (!this._options.worldParentNode) {\n        // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\n      } else {\n        mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\n      }\n    }\n    return anchor;\n  }\n  async _createAnchorAtTransformation(xrTransformation, xrFrame) {\n    var _a;\n    if (xrFrame.createAnchor) {\n      try {\n        return xrFrame.createAnchor(xrTransformation, (_a = this._referenceSpaceForFrameAnchors) !== null && _a !== void 0 ? _a : this._xrSessionManager.referenceSpace);\n      } catch (error) {\n        throw new Error(error);\n      }\n    } else {\n      this.detach();\n      throw new Error(\"Anchors are not enabled in your browser\");\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRAnchorSystem.Name = WebXRFeatureName.ANCHOR_SYSTEM;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRAnchorSystem.Version = 1;\n// register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRAnchorSystem.Name, (xrSessionManager, options) => {\n  return () => new WebXRAnchorSystem(xrSessionManager, options);\n}, WebXRAnchorSystem.Version);","map":{"version":3,"mappings":"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","names":["WebXRFeatureName","WebXRFeaturesManager","Observable","Matrix","Vector3","Quaternion","WebXRAbstractFeature","Tools","anchorIdProvider","WebXRAnchorSystem","constructor","_xrSessionManager","_options","Set","xrNativeFeatureName","referenceSpaceForFrameAnchors","referenceSpace","_referenceSpaceForFrameAnchors","_populateTmpTransformation","position","rotationQuaternion","_tmpVector","copyFrom","_tmpQuaternion","scene","useRightHandedSystem","z","w","addAnchorPointUsingHitTestResultAsync","hitTestResult","m","XRRigidTransform","x","y","xrHitResult","createAnchor","detach","Error","nativeAnchor","Promise","resolve","reject","_futureAnchors","push","resolved","submitted","xrTransformation","error","addAnchorAtPositionAndRotationAsync","forceCreateInCurrentFrame","xrAnchor","attached","currentFrame","_createAnchorAtTransformation","undefined","anchors","_trackedAnchors","doNotRemoveAnchorsOnSessionEnded","length","toRemove","pop","remove","e","onAnchorRemovedObservable","notifyObservers","dispose","onAnchorAddedObservable","clear","onAnchorUpdatedObservable","_onXRFrame","frame","trackedAnchors","filter","anchor","has","map","index","indexOf","idxTracker","forEach","splice","_lastFrameDetected","newAnchor","id","delete","_updateAnchorWithXRFrame","results","futureAnchor","result","_findIndexInAnchorArray","attachedNode","transformationMatrix","decompose","scaling","Warn","then","i","xrFrame","pose","getPose","anchorSpace","mat","FromArrayToRef","transform","matrix","toggleModelMatrixHandInPlace","worldParentNode","multiplyToRef","getWorldMatrix","ANCHOR_SYSTEM","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRAnchorSystem.ts"],"sourcesContent":["import { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Matrix, Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRHitResult } from \"./WebXRHitTest\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Configuration options of the anchor system\r\n */\r\nexport interface IWebXRAnchorSystemOptions {\r\n    /**\r\n     * a node that will be used to convert local to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n\r\n    /**\r\n     * If set to true a reference of the created anchors will be kept until the next session starts\r\n     * If not defined, anchors will be removed from the array when the feature is detached or the session ended.\r\n     */\r\n    doNotRemoveAnchorsOnSessionEnded?: boolean;\r\n}\r\n\r\n/**\r\n * A babylon container for an XR Anchor\r\n */\r\nexport interface IWebXRAnchor {\r\n    /**\r\n     * A babylon-assigned ID for this anchor\r\n     */\r\n    id: number;\r\n    /**\r\n     * Transformation matrix to apply to an object attached to this anchor\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native anchor object\r\n     */\r\n    xrAnchor: XRAnchor;\r\n\r\n    /**\r\n     * if defined, this object will be constantly updated by the anchor's position and rotation\r\n     */\r\n    attachedNode?: TransformNode;\r\n\r\n    /**\r\n     * Remove this anchor from the scene\r\n     */\r\n    remove(): void;\r\n}\r\n\r\n/**\r\n * An internal interface for a future (promise based) anchor\r\n */\r\ninterface IWebXRFutureAnchor {\r\n    /**\r\n     * The native anchor\r\n     */\r\n    nativeAnchor?: XRAnchor;\r\n    /**\r\n     * Was this request submitted to the xr frame?\r\n     */\r\n    submitted: boolean;\r\n    /**\r\n     * Was this promise resolved already?\r\n     */\r\n    resolved: boolean;\r\n    /**\r\n     * A resolve function\r\n     */\r\n    resolve: (xrAnchor: IWebXRAnchor) => void;\r\n    /**\r\n     * A reject function\r\n     */\r\n    reject: (msg?: string) => void;\r\n    /**\r\n     * The XR Transformation of the future anchor\r\n     */\r\n    xrTransformation: XRRigidTransform;\r\n}\r\n\r\nlet anchorIdProvider = 0;\r\n\r\n/**\r\n * An implementation of the anchor system for WebXR.\r\n * For further information see https://github.com/immersive-web/anchors/\r\n */\r\nexport class WebXRAnchorSystem extends WebXRAbstractFeature {\r\n    private _lastFrameDetected: XRAnchorSet = new Set();\r\n\r\n    private _trackedAnchors: Array<IWebXRAnchor> = [];\r\n\r\n    private _referenceSpaceForFrameAnchors: XRReferenceSpace;\r\n\r\n    private _futureAnchors: IWebXRFutureAnchor[] = [];\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.ANCHOR_SYSTEM;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Observers registered here will be executed when a new anchor was added to the session\r\n     */\r\n    public onAnchorAddedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an anchor was removed from the session\r\n     */\r\n    public onAnchorRemovedObservable: Observable<IWebXRAnchor> = new Observable();\r\n    /**\r\n     * Observers registered here will be executed when an existing anchor updates\r\n     * This can execute N times every frame\r\n     */\r\n    public onAnchorUpdatedObservable: Observable<IWebXRAnchor> = new Observable();\r\n\r\n    /**\r\n     * Set the reference space to use for anchor creation, when not using a hit test.\r\n     * Will default to the session's reference space if not defined\r\n     */\r\n    public set referenceSpaceForFrameAnchors(referenceSpace: XRReferenceSpace) {\r\n        this._referenceSpaceForFrameAnchors = referenceSpace;\r\n    }\r\n\r\n    /**\r\n     * constructs a new anchor system\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param _options configuration object for this feature\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private _options: IWebXRAnchorSystemOptions = {}) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"anchors\";\r\n    }\r\n\r\n    private _tmpVector = new Vector3();\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    private _populateTmpTransformation(position: Vector3, rotationQuaternion: Quaternion) {\r\n        this._tmpVector.copyFrom(position);\r\n        this._tmpQuaternion.copyFrom(rotationQuaternion);\r\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n            this._tmpVector.z *= -1;\r\n            this._tmpQuaternion.z *= -1;\r\n            this._tmpQuaternion.w *= -1;\r\n        }\r\n        return {\r\n            position: this._tmpVector,\r\n            rotationQuaternion: this._tmpQuaternion,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Create a new anchor point using a hit test result at a specific point in the scene\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param hitTestResult The hit test result to use for this anchor creation\r\n     * @param position an optional position offset for this anchor\r\n     * @param rotationQuaternion an optional rotation offset for this anchor\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorPointUsingHitTestResultAsync(\r\n        hitTestResult: IWebXRHitResult,\r\n        position: Vector3 = new Vector3(),\r\n        rotationQuaternion: Quaternion = new Quaternion()\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const m = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        if (!hitTestResult.xrHitResult.createAnchor) {\r\n            this.detach();\r\n            throw new Error(\"Anchors not enabled in this environment/browser\");\r\n        } else {\r\n            try {\r\n                const nativeAnchor = await hitTestResult.xrHitResult.createAnchor(m);\r\n                return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n                    this._futureAnchors.push({\r\n                        nativeAnchor,\r\n                        resolved: false,\r\n                        submitted: true,\r\n                        xrTransformation: m,\r\n                        resolve,\r\n                        reject,\r\n                    });\r\n                });\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new anchor at a specific position and rotation\r\n     * This function will add a new anchor per default in the next available frame. Unless forced, the createAnchor function\r\n     * will be called in the next xrFrame loop to make sure that the anchor can be created correctly.\r\n     * An anchor is tracked only after it is added to the trackerAnchors in xrFrame. The promise returned here does not yet guaranty that.\r\n     * Use onAnchorAddedObservable to get newly added anchors if you require tracking guaranty.\r\n     *\r\n     * @param position the position in which to add an anchor\r\n     * @param rotationQuaternion an optional rotation for the anchor transformation\r\n     * @param forceCreateInCurrentFrame force the creation of this anchor in the current frame. Must be called inside xrFrame loop!\r\n     * @returns A promise that fulfills when babylon has created the corresponding WebXRAnchor object and tracking has begun\r\n     */\r\n    public async addAnchorAtPositionAndRotationAsync(\r\n        position: Vector3,\r\n        rotationQuaternion: Quaternion = new Quaternion(),\r\n        forceCreateInCurrentFrame = false\r\n    ): Promise<IWebXRAnchor> {\r\n        // convert to XR space (right handed) if needed\r\n        this._populateTmpTransformation(position, rotationQuaternion);\r\n        // the matrix that we'll use\r\n        const xrTransformation = new XRRigidTransform(\r\n            { x: this._tmpVector.x, y: this._tmpVector.y, z: this._tmpVector.z },\r\n            { x: this._tmpQuaternion.x, y: this._tmpQuaternion.y, z: this._tmpQuaternion.z, w: this._tmpQuaternion.w }\r\n        );\r\n        const xrAnchor =\r\n            forceCreateInCurrentFrame && this.attached && this._xrSessionManager.currentFrame\r\n                ? await this._createAnchorAtTransformation(xrTransformation, this._xrSessionManager.currentFrame)\r\n                : undefined;\r\n        // add the transformation to the future anchors list\r\n        return new Promise<IWebXRAnchor>((resolve, reject) => {\r\n            this._futureAnchors.push({\r\n                nativeAnchor: xrAnchor,\r\n                resolved: false,\r\n                submitted: false,\r\n                xrTransformation,\r\n                resolve,\r\n                reject,\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the list of anchors currently being tracked by the system\r\n     */\r\n    public get anchors(): IWebXRAnchor[] {\r\n        return this._trackedAnchors;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.doNotRemoveAnchorsOnSessionEnded) {\r\n            while (this._trackedAnchors.length) {\r\n                const toRemove = this._trackedAnchors.pop();\r\n                if (toRemove) {\r\n                    try {\r\n                        // try to natively remove it as well\r\n                        toRemove.remove();\r\n                    } catch (e) {\r\n                        // no-op\r\n                    }\r\n                    // as the xr frame loop is removed, we need to notify manually\r\n                    this.onAnchorRemovedObservable.notifyObservers(toRemove);\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        this._futureAnchors.length = 0;\r\n        super.dispose();\r\n        this.onAnchorAddedObservable.clear();\r\n        this.onAnchorRemovedObservable.clear();\r\n        this.onAnchorUpdatedObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        if (!this.attached || !frame) {\r\n            return;\r\n        }\r\n\r\n        const trackedAnchors = frame.trackedAnchors;\r\n        if (trackedAnchors) {\r\n            const toRemove = this._trackedAnchors\r\n                .filter((anchor) => !trackedAnchors.has(anchor.xrAnchor))\r\n                .map((anchor) => {\r\n                    const index = this._trackedAnchors.indexOf(anchor);\r\n                    return index;\r\n                });\r\n            let idxTracker = 0;\r\n            toRemove.forEach((index) => {\r\n                const anchor = this._trackedAnchors.splice(index - idxTracker, 1)[0];\r\n                this.onAnchorRemovedObservable.notifyObservers(anchor);\r\n                idxTracker++;\r\n            });\r\n            // now check for new ones\r\n            trackedAnchors.forEach((xrAnchor) => {\r\n                if (!this._lastFrameDetected.has(xrAnchor)) {\r\n                    const newAnchor: Partial<IWebXRAnchor> = {\r\n                        id: anchorIdProvider++,\r\n                        xrAnchor: xrAnchor,\r\n                        remove: () => xrAnchor.delete(),\r\n                    };\r\n                    const anchor = this._updateAnchorWithXRFrame(xrAnchor, newAnchor, frame);\r\n                    this._trackedAnchors.push(anchor);\r\n                    this.onAnchorAddedObservable.notifyObservers(anchor);\r\n                    // search for the future anchor promise that matches this\r\n                    const results = this._futureAnchors.filter((futureAnchor) => futureAnchor.nativeAnchor === xrAnchor);\r\n                    const result = results[0];\r\n                    if (result) {\r\n                        result.resolve(anchor);\r\n                        result.resolved = true;\r\n                    }\r\n                } else {\r\n                    const index = this._findIndexInAnchorArray(xrAnchor);\r\n                    const anchor = this._trackedAnchors[index];\r\n                    try {\r\n                        // anchors update every frame\r\n                        this._updateAnchorWithXRFrame(xrAnchor, anchor, frame);\r\n                        if (anchor.attachedNode) {\r\n                            anchor.attachedNode.rotationQuaternion = anchor.attachedNode.rotationQuaternion || new Quaternion();\r\n                            anchor.transformationMatrix.decompose(anchor.attachedNode.scaling, anchor.attachedNode.rotationQuaternion, anchor.attachedNode.position);\r\n                        }\r\n                        this.onAnchorUpdatedObservable.notifyObservers(anchor);\r\n                    } catch (e) {\r\n                        Tools.Warn(`Anchor could not be updated`);\r\n                    }\r\n                }\r\n            });\r\n            this._lastFrameDetected = trackedAnchors;\r\n        }\r\n\r\n        // process future anchors\r\n        this._futureAnchors.forEach((futureAnchor) => {\r\n            if (!futureAnchor.resolved && !futureAnchor.submitted) {\r\n                this._createAnchorAtTransformation(futureAnchor.xrTransformation, frame).then(\r\n                    (nativeAnchor) => {\r\n                        futureAnchor.nativeAnchor = nativeAnchor;\r\n                    },\r\n                    (error) => {\r\n                        futureAnchor.resolved = true;\r\n                        futureAnchor.reject(error);\r\n                    }\r\n                );\r\n                futureAnchor.submitted = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * avoiding using Array.find for global support.\r\n     * @param xrAnchor the plane to find in the array\r\n     */\r\n    private _findIndexInAnchorArray(xrAnchor: XRAnchor) {\r\n        for (let i = 0; i < this._trackedAnchors.length; ++i) {\r\n            if (this._trackedAnchors[i].xrAnchor === xrAnchor) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    private _updateAnchorWithXRFrame(xrAnchor: XRAnchor, anchor: Partial<IWebXRAnchor>, xrFrame: XRFrame): IWebXRAnchor {\r\n        // matrix\r\n        const pose = xrFrame.getPose(xrAnchor.anchorSpace, this._xrSessionManager.referenceSpace);\r\n        if (pose) {\r\n            const mat = anchor.transformationMatrix || new Matrix();\r\n            Matrix.FromArrayToRef(pose.transform.matrix, 0, mat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            anchor.transformationMatrix = mat;\r\n            if (!this._options.worldParentNode) {\r\n                // Logger.Warn(\"Please provide a world parent node to apply world transformation\");\r\n            } else {\r\n                mat.multiplyToRef(this._options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n        }\r\n\r\n        return <IWebXRAnchor>anchor;\r\n    }\r\n\r\n    private async _createAnchorAtTransformation(xrTransformation: XRRigidTransform, xrFrame: XRFrame) {\r\n        if (xrFrame.createAnchor) {\r\n            try {\r\n                return xrFrame.createAnchor(xrTransformation, this._referenceSpaceForFrameAnchors ?? this._xrSessionManager.referenceSpace);\r\n            } catch (error) {\r\n                throw new Error(error);\r\n            }\r\n        } else {\r\n            this.detach();\r\n            throw new Error(\"Anchors are not enabled in your browser\");\r\n        }\r\n    }\r\n}\r\n\r\n// register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRAnchorSystem.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRAnchorSystem(xrSessionManager, options);\r\n    },\r\n    WebXRAnchorSystem.Version\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}