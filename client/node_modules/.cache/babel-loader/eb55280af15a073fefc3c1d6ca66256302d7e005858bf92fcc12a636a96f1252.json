{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { BackEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\n */\nexport class BouncingBehavior {\n  constructor() {\n    /**\n     * The duration of the animation, in milliseconds\n     */\n    this.transitionDuration = 450;\n    /**\n     * Length of the distance animated by the transition when lower radius is reached\n     */\n    this.lowerRadiusTransitionRange = 2;\n    /**\n     * Length of the distance animated by the transition when upper radius is reached\n     */\n    this.upperRadiusTransitionRange = -2;\n    this._autoTransitionRange = false;\n    // Animations\n    this._radiusIsAnimating = false;\n    this._radiusBounceTransition = null;\n    this._animatables = new Array();\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"Bouncing\";\n  }\n  /**\n   * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n   */\n  get autoTransitionRange() {\n    return this._autoTransitionRange;\n  }\n  /**\n   * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\n   * Transition ranges will be set to 5% of the bounding box diagonal in world space\n   */\n  set autoTransitionRange(value) {\n    if (this._autoTransitionRange === value) {\n      return;\n    }\n    this._autoTransitionRange = value;\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return;\n    }\n    if (value) {\n      this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(mesh => {\n        if (!mesh) {\n          return;\n        }\n        mesh.computeWorldMatrix(true);\n        const diagonal = mesh.getBoundingInfo().diagonalLength;\n        this.lowerRadiusTransitionRange = diagonal * 0.05;\n        this.upperRadiusTransitionRange = diagonal * 0.05;\n      });\n    } else if (this._onMeshTargetChangedObserver) {\n      camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      if (!this._attachedCamera) {\n        return;\n      }\n      // Add the bounce animation to the lower radius limit\n      if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\n        this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\n      }\n      // Add the bounce animation to the upper radius limit\n      if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\n        this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\n      }\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n    this._attachedCamera = null;\n  }\n  /**\n   * Checks if the camera radius is at the specified limit. Takes into account animation locks.\n   * @param radiusLimit The limit to check against.\n   * @returns Bool to indicate if at limit.\n   */\n  _isRadiusAtLimit(radiusLimit) {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Applies an animation to the radius of the camera, extending by the radiusDelta.\n   * @param radiusDelta The delta by which to animate to. Can be negative.\n   */\n  _applyBoundRadiusAnimation(radiusDelta) {\n    if (!this._attachedCamera) {\n      return;\n    }\n    if (!this._radiusBounceTransition) {\n      BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\n      this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\n    }\n    // Prevent zoom until bounce has completed\n    this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\n    this._attachedCamera.wheelPrecision = Infinity;\n    this._attachedCamera.inertialRadiusOffset = 0;\n    // Animate to the radius limit\n    this.stopAllAnimations();\n    this._radiusIsAnimating = true;\n    const animatable = Animation.TransitionTo(\"radius\", this._attachedCamera.radius + radiusDelta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusBounceTransition, this.transitionDuration, () => this._clearAnimationLocks());\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  }\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the camera properties.\n   */\n  _clearAnimationLocks() {\n    this._radiusIsAnimating = false;\n    if (this._attachedCamera) {\n      this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\n    }\n  }\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n  stopAllAnimations() {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n    while (this._animatables.length) {\n      this._animatables[0].onAnimationEnd = null;\n      this._animatables[0].stop();\n      this._animatables.shift();\n    }\n  }\n}\n/**\n * The easing function used by animations\n */\nBouncingBehavior.EasingFunction = new BackEase(0.3);\n/**\n * The easing mode used by animations\n */\nBouncingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEOUT;","map":{"version":3,"mappings":"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","names":["BackEase","EasingFunction","Animation","BouncingBehavior","constructor","Array","name","autoTransitionRange","_autoTransitionRange","value","camera","_attachedCamera","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","add","mesh","computeWorldMatrix","diagonal","getBoundingInfo","diagonalLength","lowerRadiusTransitionRange","upperRadiusTransitionRange","remove","init","attach","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_isRadiusAtLimit","lowerRadiusLimit","_applyBoundRadiusAnimation","upperRadiusLimit","detach","radiusLimit","radius","_radiusIsAnimating","radiusDelta","_radiusBounceTransition","setEasingMode","EasingMode","CreateAnimation","ANIMATIONTYPE_FLOAT","_cachedWheelPrecision","wheelPrecision","Infinity","inertialRadiusOffset","stopAllAnimations","animatable","TransitionTo","getScene","transitionDuration","_clearAnimationLocks","_animatables","push","animations","length","onAnimationEnd","stop","shift","EASINGMODE_EASEOUT"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Cameras/bouncingBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { BackEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#bouncing-behavior\r\n */\r\nexport class BouncingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Bouncing\";\r\n    }\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new BackEase(0.3);\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEOUT;\r\n\r\n    /**\r\n     * The duration of the animation, in milliseconds\r\n     */\r\n    public transitionDuration = 450;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when lower radius is reached\r\n     */\r\n    public lowerRadiusTransitionRange = 2;\r\n\r\n    /**\r\n     * Length of the distance animated by the transition when upper radius is reached\r\n     */\r\n    public upperRadiusTransitionRange = -2;\r\n\r\n    private _autoTransitionRange = false;\r\n\r\n    /**\r\n     * Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     */\r\n    public get autoTransitionRange(): boolean {\r\n        return this._autoTransitionRange;\r\n    }\r\n\r\n    /**\r\n     * Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically\r\n     * Transition ranges will be set to 5% of the bounding box diagonal in world space\r\n     */\r\n    public set autoTransitionRange(value: boolean) {\r\n        if (this._autoTransitionRange === value) {\r\n            return;\r\n        }\r\n\r\n        this._autoTransitionRange = value;\r\n\r\n        const camera = this._attachedCamera;\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        if (value) {\r\n            this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n                if (!mesh) {\r\n                    return;\r\n                }\r\n\r\n                mesh.computeWorldMatrix(true);\r\n                const diagonal = mesh.getBoundingInfo().diagonalLength;\r\n\r\n                this.lowerRadiusTransitionRange = diagonal * 0.05;\r\n                this.upperRadiusTransitionRange = diagonal * 0.05;\r\n            });\r\n        } else if (this._onMeshTargetChangedObserver) {\r\n            camera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n    }\r\n\r\n    // Connection\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (!this._attachedCamera) {\r\n                return;\r\n            }\r\n\r\n            // Add the bounce animation to the lower radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange);\r\n            }\r\n\r\n            // Add the bounce animation to the upper radius limit\r\n            if (this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)) {\r\n                this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Animations\r\n    private _radiusIsAnimating: boolean = false;\r\n    private _radiusBounceTransition: Nullable<Animation> = null;\r\n    private _animatables = new Array<Animatable>();\r\n    private _cachedWheelPrecision: number;\r\n\r\n    /**\r\n     * Checks if the camera radius is at the specified limit. Takes into account animation locks.\r\n     * @param radiusLimit The limit to check against.\r\n     * @returns Bool to indicate if at limit.\r\n     */\r\n    private _isRadiusAtLimit(radiusLimit: Nullable<number>): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        if (this._attachedCamera.radius === radiusLimit && !this._radiusIsAnimating) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Applies an animation to the radius of the camera, extending by the radiusDelta.\r\n     * @param radiusDelta The delta by which to animate to. Can be negative.\r\n     */\r\n    private _applyBoundRadiusAnimation(radiusDelta: number): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        if (!this._radiusBounceTransition) {\r\n            BouncingBehavior.EasingFunction.setEasingMode(BouncingBehavior.EasingMode);\r\n            this._radiusBounceTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, BouncingBehavior.EasingFunction);\r\n        }\r\n        // Prevent zoom until bounce has completed\r\n        this._cachedWheelPrecision = this._attachedCamera.wheelPrecision;\r\n        this._attachedCamera.wheelPrecision = Infinity;\r\n        this._attachedCamera.inertialRadiusOffset = 0;\r\n\r\n        // Animate to the radius limit\r\n        this.stopAllAnimations();\r\n        this._radiusIsAnimating = true;\r\n        const animatable = Animation.TransitionTo(\r\n            \"radius\",\r\n            this._attachedCamera.radius + radiusDelta,\r\n            this._attachedCamera,\r\n            this._attachedCamera.getScene(),\r\n            60,\r\n            this._radiusBounceTransition,\r\n            this.transitionDuration,\r\n            () => this._clearAnimationLocks()\r\n        );\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the camera properties.\r\n     */\r\n    protected _clearAnimationLocks(): void {\r\n        this._radiusIsAnimating = false;\r\n\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.wheelPrecision = this._cachedWheelPrecision;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n        while (this._animatables.length) {\r\n            this._animatables[0].onAnimationEnd = null;\r\n            this._animatables[0].stop();\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}