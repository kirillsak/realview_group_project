{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize } from \"../Misc/decorators.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n */\nexport class FreeCamera extends TargetCamera {\n  /**\n   * Instantiates a Free Camera.\n   * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\n   * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the start position of the camera in the scene\n   * @param scene Define the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    /**\n     * Define the collision ellipsoid of the camera.\n     * This is helpful to simulate a camera body like the player body around the camera\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n     */\n    this.ellipsoid = new Vector3(0.5, 1, 0.5);\n    /**\n     * Define an offset for the position of the ellipsoid around the camera.\n     * This can be helpful to determine the center of the body near the gravity center of the body\n     * instead of its head.\n     */\n    this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\n     * Enable or disable collisions of the camera with the rest of the scene objects.\n     */\n    this.checkCollisions = false;\n    /**\n     * Enable or disable gravity on the camera.\n     */\n    this.applyGravity = false;\n    this._needMoveForGravity = false;\n    this._oldPosition = Vector3.Zero();\n    this._diffPosition = Vector3.Zero();\n    this._newPosition = Vector3.Zero();\n    // Collisions\n    this._collisionMask = -1;\n    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n      const updatePosition = newPos => {\n        this._newPosition.copyFrom(newPos);\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\n          this.position.addInPlace(this._diffPosition);\n          if (this.onCollide && collidedMesh) {\n            this.onCollide(collidedMesh);\n          }\n        }\n      };\n      updatePosition(newPosition);\n    };\n    this.inputs = new FreeCameraInputsManager(this);\n    this.inputs.addKeyboard().addMouse();\n  }\n  /**\n   * Gets the input sensibility for a mouse input. (default is 2000.0)\n   * Higher values reduce sensitivity.\n   */\n  get angularSensibility() {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      return mouse.angularSensibility;\n    }\n    return 0;\n  }\n  /**\n   * Sets the input sensibility for a mouse input. (default is 2000.0)\n   * Higher values reduce sensitivity.\n   */\n  set angularSensibility(value) {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      mouse.angularSensibility = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the forward move of the camera.\n   */\n  get keysUp() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUp;\n    }\n    return [];\n  }\n  set keysUp(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUp = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the upward move of the camera.\n   */\n  get keysUpward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUpward;\n    }\n    return [];\n  }\n  set keysUpward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUpward = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the backward move of the camera.\n   */\n  get keysDown() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDown;\n    }\n    return [];\n  }\n  set keysDown(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDown = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the downward move of the camera.\n   */\n  get keysDownward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDownward;\n    }\n    return [];\n  }\n  set keysDownward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDownward = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\n   */\n  get keysLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysLeft;\n    }\n    return [];\n  }\n  set keysLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysLeft = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\n   */\n  get keysRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRight;\n    }\n    return [];\n  }\n  set keysRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRight = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\n   */\n  get keysRotateLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateLeft;\n    }\n    return [];\n  }\n  set keysRotateLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateLeft = value;\n    }\n  }\n  /**\n   * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\n   */\n  get keysRotateRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRotateRight;\n    }\n    return [];\n  }\n  set keysRotateRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRotateRight = value;\n    }\n  }\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n    this.cameraRotation = new Vector2(0, 0);\n  }\n  /**\n   * Define a collision mask to limit the list of object the camera can collide with\n   */\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * @internal\n   */\n  _collideWithWorld(displacement) {\n    let globalPosition;\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n    const coordinator = this.getScene().collisionCoordinator;\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask;\n    //no need for clone, as long as gravity is not on.\n    let actualDisplacement = displacement;\n    //add gravity to the direction to prevent the dual-collision checking\n    if (this.applyGravity) {\n      //this prevents mending with cameraDirection, a global variable of the free camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  }\n  /** @internal */\n  _checkInputs() {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n    this.inputs.checkInputs();\n    super._checkInputs();\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      super._updatePosition();\n    }\n  }\n  /**\n   * Destroy the camera and release the current resources hold by it.\n   */\n  dispose() {\n    this.inputs.clear();\n    super.dispose();\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCamera\";\n  }\n}\n__decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoid\", void 0);\n__decorate([serializeAsVector3()], FreeCamera.prototype, \"ellipsoidOffset\", void 0);\n__decorate([serialize()], FreeCamera.prototype, \"checkCollisions\", void 0);\n__decorate([serialize()], FreeCamera.prototype, \"applyGravity\", void 0);","map":{"version":3,"mappings":"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","names":["serializeAsVector3","serialize","Vector3","Vector2","Engine","TargetCamera","FreeCameraInputsManager","Tools","FreeCamera","constructor","name","position","scene","setActiveOnSceneIfNoneActive","Zero","collisionId","newPosition","collidedMesh","updatePosition","newPos","_newPosition","copyFrom","subtractToRef","_oldPosition","_diffPosition","length","CollisionsEpsilon","addInPlace","onCollide","inputs","addKeyboard","addMouse","angularSensibility","mouse","attached","value","keysUp","keyboard","keysUpward","keysDown","keysDownward","keysLeft","keysRight","keysRotateLeft","keysRotateRight","attachControl","ignored","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","attachElement","detachControl","detachElement","cameraDirection","cameraRotation","collisionMask","_collisionMask","mask","isNaN","_collideWithWorld","displacement","globalPosition","parent","TransformCoordinates","getWorldMatrix","subtractFromFloatsToRef","ellipsoid","y","ellipsoidOffset","coordinator","getScene","collisionCoordinator","_collider","createCollider","_radius","actualDisplacement","applyGravity","add","gravity","getNewPosition","_onCollisionPositionChange","uniqueId","_checkInputs","_localDirection","_transformedDirection","checkInputs","_decideIfNeedsToMove","_needMoveForGravity","Math","abs","x","z","_updatePosition","checkCollisions","collisionsEnabled","dispose","clear","getClassName","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Cameras/freeCamera.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        const updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}