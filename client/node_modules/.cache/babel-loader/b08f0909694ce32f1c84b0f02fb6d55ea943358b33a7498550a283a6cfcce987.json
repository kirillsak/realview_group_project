{"ast":null,"code":"import { Observable } from \"../Misc/observable.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { RotationGizmo } from \"./rotationGizmo.js\";\nimport { PositionGizmo } from \"./positionGizmo.js\";\nimport { ScaleGizmo } from \"./scaleGizmo.js\";\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo.js\";\n/**\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\n */\nexport class GizmoManager {\n  /**\n   * Instantiates a gizmo manager\n   * @param _scene the scene to overlay the gizmos on top of\n   * @param thickness display gizmo axis thickness\n   * @param utilityLayer the layer where gizmos are rendered\n   * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\n   */\n  constructor(_scene, thickness = 1, utilityLayer = UtilityLayerRenderer.DefaultUtilityLayer, keepDepthUtilityLayer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer) {\n    this._scene = _scene;\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\n    this.clearGizmoOnEmptyPointerEvent = false;\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\n    this.enableAutoPicking = true;\n    /** Fires an event when the manager is attached to a mesh */\n    this.onAttachedToMeshObservable = new Observable();\n    /** Fires an event when the manager is attached to a node */\n    this.onAttachedToNodeObservable = new Observable();\n    this._gizmosEnabled = {\n      positionGizmo: false,\n      rotationGizmo: false,\n      scaleGizmo: false,\n      boundingBoxGizmo: false\n    };\n    this._pointerObservers = [];\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._boundingBoxColor = Color3.FromHexString(\"#0984e3\");\n    this._thickness = 1;\n    this._scaleRatio = 1;\n    /** Node Caching for quick lookup */\n    this._gizmoAxisCache = new Map();\n    /**\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\n     */\n    this.boundingBoxDragBehavior = new SixDofDragBehavior();\n    /**\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\n     */\n    this.attachableMeshes = null;\n    /**\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\n     */\n    this.attachableNodes = null;\n    /**\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\n     */\n    this.usePointerToAttachGizmos = true;\n    this._defaultUtilityLayer = utilityLayer;\n    this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\n    this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n    this._thickness = thickness;\n    this.gizmos = {\n      positionGizmo: null,\n      rotationGizmo: null,\n      scaleGizmo: null,\n      boundingBoxGizmo: null\n    };\n    const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\n    const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\n    this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\n  }\n  /**\n   * Utility layer that the bounding box gizmo belongs to\n   */\n  get keepDepthUtilityLayer() {\n    return this._defaultKeepDepthUtilityLayer;\n  }\n  /**\n   * Utility layer that all gizmos besides bounding box belong to\n   */\n  get utilityLayer() {\n    return this._defaultUtilityLayer;\n  }\n  /**\n   * True when the mouse pointer is hovering a gizmo mesh\n   */\n  get isHovered() {\n    let hovered = false;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && gizmo.isHovered) {\n        hovered = true;\n        break;\n      }\n    }\n    return hovered;\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n    [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach(gizmo => {\n      if (gizmo) {\n        gizmo.scaleRatio = value;\n      }\n    });\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * Subscribes to pointer down events, for attaching and detaching mesh\n   * @param scene The scene layer the observer will be added to\n   */\n  _attachToMeshPointerObserver(scene) {\n    // Instantiate/dispose gizmos based on pointer actions\n    const pointerObserver = scene.onPointerObservable.add(pointerInfo => {\n      if (!this.usePointerToAttachGizmos) {\n        return;\n      }\n      if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\n        if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\n          if (this.enableAutoPicking) {\n            let node = pointerInfo.pickInfo.pickedMesh;\n            if (this.attachableMeshes == null) {\n              // Attach to the most parent node\n              while (node && node.parent != null) {\n                node = node.parent;\n              }\n            } else {\n              // Attach to the parent node that is an attachableMesh\n              let found = false;\n              this.attachableMeshes.forEach(mesh => {\n                if (node && (node == mesh || node.isDescendantOf(mesh))) {\n                  node = mesh;\n                  found = true;\n                }\n              });\n              if (!found) {\n                node = null;\n              }\n            }\n            if (node instanceof AbstractMesh) {\n              if (this._attachedMesh != node) {\n                this.attachToMesh(node);\n              }\n            } else {\n              if (this.clearGizmoOnEmptyPointerEvent) {\n                this.attachToMesh(null);\n              }\n            }\n          }\n        } else {\n          if (this.clearGizmoOnEmptyPointerEvent) {\n            this.attachToMesh(null);\n          }\n        }\n      }\n    });\n    return pointerObserver;\n  }\n  /**\n   * Attaches a set of gizmos to the specified mesh\n   * @param mesh The mesh the gizmo's should be attached to\n   */\n  attachToMesh(mesh) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    this._attachedMesh = mesh;\n    this._attachedNode = null;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedMesh = mesh;\n      }\n    }\n    if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\n      this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n    }\n    this.onAttachedToMeshObservable.notifyObservers(mesh);\n  }\n  /**\n   * Attaches a set of gizmos to the specified node\n   * @param node The node the gizmo's should be attached to\n   */\n  attachToNode(node) {\n    if (this._attachedMesh) {\n      this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    if (this._attachedNode) {\n      this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n    }\n    this._attachedMesh = null;\n    this._attachedNode = node;\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo && this._gizmosEnabled[key]) {\n        gizmo.attachedNode = node;\n      }\n    }\n    if (this.boundingBoxGizmoEnabled && this._attachedNode) {\n      this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n    }\n    this.onAttachedToNodeObservable.notifyObservers(node);\n  }\n  /**\n   * If the position gizmo is enabled\n   */\n  set positionGizmoEnabled(value) {\n    if (value) {\n      if (!this.gizmos.positionGizmo) {\n        this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\n      }\n      if (this._attachedNode) {\n        this.gizmos.positionGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.positionGizmo) {\n      this.gizmos.positionGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.positionGizmo = value;\n  }\n  get positionGizmoEnabled() {\n    return this._gizmosEnabled.positionGizmo;\n  }\n  /**\n   * If the rotation gizmo is enabled\n   */\n  set rotationGizmoEnabled(value) {\n    if (value) {\n      if (!this.gizmos.rotationGizmo) {\n        this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\n      }\n      if (this._attachedNode) {\n        this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.rotationGizmo) {\n      this.gizmos.rotationGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.rotationGizmo = value;\n  }\n  get rotationGizmoEnabled() {\n    return this._gizmosEnabled.rotationGizmo;\n  }\n  /**\n   * If the scale gizmo is enabled\n   */\n  set scaleGizmoEnabled(value) {\n    if (value) {\n      this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\n      if (this._attachedNode) {\n        this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\n      } else {\n        this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\n      }\n    } else if (this.gizmos.scaleGizmo) {\n      this.gizmos.scaleGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.scaleGizmo = value;\n  }\n  get scaleGizmoEnabled() {\n    return this._gizmosEnabled.scaleGizmo;\n  }\n  /**\n   * If the boundingBox gizmo is enabled\n   */\n  set boundingBoxGizmoEnabled(value) {\n    if (value) {\n      this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\n      if (this._attachedMesh) {\n        this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\n      } else {\n        this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\n      }\n      if (this._attachedMesh) {\n        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n        this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\n      } else if (this._attachedNode) {\n        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n        this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\n      }\n    } else if (this.gizmos.boundingBoxGizmo) {\n      if (this._attachedMesh) {\n        this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\n      } else if (this._attachedNode) {\n        this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\n      }\n      this.gizmos.boundingBoxGizmo.attachedNode = null;\n    }\n    this._gizmosEnabled.boundingBoxGizmo = value;\n  }\n  get boundingBoxGizmoEnabled() {\n    return this._gizmosEnabled.boundingBoxGizmo;\n  }\n  /**\n   * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   */\n  addToAxisCache(gizmoAxisCache) {\n    if (gizmoAxisCache.size > 0) {\n      gizmoAxisCache.forEach((v, k) => {\n        this._gizmoAxisCache.set(k, v);\n      });\n    }\n  }\n  /**\n   * Disposes of the gizmo manager\n   */\n  dispose() {\n    var _a, _b;\n    this._pointerObservers.forEach(observer => {\n      this._scene.onPointerObservable.remove(observer);\n    });\n    for (const key in this.gizmos) {\n      const gizmo = this.gizmos[key];\n      if (gizmo) {\n        gizmo.dispose();\n      }\n    }\n    if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\n      (_a = this._defaultKeepDepthUtilityLayer) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n    if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\n      (_b = this._defaultUtilityLayer) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n    this.boundingBoxDragBehavior.detach();\n    this.onAttachedToMeshObservable.clear();\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","PointerEventTypes","AbstractMesh","UtilityLayerRenderer","Color3","SixDofDragBehavior","Gizmo","RotationGizmo","PositionGizmo","ScaleGizmo","BoundingBoxGizmo","GizmoManager","constructor","_scene","thickness","utilityLayer","DefaultUtilityLayer","keepDepthUtilityLayer","DefaultKeepDepthUtilityLayer","positionGizmo","rotationGizmo","scaleGizmo","boundingBoxGizmo","FromHexString","Map","_defaultUtilityLayer","_defaultKeepDepthUtilityLayer","utilityLayerScene","autoClearDepthAndStencil","_thickness","gizmos","attachToMeshPointerObserver","_attachToMeshPointerObserver","gizmoAxisPointerObserver","GizmoAxisPointerObserver","_gizmoAxisCache","_pointerObservers","isHovered","hovered","key","gizmo","scaleRatio","value","_scaleRatio","forEach","scene","pointerObserver","onPointerObservable","add","pointerInfo","usePointerToAttachGizmos","type","POINTERDOWN","pickInfo","pickedMesh","enableAutoPicking","node","attachableMeshes","parent","found","mesh","isDescendantOf","_attachedMesh","attachToMesh","clearGizmoOnEmptyPointerEvent","removeBehavior","boundingBoxDragBehavior","_attachedNode","_gizmosEnabled","attachedMesh","boundingBoxGizmoEnabled","addBehavior","onAttachedToMeshObservable","notifyObservers","attachToNode","attachedNode","onAttachedToNodeObservable","positionGizmoEnabled","rotationGizmoEnabled","scaleGizmoEnabled","_boundingBoxColor","addToAxisCache","gizmoAxisCache","size","v","k","set","dispose","observer","remove","_DefaultKeepDepthUtilityLayer","_DefaultUtilityLayer","detach","clear"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/gizmoManager.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { SixDofDragBehavior } from \"../Behaviors/Meshes/sixDofDragBehavior\";\r\nimport type { GizmoAxisCache, IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport type { IRotationGizmo } from \"./rotationGizmo\";\r\nimport { RotationGizmo } from \"./rotationGizmo\";\r\nimport type { IPositionGizmo } from \"./positionGizmo\";\r\nimport { PositionGizmo } from \"./positionGizmo\";\r\nimport type { IScaleGizmo } from \"./scaleGizmo\";\r\nimport { ScaleGizmo } from \"./scaleGizmo\";\r\nimport type { IBoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\nimport { BoundingBoxGizmo } from \"./boundingBoxGizmo\";\r\n\r\n/**\r\n * Helps setup gizmo's in the scene to rotate/scale/position nodes\r\n */\r\nexport class GizmoManager implements IDisposable {\r\n    /**\r\n     * Gizmo's created by the gizmo manager, gizmo will be null until gizmo has been enabled for the first time\r\n     */\r\n    public gizmos: {\r\n        positionGizmo: Nullable<IPositionGizmo>;\r\n        rotationGizmo: Nullable<IRotationGizmo>;\r\n        scaleGizmo: Nullable<IScaleGizmo>;\r\n        boundingBoxGizmo: Nullable<IBoundingBoxGizmo>;\r\n    };\r\n\r\n    /** When true, the gizmo will be detached from the current object when a pointer down occurs with an empty picked mesh */\r\n    public clearGizmoOnEmptyPointerEvent = false;\r\n\r\n    /** When true (default), picking to attach a new mesh is enabled. This works in sync with inspector autopicking. */\r\n    public enableAutoPicking = true;\r\n\r\n    /** Fires an event when the manager is attached to a mesh */\r\n    public onAttachedToMeshObservable = new Observable<Nullable<AbstractMesh>>();\r\n\r\n    /** Fires an event when the manager is attached to a node */\r\n    public onAttachedToNodeObservable = new Observable<Nullable<Node>>();\r\n\r\n    protected _gizmosEnabled = { positionGizmo: false, rotationGizmo: false, scaleGizmo: false, boundingBoxGizmo: false };\r\n    protected _pointerObservers: Observer<PointerInfo>[] = [];\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _boundingBoxColor = Color3.FromHexString(\"#0984e3\");\r\n    protected _defaultUtilityLayer: UtilityLayerRenderer;\r\n    protected _defaultKeepDepthUtilityLayer: UtilityLayerRenderer;\r\n    protected _thickness: number = 1;\r\n    protected _scaleRatio: number = 1;\r\n\r\n    /** Node Caching for quick lookup */\r\n    private _gizmoAxisCache: Map<Mesh, GizmoAxisCache> = new Map();\r\n    /**\r\n     * When bounding box gizmo is enabled, this can be used to track drag/end events\r\n     */\r\n    public boundingBoxDragBehavior = new SixDofDragBehavior();\r\n    /**\r\n     * Array of meshes which will have the gizmo attached when a pointer selected them. If null, all meshes are attachable. (Default: null)\r\n     */\r\n    public attachableMeshes: Nullable<Array<AbstractMesh>> = null;\r\n    /**\r\n     * Array of nodes which will have the gizmo attached when a pointer selected them. If null, all nodes are attachable. (Default: null)\r\n     */\r\n    public attachableNodes: Nullable<Array<Node>> = null;\r\n    /**\r\n     * If pointer events should perform attaching/detaching a gizmo, if false this can be done manually via attachToMesh/attachToNode. (Default: true)\r\n     */\r\n    public usePointerToAttachGizmos = true;\r\n\r\n    /**\r\n     * Utility layer that the bounding box gizmo belongs to\r\n     */\r\n    public get keepDepthUtilityLayer() {\r\n        return this._defaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Utility layer that all gizmos besides bounding box belong to\r\n     */\r\n    public get utilityLayer() {\r\n        return this._defaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovering a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        let hovered = false;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && gizmo.isHovered) {\r\n                hovered = true;\r\n                break;\r\n            }\r\n        }\r\n        return hovered;\r\n    }\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n        [this.gizmos.positionGizmo, this.gizmos.rotationGizmo, this.gizmos.scaleGizmo].forEach((gizmo) => {\r\n            if (gizmo) {\r\n                gizmo.scaleRatio = value;\r\n            }\r\n        });\r\n    }\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a gizmo manager\r\n     * @param _scene the scene to overlay the gizmos on top of\r\n     * @param thickness display gizmo axis thickness\r\n     * @param utilityLayer the layer where gizmos are rendered\r\n     * @param keepDepthUtilityLayer the layer where occluded gizmos are rendered\r\n     */\r\n    constructor(\r\n        private _scene: Scene,\r\n        thickness: number = 1,\r\n        utilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer,\r\n        keepDepthUtilityLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultKeepDepthUtilityLayer\r\n    ) {\r\n        this._defaultUtilityLayer = utilityLayer;\r\n        this._defaultKeepDepthUtilityLayer = keepDepthUtilityLayer;\r\n        this._defaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n        this._thickness = thickness;\r\n        this.gizmos = { positionGizmo: null, rotationGizmo: null, scaleGizmo: null, boundingBoxGizmo: null };\r\n\r\n        const attachToMeshPointerObserver = this._attachToMeshPointerObserver(_scene);\r\n        const gizmoAxisPointerObserver = Gizmo.GizmoAxisPointerObserver(this._defaultUtilityLayer, this._gizmoAxisCache);\r\n        this._pointerObservers = [attachToMeshPointerObserver, gizmoAxisPointerObserver];\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer down events, for attaching and detaching mesh\r\n     * @param scene The scene layer the observer will be added to\r\n     */\r\n    private _attachToMeshPointerObserver(scene: Scene): Observer<PointerInfo> {\r\n        // Instantiate/dispose gizmos based on pointer actions\r\n        const pointerObserver = scene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this.usePointerToAttachGizmos) {\r\n                return;\r\n            }\r\n            if (pointerInfo.type == PointerEventTypes.POINTERDOWN) {\r\n                if (pointerInfo.pickInfo && pointerInfo.pickInfo.pickedMesh) {\r\n                    if (this.enableAutoPicking) {\r\n                        let node: Nullable<Node> = pointerInfo.pickInfo.pickedMesh;\r\n                        if (this.attachableMeshes == null) {\r\n                            // Attach to the most parent node\r\n                            while (node && node.parent != null) {\r\n                                node = node.parent;\r\n                            }\r\n                        } else {\r\n                            // Attach to the parent node that is an attachableMesh\r\n                            let found = false;\r\n                            this.attachableMeshes.forEach((mesh) => {\r\n                                if (node && (node == mesh || node.isDescendantOf(mesh))) {\r\n                                    node = mesh;\r\n                                    found = true;\r\n                                }\r\n                            });\r\n                            if (!found) {\r\n                                node = null;\r\n                            }\r\n                        }\r\n                        if (node instanceof AbstractMesh) {\r\n                            if (this._attachedMesh != node) {\r\n                                this.attachToMesh(node);\r\n                            }\r\n                        } else {\r\n                            if (this.clearGizmoOnEmptyPointerEvent) {\r\n                                this.attachToMesh(null);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.clearGizmoOnEmptyPointerEvent) {\r\n                        this.attachToMesh(null);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified mesh\r\n     * @param mesh The mesh the gizmo's should be attached to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = mesh;\r\n        this._attachedNode = null;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedMesh = mesh;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedMesh) {\r\n            this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToMeshObservable.notifyObservers(mesh);\r\n    }\r\n\r\n    /**\r\n     * Attaches a set of gizmos to the specified node\r\n     * @param node The node the gizmo's should be attached to\r\n     */\r\n    public attachToNode(node: Nullable<Node>) {\r\n        if (this._attachedMesh) {\r\n            this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        if (this._attachedNode) {\r\n            this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this._attachedMesh = null;\r\n        this._attachedNode = node;\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo && (<any>this._gizmosEnabled)[key]) {\r\n                gizmo.attachedNode = node;\r\n            }\r\n        }\r\n        if (this.boundingBoxGizmoEnabled && this._attachedNode) {\r\n            this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n        }\r\n        this.onAttachedToNodeObservable.notifyObservers(node);\r\n    }\r\n\r\n    /**\r\n     * If the position gizmo is enabled\r\n     */\r\n    public set positionGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.positionGizmo) {\r\n                this.gizmos.positionGizmo = new PositionGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.positionGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.positionGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.positionGizmo) {\r\n            this.gizmos.positionGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.positionGizmo = value;\r\n    }\r\n    public get positionGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.positionGizmo;\r\n    }\r\n    /**\r\n     * If the rotation gizmo is enabled\r\n     */\r\n    public set rotationGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            if (!this.gizmos.rotationGizmo) {\r\n                this.gizmos.rotationGizmo = new RotationGizmo(this._defaultUtilityLayer, 32, false, this._thickness, this);\r\n            }\r\n            if (this._attachedNode) {\r\n                this.gizmos.rotationGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.rotationGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.rotationGizmo) {\r\n            this.gizmos.rotationGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.rotationGizmo = value;\r\n    }\r\n    public get rotationGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.rotationGizmo;\r\n    }\r\n    /**\r\n     * If the scale gizmo is enabled\r\n     */\r\n    public set scaleGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.scaleGizmo = this.gizmos.scaleGizmo || new ScaleGizmo(this._defaultUtilityLayer, this._thickness, this);\r\n            if (this._attachedNode) {\r\n                this.gizmos.scaleGizmo.attachedNode = this._attachedNode;\r\n            } else {\r\n                this.gizmos.scaleGizmo.attachedMesh = this._attachedMesh;\r\n            }\r\n        } else if (this.gizmos.scaleGizmo) {\r\n            this.gizmos.scaleGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.scaleGizmo = value;\r\n    }\r\n    public get scaleGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.scaleGizmo;\r\n    }\r\n    /**\r\n     * If the boundingBox gizmo is enabled\r\n     */\r\n    public set boundingBoxGizmoEnabled(value: boolean) {\r\n        if (value) {\r\n            this.gizmos.boundingBoxGizmo = this.gizmos.boundingBoxGizmo || new BoundingBoxGizmo(this._boundingBoxColor, this._defaultKeepDepthUtilityLayer);\r\n            if (this._attachedMesh) {\r\n                this.gizmos.boundingBoxGizmo.attachedMesh = this._attachedMesh;\r\n            } else {\r\n                this.gizmos.boundingBoxGizmo.attachedNode = this._attachedNode;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedMesh.addBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n                this._attachedNode.addBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n        } else if (this.gizmos.boundingBoxGizmo) {\r\n            if (this._attachedMesh) {\r\n                this._attachedMesh.removeBehavior(this.boundingBoxDragBehavior);\r\n            } else if (this._attachedNode) {\r\n                this._attachedNode.removeBehavior(this.boundingBoxDragBehavior);\r\n            }\r\n            this.gizmos.boundingBoxGizmo.attachedNode = null;\r\n        }\r\n        this._gizmosEnabled.boundingBoxGizmo = value;\r\n    }\r\n    public get boundingBoxGizmoEnabled(): boolean {\r\n        return this._gizmosEnabled.boundingBoxGizmo;\r\n    }\r\n\r\n    /**\r\n     * Builds Gizmo Axis Cache to enable features such as hover state preservation and graying out other axis during manipulation\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     */\r\n    public addToAxisCache(gizmoAxisCache: Map<Mesh, GizmoAxisCache>) {\r\n        if (gizmoAxisCache.size > 0) {\r\n            gizmoAxisCache.forEach((v, k) => {\r\n                this._gizmoAxisCache.set(k, v);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo manager\r\n     */\r\n    public dispose() {\r\n        this._pointerObservers.forEach((observer) => {\r\n            this._scene.onPointerObservable.remove(observer);\r\n        });\r\n        for (const key in this.gizmos) {\r\n            const gizmo = <Nullable<IGizmo>>(<any>this.gizmos)[key];\r\n            if (gizmo) {\r\n                gizmo.dispose();\r\n            }\r\n        }\r\n        if (this._defaultKeepDepthUtilityLayer !== UtilityLayerRenderer._DefaultKeepDepthUtilityLayer) {\r\n            this._defaultKeepDepthUtilityLayer?.dispose();\r\n        }\r\n        if (this._defaultUtilityLayer !== UtilityLayerRenderer._DefaultUtilityLayer) {\r\n            this._defaultUtilityLayer?.dispose();\r\n        }\r\n        this.boundingBoxDragBehavior.detach();\r\n        this.onAttachedToMeshObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}