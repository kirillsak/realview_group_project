{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator.js\";\nimport { GetClass } from \"../../Misc/typeStore.js\";\n/**\n * Defines a block that can be used inside a node based material\n */\nexport class NodeMaterialBlock {\n  /**\n   * Creates a new NodeMaterialBlock\n   * @param name defines the block name\n   * @param target defines the target of that block (Vertex by default)\n   * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\n   * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\n   */\n  constructor(name, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {\n    this._isFinalMerger = false;\n    this._isInput = false;\n    this._name = \"\";\n    this._isUnique = false;\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\n    this.inputsAreExclusive = false;\n    /** @internal */\n    this._codeVariableName = \"\";\n    /** @internal */\n    this._inputs = new Array();\n    /** @internal */\n    this._outputs = new Array();\n    /**\n     * Gets or sets the comments associated with this block\n     */\n    this.comments = \"\";\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\n    this.visibleInInspector = false;\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\n    this.visibleOnFrame = false;\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n    this._isFinalMerger = isFinalMerger;\n    this._isInput = isInput;\n    this._name = name;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n  }\n  /**\n   * Gets the name of the block\n   */\n  get name() {\n    return this._name;\n  }\n  /**\n   * Sets the name of the block. Will check if the name is valid.\n   */\n  set name(newName) {\n    if (!this.validateBlockName(newName)) {\n      return;\n    }\n    this._name = newName;\n  }\n  /**\n   * Gets a boolean indicating that this block can only be used once per NodeMaterial\n   */\n  get isUnique() {\n    return this._isUnique;\n  }\n  /**\n   * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\n   */\n  get isFinalMerger() {\n    return this._isFinalMerger;\n  }\n  /**\n   * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\n   */\n  get isInput() {\n    return this._isInput;\n  }\n  /**\n   * Gets or sets the build Id\n   */\n  get buildId() {\n    return this._buildId;\n  }\n  set buildId(value) {\n    this._buildId = value;\n  }\n  /**\n   * Gets or sets the target of the block\n   */\n  get target() {\n    return this._target;\n  }\n  set target(value) {\n    if ((this._target & value) !== 0) {\n      return;\n    }\n    this._target = value;\n  }\n  /**\n   * Gets the list of input points\n   */\n  get inputs() {\n    return this._inputs;\n  }\n  /** Gets the list of output points */\n  get outputs() {\n    return this._outputs;\n  }\n  /**\n   * Find an input by its name\n   * @param name defines the name of the input to look for\n   * @returns the input or null if not found\n   */\n  getInputByName(name) {\n    const filter = this._inputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /**\n   * Find an output by its name\n   * @param name defines the name of the output to look for\n   * @returns the output or null if not found\n   */\n  getOutputByName(name) {\n    const filter = this._outputs.filter(e => e.name === name);\n    if (filter.length) {\n      return filter[0];\n    }\n    return null;\n  }\n  /** @internal */\n  _setInitialTarget(target) {\n    this._target = target;\n    this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initialize(state) {\n    // Do nothing\n  }\n  /**\n   * Bind data to effect. Will only be called for blocks with isBindable === true\n   * @param effect defines the effect to bind data to\n   * @param nodeMaterial defines the hosting NodeMaterial\n   * @param mesh defines the mesh that will be rendered\n   * @param subMesh defines the submesh that will be rendered\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  bind(effect, nodeMaterial, mesh, subMesh) {\n    // Do nothing\n  }\n  _declareOutput(output, state) {\n    return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\n  }\n  _writeVariable(currentPoint) {\n    const connectionPoint = currentPoint.connectedPoint;\n    if (connectionPoint) {\n      return `${currentPoint.associatedVariableName}`;\n    }\n    return `0.`;\n  }\n  _writeFloat(value) {\n    let stringVersion = value.toString();\n    if (stringVersion.indexOf(\".\") === -1) {\n      stringVersion += \".0\";\n    }\n    return `${stringVersion}`;\n  }\n  /**\n   * Gets the current class name e.g. \"NodeMaterialBlock\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterialBlock\";\n  }\n  /**\n   * Register a new input. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param isOptional defines a boolean indicating that this input can be omitted\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerInput(name, type, isOptional = false, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\n    point.type = type;\n    point.isOptional = isOptional;\n    if (target) {\n      point.target = target;\n    }\n    this._inputs.push(point);\n    return this;\n  }\n  /**\n   * Register a new output. Must be called inside a block constructor\n   * @param name defines the connection point name\n   * @param type defines the connection point type\n   * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\n   * @param point an already created connection point. If not provided, create a new one\n   * @returns the current block\n   */\n  registerOutput(name, type, target, point) {\n    point = point !== null && point !== void 0 ? point : new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\n    point.type = type;\n    if (target) {\n      point.target = target;\n    }\n    this._outputs.push(point);\n    return this;\n  }\n  /**\n   * Will return the first available input e.g. the first one which is not an uniform or an attribute\n   * @param forOutput defines an optional connection point to check compatibility with\n   * @returns the first available input or null\n   */\n  getFirstAvailableInput(forOutput = null) {\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\n          return input;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Will return the first available output e.g. the first one which is not yet connected and not a varying\n   * @param forBlock defines an optional block to check compatibility with\n   * @returns the first available input or null\n   */\n  getFirstAvailableOutput(forBlock = null) {\n    for (const output of this._outputs) {\n      if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\n        return output;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the sibling of the given output\n   * @param current defines the current output\n   * @returns the next output in the list or null\n   */\n  getSiblingOutput(current) {\n    const index = this._outputs.indexOf(current);\n    if (index === -1 || index >= this._outputs.length) {\n      return null;\n    }\n    return this._outputs[index + 1];\n  }\n  /**\n   * Checks if the current block is an ancestor of a given block\n   * @param block defines the potential descendant block to check\n   * @returns true if block is a descendant\n   */\n  isAnAncestorOf(block) {\n    for (const output of this._outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        if (endpoint.ownerBlock === block) {\n          return true;\n        }\n        if (endpoint.ownerBlock.isAnAncestorOf(block)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Connect current block with another block\n   * @param other defines the block to connect with\n   * @param options define the various options to help pick the right connections\n   * @param options.input\n   * @param options.output\n   * @param options.outputSwizzle\n   * @returns the current block\n   */\n  connectTo(other, options) {\n    if (this._outputs.length === 0) {\n      return;\n    }\n    let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\n    let notFound = true;\n    while (notFound) {\n      const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\n      if (output && input && output.canConnectTo(input)) {\n        output.connectTo(input);\n        notFound = false;\n      } else if (!output) {\n        throw \"Unable to find a compatible match\";\n      } else {\n        output = this.getSiblingOutput(output);\n      }\n    }\n    return this;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _buildBlock(state) {\n    // Empty. Must be defined by child nodes\n  }\n  /**\n   * Add uniforms, samplers and uniform buffers at compilation time\n   * @param state defines the state to update\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param uniformBuffers defines the list of uniform buffer names\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    // Do nothing\n  }\n  /**\n   * Add potential fallbacks if shader compilation fails\n   * @param mesh defines the mesh to be rendered\n   * @param fallbacks defines the current prioritized list of fallbacks\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  provideFallbacks(mesh, fallbacks) {\n    // Do nothing\n  }\n  /**\n   * Initialize defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  initializeDefines(mesh, nodeMaterial, defines, useInstances = false) {}\n  /**\n   * Update defines for shader compilation\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @param subMesh defines which submesh to render\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  prepareDefines(mesh, nodeMaterial, defines, useInstances = false, subMesh) {\n    // Do nothing\n  }\n  /**\n   * Lets the block try to connect some inputs automatically\n   * @param material defines the hosting NodeMaterial\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  autoConfigure(material) {\n    // Do nothing\n  }\n  /**\n   * Function called when a block is declared as repeatable content generator\n   * @param vertexShaderState defines the current compilation state for the vertex shader\n   * @param fragmentShaderState defines the current compilation state for the fragment shader\n   * @param mesh defines the mesh to be rendered\n   * @param defines defines the material defines to update\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {\n    // Do nothing\n  }\n  /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\n  get willBeGeneratedIntoVertexShaderFromFragmentShader() {\n    if (this.isInput || this.isFinalMerger) {\n      return false;\n    }\n    if (this._outputs.some(o => o.isDirectlyConnectedToVertexOutput)) {\n      return false;\n    }\n    if (this.target === NodeMaterialBlockTargets.Vertex) {\n      return false;\n    }\n    if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\n      if (this._outputs.some(o => o.isConnectedInVertexShader)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks if the block is ready\n   * @param mesh defines the mesh to be rendered\n   * @param nodeMaterial defines the node material requesting the update\n   * @param defines defines the material defines to update\n   * @param useInstances specifies that instances should be used\n   * @returns true if the block is ready\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isReady(mesh, nodeMaterial, defines, useInstances = false) {\n    return true;\n  }\n  _linkConnectionTypes(inputIndex0, inputIndex1, looseCoupling = false) {\n    if (looseCoupling) {\n      this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\n    } else {\n      this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\n    }\n    this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\n  }\n  _processBuild(block, state, input, activeBlocks) {\n    block.build(state, activeBlocks);\n    const localBlockIsFragment = state._vertexState != null;\n    const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\n    if (localBlockIsFragment && ((block.target & block._buildTarget) === 0 || (block.target & input.target) === 0 || this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader)) {\n      // context switch! We need a varying\n      if (!block.isInput && state.target !== block._buildTarget ||\n      // block was already emitted by vertex shader\n      block.isInput && block.isAttribute && !block._noContextSwitch // block is an attribute\n      ) {\n        const connectedPoint = input.connectedPoint;\n        if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\n          state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\r\\n`;\n        }\n        input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\n        input._enforceAssociatedVariableName = true;\n      }\n    }\n  }\n  /**\n   * Validates the new name for the block node.\n   * @param newName the new name to be given to the node.\n   * @returns false if the name is a reserve word, else true.\n   */\n  validateBlockName(newName) {\n    const reservedNames = [\"position\", \"normal\", \"tangent\", \"particle_positionw\", \"uv\", \"uv2\", \"uv3\", \"uv4\", \"uv5\", \"uv6\", \"position2d\", \"particle_uv\", \"matricesIndices\", \"matricesWeights\", \"world0\", \"world1\", \"world2\", \"world3\", \"particle_color\", \"particle_texturemask\"];\n    for (const reservedName of reservedNames) {\n      if (newName === reservedName) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Compile the current node and generate the shader code\n   * @param state defines the current compilation state (uniforms, samplers, current string)\n   * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\n   * @returns true if already built\n   */\n  build(state, activeBlocks) {\n    if (this._buildId === state.sharedData.buildId) {\n      return true;\n    }\n    if (!this.isInput) {\n      /** Prepare outputs */\n      for (const output of this._outputs) {\n        if (!output.associatedVariableName) {\n          output.associatedVariableName = state._getFreeVariableName(output.name);\n        }\n      }\n    }\n    // Check if \"parent\" blocks are compiled\n    for (const input of this._inputs) {\n      if (!input.connectedPoint) {\n        if (!input.isOptional) {\n          // Emit a warning\n          state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\n        }\n        continue;\n      }\n      if (this.target !== NodeMaterialBlockTargets.Neutral) {\n        if ((input.target & this.target) === 0) {\n          continue;\n        }\n        if ((input.target & state.target) === 0) {\n          continue;\n        }\n      }\n      const block = input.connectedPoint.ownerBlock;\n      if (block && block !== this) {\n        this._processBuild(block, state, input, activeBlocks);\n      }\n    }\n    if (this._buildId === state.sharedData.buildId) {\n      return true; // Need to check again as inputs can be connected multiple time to this endpoint\n    }\n    // Logs\n    if (state.sharedData.verbose) {\n      console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\n    }\n    // Checks final outputs\n    if (this.isFinalMerger) {\n      switch (state.target) {\n        case NodeMaterialBlockTargets.Vertex:\n          state.sharedData.checks.emitVertex = true;\n          break;\n        case NodeMaterialBlockTargets.Fragment:\n          state.sharedData.checks.emitFragment = true;\n          break;\n      }\n    }\n    if (!this.isInput && state.sharedData.emitComments) {\n      state.compilationString += `\\r\\n//${this.name}\\r\\n`;\n    }\n    this._buildBlock(state);\n    this._buildId = state.sharedData.buildId;\n    this._buildTarget = state.target;\n    // Compile connected blocks\n    for (const output of this._outputs) {\n      if ((output.target & state.target) === 0) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const block = endpoint.ownerBlock;\n        if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\n          this._processBuild(block, state, endpoint, activeBlocks);\n        }\n      }\n    }\n    return false;\n  }\n  _inputRename(name) {\n    return name;\n  }\n  _outputRename(name) {\n    return name;\n  }\n  _dumpPropertiesCode() {\n    const variableName = this._codeVariableName;\n    return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\r\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\r\\n${variableName}.target = ${this.target};\\r\\n`;\n  }\n  /**\n   * @internal\n   */\n  _dumpCode(uniqueNames, alreadyDumped) {\n    alreadyDumped.push(this);\n    let codeString;\n    // Get unique name\n    const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\n    this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\n    if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\n      let index = 0;\n      do {\n        index++;\n        this._codeVariableName = nameAsVariableName + index;\n      } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\n    }\n    uniqueNames.push(this._codeVariableName);\n    // Declaration\n    codeString = `\\r\\n// ${this.getClassName()}\\r\\n`;\n    if (this.comments) {\n      codeString += `// ${this.comments}\\r\\n`;\n    }\n    codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\r\\n`;\n    // Properties\n    codeString += this._dumpPropertiesCode();\n    // Inputs\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      if (alreadyDumped.indexOf(connectedBlock) === -1) {\n        codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Outputs\n    for (const output of this.outputs) {\n      if (!output.hasEndpoints) {\n        continue;\n      }\n      for (const endpoint of output.endpoints) {\n        const connectedBlock = endpoint.ownerBlock;\n        if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\n          codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\n        }\n      }\n    }\n    return codeString;\n  }\n  /**\n   * @internal\n   */\n  _dumpCodeForOutputConnections(alreadyDumped) {\n    let codeString = \"\";\n    if (alreadyDumped.indexOf(this) !== -1) {\n      return codeString;\n    }\n    alreadyDumped.push(this);\n    for (const input of this.inputs) {\n      if (!input.isConnected) {\n        continue;\n      }\n      const connectedOutput = input.connectedPoint;\n      const connectedBlock = connectedOutput.ownerBlock;\n      codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\n      codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(input.name)});\\r\\n`;\n    }\n    return codeString;\n  }\n  /**\n   * Clone the current block to a new identical block\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a copy of the current block\n   */\n  clone(scene, rootUrl = \"\") {\n    const serializationObject = this.serialize();\n    const blockType = GetClass(serializationObject.customType);\n    if (blockType) {\n      const block = new blockType();\n      block._deserialize(serializationObject, scene, rootUrl);\n      return block;\n    }\n    return null;\n  }\n  /**\n   * Serializes this block in a JSON representation\n   * @returns the serialized block object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.\" + this.getClassName();\n    serializationObject.id = this.uniqueId;\n    serializationObject.name = this.name;\n    serializationObject.comments = this.comments;\n    serializationObject.visibleInInspector = this.visibleInInspector;\n    serializationObject.visibleOnFrame = this.visibleOnFrame;\n    serializationObject.target = this.target;\n    serializationObject.inputs = [];\n    serializationObject.outputs = [];\n    for (const input of this.inputs) {\n      serializationObject.inputs.push(input.serialize());\n    }\n    for (const output of this.outputs) {\n      serializationObject.outputs.push(output.serialize(false));\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _deserialize(serializationObject, scene, rootUrl) {\n    var _a;\n    this.name = serializationObject.name;\n    this.comments = serializationObject.comments;\n    this.visibleInInspector = !!serializationObject.visibleInInspector;\n    this.visibleOnFrame = !!serializationObject.visibleOnFrame;\n    this._target = (_a = serializationObject.target) !== null && _a !== void 0 ? _a : this.target;\n    this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\n  }\n  _deserializePortDisplayNamesAndExposedOnFrame(serializationObject) {\n    const serializedInputs = serializationObject.inputs;\n    const serializedOutputs = serializationObject.outputs;\n    if (serializedInputs) {\n      serializedInputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.inputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.inputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n    if (serializedOutputs) {\n      serializedOutputs.forEach((port, i) => {\n        if (port.displayName) {\n          this.outputs[i].displayName = port.displayName;\n        }\n        if (port.isExposedOnFrame) {\n          this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\n          this.outputs[i].exposedPortPosition = port.exposedPortPosition;\n        }\n      });\n    }\n  }\n  /**\n   * Release resources\n   */\n  dispose() {\n    for (const input of this.inputs) {\n      input.dispose();\n    }\n    for (const output of this.outputs) {\n      output.dispose();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPoint","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","UniqueIdGenerator","GetClass","NodeMaterialBlock","constructor","name","target","Vertex","isFinalMerger","isInput","Array","_target","_originalTargetIsNeutral","Neutral","_isFinalMerger","_isInput","_name","uniqueId","UniqueId","newName","validateBlockName","isUnique","_isUnique","buildId","_buildId","value","inputs","_inputs","outputs","_outputs","getInputByName","filter","e","length","getOutputByName","_setInitialTarget","initialize","state","bind","effect","nodeMaterial","mesh","subMesh","_declareOutput","output","_getGLType","type","associatedVariableName","_writeVariable","currentPoint","connectionPoint","connectedPoint","_writeFloat","stringVersion","toString","indexOf","getClassName","registerInput","isOptional","point","Input","push","registerOutput","Output","getFirstAvailableInput","forOutput","input","AutoDetect","getFirstAvailableOutput","forBlock","getSiblingOutput","current","index","isAnAncestorOf","block","hasEndpoints","endpoint","endpoints","ownerBlock","connectTo","other","options","notFound","canConnectTo","_buildBlock","updateUniformsAndSamples","defines","uniformBuffers","provideFallbacks","fallbacks","initializeDefines","useInstances","prepareDefines","autoConfigure","material","replaceRepeatableContent","vertexShaderState","fragmentShaderState","willBeGeneratedIntoVertexShaderFromFragmentShader","some","o","isDirectlyConnectedToVertexOutput","VertexAndFragment","isConnectedInVertexShader","isReady","_linkConnectionTypes","inputIndex0","inputIndex1","looseCoupling","_acceptedConnectionPointType","_linkedConnectionSource","_processBuild","activeBlocks","build","localBlockIsFragment","_vertexState","otherBlockWasGeneratedInVertexShader","_buildTarget","isAttribute","_noContextSwitch","_emitVaryingFromString","compilationString","_enforceAssociatedVariableName","reservedNames","reservedName","sharedData","_getFreeVariableName","checks","notConnectedNonOptionalInputs","verbose","console","log","emitVertex","Fragment","emitFragment","emitComments","_inputRename","_outputRename","_dumpPropertiesCode","variableName","_codeVariableName","visibleInInspector","visibleOnFrame","_dumpCode","uniqueNames","alreadyDumped","codeString","nameAsVariableName","replace","comments","isConnected","connectedOutput","connectedBlock","_dumpCodeForOutputConnections","clone","scene","rootUrl","serializationObject","serialize","blockType","customType","_deserialize","id","_deserializePortDisplayNamesAndExposedOnFrame","serializedInputs","serializedOutputs","forEach","port","i","displayName","isExposedOnFrame","exposedPortPosition","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Node/nodeMaterialBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"./Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { NodeMaterialConnectionPoint, NodeMaterialConnectionPointDirection } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport type { Effect } from \"../effect\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"./nodeMaterial\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { UniqueIdGenerator } from \"../../Misc/uniqueIdGenerator\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { GetClass } from \"../../Misc/typeStore\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\n\r\n/**\r\n * Defines a block that can be used inside a node based material\r\n */\r\nexport class NodeMaterialBlock {\r\n    private _buildId: number;\r\n    private _buildTarget: NodeMaterialBlockTargets;\r\n    protected _target: NodeMaterialBlockTargets;\r\n    private _isFinalMerger = false;\r\n    private _isInput = false;\r\n    private _name = \"\";\r\n    protected _isUnique = false;\r\n\r\n    /** Gets or sets a boolean indicating that only one input can be connected at a time */\r\n    public inputsAreExclusive = false;\r\n\r\n    /** @internal */\r\n    public _codeVariableName = \"\";\r\n\r\n    /** @internal */\r\n    public _inputs = new Array<NodeMaterialConnectionPoint>();\r\n    /** @internal */\r\n    public _outputs = new Array<NodeMaterialConnectionPoint>();\r\n\r\n    /** @internal */\r\n    public _preparationId: number;\r\n\r\n    /** @internal */\r\n    public readonly _originalTargetIsNeutral: boolean;\r\n\r\n    /**\r\n     * Gets the name of the block\r\n     */\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Sets the name of the block. Will check if the name is valid.\r\n     */\r\n    public set name(newName: string) {\r\n        if (!this.validateBlockName(newName)) {\r\n            return;\r\n        }\r\n\r\n        this._name = newName;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets or sets the comments associated with this block\r\n     */\r\n    public comments: string = \"\";\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block can only be used once per NodeMaterial\r\n     */\r\n    public get isUnique() {\r\n        return this._isUnique;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an end block (e.g. it is generating a system value)\r\n     */\r\n    public get isFinalMerger(): boolean {\r\n        return this._isFinalMerger;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is an input (e.g. it sends data to the shader)\r\n     */\r\n    public get isInput(): boolean {\r\n        return this._isInput;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the build Id\r\n     */\r\n    public get buildId(): number {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target of the block\r\n     */\r\n    public get target() {\r\n        return this._target;\r\n    }\r\n\r\n    public set target(value: NodeMaterialBlockTargets) {\r\n        if ((this._target & value) !== 0) {\r\n            return;\r\n        }\r\n        this._target = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input points\r\n     */\r\n    public get inputs(): NodeMaterialConnectionPoint[] {\r\n        return this._inputs;\r\n    }\r\n\r\n    /** Gets the list of output points */\r\n    public get outputs(): NodeMaterialConnectionPoint[] {\r\n        return this._outputs;\r\n    }\r\n\r\n    /**\r\n     * Find an input by its name\r\n     * @param name defines the name of the input to look for\r\n     * @returns the input or null if not found\r\n     */\r\n    public getInputByName(name: string) {\r\n        const filter = this._inputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Find an output by its name\r\n     * @param name defines the name of the output to look for\r\n     * @returns the output or null if not found\r\n     */\r\n    public getOutputByName(name: string) {\r\n        const filter = this._outputs.filter((e) => e.name === name);\r\n\r\n        if (filter.length) {\r\n            return filter[0];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited in the Inspector (false by default) */\r\n    public visibleInInspector = false;\r\n\r\n    /** Gets or sets a boolean indicating that this input can be edited from a collapsed frame */\r\n    public visibleOnFrame = false;\r\n\r\n    /**\r\n     * Creates a new NodeMaterialBlock\r\n     * @param name defines the block name\r\n     * @param target defines the target of that block (Vertex by default)\r\n     * @param isFinalMerger defines a boolean indicating that this block is an end block (e.g. it is generating a system value). Default is false\r\n     * @param isInput defines a boolean indicating that this block is an input (e.g. it sends data to the shader). Default is false\r\n     */\r\n    public constructor(name: string, target = NodeMaterialBlockTargets.Vertex, isFinalMerger = false, isInput = false) {\r\n        this._target = target;\r\n        this._originalTargetIsNeutral = target === NodeMaterialBlockTargets.Neutral;\r\n        this._isFinalMerger = isFinalMerger;\r\n        this._isInput = isInput;\r\n        this._name = name;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n    }\r\n\r\n    /** @internal */\r\n    public _setInitialTarget(target: NodeMaterialBlockTargets): void {\r\n        this._target = target;\r\n        (this._originalTargetIsNeutral as boolean) = target === NodeMaterialBlockTargets.Neutral;\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Bind data to effect. Will only be called for blocks with isBindable === true\r\n     * @param effect defines the effect to bind data to\r\n     * @param nodeMaterial defines the hosting NodeMaterial\r\n     * @param mesh defines the mesh that will be rendered\r\n     * @param subMesh defines the submesh that will be rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    protected _declareOutput(output: NodeMaterialConnectionPoint, state: NodeMaterialBuildState): string {\r\n        return `${state._getGLType(output.type)} ${output.associatedVariableName}`;\r\n    }\r\n\r\n    protected _writeVariable(currentPoint: NodeMaterialConnectionPoint): string {\r\n        const connectionPoint = currentPoint.connectedPoint;\r\n\r\n        if (connectionPoint) {\r\n            return `${currentPoint.associatedVariableName}`;\r\n        }\r\n\r\n        return `0.`;\r\n    }\r\n\r\n    protected _writeFloat(value: number) {\r\n        let stringVersion = value.toString();\r\n\r\n        if (stringVersion.indexOf(\".\") === -1) {\r\n            stringVersion += \".0\";\r\n        }\r\n        return `${stringVersion}`;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name e.g. \"NodeMaterialBlock\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"NodeMaterialBlock\";\r\n    }\r\n\r\n    /**\r\n     * Register a new input. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param isOptional defines a boolean indicating that this input can be omitted\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerInput(\r\n        name: string,\r\n        type: NodeMaterialBlockConnectionPointTypes,\r\n        isOptional: boolean = false,\r\n        target?: NodeMaterialBlockTargets,\r\n        point?: NodeMaterialConnectionPoint\r\n    ) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Input);\r\n        point.type = type;\r\n        point.isOptional = isOptional;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._inputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Register a new output. Must be called inside a block constructor\r\n     * @param name defines the connection point name\r\n     * @param type defines the connection point type\r\n     * @param target defines the target to use to limit the connection point (will be VertexAndFragment by default)\r\n     * @param point an already created connection point. If not provided, create a new one\r\n     * @returns the current block\r\n     */\r\n    public registerOutput(name: string, type: NodeMaterialBlockConnectionPointTypes, target?: NodeMaterialBlockTargets, point?: NodeMaterialConnectionPoint) {\r\n        point = point ?? new NodeMaterialConnectionPoint(name, this, NodeMaterialConnectionPointDirection.Output);\r\n        point.type = type;\r\n        if (target) {\r\n            point.target = target;\r\n        }\r\n\r\n        this._outputs.push(point);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available input e.g. the first one which is not an uniform or an attribute\r\n     * @param forOutput defines an optional connection point to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableInput(forOutput: Nullable<NodeMaterialConnectionPoint> = null) {\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!forOutput || forOutput.type === input.type || input.type === NodeMaterialBlockConnectionPointTypes.AutoDetect) {\r\n                    return input;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Will return the first available output e.g. the first one which is not yet connected and not a varying\r\n     * @param forBlock defines an optional block to check compatibility with\r\n     * @returns the first available input or null\r\n     */\r\n    public getFirstAvailableOutput(forBlock: Nullable<NodeMaterialBlock> = null) {\r\n        for (const output of this._outputs) {\r\n            if (!forBlock || !forBlock.target || forBlock.target === NodeMaterialBlockTargets.Neutral || (forBlock.target & output.target) !== 0) {\r\n                return output;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sibling of the given output\r\n     * @param current defines the current output\r\n     * @returns the next output in the list or null\r\n     */\r\n    public getSiblingOutput(current: NodeMaterialConnectionPoint) {\r\n        const index = this._outputs.indexOf(current);\r\n\r\n        if (index === -1 || index >= this._outputs.length) {\r\n            return null;\r\n        }\r\n\r\n        return this._outputs[index + 1];\r\n    }\r\n\r\n    /**\r\n     * Checks if the current block is an ancestor of a given block\r\n     * @param block defines the potential descendant block to check\r\n     * @returns true if block is a descendant\r\n     */\r\n    public isAnAncestorOf(block: NodeMaterialBlock): boolean {\r\n        for (const output of this._outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                if (endpoint.ownerBlock === block) {\r\n                    return true;\r\n                }\r\n                if (endpoint.ownerBlock.isAnAncestorOf(block)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Connect current block with another block\r\n     * @param other defines the block to connect with\r\n     * @param options define the various options to help pick the right connections\r\n     * @param options.input\r\n     * @param options.output\r\n     * @param options.outputSwizzle\r\n     * @returns the current block\r\n     */\r\n    public connectTo(\r\n        other: NodeMaterialBlock,\r\n        options?: {\r\n            input?: string;\r\n            output?: string;\r\n            outputSwizzle?: string;\r\n        }\r\n    ) {\r\n        if (this._outputs.length === 0) {\r\n            return;\r\n        }\r\n\r\n        let output = options && options.output ? this.getOutputByName(options.output) : this.getFirstAvailableOutput(other);\r\n\r\n        let notFound = true;\r\n        while (notFound) {\r\n            const input = options && options.input ? other.getInputByName(options.input) : other.getFirstAvailableInput(output);\r\n\r\n            if (output && input && output.canConnectTo(input)) {\r\n                output.connectTo(input);\r\n                notFound = false;\r\n            } else if (!output) {\r\n                throw \"Unable to find a compatible match\";\r\n            } else {\r\n                output = this.getSiblingOutput(output);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        // Empty. Must be defined by child nodes\r\n    }\r\n\r\n    /**\r\n     * Add uniforms, samplers and uniform buffers at compilation time\r\n     * @param state defines the state to update\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param uniformBuffers defines the list of uniform buffer names\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Add potential fallbacks if shader compilation fails\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param fallbacks defines the current prioritized list of fallbacks\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public provideFallbacks(mesh: AbstractMesh, fallbacks: EffectFallbacks) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Initialize defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public initializeDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {}\r\n\r\n    /**\r\n     * Update defines for shader compilation\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @param subMesh defines which submesh to render\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false, subMesh?: SubMesh) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Lets the block try to connect some inputs automatically\r\n     * @param material defines the hosting NodeMaterial\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public autoConfigure(material: NodeMaterial) {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Function called when a block is declared as repeatable content generator\r\n     * @param vertexShaderState defines the current compilation state for the vertex shader\r\n     * @param fragmentShaderState defines the current compilation state for the fragment shader\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param defines defines the material defines to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        // Do nothing\r\n    }\r\n\r\n    /** Gets a boolean indicating that the code of this block will be promoted to vertex shader even if connected to fragment output */\r\n    public get willBeGeneratedIntoVertexShaderFromFragmentShader(): boolean {\r\n        if (this.isInput || this.isFinalMerger) {\r\n            return false;\r\n        }\r\n\r\n        if (this._outputs.some((o) => o.isDirectlyConnectedToVertexOutput)) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.Vertex) {\r\n            return false;\r\n        }\r\n\r\n        if (this.target === NodeMaterialBlockTargets.VertexAndFragment || this.target === NodeMaterialBlockTargets.Neutral) {\r\n            if (this._outputs.some((o) => o.isConnectedInVertexShader)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the block is ready\r\n     * @param mesh defines the mesh to be rendered\r\n     * @param nodeMaterial defines the node material requesting the update\r\n     * @param defines defines the material defines to update\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns true if the block is ready\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReady(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, useInstances: boolean = false) {\r\n        return true;\r\n    }\r\n\r\n    protected _linkConnectionTypes(inputIndex0: number, inputIndex1: number, looseCoupling = false) {\r\n        if (looseCoupling) {\r\n            this._inputs[inputIndex1]._acceptedConnectionPointType = this._inputs[inputIndex0];\r\n        } else {\r\n            this._inputs[inputIndex0]._linkedConnectionSource = this._inputs[inputIndex1];\r\n        }\r\n        this._inputs[inputIndex1]._linkedConnectionSource = this._inputs[inputIndex0];\r\n    }\r\n\r\n    private _processBuild(block: NodeMaterialBlock, state: NodeMaterialBuildState, input: NodeMaterialConnectionPoint, activeBlocks: NodeMaterialBlock[]) {\r\n        block.build(state, activeBlocks);\r\n\r\n        const localBlockIsFragment = state._vertexState != null;\r\n        const otherBlockWasGeneratedInVertexShader = block._buildTarget === NodeMaterialBlockTargets.Vertex && block.target !== NodeMaterialBlockTargets.VertexAndFragment;\r\n\r\n        if (\r\n            localBlockIsFragment &&\r\n            ((block.target & block._buildTarget) === 0 ||\r\n                (block.target & input.target) === 0 ||\r\n                (this.target !== NodeMaterialBlockTargets.VertexAndFragment && otherBlockWasGeneratedInVertexShader))\r\n        ) {\r\n            // context switch! We need a varying\r\n            if (\r\n                (!block.isInput && state.target !== block._buildTarget) || // block was already emitted by vertex shader\r\n                (block.isInput && (block as InputBlock).isAttribute && !(block as InputBlock)._noContextSwitch) // block is an attribute\r\n            ) {\r\n                const connectedPoint = input.connectedPoint!;\r\n                if (state._vertexState._emitVaryingFromString(\"v_\" + connectedPoint.associatedVariableName, state._getGLType(connectedPoint.type))) {\r\n                    state._vertexState.compilationString += `${\"v_\" + connectedPoint.associatedVariableName} = ${connectedPoint.associatedVariableName};\\r\\n`;\r\n                }\r\n                input.associatedVariableName = \"v_\" + connectedPoint.associatedVariableName;\r\n                input._enforceAssociatedVariableName = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validates the new name for the block node.\r\n     * @param newName the new name to be given to the node.\r\n     * @returns false if the name is a reserve word, else true.\r\n     */\r\n    public validateBlockName(newName: string) {\r\n        const reservedNames: Array<string> = [\r\n            \"position\",\r\n            \"normal\",\r\n            \"tangent\",\r\n            \"particle_positionw\",\r\n            \"uv\",\r\n            \"uv2\",\r\n            \"uv3\",\r\n            \"uv4\",\r\n            \"uv5\",\r\n            \"uv6\",\r\n            \"position2d\",\r\n            \"particle_uv\",\r\n            \"matricesIndices\",\r\n            \"matricesWeights\",\r\n            \"world0\",\r\n            \"world1\",\r\n            \"world2\",\r\n            \"world3\",\r\n            \"particle_color\",\r\n            \"particle_texturemask\",\r\n        ];\r\n        for (const reservedName of reservedNames) {\r\n            if (newName === reservedName) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Compile the current node and generate the shader code\r\n     * @param state defines the current compilation state (uniforms, samplers, current string)\r\n     * @param activeBlocks defines the list of active blocks (i.e. blocks to compile)\r\n     * @returns true if already built\r\n     */\r\n    public build(state: NodeMaterialBuildState, activeBlocks: NodeMaterialBlock[]): boolean {\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true;\r\n        }\r\n\r\n        if (!this.isInput) {\r\n            /** Prepare outputs */\r\n            for (const output of this._outputs) {\r\n                if (!output.associatedVariableName) {\r\n                    output.associatedVariableName = state._getFreeVariableName(output.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if \"parent\" blocks are compiled\r\n        for (const input of this._inputs) {\r\n            if (!input.connectedPoint) {\r\n                if (!input.isOptional) {\r\n                    // Emit a warning\r\n                    state.sharedData.checks.notConnectedNonOptionalInputs.push(input);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (this.target !== NodeMaterialBlockTargets.Neutral) {\r\n                if ((input.target & this.target!) === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if ((input.target & state.target!) === 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const block = input.connectedPoint.ownerBlock;\r\n            if (block && block !== this) {\r\n                this._processBuild(block, state, input, activeBlocks);\r\n            }\r\n        }\r\n\r\n        if (this._buildId === state.sharedData.buildId) {\r\n            return true; // Need to check again as inputs can be connected multiple time to this endpoint\r\n        }\r\n\r\n        // Logs\r\n        if (state.sharedData.verbose) {\r\n            console.log(`${state.target === NodeMaterialBlockTargets.Vertex ? \"Vertex shader\" : \"Fragment shader\"}: Building ${this.name} [${this.getClassName()}]`);\r\n        }\r\n\r\n        // Checks final outputs\r\n        if (this.isFinalMerger) {\r\n            switch (state.target) {\r\n                case NodeMaterialBlockTargets.Vertex:\r\n                    state.sharedData.checks.emitVertex = true;\r\n                    break;\r\n                case NodeMaterialBlockTargets.Fragment:\r\n                    state.sharedData.checks.emitFragment = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (!this.isInput && state.sharedData.emitComments) {\r\n            state.compilationString += `\\r\\n//${this.name}\\r\\n`;\r\n        }\r\n\r\n        this._buildBlock(state);\r\n\r\n        this._buildId = state.sharedData.buildId;\r\n        this._buildTarget = state.target;\r\n\r\n        // Compile connected blocks\r\n        for (const output of this._outputs) {\r\n            if ((output.target & state.target) === 0) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const block = endpoint.ownerBlock;\r\n\r\n                if (block && (block.target & state.target) !== 0 && activeBlocks.indexOf(block) !== -1) {\r\n                    this._processBuild(block, state, endpoint, activeBlocks);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected _inputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _outputRename(name: string) {\r\n        return name;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        const variableName = this._codeVariableName;\r\n        return `${variableName}.visibleInInspector = ${this.visibleInInspector};\\r\\n${variableName}.visibleOnFrame = ${this.visibleOnFrame};\\r\\n${variableName}.target = ${this.target};\\r\\n`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCode(uniqueNames: string[], alreadyDumped: NodeMaterialBlock[]) {\r\n        alreadyDumped.push(this);\r\n\r\n        let codeString: string;\r\n\r\n        // Get unique name\r\n        const nameAsVariableName = this.name.replace(/[^A-Za-z_]+/g, \"\");\r\n        this._codeVariableName = nameAsVariableName || `${this.getClassName()}_${this.uniqueId}`;\r\n\r\n        if (uniqueNames.indexOf(this._codeVariableName) !== -1) {\r\n            let index = 0;\r\n            do {\r\n                index++;\r\n                this._codeVariableName = nameAsVariableName + index;\r\n            } while (uniqueNames.indexOf(this._codeVariableName) !== -1);\r\n        }\r\n\r\n        uniqueNames.push(this._codeVariableName);\r\n\r\n        // Declaration\r\n        codeString = `\\r\\n// ${this.getClassName()}\\r\\n`;\r\n        if (this.comments) {\r\n            codeString += `// ${this.comments}\\r\\n`;\r\n        }\r\n        codeString += `var ${this._codeVariableName} = new BABYLON.${this.getClassName()}(\"${this.name}\");\\r\\n`;\r\n\r\n        // Properties\r\n        codeString += this._dumpPropertiesCode();\r\n\r\n        // Inputs\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            if (alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Outputs\r\n        for (const output of this.outputs) {\r\n            if (!output.hasEndpoints) {\r\n                continue;\r\n            }\r\n\r\n            for (const endpoint of output.endpoints) {\r\n                const connectedBlock = endpoint.ownerBlock;\r\n                if (connectedBlock && alreadyDumped.indexOf(connectedBlock) === -1) {\r\n                    codeString += connectedBlock._dumpCode(uniqueNames, alreadyDumped);\r\n                }\r\n            }\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _dumpCodeForOutputConnections(alreadyDumped: NodeMaterialBlock[]) {\r\n        let codeString = \"\";\r\n\r\n        if (alreadyDumped.indexOf(this) !== -1) {\r\n            return codeString;\r\n        }\r\n\r\n        alreadyDumped.push(this);\r\n\r\n        for (const input of this.inputs) {\r\n            if (!input.isConnected) {\r\n                continue;\r\n            }\r\n\r\n            const connectedOutput = input.connectedPoint!;\r\n            const connectedBlock = connectedOutput.ownerBlock;\r\n\r\n            codeString += connectedBlock._dumpCodeForOutputConnections(alreadyDumped);\r\n            codeString += `${connectedBlock._codeVariableName}.${connectedBlock._outputRename(connectedOutput.name)}.connectTo(${this._codeVariableName}.${this._inputRename(\r\n                input.name\r\n            )});\\r\\n`;\r\n        }\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Clone the current block to a new identical block\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a copy of the current block\r\n     */\r\n    public clone(scene: Scene, rootUrl: string = \"\") {\r\n        const serializationObject = this.serialize();\r\n\r\n        const blockType = GetClass(serializationObject.customType);\r\n        if (blockType) {\r\n            const block: NodeMaterialBlock = new blockType();\r\n            block._deserialize(serializationObject, scene, rootUrl);\r\n\r\n            return block;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Serializes this block in a JSON representation\r\n     * @returns the serialized block object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.\" + this.getClassName();\r\n        serializationObject.id = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject.comments = this.comments;\r\n        serializationObject.visibleInInspector = this.visibleInInspector;\r\n        serializationObject.visibleOnFrame = this.visibleOnFrame;\r\n        serializationObject.target = this.target;\r\n\r\n        serializationObject.inputs = [];\r\n        serializationObject.outputs = [];\r\n\r\n        for (const input of this.inputs) {\r\n            serializationObject.inputs.push(input.serialize());\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            serializationObject.outputs.push(output.serialize(false));\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        this.name = serializationObject.name;\r\n        this.comments = serializationObject.comments;\r\n        this.visibleInInspector = !!serializationObject.visibleInInspector;\r\n        this.visibleOnFrame = !!serializationObject.visibleOnFrame;\r\n        this._target = serializationObject.target ?? this.target;\r\n        this._deserializePortDisplayNamesAndExposedOnFrame(serializationObject);\r\n    }\r\n\r\n    private _deserializePortDisplayNamesAndExposedOnFrame(serializationObject: any) {\r\n        const serializedInputs = serializationObject.inputs;\r\n        const serializedOutputs = serializationObject.outputs;\r\n        if (serializedInputs) {\r\n            serializedInputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.inputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.inputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.inputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n        if (serializedOutputs) {\r\n            serializedOutputs.forEach((port: any, i: number) => {\r\n                if (port.displayName) {\r\n                    this.outputs[i].displayName = port.displayName;\r\n                }\r\n                if (port.isExposedOnFrame) {\r\n                    this.outputs[i].isExposedOnFrame = port.isExposedOnFrame;\r\n                    this.outputs[i].exposedPortPosition = port.exposedPortPosition;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release resources\r\n     */\r\n    public dispose() {\r\n        for (const input of this.inputs) {\r\n            input.dispose();\r\n        }\r\n\r\n        for (const output of this.outputs) {\r\n            output.dispose();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}