{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n/**\n * Creates the VertexData for a TorusKnot\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n * * radius the radius of the torus knot, optional, default 2\n * * tube the thickness of the tube, optional, default 0.5\n * * radialSegments the number of sides on each tube segments, optional, default 32\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n * * p the number of windings around the z axis, optional,  default 2\n * * q the number of windings around the x axis, optional,  default 3\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @returns the VertexData of the Torus Knot\n */\nexport function CreateTorusKnotVertexData(options) {\n  const indices = new Array();\n  const positions = new Array();\n  const normals = new Array();\n  const uvs = new Array();\n  const radius = options.radius || 2;\n  const tube = options.tube || 0.5;\n  const radialSegments = options.radialSegments || 32;\n  const tubularSegments = options.tubularSegments || 32;\n  const p = options.p || 2;\n  const q = options.q || 3;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  // Helper\n  const getPos = angle => {\n    const cu = Math.cos(angle);\n    const su = Math.sin(angle);\n    const quOverP = q / p * angle;\n    const cs = Math.cos(quOverP);\n    const tx = radius * (2 + cs) * 0.5 * cu;\n    const ty = radius * (2 + cs) * su * 0.5;\n    const tz = radius * Math.sin(quOverP) * 0.5;\n    return new Vector3(tx, ty, tz);\n  };\n  // Vertices\n  let i;\n  let j;\n  for (i = 0; i <= radialSegments; i++) {\n    const modI = i % radialSegments;\n    const u = modI / radialSegments * 2 * p * Math.PI;\n    const p1 = getPos(u);\n    const p2 = getPos(u + 0.01);\n    const tang = p2.subtract(p1);\n    let n = p2.add(p1);\n    const bitan = Vector3.Cross(tang, n);\n    n = Vector3.Cross(bitan, tang);\n    bitan.normalize();\n    n.normalize();\n    for (j = 0; j < tubularSegments; j++) {\n      const modJ = j % tubularSegments;\n      const v = modJ / tubularSegments * 2 * Math.PI;\n      const cx = -tube * Math.cos(v);\n      const cy = tube * Math.sin(v);\n      positions.push(p1.x + cx * n.x + cy * bitan.x);\n      positions.push(p1.y + cx * n.y + cy * bitan.y);\n      positions.push(p1.z + cx * n.z + cy * bitan.z);\n      uvs.push(i / radialSegments);\n      uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\n    }\n  }\n  for (i = 0; i < radialSegments; i++) {\n    for (j = 0; j < tubularSegments; j++) {\n      const jNext = (j + 1) % tubularSegments;\n      const a = i * tubularSegments + j;\n      const b = (i + 1) * tubularSegments + j;\n      const c = (i + 1) * tubularSegments + jNext;\n      const d = i * tubularSegments + jNext;\n      indices.push(d);\n      indices.push(b);\n      indices.push(a);\n      indices.push(d);\n      indices.push(c);\n      indices.push(b);\n    }\n  }\n  // Normals\n  VertexData.ComputeNormals(positions, indices, normals);\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a torus knot mesh\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.radius\n * @param options.tube\n * @param options.radialSegments\n * @param options.tubularSegments\n * @param options.p\n * @param options.q\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param scene defines the hosting scene\n * @returns the torus knot mesh\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\n */\nexport function CreateTorusKnot(name, options = {}, scene) {\n  const torusKnot = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  torusKnot._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateTorusKnotVertexData(options);\n  vertexData.applyToMesh(torusKnot, options.updatable);\n  return torusKnot;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTorusKnot instead\n */\nexport const TorusKnotBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTorusKnot\n};\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\nMesh.CreateTorusKnot = (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) => {\n  const options = {\n    radius,\n    tube,\n    radialSegments,\n    tubularSegments,\n    p,\n    q,\n    sideOrientation,\n    updatable\n  };\n  return CreateTorusKnot(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Mesh","VertexData","CompatibilityOptions","CreateTorusKnotVertexData","options","indices","Array","positions","normals","uvs","radius","tube","radialSegments","tubularSegments","p","q","sideOrientation","DEFAULTSIDE","getPos","angle","cu","Math","cos","su","sin","quOverP","cs","tx","ty","tz","i","j","modI","u","PI","p1","p2","tang","subtract","n","add","bitan","Cross","normalize","modJ","v","cx","cy","push","x","y","z","UseOpenGLOrientationForUV","jNext","a","b","c","d","ComputeNormals","_ComputeSides","frontUVs","backUVs","vertexData","CreateTorusKnot","name","scene","torusKnot","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","TorusKnotBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/torusKnotBuilder.ts"],"sourcesContent":["import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n// based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n/**\r\n * Creates the VertexData for a TorusKnot\r\n * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n * * radius the radius of the torus knot, optional, default 2\r\n * * tube the thickness of the tube, optional, default 0.5\r\n * * radialSegments the number of sides on each tube segments, optional, default 32\r\n * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n * * p the number of windings around the z axis, optional,  default 2\r\n * * q the number of windings around the x axis, optional,  default 3\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @returns the VertexData of the Torus Knot\r\n */\r\nexport function CreateTorusKnotVertexData(options: {\r\n    radius?: number;\r\n    tube?: number;\r\n    radialSegments?: number;\r\n    tubularSegments?: number;\r\n    p?: number;\r\n    q?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n\r\n    const radius = options.radius || 2;\r\n    const tube = options.tube || 0.5;\r\n    const radialSegments = options.radialSegments || 32;\r\n    const tubularSegments = options.tubularSegments || 32;\r\n    const p = options.p || 2;\r\n    const q = options.q || 3;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Helper\r\n    const getPos = (angle: number) => {\r\n        const cu = Math.cos(angle);\r\n        const su = Math.sin(angle);\r\n        const quOverP = (q / p) * angle;\r\n        const cs = Math.cos(quOverP);\r\n\r\n        const tx = radius * (2 + cs) * 0.5 * cu;\r\n        const ty = radius * (2 + cs) * su * 0.5;\r\n        const tz = radius * Math.sin(quOverP) * 0.5;\r\n\r\n        return new Vector3(tx, ty, tz);\r\n    };\r\n\r\n    // Vertices\r\n    let i: number;\r\n    let j: number;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        const modI = i % radialSegments;\r\n        const u = (modI / radialSegments) * 2 * p * Math.PI;\r\n        const p1 = getPos(u);\r\n        const p2 = getPos(u + 0.01);\r\n        const tang = p2.subtract(p1);\r\n        let n = p2.add(p1);\r\n\r\n        const bitan = Vector3.Cross(tang, n);\r\n        n = Vector3.Cross(bitan, tang);\r\n\r\n        bitan.normalize();\r\n        n.normalize();\r\n\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const modJ = j % tubularSegments;\r\n            const v = (modJ / tubularSegments) * 2 * Math.PI;\r\n            const cx = -tube * Math.cos(v);\r\n            const cy = tube * Math.sin(v);\r\n\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - j / tubularSegments : j / tubularSegments);\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            const jNext = (j + 1) % tubularSegments;\r\n            const a = i * tubularSegments + j;\r\n            const b = (i + 1) * tubularSegments + j;\r\n            const c = (i + 1) * tubularSegments + jNext;\r\n            const d = i * tubularSegments + jNext;\r\n\r\n            indices.push(d);\r\n            indices.push(b);\r\n            indices.push(a);\r\n            indices.push(d);\r\n            indices.push(c);\r\n            indices.push(b);\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a torus knot mesh\r\n * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.radius\r\n * @param options.tube\r\n * @param options.radialSegments\r\n * @param options.tubularSegments\r\n * @param options.p\r\n * @param options.q\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param scene defines the hosting scene\r\n * @returns the torus knot mesh\r\n * @see  https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#torus-knot\r\n */\r\nexport function CreateTorusKnot(\r\n    name: string,\r\n    options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    } = {},\r\n    scene?: Scene\r\n): Mesh {\r\n    const torusKnot = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTorusKnotVertexData(options);\r\n\r\n    vertexData.applyToMesh(torusKnot, options.updatable);\r\n\r\n    return torusKnot;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTorusKnot instead\r\n */\r\nexport const TorusKnotBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTorusKnot,\r\n};\r\n\r\nVertexData.CreateTorusKnot = CreateTorusKnotVertexData;\r\n\r\n(Mesh as any).CreateTorusKnot = (\r\n    name: string,\r\n    radius: number,\r\n    tube: number,\r\n    radialSegments: number,\r\n    tubularSegments: number,\r\n    p: number,\r\n    q: number,\r\n    scene?: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number\r\n): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tube,\r\n        radialSegments,\r\n        tubularSegments,\r\n        p,\r\n        q,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTorusKnot(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}