{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { TransformNode } from \"./transformNode.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nMesh._instancedMeshFactory = (name, mesh) => {\n  const instance = new InstancedMesh(name, mesh);\n  if (mesh.instancedBuffers) {\n    instance.instancedBuffers = {};\n    for (const key in mesh.instancedBuffers) {\n      instance.instancedBuffers[key] = mesh.instancedBuffers[key];\n    }\n  }\n  return instance;\n};\n/**\n * Creates an instance based on a source mesh.\n */\nexport class InstancedMesh extends AbstractMesh {\n  constructor(name, source) {\n    super(name, source.getScene());\n    /** @internal */\n    this._indexInSourceMeshInstanceArray = -1;\n    /** @internal */\n    this._distanceToCamera = 0;\n    source.addInstance(this);\n    this._sourceMesh = source;\n    this._unIndexed = source._unIndexed;\n    this.position.copyFrom(source.position);\n    this.rotation.copyFrom(source.rotation);\n    this.scaling.copyFrom(source.scaling);\n    if (source.rotationQuaternion) {\n      this.rotationQuaternion = source.rotationQuaternion.clone();\n    }\n    this.animations = source.animations.slice();\n    for (const range of source.getAnimationRanges()) {\n      if (range != null) {\n        this.createAnimationRange(range.name, range.from, range.to);\n      }\n    }\n    this.infiniteDistance = source.infiniteDistance;\n    this.setPivotMatrix(source.getPivotMatrix());\n    this.refreshBoundingInfo(true, true);\n    this._syncSubMeshes();\n  }\n  /**\n   * Returns the string \"InstancedMesh\".\n   */\n  getClassName() {\n    return \"InstancedMesh\";\n  }\n  /** Gets the list of lights affecting that mesh */\n  get lightSources() {\n    return this._sourceMesh._lightSources;\n  }\n  _resyncLightSources() {\n    // Do nothing as all the work will be done by source mesh\n  }\n  _resyncLightSource() {\n    // Do nothing as all the work will be done by source mesh\n  }\n  _removeLightSource() {\n    // Do nothing as all the work will be done by source mesh\n  }\n  // Methods\n  /**\n   * If the source mesh receives shadows\n   */\n  get receiveShadows() {\n    return this._sourceMesh.receiveShadows;\n  }\n  /**\n   * The material of the source mesh\n   */\n  get material() {\n    return this._sourceMesh.material;\n  }\n  /**\n   * Visibility of the source mesh\n   */\n  get visibility() {\n    return this._sourceMesh.visibility;\n  }\n  /**\n   * Skeleton of the source mesh\n   */\n  get skeleton() {\n    return this._sourceMesh.skeleton;\n  }\n  /**\n   * Rendering ground id of the source mesh\n   */\n  get renderingGroupId() {\n    return this._sourceMesh.renderingGroupId;\n  }\n  set renderingGroupId(value) {\n    if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\n      return;\n    }\n    //no-op with warning\n    Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\n  }\n  /**\n   * Returns the total number of vertices (integer).\n   */\n  getTotalVertices() {\n    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\n  }\n  /**\n   * Returns a positive integer : the total number of indices in this mesh geometry.\n   * @returns the number of indices or zero if the mesh has no geometry.\n   */\n  getTotalIndices() {\n    return this._sourceMesh.getTotalIndices();\n  }\n  /**\n   * The source mesh of the instance\n   */\n  get sourceMesh() {\n    return this._sourceMesh;\n  }\n  /**\n   * Creates a new InstancedMesh object from the mesh model.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\n   * @param name defines the name of the new instance\n   * @returns a new InstancedMesh\n   */\n  createInstance(name) {\n    return this._sourceMesh.createInstance(name);\n  }\n  /**\n   * Is this node ready to be used/rendered\n   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n   * @returns {boolean} is it ready\n   */\n  isReady(completeCheck = false) {\n    return this._sourceMesh.isReady(completeCheck, true);\n  }\n  /**\n   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n   * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\n   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n   * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\n   */\n  getVerticesData(kind, copyWhenShared) {\n    return this._sourceMesh.getVerticesData(kind, copyWhenShared);\n  }\n  /**\n   * Sets the vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n   * The `data` are either a numeric array either a Float32Array.\n   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\n   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n   * Note that a new underlying VertexBuffer object is created each call.\n   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   *\n   * Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   *\n   * Returns the Mesh.\n   * @param kind\n   * @param data\n   * @param updatable\n   * @param stride\n   */\n  setVerticesData(kind, data, updatable, stride) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n    }\n    return this.sourceMesh;\n  }\n  /**\n   * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n   * If the mesh has no geometry, it is simply returned as it is.\n   * The `data` are either a numeric array either a Float32Array.\n   * No new underlying VertexBuffer object is created.\n   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n   *\n   * Possible `kind` values :\n   * - VertexBuffer.PositionKind\n   * - VertexBuffer.UVKind\n   * - VertexBuffer.UV2Kind\n   * - VertexBuffer.UV3Kind\n   * - VertexBuffer.UV4Kind\n   * - VertexBuffer.UV5Kind\n   * - VertexBuffer.UV6Kind\n   * - VertexBuffer.ColorKind\n   * - VertexBuffer.MatricesIndicesKind\n   * - VertexBuffer.MatricesIndicesExtraKind\n   * - VertexBuffer.MatricesWeightsKind\n   * - VertexBuffer.MatricesWeightsExtraKind\n   *\n   * Returns the Mesh.\n   * @param kind\n   * @param data\n   * @param updateExtends\n   * @param makeItUnique\n   */\n  updateVerticesData(kind, data, updateExtends, makeItUnique) {\n    if (this.sourceMesh) {\n      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n    }\n    return this.sourceMesh;\n  }\n  /**\n   * Sets the mesh indices.\n   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n   * This method creates a new index buffer each call.\n   * Returns the Mesh.\n   * @param indices\n   * @param totalVertices\n   */\n  setIndices(indices, totalVertices = null) {\n    if (this.sourceMesh) {\n      this.sourceMesh.setIndices(indices, totalVertices);\n    }\n    return this.sourceMesh;\n  }\n  /**\n   * Boolean : True if the mesh owns the requested kind of data.\n   * @param kind\n   */\n  isVerticesDataPresent(kind) {\n    return this._sourceMesh.isVerticesDataPresent(kind);\n  }\n  /**\n   * Returns an array of indices (IndicesArray).\n   */\n  getIndices() {\n    return this._sourceMesh.getIndices();\n  }\n  get _positions() {\n    return this._sourceMesh._positions;\n  }\n  /**\n   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n   * This means the mesh underlying bounding box and sphere are recomputed.\n   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n   * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n   * @returns the current mesh\n   */\n  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {\n    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n      return this;\n    }\n    const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\n    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\n    return this;\n  }\n  /** @internal */\n  _preActivate() {\n    if (this._currentLOD) {\n      this._currentLOD._preActivate();\n    }\n    return this;\n  }\n  /**\n   * @internal\n   */\n  _activate(renderId, intermediateRendering) {\n    super._activate(renderId, intermediateRendering);\n    if (!this._sourceMesh.subMeshes) {\n      Logger.Warn(\"Instances should only be created for meshes with geometry.\");\n    }\n    if (this._currentLOD) {\n      const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\n      if (differentSign) {\n        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\n        return true;\n      }\n      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\n      this._currentLOD._registerInstanceForRenderId(this, renderId);\n      if (intermediateRendering) {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\n          return true;\n        }\n      } else {\n        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\n          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** @internal */\n  _postActivate() {\n    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer of the source mesh\n      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\n      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\n    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\n      // we are using the edge renderer defined for this instance\n      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\n    }\n  }\n  getWorldMatrix() {\n    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\n      if (!this._billboardWorldMatrix) {\n        this._billboardWorldMatrix = new Matrix();\n      }\n      const tempMaster = this._currentLOD._masterMesh;\n      this._currentLOD._masterMesh = this;\n      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\n      this._currentLOD.position.set(0, 0, 0);\n      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\n      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\n      this._currentLOD._masterMesh = tempMaster;\n      return this._billboardWorldMatrix;\n    }\n    return super.getWorldMatrix();\n  }\n  get isAnInstance() {\n    return true;\n  }\n  /**\n   * Returns the current associated LOD AbstractMesh.\n   * @param camera\n   */\n  getLOD(camera) {\n    if (!camera) {\n      return this;\n    }\n    const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\n    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\n      this._currentLOD = this.sourceMesh;\n    } else {\n      const boundingInfo = this.getBoundingInfo();\n      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\n    }\n    return this._currentLOD;\n  }\n  /**\n   * @internal\n   */\n  _preActivateForIntermediateRendering(renderId) {\n    return this.sourceMesh._preActivateForIntermediateRendering(renderId);\n  }\n  /** @internal */\n  _syncSubMeshes() {\n    this.releaseSubMeshes();\n    if (this._sourceMesh.subMeshes) {\n      for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n      }\n    }\n    return this;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    return this._sourceMesh._generatePointsArray();\n  }\n  /** @internal */\n  _updateBoundingInfo() {\n    if (this.hasBoundingInfo) {\n      this.getBoundingInfo().update(this.worldMatrixFromCache);\n    } else {\n      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\n    }\n    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n    return this;\n  }\n  /**\n   * Creates a new InstancedMesh from the current mesh.\n   *\n   * Returns the clone.\n   * @param name the cloned mesh name\n   * @param newParent the optional Node to parent the clone to.\n   * @param doNotCloneChildren if `true` the model children aren't cloned.\n   * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\n   * @returns the clone\n   */\n  clone(name, newParent = null, doNotCloneChildren, newSourceMesh) {\n    const result = (newSourceMesh || this._sourceMesh).createInstance(name);\n    // Deep copy\n    DeepCopier.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\", \"parent\", \"lightSources\", \"receiveShadows\", \"material\", \"visibility\", \"skeleton\", \"sourceMesh\", \"isAnInstance\", \"facetNb\", \"isFacetDataEnabled\", \"isBlocked\", \"useBones\", \"hasInstances\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"hasBoundingInfo\"], []);\n    // Bounding info\n    this.refreshBoundingInfo();\n    // Parent\n    if (newParent) {\n      result.parent = newParent;\n    }\n    if (!doNotCloneChildren) {\n      // Children\n      for (let index = 0; index < this.getScene().meshes.length; index++) {\n        const mesh = this.getScene().meshes[index];\n        if (mesh.parent === this) {\n          mesh.clone(mesh.name, result);\n        }\n      }\n    }\n    result.computeWorldMatrix(true);\n    this.onClonedObservable.notifyObservers(result);\n    return result;\n  }\n  /**\n   * Disposes the InstancedMesh.\n   * Returns nothing.\n   * @param doNotRecurse\n   * @param disposeMaterialAndTextures\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    // Remove from mesh\n    this._sourceMesh.removeInstance(this);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   * @internal\n   */\n  _serializeAsParent(serializationObject) {\n    super._serializeAsParent(serializationObject);\n    serializationObject.parentId = this._sourceMesh.uniqueId;\n    serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\n  }\n  /**\n   * Instantiate (when possible) or clone that node with its hierarchy\n   * @param newParent defines the new parent to use for the instance (or clone)\n   * @param options defines options to configure how copy is done\n   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\n   * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\n   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\n   * @returns an instance (or a clone) of the current node with its hierarchy\n   */\n  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {\n    const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\n    if (clone) {\n      if (onNewNodeCreated) {\n        onNewNodeCreated(this, clone);\n      }\n    }\n    for (const child of this.getChildTransformNodes(true)) {\n      child.instantiateHierarchy(clone, options, onNewNodeCreated);\n    }\n    return clone;\n  }\n}\nMesh.prototype.registerInstancedBuffer = function (kind, stride) {\n  var _a, _b;\n  // Remove existing one\n  (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();\n  // Creates the instancedBuffer field if not present\n  if (!this.instancedBuffers) {\n    this.instancedBuffers = {};\n    for (const instance of this.instances) {\n      instance.instancedBuffers = {};\n    }\n    if (!this._userInstancedBuffersStorage) {\n      this._userInstancedBuffersStorage = {\n        data: {},\n        vertexBuffers: {},\n        strides: {},\n        sizes: {},\n        vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n      };\n    }\n  }\n  // Creates an empty property for this kind\n  this.instancedBuffers[kind] = null;\n  this._userInstancedBuffersStorage.strides[kind] = stride;\n  this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\n  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\n  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n  for (const instance of this.instances) {\n    instance.instancedBuffers[kind] = null;\n  }\n  this._invalidateInstanceVertexArrayObject();\n  this._markSubMeshesAsAttributesDirty();\n};\nMesh.prototype._processInstancedBuffers = function (visibleInstances, renderSelf) {\n  const instanceCount = visibleInstances ? visibleInstances.length : 0;\n  for (const kind in this.instancedBuffers) {\n    let size = this._userInstancedBuffersStorage.sizes[kind];\n    const stride = this._userInstancedBuffersStorage.strides[kind];\n    // Resize if required\n    const expectedSize = (instanceCount + 1) * stride;\n    while (size < expectedSize) {\n      size *= 2;\n    }\n    if (this._userInstancedBuffersStorage.data[kind].length != size) {\n      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\n      this._userInstancedBuffersStorage.sizes[kind] = size;\n      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n      }\n    }\n    const data = this._userInstancedBuffersStorage.data[kind];\n    // Update data buffer\n    let offset = 0;\n    if (renderSelf) {\n      const value = this.instancedBuffers[kind];\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else if (value.copyToArray) {\n        value.copyToArray(data, offset);\n      } else {\n        data[offset] = value;\n      }\n      offset += stride;\n    }\n    for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\n      const instance = visibleInstances[instanceIndex];\n      const value = instance.instancedBuffers[kind];\n      if (value.toArray) {\n        value.toArray(data, offset);\n      } else if (value.copyToArray) {\n        value.copyToArray(data, offset);\n      } else {\n        data[offset] = value;\n      }\n      offset += stride;\n    }\n    // Update vertex buffer\n    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\n      this._invalidateInstanceVertexArrayObject();\n    } else {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);\n    }\n  }\n};\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\n  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\n    return;\n  }\n  for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\n    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\n  }\n  this._userInstancedBuffersStorage.vertexArrayObjects = {};\n};\nMesh.prototype._disposeInstanceSpecificData = function () {\n  if (this._instanceDataStorage.instancesBuffer) {\n    this._instanceDataStorage.instancesBuffer.dispose();\n    this._instanceDataStorage.instancesBuffer = null;\n  }\n  while (this.instances.length) {\n    this.instances[0].dispose();\n  }\n  for (const kind in this.instancedBuffers) {\n    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\n      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();\n    }\n  }\n  this._invalidateInstanceVertexArrayObject();\n  this.instancedBuffers = {};\n};","map":{"version":3,"mappings":"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","names":["Matrix","TmpVectors","Logger","AbstractMesh","Mesh","DeepCopier","TransformNode","VertexBuffer","_instancedMeshFactory","name","mesh","instance","InstancedMesh","instancedBuffers","key","constructor","source","getScene","addInstance","_sourceMesh","_unIndexed","position","copyFrom","rotation","scaling","rotationQuaternion","clone","animations","slice","range","getAnimationRanges","createAnimationRange","from","to","infiniteDistance","setPivotMatrix","getPivotMatrix","refreshBoundingInfo","_syncSubMeshes","getClassName","lightSources","_lightSources","_resyncLightSources","_resyncLightSource","_removeLightSource","receiveShadows","material","visibility","skeleton","renderingGroupId","value","Warn","getTotalVertices","getTotalIndices","sourceMesh","createInstance","isReady","completeCheck","getVerticesData","kind","copyWhenShared","setVerticesData","data","updatable","stride","updateVerticesData","updateExtends","makeItUnique","setIndices","indices","totalVertices","isVerticesDataPresent","getIndices","_positions","applySkeleton","applyMorph","hasBoundingInfo","getBoundingInfo","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","_preActivate","_currentLOD","_activate","renderId","intermediateRendering","subMeshes","differentSign","_getWorldMatrixDeterminant","_internalAbstractMeshDataInfo","_actAsRegularMesh","_registerInstanceForRenderId","_isActiveIntermediate","_onlyForInstancesIntermediate","_isActive","_onlyForInstances","_postActivate","edgesShareWithInstances","_edgesRenderer","isEnabled","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","push","getWorldMatrix","billboardMode","BILLBOARDMODE_NONE","_masterMesh","_billboardWorldMatrix","tempMaster","Vector3","set","computeWorldMatrix","isAnInstance","getLOD","camera","sourceMeshLODLevels","getLODLevels","length","boundingInfo","boundingSphere","_preActivateForIntermediateRendering","releaseSubMeshes","index","_generatePointsArray","_updateBoundingInfo","update","worldMatrixFromCache","buildBoundingInfo","absolutePosition","_updateSubMeshesBoundingInfo","newParent","doNotCloneChildren","newSourceMesh","result","DeepCopy","parent","meshes","onClonedObservable","notifyObservers","dispose","doNotRecurse","disposeMaterialAndTextures","removeInstance","_serializeAsParent","serializationObject","parentId","uniqueId","parentInstanceIndex","_indexInSourceMeshInstanceArray","instantiateHierarchy","options","onNewNodeCreated","id","newSourcedMesh","child","getChildTransformNodes","prototype","registerInstancedBuffer","_userInstancedBuffersStorage","vertexBuffers","instances","strides","sizes","vertexArrayObjects","getEngine","getCaps","vertexArrayObject","undefined","Float32Array","_invalidateInstanceVertexArrayObject","_markSubMeshesAsAttributesDirty","_processInstancedBuffers","visibleInstances","renderSelf","instanceCount","size","expectedSize","offset","toArray","copyToArray","instanceIndex","updateDirectly","releaseVertexArrayObject","_disposeInstanceSpecificData","_instanceDataStorage","instancesBuffer"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/instancedMesh.ts"],"sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updatable\r\n     * @param stride\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind\r\n     * @param data\r\n     * @param updateExtends\r\n     * @param makeItUnique\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices\r\n     * @param totalVertices\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse\r\n     * @param disposeMaterialAndTextures\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n\r\n        if (!this._userInstancedBuffersStorage) {\r\n            this._userInstancedBuffersStorage = {\r\n                data: {},\r\n                vertexBuffers: {},\r\n                strides: {},\r\n                sizes: {},\r\n                vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n            };\r\n        }\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}