{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport \"../../Engines/Extensions/engine.multiRender.js\";\n/**\n * A multi render target, like a render target provides the ability to render to a texture.\n * Unlike the render target, it can render to several draw buffers in one draw.\n * This is specially interesting in deferred rendering or for any effects requiring more than\n * just one color from a single pass.\n */\nexport class MultiRenderTarget extends RenderTargetTexture {\n  /**\n   * Instantiate a new multi render target texture.\n   * A multi render target, like a render target provides the ability to render to a texture.\n   * Unlike the render target, it can render to several draw buffers in one draw.\n   * This is specially interesting in deferred rendering or for any effects requiring more than\n   * just one color from a single pass.\n   * @param name Define the name of the texture\n   * @param size Define the size of the buffers to render to\n   * @param count Define the number of target we are rendering into\n   * @param scene Define the scene the texture belongs to\n   * @param options Define the options used to create the multi render target\n   * @param textureNames Define the names to set to the textures (if count > 0 - optional)\n   */\n  constructor(name, size, count, scene, options, textureNames) {\n    const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\n    const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\n    const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : 15;\n    const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n    const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\n    super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\n    if (!this.isSupported) {\n      this.dispose();\n      return;\n    }\n    const types = [];\n    const samplingModes = [];\n    const useSRGBBuffers = [];\n    this._initTypes(count, types, samplingModes, useSRGBBuffers, options);\n    const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    this._size = size;\n    this._multiRenderTargetOptions = {\n      samplingModes: samplingModes,\n      generateMipMaps: generateMipMaps,\n      generateDepthBuffer: generateDepthBuffer,\n      generateStencilBuffer: generateStencilBuffer,\n      generateDepthTexture: generateDepthTexture,\n      depthTextureFormat: depthTextureFormat,\n      types: types,\n      textureCount: count,\n      useSRGBBuffers: useSRGBBuffers\n    };\n    this._count = count;\n    this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\n    if (count > 0) {\n      this._createInternalTextures();\n      this._createTextures(textureNames);\n    }\n  }\n  /**\n   * Get if draw buffers are currently supported by the used hardware and browser.\n   */\n  get isSupported() {\n    var _a, _b;\n    return (_b = (_a = this._engine) === null || _a === void 0 ? void 0 : _a.getCaps().drawBuffersExtension) !== null && _b !== void 0 ? _b : false;\n  }\n  /**\n   * Get the list of textures generated by the multi render target.\n   */\n  get textures() {\n    return this._textures;\n  }\n  /**\n   * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\n   */\n  get count() {\n    return this._count;\n  }\n  /**\n   * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\n   */\n  get depthTexture() {\n    return this._textures[this._textures.length - 1];\n  }\n  /**\n   * Set the wrapping mode on U of all the textures we are rendering to.\n   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n   */\n  set wrapU(wrap) {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i].wrapU = wrap;\n      }\n    }\n  }\n  /**\n   * Set the wrapping mode on V of all the textures we are rendering to.\n   * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\n   */\n  set wrapV(wrap) {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i].wrapV = wrap;\n      }\n    }\n  }\n  _initTypes(count, types, samplingModes, useSRGBBuffers, options) {\n    for (let i = 0; i < count; i++) {\n      if (options && options.types && options.types[i] !== undefined) {\n        types.push(options.types[i]);\n      } else {\n        types.push(options && options.defaultType ? options.defaultType : 0);\n      }\n      if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\n        samplingModes.push(options.samplingModes[i]);\n      } else {\n        samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\n      }\n      if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\n        useSRGBBuffers.push(options.useSRGBBuffers[i]);\n      } else {\n        useSRGBBuffers.push(false);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _rebuild(forceFullRebuild = false, textureNames) {\n    if (this._count < 1) {\n      return;\n    }\n    this.releaseInternalTextures();\n    this._createInternalTextures();\n    if (forceFullRebuild) {\n      this._releaseTextures();\n      this._createTextures(textureNames);\n    }\n    const internalTextures = this._renderTarget.textures;\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = this._textures[i];\n      texture._texture = internalTextures[i];\n    }\n    if (this.samples !== 1) {\n      this._renderTarget.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\n    }\n  }\n  _createInternalTextures() {\n    this._renderTarget = this._getEngine().createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\n    this._texture = this._renderTarget.texture;\n  }\n  _releaseTextures() {\n    if (this._textures) {\n      for (let i = 0; i < this._textures.length; i++) {\n        this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\n        this._textures[i].dispose();\n      }\n    }\n  }\n  _createTextures(textureNames) {\n    const internalTextures = this._renderTarget.textures;\n    this._textures = [];\n    for (let i = 0; i < internalTextures.length; i++) {\n      const texture = new Texture(null, this.getScene());\n      if (textureNames === null || textureNames === void 0 ? void 0 : textureNames[i]) {\n        texture.name = textureNames[i];\n      }\n      texture._texture = internalTextures[i];\n      this._textures.push(texture);\n    }\n  }\n  /**\n   * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\n   * @param texture The new texture to set in the MRT\n   * @param index The index of the texture to replace\n   * @param disposePrevious Set to true if the previous internal texture should be disposed\n   */\n  setInternalTexture(texture, index, disposePrevious = true) {\n    if (!this.renderTarget) {\n      return;\n    }\n    if (index === 0) {\n      this._texture = texture;\n    }\n    this.renderTarget.setTexture(texture, index, disposePrevious);\n    if (!this.textures[index]) {\n      this.textures[index] = new Texture(null, this.getScene());\n    }\n    this.textures[index]._texture = texture;\n    this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\n    if (this._multiRenderTargetOptions.types) {\n      this._multiRenderTargetOptions.types[index] = texture.type;\n    }\n    if (this._multiRenderTargetOptions.samplingModes) {\n      this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\n    }\n    if (this._multiRenderTargetOptions.useSRGBBuffers) {\n      this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\n    }\n  }\n  /**\n   * Define the number of samples used if MSAA is enabled.\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(value) {\n    if (this._renderTarget) {\n      this._samples = this._renderTarget.setSamples(value);\n    } else {\n      // In case samples are set with 0 textures created, we must save the desired samples value\n      this._samples = value;\n    }\n  }\n  /**\n   * Resize all the textures in the multi render target.\n   * Be careful as it will recreate all the data in the new texture.\n   * @param size Define the new size\n   */\n  resize(size) {\n    this._size = size;\n    this._rebuild();\n  }\n  /**\n   * Changes the number of render targets in this MRT\n   * Be careful as it will recreate all the data in the new texture.\n   * @param count new texture count\n   * @param options Specifies texture types and sampling modes for new textures\n   * @param textureNames Specifies the names of the textures (optional)\n   */\n  updateCount(count, options, textureNames) {\n    this._multiRenderTargetOptions.textureCount = count;\n    this._count = count;\n    const types = [];\n    const samplingModes = [];\n    const useSRGBBuffers = [];\n    this._initTypes(count, types, samplingModes, useSRGBBuffers, options);\n    this._multiRenderTargetOptions.types = types;\n    this._multiRenderTargetOptions.samplingModes = samplingModes;\n    this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\n    this._rebuild(true, textureNames);\n  }\n  _unbindFrameBuffer(engine, faceIndex) {\n    if (this._renderTarget) {\n      engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\n        this.onAfterRenderObservable.notifyObservers(faceIndex);\n      });\n    }\n  }\n  /**\n   * Dispose the render targets and their associated resources\n   * @param doNotDisposeInternalTextures\n   */\n  dispose(doNotDisposeInternalTextures = false) {\n    this._releaseTextures();\n    if (!doNotDisposeInternalTextures) {\n      this.releaseInternalTextures();\n    } else {\n      // Prevent internal texture dispose in super.dispose\n      this._texture = null;\n    }\n    super.dispose();\n  }\n  /**\n   * Release all the underlying texture used as draw buffers.\n   */\n  releaseInternalTextures() {\n    var _a, _b;\n    const internalTextures = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.textures;\n    if (!internalTextures) {\n      return;\n    }\n    for (let i = internalTextures.length - 1; i >= 0; i--) {\n      this._textures[i]._texture = null;\n    }\n    (_b = this._renderTarget) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._renderTarget = null;\n  }\n}","map":{"version":3,"mappings":"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","names":["Texture","RenderTargetTexture","MultiRenderTarget","constructor","name","size","count","scene","options","textureNames","generateMipMaps","generateDepthTexture","depthTextureFormat","doNotChangeAspectRatio","undefined","drawOnlyOnFirstAttachmentByDefault","isSupported","dispose","types","samplingModes","useSRGBBuffers","_initTypes","generateDepthBuffer","generateStencilBuffer","_size","_multiRenderTargetOptions","textureCount","_count","_drawOnlyOnFirstAttachmentByDefault","_createInternalTextures","_createTextures","_engine","getCaps","drawBuffersExtension","textures","_textures","depthTexture","length","wrapU","wrap","i","wrapV","push","defaultType","BILINEAR_SAMPLINGMODE","_rebuild","forceFullRebuild","releaseInternalTextures","_releaseTextures","internalTextures","_renderTarget","texture","_texture","samples","setSamples","_getEngine","createMultipleRenderTarget","getScene","setInternalTexture","index","disposePrevious","renderTarget","setTexture","type","samplingMode","_useSRGBBuffer","_samples","value","resize","updateCount","_unbindFrameBuffer","engine","faceIndex","unBindMultiColorAttachmentFramebuffer","isCube","onAfterRenderObservable","notifyObservers","doNotDisposeInternalTextures"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/multiRenderTarget.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport \"../../Engines/Extensions/engine.multiRender\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\n/**\r\n * Creation options of the multi render target texture.\r\n */\r\nexport interface IMultiRenderTargetOptions {\r\n    /**\r\n     * Define if the texture needs to create mip maps after render.\r\n     */\r\n    generateMipMaps?: boolean;\r\n    /**\r\n     * Define the types of all the draw buffers we want to create\r\n     */\r\n    types?: number[];\r\n    /**\r\n     * Define the sampling modes of all the draw buffers we want to create\r\n     */\r\n    samplingModes?: number[];\r\n    /**\r\n     * Define if sRGB format should be used for each of the draw buffers we want to create\r\n     */\r\n    useSRGBBuffers?: boolean[];\r\n    /**\r\n     * Define if a depth buffer is required\r\n     */\r\n    generateDepthBuffer?: boolean;\r\n    /**\r\n     * Define if a stencil buffer is required\r\n     */\r\n    generateStencilBuffer?: boolean;\r\n    /**\r\n     * Define if a depth texture is required instead of a depth buffer\r\n     */\r\n    generateDepthTexture?: boolean;\r\n    /**\r\n     * Define depth texture format to use\r\n     */\r\n    depthTextureFormat?: number;\r\n    /**\r\n     * Define the number of desired draw buffers\r\n     */\r\n    textureCount?: number;\r\n    /**\r\n     * Define if aspect ratio should be adapted to the texture or stay the scene one\r\n     */\r\n    doNotChangeAspectRatio?: boolean;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    defaultType?: number;\r\n    /**\r\n     * Define the default type of the buffers we are creating\r\n     */\r\n    drawOnlyOnFirstAttachmentByDefault?: boolean;\r\n}\r\n\r\n/**\r\n * A multi render target, like a render target provides the ability to render to a texture.\r\n * Unlike the render target, it can render to several draw buffers in one draw.\r\n * This is specially interesting in deferred rendering or for any effects requiring more than\r\n * just one color from a single pass.\r\n */\r\nexport class MultiRenderTarget extends RenderTargetTexture {\r\n    private _textures: Texture[];\r\n    private _multiRenderTargetOptions: IMultiRenderTargetOptions;\r\n    private _count: number;\r\n    private _drawOnlyOnFirstAttachmentByDefault: boolean;\r\n\r\n    /**\r\n     * Get if draw buffers are currently supported by the used hardware and browser.\r\n     */\r\n    public get isSupported(): boolean {\r\n        return this._engine?.getCaps().drawBuffersExtension ?? false;\r\n    }\r\n\r\n    /**\r\n     * Get the list of textures generated by the multi render target.\r\n     */\r\n    public get textures(): Texture[] {\r\n        return this._textures;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.\r\n     */\r\n    public get count(): number {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set\r\n     */\r\n    public get depthTexture(): Texture {\r\n        return this._textures[this._textures.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on U of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapU(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapU = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the wrapping mode on V of all the textures we are rendering to.\r\n     * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)\r\n     */\r\n    public set wrapV(wrap: number) {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i].wrapV = wrap;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new multi render target texture.\r\n     * A multi render target, like a render target provides the ability to render to a texture.\r\n     * Unlike the render target, it can render to several draw buffers in one draw.\r\n     * This is specially interesting in deferred rendering or for any effects requiring more than\r\n     * just one color from a single pass.\r\n     * @param name Define the name of the texture\r\n     * @param size Define the size of the buffers to render to\r\n     * @param count Define the number of target we are rendering into\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param options Define the options used to create the multi render target\r\n     * @param textureNames Define the names to set to the textures (if count > 0 - optional)\r\n     */\r\n    constructor(name: string, size: any, count: number, scene?: Scene, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        const generateMipMaps = options && options.generateMipMaps ? options.generateMipMaps : false;\r\n        const generateDepthTexture = options && options.generateDepthTexture ? options.generateDepthTexture : false;\r\n        const depthTextureFormat = options && options.depthTextureFormat ? options.depthTextureFormat : Constants.TEXTUREFORMAT_DEPTH16;\r\n        const doNotChangeAspectRatio = !options || options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\r\n        const drawOnlyOnFirstAttachmentByDefault = options && options.drawOnlyOnFirstAttachmentByDefault ? options.drawOnlyOnFirstAttachmentByDefault : false;\r\n        super(name, size, scene, generateMipMaps, doNotChangeAspectRatio, undefined, undefined, undefined, undefined, undefined, undefined, undefined, true);\r\n\r\n        if (!this.isSupported) {\r\n            this.dispose();\r\n            return;\r\n        }\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        const useSRGBBuffers: boolean[] = [];\r\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, options);\r\n\r\n        const generateDepthBuffer = !options || options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        const generateStencilBuffer = !options || options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n\r\n        this._size = size;\r\n        this._multiRenderTargetOptions = {\r\n            samplingModes: samplingModes,\r\n            generateMipMaps: generateMipMaps,\r\n            generateDepthBuffer: generateDepthBuffer,\r\n            generateStencilBuffer: generateStencilBuffer,\r\n            generateDepthTexture: generateDepthTexture,\r\n            depthTextureFormat: depthTextureFormat,\r\n            types: types,\r\n            textureCount: count,\r\n            useSRGBBuffers: useSRGBBuffers,\r\n        };\r\n\r\n        this._count = count;\r\n        this._drawOnlyOnFirstAttachmentByDefault = drawOnlyOnFirstAttachmentByDefault;\r\n\r\n        if (count > 0) {\r\n            this._createInternalTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n    }\r\n\r\n    private _initTypes(count: number, types: number[], samplingModes: number[], useSRGBBuffers: boolean[], options?: IMultiRenderTargetOptions) {\r\n        for (let i = 0; i < count; i++) {\r\n            if (options && options.types && options.types[i] !== undefined) {\r\n                types.push(options.types[i]);\r\n            } else {\r\n                types.push(options && options.defaultType ? options.defaultType : Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            }\r\n\r\n            if (options && options.samplingModes && options.samplingModes[i] !== undefined) {\r\n                samplingModes.push(options.samplingModes[i]);\r\n            } else {\r\n                samplingModes.push(Texture.BILINEAR_SAMPLINGMODE);\r\n            }\r\n\r\n            if (options && options.useSRGBBuffers && options.useSRGBBuffers[i] !== undefined) {\r\n                useSRGBBuffers.push(options.useSRGBBuffers[i]);\r\n            } else {\r\n                useSRGBBuffers.push(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _rebuild(forceFullRebuild: boolean = false, textureNames?: string[]): void {\r\n        if (this._count < 1) {\r\n            return;\r\n        }\r\n\r\n        this.releaseInternalTextures();\r\n        this._createInternalTextures();\r\n\r\n        if (forceFullRebuild) {\r\n            this._releaseTextures();\r\n            this._createTextures(textureNames);\r\n        }\r\n\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = this._textures[i];\r\n            texture._texture = internalTextures[i];\r\n        }\r\n\r\n        if (this.samples !== 1) {\r\n            this._renderTarget!.setSamples(this.samples, !this._drawOnlyOnFirstAttachmentByDefault, true);\r\n        }\r\n    }\r\n\r\n    private _createInternalTextures(): void {\r\n        this._renderTarget = this._getEngine()!.createMultipleRenderTarget(this._size, this._multiRenderTargetOptions, !this._drawOnlyOnFirstAttachmentByDefault);\r\n        this._texture = this._renderTarget.texture;\r\n    }\r\n\r\n    private _releaseTextures(): void {\r\n        if (this._textures) {\r\n            for (let i = 0; i < this._textures.length; i++) {\r\n                this._textures[i]._texture = null; // internal textures are released by a call to releaseInternalTextures()\r\n                this._textures[i].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createTextures(textureNames?: string[]): void {\r\n        const internalTextures = this._renderTarget!.textures!;\r\n        this._textures = [];\r\n        for (let i = 0; i < internalTextures.length; i++) {\r\n            const texture = new Texture(null, this.getScene());\r\n            if (textureNames?.[i]) {\r\n                texture.name = textureNames[i];\r\n            }\r\n            texture._texture = internalTextures[i];\r\n            this._textures.push(texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces an internal texture within the MRT. Useful to share textures between MultiRenderTarget.\r\n     * @param texture The new texture to set in the MRT\r\n     * @param index The index of the texture to replace\r\n     * @param disposePrevious Set to true if the previous internal texture should be disposed\r\n     */\r\n    public setInternalTexture(texture: InternalTexture, index: number, disposePrevious: boolean = true) {\r\n        if (!this.renderTarget) {\r\n            return;\r\n        }\r\n\r\n        if (index === 0) {\r\n            this._texture = texture;\r\n        }\r\n\r\n        this.renderTarget.setTexture(texture, index, disposePrevious);\r\n\r\n        if (!this.textures[index]) {\r\n            this.textures[index] = new Texture(null, this.getScene());\r\n        }\r\n        this.textures[index]._texture = texture;\r\n\r\n        this._count = this.renderTarget.textures ? this.renderTarget.textures.length : 0;\r\n\r\n        if (this._multiRenderTargetOptions.types) {\r\n            this._multiRenderTargetOptions.types[index] = texture.type;\r\n        }\r\n        if (this._multiRenderTargetOptions.samplingModes) {\r\n            this._multiRenderTargetOptions.samplingModes[index] = texture.samplingMode;\r\n        }\r\n        if (this._multiRenderTargetOptions.useSRGBBuffers) {\r\n            this._multiRenderTargetOptions.useSRGBBuffers[index] = texture._useSRGBBuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define the number of samples used if MSAA is enabled.\r\n     */\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        if (this._renderTarget) {\r\n            this._samples = this._renderTarget.setSamples(value);\r\n        } else {\r\n            // In case samples are set with 0 textures created, we must save the desired samples value\r\n            this._samples = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resize all the textures in the multi render target.\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param size Define the new size\r\n     */\r\n    public resize(size: any) {\r\n        this._size = size;\r\n        this._rebuild();\r\n    }\r\n\r\n    /**\r\n     * Changes the number of render targets in this MRT\r\n     * Be careful as it will recreate all the data in the new texture.\r\n     * @param count new texture count\r\n     * @param options Specifies texture types and sampling modes for new textures\r\n     * @param textureNames Specifies the names of the textures (optional)\r\n     */\r\n    public updateCount(count: number, options?: IMultiRenderTargetOptions, textureNames?: string[]) {\r\n        this._multiRenderTargetOptions.textureCount = count;\r\n        this._count = count;\r\n\r\n        const types: number[] = [];\r\n        const samplingModes: number[] = [];\r\n        const useSRGBBuffers: boolean[] = [];\r\n\r\n        this._initTypes(count, types, samplingModes, useSRGBBuffers, options);\r\n        this._multiRenderTargetOptions.types = types;\r\n        this._multiRenderTargetOptions.samplingModes = samplingModes;\r\n        this._multiRenderTargetOptions.useSRGBBuffers = useSRGBBuffers;\r\n        this._rebuild(true, textureNames);\r\n    }\r\n\r\n    protected _unbindFrameBuffer(engine: Engine, faceIndex: number): void {\r\n        if (this._renderTarget) {\r\n            engine.unBindMultiColorAttachmentFramebuffer(this._renderTarget, this.isCube, () => {\r\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the render targets and their associated resources\r\n     * @param doNotDisposeInternalTextures\r\n     */\r\n    public dispose(doNotDisposeInternalTextures = false): void {\r\n        this._releaseTextures();\r\n        if (!doNotDisposeInternalTextures) {\r\n            this.releaseInternalTextures();\r\n        } else {\r\n            // Prevent internal texture dispose in super.dispose\r\n            this._texture = null;\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Release all the underlying texture used as draw buffers.\r\n     */\r\n    public releaseInternalTextures(): void {\r\n        const internalTextures = this._renderTarget?.textures;\r\n\r\n        if (!internalTextures) {\r\n            return;\r\n        }\r\n\r\n        for (let i = internalTextures.length - 1; i >= 0; i--) {\r\n            this._textures[i]._texture = null;\r\n        }\r\n\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}