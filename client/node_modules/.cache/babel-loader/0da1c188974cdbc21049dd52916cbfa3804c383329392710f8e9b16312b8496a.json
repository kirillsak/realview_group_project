{"ast":null,"code":"import { Texture } from \"./texture.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * Raw texture can help creating a texture directly from an array of data.\n * This can be super useful if you either get the data from an uncompressed source or\n * if you wish to create your texture pixel by pixel.\n */\nexport class RawTexture extends Texture {\n  /**\n   * Instantiates a new RawTexture.\n   * Raw texture can help creating a texture directly from an array of data.\n   * This can be super useful if you either get the data from an uncompressed source or\n   * if you wish to create your texture pixel by pixel.\n   * @param data define the array of data to use to create the texture (null to create an empty texture)\n   * @param width define the width of the texture\n   * @param height define the height of the texture\n   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps define whether mip maps should be generated or not\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   */\n  constructor(data, width, height,\n  /**\n   * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n   */\n  format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer) {\n    super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\n    this.format = format;\n    if (!this._engine) {\n      return;\n    }\n    if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {\n      samplingMode = 1;\n    }\n    if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {\n      samplingMode = 1;\n    }\n    this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0, useSRGBBuffer !== null && useSRGBBuffer !== void 0 ? useSRGBBuffer : false);\n    this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this.wrapV = Texture.CLAMP_ADDRESSMODE;\n  }\n  /**\n   * Updates the texture underlying data.\n   * @param data Define the new data of the texture\n   */\n  update(data) {\n    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);\n  }\n  /**\n   * Creates a luminance texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the luminance texture\n   */\n  static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n    return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  }\n  /**\n   * Creates a luminance alpha texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the luminance alpha texture\n   */\n  static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n    return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  }\n  /**\n   * Creates an alpha texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @returns the alpha texture\n   */\n  static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {\n    return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n  }\n  /**\n   * Creates a RGB texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the RGB alpha texture\n   */\n  static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n  }\n  /**\n   * Creates a RGBA texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the RGBA texture\n   */\n  static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n  }\n  /**\n   * Creates a RGBA storage texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the RGBA texture\n   */\n  static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {\n    return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);\n  }\n  /**\n   * Creates a R texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the R texture\n   */\n  static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n  }\n  /**\n   * Creates a R storage texture from some data.\n   * @param data Define the texture data\n   * @param width Define the width of the texture\n   * @param height Define the height of the texture\n   * @param sceneOrEngine defines the scene or engine the texture will belong to\n   * @param generateMipMaps Define whether or not to create mip maps for the texture\n   * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n   * @returns the R texture\n   */\n  static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {\n    return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);\n  }\n}","map":{"version":3,"mappings":"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","names":["Texture","RawTexture","constructor","data","width","height","format","sceneOrEngine","generateMipMaps","invertY","samplingMode","undefined","creationFlags","_engine","_caps","textureFloatLinearFiltering","type","textureHalfFloatLinearFiltering","_texture","createRawTexture","useSRGBBuffer","wrapU","CLAMP_ADDRESSMODE","wrapV","update","_getEngine","updateRawTexture","_useSRGBBuffer","CreateLuminanceTexture","CreateLuminanceAlphaTexture","CreateAlphaTexture","CreateRGBTexture","CreateRGBATexture","CreateRGBAStorageTexture","CreateRTexture","TRILINEAR_SAMPLINGMODE","CreateRStorageTexture"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/rawTexture.ts"],"sourcesContent":["import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | ThinEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}