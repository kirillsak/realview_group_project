{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine.js\";\nThinEngine.prototype.updateVideoTexture = function (texture, video, invertY) {\n  if (!texture || texture._isDisabled) {\n    return;\n  }\n  const glformat = this._getInternalFormat(texture.format);\n  const internalFormat = this._getRGBABufferInternalSizedFormat(0, texture.format);\n  const wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\n  this._unpackFlipY(!invertY); // Video are upside down by default\n  try {\n    // Testing video texture support\n    if (this._videoTextureSupported === undefined) {\n      // clear old errors just in case.\n      this._gl.getError();\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);\n      if (this._gl.getError() !== 0) {\n        this._videoTextureSupported = false;\n      } else {\n        this._videoTextureSupported = true;\n      }\n    }\n    // Copy video through the current working canvas if video texture is not supported\n    if (!this._videoTextureSupported) {\n      if (!texture._workingCanvas) {\n        texture._workingCanvas = this.createCanvas(texture.width, texture.height);\n        const context = texture._workingCanvas.getContext(\"2d\");\n        if (!context) {\n          throw new Error(\"Unable to get 2d context\");\n        }\n        texture._workingContext = context;\n        texture._workingCanvas.width = texture.width;\n        texture._workingCanvas.height = texture.height;\n      }\n      texture._workingContext.clearRect(0, 0, texture.width, texture.height);\n      texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, texture._workingCanvas);\n    } else {\n      this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);\n    }\n    if (texture.generateMipMaps) {\n      this._gl.generateMipmap(this._gl.TEXTURE_2D);\n    }\n    if (!wasPreviouslyBound) {\n      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n    }\n    //    this.resetTextureCache();\n    texture.isReady = true;\n  } catch (ex) {\n    // Something unexpected\n    // Let's disable the texture\n    texture._isDisabled = true;\n  }\n};","map":{"version":3,"mappings":"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","names":["ThinEngine","prototype","updateVideoTexture","texture","video","invertY","_isDisabled","glformat","_getInternalFormat","format","internalFormat","_getRGBABufferInternalSizedFormat","wasPreviouslyBound","_bindTextureDirectly","_gl","TEXTURE_2D","_unpackFlipY","_videoTextureSupported","undefined","getError","texImage2D","UNSIGNED_BYTE","_workingCanvas","createCanvas","width","height","context","getContext","Error","_workingContext","clearRect","drawImage","videoWidth","videoHeight","generateMipMaps","generateMipmap","isReady","ex"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.videoTexture.ts"],"sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Update a video texture\r\n         * @param texture defines the texture to update\r\n         * @param video defines the video element to use\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement | Nullable<ExternalTexture>, invertY: boolean): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateVideoTexture = function (texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n    if (!texture || texture._isDisabled) {\r\n        return;\r\n    }\r\n\r\n    const glformat = this._getInternalFormat(texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(Constants.TEXTURETYPE_UNSIGNED_BYTE, texture.format);\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(!invertY); // Video are upside down by default\r\n\r\n    try {\r\n        // Testing video texture support\r\n        if (this._videoTextureSupported === undefined) {\r\n            // clear old errors just in case.\r\n            this._gl.getError();\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);\r\n\r\n            if (this._gl.getError() !== 0) {\r\n                this._videoTextureSupported = false;\r\n            } else {\r\n                this._videoTextureSupported = true;\r\n            }\r\n        }\r\n\r\n        // Copy video through the current working canvas if video texture is not supported\r\n        if (!this._videoTextureSupported) {\r\n            if (!texture._workingCanvas) {\r\n                texture._workingCanvas = this.createCanvas(texture.width, texture.height);\r\n                const context = texture._workingCanvas.getContext(\"2d\");\r\n\r\n                if (!context) {\r\n                    throw new Error(\"Unable to get 2d context\");\r\n                }\r\n\r\n                texture._workingContext = context;\r\n                texture._workingCanvas.width = texture.width;\r\n                texture._workingCanvas.height = texture.height;\r\n            }\r\n\r\n            texture._workingContext!.clearRect(0, 0, texture.width, texture.height);\r\n            texture._workingContext!.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture.width, texture.height);\r\n\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, texture._workingCanvas as TexImageSource);\r\n        } else {\r\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, glformat, this._gl.UNSIGNED_BYTE, video);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n        }\r\n\r\n        if (!wasPreviouslyBound) {\r\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n        }\r\n        //    this.resetTextureCache();\r\n        texture.isReady = true;\r\n    } catch (ex) {\r\n        // Something unexpected\r\n        // Let's disable the texture\r\n        texture._isDisabled = true;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}