{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nMesh._GoldbergMeshParser = (parsedMesh, scene) => {\n  return GoldbergMesh.Parse(parsedMesh, scene);\n};\n/**\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\n */\nexport class GoldbergMesh extends Mesh {\n  constructor() {\n    super(...arguments);\n    /**\n     * Defines the specific Goldberg data used in this mesh construction.\n     */\n    this.goldbergData = {\n      faceColors: [],\n      faceCenters: [],\n      faceZaxis: [],\n      faceXaxis: [],\n      faceYaxis: [],\n      nbSharedFaces: 0,\n      nbUnsharedFaces: 0,\n      nbFaces: 0,\n      nbFacesAtPole: 0,\n      adjacentFaces: []\n    };\n  }\n  /**\n   * Gets the related Goldberg face from pole infos\n   * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\n   * @param fromPole Defines an optional pole index to find the related info from\n   * @returns the goldberg face number\n   */\n  relatedGoldbergFace(poleOrShared, fromPole) {\n    if (fromPole === void 0) {\n      if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\n        Logger.Warn(\"Maximum number of unshared faces used\");\n        poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\n      }\n      return this.goldbergData.nbUnsharedFaces + poleOrShared;\n    }\n    if (poleOrShared > 11) {\n      Logger.Warn(\"Last pole used\");\n      poleOrShared = 11;\n    }\n    if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\n      Logger.Warn(\"Maximum number of faces at a pole used\");\n      fromPole = this.goldbergData.nbFacesAtPole - 1;\n    }\n    return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\n  }\n  _changeGoldbergFaceColors(colorRange) {\n    for (let i = 0; i < colorRange.length; i++) {\n      const min = colorRange[i][0];\n      const max = colorRange[i][1];\n      const col = colorRange[i][2];\n      for (let f = min; f < max + 1; f++) {\n        this.goldbergData.faceColors[f] = col;\n      }\n    }\n    const newCols = [];\n    for (let f = 0; f < 12; f++) {\n      for (let i = 0; i < 5; i++) {\n        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n      }\n    }\n    for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\n      for (let i = 0; i < 6; i++) {\n        newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\n      }\n    }\n    return newCols;\n  }\n  /**\n   * Set new goldberg face colors\n   * @param colorRange the new color to apply to the mesh\n   */\n  setGoldbergFaceColors(colorRange) {\n    const newCols = this._changeGoldbergFaceColors(colorRange);\n    this.setVerticesData(VertexBuffer.ColorKind, newCols);\n  }\n  /**\n   * Updates new goldberg face colors\n   * @param colorRange the new color to apply to the mesh\n   */\n  updateGoldbergFaceColors(colorRange) {\n    const newCols = this._changeGoldbergFaceColors(colorRange);\n    this.updateVerticesData(VertexBuffer.ColorKind, newCols);\n  }\n  _changeGoldbergFaceUVs(uvRange) {\n    const uvs = this.getVerticesData(VertexBuffer.UVKind);\n    for (let i = 0; i < uvRange.length; i++) {\n      const min = uvRange[i][0];\n      const max = uvRange[i][1];\n      const center = uvRange[i][2];\n      const radius = uvRange[i][3];\n      const angle = uvRange[i][4];\n      const points5 = [];\n      const points6 = [];\n      let u;\n      let v;\n      for (let p = 0; p < 5; p++) {\n        u = center.x + radius * Math.cos(angle + p * Math.PI / 2.5);\n        v = center.y + radius * Math.sin(angle + p * Math.PI / 2.5);\n        if (u < 0) {\n          u = 0;\n        }\n        if (u > 1) {\n          u = 1;\n        }\n        points5.push(u, v);\n      }\n      for (let p = 0; p < 6; p++) {\n        u = center.x + radius * Math.cos(angle + p * Math.PI / 3);\n        v = center.y + radius * Math.sin(angle + p * Math.PI / 3);\n        if (u < 0) {\n          u = 0;\n        }\n        if (u > 1) {\n          u = 1;\n        }\n        points6.push(u, v);\n      }\n      for (let f = min; f < Math.min(12, max + 1); f++) {\n        for (let p = 0; p < 5; p++) {\n          uvs[10 * f + 2 * p] = points5[2 * p];\n          uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\n        }\n      }\n      for (let f = Math.max(12, min); f < max + 1; f++) {\n        for (let p = 0; p < 6; p++) {\n          //120 + 12 * (f - 12) = 12 * f - 24\n          uvs[12 * f - 24 + 2 * p] = points6[2 * p];\n          uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\n        }\n      }\n    }\n    return uvs;\n  }\n  /**\n   * set new goldberg face UVs\n   * @param uvRange the new UVs to apply to the mesh\n   */\n  setGoldbergFaceUVs(uvRange) {\n    const newUVs = this._changeGoldbergFaceUVs(uvRange);\n    this.setVerticesData(VertexBuffer.UVKind, newUVs);\n  }\n  /**\n   * Updates new goldberg face UVs\n   * @param uvRange the new UVs to apply to the mesh\n   */\n  updateGoldbergFaceUVs(uvRange) {\n    const newUVs = this._changeGoldbergFaceUVs(uvRange);\n    this.updateVerticesData(VertexBuffer.UVKind, newUVs);\n  }\n  /**\n   * Places a mesh on a particular face of the goldberg polygon\n   * @param mesh Defines the mesh to position\n   * @param face Defines the face to position onto\n   * @param position Defines the position relative to the face we are positioning the mesh onto\n   */\n  placeOnGoldbergFaceAt(mesh, face, position) {\n    const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\n    mesh.rotation = orientation;\n    mesh.position = this.goldbergData.faceCenters[face].add(this.goldbergData.faceXaxis[face].scale(position.x)).add(this.goldbergData.faceYaxis[face].scale(position.y)).add(this.goldbergData.faceZaxis[face].scale(position.z));\n  }\n  /**\n   * Serialize current mesh\n   * @param serializationObject defines the object which will receive the serialization data\n   */\n  serialize(serializationObject) {\n    super.serialize(serializationObject);\n    serializationObject.type = \"GoldbergMesh\";\n    const goldbergData = {};\n    goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\n    goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\n    goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\n    goldbergData.nbFaces = this.goldbergData.nbFaces;\n    goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\n    if (this.goldbergData.faceColors) {\n      goldbergData.faceColors = [];\n      for (const color of this.goldbergData.faceColors) {\n        goldbergData.faceColors.push(color.asArray());\n      }\n    }\n    if (this.goldbergData.faceCenters) {\n      goldbergData.faceCenters = [];\n      for (const vector of this.goldbergData.faceCenters) {\n        goldbergData.faceCenters.push(vector.asArray());\n      }\n    }\n    if (this.goldbergData.faceZaxis) {\n      goldbergData.faceZaxis = [];\n      for (const vector of this.goldbergData.faceZaxis) {\n        goldbergData.faceZaxis.push(vector.asArray());\n      }\n    }\n    if (this.goldbergData.faceYaxis) {\n      goldbergData.faceYaxis = [];\n      for (const vector of this.goldbergData.faceYaxis) {\n        goldbergData.faceYaxis.push(vector.asArray());\n      }\n    }\n    if (this.goldbergData.faceXaxis) {\n      goldbergData.faceXaxis = [];\n      for (const vector of this.goldbergData.faceXaxis) {\n        goldbergData.faceXaxis.push(vector.asArray());\n      }\n    }\n    serializationObject.goldbergData = goldbergData;\n  }\n  /**\n   * Parses a serialized goldberg mesh\n   * @param parsedMesh the serialized mesh\n   * @param scene the scene to create the goldberg mesh in\n   * @returns the created goldberg mesh\n   */\n  static Parse(parsedMesh, scene) {\n    const goldbergData = parsedMesh.goldbergData;\n    goldbergData.faceColors = goldbergData.faceColors.map(el => Color4.FromArray(el));\n    goldbergData.faceCenters = goldbergData.faceCenters.map(el => Vector3.FromArray(el));\n    goldbergData.faceZaxis = goldbergData.faceZaxis.map(el => Vector3.FromArray(el));\n    goldbergData.faceXaxis = goldbergData.faceXaxis.map(el => Vector3.FromArray(el));\n    goldbergData.faceYaxis = goldbergData.faceYaxis.map(el => Vector3.FromArray(el));\n    const goldberg = new GoldbergMesh(parsedMesh.name, scene);\n    goldberg.goldbergData = goldbergData;\n    return goldberg;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","VertexBuffer","Mesh","Color4","Logger","_GoldbergMeshParser","parsedMesh","scene","GoldbergMesh","Parse","constructor","faceColors","faceCenters","faceZaxis","faceXaxis","faceYaxis","nbSharedFaces","nbUnsharedFaces","nbFaces","nbFacesAtPole","adjacentFaces","relatedGoldbergFace","poleOrShared","fromPole","goldbergData","Warn","_changeGoldbergFaceColors","colorRange","i","length","min","max","col","f","newCols","push","r","g","b","a","setGoldbergFaceColors","setVerticesData","ColorKind","updateGoldbergFaceColors","updateVerticesData","_changeGoldbergFaceUVs","uvRange","uvs","getVerticesData","UVKind","center","radius","angle","points5","points6","u","v","p","x","Math","cos","PI","y","sin","setGoldbergFaceUVs","newUVs","updateGoldbergFaceUVs","placeOnGoldbergFaceAt","mesh","face","position","orientation","RotationFromAxis","rotation","add","scale","z","serialize","serializationObject","type","color","asArray","vector","map","el","FromArray","goldberg","name"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/goldbergMesh.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { FloatArray } from \"../types\";\r\n\r\nMesh._GoldbergMeshParser = (parsedMesh: any, scene: Scene): GoldbergMesh => {\r\n    return GoldbergMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Defines the set of goldberg data used to create the polygon\r\n */\r\nexport type GoldbergData = {\r\n    /**\r\n     * The list of Goldberg faces colors\r\n     */\r\n    faceColors: Color4[];\r\n    /**\r\n     * The list of Goldberg faces centers\r\n     */\r\n    faceCenters: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Z axis\r\n     */\r\n    faceZaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces Y axis\r\n     */\r\n    faceXaxis: Vector3[];\r\n    /**\r\n     * The list of Goldberg faces X axis\r\n     */\r\n    faceYaxis: Vector3[];\r\n    /**\r\n     * Defines the number of shared faces\r\n     */\r\n    nbSharedFaces: number;\r\n    /**\r\n     * Defines the number of unshared faces\r\n     */\r\n    nbUnsharedFaces: number;\r\n    /**\r\n     * Defines the total number of goldberg faces\r\n     */\r\n    nbFaces: number;\r\n    /**\r\n     * Defines the number of goldberg faces at the pole\r\n     */\r\n    nbFacesAtPole: number;\r\n    /**\r\n     * Defines the number of adjacent faces per goldberg faces\r\n     */\r\n    adjacentFaces: number[][];\r\n};\r\n\r\n/**\r\n * Mesh for a Goldberg Polyhedron which is made from 12 pentagonal and the rest hexagonal faces\r\n * @see https://en.wikipedia.org/wiki/Goldberg_polyhedron\r\n */\r\nexport class GoldbergMesh extends Mesh {\r\n    /**\r\n     * Defines the specific Goldberg data used in this mesh construction.\r\n     */\r\n    public goldbergData: GoldbergData = {\r\n        faceColors: [],\r\n        faceCenters: [],\r\n        faceZaxis: [],\r\n        faceXaxis: [],\r\n        faceYaxis: [],\r\n        nbSharedFaces: 0,\r\n        nbUnsharedFaces: 0,\r\n        nbFaces: 0,\r\n        nbFacesAtPole: 0,\r\n        adjacentFaces: [],\r\n    };\r\n\r\n    /**\r\n     * Gets the related Goldberg face from pole infos\r\n     * @param poleOrShared Defines the pole index or the shared face index if the fromPole parameter is passed in\r\n     * @param fromPole Defines an optional pole index to find the related info from\r\n     * @returns the goldberg face number\r\n     */\r\n    public relatedGoldbergFace(poleOrShared: number, fromPole?: number): number {\r\n        if (fromPole === void 0) {\r\n            if (poleOrShared > this.goldbergData.nbUnsharedFaces - 1) {\r\n                Logger.Warn(\"Maximum number of unshared faces used\");\r\n                poleOrShared = this.goldbergData.nbUnsharedFaces - 1;\r\n            }\r\n            return this.goldbergData.nbUnsharedFaces + poleOrShared;\r\n        }\r\n        if (poleOrShared > 11) {\r\n            Logger.Warn(\"Last pole used\");\r\n            poleOrShared = 11;\r\n        }\r\n        if (fromPole > this.goldbergData.nbFacesAtPole - 1) {\r\n            Logger.Warn(\"Maximum number of faces at a pole used\");\r\n            fromPole = this.goldbergData.nbFacesAtPole - 1;\r\n        }\r\n\r\n        return 12 + poleOrShared * this.goldbergData.nbFacesAtPole + fromPole;\r\n    }\r\n\r\n    private _changeGoldbergFaceColors(colorRange: (number | Color4)[][]): number[] {\r\n        for (let i = 0; i < colorRange.length; i++) {\r\n            const min: number = <number>colorRange[i][0];\r\n            const max: number = <number>colorRange[i][1];\r\n            const col: Color4 = <Color4>colorRange[i][2];\r\n            for (let f = min; f < max + 1; f++) {\r\n                this.goldbergData.faceColors[f] = col;\r\n            }\r\n        }\r\n\r\n        const newCols: number[] = [];\r\n        for (let f = 0; f < 12; f++) {\r\n            for (let i = 0; i < 5; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        for (let f = 12; f < this.goldbergData.faceColors.length; f++) {\r\n            for (let i = 0; i < 6; i++) {\r\n                newCols.push(this.goldbergData.faceColors[f].r, this.goldbergData.faceColors[f].g, this.goldbergData.faceColors[f].b, this.goldbergData.faceColors[f].a);\r\n            }\r\n        }\r\n        return newCols;\r\n    }\r\n\r\n    /**\r\n     * Set new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public setGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.setVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face colors\r\n     * @param colorRange the new color to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceColors(colorRange: (number | Color4)[][]) {\r\n        const newCols = this._changeGoldbergFaceColors(colorRange);\r\n        this.updateVerticesData(VertexBuffer.ColorKind, newCols);\r\n    }\r\n\r\n    private _changeGoldbergFaceUVs(uvRange: (number | Vector2)[][]): FloatArray {\r\n        const uvs: FloatArray = this.getVerticesData(VertexBuffer.UVKind)!!;\r\n        for (let i = 0; i < uvRange.length; i++) {\r\n            const min: number = <number>uvRange[i][0];\r\n            const max: number = <number>uvRange[i][1];\r\n            const center: Vector2 = <Vector2>uvRange[i][2];\r\n            const radius: number = <number>uvRange[i][3];\r\n            const angle: number = <number>uvRange[i][4];\r\n            const points5: number[] = [];\r\n            const points6: number[] = [];\r\n            let u: number;\r\n            let v: number;\r\n            for (let p = 0; p < 5; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 2.5);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 2.5);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points5.push(u, v);\r\n            }\r\n            for (let p = 0; p < 6; p++) {\r\n                u = center.x + radius * Math.cos(angle + (p * Math.PI) / 3);\r\n                v = center.y + radius * Math.sin(angle + (p * Math.PI) / 3);\r\n                if (u < 0) {\r\n                    u = 0;\r\n                }\r\n                if (u > 1) {\r\n                    u = 1;\r\n                }\r\n                points6.push(u, v);\r\n            }\r\n            for (let f = min; f < Math.min(12, max + 1); f++) {\r\n                for (let p = 0; p < 5; p++) {\r\n                    uvs[10 * f + 2 * p] = points5[2 * p];\r\n                    uvs[10 * f + 2 * p + 1] = points5[2 * p + 1];\r\n                }\r\n            }\r\n            for (let f = Math.max(12, min); f < max + 1; f++) {\r\n                for (let p = 0; p < 6; p++) {\r\n                    //120 + 12 * (f - 12) = 12 * f - 24\r\n                    uvs[12 * f - 24 + 2 * p] = points6[2 * p];\r\n                    uvs[12 * f - 23 + 2 * p] = points6[2 * p + 1];\r\n                }\r\n            }\r\n        }\r\n        return uvs;\r\n    }\r\n\r\n    /**\r\n     * set new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public setGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs: FloatArray = this._changeGoldbergFaceUVs(uvRange);\r\n        this.setVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Updates new goldberg face UVs\r\n     * @param uvRange the new UVs to apply to the mesh\r\n     */\r\n    public updateGoldbergFaceUVs(uvRange: (number | Vector2)[][]) {\r\n        const newUVs = this._changeGoldbergFaceUVs(uvRange);\r\n        this.updateVerticesData(VertexBuffer.UVKind, newUVs);\r\n    }\r\n\r\n    /**\r\n     * Places a mesh on a particular face of the goldberg polygon\r\n     * @param mesh Defines the mesh to position\r\n     * @param face Defines the face to position onto\r\n     * @param position Defines the position relative to the face we are positioning the mesh onto\r\n     */\r\n    public placeOnGoldbergFaceAt(mesh: Mesh, face: number, position: Vector3) {\r\n        const orientation = Vector3.RotationFromAxis(this.goldbergData.faceXaxis[face], this.goldbergData.faceYaxis[face], this.goldbergData.faceZaxis[face]);\r\n        mesh.rotation = orientation;\r\n        mesh.position = this.goldbergData.faceCenters[face]\r\n            .add(this.goldbergData.faceXaxis[face].scale(position.x))\r\n            .add(this.goldbergData.faceYaxis[face].scale(position.y))\r\n            .add(this.goldbergData.faceZaxis[face].scale(position.z));\r\n    }\r\n\r\n    /**\r\n     * Serialize current mesh\r\n     * @param serializationObject defines the object which will receive the serialization data\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = \"GoldbergMesh\";\r\n\r\n        const goldbergData: any = {};\r\n        goldbergData.adjacentFaces = this.goldbergData.adjacentFaces;\r\n        goldbergData.nbSharedFaces = this.goldbergData.nbSharedFaces;\r\n        goldbergData.nbUnsharedFaces = this.goldbergData.nbUnsharedFaces;\r\n        goldbergData.nbFaces = this.goldbergData.nbFaces;\r\n        goldbergData.nbFacesAtPole = this.goldbergData.nbFacesAtPole;\r\n\r\n        if (this.goldbergData.faceColors) {\r\n            goldbergData.faceColors = [];\r\n            for (const color of this.goldbergData.faceColors) {\r\n                goldbergData.faceColors.push(color.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceCenters) {\r\n            goldbergData.faceCenters = [];\r\n            for (const vector of this.goldbergData.faceCenters) {\r\n                goldbergData.faceCenters.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceZaxis) {\r\n            goldbergData.faceZaxis = [];\r\n            for (const vector of this.goldbergData.faceZaxis) {\r\n                goldbergData.faceZaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceYaxis) {\r\n            goldbergData.faceYaxis = [];\r\n            for (const vector of this.goldbergData.faceYaxis) {\r\n                goldbergData.faceYaxis.push(vector.asArray());\r\n            }\r\n        }\r\n        if (this.goldbergData.faceXaxis) {\r\n            goldbergData.faceXaxis = [];\r\n            for (const vector of this.goldbergData.faceXaxis) {\r\n                goldbergData.faceXaxis.push(vector.asArray());\r\n            }\r\n        }\r\n\r\n        serializationObject.goldbergData = goldbergData;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized goldberg mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the goldberg mesh in\r\n     * @returns the created goldberg mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): GoldbergMesh {\r\n        const goldbergData = parsedMesh.goldbergData;\r\n        goldbergData.faceColors = goldbergData.faceColors.map((el: number[]) => Color4.FromArray(el));\r\n        goldbergData.faceCenters = goldbergData.faceCenters.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceZaxis = goldbergData.faceZaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceXaxis = goldbergData.faceXaxis.map((el: number[]) => Vector3.FromArray(el));\r\n        goldbergData.faceYaxis = goldbergData.faceYaxis.map((el: number[]) => Vector3.FromArray(el));\r\n\r\n        const goldberg = new GoldbergMesh(parsedMesh.name, scene);\r\n        goldberg.goldbergData = goldbergData;\r\n\r\n        return goldberg;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}