{"ast":null,"code":"import { Camera } from \"../../Cameras/camera.js\";\nimport { UniversalCamera } from \"../../Cameras/universalCamera.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { TargetCamera } from \"../targetCamera.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Viewport } from \"../../Maths/math.viewport.js\";\n/**\n * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class StereoscopicScreenUniversalCamera extends UniversalCamera {\n  /**\n   * Creates a new StereoscopicScreenUniversalCamera\n   * @param name defines camera name\n   * @param position defines initial position\n   * @param scene defines the hosting scene\n   * @param distanceToProjectionPlane defines distance between each color axis. The rig cameras will receive this as their negative z position!\n   * @param distanceBetweenEyes defines is stereoscopic is done side by side or over under\n   */\n  constructor(name, position, scene, distanceToProjectionPlane = 1, distanceBetweenEyes = 0.065) {\n    super(name, position, scene);\n    this._distanceBetweenEyes = distanceBetweenEyes;\n    this._distanceToProjectionPlane = distanceToProjectionPlane;\n    this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {\n      stereoHalfAngle: 0\n    });\n    this._cameraRigParams.stereoHalfAngle = 0;\n    this._cameraRigParams.interaxialDistance = distanceBetweenEyes;\n  }\n  set distanceBetweenEyes(newValue) {\n    this._distanceBetweenEyes = newValue;\n  }\n  /**\n   * distance between the eyes\n   */\n  get distanceBetweenEyes() {\n    return this._distanceBetweenEyes;\n  }\n  set distanceToProjectionPlane(newValue) {\n    this._distanceToProjectionPlane = newValue;\n  }\n  /**\n   * Distance to projection plane (should be the same units the like distance between the eyes)\n   */\n  get distanceToProjectionPlane() {\n    return this._distanceToProjectionPlane;\n  }\n  /**\n   * Gets camera class name\n   * @returns StereoscopicScreenUniversalCamera\n   */\n  getClassName() {\n    return \"StereoscopicUniversalCamera\";\n  }\n  /**\n   * @internal\n   */\n  createRigCamera(name) {\n    const camera = new TargetCamera(name, Vector3.Zero(), this.getScene());\n    const transform = new TransformNode(\"tm_\" + name, this.getScene());\n    camera.parent = transform;\n    transform.setPivotMatrix(Matrix.Identity(), false);\n    camera.isRigCamera = true;\n    camera.rigParent = this;\n    return camera;\n  }\n  /**\n   * @internal\n   */\n  _updateRigCameras() {\n    for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\n      const cam = this._rigCameras[cameraIndex];\n      cam.minZ = this.minZ;\n      cam.maxZ = this.maxZ;\n      cam.fov = this.fov;\n      cam.upVector.copyFrom(this.upVector);\n      if (cam.rotationQuaternion) {\n        cam.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        cam.rotation.copyFrom(this.rotation);\n      }\n      this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);\n    }\n  }\n  _updateCamera(camera, cameraIndex) {\n    const b = this.distanceBetweenEyes / 2;\n    const z = b / this.distanceToProjectionPlane;\n    camera.position.copyFrom(this.position);\n    camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);\n    const transform = camera.parent;\n    const m = transform.getPivotMatrix();\n    m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);\n    m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);\n    transform.setPivotMatrix(m, false);\n  }\n  _setRigMode() {\n    this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);\n    this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n    for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\n      this._updateCamera(this._rigCameras[cameraIndex], cameraIndex);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Camera","UniversalCamera","Matrix","Vector3","TargetCamera","TransformNode","Viewport","StereoscopicScreenUniversalCamera","constructor","name","position","scene","distanceToProjectionPlane","distanceBetweenEyes","_distanceBetweenEyes","_distanceToProjectionPlane","setCameraRigMode","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","stereoHalfAngle","_cameraRigParams","interaxialDistance","newValue","getClassName","createRigCamera","camera","Zero","getScene","transform","parent","setPivotMatrix","Identity","isRigCamera","rigParent","_updateRigCameras","cameraIndex","_rigCameras","length","cam","minZ","maxZ","fov","upVector","copyFrom","rotationQuaternion","rotation","_updateCamera","b","z","addInPlaceFromFloats","m","getPivotMatrix","setTranslationFromFloats","setRowFromFloats","_setRigMode","viewport"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/Stereoscopic/stereoscopicScreenUniversalCamera.ts"],"sourcesContent":["import { Camera } from \"../../Cameras/camera\";\r\nimport { UniversalCamera } from \"../../Cameras/universalCamera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { TargetCamera } from \"../targetCamera\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Viewport } from \"../../Maths/math.viewport\";\r\n\r\n/**\r\n * Camera used to simulate stereoscopic rendering on real screens (based on UniversalCamera)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class StereoscopicScreenUniversalCamera extends UniversalCamera {\r\n    private _distanceToProjectionPlane: number;\r\n    private _distanceBetweenEyes: number;\r\n\r\n    public set distanceBetweenEyes(newValue: number) {\r\n        this._distanceBetweenEyes = newValue;\r\n    }\r\n\r\n    /**\r\n     * distance between the eyes\r\n     */\r\n    public get distanceBetweenEyes(): number {\r\n        return this._distanceBetweenEyes;\r\n    }\r\n\r\n    public set distanceToProjectionPlane(newValue: number) {\r\n        this._distanceToProjectionPlane = newValue;\r\n    }\r\n\r\n    /**\r\n     * Distance to projection plane (should be the same units the like distance between the eyes)\r\n     */\r\n    public get distanceToProjectionPlane(): number {\r\n        return this._distanceToProjectionPlane;\r\n    }\r\n    /**\r\n     * Creates a new StereoscopicScreenUniversalCamera\r\n     * @param name defines camera name\r\n     * @param position defines initial position\r\n     * @param scene defines the hosting scene\r\n     * @param distanceToProjectionPlane defines distance between each color axis. The rig cameras will receive this as their negative z position!\r\n     * @param distanceBetweenEyes defines is stereoscopic is done side by side or over under\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, distanceToProjectionPlane: number = 1, distanceBetweenEyes: number = 0.065) {\r\n        super(name, position, scene);\r\n        this._distanceBetweenEyes = distanceBetweenEyes;\r\n        this._distanceToProjectionPlane = distanceToProjectionPlane;\r\n        this.setCameraRigMode(Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL, {\r\n            stereoHalfAngle: 0,\r\n        });\r\n        this._cameraRigParams.stereoHalfAngle = 0;\r\n        this._cameraRigParams.interaxialDistance = distanceBetweenEyes;\r\n    }\r\n\r\n    /**\r\n     * Gets camera class name\r\n     * @returns StereoscopicScreenUniversalCamera\r\n     */\r\n    public getClassName(): string {\r\n        return \"StereoscopicUniversalCamera\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createRigCamera(name: string): Nullable<Camera> {\r\n        const camera = new TargetCamera(name, Vector3.Zero(), this.getScene());\r\n        const transform = new TransformNode(\"tm_\" + name, this.getScene());\r\n        camera.parent = transform;\r\n        transform.setPivotMatrix(Matrix.Identity(), false);\r\n        camera.isRigCamera = true;\r\n        camera.rigParent = this;\r\n        return camera;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\r\n            const cam = this._rigCameras[cameraIndex] as TargetCamera;\r\n            cam.minZ = this.minZ;\r\n            cam.maxZ = this.maxZ;\r\n            cam.fov = this.fov;\r\n            cam.upVector.copyFrom(this.upVector);\r\n            if (cam.rotationQuaternion) {\r\n                cam.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n            } else {\r\n                cam.rotation.copyFrom(this.rotation);\r\n            }\r\n            this._updateCamera(this._rigCameras[cameraIndex] as TargetCamera, cameraIndex);\r\n        }\r\n    }\r\n\r\n    private _updateCamera(camera: TargetCamera, cameraIndex: number) {\r\n        const b = this.distanceBetweenEyes / 2;\r\n        const z = b / this.distanceToProjectionPlane;\r\n        camera.position.copyFrom(this.position);\r\n        camera.position.addInPlaceFromFloats(cameraIndex === 0 ? -b : b, 0, -this._distanceToProjectionPlane);\r\n        const transform = camera.parent as TransformNode;\r\n        const m = transform.getPivotMatrix();\r\n        m.setTranslationFromFloats(cameraIndex === 0 ? b : -b, 0, 0);\r\n        m.setRowFromFloats(2, cameraIndex === 0 ? z : -z, 0, 1, 0);\r\n        transform.setPivotMatrix(m, false);\r\n    }\r\n\r\n    protected _setRigMode() {\r\n        this._rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1);\r\n        this._rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        for (let cameraIndex = 0; cameraIndex < this._rigCameras.length; cameraIndex++) {\r\n            this._updateCamera(this._rigCameras[cameraIndex] as TargetCamera, cameraIndex);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}