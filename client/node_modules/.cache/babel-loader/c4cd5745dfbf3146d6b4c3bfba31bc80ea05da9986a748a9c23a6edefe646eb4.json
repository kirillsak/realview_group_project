{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a tiled box\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * @param options.pattern\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.faceUV\n * @param options.faceColors\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @returns the VertexData of the TiledBox\n */\nexport function CreateTiledBoxVertexData(options) {\n  const nbFaces = 6;\n  const faceUV = options.faceUV || new Array(6);\n  const faceColors = options.faceColors;\n  const flipTile = options.pattern || Mesh.NO_FLIP;\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const tileWidth = options.tileWidth || options.tileSize || 1;\n  const tileHeight = options.tileHeight || options.tileSize || 1;\n  const alignH = options.alignHorizontal || 0;\n  const alignV = options.alignVertical || 0;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  // default face colors and UV if undefined\n  for (let f = 0; f < nbFaces; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n  const halfDepth = depth / 2;\n  const faceVertexData = [];\n  for (let f = 0; f < 2; f++) {\n    //front and back\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n  for (let f = 2; f < 4; f++) {\n    //sides\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: depth,\n      height: height,\n      alignVertical: alignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n  let baseAlignV = alignV;\n  if (alignV === Mesh.BOTTOM) {\n    baseAlignV = Mesh.TOP;\n  } else if (alignV === Mesh.TOP) {\n    baseAlignV = Mesh.BOTTOM;\n  }\n  for (let f = 4; f < 6; f++) {\n    //top and bottom\n    faceVertexData[f] = CreateTiledPlaneVertexData({\n      pattern: flipTile,\n      tileWidth: tileWidth,\n      tileHeight: tileHeight,\n      width: width,\n      height: depth,\n      alignVertical: baseAlignV,\n      alignHorizontal: alignH,\n      sideOrientation: sideOrientation\n    });\n  }\n  let positions = [];\n  let normals = [];\n  let uvs = [];\n  let indices = [];\n  const colors = [];\n  const facePositions = [];\n  const faceNormals = [];\n  const newFaceUV = [];\n  let lu = 0;\n  let li = 0;\n  for (let f = 0; f < nbFaces; f++) {\n    const len = faceVertexData[f].positions.length;\n    facePositions[f] = [];\n    faceNormals[f] = [];\n    for (let p = 0; p < len / 3; p++) {\n      facePositions[f].push(new Vector3(faceVertexData[f].positions[3 * p], faceVertexData[f].positions[3 * p + 1], faceVertexData[f].positions[3 * p + 2]));\n      faceNormals[f].push(new Vector3(faceVertexData[f].normals[3 * p], faceVertexData[f].normals[3 * p + 1], faceVertexData[f].normals[3 * p + 2]));\n    }\n    // uvs\n    lu = faceVertexData[f].uvs.length;\n    newFaceUV[f] = [];\n    for (let i = 0; i < lu; i += 2) {\n      newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs[i];\n      newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs[i + 1];\n      if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n        newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\n      }\n    }\n    uvs = uvs.concat(newFaceUV[f]);\n    indices = indices.concat(faceVertexData[f].indices.map(x => x + li));\n    li += facePositions[f].length;\n    if (faceColors) {\n      for (let c = 0; c < 4; c++) {\n        colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n      }\n    }\n  }\n  const vec0 = new Vector3(0, 0, halfDepth);\n  const mtrx0 = Matrix.RotationY(Math.PI);\n  positions = facePositions[0].map(entry => Vector3.TransformNormal(entry, mtrx0).add(vec0)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n  normals = faceNormals[0].map(entry => Vector3.TransformNormal(entry, mtrx0)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n  positions = positions.concat(facePositions[1].map(entry => entry.subtract(vec0)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[1].map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const vec2 = new Vector3(halfWidth, 0, 0);\n  const mtrx2 = Matrix.RotationY(-Math.PI / 2);\n  positions = positions.concat(facePositions[2].map(entry => Vector3.TransformNormal(entry, mtrx2).add(vec2)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[2].map(entry => Vector3.TransformNormal(entry, mtrx2)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const mtrx3 = Matrix.RotationY(Math.PI / 2);\n  positions = positions.concat(facePositions[3].map(entry => Vector3.TransformNormal(entry, mtrx3).subtract(vec2)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[3].map(entry => Vector3.TransformNormal(entry, mtrx3)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const vec4 = new Vector3(0, halfHeight, 0);\n  const mtrx4 = Matrix.RotationX(Math.PI / 2);\n  positions = positions.concat(facePositions[4].map(entry => Vector3.TransformNormal(entry, mtrx4).add(vec4)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[4].map(entry => Vector3.TransformNormal(entry, mtrx4)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  const mtrx5 = Matrix.RotationX(-Math.PI / 2);\n  positions = positions.concat(facePositions[5].map(entry => Vector3.TransformNormal(entry, mtrx5).subtract(vec4)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  normals = normals.concat(faceNormals[5].map(entry => Vector3.TransformNormal(entry, mtrx5)).map(entry => [entry.x, entry.y, entry.z]).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []));\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n  return vertexData;\n}\n/**\n * Creates a tiled box mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\n * * pattern sets the rotation or reflection pattern for the tiles,\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * depth of the box, overwrites size\n * * tileSize sets the size of a tile\n * * tileWidth sets the tile width and overwrites tileSize\n * * tileHeight sets the tile width and overwrites tileSize\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * @param options.pattern\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledBox(name, options, scene = null) {\n  const box = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  box._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateTiledBoxVertexData(options);\n  vertexData.applyToMesh(box, options.updatable);\n  return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledBox instead\n */\nexport const TiledBoxBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledBox\n};\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;","map":{"version":3,"mappings":";AAEA,SAASA,MAAM,EAAEC,OAAO,EAAEC,OAAO,QAAQ,4BAA0B;AACnE,SAASC,MAAM,QAAQ,2BAAyB;AAChD,SAASC,IAAI,QAAQ,YAAU;AAC/B,SAASC,UAAU,QAAQ,uBAAqB;AAChD,SAASC,0BAA0B,QAAQ,wBAAsB;AACjE,SAASC,oBAAoB,QAAQ,sCAAoC;AAEzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAM,SAAUC,wBAAwB,CAACC,OAcxC;EACG,MAAMC,OAAO,GAAG,CAAC;EAEjB,MAAMC,MAAM,GAAcF,OAAO,CAACE,MAAM,IAAI,IAAIC,KAAK,CAAU,CAAC,CAAC;EACjE,MAAMC,UAAU,GAAGJ,OAAO,CAACI,UAAU;EAErC,MAAMC,QAAQ,GAAGL,OAAO,CAACM,OAAO,IAAIX,IAAI,CAACY,OAAO;EAEhD,MAAMC,KAAK,GAAGR,OAAO,CAACQ,KAAK,IAAIR,OAAO,CAACS,IAAI,IAAI,CAAC;EAChD,MAAMC,MAAM,GAAGV,OAAO,CAACU,MAAM,IAAIV,OAAO,CAACS,IAAI,IAAI,CAAC;EAClD,MAAME,KAAK,GAAGX,OAAO,CAACW,KAAK,IAAIX,OAAO,CAACS,IAAI,IAAI,CAAC;EAChD,MAAMG,SAAS,GAAGZ,OAAO,CAACY,SAAS,IAAIZ,OAAO,CAACa,QAAQ,IAAI,CAAC;EAC5D,MAAMC,UAAU,GAAGd,OAAO,CAACc,UAAU,IAAId,OAAO,CAACa,QAAQ,IAAI,CAAC;EAC9D,MAAME,MAAM,GAAGf,OAAO,CAACgB,eAAe,IAAI,CAAC;EAC3C,MAAMC,MAAM,GAAGjB,OAAO,CAACkB,aAAa,IAAI,CAAC;EAEzC,MAAMC,eAAe,GAAGnB,OAAO,CAACmB,eAAe,KAAK,CAAC,GAAG,CAAC,GAAGnB,OAAO,CAACmB,eAAe,IAAIvB,UAAU,CAACwB,WAAW;EAE7G;EACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,OAAO,EAAEoB,CAAC,EAAE,EAAE;IAC9B,IAAInB,MAAM,CAACmB,CAAC,CAAC,KAAKC,SAAS,EAAE;MACzBpB,MAAM,CAACmB,CAAC,CAAC,GAAG,IAAI5B,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAEvC,IAAIW,UAAU,IAAIA,UAAU,CAACiB,CAAC,CAAC,KAAKC,SAAS,EAAE;MAC3ClB,UAAU,CAACiB,CAAC,CAAC,GAAG,IAAI3B,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;;EAI9C,MAAM6B,SAAS,GAAGf,KAAK,GAAG,CAAC;EAC3B,MAAMgB,UAAU,GAAGd,MAAM,GAAG,CAAC;EAC7B,MAAMe,SAAS,GAAGd,KAAK,GAAG,CAAC;EAE3B,MAAMe,cAAc,GAAsB,EAAE;EAE5C,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxB;IACAK,cAAc,CAACL,CAAC,CAAC,GAAGxB,0BAA0B,CAAC;MAC3CS,OAAO,EAAED,QAAQ;MACjBO,SAAS,EAAEA,SAAS;MACpBE,UAAU,EAAEA,UAAU;MACtBN,KAAK,EAAEA,KAAK;MACZE,MAAM,EAAEA,MAAM;MACdQ,aAAa,EAAED,MAAM;MACrBD,eAAe,EAAED,MAAM;MACvBI,eAAe,EAAEA;KACpB,CAAC;;EAGN,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxB;IACAK,cAAc,CAACL,CAAC,CAAC,GAAGxB,0BAA0B,CAAC;MAC3CS,OAAO,EAAED,QAAQ;MACjBO,SAAS,EAAEA,SAAS;MACpBE,UAAU,EAAEA,UAAU;MACtBN,KAAK,EAAEG,KAAK;MACZD,MAAM,EAAEA,MAAM;MACdQ,aAAa,EAAED,MAAM;MACrBD,eAAe,EAAED,MAAM;MACvBI,eAAe,EAAEA;KACpB,CAAC;;EAGN,IAAIQ,UAAU,GAAGV,MAAM;EACvB,IAAIA,MAAM,KAAKtB,IAAI,CAACiC,MAAM,EAAE;IACxBD,UAAU,GAAGhC,IAAI,CAACkC,GAAG;GACxB,MAAM,IAAIZ,MAAM,KAAKtB,IAAI,CAACkC,GAAG,EAAE;IAC5BF,UAAU,GAAGhC,IAAI,CAACiC,MAAM;;EAG5B,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IACxB;IACAK,cAAc,CAACL,CAAC,CAAC,GAAGxB,0BAA0B,CAAC;MAC3CS,OAAO,EAAED,QAAQ;MACjBO,SAAS,EAAEA,SAAS;MACpBE,UAAU,EAAEA,UAAU;MACtBN,KAAK,EAAEA,KAAK;MACZE,MAAM,EAAEC,KAAK;MACbO,aAAa,EAAES,UAAU;MACzBX,eAAe,EAAED,MAAM;MACvBI,eAAe,EAAEA;KACpB,CAAC;;EAGN,IAAIW,SAAS,GAAkB,EAAE;EACjC,IAAIC,OAAO,GAAkB,EAAE;EAC/B,IAAIC,GAAG,GAAkB,EAAE;EAC3B,IAAIC,OAAO,GAAkB,EAAE;EAC/B,MAAMC,MAAM,GAAkB,EAAE;EAChC,MAAMC,aAAa,GAA0B,EAAE;EAC/C,MAAMC,WAAW,GAA0B,EAAE;EAE7C,MAAMC,SAAS,GAAyB,EAAE;EAC1C,IAAIC,EAAE,GAAW,CAAC;EAElB,IAAIC,EAAE,GAAW,CAAC;EAElB,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpB,OAAO,EAAEoB,CAAC,EAAE,EAAE;IAC9B,MAAMmB,GAAG,GAAGd,cAAc,CAACL,CAAC,CAAC,CAACS,SAAU,CAACW,MAAM;IAC/CN,aAAa,CAACd,CAAC,CAAC,GAAG,EAAE;IACrBe,WAAW,CAACf,CAAC,CAAC,GAAG,EAAE;IACnB,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,GAAG,CAAC,EAAEE,CAAC,EAAE,EAAE;MAC9BP,aAAa,CAACd,CAAC,CAAC,CAACsB,IAAI,CAAC,IAAInD,OAAO,CAACkC,cAAc,CAACL,CAAC,CAAC,CAACS,SAAU,CAAC,CAAC,GAAGY,CAAC,CAAC,EAAEhB,cAAc,CAACL,CAAC,CAAC,CAACS,SAAU,CAAC,CAAC,GAAGY,CAAC,GAAG,CAAC,CAAC,EAAEhB,cAAc,CAACL,CAAC,CAAC,CAACS,SAAU,CAAC,CAAC,GAAGY,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MACzJN,WAAW,CAACf,CAAC,CAAC,CAACsB,IAAI,CAAC,IAAInD,OAAO,CAACkC,cAAc,CAACL,CAAC,CAAC,CAACU,OAAQ,CAAC,CAAC,GAAGW,CAAC,CAAC,EAAEhB,cAAc,CAACL,CAAC,CAAC,CAACU,OAAQ,CAAC,CAAC,GAAGW,CAAC,GAAG,CAAC,CAAC,EAAEhB,cAAc,CAACL,CAAC,CAAC,CAACU,OAAQ,CAAC,CAAC,GAAGW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAErJ;IACAJ,EAAE,GAAGZ,cAAc,CAACL,CAAC,CAAC,CAACW,GAAI,CAACS,MAAM;IAClCJ,SAAS,CAAChB,CAAC,CAAC,GAAG,EAAE;IACjB,KAAK,IAAIuB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,EAAE,EAAEM,CAAC,IAAI,CAAC,EAAE;MAC5BP,SAAS,CAAChB,CAAC,CAAC,CAACuB,CAAC,CAAC,GAAG1C,MAAM,CAACmB,CAAC,CAAC,CAACwB,CAAC,GAAG,CAAC3C,MAAM,CAACmB,CAAC,CAAC,CAACyB,CAAC,GAAG5C,MAAM,CAACmB,CAAC,CAAC,CAACwB,CAAC,IAAInB,cAAc,CAACL,CAAC,CAAC,CAACW,GAAI,CAACY,CAAC,CAAC;MACvFP,SAAS,CAAChB,CAAC,CAAC,CAACuB,CAAC,GAAG,CAAC,CAAC,GAAG1C,MAAM,CAACmB,CAAC,CAAC,CAAC0B,CAAC,GAAG,CAAC7C,MAAM,CAACmB,CAAC,CAAC,CAAC2B,CAAC,GAAG9C,MAAM,CAACmB,CAAC,CAAC,CAAC0B,CAAC,IAAIrB,cAAc,CAACL,CAAC,CAAC,CAACW,GAAI,CAACY,CAAC,GAAG,CAAC,CAAC;MAE/F,IAAI9C,oBAAoB,CAACmD,yBAAyB,EAAE;QAChDZ,SAAS,CAAChB,CAAC,CAAC,CAACuB,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,GAAGP,SAAS,CAAChB,CAAC,CAAC,CAACuB,CAAC,GAAG,CAAC,CAAC;;;IAGvDZ,GAAG,GAAGA,GAAG,CAACkB,MAAM,CAACb,SAAS,CAAChB,CAAC,CAAC,CAAC;IAE9BY,OAAO,GAAGA,OAAO,CAACiB,MAAM,CAAgBxB,cAAc,CAACL,CAAC,CAAC,CAACY,OAAQ,CAACkB,GAAG,CAAEN,CAAS,IAAKA,CAAC,GAAGN,EAAE,CAAC,CAAC;IAC9FA,EAAE,IAAIJ,aAAa,CAACd,CAAC,CAAC,CAACoB,MAAM;IAC7B,IAAIrC,UAAU,EAAE;MACZ,KAAK,IAAIgD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QACxBlB,MAAM,CAACS,IAAI,CAACvC,UAAU,CAACiB,CAAC,CAAC,CAACgC,CAAC,EAAEjD,UAAU,CAACiB,CAAC,CAAC,CAACiC,CAAC,EAAElD,UAAU,CAACiB,CAAC,CAAC,CAACkC,CAAC,EAAEnD,UAAU,CAACiB,CAAC,CAAC,CAACmC,CAAC,CAAC;;;;EAK3F,MAAMC,IAAI,GAAG,IAAIjE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAEiC,SAAS,CAAC;EACzC,MAAMiC,KAAK,GAAGnE,MAAM,CAACoE,SAAS,CAACC,IAAI,CAACC,EAAE,CAAC;EACvC/B,SAAS,GAAGK,aAAa,CAAC,CAAC,CAAC,CACvBgB,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEJ,KAAK,CAAC,CAACM,GAAG,CAACP,IAAI,CAAC,CAAC,CAC/DN,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC;EAC/FpC,OAAO,GAAGK,WAAW,CAAC,CAAC,CAAC,CACnBe,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEJ,KAAK,CAAC,CAAC,CACrDP,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC;EAC/FrC,SAAS,GAAGA,SAAS,CAACoB,MAAM,CACxBf,aAAa,CAAC,CAAC,CAAC,CACXgB,GAAG,CAAEW,KAAK,IAAKA,KAAK,CAACM,QAAQ,CAACX,IAAI,CAAC,CAAC,CACpCN,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACDpC,OAAO,GAAGA,OAAO,CAACmB,MAAM,CAACd,WAAW,CAAC,CAAC,CAAC,CAACe,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAACmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAAC;EAE/K,MAAME,IAAI,GAAG,IAAI7E,OAAO,CAAC+B,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC;EACzC,MAAM+C,KAAK,GAAG/E,MAAM,CAACoE,SAAS,CAAC,CAACC,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;EAC5C/B,SAAS,GAAGA,SAAS,CAACoB,MAAM,CACxBf,aAAa,CAAC,CAAC,CAAC,CACXgB,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEQ,KAAK,CAAC,CAACN,GAAG,CAACK,IAAI,CAAC,CAAC,CAC/DlB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACDpC,OAAO,GAAGA,OAAO,CAACmB,MAAM,CACpBd,WAAW,CAAC,CAAC,CAAC,CACTe,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEQ,KAAK,CAAC,CAAC,CACrDnB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACD,MAAMI,KAAK,GAAGhF,MAAM,CAACoE,SAAS,CAACC,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;EAC3C/B,SAAS,GAAGA,SAAS,CAACoB,MAAM,CACxBf,aAAa,CAAC,CAAC,CAAC,CACXgB,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAES,KAAK,CAAC,CAACH,QAAQ,CAACC,IAAI,CAAC,CAAC,CACpElB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACDpC,OAAO,GAAGA,OAAO,CAACmB,MAAM,CACpBd,WAAW,CAAC,CAAC,CAAC,CACTe,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAES,KAAK,CAAC,CAAC,CACrDpB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EAED,MAAMK,IAAI,GAAG,IAAIhF,OAAO,CAAC,CAAC,EAAEgC,UAAU,EAAE,CAAC,CAAC;EAC1C,MAAMiD,KAAK,GAAGlF,MAAM,CAACmF,SAAS,CAACd,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;EAC3C/B,SAAS,GAAGA,SAAS,CAACoB,MAAM,CACxBf,aAAa,CAAC,CAAC,CAAC,CACXgB,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEW,KAAK,CAAC,CAACT,GAAG,CAACQ,IAAI,CAAC,CAAC,CAC/DrB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACDpC,OAAO,GAAGA,OAAO,CAACmB,MAAM,CACpBd,WAAW,CAAC,CAAC,CAAC,CACTe,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEW,KAAK,CAAC,CAAC,CACrDtB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACD,MAAMQ,KAAK,GAAGpF,MAAM,CAACmF,SAAS,CAAC,CAACd,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;EAC5C/B,SAAS,GAAGA,SAAS,CAACoB,MAAM,CACxBf,aAAa,CAAC,CAAC,CAAC,CACXgB,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEa,KAAK,CAAC,CAACP,QAAQ,CAACI,IAAI,CAAC,CAAC,CACpErB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EACDpC,OAAO,GAAGA,OAAO,CAACmB,MAAM,CACpBd,WAAW,CAAC,CAAC,CAAC,CACTe,GAAG,CAAEW,KAAK,IAAKtE,OAAO,CAACuE,eAAe,CAACD,KAAK,EAAEa,KAAK,CAAC,CAAC,CACrDxB,GAAG,CAAEW,KAAK,IAAK,CAACA,KAAK,CAACjB,CAAC,EAAEiB,KAAK,CAACf,CAAC,EAAEe,KAAK,CAAChB,CAAC,CAAC,CAAC,CAC3CmB,MAAM,CAAC,CAACC,WAA0B,EAAEC,YAAY,KAAKD,WAAW,CAAChB,MAAM,CAACiB,YAAY,CAAC,EAAE,EAAE,CAAC,CAClG;EAED;EACAvE,UAAU,CAACgF,aAAa,CAACzD,eAAe,EAAEW,SAAS,EAAEG,OAAO,EAAEF,OAAO,EAAEC,GAAG,CAAC;EAE3E;EACA,MAAM6C,UAAU,GAAG,IAAIjF,UAAU,EAAE;EAEnCiF,UAAU,CAAC5C,OAAO,GAAGA,OAAO;EAC5B4C,UAAU,CAAC/C,SAAS,GAAGA,SAAS;EAChC+C,UAAU,CAAC9C,OAAO,GAAGA,OAAO;EAC5B8C,UAAU,CAAC7C,GAAG,GAAGA,GAAG;EAEpB,IAAI5B,UAAU,EAAE;IACZ,MAAM0E,WAAW,GAAG3D,eAAe,KAAKvB,UAAU,CAACmF,UAAU,GAAG7C,MAAM,CAACgB,MAAM,CAAChB,MAAM,CAAC,GAAGA,MAAM;IAC9F2C,UAAU,CAAC3C,MAAM,GAAG4C,WAAW;;EAGnC,OAAOD,UAAU;AACrB;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA,OAAM,SAAUG,cAAc,CAC1BC,IAAY,EACZjF,OAcC,EACDkF,QAAyB,IAAI;EAE7B,MAAMC,GAAG,GAAG,IAAIxF,IAAI,CAACsF,IAAI,EAAEC,KAAK,CAAC;EAEjClF,OAAO,CAACmB,eAAe,GAAGxB,IAAI,CAACyF,0BAA0B,CAACpF,OAAO,CAACmB,eAAe,CAAC;EAClFgE,GAAG,CAACE,+BAA+B,GAAGrF,OAAO,CAACmB,eAAe;EAE7D,MAAM0D,UAAU,GAAG9E,wBAAwB,CAACC,OAAO,CAAC;EAEpD6E,UAAU,CAACS,WAAW,CAACH,GAAG,EAAEnF,OAAO,CAACuF,SAAS,CAAC;EAE9C,OAAOJ,GAAG;AACd;AAEA;;;;AAIA,OAAO,MAAMK,eAAe,GAAG;EAC3B;EACAR;CACH;AAEDpF,UAAU,CAACoF,cAAc,GAAGjF,wBAAwB","names":["Matrix","Vector3","Vector4","Color4","Mesh","VertexData","CreateTiledPlaneVertexData","CompatibilityOptions","CreateTiledBoxVertexData","options","nbFaces","faceUV","Array","faceColors","flipTile","pattern","NO_FLIP","width","size","height","depth","tileWidth","tileSize","tileHeight","alignH","alignHorizontal","alignV","alignVertical","sideOrientation","DEFAULTSIDE","f","undefined","halfWidth","halfHeight","halfDepth","faceVertexData","baseAlignV","BOTTOM","TOP","positions","normals","uvs","indices","colors","facePositions","faceNormals","newFaceUV","lu","li","len","length","p","push","i","x","z","y","w","UseOpenGLOrientationForUV","concat","map","c","r","g","b","a","vec0","mtrx0","RotationY","Math","PI","entry","TransformNormal","add","reduce","accumulator","currentValue","subtract","vec2","mtrx2","mtrx3","vec4","mtrx4","RotationX","mtrx5","_ComputeSides","vertexData","totalColors","DOUBLESIDE","CreateTiledBox","name","scene","box","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","TiledBoxBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/tiledBoxBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CreateTiledPlaneVertexData } from \"./tiledPlaneBuilder\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled box\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * @param options.pattern\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @returns the VertexData of the TiledBox\r\n */\r\nexport function CreateTiledBoxVertexData(options: {\r\n    pattern?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const halfWidth = width / 2;\r\n    const halfHeight = height / 2;\r\n    const halfDepth = depth / 2;\r\n\r\n    const faceVertexData: Array<VertexData> = [];\r\n\r\n    for (let f = 0; f < 2; f++) {\r\n        //front and back\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    for (let f = 2; f < 4; f++) {\r\n        //sides\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: depth,\r\n            height: height,\r\n            alignVertical: alignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let baseAlignV = alignV;\r\n    if (alignV === Mesh.BOTTOM) {\r\n        baseAlignV = Mesh.TOP;\r\n    } else if (alignV === Mesh.TOP) {\r\n        baseAlignV = Mesh.BOTTOM;\r\n    }\r\n\r\n    for (let f = 4; f < 6; f++) {\r\n        //top and bottom\r\n        faceVertexData[f] = CreateTiledPlaneVertexData({\r\n            pattern: flipTile,\r\n            tileWidth: tileWidth,\r\n            tileHeight: tileHeight,\r\n            width: width,\r\n            height: depth,\r\n            alignVertical: baseAlignV,\r\n            alignHorizontal: alignH,\r\n            sideOrientation: sideOrientation,\r\n        });\r\n    }\r\n\r\n    let positions: Array<number> = [];\r\n    let normals: Array<number> = [];\r\n    let uvs: Array<number> = [];\r\n    let indices: Array<number> = [];\r\n    const colors: Array<number> = [];\r\n    const facePositions: Array<Array<Vector3>> = [];\r\n    const faceNormals: Array<Array<Vector3>> = [];\r\n\r\n    const newFaceUV: Array<Array<number>> = [];\r\n    let lu: number = 0;\r\n\r\n    let li: number = 0;\r\n\r\n    for (let f = 0; f < nbFaces; f++) {\r\n        const len = faceVertexData[f].positions!.length;\r\n        facePositions[f] = [];\r\n        faceNormals[f] = [];\r\n        for (let p = 0; p < len / 3; p++) {\r\n            facePositions[f].push(new Vector3(faceVertexData[f].positions![3 * p], faceVertexData[f].positions![3 * p + 1], faceVertexData[f].positions![3 * p + 2]));\r\n            faceNormals[f].push(new Vector3(faceVertexData[f].normals![3 * p], faceVertexData[f].normals![3 * p + 1], faceVertexData[f].normals![3 * p + 2]));\r\n        }\r\n        // uvs\r\n        lu = faceVertexData[f].uvs!.length;\r\n        newFaceUV[f] = [];\r\n        for (let i = 0; i < lu; i += 2) {\r\n            newFaceUV[f][i] = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * faceVertexData[f].uvs![i];\r\n            newFaceUV[f][i + 1] = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * faceVertexData[f].uvs![i + 1];\r\n\r\n            if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                newFaceUV[f][i + 1] = 1.0 - newFaceUV[f][i + 1];\r\n            }\r\n        }\r\n        uvs = uvs.concat(newFaceUV[f]);\r\n\r\n        indices = indices.concat(<Array<number>>faceVertexData[f].indices!.map((x: number) => x + li));\r\n        li += facePositions[f].length;\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    const vec0 = new Vector3(0, 0, halfDepth);\r\n    const mtrx0 = Matrix.RotationY(Math.PI);\r\n    positions = facePositions[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0).add(vec0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    normals = faceNormals[0]\r\n        .map((entry) => Vector3.TransformNormal(entry, mtrx0))\r\n        .map((entry) => [entry.x, entry.y, entry.z])\r\n        .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []);\r\n    positions = positions.concat(\r\n        facePositions[1]\r\n            .map((entry) => entry.subtract(vec0))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(faceNormals[1].map((entry) => [entry.x, entry.y, entry.z]).reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), []));\r\n\r\n    const vec2 = new Vector3(halfWidth, 0, 0);\r\n    const mtrx2 = Matrix.RotationY(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2).add(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[2]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx3 = Matrix.RotationY(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3).subtract(vec2))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[3]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx3))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    const vec4 = new Vector3(0, halfHeight, 0);\r\n    const mtrx4 = Matrix.RotationX(Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4).add(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[4]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    const mtrx5 = Matrix.RotationX(-Math.PI / 2);\r\n    positions = positions.concat(\r\n        facePositions[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5).subtract(vec4))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n    normals = normals.concat(\r\n        faceNormals[5]\r\n            .map((entry) => Vector3.TransformNormal(entry, mtrx5))\r\n            .map((entry) => [entry.x, entry.y, entry.z])\r\n            .reduce((accumulator: Array<number>, currentValue) => accumulator.concat(currentValue), [])\r\n    );\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled box mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_box\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled box, required but can be empty\r\n * * pattern sets the rotation or reflection pattern for the tiles,\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * depth of the box, overwrites size\r\n * * tileSize sets the size of a tile\r\n * * tileWidth sets the tile width and overwrites tileSize\r\n * * tileHeight sets the tile width and overwrites tileSize\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param options.pattern\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledBox(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledBox instead\r\n */\r\nexport const TiledBoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledBox,\r\n};\r\n\r\nVertexData.CreateTiledBox = CreateTiledBoxVertexData;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}