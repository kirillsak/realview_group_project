{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Ray } from \"../Culling/ray.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { LensFlare } from \"./lensFlare.js\";\nimport \"../Shaders/lensFlare.fragment.js\";\nimport \"../Shaders/lensFlare.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n * It is usually composed of several `lensFlare`.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n */\nexport class LensFlareSystem {\n  /**\n   * Instantiates a lens flare system.\n   * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\n   * It is usually composed of several `lensFlare`.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\n   * @param name Define the name of the lens flare system in the scene\n   * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\n   * @param scene Define the scene the lens flare system belongs to\n   */\n  constructor(\n  /**\n   * Define the name of the lens flare system\n   */\n  name, emitter, scene) {\n    this.name = name;\n    /**\n     * List of lens flares used in this system.\n     */\n    this.lensFlares = new Array();\n    /**\n     * Define a limit from the border the lens flare can be visible.\n     */\n    this.borderLimit = 300;\n    /**\n     * Define a viewport border we do not want to see the lens flare in.\n     */\n    this.viewportBorder = 0;\n    /**\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\n     */\n    this.layerMask = 0x0fffffff;\n    this._vertexBuffers = {};\n    this._isEnabled = true;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    LensFlareSystem._SceneComponentInitialization(this._scene);\n    this._emitter = emitter;\n    this.id = name;\n    scene.lensFlareSystems.push(this);\n    this.meshesSelectionPredicate = m => scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0;\n    const engine = scene.getEngine();\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    // Indices\n    this._createIndexBuffer();\n  }\n  /** Gets the scene */\n  get scene() {\n    return this._scene;\n  }\n  _createIndexBuffer() {\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n  }\n  /**\n   * Define if the lens flare system is enabled.\n   */\n  get isEnabled() {\n    return this._isEnabled;\n  }\n  set isEnabled(value) {\n    this._isEnabled = value;\n  }\n  /**\n   * Get the scene the effects belongs to.\n   * @returns the scene holding the lens flare system\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Get the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the emitter of the lens flare system\n   */\n  getEmitter() {\n    return this._emitter;\n  }\n  /**\n   * Set the emitter of the lens flare system.\n   * It defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @param newEmitter Define the new emitter of the system\n   */\n  setEmitter(newEmitter) {\n    this._emitter = newEmitter;\n  }\n  /**\n   * Get the lens flare system emitter position.\n   * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\n   * @returns the position\n   */\n  getEmitterPosition() {\n    return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n  }\n  /**\n   * @internal\n   */\n  computeEffectivePosition(globalViewport) {\n    let position = this.getEmitterPosition();\n    position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n    this._positionX = position.x;\n    this._positionY = position.y;\n    position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n    if (this.viewportBorder > 0) {\n      globalViewport.x -= this.viewportBorder;\n      globalViewport.y -= this.viewportBorder;\n      globalViewport.width += this.viewportBorder * 2;\n      globalViewport.height += this.viewportBorder * 2;\n      position.x += this.viewportBorder;\n      position.y += this.viewportBorder;\n      this._positionX += this.viewportBorder;\n      this._positionY += this.viewportBorder;\n    }\n    const rhs = this._scene.useRightHandedSystem;\n    const okZ = position.z > 0 && !rhs || position.z < 0 && rhs;\n    if (okZ) {\n      if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\n        if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\n          return true;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  /** @internal */\n  _isVisible() {\n    if (!this._isEnabled || !this._scene.activeCamera) {\n      return false;\n    }\n    const emitterPosition = this.getEmitterPosition();\n    const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n    const distance = direction.length();\n    direction.normalize();\n    const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\n    const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n    return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\n  }\n  /**\n   * @internal\n   */\n  render() {\n    if (!this._scene.activeCamera) {\n      return false;\n    }\n    const engine = this._scene.getEngine();\n    const viewport = this._scene.activeCamera.viewport;\n    const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\n    // Position\n    if (!this.computeEffectivePosition(globalViewport)) {\n      return false;\n    }\n    // Visibility\n    if (!this._isVisible()) {\n      return false;\n    }\n    // Intensity\n    let awayX;\n    let awayY;\n    if (this._positionX < this.borderLimit + globalViewport.x) {\n      awayX = this.borderLimit + globalViewport.x - this._positionX;\n    } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n      awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n    } else {\n      awayX = 0;\n    }\n    if (this._positionY < this.borderLimit + globalViewport.y) {\n      awayY = this.borderLimit + globalViewport.y - this._positionY;\n    } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n      awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n    } else {\n      awayY = 0;\n    }\n    let away = awayX > awayY ? awayX : awayY;\n    away -= this.viewportBorder;\n    if (away > this.borderLimit) {\n      away = this.borderLimit;\n    }\n    let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\n    if (intensity < 0) {\n      return false;\n    }\n    if (intensity > 1.0) {\n      intensity = 1.0;\n    }\n    if (this.viewportBorder > 0) {\n      globalViewport.x += this.viewportBorder;\n      globalViewport.y += this.viewportBorder;\n      globalViewport.width -= this.viewportBorder * 2;\n      globalViewport.height -= this.viewportBorder * 2;\n      this._positionX -= this.viewportBorder;\n      this._positionY -= this.viewportBorder;\n    }\n    // Position\n    const centerX = globalViewport.x + globalViewport.width / 2;\n    const centerY = globalViewport.y + globalViewport.height / 2;\n    const distX = centerX - this._positionX;\n    const distY = centerY - this._positionY;\n    // Effects\n    engine.setState(false);\n    engine.setDepthBuffer(false);\n    // Flares\n    for (let index = 0; index < this.lensFlares.length; index++) {\n      const flare = this.lensFlares[index];\n      if (!flare._drawWrapper.effect.isReady() || flare.texture && !flare.texture.isReady()) {\n        continue;\n      }\n      engine.enableEffect(flare._drawWrapper);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect);\n      engine.setAlphaMode(flare.alphaMode);\n      const x = centerX - distX * flare.position;\n      const y = centerY - distY * flare.position;\n      const cw = flare.size;\n      const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n      const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n      const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n      const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n      flare._drawWrapper.effect.setMatrix(\"viewportMatrix\", viewportMatrix);\n      // Texture\n      flare._drawWrapper.effect.setTexture(\"textureSampler\", flare.texture);\n      // Color\n      flare._drawWrapper.effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\n      // Draw order\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    engine.setDepthBuffer(true);\n    engine.setAlphaMode(0);\n    return true;\n  }\n  /**\n   * Rebuilds the lens flare system\n   */\n  rebuild() {\n    var _a;\n    this._createIndexBuffer();\n    for (const key in this._vertexBuffers) {\n      (_a = this._vertexBuffers[key]) === null || _a === void 0 ? void 0 : _a._rebuild();\n    }\n  }\n  /**\n   * Dispose and release the lens flare with its associated resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    while (this.lensFlares.length) {\n      this.lensFlares[0].dispose();\n    }\n    // Remove from scene\n    const index = this._scene.lensFlareSystems.indexOf(this);\n    this._scene.lensFlareSystems.splice(index, 1);\n  }\n  /**\n   * Parse a lens flare system from a JSON representation\n   * @param parsedLensFlareSystem Define the JSON to parse\n   * @param scene Define the scene the parsed system should be instantiated in\n   * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\n   * @returns the parsed system\n   */\n  static Parse(parsedLensFlareSystem, scene, rootUrl) {\n    const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\n    const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n    const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n    lensFlareSystem.id = parsedLensFlareSystem.id || name;\n    lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n    for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n      const parsedFlare = parsedLensFlareSystem.flares[index];\n      LensFlare.AddFlare(parsedFlare.size, parsedFlare.position, Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n    }\n    return lensFlareSystem;\n  }\n  /**\n   * Serialize the current Lens Flare System into a JSON representation.\n   * @returns the serialized JSON\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.name = this.name;\n    serializationObject.emitterId = this.getEmitter().id;\n    serializationObject.borderLimit = this.borderLimit;\n    serializationObject.flares = [];\n    for (let index = 0; index < this.lensFlares.length; index++) {\n      const flare = this.lensFlares[index];\n      serializationObject.flares.push({\n        size: flare.size,\n        position: flare.position,\n        color: flare.color.asArray(),\n        textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\")\n      });\n    }\n    return serializationObject;\n  }\n}\n/**\n * @internal\n */\nLensFlareSystem._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"LensFlareSystemSceneComponent\");\n};","map":{"version":3,"mappings":"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","names":["Tools","Matrix","Vector3","Scalar","EngineStore","VertexBuffer","Ray","Material","LensFlare","_WarnImport","Color3","LensFlareSystem","constructor","name","emitter","scene","Array","_scene","LastCreatedScene","_SceneComponentInitialization","_emitter","id","lensFlareSystems","push","meshesSelectionPredicate","m","activeCamera","material","isVisible","isEnabled","isBlocker","layerMask","engine","getEngine","vertices","_vertexBuffers","PositionKind","_createIndexBuffer","indices","_indexBuffer","createIndexBuffer","_isEnabled","value","getScene","getEmitter","setEmitter","newEmitter","getEmitterPosition","getAbsolutePosition","position","computeEffectivePosition","globalViewport","Project","Identity","getTransformMatrix","_positionX","x","_positionY","y","TransformCoordinates","getViewMatrix","viewportBorder","width","height","rhs","useRightHandedSystem","okZ","z","_isVisible","emitterPosition","direction","subtract","globalPosition","distance","length","normalize","ray","pickInfo","pickWithRay","hit","render","viewport","toGlobal","getRenderWidth","getRenderHeight","awayX","awayY","borderLimit","away","intensity","Clamp","centerX","centerY","distX","distY","setState","setDepthBuffer","index","lensFlares","flare","_drawWrapper","effect","isReady","texture","enableEffect","bindBuffers","setAlphaMode","alphaMode","cw","size","ch","getAspectRatio","cx","cy","viewportMatrix","FromValues","setMatrix","setTexture","setFloat4","color","r","g","b","drawElementsType","TriangleFillMode","rebuild","key","_rebuild","dispose","vertexBuffer","_releaseBuffer","indexOf","splice","Parse","parsedLensFlareSystem","rootUrl","getLastEntryById","emitterId","lensFlareSystem","flares","parsedFlare","AddFlare","FromArray","textureName","serialize","serializationObject","asArray","GetFilename","_"],"sourceRoot":"","sources":["../../../../lts/core/generated/LensFlares/lensFlareSystem.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { LensFlare } from \"./lensFlare\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/lensFlare.fragment\";\r\nimport \"../Shaders/lensFlare.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { Viewport } from \"../Maths/math.viewport\";\r\n\r\n/**\r\n * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n * It is usually composed of several `lensFlare`.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n */\r\nexport class LensFlareSystem {\r\n    /**\r\n     * List of lens flares used in this system.\r\n     */\r\n    public lensFlares = new Array<LensFlare>();\r\n\r\n    /**\r\n     * Define a limit from the border the lens flare can be visible.\r\n     */\r\n    public borderLimit = 300;\r\n\r\n    /**\r\n     * Define a viewport border we do not want to see the lens flare in.\r\n     */\r\n    public viewportBorder = 0;\r\n\r\n    /**\r\n     * Define a predicate which could limit the list of meshes able to occlude the effect.\r\n     */\r\n    public meshesSelectionPredicate: (mesh: AbstractMesh) => boolean;\r\n\r\n    /**\r\n     * Restricts the rendering of the effect to only the camera rendering this layer mask.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /** Gets the scene */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Define the id of the lens flare system in the scene.\r\n     * (equal to name by default)\r\n     */\r\n    public id: string;\r\n\r\n    private _scene: Scene;\r\n    private _emitter: any;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _positionX: number;\r\n    private _positionY: number;\r\n    private _isEnabled = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"LensFlareSystemSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Instantiates a lens flare system.\r\n     * This represents a Lens Flare System or the shiny effect created by the light reflection on the  camera lenses.\r\n     * It is usually composed of several `lensFlare`.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/lenseFlare\r\n     * @param name Define the name of the lens flare system in the scene\r\n     * @param emitter Define the source (the emitter) of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param scene Define the scene the lens flare system belongs to\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the lens flare system\r\n         */\r\n        public name: string,\r\n        emitter: any,\r\n        scene: Scene\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        LensFlareSystem._SceneComponentInitialization(this._scene);\r\n\r\n        this._emitter = emitter;\r\n        this.id = name;\r\n        scene.lensFlareSystems.push(this);\r\n\r\n        this.meshesSelectionPredicate = (m) =>\r\n            <boolean>(scene.activeCamera && m.material && m.isVisible && m.isEnabled() && m.isBlocker && (m.layerMask & scene.activeCamera.layerMask) != 0);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        // Indices\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Define if the lens flare system is enabled.\r\n     */\r\n    public get isEnabled(): boolean {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    public set isEnabled(value: boolean) {\r\n        this._isEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the effects belongs to.\r\n     * @returns the scene holding the lens flare system\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Get the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the emitter of the lens flare system\r\n     */\r\n    public getEmitter(): any {\r\n        return this._emitter;\r\n    }\r\n\r\n    /**\r\n     * Set the emitter of the lens flare system.\r\n     * It defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @param newEmitter Define the new emitter of the system\r\n     */\r\n    public setEmitter(newEmitter: any): void {\r\n        this._emitter = newEmitter;\r\n    }\r\n\r\n    /**\r\n     * Get the lens flare system emitter position.\r\n     * The emitter defines the source of the lens flares (it can be a camera, a light or a mesh).\r\n     * @returns the position\r\n     */\r\n    public getEmitterPosition(): Vector3 {\r\n        return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public computeEffectivePosition(globalViewport: Viewport): boolean {\r\n        let position = this.getEmitterPosition();\r\n\r\n        position = Vector3.Project(position, Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\r\n\r\n        this._positionX = position.x;\r\n        this._positionY = position.y;\r\n\r\n        position = Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x -= this.viewportBorder;\r\n            globalViewport.y -= this.viewportBorder;\r\n            globalViewport.width += this.viewportBorder * 2;\r\n            globalViewport.height += this.viewportBorder * 2;\r\n            position.x += this.viewportBorder;\r\n            position.y += this.viewportBorder;\r\n            this._positionX += this.viewportBorder;\r\n            this._positionY += this.viewportBorder;\r\n        }\r\n\r\n        const rhs = this._scene.useRightHandedSystem;\r\n        const okZ = (position.z > 0 && !rhs) || (position.z < 0 && rhs);\r\n\r\n        if (okZ) {\r\n            if (this._positionX > globalViewport.x && this._positionX < globalViewport.x + globalViewport.width) {\r\n                if (this._positionY > globalViewport.y && this._positionY < globalViewport.y + globalViewport.height) {\r\n                    return true;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isVisible(): boolean {\r\n        if (!this._isEnabled || !this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const emitterPosition = this.getEmitterPosition();\r\n        const direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\r\n        const distance = direction.length();\r\n        direction.normalize();\r\n\r\n        const ray = new Ray(this._scene.activeCamera.globalPosition, direction);\r\n        const pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\r\n\r\n        return !pickInfo || !pickInfo.hit || pickInfo.distance > distance;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public render(): boolean {\r\n        if (!this._scene.activeCamera) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const viewport = this._scene.activeCamera.viewport;\r\n        const globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\r\n\r\n        // Position\r\n        if (!this.computeEffectivePosition(globalViewport)) {\r\n            return false;\r\n        }\r\n\r\n        // Visibility\r\n        if (!this._isVisible()) {\r\n            return false;\r\n        }\r\n\r\n        // Intensity\r\n        let awayX;\r\n        let awayY;\r\n\r\n        if (this._positionX < this.borderLimit + globalViewport.x) {\r\n            awayX = this.borderLimit + globalViewport.x - this._positionX;\r\n        } else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\r\n            awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\r\n        } else {\r\n            awayX = 0;\r\n        }\r\n\r\n        if (this._positionY < this.borderLimit + globalViewport.y) {\r\n            awayY = this.borderLimit + globalViewport.y - this._positionY;\r\n        } else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\r\n            awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\r\n        } else {\r\n            awayY = 0;\r\n        }\r\n\r\n        let away = awayX > awayY ? awayX : awayY;\r\n\r\n        away -= this.viewportBorder;\r\n\r\n        if (away > this.borderLimit) {\r\n            away = this.borderLimit;\r\n        }\r\n\r\n        let intensity = 1.0 - Scalar.Clamp(away / this.borderLimit, 0, 1);\r\n        if (intensity < 0) {\r\n            return false;\r\n        }\r\n\r\n        if (intensity > 1.0) {\r\n            intensity = 1.0;\r\n        }\r\n\r\n        if (this.viewportBorder > 0) {\r\n            globalViewport.x += this.viewportBorder;\r\n            globalViewport.y += this.viewportBorder;\r\n            globalViewport.width -= this.viewportBorder * 2;\r\n            globalViewport.height -= this.viewportBorder * 2;\r\n            this._positionX -= this.viewportBorder;\r\n            this._positionY -= this.viewportBorder;\r\n        }\r\n\r\n        // Position\r\n        const centerX = globalViewport.x + globalViewport.width / 2;\r\n        const centerY = globalViewport.y + globalViewport.height / 2;\r\n        const distX = centerX - this._positionX;\r\n        const distY = centerY - this._positionY;\r\n\r\n        // Effects\r\n        engine.setState(false);\r\n        engine.setDepthBuffer(false);\r\n\r\n        // Flares\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            if (!flare._drawWrapper.effect!.isReady() || (flare.texture && !flare.texture.isReady())) {\r\n                continue;\r\n            }\r\n\r\n            engine.enableEffect(flare._drawWrapper);\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, flare._drawWrapper.effect!);\r\n\r\n            engine.setAlphaMode(flare.alphaMode);\r\n\r\n            const x = centerX - distX * flare.position;\r\n            const y = centerY - distY * flare.position;\r\n\r\n            const cw = flare.size;\r\n            const ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\r\n            const cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\r\n            const cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\r\n\r\n            const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\r\n\r\n            flare._drawWrapper.effect!.setMatrix(\"viewportMatrix\", viewportMatrix);\r\n\r\n            // Texture\r\n            flare._drawWrapper.effect!.setTexture(\"textureSampler\", flare.texture);\r\n\r\n            // Color\r\n            flare._drawWrapper.effect!.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        engine.setDepthBuffer(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the lens flare system\r\n     */\r\n    public rebuild(): void {\r\n        this._createIndexBuffer();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]?._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the lens flare with its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        while (this.lensFlares.length) {\r\n            this.lensFlares[0].dispose();\r\n        }\r\n\r\n        // Remove from scene\r\n        const index = this._scene.lensFlareSystems.indexOf(this);\r\n        this._scene.lensFlareSystems.splice(index, 1);\r\n    }\r\n\r\n    /**\r\n     * Parse a lens flare system from a JSON representation\r\n     * @param parsedLensFlareSystem Define the JSON to parse\r\n     * @param scene Define the scene the parsed system should be instantiated in\r\n     * @param rootUrl Define the rootUrl of the load sequence to easily find a load relative dependencies such as textures\r\n     * @returns the parsed system\r\n     */\r\n    public static Parse(parsedLensFlareSystem: any, scene: Scene, rootUrl: string): LensFlareSystem {\r\n        const emitter = scene.getLastEntryById(parsedLensFlareSystem.emitterId);\r\n\r\n        const name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\r\n\r\n        const lensFlareSystem = new LensFlareSystem(name, emitter, scene);\r\n\r\n        lensFlareSystem.id = parsedLensFlareSystem.id || name;\r\n        lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\r\n\r\n        for (let index = 0; index < parsedLensFlareSystem.flares.length; index++) {\r\n            const parsedFlare = parsedLensFlareSystem.flares[index];\r\n            LensFlare.AddFlare(\r\n                parsedFlare.size,\r\n                parsedFlare.position,\r\n                Color3.FromArray(parsedFlare.color),\r\n                parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\",\r\n                lensFlareSystem\r\n            );\r\n        }\r\n\r\n        return lensFlareSystem;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current Lens Flare System into a JSON representation.\r\n     * @returns the serialized JSON\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.name = this.name;\r\n\r\n        serializationObject.emitterId = this.getEmitter().id;\r\n        serializationObject.borderLimit = this.borderLimit;\r\n\r\n        serializationObject.flares = [];\r\n        for (let index = 0; index < this.lensFlares.length; index++) {\r\n            const flare = this.lensFlares[index];\r\n\r\n            serializationObject.flares.push({\r\n                size: flare.size,\r\n                position: flare.position,\r\n                color: flare.color.asArray(),\r\n                textureName: Tools.GetFilename(flare.texture ? flare.texture.name : \"\"),\r\n            });\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}