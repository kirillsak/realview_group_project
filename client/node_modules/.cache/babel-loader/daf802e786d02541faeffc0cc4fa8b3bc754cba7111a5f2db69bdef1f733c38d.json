{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Observable } from \"./observable.js\";\n/**\n * Defines the root class used to create scene optimization to use with SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimization {\n  /**\n   * Creates the SceneOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   */\n  constructor(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority = 0) {\n    this.priority = priority;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    return true;\n  }\n}\n/**\n * Defines an optimization used to reduce the size of render target textures\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class TextureOptimization extends SceneOptimization {\n  /**\n   * Creates the TextureOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n   * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n   */\n  constructor(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority = 0,\n  /**\n   * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\n   */\n  maximumSize = 1024,\n  /**\n   * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\n   */\n  step = 0.5) {\n    super(priority);\n    this.priority = priority;\n    this.maximumSize = maximumSize;\n    this.step = step;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Reducing render target texture size to \" + this.maximumSize;\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    let allDone = true;\n    for (let index = 0; index < scene.textures.length; index++) {\n      const texture = scene.textures[index];\n      if (!texture.canRescale || texture.getContext) {\n        continue;\n      }\n      const currentSize = texture.getSize();\n      const maxDimension = Math.max(currentSize.width, currentSize.height);\n      if (maxDimension > this.maximumSize) {\n        texture.scale(this.step);\n        allDone = false;\n      }\n    }\n    return allDone;\n  }\n}\n/**\n * Defines an optimization used to increase or decrease the rendering resolution\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class HardwareScalingOptimization extends SceneOptimization {\n  /**\n   * Creates the HardwareScalingOptimization object\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @param maximumScale defines the maximum scale to use (2 by default)\n   * @param step defines the step to use between two passes (0.5 by default)\n   */\n  constructor(\n  /**\n   * Defines the priority of this optimization (0 by default which means first in the list)\n   */\n  priority = 0,\n  /**\n   * Defines the maximum scale to use (2 by default)\n   */\n  maximumScale = 2,\n  /**\n   * Defines the step to use between two passes (0.5 by default)\n   */\n  step = 0.25) {\n    super(priority);\n    this.priority = priority;\n    this.maximumScale = maximumScale;\n    this.step = step;\n    this._currentScale = -1;\n    this._directionOffset = 1;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Setting hardware scaling level to \" + this._currentScale;\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    if (this._currentScale === -1) {\n      this._currentScale = scene.getEngine().getHardwareScalingLevel();\n      if (this._currentScale > this.maximumScale) {\n        this._directionOffset = -1;\n      }\n    }\n    this._currentScale += this._directionOffset * this.step;\n    scene.getEngine().setHardwareScalingLevel(this._currentScale);\n    return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\n  }\n}\n/**\n * Defines an optimization used to remove shadows\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ShadowsOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning shadows on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.shadowsEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn post-processes off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class PostProcessesOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning post-processes on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.postProcessesEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn lens flares off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class LensFlaresOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning lens flares on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.lensFlaresEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization based on user defined callback.\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class CustomOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    if (this.onGetDescription) {\n      return this.onGetDescription();\n    }\n    return \"Running user defined callback\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    if (this.onApply) {\n      return this.onApply(scene, optimizer);\n    }\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn particles off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class ParticlesOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning particles on/off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.particlesEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to turn render targets off\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class RenderTargetsOptimization extends SceneOptimization {\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Turning render targets off\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer) {\n    scene.renderTargetsEnabled = optimizer.isInImprovementMode;\n    return true;\n  }\n}\n/**\n * Defines an optimization used to merge meshes with compatible materials\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class MergeMeshesOptimization extends SceneOptimization {\n  constructor() {\n    super(...arguments);\n    this._canBeMerged = abstractMesh => {\n      if (!(abstractMesh instanceof Mesh)) {\n        return false;\n      }\n      const mesh = abstractMesh;\n      if (mesh.isDisposed()) {\n        return false;\n      }\n      if (!mesh.isVisible || !mesh.isEnabled()) {\n        return false;\n      }\n      if (mesh.instances.length > 0) {\n        return false;\n      }\n      if (mesh.skeleton || mesh.hasLODLevels) {\n        return false;\n      }\n      return true;\n    };\n  }\n  /**\n   * Gets or sets a boolean which defines if optimization octree has to be updated\n   */\n  static get UpdateSelectionTree() {\n    return MergeMeshesOptimization._UpdateSelectionTree;\n  }\n  /**\n   * Gets or sets a boolean which defines if optimization octree has to be updated\n   */\n  static set UpdateSelectionTree(value) {\n    MergeMeshesOptimization._UpdateSelectionTree = value;\n  }\n  /**\n   * Gets a string describing the action executed by the current optimization\n   * @returns description string\n   */\n  getDescription() {\n    return \"Merging similar meshes together\";\n  }\n  /**\n   * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\n   * @param scene defines the current scene where to apply this optimization\n   * @param optimizer defines the current optimizer\n   * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\n   * @returns true if everything that can be done was applied\n   */\n  apply(scene, optimizer, updateSelectionTree) {\n    const globalPool = scene.meshes.slice(0);\n    let globalLength = globalPool.length;\n    for (let index = 0; index < globalLength; index++) {\n      const currentPool = new Array();\n      const current = globalPool[index];\n      // Checks\n      if (!this._canBeMerged(current)) {\n        continue;\n      }\n      currentPool.push(current);\n      // Find compatible meshes\n      for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {\n        const otherMesh = globalPool[subIndex];\n        if (!this._canBeMerged(otherMesh)) {\n          continue;\n        }\n        if (otherMesh.material !== current.material) {\n          continue;\n        }\n        if (otherMesh.checkCollisions !== current.checkCollisions) {\n          continue;\n        }\n        currentPool.push(otherMesh);\n        globalLength--;\n        globalPool.splice(subIndex, 1);\n        subIndex--;\n      }\n      if (currentPool.length < 2) {\n        continue;\n      }\n      // Merge meshes\n      Mesh.MergeMeshes(currentPool, undefined, true);\n    }\n    // Call the octree system optimization if it is defined.\n    const sceneAsAny = scene;\n    if (sceneAsAny.createOrUpdateSelectionOctree) {\n      if (updateSelectionTree != undefined) {\n        if (updateSelectionTree) {\n          sceneAsAny.createOrUpdateSelectionOctree();\n        }\n      } else if (MergeMeshesOptimization.UpdateSelectionTree) {\n        sceneAsAny.createOrUpdateSelectionOctree();\n      }\n    }\n    return true;\n  }\n}\nMergeMeshesOptimization._UpdateSelectionTree = false;\n/**\n * Defines a list of options used by SceneOptimizer\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizerOptions {\n  /**\n   * Creates a new list of options used by SceneOptimizer\n   * @param targetFrameRate defines the target frame rate to reach (60 by default)\n   * @param trackerDuration defines the interval between two checks (2000ms by default)\n   */\n  constructor(\n  /**\n   * Defines the target frame rate to reach (60 by default)\n   */\n  targetFrameRate = 60,\n  /**\n   * Defines the interval between two checks (2000ms by default)\n   */\n  trackerDuration = 2000) {\n    this.targetFrameRate = targetFrameRate;\n    this.trackerDuration = trackerDuration;\n    /**\n     * Gets the list of optimizations to apply\n     */\n    this.optimizations = new Array();\n  }\n  /**\n   * Add a new optimization\n   * @param optimization defines the SceneOptimization to add to the list of active optimizations\n   * @returns the current SceneOptimizerOptions\n   */\n  addOptimization(optimization) {\n    this.optimizations.push(optimization);\n    return this;\n  }\n  /**\n   * Add a new custom optimization\n   * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\n   * @param onGetDescription defines the callback called to get the description attached with the optimization.\n   * @param priority defines the priority of this optimization (0 by default which means first in the list)\n   * @returns the current SceneOptimizerOptions\n   */\n  addCustomOptimization(onApply, onGetDescription, priority = 0) {\n    const optimization = new CustomOptimization(priority);\n    optimization.onApply = onApply;\n    optimization.onGetDescription = onGetDescription;\n    this.optimizations.push(optimization);\n    return this;\n  }\n  /**\n   * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n  static LowDegradationAllowed(targetFrameRate) {\n    const result = new SceneOptimizerOptions(targetFrameRate);\n    let priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 1024));\n    return result;\n  }\n  /**\n   * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n  static ModerateDegradationAllowed(targetFrameRate) {\n    const result = new SceneOptimizerOptions(targetFrameRate);\n    let priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 512));\n    // Next priority\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 2));\n    return result;\n  }\n  /**\n   * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\n   * @param targetFrameRate defines the target frame rate (60 by default)\n   * @returns a SceneOptimizerOptions object\n   */\n  static HighDegradationAllowed(targetFrameRate) {\n    const result = new SceneOptimizerOptions(targetFrameRate);\n    let priority = 0;\n    result.addOptimization(new MergeMeshesOptimization(priority));\n    result.addOptimization(new ShadowsOptimization(priority));\n    result.addOptimization(new LensFlaresOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new PostProcessesOptimization(priority));\n    result.addOptimization(new ParticlesOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new TextureOptimization(priority, 256));\n    // Next priority\n    priority++;\n    result.addOptimization(new RenderTargetsOptimization(priority));\n    // Next priority\n    priority++;\n    result.addOptimization(new HardwareScalingOptimization(priority, 4));\n    return result;\n  }\n}\n/**\n * Class used to run optimizations in order to reach a target frame rate\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\n */\nexport class SceneOptimizer {\n  /**\n   * Creates a new SceneOptimizer\n   * @param scene defines the scene to work on\n   * @param options defines the options to use with the SceneOptimizer\n   * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\n   * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\n   */\n  constructor(scene, options, autoGeneratePriorities = true, improvementMode = false) {\n    this._isRunning = false;\n    this._currentPriorityLevel = 0;\n    this._targetFrameRate = 60;\n    this._trackerDuration = 2000;\n    this._currentFrameRate = 0;\n    this._improvementMode = false;\n    /**\n     * Defines an observable called when the optimizer reaches the target frame rate\n     */\n    this.onSuccessObservable = new Observable();\n    /**\n     * Defines an observable called when the optimizer enables an optimization\n     */\n    this.onNewOptimizationAppliedObservable = new Observable();\n    /**\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\n     */\n    this.onFailureObservable = new Observable();\n    if (!options) {\n      this._options = new SceneOptimizerOptions();\n    } else {\n      this._options = options;\n    }\n    if (this._options.targetFrameRate) {\n      this._targetFrameRate = this._options.targetFrameRate;\n    }\n    if (this._options.trackerDuration) {\n      this._trackerDuration = this._options.trackerDuration;\n    }\n    if (autoGeneratePriorities) {\n      let priority = 0;\n      for (const optim of this._options.optimizations) {\n        optim.priority = priority++;\n      }\n    }\n    this._improvementMode = improvementMode;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n      this._sceneDisposeObserver = null;\n      this.dispose();\n    });\n  }\n  /**\n   * Gets or sets a boolean indicating if the optimizer is in improvement mode\n   */\n  get isInImprovementMode() {\n    return this._improvementMode;\n  }\n  set isInImprovementMode(value) {\n    this._improvementMode = value;\n  }\n  /**\n   * Gets the current priority level (0 at start)\n   */\n  get currentPriorityLevel() {\n    return this._currentPriorityLevel;\n  }\n  /**\n   * Gets the current frame rate checked by the SceneOptimizer\n   */\n  get currentFrameRate() {\n    return this._currentFrameRate;\n  }\n  /**\n   * Gets or sets the current target frame rate (60 by default)\n   */\n  get targetFrameRate() {\n    return this._targetFrameRate;\n  }\n  /**\n   * Gets or sets the current target frame rate (60 by default)\n   */\n  set targetFrameRate(value) {\n    this._targetFrameRate = value;\n  }\n  /**\n   * Gets or sets the current interval between two checks (every 2000ms by default)\n   */\n  get trackerDuration() {\n    return this._trackerDuration;\n  }\n  /**\n   * Gets or sets the current interval between two checks (every 2000ms by default)\n   */\n  set trackerDuration(value) {\n    this._trackerDuration = value;\n  }\n  /**\n   * Gets the list of active optimizations\n   */\n  get optimizations() {\n    return this._options.optimizations;\n  }\n  /**\n   * Stops the current optimizer\n   */\n  stop() {\n    this._isRunning = false;\n  }\n  /**\n   * Reset the optimizer to initial step (current priority level = 0)\n   */\n  reset() {\n    this._currentPriorityLevel = 0;\n  }\n  /**\n   * Start the optimizer. By default it will try to reach a specific framerate\n   * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\n   */\n  start() {\n    if (this._isRunning) {\n      return;\n    }\n    this._isRunning = true;\n    // Let's wait for the scene to be ready before running our check\n    this._scene.executeWhenReady(() => {\n      setTimeout(() => {\n        this._checkCurrentState();\n      }, this._trackerDuration);\n    });\n  }\n  _checkCurrentState() {\n    if (!this._isRunning) {\n      return;\n    }\n    const scene = this._scene;\n    const options = this._options;\n    this._currentFrameRate = Math.round(scene.getEngine().getFps());\n    if (this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {\n      this._isRunning = false;\n      this.onSuccessObservable.notifyObservers(this);\n      return;\n    }\n    // Apply current level of optimizations\n    let allDone = true;\n    let noOptimizationApplied = true;\n    for (let index = 0; index < options.optimizations.length; index++) {\n      const optimization = options.optimizations[index];\n      if (optimization.priority === this._currentPriorityLevel) {\n        noOptimizationApplied = false;\n        allDone = allDone && optimization.apply(scene, this);\n        this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\n      }\n    }\n    // If no optimization was applied, this is a failure :(\n    if (noOptimizationApplied) {\n      this._isRunning = false;\n      this.onFailureObservable.notifyObservers(this);\n      return;\n    }\n    // If all optimizations were done, move to next level\n    if (allDone) {\n      this._currentPriorityLevel++;\n    }\n    // Let's the system running for a specific amount of time before checking FPS\n    scene.executeWhenReady(() => {\n      setTimeout(() => {\n        this._checkCurrentState();\n      }, this._trackerDuration);\n    });\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this.stop();\n    this.onSuccessObservable.clear();\n    this.onFailureObservable.clear();\n    this.onNewOptimizationAppliedObservable.clear();\n    if (this._sceneDisposeObserver) {\n      this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n  }\n  /**\n   * Helper function to create a SceneOptimizer with one single line of code\n   * @param scene defines the scene to work on\n   * @param options defines the options to use with the SceneOptimizer\n   * @param onSuccess defines a callback to call on success\n   * @param onFailure defines a callback to call on failure\n   * @returns the new SceneOptimizer object\n   */\n  static OptimizeAsync(scene, options, onSuccess, onFailure) {\n    const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\n    if (onSuccess) {\n      optimizer.onSuccessObservable.add(() => {\n        onSuccess();\n      });\n    }\n    if (onFailure) {\n      optimizer.onFailureObservable.add(() => {\n        onFailure();\n      });\n    }\n    optimizer.start();\n    return optimizer;\n  }\n}","map":{"version":3,"mappings":";AAEA,SAASA,WAAW,QAAQ,2BAAyB;AAErD,SAASC,IAAI,QAAQ,mBAAiB;AAGtC,SAASC,UAAU,QAAQ,iBAAe;AAE1C;;;;AAIA,OAAM,MAAOC,iBAAiB;EAmB1B;;;;EAIAC;EACI;;;EAGOC,WAAmB,CAAC;IAApB,aAAQ,GAARA,QAAQ;EAChB;EA3BH;;;;EAIOC,cAAc;IACjB,OAAO,EAAE;EACb;EAEA;;;;;;EAMOC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChD,OAAO,IAAI;EACf;;AAcJ;;;;AAIA,OAAM,MAAOC,mBAAoB,SAAQP,iBAAiB;EAStD;;;;;;EAMAC;EACI;;;EAGOC,WAAmB,CAAC;EAC3B;;;EAGOM,cAAsB,IAAI;EACjC;;;EAGOC,OAAO,GAAG;IAEjB,KAAK,CAACP,QAAQ,CAAC;IAVR,aAAQ,GAARA,QAAQ;IAIR,gBAAW,GAAXM,WAAW;IAIX,SAAI,GAAJC,IAAI;EAGf;EA7BA;;;;EAION,cAAc;IACjB,OAAO,yCAAyC,GAAG,IAAI,CAACK,WAAW;EACvE;EAyBA;;;;;;EAMOJ,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChD,IAAII,OAAO,GAAG,IAAI;IAClB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGN,KAAK,CAACO,QAAQ,CAACC,MAAM,EAAEF,KAAK,EAAE,EAAE;MACxD,MAAMG,OAAO,GAAGT,KAAK,CAACO,QAAQ,CAACD,KAAK,CAAC;MAErC,IAAI,CAACG,OAAO,CAACC,UAAU,IAAUD,OAAQ,CAACE,UAAU,EAAE;QAClD;;MAGJ,MAAMC,WAAW,GAAGH,OAAO,CAACI,OAAO,EAAE;MACrC,MAAMC,YAAY,GAAGC,IAAI,CAACC,GAAG,CAACJ,WAAW,CAACK,KAAK,EAAEL,WAAW,CAACM,MAAM,CAAC;MAEpE,IAAIJ,YAAY,GAAG,IAAI,CAACX,WAAW,EAAE;QACjCM,OAAO,CAACU,KAAK,CAAC,IAAI,CAACf,IAAI,CAAC;QACxBC,OAAO,GAAG,KAAK;;;IAIvB,OAAOA,OAAO;EAClB;;AAGJ;;;;AAIA,OAAM,MAAOe,2BAA4B,SAAQzB,iBAAiB;EAY9D;;;;;;EAMAC;EACI;;;EAGOC,WAAmB,CAAC;EAC3B;;;EAGOwB,eAAuB,CAAC;EAC/B;;;EAGOjB,OAAe,IAAI;IAE1B,KAAK,CAACP,QAAQ,CAAC;IAVR,aAAQ,GAARA,QAAQ;IAIR,iBAAY,GAAZwB,YAAY;IAIZ,SAAI,GAAJjB,IAAI;IA7BP,kBAAa,GAAG,CAAC,CAAC;IAClB,qBAAgB,GAAG,CAAC;EA+B5B;EA7BA;;;;EAION,cAAc;IACjB,OAAO,oCAAoC,GAAG,IAAI,CAACwB,aAAa;EACpE;EAyBA;;;;;;EAMOvB,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChD,IAAI,IAAI,CAACqB,aAAa,KAAK,CAAC,CAAC,EAAE;MAC3B,IAAI,CAACA,aAAa,GAAGtB,KAAK,CAACuB,SAAS,EAAE,CAACC,uBAAuB,EAAE;MAChE,IAAI,IAAI,CAACF,aAAa,GAAG,IAAI,CAACD,YAAY,EAAE;QACxC,IAAI,CAACI,gBAAgB,GAAG,CAAC,CAAC;;;IAIlC,IAAI,CAACH,aAAa,IAAI,IAAI,CAACG,gBAAgB,GAAG,IAAI,CAACrB,IAAI;IAEvDJ,KAAK,CAACuB,SAAS,EAAE,CAACG,uBAAuB,CAAC,IAAI,CAACJ,aAAa,CAAC;IAE7D,OAAO,IAAI,CAACG,gBAAgB,KAAK,CAAC,GAAG,IAAI,CAACH,aAAa,IAAI,IAAI,CAACD,YAAY,GAAG,IAAI,CAACC,aAAa,IAAI,IAAI,CAACD,YAAY;EAC1H;;AAGJ;;;;AAIA,OAAM,MAAOM,mBAAoB,SAAQhC,iBAAiB;EACtD;;;;EAIOG,cAAc;IACjB,OAAO,wBAAwB;EACnC;EAEA;;;;;;EAMOC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChDD,KAAK,CAAC4B,cAAc,GAAG3B,SAAS,CAAC4B,mBAAmB;IACpD,OAAO,IAAI;EACf;;AAGJ;;;;AAIA,OAAM,MAAOC,yBAA0B,SAAQnC,iBAAiB;EAC5D;;;;EAIOG,cAAc;IACjB,OAAO,+BAA+B;EAC1C;EAEA;;;;;;EAMOC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChDD,KAAK,CAAC+B,oBAAoB,GAAG9B,SAAS,CAAC4B,mBAAmB;IAC1D,OAAO,IAAI;EACf;;AAGJ;;;;AAIA,OAAM,MAAOG,sBAAuB,SAAQrC,iBAAiB;EACzD;;;;EAIOG,cAAc;IACjB,OAAO,4BAA4B;EACvC;EAEA;;;;;;EAMOC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChDD,KAAK,CAACiC,iBAAiB,GAAGhC,SAAS,CAAC4B,mBAAmB;IACvD,OAAO,IAAI;EACf;;AAGJ;;;;AAIA,OAAM,MAAOK,kBAAmB,SAAQvC,iBAAiB;EAWrD;;;;EAIOG,cAAc;IACjB,IAAI,IAAI,CAACqC,gBAAgB,EAAE;MACvB,OAAO,IAAI,CAACA,gBAAgB,EAAE;;IAGlC,OAAO,+BAA+B;EAC1C;EAEA;;;;;;EAMOpC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChD,IAAI,IAAI,CAACmC,OAAO,EAAE;MACd,OAAO,IAAI,CAACA,OAAO,CAACpC,KAAK,EAAEC,SAAS,CAAC;;IAEzC,OAAO,IAAI;EACf;;AAGJ;;;;AAIA,OAAM,MAAOoC,qBAAsB,SAAQ1C,iBAAiB;EACxD;;;;EAIOG,cAAc;IACjB,OAAO,0BAA0B;EACrC;EAEA;;;;;;EAMOC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChDD,KAAK,CAACsC,gBAAgB,GAAGrC,SAAS,CAAC4B,mBAAmB;IACtD,OAAO,IAAI;EACf;;AAGJ;;;;AAIA,OAAM,MAAOU,yBAA0B,SAAQ5C,iBAAiB;EAC5D;;;;EAIOG,cAAc;IACjB,OAAO,4BAA4B;EACvC;EAEA;;;;;;EAMOC,KAAK,CAACC,KAAY,EAAEC,SAAyB;IAChDD,KAAK,CAACwC,oBAAoB,GAAGvC,SAAS,CAAC4B,mBAAmB;IAC1D,OAAO,IAAI;EACf;;AAGJ;;;;AAIA,OAAM,MAAOY,uBAAwB,SAAQ9C,iBAAiB;EAA9DC;;IAyBY,iBAAY,GAAI8C,YAA0B,IAAa;MAC3D,IAAI,EAAEA,YAAY,YAAYjD,IAAI,CAAC,EAAE;QACjC,OAAO,KAAK;;MAGhB,MAAMkD,IAAI,GAASD,YAAY;MAE/B,IAAIC,IAAI,CAACC,UAAU,EAAE,EAAE;QACnB,OAAO,KAAK;;MAGhB,IAAI,CAACD,IAAI,CAACE,SAAS,IAAI,CAACF,IAAI,CAACG,SAAS,EAAE,EAAE;QACtC,OAAO,KAAK;;MAGhB,IAAIH,IAAI,CAACI,SAAS,CAACvC,MAAM,GAAG,CAAC,EAAE;QAC3B,OAAO,KAAK;;MAGhB,IAAImC,IAAI,CAACK,QAAQ,IAAIL,IAAI,CAACM,YAAY,EAAE;QACpC,OAAO,KAAK;;MAGhB,OAAO,IAAI;IACf,CAAC;EAsEL;EApHI;;;EAGO,WAAWC,mBAAmB;IACjC,OAAOT,uBAAuB,CAACU,oBAAoB;EACvD;EAEA;;;EAGO,WAAWD,mBAAmB,CAACE,KAAc;IAChDX,uBAAuB,CAACU,oBAAoB,GAAGC,KAAK;EACxD;EAEA;;;;EAIOtD,cAAc;IACjB,OAAO,iCAAiC;EAC5C;EA4BA;;;;;;;EAOOC,KAAK,CAACC,KAAY,EAAEC,SAAyB,EAAEoD,mBAA6B;IAC/E,MAAMC,UAAU,GAAGtD,KAAK,CAACuD,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACxC,IAAIC,YAAY,GAAGH,UAAU,CAAC9C,MAAM;IAEpC,KAAK,IAAIF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGmD,YAAY,EAAEnD,KAAK,EAAE,EAAE;MAC/C,MAAMoD,WAAW,GAAG,IAAIC,KAAK,EAAQ;MACrC,MAAMC,OAAO,GAAGN,UAAU,CAAChD,KAAK,CAAC;MAEjC;MACA,IAAI,CAAC,IAAI,CAACuD,YAAY,CAACD,OAAO,CAAC,EAAE;QAC7B;;MAGJF,WAAW,CAACI,IAAI,CAAOF,OAAO,CAAC;MAE/B;MACA,KAAK,IAAIG,QAAQ,GAAGzD,KAAK,GAAG,CAAC,EAAEyD,QAAQ,GAAGN,YAAY,EAAEM,QAAQ,EAAE,EAAE;QAChE,MAAMC,SAAS,GAAGV,UAAU,CAACS,QAAQ,CAAC;QAEtC,IAAI,CAAC,IAAI,CAACF,YAAY,CAACG,SAAS,CAAC,EAAE;UAC/B;;QAGJ,IAAIA,SAAS,CAACC,QAAQ,KAAKL,OAAO,CAACK,QAAQ,EAAE;UACzC;;QAGJ,IAAID,SAAS,CAACE,eAAe,KAAKN,OAAO,CAACM,eAAe,EAAE;UACvD;;QAGJR,WAAW,CAACI,IAAI,CAAOE,SAAS,CAAC;QACjCP,YAAY,EAAE;QAEdH,UAAU,CAACa,MAAM,CAACJ,QAAQ,EAAE,CAAC,CAAC;QAE9BA,QAAQ,EAAE;;MAGd,IAAIL,WAAW,CAAClD,MAAM,GAAG,CAAC,EAAE;QACxB;;MAGJ;MACAf,IAAI,CAAC2E,WAAW,CAACV,WAAW,EAAEW,SAAS,EAAE,IAAI,CAAC;;IAGlD;IACA,MAAMC,UAAU,GAAGtE,KAAY;IAC/B,IAAIsE,UAAU,CAACC,6BAA6B,EAAE;MAC1C,IAAIlB,mBAAmB,IAAIgB,SAAS,EAAE;QAClC,IAAIhB,mBAAmB,EAAE;UACrBiB,UAAU,CAACC,6BAA6B,EAAE;;OAEjD,MAAM,IAAI9B,uBAAuB,CAACS,mBAAmB,EAAE;QACpDoB,UAAU,CAACC,6BAA6B,EAAE;;;IAIlD,OAAO,IAAI;EACf;;AArHe9B,4CAAoB,GAAG,KAAK;AAwH/C;;;;AAIA,OAAM,MAAO+B,qBAAqB;EAM9B;;;;;EAKA5E;EACI;;;EAGO6E,kBAA0B,EAAE;EACnC;;;EAGOC,kBAA0B,IAAI;IAJ9B,oBAAe,GAAfD,eAAe;IAIf,oBAAe,GAAfC,eAAe;IAlB1B;;;IAGO,kBAAa,GAAG,IAAIf,KAAK,EAAqB;EAgBlD;EAEH;;;;;EAKOgB,eAAe,CAACC,YAA+B;IAClD,IAAI,CAACC,aAAa,CAACf,IAAI,CAACc,YAAY,CAAC;IACrC,OAAO,IAAI;EACf;EAEA;;;;;;;EAOOE,qBAAqB,CAAC1C,OAA6D,EAAED,gBAA8B,EAAEtC,WAAmB,CAAC;IAC5I,MAAM+E,YAAY,GAAG,IAAI1C,kBAAkB,CAACrC,QAAQ,CAAC;IACrD+E,YAAY,CAACxC,OAAO,GAAGA,OAAO;IAC9BwC,YAAY,CAACzC,gBAAgB,GAAGA,gBAAgB;IAEhD,IAAI,CAAC0C,aAAa,CAACf,IAAI,CAACc,YAAY,CAAC;IACrC,OAAO,IAAI;EACf;EAEA;;;;;EAKO,OAAOG,qBAAqB,CAACN,eAAwB;IACxD,MAAMO,MAAM,GAAG,IAAIR,qBAAqB,CAACC,eAAe,CAAC;IAEzD,IAAI5E,QAAQ,GAAG,CAAC;IAChBmF,MAAM,CAACL,eAAe,CAAC,IAAIlC,uBAAuB,CAAC5C,QAAQ,CAAC,CAAC;IAC7DmF,MAAM,CAACL,eAAe,CAAC,IAAIhD,mBAAmB,CAAC9B,QAAQ,CAAC,CAAC;IACzDmF,MAAM,CAACL,eAAe,CAAC,IAAI3C,sBAAsB,CAACnC,QAAQ,CAAC,CAAC;IAE5D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAI7C,yBAAyB,CAACjC,QAAQ,CAAC,CAAC;IAC/DmF,MAAM,CAACL,eAAe,CAAC,IAAItC,qBAAqB,CAACxC,QAAQ,CAAC,CAAC;IAE3D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIzE,mBAAmB,CAACL,QAAQ,EAAE,IAAI,CAAC,CAAC;IAE/D,OAAOmF,MAAM;EACjB;EAEA;;;;;EAKO,OAAOC,0BAA0B,CAACR,eAAwB;IAC7D,MAAMO,MAAM,GAAG,IAAIR,qBAAqB,CAACC,eAAe,CAAC;IAEzD,IAAI5E,QAAQ,GAAG,CAAC;IAChBmF,MAAM,CAACL,eAAe,CAAC,IAAIlC,uBAAuB,CAAC5C,QAAQ,CAAC,CAAC;IAC7DmF,MAAM,CAACL,eAAe,CAAC,IAAIhD,mBAAmB,CAAC9B,QAAQ,CAAC,CAAC;IACzDmF,MAAM,CAACL,eAAe,CAAC,IAAI3C,sBAAsB,CAACnC,QAAQ,CAAC,CAAC;IAE5D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAI7C,yBAAyB,CAACjC,QAAQ,CAAC,CAAC;IAC/DmF,MAAM,CAACL,eAAe,CAAC,IAAItC,qBAAqB,CAACxC,QAAQ,CAAC,CAAC;IAE3D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIzE,mBAAmB,CAACL,QAAQ,EAAE,GAAG,CAAC,CAAC;IAE9D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIpC,yBAAyB,CAAC1C,QAAQ,CAAC,CAAC;IAE/D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIvD,2BAA2B,CAACvB,QAAQ,EAAE,CAAC,CAAC,CAAC;IAEpE,OAAOmF,MAAM;EACjB;EAEA;;;;;EAKO,OAAOE,sBAAsB,CAACT,eAAwB;IACzD,MAAMO,MAAM,GAAG,IAAIR,qBAAqB,CAACC,eAAe,CAAC;IAEzD,IAAI5E,QAAQ,GAAG,CAAC;IAChBmF,MAAM,CAACL,eAAe,CAAC,IAAIlC,uBAAuB,CAAC5C,QAAQ,CAAC,CAAC;IAC7DmF,MAAM,CAACL,eAAe,CAAC,IAAIhD,mBAAmB,CAAC9B,QAAQ,CAAC,CAAC;IACzDmF,MAAM,CAACL,eAAe,CAAC,IAAI3C,sBAAsB,CAACnC,QAAQ,CAAC,CAAC;IAE5D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAI7C,yBAAyB,CAACjC,QAAQ,CAAC,CAAC;IAC/DmF,MAAM,CAACL,eAAe,CAAC,IAAItC,qBAAqB,CAACxC,QAAQ,CAAC,CAAC;IAE3D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIzE,mBAAmB,CAACL,QAAQ,EAAE,GAAG,CAAC,CAAC;IAE9D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIpC,yBAAyB,CAAC1C,QAAQ,CAAC,CAAC;IAE/D;IACAA,QAAQ,EAAE;IACVmF,MAAM,CAACL,eAAe,CAAC,IAAIvD,2BAA2B,CAACvB,QAAQ,EAAE,CAAC,CAAC,CAAC;IAEpE,OAAOmF,MAAM;EACjB;;AAGJ;;;;AAIA,OAAM,MAAOG,cAAc;EAoFvB;;;;;;;EAOAvF,YAAmBI,KAAY,EAAEoF,OAA+B,EAAEC,sBAAsB,GAAG,IAAI,EAAEC,eAAe,GAAG,KAAK;IA1FhH,eAAU,GAAG,KAAK;IAGlB,0BAAqB,GAAG,CAAC;IACzB,qBAAgB,GAAG,EAAE;IACrB,qBAAgB,GAAG,IAAI;IACvB,sBAAiB,GAAG,CAAC;IAErB,qBAAgB,GAAG,KAAK;IAEhC;;;IAGO,wBAAmB,GAAG,IAAI5F,UAAU,EAAkB;IAC7D;;;IAGO,uCAAkC,GAAG,IAAIA,UAAU,EAAqB;IAC/E;;;IAGO,wBAAmB,GAAG,IAAIA,UAAU,EAAkB;IAsEzD,IAAI,CAAC0F,OAAO,EAAE;MACV,IAAI,CAACG,QAAQ,GAAG,IAAIf,qBAAqB,EAAE;KAC9C,MAAM;MACH,IAAI,CAACe,QAAQ,GAAGH,OAAO;;IAG3B,IAAI,IAAI,CAACG,QAAQ,CAACd,eAAe,EAAE;MAC/B,IAAI,CAACe,gBAAgB,GAAG,IAAI,CAACD,QAAQ,CAACd,eAAe;;IAGzD,IAAI,IAAI,CAACc,QAAQ,CAACb,eAAe,EAAE;MAC/B,IAAI,CAACe,gBAAgB,GAAG,IAAI,CAACF,QAAQ,CAACb,eAAe;;IAGzD,IAAIW,sBAAsB,EAAE;MACxB,IAAIxF,QAAQ,GAAG,CAAC;MAChB,KAAK,MAAM6F,KAAK,IAAI,IAAI,CAACH,QAAQ,CAACV,aAAa,EAAE;QAC7Ca,KAAK,CAAC7F,QAAQ,GAAGA,QAAQ,EAAE;;;IAInC,IAAI,CAAC8F,gBAAgB,GAAGL,eAAe;IACvC,IAAI,CAACM,MAAM,GAAG5F,KAAK,IAAIR,WAAW,CAACqG,gBAAgB;IACnD,IAAI,CAACC,qBAAqB,GAAG,IAAI,CAACF,MAAM,CAACG,mBAAmB,CAACC,GAAG,CAAC,MAAK;MAClE,IAAI,CAACF,qBAAqB,GAAG,IAAI;MACjC,IAAI,CAACG,OAAO,EAAE;IAClB,CAAC,CAAC;EACN;EA/FA;;;EAGA,IAAWpE,mBAAmB;IAC1B,OAAO,IAAI,CAAC8D,gBAAgB;EAChC;EAEA,IAAW9D,mBAAmB,CAACuB,KAAc;IACzC,IAAI,CAACuC,gBAAgB,GAAGvC,KAAK;EACjC;EAEA;;;EAGA,IAAW8C,oBAAoB;IAC3B,OAAO,IAAI,CAACC,qBAAqB;EACrC;EAEA;;;EAGA,IAAWC,gBAAgB;IACvB,OAAO,IAAI,CAACC,iBAAiB;EACjC;EAEA;;;EAGA,IAAW5B,eAAe;IACtB,OAAO,IAAI,CAACe,gBAAgB;EAChC;EAEA;;;EAGA,IAAWf,eAAe,CAACrB,KAAa;IACpC,IAAI,CAACoC,gBAAgB,GAAGpC,KAAK;EACjC;EAEA;;;EAGA,IAAWsB,eAAe;IACtB,OAAO,IAAI,CAACe,gBAAgB;EAChC;EAEA;;;EAGA,IAAWf,eAAe,CAACtB,KAAa;IACpC,IAAI,CAACqC,gBAAgB,GAAGrC,KAAK;EACjC;EAEA;;;EAGA,IAAWyB,aAAa;IACpB,OAAO,IAAI,CAACU,QAAQ,CAACV,aAAa;EACtC;EAuCA;;;EAGOyB,IAAI;IACP,IAAI,CAACC,UAAU,GAAG,KAAK;EAC3B;EAEA;;;EAGOC,KAAK;IACR,IAAI,CAACL,qBAAqB,GAAG,CAAC;EAClC;EAEA;;;;EAIOM,KAAK;IACR,IAAI,IAAI,CAACF,UAAU,EAAE;MACjB;;IAGJ,IAAI,CAACA,UAAU,GAAG,IAAI;IAEtB;IACA,IAAI,CAACX,MAAM,CAACc,gBAAgB,CAAC,MAAK;MAC9BC,UAAU,CAAC,MAAK;QACZ,IAAI,CAACC,kBAAkB,EAAE;MAC7B,CAAC,EAAE,IAAI,CAACnB,gBAAgB,CAAC;IAC7B,CAAC,CAAC;EACN;EAEQmB,kBAAkB;IACtB,IAAI,CAAC,IAAI,CAACL,UAAU,EAAE;MAClB;;IAGJ,MAAMvG,KAAK,GAAG,IAAI,CAAC4F,MAAM;IACzB,MAAMR,OAAO,GAAG,IAAI,CAACG,QAAQ;IAE7B,IAAI,CAACc,iBAAiB,GAAGtF,IAAI,CAAC8F,KAAK,CAAC7G,KAAK,CAACuB,SAAS,EAAE,CAACuF,MAAM,EAAE,CAAC;IAE/D,IAAK,IAAI,CAACnB,gBAAgB,IAAI,IAAI,CAACU,iBAAiB,IAAI,IAAI,CAACb,gBAAgB,IAAM,CAAC,IAAI,CAACG,gBAAgB,IAAI,IAAI,CAACU,iBAAiB,IAAI,IAAI,CAACb,gBAAiB,EAAE;MAC3J,IAAI,CAACe,UAAU,GAAG,KAAK;MACvB,IAAI,CAACQ,mBAAmB,CAACC,eAAe,CAAC,IAAI,CAAC;MAC9C;;IAGJ;IACA,IAAI3G,OAAO,GAAG,IAAI;IAClB,IAAI4G,qBAAqB,GAAG,IAAI;IAChC,KAAK,IAAI3G,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG8E,OAAO,CAACP,aAAa,CAACrE,MAAM,EAAEF,KAAK,EAAE,EAAE;MAC/D,MAAMsE,YAAY,GAAGQ,OAAO,CAACP,aAAa,CAACvE,KAAK,CAAC;MAEjD,IAAIsE,YAAY,CAAC/E,QAAQ,KAAK,IAAI,CAACsG,qBAAqB,EAAE;QACtDc,qBAAqB,GAAG,KAAK;QAC7B5G,OAAO,GAAGA,OAAO,IAAIuE,YAAY,CAAC7E,KAAK,CAACC,KAAK,EAAE,IAAI,CAAC;QACpD,IAAI,CAACkH,kCAAkC,CAACF,eAAe,CAACpC,YAAY,CAAC;;;IAI7E;IACA,IAAIqC,qBAAqB,EAAE;MACvB,IAAI,CAACV,UAAU,GAAG,KAAK;MACvB,IAAI,CAACY,mBAAmB,CAACH,eAAe,CAAC,IAAI,CAAC;MAE9C;;IAGJ;IACA,IAAI3G,OAAO,EAAE;MACT,IAAI,CAAC8F,qBAAqB,EAAE;;IAGhC;IACAnG,KAAK,CAAC0G,gBAAgB,CAAC,MAAK;MACxBC,UAAU,CAAC,MAAK;QACZ,IAAI,CAACC,kBAAkB,EAAE;MAC7B,CAAC,EAAE,IAAI,CAACnB,gBAAgB,CAAC;IAC7B,CAAC,CAAC;EACN;EAEA;;;EAGOQ,OAAO;IACV,IAAI,CAACK,IAAI,EAAE;IACX,IAAI,CAACS,mBAAmB,CAACK,KAAK,EAAE;IAChC,IAAI,CAACD,mBAAmB,CAACC,KAAK,EAAE;IAChC,IAAI,CAACF,kCAAkC,CAACE,KAAK,EAAE;IAC/C,IAAI,IAAI,CAACtB,qBAAqB,EAAE;MAC5B,IAAI,CAACF,MAAM,CAACG,mBAAmB,CAACsB,MAAM,CAAC,IAAI,CAACvB,qBAAqB,CAAC;;EAE1E;EAEA;;;;;;;;EAQO,OAAOwB,aAAa,CAACtH,KAAY,EAAEoF,OAA+B,EAAEmC,SAAsB,EAAEC,SAAsB;IACrH,MAAMvH,SAAS,GAAG,IAAIkF,cAAc,CAACnF,KAAK,EAAEoF,OAAO,IAAIZ,qBAAqB,CAACS,0BAA0B,EAAE,EAAE,KAAK,CAAC;IAEjH,IAAIsC,SAAS,EAAE;MACXtH,SAAS,CAAC8G,mBAAmB,CAACf,GAAG,CAAC,MAAK;QACnCuB,SAAS,EAAE;MACf,CAAC,CAAC;;IAGN,IAAIC,SAAS,EAAE;MACXvH,SAAS,CAACkH,mBAAmB,CAACnB,GAAG,CAAC,MAAK;QACnCwB,SAAS,EAAE;MACf,CAAC,CAAC;;IAGNvH,SAAS,CAACwG,KAAK,EAAE;IAEjB,OAAOxG,SAAS;EACpB","names":["EngineStore","Mesh","Observable","SceneOptimization","constructor","priority","getDescription","apply","scene","optimizer","TextureOptimization","maximumSize","step","allDone","index","textures","length","texture","canRescale","getContext","currentSize","getSize","maxDimension","Math","max","width","height","scale","HardwareScalingOptimization","maximumScale","_currentScale","getEngine","getHardwareScalingLevel","_directionOffset","setHardwareScalingLevel","ShadowsOptimization","shadowsEnabled","isInImprovementMode","PostProcessesOptimization","postProcessesEnabled","LensFlaresOptimization","lensFlaresEnabled","CustomOptimization","onGetDescription","onApply","ParticlesOptimization","particlesEnabled","RenderTargetsOptimization","renderTargetsEnabled","MergeMeshesOptimization","abstractMesh","mesh","isDisposed","isVisible","isEnabled","instances","skeleton","hasLODLevels","UpdateSelectionTree","_UpdateSelectionTree","value","updateSelectionTree","globalPool","meshes","slice","globalLength","currentPool","Array","current","_canBeMerged","push","subIndex","otherMesh","material","checkCollisions","splice","MergeMeshes","undefined","sceneAsAny","createOrUpdateSelectionOctree","SceneOptimizerOptions","targetFrameRate","trackerDuration","addOptimization","optimization","optimizations","addCustomOptimization","LowDegradationAllowed","result","ModerateDegradationAllowed","HighDegradationAllowed","SceneOptimizer","options","autoGeneratePriorities","improvementMode","_options","_targetFrameRate","_trackerDuration","optim","_improvementMode","_scene","LastCreatedScene","_sceneDisposeObserver","onDisposeObservable","add","dispose","currentPriorityLevel","_currentPriorityLevel","currentFrameRate","_currentFrameRate","stop","_isRunning","reset","start","executeWhenReady","setTimeout","_checkCurrentState","round","getFps","onSuccessObservable","notifyObservers","noOptimizationApplied","onNewOptimizationAppliedObservable","onFailureObservable","clear","remove","OptimizeAsync","onSuccess","onFailure"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/sceneOptimizer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"./observable\";\r\nimport { Observable } from \"./observable\";\r\n\r\n/**\r\n * Defines the root class used to create scene optimization to use with SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates the SceneOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0\r\n    ) {}\r\n}\r\n\r\n/**\r\n * Defines an optimization used to reduce the size of render target textures\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class TextureOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Reducing render target texture size to \" + this.maximumSize;\r\n    }\r\n\r\n    /**\r\n     * Creates the TextureOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param maximumSize defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n     * @param step defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0,\r\n        /**\r\n         * Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter\r\n         */\r\n        public maximumSize: number = 1024,\r\n        /**\r\n         * Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.\r\n         */\r\n        public step = 0.5\r\n    ) {\r\n        super(priority);\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        let allDone = true;\r\n        for (let index = 0; index < scene.textures.length; index++) {\r\n            const texture = scene.textures[index];\r\n\r\n            if (!texture.canRescale || (<any>texture).getContext) {\r\n                continue;\r\n            }\r\n\r\n            const currentSize = texture.getSize();\r\n            const maxDimension = Math.max(currentSize.width, currentSize.height);\r\n\r\n            if (maxDimension > this.maximumSize) {\r\n                texture.scale(this.step);\r\n                allDone = false;\r\n            }\r\n        }\r\n\r\n        return allDone;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to increase or decrease the rendering resolution\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class HardwareScalingOptimization extends SceneOptimization {\r\n    private _currentScale = -1;\r\n    private _directionOffset = 1;\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Setting hardware scaling level to \" + this._currentScale;\r\n    }\r\n\r\n    /**\r\n     * Creates the HardwareScalingOptimization object\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @param maximumScale defines the maximum scale to use (2 by default)\r\n     * @param step defines the step to use between two passes (0.5 by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the priority of this optimization (0 by default which means first in the list)\r\n         */\r\n        public priority: number = 0,\r\n        /**\r\n         * Defines the maximum scale to use (2 by default)\r\n         */\r\n        public maximumScale: number = 2,\r\n        /**\r\n         * Defines the step to use between two passes (0.5 by default)\r\n         */\r\n        public step: number = 0.25\r\n    ) {\r\n        super(priority);\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        if (this._currentScale === -1) {\r\n            this._currentScale = scene.getEngine().getHardwareScalingLevel();\r\n            if (this._currentScale > this.maximumScale) {\r\n                this._directionOffset = -1;\r\n            }\r\n        }\r\n\r\n        this._currentScale += this._directionOffset * this.step;\r\n\r\n        scene.getEngine().setHardwareScalingLevel(this._currentScale);\r\n\r\n        return this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to remove shadows\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class ShadowsOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning shadows on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.shadowsEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn post-processes off\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class PostProcessesOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning post-processes on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.postProcessesEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn lens flares off\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class LensFlaresOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning lens flares on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.lensFlaresEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization based on user defined callback.\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class CustomOptimization extends SceneOptimization {\r\n    /**\r\n     * Callback called to apply the custom optimization.\r\n     */\r\n    public onApply: (scene: Scene, optimizer: SceneOptimizer) => boolean;\r\n\r\n    /**\r\n     * Callback called to get custom description\r\n     */\r\n    public onGetDescription: () => string;\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        if (this.onGetDescription) {\r\n            return this.onGetDescription();\r\n        }\r\n\r\n        return \"Running user defined callback\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        if (this.onApply) {\r\n            return this.onApply(scene, optimizer);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn particles off\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class ParticlesOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning particles on/off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.particlesEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to turn render targets off\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class RenderTargetsOptimization extends SceneOptimization {\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Turning render targets off\";\r\n    }\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer): boolean {\r\n        scene.renderTargetsEnabled = optimizer.isInImprovementMode;\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines an optimization used to merge meshes with compatible materials\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class MergeMeshesOptimization extends SceneOptimization {\r\n    private static _UpdateSelectionTree = false;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\r\n    public static get UpdateSelectionTree(): boolean {\r\n        return MergeMeshesOptimization._UpdateSelectionTree;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if optimization octree has to be updated\r\n     */\r\n    public static set UpdateSelectionTree(value: boolean) {\r\n        MergeMeshesOptimization._UpdateSelectionTree = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string describing the action executed by the current optimization\r\n     * @returns description string\r\n     */\r\n    public getDescription(): string {\r\n        return \"Merging similar meshes together\";\r\n    }\r\n\r\n    private _canBeMerged = (abstractMesh: AbstractMesh): boolean => {\r\n        if (!(abstractMesh instanceof Mesh)) {\r\n            return false;\r\n        }\r\n\r\n        const mesh = <Mesh>abstractMesh;\r\n\r\n        if (mesh.isDisposed()) {\r\n            return false;\r\n        }\r\n\r\n        if (!mesh.isVisible || !mesh.isEnabled()) {\r\n            return false;\r\n        }\r\n\r\n        if (mesh.instances.length > 0) {\r\n            return false;\r\n        }\r\n\r\n        if (mesh.skeleton || mesh.hasLODLevels) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization\r\n     * @param scene defines the current scene where to apply this optimization\r\n     * @param optimizer defines the current optimizer\r\n     * @param updateSelectionTree defines that the selection octree has to be updated (false by default)\r\n     * @returns true if everything that can be done was applied\r\n     */\r\n    public apply(scene: Scene, optimizer: SceneOptimizer, updateSelectionTree?: boolean): boolean {\r\n        const globalPool = scene.meshes.slice(0);\r\n        let globalLength = globalPool.length;\r\n\r\n        for (let index = 0; index < globalLength; index++) {\r\n            const currentPool = new Array<Mesh>();\r\n            const current = globalPool[index];\r\n\r\n            // Checks\r\n            if (!this._canBeMerged(current)) {\r\n                continue;\r\n            }\r\n\r\n            currentPool.push(<Mesh>current);\r\n\r\n            // Find compatible meshes\r\n            for (let subIndex = index + 1; subIndex < globalLength; subIndex++) {\r\n                const otherMesh = globalPool[subIndex];\r\n\r\n                if (!this._canBeMerged(otherMesh)) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material !== current.material) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.checkCollisions !== current.checkCollisions) {\r\n                    continue;\r\n                }\r\n\r\n                currentPool.push(<Mesh>otherMesh);\r\n                globalLength--;\r\n\r\n                globalPool.splice(subIndex, 1);\r\n\r\n                subIndex--;\r\n            }\r\n\r\n            if (currentPool.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            // Merge meshes\r\n            Mesh.MergeMeshes(currentPool, undefined, true);\r\n        }\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const sceneAsAny = scene as any;\r\n        if (sceneAsAny.createOrUpdateSelectionOctree) {\r\n            if (updateSelectionTree != undefined) {\r\n                if (updateSelectionTree) {\r\n                    sceneAsAny.createOrUpdateSelectionOctree();\r\n                }\r\n            } else if (MergeMeshesOptimization.UpdateSelectionTree) {\r\n                sceneAsAny.createOrUpdateSelectionOctree();\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines a list of options used by SceneOptimizer\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class SceneOptimizerOptions {\r\n    /**\r\n     * Gets the list of optimizations to apply\r\n     */\r\n    public optimizations = new Array<SceneOptimization>();\r\n\r\n    /**\r\n     * Creates a new list of options used by SceneOptimizer\r\n     * @param targetFrameRate defines the target frame rate to reach (60 by default)\r\n     * @param trackerDuration defines the interval between two checks (2000ms by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the target frame rate to reach (60 by default)\r\n         */\r\n        public targetFrameRate: number = 60,\r\n        /**\r\n         * Defines the interval between two checks (2000ms by default)\r\n         */\r\n        public trackerDuration: number = 2000\r\n    ) {}\r\n\r\n    /**\r\n     * Add a new optimization\r\n     * @param optimization defines the SceneOptimization to add to the list of active optimizations\r\n     * @returns the current SceneOptimizerOptions\r\n     */\r\n    public addOptimization(optimization: SceneOptimization): SceneOptimizerOptions {\r\n        this.optimizations.push(optimization);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new custom optimization\r\n     * @param onApply defines the callback called to apply the custom optimization (true if everything that can be done was applied)\r\n     * @param onGetDescription defines the callback called to get the description attached with the optimization.\r\n     * @param priority defines the priority of this optimization (0 by default which means first in the list)\r\n     * @returns the current SceneOptimizerOptions\r\n     */\r\n    public addCustomOptimization(onApply: (scene: Scene, optimizer: SceneOptimizer) => boolean, onGetDescription: () => string, priority: number = 0): SceneOptimizerOptions {\r\n        const optimization = new CustomOptimization(priority);\r\n        optimization.onApply = onApply;\r\n        optimization.onGetDescription = onGetDescription;\r\n\r\n        this.optimizations.push(optimization);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static LowDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        const result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        let priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 1024));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static ModerateDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        const result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        let priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 512));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new RenderTargetsOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new HardwareScalingOptimization(priority, 2));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual\r\n     * @param targetFrameRate defines the target frame rate (60 by default)\r\n     * @returns a SceneOptimizerOptions object\r\n     */\r\n    public static HighDegradationAllowed(targetFrameRate?: number): SceneOptimizerOptions {\r\n        const result = new SceneOptimizerOptions(targetFrameRate);\r\n\r\n        let priority = 0;\r\n        result.addOptimization(new MergeMeshesOptimization(priority));\r\n        result.addOptimization(new ShadowsOptimization(priority));\r\n        result.addOptimization(new LensFlaresOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new PostProcessesOptimization(priority));\r\n        result.addOptimization(new ParticlesOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new TextureOptimization(priority, 256));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new RenderTargetsOptimization(priority));\r\n\r\n        // Next priority\r\n        priority++;\r\n        result.addOptimization(new HardwareScalingOptimization(priority, 4));\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to run optimizations in order to reach a target frame rate\r\n * @description More details at https://doc.babylonjs.com/features/featuresDeepDive/scene/sceneOptimizer\r\n */\r\nexport class SceneOptimizer implements IDisposable {\r\n    private _isRunning = false;\r\n    private _options: SceneOptimizerOptions;\r\n    private _scene: Scene;\r\n    private _currentPriorityLevel = 0;\r\n    private _targetFrameRate = 60;\r\n    private _trackerDuration = 2000;\r\n    private _currentFrameRate = 0;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _improvementMode = false;\r\n\r\n    /**\r\n     * Defines an observable called when the optimizer reaches the target frame rate\r\n     */\r\n    public onSuccessObservable = new Observable<SceneOptimizer>();\r\n    /**\r\n     * Defines an observable called when the optimizer enables an optimization\r\n     */\r\n    public onNewOptimizationAppliedObservable = new Observable<SceneOptimization>();\r\n    /**\r\n     * Defines an observable called when the optimizer is not able to reach the target frame rate\r\n     */\r\n    public onFailureObservable = new Observable<SceneOptimizer>();\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the optimizer is in improvement mode\r\n     */\r\n    public get isInImprovementMode(): boolean {\r\n        return this._improvementMode;\r\n    }\r\n\r\n    public set isInImprovementMode(value: boolean) {\r\n        this._improvementMode = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the current priority level (0 at start)\r\n     */\r\n    public get currentPriorityLevel(): number {\r\n        return this._currentPriorityLevel;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame rate checked by the SceneOptimizer\r\n     */\r\n    public get currentFrameRate(): number {\r\n        return this._currentFrameRate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\r\n    public get targetFrameRate(): number {\r\n        return this._targetFrameRate;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current target frame rate (60 by default)\r\n     */\r\n    public set targetFrameRate(value: number) {\r\n        this._targetFrameRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\r\n    public get trackerDuration(): number {\r\n        return this._trackerDuration;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current interval between two checks (every 2000ms by default)\r\n     */\r\n    public set trackerDuration(value: number) {\r\n        this._trackerDuration = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active optimizations\r\n     */\r\n    public get optimizations(): SceneOptimization[] {\r\n        return this._options.optimizations;\r\n    }\r\n\r\n    /**\r\n     * Creates a new SceneOptimizer\r\n     * @param scene defines the scene to work on\r\n     * @param options defines the options to use with the SceneOptimizer\r\n     * @param autoGeneratePriorities defines if priorities must be generated and not read from SceneOptimization property (true by default)\r\n     * @param improvementMode defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)\r\n     */\r\n    public constructor(scene: Scene, options?: SceneOptimizerOptions, autoGeneratePriorities = true, improvementMode = false) {\r\n        if (!options) {\r\n            this._options = new SceneOptimizerOptions();\r\n        } else {\r\n            this._options = options;\r\n        }\r\n\r\n        if (this._options.targetFrameRate) {\r\n            this._targetFrameRate = this._options.targetFrameRate;\r\n        }\r\n\r\n        if (this._options.trackerDuration) {\r\n            this._trackerDuration = this._options.trackerDuration;\r\n        }\r\n\r\n        if (autoGeneratePriorities) {\r\n            let priority = 0;\r\n            for (const optim of this._options.optimizations) {\r\n                optim.priority = priority++;\r\n            }\r\n        }\r\n\r\n        this._improvementMode = improvementMode;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\r\n            this._sceneDisposeObserver = null;\r\n            this.dispose();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops the current optimizer\r\n     */\r\n    public stop() {\r\n        this._isRunning = false;\r\n    }\r\n\r\n    /**\r\n     * Reset the optimizer to initial step (current priority level = 0)\r\n     */\r\n    public reset() {\r\n        this._currentPriorityLevel = 0;\r\n    }\r\n\r\n    /**\r\n     * Start the optimizer. By default it will try to reach a specific framerate\r\n     * but if the optimizer is set with improvementMode === true then it will run all optimization while frame rate is above the target frame rate\r\n     */\r\n    public start() {\r\n        if (this._isRunning) {\r\n            return;\r\n        }\r\n\r\n        this._isRunning = true;\r\n\r\n        // Let's wait for the scene to be ready before running our check\r\n        this._scene.executeWhenReady(() => {\r\n            setTimeout(() => {\r\n                this._checkCurrentState();\r\n            }, this._trackerDuration);\r\n        });\r\n    }\r\n\r\n    private _checkCurrentState() {\r\n        if (!this._isRunning) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._scene;\r\n        const options = this._options;\r\n\r\n        this._currentFrameRate = Math.round(scene.getEngine().getFps());\r\n\r\n        if ((this._improvementMode && this._currentFrameRate <= this._targetFrameRate) || (!this._improvementMode && this._currentFrameRate >= this._targetFrameRate)) {\r\n            this._isRunning = false;\r\n            this.onSuccessObservable.notifyObservers(this);\r\n            return;\r\n        }\r\n\r\n        // Apply current level of optimizations\r\n        let allDone = true;\r\n        let noOptimizationApplied = true;\r\n        for (let index = 0; index < options.optimizations.length; index++) {\r\n            const optimization = options.optimizations[index];\r\n\r\n            if (optimization.priority === this._currentPriorityLevel) {\r\n                noOptimizationApplied = false;\r\n                allDone = allDone && optimization.apply(scene, this);\r\n                this.onNewOptimizationAppliedObservable.notifyObservers(optimization);\r\n            }\r\n        }\r\n\r\n        // If no optimization was applied, this is a failure :(\r\n        if (noOptimizationApplied) {\r\n            this._isRunning = false;\r\n            this.onFailureObservable.notifyObservers(this);\r\n\r\n            return;\r\n        }\r\n\r\n        // If all optimizations were done, move to next level\r\n        if (allDone) {\r\n            this._currentPriorityLevel++;\r\n        }\r\n\r\n        // Let's the system running for a specific amount of time before checking FPS\r\n        scene.executeWhenReady(() => {\r\n            setTimeout(() => {\r\n                this._checkCurrentState();\r\n            }, this._trackerDuration);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose(): void {\r\n        this.stop();\r\n        this.onSuccessObservable.clear();\r\n        this.onFailureObservable.clear();\r\n        this.onNewOptimizationAppliedObservable.clear();\r\n        if (this._sceneDisposeObserver) {\r\n            this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to create a SceneOptimizer with one single line of code\r\n     * @param scene defines the scene to work on\r\n     * @param options defines the options to use with the SceneOptimizer\r\n     * @param onSuccess defines a callback to call on success\r\n     * @param onFailure defines a callback to call on failure\r\n     * @returns the new SceneOptimizer object\r\n     */\r\n    public static OptimizeAsync(scene: Scene, options?: SceneOptimizerOptions, onSuccess?: () => void, onFailure?: () => void): SceneOptimizer {\r\n        const optimizer = new SceneOptimizer(scene, options || SceneOptimizerOptions.ModerateDegradationAllowed(), false);\r\n\r\n        if (onSuccess) {\r\n            optimizer.onSuccessObservable.add(() => {\r\n                onSuccess();\r\n            });\r\n        }\r\n\r\n        if (onFailure) {\r\n            optimizer.onFailureObservable.add(() => {\r\n                onFailure();\r\n            });\r\n        }\r\n\r\n        optimizer.start();\r\n\r\n        return optimizer;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}