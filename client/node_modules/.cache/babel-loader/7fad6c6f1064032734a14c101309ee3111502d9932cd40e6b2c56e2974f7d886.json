{"ast":null,"code":"import { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { StringDictionary } from \"./stringDictionary.js\";\n// Mainly based on these 2 articles :\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\n/**\n * Defines the potential axis of a Joystick\n */\nexport var JoystickAxis;\n(function (JoystickAxis) {\n  /** X axis */\n  JoystickAxis[JoystickAxis[\"X\"] = 0] = \"X\";\n  /** Y axis */\n  JoystickAxis[JoystickAxis[\"Y\"] = 1] = \"Y\";\n  /** Z axis */\n  JoystickAxis[JoystickAxis[\"Z\"] = 2] = \"Z\";\n})(JoystickAxis || (JoystickAxis = {}));\n/**\n * Class used to define virtual joystick (used in touch mode)\n */\nexport class VirtualJoystick {\n  /**\n   * Creates a new virtual joystick\n   * @param leftJoystick defines that the joystick is for left hand (false by default)\n   * @param customizations Defines the options we want to customize the VirtualJoystick\n   */\n  constructor(leftJoystick, customizations) {\n    this._released = false;\n    const options = {\n      ...VirtualJoystick._GetDefaultOptions(),\n      ...customizations\n    };\n    if (leftJoystick) {\n      this._leftJoystick = true;\n    } else {\n      this._leftJoystick = false;\n    }\n    VirtualJoystick._GlobalJoystickIndex++;\n    // By default left & right arrow keys are moving the X\n    // and up & down keys are moving the Y\n    this._axisTargetedByLeftAndRight = JoystickAxis.X;\n    this._axisTargetedByUpAndDown = JoystickAxis.Y;\n    this.reverseLeftRight = false;\n    this.reverseUpDown = false;\n    // collections of pointers\n    this._touches = new StringDictionary();\n    this.deltaPosition = Vector3.Zero();\n    this._joystickSensibility = 25;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n    this._onResize = () => {\n      VirtualJoystick._VJCanvasWidth = window.innerWidth;\n      VirtualJoystick._VJCanvasHeight = window.innerHeight;\n      if (VirtualJoystick.Canvas) {\n        VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\n        VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\n      }\n      VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\n    };\n    // injecting a canvas element on top of the canvas 3D game\n    if (!VirtualJoystick.Canvas) {\n      window.addEventListener(\"resize\", this._onResize, false);\n      VirtualJoystick.Canvas = document.createElement(\"canvas\");\n      VirtualJoystick._VJCanvasWidth = window.innerWidth;\n      VirtualJoystick._VJCanvasHeight = window.innerHeight;\n      VirtualJoystick.Canvas.width = window.innerWidth;\n      VirtualJoystick.Canvas.height = window.innerHeight;\n      VirtualJoystick.Canvas.style.width = \"100%\";\n      VirtualJoystick.Canvas.style.height = \"100%\";\n      VirtualJoystick.Canvas.style.position = \"absolute\";\n      VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\n      VirtualJoystick.Canvas.style.top = \"0px\";\n      VirtualJoystick.Canvas.style.left = \"0px\";\n      VirtualJoystick.Canvas.style.zIndex = \"5\";\n      VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\n      // Support for jQuery PEP polyfill\n      VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\n      const context = VirtualJoystick.Canvas.getContext(\"2d\");\n      if (!context) {\n        throw new Error(\"Unable to create canvas for virtual joystick\");\n      }\n      VirtualJoystick._VJCanvasContext = context;\n      VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      document.body.appendChild(VirtualJoystick.Canvas);\n    }\n    VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\n    this.pressed = false;\n    this.limitToContainer = options.limitToContainer;\n    // default joystick color\n    this._joystickColor = options.color;\n    // default joystick size\n    this.containerSize = options.containerSize;\n    this.puckSize = options.puckSize;\n    if (options.position) {\n      this.setPosition(options.position.x, options.position.y);\n    }\n    if (options.puckImage) {\n      this.setPuckImage(options.puckImage);\n    }\n    if (options.containerImage) {\n      this.setContainerImage(options.containerImage);\n    }\n    if (options.alwaysVisible) {\n      VirtualJoystick._AlwaysVisibleSticks++;\n    }\n    // must come after position potentially set\n    this.alwaysVisible = options.alwaysVisible;\n    this._joystickPointerId = -1;\n    // current joystick position\n    this._joystickPointerPos = new Vector2(0, 0);\n    this._joystickPreviousPointerPos = new Vector2(0, 0);\n    // origin joystick position\n    this._joystickPointerStartPos = new Vector2(0, 0);\n    this._deltaJoystickVector = new Vector2(0, 0);\n    this._onPointerDownHandlerRef = evt => {\n      this._onPointerDown(evt);\n    };\n    this._onPointerMoveHandlerRef = evt => {\n      this._onPointerMove(evt);\n    };\n    this._onPointerUpHandlerRef = evt => {\n      this._onPointerUp(evt);\n    };\n    VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\n    VirtualJoystick.Canvas.addEventListener(\"contextmenu\", evt => {\n      evt.preventDefault(); // Disables system menu\n    }, false);\n    requestAnimationFrame(() => {\n      this._drawVirtualJoystick();\n    });\n  }\n  static _GetDefaultOptions() {\n    return {\n      puckSize: 40,\n      containerSize: 60,\n      color: \"cyan\",\n      puckImage: undefined,\n      containerImage: undefined,\n      position: undefined,\n      alwaysVisible: false,\n      limitToContainer: false\n    };\n  }\n  /**\n   * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\n   * @param newJoystickSensibility defines the new sensibility\n   */\n  setJoystickSensibility(newJoystickSensibility) {\n    this._joystickSensibility = newJoystickSensibility;\n    this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n  }\n  _onPointerDown(e) {\n    let positionOnScreenCondition;\n    e.preventDefault();\n    if (this._leftJoystick === true) {\n      positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\n    } else {\n      positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\n    }\n    if (positionOnScreenCondition && this._joystickPointerId < 0) {\n      // First contact will be dedicated to the virtual joystick\n      this._joystickPointerId = e.pointerId;\n      if (this._joystickPosition) {\n        this._joystickPointerStartPos = this._joystickPosition.clone();\n        this._joystickPointerPos = this._joystickPosition.clone();\n        this._joystickPreviousPointerPos = this._joystickPosition.clone();\n        // in case the user only clicks down && doesn't move:\n        // this ensures the delta is properly set\n        this._onPointerMove(e);\n      } else {\n        this._joystickPointerStartPos.x = e.clientX;\n        this._joystickPointerStartPos.y = e.clientY;\n        this._joystickPointerPos = this._joystickPointerStartPos.clone();\n        this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\n      }\n      this._deltaJoystickVector.x = 0;\n      this._deltaJoystickVector.y = 0;\n      this.pressed = true;\n      this._touches.add(e.pointerId.toString(), e);\n    } else {\n      // You can only trigger the action buttons with a joystick declared\n      if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\n        this._action();\n        this._touches.add(e.pointerId.toString(), {\n          x: e.clientX,\n          y: e.clientY,\n          prevX: e.clientX,\n          prevY: e.clientY\n        });\n      }\n    }\n  }\n  _onPointerMove(e) {\n    // If the current pointer is the one associated to the joystick (first touch contact)\n    if (this._joystickPointerId == e.pointerId) {\n      // limit to container if need be\n      if (this.limitToContainer) {\n        const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\n        const distance = vector.length();\n        if (distance > this.containerSize) {\n          vector.scaleInPlace(this.containerSize / distance);\n        }\n        this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\n        this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\n      } else {\n        this._joystickPointerPos.x = e.clientX;\n        this._joystickPointerPos.y = e.clientY;\n      }\n      // create delta vector\n      this._deltaJoystickVector = this._joystickPointerPos.clone();\n      this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\n      // if a joystick is always visible, there will be clipping issues if\n      // you drag the puck from one over the container of the other\n      if (0 < VirtualJoystick._AlwaysVisibleSticks) {\n        if (this._leftJoystick) {\n          this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n        } else {\n          this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\n        }\n      }\n      const directionLeftRight = this.reverseLeftRight ? -1 : 1;\n      const deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;\n      switch (this._axisTargetedByLeftAndRight) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\n          break;\n      }\n      const directionUpDown = this.reverseUpDown ? 1 : -1;\n      const deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;\n      switch (this._axisTargetedByUpAndDown) {\n        case JoystickAxis.X:\n          this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n        case JoystickAxis.Y:\n          this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n        case JoystickAxis.Z:\n          this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\n          break;\n      }\n    } else {\n      const data = this._touches.get(e.pointerId.toString());\n      if (data) {\n        data.x = e.clientX;\n        data.y = e.clientY;\n      }\n    }\n  }\n  _onPointerUp(e) {\n    if (this._joystickPointerId == e.pointerId) {\n      this._clearPreviousDraw();\n      this._joystickPointerId = -1;\n      this.pressed = false;\n    } else {\n      const touch = this._touches.get(e.pointerId.toString());\n      if (touch) {\n        VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n      }\n    }\n    this._deltaJoystickVector.x = 0;\n    this._deltaJoystickVector.y = 0;\n    this._touches.remove(e.pointerId.toString());\n  }\n  /**\n   * Change the color of the virtual joystick\n   * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\n   */\n  setJoystickColor(newColor) {\n    this._joystickColor = newColor;\n  }\n  /**\n   * Size of the joystick's container\n   */\n  set containerSize(newSize) {\n    this._joystickContainerSize = newSize;\n    this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\n    this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\n  }\n  get containerSize() {\n    return this._joystickContainerSize;\n  }\n  /**\n   * Size of the joystick's puck\n   */\n  set puckSize(newSize) {\n    this._joystickPuckSize = newSize;\n    this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\n    this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\n  }\n  get puckSize() {\n    return this._joystickPuckSize;\n  }\n  /**\n   * Clears the set position of the joystick\n   */\n  clearPosition() {\n    this.alwaysVisible = false;\n    this._joystickPosition = null;\n  }\n  /**\n   * Defines whether or not the joystick container is always visible\n   */\n  set alwaysVisible(value) {\n    if (this._alwaysVisible === value) {\n      return;\n    }\n    if (value && this._joystickPosition) {\n      VirtualJoystick._AlwaysVisibleSticks++;\n      this._alwaysVisible = true;\n    } else {\n      VirtualJoystick._AlwaysVisibleSticks--;\n      this._alwaysVisible = false;\n    }\n  }\n  get alwaysVisible() {\n    return this._alwaysVisible;\n  }\n  /**\n   * Sets the constant position of the Joystick container\n   * @param x X axis coordinate\n   * @param y Y axis coordinate\n   */\n  setPosition(x, y) {\n    // just in case position is moved while the container is visible\n    if (this._joystickPointerStartPos) {\n      this._clearPreviousDraw();\n    }\n    this._joystickPosition = new Vector2(x, y);\n  }\n  /**\n   * Defines a callback to call when the joystick is touched\n   * @param action defines the callback\n   */\n  setActionOnTouch(action) {\n    this._action = action;\n  }\n  /**\n   * Defines which axis you'd like to control for left & right\n   * @param axis defines the axis to use\n   */\n  setAxisForLeftRight(axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByLeftAndRight = axis;\n        break;\n      default:\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\n        break;\n    }\n  }\n  /**\n   * Defines which axis you'd like to control for up & down\n   * @param axis defines the axis to use\n   */\n  setAxisForUpDown(axis) {\n    switch (axis) {\n      case JoystickAxis.X:\n      case JoystickAxis.Y:\n      case JoystickAxis.Z:\n        this._axisTargetedByUpAndDown = axis;\n        break;\n      default:\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\n        break;\n    }\n  }\n  /**\n   * Clears the canvas from the previous puck / container draw\n   */\n  _clearPreviousDraw() {\n    const jp = this._joystickPosition || this._joystickPointerStartPos;\n    // clear container pixels\n    VirtualJoystick._VJCanvasContext.clearRect(jp.x - this._clearContainerSizeOffset, jp.y - this._clearContainerSizeOffset, this._clearContainerSize, this._clearContainerSize);\n    // clear puck pixels\n    VirtualJoystick._VJCanvasContext.clearRect(this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset, this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset, this._clearPuckSize, this._clearPuckSize);\n  }\n  /**\n   * Loads `urlPath` to be used for the container's image\n   * @param urlPath defines the urlPath of an image to use\n   */\n  setContainerImage(urlPath) {\n    const image = new Image();\n    image.src = urlPath;\n    image.onload = () => this._containerImage = image;\n  }\n  /**\n   * Loads `urlPath` to be used for the puck's image\n   * @param urlPath defines the urlPath of an image to use\n   */\n  setPuckImage(urlPath) {\n    const image = new Image();\n    image.src = urlPath;\n    image.onload = () => this._puckImage = image;\n  }\n  /**\n   * Draws the Virtual Joystick's container\n   */\n  _drawContainer() {\n    const jp = this._joystickPosition || this._joystickPointerStartPos;\n    this._clearPreviousDraw();\n    if (this._containerImage) {\n      VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\n    } else {\n      // outer container\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n      // inner container\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.lineWidth = 6;\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n    }\n  }\n  /**\n   * Draws the Virtual Joystick's puck\n   */\n  _drawPuck() {\n    if (this._puckImage) {\n      VirtualJoystick._VJCanvasContext.drawImage(this._puckImage, this._joystickPointerPos.x - this.puckSize, this._joystickPointerPos.y - this.puckSize, this.puckSize * 2, this.puckSize * 2);\n    } else {\n      VirtualJoystick._VJCanvasContext.beginPath();\n      VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\n      VirtualJoystick._VJCanvasContext.lineWidth = 2;\n      VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\n      VirtualJoystick._VJCanvasContext.stroke();\n      VirtualJoystick._VJCanvasContext.closePath();\n    }\n  }\n  _drawVirtualJoystick() {\n    // canvas released? don't continue iterating\n    if (this._released) {\n      return;\n    }\n    if (this.alwaysVisible) {\n      this._drawContainer();\n    }\n    if (this.pressed) {\n      this._touches.forEach((key, touch) => {\n        if (touch.pointerId === this._joystickPointerId) {\n          if (!this.alwaysVisible) {\n            this._drawContainer();\n          }\n          this._drawPuck();\n          // store current pointer for next clear\n          this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\n        } else {\n          VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n          VirtualJoystick._VJCanvasContext.beginPath();\n          VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\n          VirtualJoystick._VJCanvasContext.beginPath();\n          VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\n          VirtualJoystick._VJCanvasContext.lineWidth = 6;\n          VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\n          VirtualJoystick._VJCanvasContext.stroke();\n          VirtualJoystick._VJCanvasContext.closePath();\n          touch.prevX = touch.x;\n          touch.prevY = touch.y;\n        }\n      });\n    }\n    requestAnimationFrame(() => {\n      this._drawVirtualJoystick();\n    });\n  }\n  /**\n   * Release internal HTML canvas\n   */\n  releaseCanvas() {\n    if (VirtualJoystick.Canvas) {\n      VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\n      VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\n      window.removeEventListener(\"resize\", this._onResize);\n      document.body.removeChild(VirtualJoystick.Canvas);\n      VirtualJoystick.Canvas = null;\n    }\n    this._released = true;\n  }\n}\n// Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\nVirtualJoystick._GlobalJoystickIndex = 0;\nVirtualJoystick._AlwaysVisibleSticks = 0;","map":{"version":3,"mappings":"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","names":["Vector3","Vector2","StringDictionary","JoystickAxis","VirtualJoystick","constructor","leftJoystick","customizations","options","_GetDefaultOptions","_leftJoystick","_GlobalJoystickIndex","_axisTargetedByLeftAndRight","X","_axisTargetedByUpAndDown","Y","reverseLeftRight","reverseUpDown","_touches","deltaPosition","Zero","_joystickSensibility","_inversedSensibility","_onResize","_VJCanvasWidth","window","innerWidth","_VJCanvasHeight","innerHeight","Canvas","width","height","_HalfWidth","addEventListener","document","createElement","style","position","backgroundColor","top","left","zIndex","touchAction","setAttribute","context","getContext","Error","_VJCanvasContext","strokeStyle","lineWidth","body","appendChild","pressed","limitToContainer","_joystickColor","color","containerSize","puckSize","setPosition","x","y","puckImage","setPuckImage","containerImage","setContainerImage","alwaysVisible","_AlwaysVisibleSticks","_joystickPointerId","_joystickPointerPos","_joystickPreviousPointerPos","_joystickPointerStartPos","_deltaJoystickVector","_onPointerDownHandlerRef","evt","_onPointerDown","_onPointerMoveHandlerRef","_onPointerMove","_onPointerUpHandlerRef","_onPointerUp","preventDefault","requestAnimationFrame","_drawVirtualJoystick","undefined","setJoystickSensibility","newJoystickSensibility","e","positionOnScreenCondition","clientX","pointerId","_joystickPosition","clone","clientY","add","toString","_action","prevX","prevY","vector","distance","length","scaleInPlace","subtract","Math","min","max","directionLeftRight","deltaJoystickX","Z","z","directionUpDown","deltaJoystickY","data","get","_clearPreviousDraw","touch","clearRect","remove","setJoystickColor","newColor","newSize","_joystickContainerSize","_clearContainerSize","_clearContainerSizeOffset","_joystickPuckSize","_clearPuckSize","_clearPuckSizeOffset","clearPosition","value","_alwaysVisible","setActionOnTouch","action","setAxisForLeftRight","axis","setAxisForUpDown","jp","urlPath","image","Image","src","onload","_containerImage","_puckImage","_drawContainer","drawImage","beginPath","arc","PI","stroke","closePath","_drawPuck","_released","forEach","key","fillStyle","releaseCanvas","removeEventListener","removeChild"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/virtualJoystick.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { StringDictionary } from \"./stringDictionary\";\r\n\r\n// Mainly based on these 2 articles :\r\n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\r\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/\r\n\r\n/**\r\n * Defines the potential axis of a Joystick\r\n */\r\nexport enum JoystickAxis {\r\n    /** X axis */\r\n    X,\r\n    /** Y axis */\r\n    Y,\r\n    /** Z axis */\r\n    Z,\r\n}\r\n\r\n/**\r\n * Represents the different customization options available\r\n * for VirtualJoystick\r\n */\r\ninterface VirtualJoystickCustomizations {\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    puckSize: number;\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    containerSize: number;\r\n    /**\r\n     * Color of the joystick && puck\r\n     */\r\n    color: string;\r\n    /**\r\n     * Image URL for the joystick's puck\r\n     */\r\n    puckImage?: string;\r\n    /**\r\n     * Image URL for the joystick's container\r\n     */\r\n    containerImage?: string;\r\n    /**\r\n     * Defines the unmoving position of the joystick container\r\n     */\r\n    position?: { x: number; y: number };\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    alwaysVisible: boolean;\r\n    /**\r\n     * Defines whether or not to limit the movement of the puck to the joystick's container\r\n     */\r\n    limitToContainer: boolean;\r\n}\r\n\r\n/**\r\n * Class used to define virtual joystick (used in touch mode)\r\n */\r\nexport class VirtualJoystick {\r\n    /**\r\n     * Gets or sets a boolean indicating that left and right values must be inverted\r\n     */\r\n    public reverseLeftRight: boolean;\r\n    /**\r\n     * Gets or sets a boolean indicating that up and down values must be inverted\r\n     */\r\n    public reverseUpDown: boolean;\r\n    /**\r\n     * Gets the offset value for the position (ie. the change of the position value)\r\n     */\r\n    public deltaPosition: Vector3;\r\n    /**\r\n     * Gets a boolean indicating if the virtual joystick was pressed\r\n     */\r\n    public pressed: boolean;\r\n    /**\r\n     * Canvas the virtual joystick will render onto, default z-index of this is 5\r\n     */\r\n    public static Canvas: Nullable<HTMLCanvasElement>;\r\n\r\n    /**\r\n     * boolean indicating whether or not the joystick's puck's movement should be limited to the joystick's container area\r\n     */\r\n    public limitToContainer: boolean;\r\n\r\n    // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\r\n    private static _GlobalJoystickIndex: number = 0;\r\n    private static _AlwaysVisibleSticks: number = 0;\r\n    private static _VJCanvasContext: CanvasRenderingContext2D;\r\n    private static _VJCanvasWidth: number;\r\n    private static _VJCanvasHeight: number;\r\n    private static _HalfWidth: number;\r\n    private static _GetDefaultOptions(): VirtualJoystickCustomizations {\r\n        return {\r\n            puckSize: 40,\r\n            containerSize: 60,\r\n            color: \"cyan\",\r\n            puckImage: undefined,\r\n            containerImage: undefined,\r\n            position: undefined,\r\n            alwaysVisible: false,\r\n            limitToContainer: false,\r\n        };\r\n    }\r\n\r\n    private _action: () => any;\r\n    private _axisTargetedByLeftAndRight: JoystickAxis;\r\n    private _axisTargetedByUpAndDown: JoystickAxis;\r\n    private _joystickSensibility: number;\r\n    private _inversedSensibility: number;\r\n    private _joystickPointerId: number;\r\n    private _joystickColor: string;\r\n    private _joystickPointerPos: Vector2;\r\n    private _joystickPreviousPointerPos: Vector2;\r\n    private _joystickPointerStartPos: Vector2;\r\n    private _deltaJoystickVector: Vector2;\r\n    private _leftJoystick: boolean;\r\n    private _touches: StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>;\r\n    private _joystickPosition: Nullable<Vector2>;\r\n    private _alwaysVisible: boolean;\r\n    private _puckImage: HTMLImageElement;\r\n    private _containerImage: HTMLImageElement;\r\n    private _released = false;\r\n\r\n    // size properties\r\n    private _joystickPuckSize: number;\r\n    private _joystickContainerSize: number;\r\n    private _clearPuckSize: number;\r\n    private _clearContainerSize: number;\r\n    private _clearPuckSizeOffset: number;\r\n    private _clearContainerSizeOffset: number;\r\n\r\n    private _onPointerDownHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerMoveHandlerRef: (e: PointerEvent) => any;\r\n    private _onPointerUpHandlerRef: (e: PointerEvent) => any;\r\n    private _onResize: (e: any) => any;\r\n\r\n    /**\r\n     * Creates a new virtual joystick\r\n     * @param leftJoystick defines that the joystick is for left hand (false by default)\r\n     * @param customizations Defines the options we want to customize the VirtualJoystick\r\n     */\r\n    constructor(leftJoystick?: boolean, customizations?: Partial<VirtualJoystickCustomizations>) {\r\n        const options = {\r\n            ...VirtualJoystick._GetDefaultOptions(),\r\n            ...customizations,\r\n        };\r\n\r\n        if (leftJoystick) {\r\n            this._leftJoystick = true;\r\n        } else {\r\n            this._leftJoystick = false;\r\n        }\r\n\r\n        VirtualJoystick._GlobalJoystickIndex++;\r\n\r\n        // By default left & right arrow keys are moving the X\r\n        // and up & down keys are moving the Y\r\n        this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n        this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n\r\n        this.reverseLeftRight = false;\r\n        this.reverseUpDown = false;\r\n\r\n        // collections of pointers\r\n        this._touches = new StringDictionary<{ x: number; y: number; prevX: number; prevY: number } | PointerEvent>();\r\n        this.deltaPosition = Vector3.Zero();\r\n\r\n        this._joystickSensibility = 25;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n\r\n        this._onResize = () => {\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            if (VirtualJoystick.Canvas) {\r\n                VirtualJoystick.Canvas.width = VirtualJoystick._VJCanvasWidth;\r\n                VirtualJoystick.Canvas.height = VirtualJoystick._VJCanvasHeight;\r\n            }\r\n            VirtualJoystick._HalfWidth = VirtualJoystick._VJCanvasWidth / 2;\r\n        };\r\n\r\n        // injecting a canvas element on top of the canvas 3D game\r\n        if (!VirtualJoystick.Canvas) {\r\n            window.addEventListener(\"resize\", this._onResize, false);\r\n            VirtualJoystick.Canvas = document.createElement(\"canvas\");\r\n            VirtualJoystick._VJCanvasWidth = window.innerWidth;\r\n            VirtualJoystick._VJCanvasHeight = window.innerHeight;\r\n            VirtualJoystick.Canvas.width = window.innerWidth;\r\n            VirtualJoystick.Canvas.height = window.innerHeight;\r\n            VirtualJoystick.Canvas.style.width = \"100%\";\r\n            VirtualJoystick.Canvas.style.height = \"100%\";\r\n            VirtualJoystick.Canvas.style.position = \"absolute\";\r\n            VirtualJoystick.Canvas.style.backgroundColor = \"transparent\";\r\n            VirtualJoystick.Canvas.style.top = \"0px\";\r\n            VirtualJoystick.Canvas.style.left = \"0px\";\r\n            VirtualJoystick.Canvas.style.zIndex = \"5\";\r\n            VirtualJoystick.Canvas.style.touchAction = \"none\"; // fix https://forum.babylonjs.com/t/virtualjoystick-needs-to-set-style-touch-action-none-explicitly/9562\r\n            // Support for jQuery PEP polyfill\r\n            VirtualJoystick.Canvas.setAttribute(\"touch-action\", \"none\");\r\n            const context = VirtualJoystick.Canvas.getContext(\"2d\");\r\n\r\n            if (!context) {\r\n                throw new Error(\"Unable to create canvas for virtual joystick\");\r\n            }\r\n\r\n            VirtualJoystick._VJCanvasContext = context;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = \"#ffffff\";\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            document.body.appendChild(VirtualJoystick.Canvas);\r\n        }\r\n        VirtualJoystick._HalfWidth = VirtualJoystick.Canvas.width / 2;\r\n        this.pressed = false;\r\n        this.limitToContainer = options.limitToContainer;\r\n\r\n        // default joystick color\r\n        this._joystickColor = options.color;\r\n\r\n        // default joystick size\r\n        this.containerSize = options.containerSize;\r\n        this.puckSize = options.puckSize;\r\n\r\n        if (options.position) {\r\n            this.setPosition(options.position.x, options.position.y);\r\n        }\r\n        if (options.puckImage) {\r\n            this.setPuckImage(options.puckImage);\r\n        }\r\n        if (options.containerImage) {\r\n            this.setContainerImage(options.containerImage);\r\n        }\r\n        if (options.alwaysVisible) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n        }\r\n\r\n        // must come after position potentially set\r\n        this.alwaysVisible = options.alwaysVisible;\r\n\r\n        this._joystickPointerId = -1;\r\n        // current joystick position\r\n        this._joystickPointerPos = new Vector2(0, 0);\r\n        this._joystickPreviousPointerPos = new Vector2(0, 0);\r\n        // origin joystick position\r\n        this._joystickPointerStartPos = new Vector2(0, 0);\r\n        this._deltaJoystickVector = new Vector2(0, 0);\r\n\r\n        this._onPointerDownHandlerRef = (evt) => {\r\n            this._onPointerDown(evt);\r\n        };\r\n        this._onPointerMoveHandlerRef = (evt) => {\r\n            this._onPointerMove(evt);\r\n        };\r\n        this._onPointerUpHandlerRef = (evt) => {\r\n            this._onPointerUp(evt);\r\n        };\r\n\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerdown\", this._onPointerDownHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointermove\", this._onPointerMoveHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerup\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\"pointerout\", this._onPointerUpHandlerRef, false);\r\n        VirtualJoystick.Canvas.addEventListener(\r\n            \"contextmenu\",\r\n            (evt) => {\r\n                evt.preventDefault(); // Disables system menu\r\n            },\r\n            false\r\n        );\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Defines joystick sensibility (ie. the ratio between a physical move and virtual joystick position change)\r\n     * @param newJoystickSensibility defines the new sensibility\r\n     */\r\n    public setJoystickSensibility(newJoystickSensibility: number) {\r\n        this._joystickSensibility = newJoystickSensibility;\r\n        this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\r\n    }\r\n\r\n    private _onPointerDown(e: PointerEvent) {\r\n        let positionOnScreenCondition: boolean;\r\n\r\n        e.preventDefault();\r\n\r\n        if (this._leftJoystick === true) {\r\n            positionOnScreenCondition = e.clientX < VirtualJoystick._HalfWidth;\r\n        } else {\r\n            positionOnScreenCondition = e.clientX > VirtualJoystick._HalfWidth;\r\n        }\r\n\r\n        if (positionOnScreenCondition && this._joystickPointerId < 0) {\r\n            // First contact will be dedicated to the virtual joystick\r\n            this._joystickPointerId = e.pointerId;\r\n\r\n            if (this._joystickPosition) {\r\n                this._joystickPointerStartPos = this._joystickPosition.clone();\r\n                this._joystickPointerPos = this._joystickPosition.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPosition.clone();\r\n\r\n                // in case the user only clicks down && doesn't move:\r\n                // this ensures the delta is properly set\r\n                this._onPointerMove(e);\r\n            } else {\r\n                this._joystickPointerStartPos.x = e.clientX;\r\n                this._joystickPointerStartPos.y = e.clientY;\r\n                this._joystickPointerPos = this._joystickPointerStartPos.clone();\r\n                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\r\n            }\r\n\r\n            this._deltaJoystickVector.x = 0;\r\n            this._deltaJoystickVector.y = 0;\r\n            this.pressed = true;\r\n            this._touches.add(e.pointerId.toString(), e);\r\n        } else {\r\n            // You can only trigger the action buttons with a joystick declared\r\n            if (VirtualJoystick._GlobalJoystickIndex < 2 && this._action) {\r\n                this._action();\r\n                this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerMove(e: PointerEvent) {\r\n        // If the current pointer is the one associated to the joystick (first touch contact)\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            // limit to container if need be\r\n            if (this.limitToContainer) {\r\n                const vector = new Vector2(e.clientX - this._joystickPointerStartPos.x, e.clientY - this._joystickPointerStartPos.y);\r\n                const distance = vector.length();\r\n\r\n                if (distance > this.containerSize) {\r\n                    vector.scaleInPlace(this.containerSize / distance);\r\n                }\r\n\r\n                this._joystickPointerPos.x = this._joystickPointerStartPos.x + vector.x;\r\n                this._joystickPointerPos.y = this._joystickPointerStartPos.y + vector.y;\r\n            } else {\r\n                this._joystickPointerPos.x = e.clientX;\r\n                this._joystickPointerPos.y = e.clientY;\r\n            }\r\n\r\n            // create delta vector\r\n            this._deltaJoystickVector = this._joystickPointerPos.clone();\r\n            this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\r\n\r\n            // if a joystick is always visible, there will be clipping issues if\r\n            // you drag the puck from one over the container of the other\r\n            if (0 < VirtualJoystick._AlwaysVisibleSticks) {\r\n                if (this._leftJoystick) {\r\n                    this._joystickPointerPos.x = Math.min(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                } else {\r\n                    this._joystickPointerPos.x = Math.max(VirtualJoystick._HalfWidth, this._joystickPointerPos.x);\r\n                }\r\n            }\r\n\r\n            const directionLeftRight = this.reverseLeftRight ? -1 : 1;\r\n            const deltaJoystickX = (directionLeftRight * this._deltaJoystickVector.x) / this._inversedSensibility;\r\n            switch (this._axisTargetedByLeftAndRight) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\r\n                    break;\r\n            }\r\n            const directionUpDown = this.reverseUpDown ? 1 : -1;\r\n            const deltaJoystickY = (directionUpDown * this._deltaJoystickVector.y) / this._inversedSensibility;\r\n            switch (this._axisTargetedByUpAndDown) {\r\n                case JoystickAxis.X:\r\n                    this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Y:\r\n                    this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n                case JoystickAxis.Z:\r\n                    this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\r\n                    break;\r\n            }\r\n        } else {\r\n            const data = this._touches.get(e.pointerId.toString());\r\n            if (data) {\r\n                (data as any).x = e.clientX;\r\n                (data as any).y = e.clientY;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onPointerUp(e: PointerEvent) {\r\n        if (this._joystickPointerId == e.pointerId) {\r\n            this._clearPreviousDraw();\r\n\r\n            this._joystickPointerId = -1;\r\n            this.pressed = false;\r\n        } else {\r\n            const touch = <{ x: number; y: number; prevX: number; prevY: number }>this._touches.get(e.pointerId.toString());\r\n            if (touch) {\r\n                VirtualJoystick._VJCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\r\n            }\r\n        }\r\n        this._deltaJoystickVector.x = 0;\r\n        this._deltaJoystickVector.y = 0;\r\n\r\n        this._touches.remove(e.pointerId.toString());\r\n    }\r\n\r\n    /**\r\n     * Change the color of the virtual joystick\r\n     * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\r\n     */\r\n    public setJoystickColor(newColor: string) {\r\n        this._joystickColor = newColor;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's container\r\n     */\r\n    public set containerSize(newSize: number) {\r\n        this._joystickContainerSize = newSize;\r\n        this._clearContainerSize = ~~(this._joystickContainerSize * 2.1);\r\n        this._clearContainerSizeOffset = ~~(this._clearContainerSize / 2);\r\n    }\r\n    public get containerSize() {\r\n        return this._joystickContainerSize;\r\n    }\r\n\r\n    /**\r\n     * Size of the joystick's puck\r\n     */\r\n    public set puckSize(newSize: number) {\r\n        this._joystickPuckSize = newSize;\r\n        this._clearPuckSize = ~~(this._joystickPuckSize * 2.1);\r\n        this._clearPuckSizeOffset = ~~(this._clearPuckSize / 2);\r\n    }\r\n    public get puckSize() {\r\n        return this._joystickPuckSize;\r\n    }\r\n\r\n    /**\r\n     * Clears the set position of the joystick\r\n     */\r\n    public clearPosition() {\r\n        this.alwaysVisible = false;\r\n\r\n        this._joystickPosition = null;\r\n    }\r\n\r\n    /**\r\n     * Defines whether or not the joystick container is always visible\r\n     */\r\n    public set alwaysVisible(value: boolean) {\r\n        if (this._alwaysVisible === value) {\r\n            return;\r\n        }\r\n\r\n        if (value && this._joystickPosition) {\r\n            VirtualJoystick._AlwaysVisibleSticks++;\r\n\r\n            this._alwaysVisible = true;\r\n        } else {\r\n            VirtualJoystick._AlwaysVisibleSticks--;\r\n\r\n            this._alwaysVisible = false;\r\n        }\r\n    }\r\n    public get alwaysVisible() {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the constant position of the Joystick container\r\n     * @param x X axis coordinate\r\n     * @param y Y axis coordinate\r\n     */\r\n    public setPosition(x: number, y: number) {\r\n        // just in case position is moved while the container is visible\r\n        if (this._joystickPointerStartPos) {\r\n            this._clearPreviousDraw();\r\n        }\r\n\r\n        this._joystickPosition = new Vector2(x, y);\r\n    }\r\n\r\n    /**\r\n     * Defines a callback to call when the joystick is touched\r\n     * @param action defines the callback\r\n     */\r\n    public setActionOnTouch(action: () => any) {\r\n        this._action = action;\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for left & right\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForLeftRight(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByLeftAndRight = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByLeftAndRight = JoystickAxis.X;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines which axis you'd like to control for up & down\r\n     * @param axis defines the axis to use\r\n     */\r\n    public setAxisForUpDown(axis: JoystickAxis) {\r\n        switch (axis) {\r\n            case JoystickAxis.X:\r\n            case JoystickAxis.Y:\r\n            case JoystickAxis.Z:\r\n                this._axisTargetedByUpAndDown = axis;\r\n                break;\r\n            default:\r\n                this._axisTargetedByUpAndDown = JoystickAxis.Y;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the canvas from the previous puck / container draw\r\n     */\r\n    private _clearPreviousDraw() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        // clear container pixels\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            jp.x - this._clearContainerSizeOffset,\r\n            jp.y - this._clearContainerSizeOffset,\r\n            this._clearContainerSize,\r\n            this._clearContainerSize\r\n        );\r\n\r\n        // clear puck pixels\r\n        VirtualJoystick._VJCanvasContext.clearRect(\r\n            this._joystickPreviousPointerPos.x - this._clearPuckSizeOffset,\r\n            this._joystickPreviousPointerPos.y - this._clearPuckSizeOffset,\r\n            this._clearPuckSize,\r\n            this._clearPuckSize\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the container's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setContainerImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._containerImage = image);\r\n    }\r\n\r\n    /**\r\n     * Loads `urlPath` to be used for the puck's image\r\n     * @param urlPath defines the urlPath of an image to use\r\n     */\r\n    public setPuckImage(urlPath: string) {\r\n        const image = new Image();\r\n        image.src = urlPath;\r\n\r\n        image.onload = () => (this._puckImage = image);\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's container\r\n     */\r\n    private _drawContainer() {\r\n        const jp = this._joystickPosition || this._joystickPointerStartPos;\r\n\r\n        this._clearPreviousDraw();\r\n\r\n        if (this._containerImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(this._containerImage, jp.x - this.containerSize, jp.y - this.containerSize, this.containerSize * 2, this.containerSize * 2);\r\n        } else {\r\n            // outer container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.containerSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n\r\n            // inner container\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.arc(jp.x, jp.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the Virtual Joystick's puck\r\n     */\r\n    private _drawPuck() {\r\n        if (this._puckImage) {\r\n            VirtualJoystick._VJCanvasContext.drawImage(\r\n                this._puckImage,\r\n                this._joystickPointerPos.x - this.puckSize,\r\n                this._joystickPointerPos.y - this.puckSize,\r\n                this.puckSize * 2,\r\n                this.puckSize * 2\r\n            );\r\n        } else {\r\n            VirtualJoystick._VJCanvasContext.beginPath();\r\n            VirtualJoystick._VJCanvasContext.strokeStyle = this._joystickColor;\r\n            VirtualJoystick._VJCanvasContext.lineWidth = 2;\r\n            VirtualJoystick._VJCanvasContext.arc(this._joystickPointerPos.x, this._joystickPointerPos.y, this.puckSize, 0, Math.PI * 2, true);\r\n            VirtualJoystick._VJCanvasContext.stroke();\r\n            VirtualJoystick._VJCanvasContext.closePath();\r\n        }\r\n    }\r\n\r\n    private _drawVirtualJoystick() {\r\n        // canvas released? don't continue iterating\r\n        if (this._released) {\r\n            return;\r\n        }\r\n        if (this.alwaysVisible) {\r\n            this._drawContainer();\r\n        }\r\n\r\n        if (this.pressed) {\r\n            this._touches.forEach((key, touch) => {\r\n                if ((<PointerEvent>touch).pointerId === this._joystickPointerId) {\r\n                    if (!this.alwaysVisible) {\r\n                        this._drawContainer();\r\n                    }\r\n\r\n                    this._drawPuck();\r\n\r\n                    // store current pointer for next clear\r\n                    this._joystickPreviousPointerPos = this._joystickPointerPos.clone();\r\n                } else {\r\n                    VirtualJoystick._VJCanvasContext.clearRect((<any>touch).prevX - 44, (<any>touch).prevY - 44, 88, 88);\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.fillStyle = \"white\";\r\n                    VirtualJoystick._VJCanvasContext.beginPath();\r\n                    VirtualJoystick._VJCanvasContext.strokeStyle = \"red\";\r\n                    VirtualJoystick._VJCanvasContext.lineWidth = 6;\r\n                    VirtualJoystick._VJCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\r\n                    VirtualJoystick._VJCanvasContext.stroke();\r\n                    VirtualJoystick._VJCanvasContext.closePath();\r\n                    (<any>touch).prevX = touch.x;\r\n                    (<any>touch).prevY = touch.y;\r\n                }\r\n            });\r\n        }\r\n        requestAnimationFrame(() => {\r\n            this._drawVirtualJoystick();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Release internal HTML canvas\r\n     */\r\n    public releaseCanvas() {\r\n        if (VirtualJoystick.Canvas) {\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerdown\", this._onPointerDownHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointermove\", this._onPointerMoveHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerup\", this._onPointerUpHandlerRef);\r\n            VirtualJoystick.Canvas.removeEventListener(\"pointerout\", this._onPointerUpHandlerRef);\r\n            window.removeEventListener(\"resize\", this._onResize);\r\n            document.body.removeChild(VirtualJoystick.Canvas);\r\n            VirtualJoystick.Canvas = null;\r\n        }\r\n        this._released = true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}