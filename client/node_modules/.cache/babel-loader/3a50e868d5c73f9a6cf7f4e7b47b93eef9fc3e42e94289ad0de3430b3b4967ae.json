{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../../Maths/math.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer.js\";\nimport \"../../../Shaders/hdrFiltering.vertex.js\";\nimport \"../../../Shaders/hdrFiltering.fragment.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\n/**\n * Filters HDR maps to get correct renderings of PBR reflections\n */\nexport class HDRFiltering {\n  /**\n   * Instantiates HDR filter for reflection maps\n   *\n   * @param engine Thin engine\n   * @param options Options\n   */\n  constructor(engine, options = {}) {\n    this._lodGenerationOffset = 0;\n    this._lodGenerationScale = 0.8;\n    /**\n     * Quality switch for prefiltering. Should be set to `4096` unless\n     * you care about baking speed.\n     */\n    this.quality = 4096;\n    /**\n     * Scales pixel intensity for the input HDR map.\n     */\n    this.hdrScale = 1;\n    // pass\n    this._engine = engine;\n    this.hdrScale = options.hdrScale || this.hdrScale;\n    this.quality = options.quality || this.quality;\n  }\n  _createRenderTarget(size) {\n    let textureType = 0;\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else if (this._engine.getCaps().textureFloatRender) {\n      textureType = 1;\n    }\n    const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\n      format: 5,\n      type: textureType,\n      createMipMaps: true,\n      generateMipMaps: false,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samplingMode: 1\n    });\n    this._engine.updateTextureWrappingMode(rtWrapper.texture, 0, 0, 0);\n    this._engine.updateTextureSamplingMode(3, rtWrapper.texture, true);\n    return rtWrapper;\n  }\n  _prefilterInternal(texture) {\n    const width = texture.getSize().width;\n    const mipmapsCount = Scalar.ILog2(width) + 1;\n    const effect = this._effectWrapper.effect;\n    const outputTexture = this._createRenderTarget(width);\n    this._effectRenderer.setViewport();\n    const intTexture = texture.getInternalTexture();\n    if (intTexture) {\n      // Just in case generate fresh clean mips.\n      this._engine.updateTextureSamplingMode(3, intTexture, true);\n    }\n    this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n    const directions = [[new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)] // NegativeZ\n    ];\n\n    effect.setFloat(\"hdrScale\", this.hdrScale);\n    effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\n    effect.setTexture(\"inputTexture\", texture);\n    for (let face = 0; face < 6; face++) {\n      effect.setVector3(\"up\", directions[face][0]);\n      effect.setVector3(\"right\", directions[face][1]);\n      effect.setVector3(\"front\", directions[face][2]);\n      for (let lod = 0; lod < mipmapsCount; lod++) {\n        this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\n        let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\n        if (lod === 0) {\n          alpha = 0;\n        }\n        effect.setFloat(\"alphaG\", alpha);\n        this._effectRenderer.draw();\n      }\n    }\n    // Cleanup\n    this._effectRenderer.restoreStates();\n    this._engine.restoreDefaultFramebuffer();\n    this._engine._releaseTexture(texture._texture);\n    // Internal Swap\n    outputTexture._swapAndDie(texture._texture);\n    texture._prefiltered = true;\n    return texture;\n  }\n  _createEffect(texture, onCompiled) {\n    const defines = [];\n    if (texture.gammaSpace) {\n      defines.push(\"#define GAMMA_INPUT\");\n    }\n    defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\n    const effectWrapper = new EffectWrapper({\n      engine: this._engine,\n      name: \"hdrFiltering\",\n      vertexShader: \"hdrFiltering\",\n      fragmentShader: \"hdrFiltering\",\n      samplerNames: [\"inputTexture\"],\n      uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\n      useShaderStore: true,\n      defines,\n      onCompiled: onCompiled\n    });\n    return effectWrapper;\n  }\n  /**\n   * Get a value indicating if the filter is ready to be used\n   * @param texture Texture to filter\n   * @returns true if the filter is ready\n   */\n  isReady(texture) {\n    return texture.isReady() && this._effectWrapper.effect.isReady();\n  }\n  /**\n   * Prefilters a cube texture to have mipmap levels representing roughness values.\n   * Prefiltering will be invoked at the end of next rendering pass.\n   * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\n   * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\n   * @param texture Texture to filter\n   * @param onFinished Callback when filtering is done\n   * @returns Promise called when prefiltering is done\n   */\n  prefilter(texture, onFinished = null) {\n    if (!this._engine._features.allowTexturePrefiltering) {\n      Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n      return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\n    }\n    return new Promise(resolve => {\n      this._effectRenderer = new EffectRenderer(this._engine);\n      this._effectWrapper = this._createEffect(texture);\n      this._effectWrapper.effect.executeWhenCompiled(() => {\n        this._prefilterInternal(texture);\n        this._effectRenderer.dispose();\n        this._effectWrapper.dispose();\n        resolve();\n        if (onFinished) {\n          onFinished();\n        }\n      });\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Scalar","EffectWrapper","EffectRenderer","Logger","HDRFiltering","constructor","engine","options","_engine","hdrScale","quality","_createRenderTarget","size","textureType","getCaps","textureHalfFloatRender","textureFloatRender","rtWrapper","createRenderTargetCubeTexture","format","type","createMipMaps","generateMipMaps","generateDepthBuffer","generateStencilBuffer","samplingMode","updateTextureWrappingMode","texture","updateTextureSamplingMode","_prefilterInternal","width","getSize","mipmapsCount","ILog2","effect","_effectWrapper","outputTexture","_effectRenderer","setViewport","intTexture","getInternalTexture","applyEffectWrapper","directions","setFloat","setFloat2","setTexture","face","setVector3","lod","bindFramebuffer","undefined","alpha","Math","pow","_lodGenerationOffset","_lodGenerationScale","draw","restoreStates","restoreDefaultFramebuffer","_releaseTexture","_texture","_swapAndDie","_prefiltered","_createEffect","onCompiled","defines","gammaSpace","push","effectWrapper","name","vertexShader","fragmentShader","samplerNames","uniformNames","useShaderStore","isReady","prefilter","onFinished","_features","allowTexturePrefiltering","Warn","Promise","reject","resolve","executeWhenCompiled","dispose"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/Filtering/hdrFiltering.ts"],"sourcesContent":["import { Vector3 } from \"../../../Maths/math\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { BaseTexture } from \"../baseTexture\";\r\nimport type { ThinEngine } from \"../../../Engines/thinEngine\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { EffectWrapper, EffectRenderer } from \"../../../Materials/effectRenderer\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\n\r\nimport \"../../../Shaders/hdrFiltering.vertex\";\r\nimport \"../../../Shaders/hdrFiltering.fragment\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\n\r\n/**\r\n * Options for texture filtering\r\n */\r\ninterface IHDRFilteringOptions {\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    hdrScale?: number;\r\n\r\n    /**\r\n     * Quality of the filter. Should be `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` for prefiltering\r\n     */\r\n    quality?: number;\r\n}\r\n\r\n/**\r\n * Filters HDR maps to get correct renderings of PBR reflections\r\n */\r\nexport class HDRFiltering {\r\n    private _engine: ThinEngine;\r\n    private _effectRenderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n\r\n    private _lodGenerationOffset: number = 0;\r\n    private _lodGenerationScale: number = 0.8;\r\n\r\n    /**\r\n     * Quality switch for prefiltering. Should be set to `Constants.TEXTURE_FILTERING_QUALITY_OFFLINE` unless\r\n     * you care about baking speed.\r\n     */\r\n    public quality: number = Constants.TEXTURE_FILTERING_QUALITY_OFFLINE;\r\n\r\n    /**\r\n     * Scales pixel intensity for the input HDR map.\r\n     */\r\n    public hdrScale: number = 1;\r\n\r\n    /**\r\n     * Instantiates HDR filter for reflection maps\r\n     *\r\n     * @param engine Thin engine\r\n     * @param options Options\r\n     */\r\n    constructor(engine: ThinEngine, options: IHDRFilteringOptions = {}) {\r\n        // pass\r\n        this._engine = engine;\r\n        this.hdrScale = options.hdrScale || this.hdrScale;\r\n        this.quality = options.quality || this.quality;\r\n    }\r\n\r\n    private _createRenderTarget(size: number): RenderTargetWrapper {\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else if (this._engine.getCaps().textureFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        const rtWrapper = this._engine.createRenderTargetCubeTexture(size, {\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n            type: textureType,\r\n            createMipMaps: true,\r\n            generateMipMaps: false,\r\n            generateDepthBuffer: false,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        });\r\n        this._engine.updateTextureWrappingMode(rtWrapper.texture!, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE, Constants.TEXTURE_CLAMP_ADDRESSMODE);\r\n\r\n        this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, rtWrapper.texture!, true);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    private _prefilterInternal(texture: BaseTexture): BaseTexture {\r\n        const width = texture.getSize().width;\r\n        const mipmapsCount = Scalar.ILog2(width) + 1;\r\n\r\n        const effect = this._effectWrapper.effect;\r\n        const outputTexture = this._createRenderTarget(width);\r\n        this._effectRenderer.setViewport();\r\n\r\n        const intTexture = texture.getInternalTexture();\r\n        if (intTexture) {\r\n            // Just in case generate fresh clean mips.\r\n            this._engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, intTexture, true);\r\n        }\r\n\r\n        this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n        const directions = [\r\n            [new Vector3(0, 0, -1), new Vector3(0, -1, 0), new Vector3(1, 0, 0)], // PositiveX\r\n            [new Vector3(0, 0, 1), new Vector3(0, -1, 0), new Vector3(-1, 0, 0)], // NegativeX\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 1, 0)], // PositiveY\r\n            [new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)], // NegativeY\r\n            [new Vector3(1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1)], // PositiveZ\r\n            [new Vector3(-1, 0, 0), new Vector3(0, -1, 0), new Vector3(0, 0, -1)], // NegativeZ\r\n        ];\r\n\r\n        effect.setFloat(\"hdrScale\", this.hdrScale);\r\n        effect.setFloat2(\"vFilteringInfo\", texture.getSize().width, mipmapsCount);\r\n        effect.setTexture(\"inputTexture\", texture);\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            effect.setVector3(\"up\", directions[face][0]);\r\n            effect.setVector3(\"right\", directions[face][1]);\r\n            effect.setVector3(\"front\", directions[face][2]);\r\n\r\n            for (let lod = 0; lod < mipmapsCount; lod++) {\r\n                this._engine.bindFramebuffer(outputTexture, face, undefined, undefined, true, lod);\r\n                this._effectRenderer.applyEffectWrapper(this._effectWrapper);\r\n\r\n                let alpha = Math.pow(2, (lod - this._lodGenerationOffset) / this._lodGenerationScale) / width;\r\n                if (lod === 0) {\r\n                    alpha = 0;\r\n                }\r\n\r\n                effect.setFloat(\"alphaG\", alpha);\r\n\r\n                this._effectRenderer.draw();\r\n            }\r\n        }\r\n\r\n        // Cleanup\r\n        this._effectRenderer.restoreStates();\r\n        this._engine.restoreDefaultFramebuffer();\r\n        this._engine._releaseTexture(texture._texture!);\r\n\r\n        // Internal Swap\r\n        outputTexture._swapAndDie(texture._texture!);\r\n\r\n        texture._prefiltered = true;\r\n\r\n        return texture;\r\n    }\r\n\r\n    private _createEffect(texture: BaseTexture, onCompiled?: Nullable<(effect: Effect) => void>): EffectWrapper {\r\n        const defines = [];\r\n        if (texture.gammaSpace) {\r\n            defines.push(\"#define GAMMA_INPUT\");\r\n        }\r\n\r\n        defines.push(\"#define NUM_SAMPLES \" + this.quality + \"u\"); // unsigned int\r\n\r\n        const effectWrapper = new EffectWrapper({\r\n            engine: this._engine,\r\n            name: \"hdrFiltering\",\r\n            vertexShader: \"hdrFiltering\",\r\n            fragmentShader: \"hdrFiltering\",\r\n            samplerNames: [\"inputTexture\"],\r\n            uniformNames: [\"vSampleDirections\", \"vWeights\", \"up\", \"right\", \"front\", \"vFilteringInfo\", \"hdrScale\", \"alphaG\"],\r\n            useShaderStore: true,\r\n            defines,\r\n            onCompiled: onCompiled,\r\n        });\r\n\r\n        return effectWrapper;\r\n    }\r\n\r\n    /**\r\n     * Get a value indicating if the filter is ready to be used\r\n     * @param texture Texture to filter\r\n     * @returns true if the filter is ready\r\n     */\r\n    public isReady(texture: BaseTexture) {\r\n        return texture.isReady() && this._effectWrapper.effect.isReady();\r\n    }\r\n\r\n    /**\r\n     * Prefilters a cube texture to have mipmap levels representing roughness values.\r\n     * Prefiltering will be invoked at the end of next rendering pass.\r\n     * This has to be done once the map is loaded, and has not been prefiltered by a third party software.\r\n     * See http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf for more information\r\n     * @param texture Texture to filter\r\n     * @param onFinished Callback when filtering is done\r\n     * @returns Promise called when prefiltering is done\r\n     */\r\n    public prefilter(texture: BaseTexture, onFinished: Nullable<() => void> = null): Promise<void> {\r\n        if (!this._engine._features.allowTexturePrefiltering) {\r\n            Logger.Warn(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n            return Promise.reject(\"HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.\");\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            this._effectRenderer = new EffectRenderer(this._engine);\r\n            this._effectWrapper = this._createEffect(texture);\r\n            this._effectWrapper.effect.executeWhenCompiled(() => {\r\n                this._prefilterInternal(texture);\r\n                this._effectRenderer.dispose();\r\n                this._effectWrapper.dispose();\r\n                resolve();\r\n                if (onFinished) {\r\n                    onFinished();\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}