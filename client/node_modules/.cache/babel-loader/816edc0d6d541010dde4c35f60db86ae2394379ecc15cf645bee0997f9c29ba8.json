{"ast":null,"code":"import { Action } from \"./action.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * This defines an action responsible to change the value of a property\n * by interpolating between its current value and the newly set one once triggered.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\n */\nexport class InterpolateValueAction extends Action {\n  /**\n   * Instantiate the action\n   * @param triggerOptions defines the trigger options\n   * @param target defines the object containing the value to interpolate\n   * @param propertyPath defines the path to the property in the target object\n   * @param value defines the target value at the end of the interpolation\n   * @param duration defines the time it will take for the property to interpolate to the value.\n   * @param condition defines the trigger related conditions\n   * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered\n   * @param onInterpolationDone defines a callback raised once the interpolation animation has been done\n   */\n  constructor(triggerOptions, target, propertyPath, value, duration = 1000, condition, stopOtherAnimations, onInterpolationDone) {\n    super(triggerOptions, condition);\n    /**\n     * Defines the time it will take for the property to interpolate to the value.\n     */\n    this.duration = 1000;\n    /**\n     * Observable triggered once the interpolation animation has been done.\n     */\n    this.onInterpolationDoneObservable = new Observable();\n    this.propertyPath = propertyPath;\n    this.value = value;\n    this.duration = duration;\n    this.stopOtherAnimations = stopOtherAnimations;\n    this.onInterpolationDone = onInterpolationDone;\n    this._target = this._effectiveTarget = target;\n  }\n  /** @internal */\n  _prepare() {\n    this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n    this._property = this._getProperty(this.propertyPath);\n  }\n  /**\n   * Execute the action starts the value interpolation.\n   */\n  execute() {\n    const scene = this._actionManager.getScene();\n    const keys = [{\n      frame: 0,\n      value: this._effectiveTarget[this._property]\n    }, {\n      frame: 100,\n      value: this.value\n    }];\n    let dataType;\n    if (typeof this.value === \"number\") {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (this.value instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (this.value instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (this.value instanceof Matrix) {\n      dataType = Animation.ANIMATIONTYPE_MATRIX;\n    } else if (this.value instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else {\n      Logger.Warn(\"InterpolateValueAction: Unsupported type (\" + typeof this.value + \")\");\n      return;\n    }\n    const animation = new Animation(\"InterpolateValueAction\", this._property, 100 * (1000.0 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setKeys(keys);\n    if (this.stopOtherAnimations) {\n      scene.stopAnimation(this._effectiveTarget);\n    }\n    const wrapper = () => {\n      this.onInterpolationDoneObservable.notifyObservers(this);\n      if (this.onInterpolationDone) {\n        this.onInterpolationDone();\n      }\n    };\n    scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);\n  }\n  /**\n   * Serializes the actions and its related information.\n   * @param parent defines the object to serialize in\n   * @returns the serialized object\n   */\n  serialize(parent) {\n    return super._serialize({\n      name: \"InterpolateValueAction\",\n      properties: [Action._GetTargetProperty(this._target), {\n        name: \"propertyPath\",\n        value: this.propertyPath\n      }, {\n        name: \"value\",\n        value: Action._SerializeValueAsString(this.value)\n      }, {\n        name: \"duration\",\n        value: Action._SerializeValueAsString(this.duration)\n      }, {\n        name: \"stopOtherAnimations\",\n        value: Action._SerializeValueAsString(this.stopOtherAnimations) || false\n      }]\n    }, parent);\n  }\n}\nRegisterClass(\"BABYLON.InterpolateValueAction\", InterpolateValueAction);","map":{"version":3,"mappings":"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","names":["Action","Logger","Observable","Color3","Vector3","Matrix","Quaternion","Animation","RegisterClass","InterpolateValueAction","constructor","triggerOptions","target","propertyPath","value","duration","condition","stopOtherAnimations","onInterpolationDone","_target","_effectiveTarget","_prepare","_getEffectiveTarget","_property","_getProperty","execute","scene","_actionManager","getScene","keys","frame","dataType","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_COLOR3","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","Warn","animation","ANIMATIONLOOPMODE_CONSTANT","setKeys","stopAnimation","wrapper","onInterpolationDoneObservable","notifyObservers","beginDirectAnimation","serialize","parent","_serialize","name","properties","_GetTargetProperty","_SerializeValueAsString"],"sourceRoot":"","sources":["../../../../lts/core/generated/Actions/interpolateValueAction.ts"],"sourcesContent":["import { Action } from \"./action\";\r\nimport type { Condition } from \"./condition\";\r\n\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Vector3, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * This defines an action responsible to change the value of a property\r\n * by interpolating between its current value and the newly set one once triggered.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\r\n */\r\nexport class InterpolateValueAction extends Action {\r\n    /**\r\n     * Defines the path of the property where the value should be interpolated\r\n     */\r\n    public propertyPath: string;\r\n\r\n    /**\r\n     * Defines the target value at the end of the interpolation.\r\n     */\r\n    public value: any;\r\n\r\n    /**\r\n     * Defines the time it will take for the property to interpolate to the value.\r\n     */\r\n    public duration: number = 1000;\r\n\r\n    /**\r\n     * Defines if the other scene animations should be stopped when the action has been triggered\r\n     */\r\n    public stopOtherAnimations?: boolean;\r\n\r\n    /**\r\n     * Defines a callback raised once the interpolation animation has been done.\r\n     */\r\n    public onInterpolationDone?: () => void;\r\n\r\n    /**\r\n     * Observable triggered once the interpolation animation has been done.\r\n     */\r\n    public onInterpolationDoneObservable = new Observable<InterpolateValueAction>();\r\n\r\n    private _target: any;\r\n    private _effectiveTarget: any;\r\n    private _property: string;\r\n\r\n    /**\r\n     * Instantiate the action\r\n     * @param triggerOptions defines the trigger options\r\n     * @param target defines the object containing the value to interpolate\r\n     * @param propertyPath defines the path to the property in the target object\r\n     * @param value defines the target value at the end of the interpolation\r\n     * @param duration defines the time it will take for the property to interpolate to the value.\r\n     * @param condition defines the trigger related conditions\r\n     * @param stopOtherAnimations defines if the other scene animations should be stopped when the action has been triggered\r\n     * @param onInterpolationDone defines a callback raised once the interpolation animation has been done\r\n     */\r\n    constructor(\r\n        triggerOptions: any,\r\n        target: any,\r\n        propertyPath: string,\r\n        value: any,\r\n        duration: number = 1000,\r\n        condition?: Condition,\r\n        stopOtherAnimations?: boolean,\r\n        onInterpolationDone?: () => void\r\n    ) {\r\n        super(triggerOptions, condition);\r\n\r\n        this.propertyPath = propertyPath;\r\n        this.value = value;\r\n        this.duration = duration;\r\n        this.stopOtherAnimations = stopOtherAnimations;\r\n        this.onInterpolationDone = onInterpolationDone;\r\n        this._target = this._effectiveTarget = target;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prepare(): void {\r\n        this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\r\n        this._property = this._getProperty(this.propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Execute the action starts the value interpolation.\r\n     */\r\n    public execute(): void {\r\n        const scene = this._actionManager.getScene();\r\n        const keys = [\r\n            {\r\n                frame: 0,\r\n                value: this._effectiveTarget[this._property],\r\n            },\r\n            {\r\n                frame: 100,\r\n                value: this.value,\r\n            },\r\n        ];\r\n\r\n        let dataType: number;\r\n\r\n        if (typeof this.value === \"number\") {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (this.value instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (this.value instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (this.value instanceof Matrix) {\r\n            dataType = Animation.ANIMATIONTYPE_MATRIX;\r\n        } else if (this.value instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else {\r\n            Logger.Warn(\"InterpolateValueAction: Unsupported type (\" + typeof this.value + \")\");\r\n            return;\r\n        }\r\n\r\n        const animation = new Animation(\"InterpolateValueAction\", this._property, 100 * (1000.0 / this.duration), dataType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (this.stopOtherAnimations) {\r\n            scene.stopAnimation(this._effectiveTarget);\r\n        }\r\n\r\n        const wrapper = () => {\r\n            this.onInterpolationDoneObservable.notifyObservers(this);\r\n            if (this.onInterpolationDone) {\r\n                this.onInterpolationDone();\r\n            }\r\n        };\r\n\r\n        scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, wrapper);\r\n    }\r\n\r\n    /**\r\n     * Serializes the actions and its related information.\r\n     * @param parent defines the object to serialize in\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(parent: any): any {\r\n        return super._serialize(\r\n            {\r\n                name: \"InterpolateValueAction\",\r\n                properties: [\r\n                    Action._GetTargetProperty(this._target),\r\n                    { name: \"propertyPath\", value: this.propertyPath },\r\n                    { name: \"value\", value: Action._SerializeValueAsString(this.value) },\r\n                    { name: \"duration\", value: Action._SerializeValueAsString(this.duration) },\r\n                    { name: \"stopOtherAnimations\", value: Action._SerializeValueAsString(this.stopOtherAnimations) || false },\r\n                ],\r\n            },\r\n            parent\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.InterpolateValueAction\", InterpolateValueAction);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}