{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\n  return () => new HemisphericLight(name, Vector3.Zero(), scene);\n});\n/**\n * The HemisphericLight simulates the ambient environment light,\n * so the passed direction is the light reflection direction, not the incoming direction.\n */\nexport class HemisphericLight extends Light {\n  /**\n   * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\n   * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\n   * The HemisphericLight can't cast shadows.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param direction The direction of the light reflection\n   * @param scene The scene the light belongs to\n   */\n  constructor(name, direction, scene) {\n    super(name, scene);\n    /**\n     * The groundColor is the light in the opposite direction to the one specified during creation.\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\n     */\n    this.groundColor = new Color3(0.0, 0.0, 0.0);\n    this.direction = direction || Vector3.Up();\n  }\n  _buildUniformLayout() {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n    this._uniformBuffer.addUniform(\"vLightGround\", 3);\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n    this._uniformBuffer.create();\n  }\n  /**\n   * Returns the string \"HemisphericLight\".\n   * @returns The class name\n   */\n  getClassName() {\n    return \"HemisphericLight\";\n  }\n  /**\n   * Sets the HemisphericLight direction towards the passed target (Vector3).\n   * Returns the updated direction.\n   * @param target The target the direction should point to\n   * @returns The computed direction\n   */\n  setDirectionToTarget(target) {\n    this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\n    return this.direction;\n  }\n  /**\n   * Returns the shadow generator associated to the light.\n   * @returns Always null for hemispheric lights because it does not support shadows.\n   */\n  getShadowGenerator() {\n    return null;\n  }\n  /**\n   * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\n   * @param _effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The hemispheric light\n   */\n  transferToEffect(_effect, lightIndex) {\n    const normalizeDirection = Vector3.Normalize(this.direction);\n    this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n    this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n    return this;\n  }\n  transferToNodeMaterialEffect(effect, lightDataUniformName) {\n    const normalizeDirection = Vector3.Normalize(this.direction);\n    effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n    return this;\n  }\n  /**\n   * Computes the world matrix of the node\n   * @returns the world matrix\n   */\n  computeWorldMatrix() {\n    if (!this._worldMatrix) {\n      this._worldMatrix = Matrix.Identity();\n    }\n    return this._worldMatrix;\n  }\n  /**\n   * Returns the integer 3.\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n  }\n  /**\n   * Prepares the list of defines specific to the light type.\n   * @param defines the list of defines\n   * @param lightIndex defines the index of the light for the effect\n   */\n  prepareLightSpecificDefines(defines, lightIndex) {\n    defines[\"HEMILIGHT\" + lightIndex] = true;\n  }\n}\n__decorate([serializeAsColor3()], HemisphericLight.prototype, \"groundColor\", void 0);\n__decorate([serializeAsVector3()], HemisphericLight.prototype, \"direction\", void 0);","map":{"version":3,"mappings":"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","names":["serializeAsColor3","serializeAsVector3","Matrix","Vector3","Color3","Node","Light","AddNodeConstructor","name","scene","HemisphericLight","Zero","constructor","direction","Up","_buildUniformLayout","_uniformBuffer","addUniform","create","getClassName","setDirectionToTarget","target","Normalize","subtract","getShadowGenerator","transferToEffect","_effect","lightIndex","normalizeDirection","updateFloat4","x","y","z","updateColor3","groundColor","scale","intensity","transferToNodeMaterialEffect","effect","lightDataUniformName","setFloat3","computeWorldMatrix","_worldMatrix","Identity","getTypeID","LIGHTTYPEID_HEMISPHERICLIGHT","prepareLightSpecificDefines","defines","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Lights/hemisphericLight.ts"],"sourcesContent":["import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}