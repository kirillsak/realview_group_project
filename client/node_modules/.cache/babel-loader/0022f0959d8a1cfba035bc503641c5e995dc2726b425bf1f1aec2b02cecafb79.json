{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\n\n/**\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\n */\nexport class PanoramaToCubeMapTools {\n  /**\n   * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\n   *\n   * @param float32Array The source data.\n   * @param inputWidth The width of the input panorama.\n   * @param inputHeight The height of the input panorama.\n   * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n   * @returns The cubemap data\n   */\n  static ConvertPanoramaToCubemap(float32Array, inputWidth, inputHeight, size) {\n    if (!float32Array) {\n      throw \"ConvertPanoramaToCubemap: input cannot be null\";\n    }\n    if (float32Array.length != inputWidth * inputHeight * 3) {\n      throw \"ConvertPanoramaToCubemap: input size is wrong\";\n    }\n    const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\n    const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\n    const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\n    const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\n    const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\n    const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\n    return {\n      front: textureFront,\n      back: textureBack,\n      left: textureLeft,\n      right: textureRight,\n      up: textureUp,\n      down: textureDown,\n      size: size,\n      type: 1,\n      format: 4,\n      gammaSpace: false\n    };\n  }\n  static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight) {\n    const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n    const textureArray = new Float32Array(buffer);\n    const rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\n    const rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\n    const dy = 1 / texSize;\n    let fy = 0;\n    for (let y = 0; y < texSize; y++) {\n      let xv1 = faceData[0];\n      let xv2 = faceData[2];\n      for (let x = 0; x < texSize; x++) {\n        const v = xv2.subtract(xv1).scale(fy).add(xv1);\n        v.normalize();\n        const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\n        // 3 channels per pixels\n        textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\n        textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\n        textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\n        xv1 = xv1.add(rotDX1);\n        xv2 = xv2.add(rotDX2);\n      }\n      fy += dy;\n    }\n    return textureArray;\n  }\n  static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight) {\n    let theta = Math.atan2(vDir.z, vDir.x);\n    const phi = Math.acos(vDir.y);\n    while (theta < -Math.PI) {\n      theta += 2 * Math.PI;\n    }\n    while (theta > Math.PI) {\n      theta -= 2 * Math.PI;\n    }\n    let dx = theta / Math.PI;\n    const dy = phi / Math.PI;\n    // recenter.\n    dx = dx * 0.5 + 0.5;\n    let px = Math.round(dx * inputWidth);\n    if (px < 0) {\n      px = 0;\n    } else if (px >= inputWidth) {\n      px = inputWidth - 1;\n    }\n    let py = Math.round(dy * inputHeight);\n    if (py < 0) {\n      py = 0;\n    } else if (py >= inputHeight) {\n      py = inputHeight - 1;\n    }\n    const inputY = inputHeight - py - 1;\n    const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\n    const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\n    const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\n    return {\n      r: r,\n      g: g,\n      b: b\n    };\n  }\n}\nPanoramaToCubeMapTools.FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\nPanoramaToCubeMapTools.FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\nPanoramaToCubeMapTools.FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];","map":{"version":3,"mappings":"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","names":["Vector3","PanoramaToCubeMapTools","ConvertPanoramaToCubemap","float32Array","inputWidth","inputHeight","size","length","textureFront","CreateCubemapTexture","FACE_FRONT","textureBack","FACE_BACK","textureLeft","FACE_LEFT","textureRight","FACE_RIGHT","textureUp","FACE_UP","textureDown","FACE_DOWN","front","back","left","right","up","down","type","format","gammaSpace","texSize","faceData","buffer","ArrayBuffer","textureArray","Float32Array","rotDX1","subtract","scale","rotDX2","dy","fy","y","xv1","xv2","x","v","add","normalize","color","CalcProjectionSpherical","r","g","b","vDir","theta","Math","atan2","z","phi","acos","PI","dx","px","round","py","inputY"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/HighDynamicRange/panoramaToCubemap.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * CubeMap information grouping all the data for each faces as well as the cubemap size.\r\n */\r\nexport interface CubeMapInfo {\r\n    /**\r\n     * The pixel array for the front face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    front: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the back face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    back: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the left face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    left: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the right face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    right: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the up face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    up: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The pixel array for the down face.\r\n     * This is stored in format, left to right, up to down format.\r\n     */\r\n    down: Nullable<ArrayBufferView>;\r\n\r\n    /**\r\n     * The size of the cubemap stored.\r\n     *\r\n     * Each faces will be size * size pixels.\r\n     */\r\n    size: number;\r\n\r\n    /**\r\n     * The format of the texture.\r\n     *\r\n     * RGBA, RGB.\r\n     */\r\n    format: number;\r\n\r\n    /**\r\n     * The type of the texture data.\r\n     *\r\n     * UNSIGNED_INT, FLOAT.\r\n     */\r\n    type: number;\r\n\r\n    /**\r\n     * Specifies whether the texture is in gamma space.\r\n     */\r\n    gammaSpace: boolean;\r\n}\r\n\r\n/**\r\n * Helper class useful to convert panorama picture to their cubemap representation in 6 faces.\r\n */\r\nexport class PanoramaToCubeMapTools {\r\n    private static FACE_LEFT = [new Vector3(-1.0, -1.0, -1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(1.0, 1.0, -1.0)];\r\n    private static FACE_RIGHT = [new Vector3(1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_FRONT = [new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0), new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0)];\r\n    private static FACE_BACK = [new Vector3(-1.0, -1.0, 1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0)];\r\n    private static FACE_DOWN = [new Vector3(1.0, 1.0, -1.0), new Vector3(1.0, 1.0, 1.0), new Vector3(-1.0, 1.0, -1.0), new Vector3(-1.0, 1.0, 1.0)];\r\n    private static FACE_UP = [new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, 1.0), new Vector3(1.0, -1.0, -1.0), new Vector3(1.0, -1.0, 1.0)];\r\n\r\n    /**\r\n     * Converts a panorama stored in RGB right to left up to down format into a cubemap (6 faces).\r\n     *\r\n     * @param float32Array The source data.\r\n     * @param inputWidth The width of the input panorama.\r\n     * @param inputHeight The height of the input panorama.\r\n     * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\r\n     * @returns The cubemap data\r\n     */\r\n    public static ConvertPanoramaToCubemap(float32Array: Float32Array, inputWidth: number, inputHeight: number, size: number): CubeMapInfo {\r\n        if (!float32Array) {\r\n            throw \"ConvertPanoramaToCubemap: input cannot be null\";\r\n        }\r\n\r\n        if (float32Array.length != inputWidth * inputHeight * 3) {\r\n            throw \"ConvertPanoramaToCubemap: input size is wrong\";\r\n        }\r\n\r\n        const textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\r\n        const textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\r\n        const textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\r\n        const textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\r\n        const textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\r\n        const textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\r\n\r\n        return {\r\n            front: textureFront,\r\n            back: textureBack,\r\n            left: textureLeft,\r\n            right: textureRight,\r\n            up: textureUp,\r\n            down: textureDown,\r\n            size: size,\r\n            type: Constants.TEXTURETYPE_FLOAT,\r\n            format: Constants.TEXTUREFORMAT_RGB,\r\n            gammaSpace: false,\r\n        };\r\n    }\r\n\r\n    private static CreateCubemapTexture(texSize: number, faceData: Vector3[], float32Array: Float32Array, inputWidth: number, inputHeight: number) {\r\n        const buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\r\n        const textureArray = new Float32Array(buffer);\r\n\r\n        const rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\r\n        const rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\r\n\r\n        const dy = 1 / texSize;\r\n        let fy = 0;\r\n\r\n        for (let y = 0; y < texSize; y++) {\r\n            let xv1 = faceData[0];\r\n            let xv2 = faceData[2];\r\n\r\n            for (let x = 0; x < texSize; x++) {\r\n                const v = xv2.subtract(xv1).scale(fy).add(xv1);\r\n                v.normalize();\r\n\r\n                const color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\r\n\r\n                // 3 channels per pixels\r\n                textureArray[y * texSize * 3 + x * 3 + 0] = color.r;\r\n                textureArray[y * texSize * 3 + x * 3 + 1] = color.g;\r\n                textureArray[y * texSize * 3 + x * 3 + 2] = color.b;\r\n\r\n                xv1 = xv1.add(rotDX1);\r\n                xv2 = xv2.add(rotDX2);\r\n            }\r\n\r\n            fy += dy;\r\n        }\r\n\r\n        return textureArray;\r\n    }\r\n\r\n    private static CalcProjectionSpherical(vDir: Vector3, float32Array: Float32Array, inputWidth: number, inputHeight: number): any {\r\n        let theta = Math.atan2(vDir.z, vDir.x);\r\n        const phi = Math.acos(vDir.y);\r\n\r\n        while (theta < -Math.PI) {\r\n            theta += 2 * Math.PI;\r\n        }\r\n        while (theta > Math.PI) {\r\n            theta -= 2 * Math.PI;\r\n        }\r\n\r\n        let dx = theta / Math.PI;\r\n        const dy = phi / Math.PI;\r\n\r\n        // recenter.\r\n        dx = dx * 0.5 + 0.5;\r\n\r\n        let px = Math.round(dx * inputWidth);\r\n        if (px < 0) {\r\n            px = 0;\r\n        } else if (px >= inputWidth) {\r\n            px = inputWidth - 1;\r\n        }\r\n\r\n        let py = Math.round(dy * inputHeight);\r\n        if (py < 0) {\r\n            py = 0;\r\n        } else if (py >= inputHeight) {\r\n            py = inputHeight - 1;\r\n        }\r\n\r\n        const inputY = inputHeight - py - 1;\r\n        const r = float32Array[inputY * inputWidth * 3 + px * 3 + 0];\r\n        const g = float32Array[inputY * inputWidth * 3 + px * 3 + 1];\r\n        const b = float32Array[inputY * inputWidth * 3 + px * 3 + 2];\r\n\r\n        return {\r\n            r: r,\r\n            g: g,\r\n            b: b,\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}