{"ast":null,"code":"/**\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\n */\nexport class FadeInOutBehavior {\n  /**\n   * Instantiates the FadeInOutBehavior\n   */\n  constructor() {\n    /**\n     * Time in milliseconds to delay before fading in (Default: 0)\n     */\n    this.fadeInDelay = 0;\n    /**\n     * Time in milliseconds to delay before fading out (Default: 0)\n     */\n    this.fadeOutDelay = 0;\n    /**\n     * Time in milliseconds for the mesh to fade in (Default: 300)\n     */\n    this.fadeInTime = 300;\n    /**\n     * Time in milliseconds for the mesh to fade out (Default: 300)\n     */\n    this.fadeOutTime = 300;\n    this._millisecondsPerFrame = 1000 / 60;\n    this._hovered = false;\n    this._hoverValue = 0;\n    this._ownerNode = null;\n    this._delay = 0;\n    this._time = 300;\n    this._update = () => {\n      if (this._ownerNode) {\n        this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\n        this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\n        if (this._ownerNode.visibility > 1) {\n          this._setAllVisibility(this._ownerNode, 1);\n          if (this._hoverValue > this._time) {\n            this._hoverValue = this._time;\n            this._detachObserver();\n            return;\n          }\n        } else if (this._ownerNode.visibility < 0) {\n          this._setAllVisibility(this._ownerNode, 0);\n          if (this._hoverValue < 0) {\n            this._hoverValue = 0;\n            this._detachObserver();\n            return;\n          }\n        }\n        this._attachObserver();\n      }\n    };\n  }\n  /**\n   * Time in milliseconds to delay before fading in (Default: 0)\n   * Will set both fade in and out delay to the same value\n   */\n  get delay() {\n    return this.fadeInDelay;\n  }\n  set delay(value) {\n    this.fadeInDelay = value;\n    this.fadeOutDelay = value;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"FadeInOut\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  /**\n   * Attaches the fade behavior on the passed in mesh\n   * @param ownerNode The mesh that will be faded in/out once attached\n   */\n  attach(ownerNode) {\n    this._ownerNode = ownerNode;\n    this._setAllVisibility(this._ownerNode, 0);\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._ownerNode = null;\n  }\n  /**\n   * Triggers the mesh to begin fading in (or out)\n   * @param fadeIn if the object should fade in or out (true to fade in)\n   */\n  fadeIn(fadeIn = true) {\n    this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\n    this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\n    // Cancel any pending updates\n    this._detachObserver();\n    // If fading in and already visible or fading out and already not visible do nothing\n    if (this._ownerNode && (fadeIn && this._ownerNode.visibility >= 1 || !fadeIn && this._ownerNode.visibility <= 0)) {\n      return;\n    }\n    this._hovered = fadeIn;\n    if (!this._hovered) {\n      // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\n      // fadeOutDelay has elapsed\n      this._delay *= -1;\n    }\n    // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\n    // the delay, so the hover value is greater than 1\n    if (this._ownerNode.visibility >= 1) {\n      this._hoverValue = this._time;\n    } else if (this._ownerNode.visibility <= 0) {\n      this._hoverValue = 0;\n    }\n    this._update();\n  }\n  /**\n   * Triggers the mesh to begin fading out\n   */\n  fadeOut() {\n    this.fadeIn(false);\n  }\n  _setAllVisibility(mesh, value) {\n    mesh.visibility = value;\n    mesh.getChildMeshes().forEach(c => {\n      this._setAllVisibility(c, value);\n    });\n  }\n  _attachObserver() {\n    var _a;\n    if (!this._onBeforeRenderObserver) {\n      this._onBeforeRenderObserver = (_a = this._ownerNode) === null || _a === void 0 ? void 0 : _a.getScene().onBeforeRenderObservable.add(this._update);\n    }\n  }\n  _detachObserver() {\n    var _a;\n    if (this._onBeforeRenderObserver) {\n      (_a = this._ownerNode) === null || _a === void 0 ? void 0 : _a.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      this._onBeforeRenderObserver = null;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["FadeInOutBehavior","constructor","_ownerNode","_hoverValue","_hovered","_millisecondsPerFrame","_setAllVisibility","_delay","_time","visibility","_detachObserver","_attachObserver","delay","fadeInDelay","value","fadeOutDelay","name","init","attach","ownerNode","detach","fadeIn","fadeInTime","fadeOutTime","_update","fadeOut","mesh","getChildMeshes","forEach","c","_onBeforeRenderObserver","getScene","onBeforeRenderObservable","add","remove"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/fadeInOutBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../behavior\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"core/Misc\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will allow the mesh to fade in and out\r\n */\r\nexport class FadeInOutBehavior implements Behavior<Mesh> {\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     */\r\n    public fadeInDelay = 0;\r\n\r\n    /**\r\n     * Time in milliseconds to delay before fading out (Default: 0)\r\n     */\r\n    public fadeOutDelay = 0;\r\n\r\n    /**\r\n     * Time in milliseconds for the mesh to fade in (Default: 300)\r\n     */\r\n    public fadeInTime = 300;\r\n\r\n    /**\r\n     * Time in milliseconds for the mesh to fade out (Default: 300)\r\n     */\r\n    public fadeOutTime = 300;\r\n\r\n    /**\r\n     * Time in milliseconds to delay before fading in (Default: 0)\r\n     * Will set both fade in and out delay to the same value\r\n     */\r\n    public get delay(): number {\r\n        return this.fadeInDelay;\r\n    }\r\n\r\n    public set delay(value: number) {\r\n        this.fadeInDelay = value;\r\n        this.fadeOutDelay = value;\r\n    }\r\n\r\n    private _millisecondsPerFrame = 1000 / 60;\r\n    private _hovered = false;\r\n    private _hoverValue = 0;\r\n    private _ownerNode: Nullable<Mesh> = null;\r\n    private _onBeforeRenderObserver: Nullable<Observer<Scene>> | undefined;\r\n    private _delay: number = 0;\r\n    private _time: number = 300;\r\n\r\n    /**\r\n     * Instantiates the FadeInOutBehavior\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"FadeInOut\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the fade behavior on the passed in mesh\r\n     * @param ownerNode The mesh that will be faded in/out once attached\r\n     */\r\n    public attach(ownerNode: Mesh): void {\r\n        this._ownerNode = ownerNode;\r\n        this._setAllVisibility(this._ownerNode, 0);\r\n    }\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this._ownerNode = null;\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading in (or out)\r\n     * @param fadeIn if the object should fade in or out (true to fade in)\r\n     */\r\n    public fadeIn(fadeIn: boolean = true) {\r\n        this._delay = fadeIn ? this.fadeInDelay : this.fadeOutDelay;\r\n        this._time = fadeIn ? this.fadeInTime : this.fadeOutTime;\r\n\r\n        // Cancel any pending updates\r\n        this._detachObserver();\r\n\r\n        // If fading in and already visible or fading out and already not visible do nothing\r\n        if (this._ownerNode && ((fadeIn && this._ownerNode.visibility >= 1) || (!fadeIn && this._ownerNode.visibility <= 0))) {\r\n            return;\r\n        }\r\n\r\n        this._hovered = fadeIn;\r\n        if (!this._hovered) {\r\n            // Make the delay the negative of fadeout delay so the hoverValue is kept above 1 until\r\n            // fadeOutDelay has elapsed\r\n            this._delay *= -1;\r\n        }\r\n\r\n        // Reset the hoverValue.  This is necessary because we may have been fading out, e.g. but not yet reached\r\n        // the delay, so the hover value is greater than 1\r\n        if (this._ownerNode!.visibility >= 1) {\r\n            this._hoverValue = this._time;\r\n        } else if (this._ownerNode!.visibility <= 0) {\r\n            this._hoverValue = 0;\r\n        }\r\n        this._update();\r\n    }\r\n\r\n    /**\r\n     * Triggers the mesh to begin fading out\r\n     */\r\n    public fadeOut() {\r\n        this.fadeIn(false);\r\n    }\r\n\r\n    private _update = () => {\r\n        if (this._ownerNode) {\r\n            this._hoverValue += this._hovered ? this._millisecondsPerFrame : -this._millisecondsPerFrame;\r\n\r\n            this._setAllVisibility(this._ownerNode, (this._hoverValue - this._delay) / this._time);\r\n\r\n            if (this._ownerNode.visibility > 1) {\r\n                this._setAllVisibility(this._ownerNode, 1);\r\n                if (this._hoverValue > this._time) {\r\n                    this._hoverValue = this._time;\r\n                    this._detachObserver();\r\n                    return;\r\n                }\r\n            } else if (this._ownerNode.visibility < 0) {\r\n                this._setAllVisibility(this._ownerNode, 0);\r\n                if (this._hoverValue < 0) {\r\n                    this._hoverValue = 0;\r\n                    this._detachObserver();\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._attachObserver();\r\n        }\r\n    };\r\n\r\n    private _setAllVisibility(mesh: AbstractMesh, value: number) {\r\n        mesh.visibility = value;\r\n        mesh.getChildMeshes().forEach((c) => {\r\n            this._setAllVisibility(c, value);\r\n        });\r\n    }\r\n\r\n    private _attachObserver() {\r\n        if (!this._onBeforeRenderObserver) {\r\n            this._onBeforeRenderObserver = this._ownerNode?.getScene().onBeforeRenderObservable.add(this._update);\r\n        }\r\n    }\r\n\r\n    private _detachObserver() {\r\n        if (this._onBeforeRenderObserver) {\r\n            this._ownerNode?.getScene().onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n            this._onBeforeRenderObserver = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}