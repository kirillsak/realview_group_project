{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize } from \"../Misc/decorators.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Light } from \"./light.js\";\nimport { ShadowLight } from \"./shadowLight.js\";\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\n  return () => new DirectionalLight(name, Vector3.Zero(), scene);\n});\n/**\n * A directional light is defined by a direction (what a surprise!).\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class DirectionalLight extends ShadowLight {\n  /**\n   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n   * The directional light is emitted from everywhere in the given direction.\n   * It can cast shadows.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param direction The direction of the light\n   * @param scene The scene the light belongs to\n   */\n  constructor(name, direction, scene) {\n    super(name, scene);\n    this._shadowFrustumSize = 0;\n    this._shadowOrthoScale = 0.1;\n    /**\n     * Automatically compute the projection matrix to best fit (including all the casters)\n     * on each frame.\n     */\n    this.autoUpdateExtends = true;\n    /**\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\n     * on each frame. autoUpdateExtends must be set to true for this to work\n     */\n    this.autoCalcShadowZBounds = false;\n    // Cache\n    this._orthoLeft = Number.MAX_VALUE;\n    this._orthoRight = Number.MIN_VALUE;\n    this._orthoTop = Number.MIN_VALUE;\n    this._orthoBottom = Number.MAX_VALUE;\n    this.position = direction.scale(-1.0);\n    this.direction = direction;\n  }\n  /**\n   * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n   */\n  get shadowFrustumSize() {\n    return this._shadowFrustumSize;\n  }\n  /**\n   * Specifies a fix frustum size for the shadow generation.\n   */\n  set shadowFrustumSize(value) {\n    this._shadowFrustumSize = value;\n    this.forceProjectionMatrixCompute();\n  }\n  /**\n   * Gets the shadow projection scale against the optimal computed one.\n   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n   * This does not impact in fixed frustum size (shadowFrustumSize being set)\n   */\n  get shadowOrthoScale() {\n    return this._shadowOrthoScale;\n  }\n  /**\n   * Sets the shadow projection scale against the optimal computed one.\n   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\n   * This does not impact in fixed frustum size (shadowFrustumSize being set)\n   */\n  set shadowOrthoScale(value) {\n    this._shadowOrthoScale = value;\n    this.forceProjectionMatrixCompute();\n  }\n  /**\n   * Gets or sets the orthoLeft property used to build the light frustum\n   */\n  get orthoLeft() {\n    return this._orthoLeft;\n  }\n  set orthoLeft(left) {\n    this._orthoLeft = left;\n  }\n  /**\n   * Gets or sets the orthoRight property used to build the light frustum\n   */\n  get orthoRight() {\n    return this._orthoRight;\n  }\n  set orthoRight(right) {\n    this._orthoRight = right;\n  }\n  /**\n   * Gets or sets the orthoTop property used to build the light frustum\n   */\n  get orthoTop() {\n    return this._orthoTop;\n  }\n  set orthoTop(top) {\n    this._orthoTop = top;\n  }\n  /**\n   * Gets or sets the orthoBottom property used to build the light frustum\n   */\n  get orthoBottom() {\n    return this._orthoBottom;\n  }\n  set orthoBottom(bottom) {\n    this._orthoBottom = bottom;\n  }\n  /**\n   * Returns the string \"DirectionalLight\".\n   * @returns The class name\n   */\n  getClassName() {\n    return \"DirectionalLight\";\n  }\n  /**\n   * Returns the integer 1.\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n  }\n  /**\n   * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   * @param viewMatrix\n   * @param renderList\n   */\n  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n    if (this.shadowFrustumSize > 0) {\n      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\n    } else {\n      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n    }\n  }\n  /**\n   * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   */\n  _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {\n    const activeCamera = this.getScene().activeCamera;\n    if (!activeCamera) {\n      return;\n    }\n    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n  }\n  /**\n   * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n   * Returns the DirectionalLight Shadow projection matrix.\n   * @param matrix\n   * @param viewMatrix\n   * @param renderList\n   */\n  _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n    const activeCamera = this.getScene().activeCamera;\n    if (!activeCamera) {\n      return;\n    }\n    // Check extends\n    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n      const tempVector3 = Vector3.Zero();\n      this._orthoLeft = Number.MAX_VALUE;\n      this._orthoRight = Number.MIN_VALUE;\n      this._orthoTop = Number.MIN_VALUE;\n      this._orthoBottom = Number.MAX_VALUE;\n      let shadowMinZ = Number.MAX_VALUE;\n      let shadowMaxZ = Number.MIN_VALUE;\n      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n        const mesh = renderList[meshIndex];\n        if (!mesh) {\n          continue;\n        }\n        const boundingInfo = mesh.getBoundingInfo();\n        const boundingBox = boundingInfo.boundingBox;\n        for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\n          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n          if (tempVector3.x < this._orthoLeft) {\n            this._orthoLeft = tempVector3.x;\n          }\n          if (tempVector3.y < this._orthoBottom) {\n            this._orthoBottom = tempVector3.y;\n          }\n          if (tempVector3.x > this._orthoRight) {\n            this._orthoRight = tempVector3.x;\n          }\n          if (tempVector3.y > this._orthoTop) {\n            this._orthoTop = tempVector3.y;\n          }\n          if (this.autoCalcShadowZBounds) {\n            if (tempVector3.z < shadowMinZ) {\n              shadowMinZ = tempVector3.z;\n            }\n            if (tempVector3.z > shadowMaxZ) {\n              shadowMaxZ = tempVector3.z;\n            }\n          }\n        }\n      }\n      if (this.autoCalcShadowZBounds) {\n        this._shadowMinZ = shadowMinZ;\n        this._shadowMaxZ = shadowMaxZ;\n      }\n    }\n    const xOffset = this._orthoRight - this._orthoLeft;\n    const yOffset = this._orthoTop - this._orthoBottom;\n    const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n    const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);\n  }\n  _buildUniformLayout() {\n    this._uniformBuffer.addUniform(\"vLightData\", 4);\n    this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n    this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n    this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n    this._uniformBuffer.addUniform(\"depthValues\", 2);\n    this._uniformBuffer.create();\n  }\n  /**\n   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The directional light\n   */\n  transferToEffect(effect, lightIndex) {\n    if (this.computeTransformedInformation()) {\n      this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n      return this;\n    }\n    this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n    return this;\n  }\n  transferToNodeMaterialEffect(effect, lightDataUniformName) {\n    if (this.computeTransformedInformation()) {\n      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\n      return this;\n    }\n    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\n    return this;\n  }\n  /**\n   * Gets the minZ used for shadow according to both the scene and the light.\n   *\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n   * (when not using reverse depth buffer / NDC half Z range)\n   * @param activeCamera The camera we are returning the min for\n   * @returns the depth min z\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDepthMinZ(activeCamera) {\n    const engine = this._scene.getEngine();\n    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n  }\n  /**\n   * Gets the maxZ used for shadow according to both the scene and the light.\n   *\n   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n   * (when not using reverse depth buffer / NDC half Z range)\n   * @param activeCamera The camera we are returning the max for\n   * @returns the depth max z\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getDepthMaxZ(activeCamera) {\n    const engine = this._scene.getEngine();\n    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n  }\n  /**\n   * Prepares the list of defines specific to the light type.\n   * @param defines the list of defines\n   * @param lightIndex defines the index of the light for the effect\n   */\n  prepareLightSpecificDefines(defines, lightIndex) {\n    defines[\"DIRLIGHT\" + lightIndex] = true;\n  }\n}\n__decorate([serialize()], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n__decorate([serialize()], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n__decorate([serialize()], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n__decorate([serialize()], DirectionalLight.prototype, \"autoCalcShadowZBounds\", void 0);\n__decorate([serialize(\"orthoLeft\")], DirectionalLight.prototype, \"_orthoLeft\", void 0);\n__decorate([serialize(\"orthoRight\")], DirectionalLight.prototype, \"_orthoRight\", void 0);\n__decorate([serialize(\"orthoTop\")], DirectionalLight.prototype, \"_orthoTop\", void 0);\n__decorate([serialize(\"orthoBottom\")], DirectionalLight.prototype, \"_orthoBottom\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","Matrix","Vector3","Node","Light","ShadowLight","AddNodeConstructor","name","scene","DirectionalLight","Zero","constructor","direction","Number","MAX_VALUE","MIN_VALUE","position","scale","shadowFrustumSize","_shadowFrustumSize","value","forceProjectionMatrixCompute","shadowOrthoScale","_shadowOrthoScale","orthoLeft","_orthoLeft","left","orthoRight","_orthoRight","right","orthoTop","_orthoTop","top","orthoBottom","_orthoBottom","bottom","getClassName","getTypeID","LIGHTTYPEID_DIRECTIONALLIGHT","_setDefaultShadowProjectionMatrix","matrix","viewMatrix","renderList","_setDefaultFixedFrustumShadowProjectionMatrix","_setDefaultAutoExtendShadowProjectionMatrix","activeCamera","getScene","OrthoLHToRef","shadowMinZ","undefined","minZ","shadowMaxZ","maxZ","getEngine","isNDCHalfZRange","autoUpdateExtends","tempVector3","meshIndex","length","mesh","boundingInfo","getBoundingInfo","boundingBox","index","vectorsWorld","TransformCoordinatesToRef","x","y","autoCalcShadowZBounds","z","_shadowMinZ","_shadowMaxZ","xOffset","yOffset","useReverseDepthBuffer","OrthoOffCenterLHToRef","_buildUniformLayout","_uniformBuffer","addUniform","create","transferToEffect","effect","lightIndex","computeTransformedInformation","updateFloat4","transformedDirection","transferToNodeMaterialEffect","lightDataUniformName","setFloat3","getDepthMinZ","engine","_scene","getDepthMaxZ","prepareLightSpecificDefines","defines","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Lights/directionalLight.ts"],"sourcesContent":["import { serialize } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    @serialize(\"orthoLeft\")\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    @serialize(\"orthoRight\")\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    @serialize(\"orthoTop\")\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    @serialize(\"orthoBottom\")\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets the orthoLeft property used to build the light frustum\r\n     */\r\n    public get orthoLeft(): number {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    public set orthoLeft(left: number) {\r\n        this._orthoLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoRight property used to build the light frustum\r\n     */\r\n    public get orthoRight(): number {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    public set orthoRight(right: number) {\r\n        this._orthoRight = right;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoTop property used to build the light frustum\r\n     */\r\n    public get orthoTop(): number {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    public set orthoTop(top: number) {\r\n        this._orthoTop = top;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoBottom property used to build the light frustum\r\n     */\r\n    public get orthoBottom(): number {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    public set orthoBottom(bottom: number) {\r\n        this._orthoBottom = bottom;\r\n    }\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        } else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(\r\n            this.shadowFrustumSize,\r\n            this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ,\r\n            this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            const tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = Number.MIN_VALUE;\r\n            this._orthoTop = Number.MIN_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            let shadowMinZ = Number.MAX_VALUE;\r\n            let shadowMaxZ = Number.MIN_VALUE;\r\n\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                const boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        const xOffset = this._orthoRight - this._orthoLeft;\r\n        const yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(\r\n            this._orthoLeft - xOffset * this.shadowOrthoScale,\r\n            this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale,\r\n            this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}