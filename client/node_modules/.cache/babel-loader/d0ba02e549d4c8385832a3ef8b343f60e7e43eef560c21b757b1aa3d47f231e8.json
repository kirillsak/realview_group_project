{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { FreeCamera } from \"../Cameras/freeCamera.js\";\nimport { TargetCamera } from \"../Cameras/targetCamera.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { WebXRTrackingState } from \"./webXRTypes.js\";\n/**\n * WebXR Camera which holds the views for the xrSession\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\n */\nexport class WebXRCamera extends FreeCamera {\n  /**\n   * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\n   * @param name the name of the camera\n   * @param scene the scene to add the camera to\n   * @param _xrSessionManager a constructed xr session manager\n   */\n  constructor(name, scene, _xrSessionManager) {\n    super(name, Vector3.Zero(), scene);\n    this._xrSessionManager = _xrSessionManager;\n    this._firstFrame = false;\n    this._referenceQuaternion = Quaternion.Identity();\n    this._referencedPosition = new Vector3();\n    this._trackingState = WebXRTrackingState.NOT_TRACKING;\n    /**\n     * Observable raised before camera teleportation\n     */\n    this.onBeforeCameraTeleport = new Observable();\n    /**\n     *  Observable raised after camera teleportation\n     */\n    this.onAfterCameraTeleport = new Observable();\n    /**\n     * Notifies when the camera's tracking state has changed.\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\n     */\n    this.onTrackingStateChanged = new Observable();\n    /**\n     * Should position compensation execute on first frame.\n     * This is used when copying the position from a native (non XR) camera\n     */\n    this.compensateOnFirstFrame = true;\n    // Initial camera configuration\n    this.minZ = 0.1;\n    this.rotationQuaternion = new Quaternion();\n    this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\n    this.updateUpVectorFromRotation = true;\n    this._updateNumberOfRigCameras(1);\n    // freeze projection matrix, which will be copied later\n    this.freezeProjectionMatrix();\n    this._xrSessionManager.onXRSessionInit.add(() => {\n      this._referencedPosition.copyFromFloats(0, 0, 0);\n      this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      // first frame - camera's y position should be 0 for the correct offset\n      this._firstFrame = this.compensateOnFirstFrame;\n    });\n    // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\n    // applied to the rest of the elements using the referenceSpace object\n    this._xrSessionManager.onXRFrameObservable.add(() => {\n      if (this._firstFrame) {\n        this._updateFromXRSession();\n      }\n      this._updateReferenceSpace();\n      this._updateFromXRSession();\n    }, undefined, true);\n  }\n  /**\n   * Get the current XR tracking state of the camera\n   */\n  get trackingState() {\n    return this._trackingState;\n  }\n  _setTrackingState(newState) {\n    if (this._trackingState !== newState) {\n      this._trackingState = newState;\n      this.onTrackingStateChanged.notifyObservers(newState);\n    }\n  }\n  /**\n   * Return the user's height, unrelated to the current ground.\n   * This will be the y position of this camera, when ground level is 0.\n   */\n  get realWorldHeight() {\n    const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\n    if (basePose && basePose.transform) {\n      return basePose.transform.position.y;\n    } else {\n      return 0;\n    }\n  }\n  /** @internal */\n  _updateForDualEyeDebugging( /*pupilDistance = 0.01*/\n  ) {\n    // Create initial camera rigs\n    this._updateNumberOfRigCameras(2);\n    this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\n    // this.rigCameras[0].position.x = -pupilDistance / 2;\n    this.rigCameras[0].outputRenderTarget = null;\n    this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\n    // this.rigCameras[1].position.x = pupilDistance / 2;\n    this.rigCameras[1].outputRenderTarget = null;\n  }\n  /**\n   * Sets this camera's transformation based on a non-vr camera\n   * @param otherCamera the non-vr camera to copy the transformation from\n   * @param resetToBaseReferenceSpace should XR reset to the base reference space\n   */\n  setTransformationFromNonVRCamera(otherCamera = this.getScene().activeCamera, resetToBaseReferenceSpace = true) {\n    if (!otherCamera || otherCamera === this) {\n      return;\n    }\n    const mat = otherCamera.computeWorldMatrix();\n    mat.decompose(undefined, this.rotationQuaternion, this.position);\n    // set the ground level\n    this.position.y = 0;\n    Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\n    this._firstFrame = true;\n    if (resetToBaseReferenceSpace) {\n      this._xrSessionManager.resetReferenceSpace();\n    }\n  }\n  /**\n   * Gets the current instance class name (\"WebXRCamera\").\n   * @returns the class name\n   */\n  getClassName() {\n    return \"WebXRCamera\";\n  }\n  dispose() {\n    super.dispose();\n    this._lastXRViewerPose = undefined;\n  }\n  _updateFromXRSession() {\n    const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\n    this._lastXRViewerPose = pose || undefined;\n    if (!pose) {\n      this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\n      return;\n    }\n    // Set the tracking state. if it didn't change it is a no-op\n    const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\n    this._setTrackingState(trackingState);\n    // check min/max Z and update if not the same as in cache\n    if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\n      const xrRenderState = {\n        // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\n        depthFar: this.maxZ || 10000,\n        depthNear: this.minZ\n      };\n      this._xrSessionManager.updateRenderState(xrRenderState);\n      this._cache.minZ = this.minZ;\n      this._cache.maxZ = this.maxZ;\n    }\n    if (pose.transform) {\n      const orientation = pose.transform.orientation;\n      if (pose.transform.orientation.x === undefined) {\n        // Babylon native polyfill can return an undefined orientation value\n        // When not initialized\n        return;\n      }\n      const pos = pose.transform.position;\n      this._referencedPosition.set(pos.x, pos.y, pos.z);\n      this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n      if (!this._scene.useRightHandedSystem) {\n        this._referencedPosition.z *= -1;\n        this._referenceQuaternion.z *= -1;\n        this._referenceQuaternion.w *= -1;\n      }\n      if (this._firstFrame) {\n        this._firstFrame = false;\n        // we have the XR reference, now use this to find the offset to get the camera to be\n        // in the right position\n        // set the height to correlate to the current height\n        this.position.y += this._referencedPosition.y;\n        // avoid using the head rotation on the first frame.\n        this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\n      } else {\n        // update position and rotation as reference\n        this.rotationQuaternion.copyFrom(this._referenceQuaternion);\n        this.position.copyFrom(this._referencedPosition);\n      }\n    }\n    // Update camera rigs\n    if (this.rigCameras.length !== pose.views.length) {\n      this._updateNumberOfRigCameras(pose.views.length);\n    }\n    pose.views.forEach((view, i) => {\n      var _a;\n      const currentRig = this.rigCameras[i];\n      // update right and left, where applicable\n      if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\n        if (view.eye === \"right\") {\n          currentRig._isRightCamera = true;\n        } else if (view.eye === \"left\") {\n          currentRig._isLeftCamera = true;\n        }\n      }\n      // Update view/projection matrix\n      const pos = view.transform.position;\n      const orientation = view.transform.orientation;\n      currentRig.parent = this.parent;\n      currentRig.position.set(pos.x, pos.y, pos.z);\n      currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\n      if (!this._scene.useRightHandedSystem) {\n        currentRig.position.z *= -1;\n        currentRig.rotationQuaternion.z *= -1;\n        currentRig.rotationQuaternion.w *= -1;\n      }\n      Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\n      if (!this._scene.useRightHandedSystem) {\n        currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\n      }\n      // first camera?\n      if (i === 0) {\n        this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\n      }\n      const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\n      this._renderingMultiview = ((_a = renderTargetTexture === null || renderTargetTexture === void 0 ? void 0 : renderTargetTexture._texture) === null || _a === void 0 ? void 0 : _a.isMultiview) || false;\n      if (this._renderingMultiview) {\n        // For multiview, the render target texture is the same per-view (just the slice index is different),\n        // so we only need to set the output render target once for the rig parent.\n        if (i == 0) {\n          this._xrSessionManager.trySetViewportForView(this.viewport, view);\n          this.outputRenderTarget = renderTargetTexture;\n        }\n      } else {\n        // Update viewport\n        this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\n        // Set cameras to render to the session's render target\n        currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\n      }\n      // Replicate parent rig camera behavior\n      currentRig.layerMask = this.layerMask;\n    });\n  }\n  _updateNumberOfRigCameras(viewCount = 1) {\n    while (this.rigCameras.length < viewCount) {\n      const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\n      newCamera.minZ = 0.1;\n      newCamera.rotationQuaternion = new Quaternion();\n      newCamera.updateUpVectorFromRotation = true;\n      newCamera.isRigCamera = true;\n      newCamera.rigParent = this;\n      // do not compute projection matrix, provided by XR\n      newCamera.freezeProjectionMatrix();\n      this.rigCameras.push(newCamera);\n    }\n    while (this.rigCameras.length > viewCount) {\n      const removedCamera = this.rigCameras.pop();\n      if (removedCamera) {\n        removedCamera.dispose();\n      }\n    }\n  }\n  _updateReferenceSpace() {\n    // were position & rotation updated OUTSIDE of the xr update loop\n    if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\n      const referencedMat = TmpVectors.Matrix[0];\n      const poseMat = TmpVectors.Matrix[1];\n      const transformMat = TmpVectors.Matrix[2];\n      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\n      Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\n      referencedMat.invert().multiplyToRef(poseMat, transformMat);\n      transformMat.invert();\n      if (!this._scene.useRightHandedSystem) {\n        transformMat.toggleModelMatrixHandInPlace();\n      }\n      transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\n      const transform = new XRRigidTransform({\n        x: this._referencedPosition.x,\n        y: this._referencedPosition.y,\n        z: this._referencedPosition.z\n      }, {\n        x: this._referenceQuaternion.x,\n        y: this._referenceQuaternion.y,\n        z: this._referenceQuaternion.z,\n        w: this._referenceQuaternion.w\n      });\n      this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\n    }\n  }\n}\nWebXRCamera._ScaleReadOnly = Vector3.One();","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","Quaternion","TmpVectors","Camera","FreeCamera","TargetCamera","Viewport","Observable","WebXRTrackingState","WebXRCamera","constructor","name","scene","_xrSessionManager","Zero","Identity","NOT_TRACKING","minZ","rotationQuaternion","cameraRigMode","RIG_MODE_CUSTOM","updateUpVectorFromRotation","_updateNumberOfRigCameras","freezeProjectionMatrix","onXRSessionInit","add","_referencedPosition","copyFromFloats","_referenceQuaternion","_firstFrame","compensateOnFirstFrame","onXRFrameObservable","_updateFromXRSession","_updateReferenceSpace","undefined","trackingState","_trackingState","_setTrackingState","newState","onTrackingStateChanged","notifyObservers","realWorldHeight","basePose","currentFrame","getViewerPose","baseReferenceSpace","transform","position","y","_updateForDualEyeDebugging","rigCameras","viewport","outputRenderTarget","setTransformationFromNonVRCamera","otherCamera","getScene","activeCamera","resetToBaseReferenceSpace","mat","computeWorldMatrix","decompose","FromEulerAnglesToRef","toEulerAngles","resetReferenceSpace","getClassName","dispose","_lastXRViewerPose","pose","referenceSpace","emulatedPosition","TRACKING_LOST","TRACKING","_cache","maxZ","xrRenderState","depthFar","depthNear","updateRenderState","orientation","x","pos","set","z","w","_scene","useRightHandedSystem","copyFrom","length","views","forEach","view","i","currentRig","isLeftCamera","isRightCamera","eye","_isRightCamera","_isLeftCamera","parent","FromFloat32ArrayToRefScaled","projectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","renderTargetTexture","getRenderTargetTextureForView","_renderingMultiview","_texture","isMultiview","trySetViewportForView","layerMask","viewCount","newCamera","isRigCamera","rigParent","push","removedCamera","pop","equals","referencedMat","poseMat","transformMat","ComposeToRef","_ScaleReadOnly","invert","multiplyToRef","toggleModelMatrixHandInPlace","XRRigidTransform","getOffsetReferenceSpace","One"],"sourceRoot":"","sources":["../../../../lts/core/generated/XR/webXRCamera.ts"],"sourcesContent":["import { Vector3, Matrix, Quaternion, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { FreeCamera } from \"../Cameras/freeCamera\";\r\nimport { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { WebXRSessionManager } from \"./webXRSessionManager\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { WebXRTrackingState } from \"./webXRTypes\";\r\n\r\n/**\r\n * WebXR Camera which holds the views for the xrSession\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/webXR/webXRCamera\r\n */\r\nexport class WebXRCamera extends FreeCamera {\r\n    private static _ScaleReadOnly = Vector3.One();\r\n\r\n    private _firstFrame = false;\r\n    private _referenceQuaternion: Quaternion = Quaternion.Identity();\r\n    private _referencedPosition: Vector3 = new Vector3();\r\n    private _trackingState: WebXRTrackingState = WebXRTrackingState.NOT_TRACKING;\r\n\r\n    /**\r\n     * Observable raised before camera teleportation\r\n     */\r\n    public onBeforeCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     *  Observable raised after camera teleportation\r\n     */\r\n    public onAfterCameraTeleport = new Observable<Vector3>();\r\n\r\n    /**\r\n     * Notifies when the camera's tracking state has changed.\r\n     * Notice - will also be triggered when tracking has started (at the beginning of the session)\r\n     */\r\n    public onTrackingStateChanged = new Observable<WebXRTrackingState>();\r\n    /**\r\n     * Should position compensation execute on first frame.\r\n     * This is used when copying the position from a native (non XR) camera\r\n     */\r\n    public compensateOnFirstFrame: boolean = true;\r\n\r\n    /**\r\n     * The last XRViewerPose from the current XRFrame\r\n     * @internal\r\n     */\r\n    public _lastXRViewerPose?: XRViewerPose;\r\n\r\n    /**\r\n     * Creates a new webXRCamera, this should only be set at the camera after it has been updated by the xrSessionManager\r\n     * @param name the name of the camera\r\n     * @param scene the scene to add the camera to\r\n     * @param _xrSessionManager a constructed xr session manager\r\n     */\r\n    constructor(name: string, scene: Scene, private _xrSessionManager: WebXRSessionManager) {\r\n        super(name, Vector3.Zero(), scene);\r\n\r\n        // Initial camera configuration\r\n        this.minZ = 0.1;\r\n        this.rotationQuaternion = new Quaternion();\r\n        this.cameraRigMode = Camera.RIG_MODE_CUSTOM;\r\n        this.updateUpVectorFromRotation = true;\r\n        this._updateNumberOfRigCameras(1);\r\n        // freeze projection matrix, which will be copied later\r\n        this.freezeProjectionMatrix();\r\n\r\n        this._xrSessionManager.onXRSessionInit.add(() => {\r\n            this._referencedPosition.copyFromFloats(0, 0, 0);\r\n            this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            // first frame - camera's y position should be 0 for the correct offset\r\n            this._firstFrame = this.compensateOnFirstFrame;\r\n        });\r\n\r\n        // Check transformation changes on each frame. Callback is added to be first so that the transformation will be\r\n        // applied to the rest of the elements using the referenceSpace object\r\n        this._xrSessionManager.onXRFrameObservable.add(\r\n            () => {\r\n                if (this._firstFrame) {\r\n                    this._updateFromXRSession();\r\n                }\r\n                this._updateReferenceSpace();\r\n                this._updateFromXRSession();\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current XR tracking state of the camera\r\n     */\r\n    public get trackingState(): WebXRTrackingState {\r\n        return this._trackingState;\r\n    }\r\n\r\n    private _setTrackingState(newState: WebXRTrackingState) {\r\n        if (this._trackingState !== newState) {\r\n            this._trackingState = newState;\r\n            this.onTrackingStateChanged.notifyObservers(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the user's height, unrelated to the current ground.\r\n     * This will be the y position of this camera, when ground level is 0.\r\n     */\r\n    public get realWorldHeight(): number {\r\n        const basePose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.baseReferenceSpace);\r\n        if (basePose && basePose.transform) {\r\n            return basePose.transform.position.y;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateForDualEyeDebugging(/*pupilDistance = 0.01*/) {\r\n        // Create initial camera rigs\r\n        this._updateNumberOfRigCameras(2);\r\n        this.rigCameras[0].viewport = new Viewport(0, 0, 0.5, 1.0);\r\n        // this.rigCameras[0].position.x = -pupilDistance / 2;\r\n        this.rigCameras[0].outputRenderTarget = null;\r\n        this.rigCameras[1].viewport = new Viewport(0.5, 0, 0.5, 1.0);\r\n        // this.rigCameras[1].position.x = pupilDistance / 2;\r\n        this.rigCameras[1].outputRenderTarget = null;\r\n    }\r\n\r\n    /**\r\n     * Sets this camera's transformation based on a non-vr camera\r\n     * @param otherCamera the non-vr camera to copy the transformation from\r\n     * @param resetToBaseReferenceSpace should XR reset to the base reference space\r\n     */\r\n    public setTransformationFromNonVRCamera(otherCamera: Camera = this.getScene().activeCamera!, resetToBaseReferenceSpace: boolean = true) {\r\n        if (!otherCamera || otherCamera === this) {\r\n            return;\r\n        }\r\n        const mat = otherCamera.computeWorldMatrix();\r\n        mat.decompose(undefined, this.rotationQuaternion, this.position);\r\n        // set the ground level\r\n        this.position.y = 0;\r\n        Quaternion.FromEulerAnglesToRef(0, this.rotationQuaternion.toEulerAngles().y, 0, this.rotationQuaternion);\r\n        this._firstFrame = true;\r\n        if (resetToBaseReferenceSpace) {\r\n            this._xrSessionManager.resetReferenceSpace();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current instance class name (\"WebXRCamera\").\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebXRCamera\";\r\n    }\r\n\r\n    public dispose() {\r\n        super.dispose();\r\n        this._lastXRViewerPose = undefined;\r\n    }\r\n\r\n    private _updateFromXRSession() {\r\n        const pose = this._xrSessionManager.currentFrame && this._xrSessionManager.currentFrame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        this._lastXRViewerPose = pose || undefined;\r\n        if (!pose) {\r\n            this._setTrackingState(WebXRTrackingState.NOT_TRACKING);\r\n            return;\r\n        }\r\n\r\n        // Set the tracking state. if it didn't change it is a no-op\r\n        const trackingState = pose.emulatedPosition ? WebXRTrackingState.TRACKING_LOST : WebXRTrackingState.TRACKING;\r\n        this._setTrackingState(trackingState);\r\n\r\n        // check min/max Z and update if not the same as in cache\r\n        if (this.minZ !== this._cache.minZ || this.maxZ !== this._cache.maxZ) {\r\n            const xrRenderState: XRRenderStateInit = {\r\n                // if maxZ is 0 it should be \"Infinity\", but it doesn't work with the WebXR API. Setting to a large number.\r\n                depthFar: this.maxZ || 10000,\r\n                depthNear: this.minZ,\r\n            };\r\n\r\n            this._xrSessionManager.updateRenderState(xrRenderState);\r\n            this._cache.minZ = this.minZ;\r\n            this._cache.maxZ = this.maxZ;\r\n        }\r\n\r\n        if (pose.transform) {\r\n            const orientation = pose.transform.orientation;\r\n            if (pose.transform.orientation.x === undefined) {\r\n                // Babylon native polyfill can return an undefined orientation value\r\n                // When not initialized\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            this._referencedPosition.set(pos.x, pos.y, pos.z);\r\n\r\n            this._referenceQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                this._referencedPosition.z *= -1;\r\n                this._referenceQuaternion.z *= -1;\r\n                this._referenceQuaternion.w *= -1;\r\n            }\r\n\r\n            if (this._firstFrame) {\r\n                this._firstFrame = false;\r\n                // we have the XR reference, now use this to find the offset to get the camera to be\r\n                // in the right position\r\n\r\n                // set the height to correlate to the current height\r\n                this.position.y += this._referencedPosition.y;\r\n                // avoid using the head rotation on the first frame.\r\n                this._referenceQuaternion.copyFromFloats(0, 0, 0, 1);\r\n            } else {\r\n                // update position and rotation as reference\r\n                this.rotationQuaternion.copyFrom(this._referenceQuaternion);\r\n                this.position.copyFrom(this._referencedPosition);\r\n            }\r\n        }\r\n\r\n        // Update camera rigs\r\n        if (this.rigCameras.length !== pose.views.length) {\r\n            this._updateNumberOfRigCameras(pose.views.length);\r\n        }\r\n\r\n        pose.views.forEach((view: XRView, i: number) => {\r\n            const currentRig = <TargetCamera>this.rigCameras[i];\r\n            // update right and left, where applicable\r\n            if (!currentRig.isLeftCamera && !currentRig.isRightCamera) {\r\n                if (view.eye === \"right\") {\r\n                    currentRig._isRightCamera = true;\r\n                } else if (view.eye === \"left\") {\r\n                    currentRig._isLeftCamera = true;\r\n                }\r\n            }\r\n            // Update view/projection matrix\r\n            const pos = view.transform.position;\r\n            const orientation = view.transform.orientation;\r\n\r\n            currentRig.parent = this.parent;\r\n\r\n            currentRig.position.set(pos.x, pos.y, pos.z);\r\n            currentRig.rotationQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig.position.z *= -1;\r\n                currentRig.rotationQuaternion.z *= -1;\r\n                currentRig.rotationQuaternion.w *= -1;\r\n            }\r\n            Matrix.FromFloat32ArrayToRefScaled(view.projectionMatrix, 0, 1, currentRig._projectionMatrix);\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                currentRig._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n            }\r\n\r\n            // first camera?\r\n            if (i === 0) {\r\n                this._projectionMatrix.copyFrom(currentRig._projectionMatrix);\r\n            }\r\n\r\n            const renderTargetTexture = this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            this._renderingMultiview = renderTargetTexture?._texture?.isMultiview || false;\r\n            if (this._renderingMultiview) {\r\n                // For multiview, the render target texture is the same per-view (just the slice index is different),\r\n                // so we only need to set the output render target once for the rig parent.\r\n                if (i == 0) {\r\n                    this._xrSessionManager.trySetViewportForView(this.viewport, view);\r\n                    this.outputRenderTarget = renderTargetTexture;\r\n                }\r\n            } else {\r\n                // Update viewport\r\n                this._xrSessionManager.trySetViewportForView(currentRig.viewport, view);\r\n\r\n                // Set cameras to render to the session's render target\r\n                currentRig.outputRenderTarget = renderTargetTexture || this._xrSessionManager.getRenderTargetTextureForView(view);\r\n            }\r\n\r\n            // Replicate parent rig camera behavior\r\n            currentRig.layerMask = this.layerMask;\r\n        });\r\n    }\r\n\r\n    private _updateNumberOfRigCameras(viewCount = 1) {\r\n        while (this.rigCameras.length < viewCount) {\r\n            const newCamera = new TargetCamera(\"XR-RigCamera: \" + this.rigCameras.length, Vector3.Zero(), this.getScene());\r\n            newCamera.minZ = 0.1;\r\n            newCamera.rotationQuaternion = new Quaternion();\r\n            newCamera.updateUpVectorFromRotation = true;\r\n            newCamera.isRigCamera = true;\r\n            newCamera.rigParent = this;\r\n            // do not compute projection matrix, provided by XR\r\n            newCamera.freezeProjectionMatrix();\r\n            this.rigCameras.push(newCamera);\r\n        }\r\n        while (this.rigCameras.length > viewCount) {\r\n            const removedCamera = this.rigCameras.pop();\r\n            if (removedCamera) {\r\n                removedCamera.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _updateReferenceSpace() {\r\n        // were position & rotation updated OUTSIDE of the xr update loop\r\n        if (!this.position.equals(this._referencedPosition) || !this.rotationQuaternion.equals(this._referenceQuaternion)) {\r\n            const referencedMat = TmpVectors.Matrix[0];\r\n            const poseMat = TmpVectors.Matrix[1];\r\n            const transformMat = TmpVectors.Matrix[2];\r\n\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this._referenceQuaternion, this._referencedPosition, referencedMat);\r\n            Matrix.ComposeToRef(WebXRCamera._ScaleReadOnly, this.rotationQuaternion, this.position, poseMat);\r\n            referencedMat.invert().multiplyToRef(poseMat, transformMat);\r\n            transformMat.invert();\r\n\r\n            if (!this._scene.useRightHandedSystem) {\r\n                transformMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            transformMat.decompose(undefined, this._referenceQuaternion, this._referencedPosition);\r\n            const transform = new XRRigidTransform(\r\n                {\r\n                    x: this._referencedPosition.x,\r\n                    y: this._referencedPosition.y,\r\n                    z: this._referencedPosition.z,\r\n                },\r\n                {\r\n                    x: this._referenceQuaternion.x,\r\n                    y: this._referenceQuaternion.y,\r\n                    z: this._referenceQuaternion.z,\r\n                    w: this._referenceQuaternion.w,\r\n                }\r\n            );\r\n            this._xrSessionManager.referenceSpace = this._xrSessionManager.referenceSpace.getOffsetReferenceSpace(transform);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}