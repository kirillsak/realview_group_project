{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { GetEnvInfo, UploadEnvLevelsAsync, UploadEnvSpherical } from \"../../../Misc/environmentTextureTools.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\n/**\n * Implementation of the ENV Texture Loader.\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _ENVTextureLoader {\n  constructor() {\n    /**\n     * Defines whether the loader supports cascade loading the different faces.\n     */\n    this.supportCascades = false;\n  }\n  /**\n   * This returns if the loader support the current file information.\n   * @param extension defines the file extension of the file being loaded\n   * @returns true if the loader can load the specified file\n   */\n  canLoad(extension) {\n    return extension.endsWith(\".env\");\n  }\n  /**\n   * Uploads the cube texture data to the WebGL texture. It has already been bound.\n   * @param data contains the texture data\n   * @param texture defines the BabylonJS internal texture\n   * @param createPolynomials will be true if polynomials have been requested\n   * @param onLoad defines the callback to trigger once the texture is ready\n   * @param onError defines the callback to trigger in case of error\n   */\n  loadCubeData(data, texture, createPolynomials, onLoad, onError) {\n    if (Array.isArray(data)) {\n      return;\n    }\n    const info = GetEnvInfo(data);\n    if (info) {\n      texture.width = info.width;\n      texture.height = info.width;\n      try {\n        UploadEnvSpherical(texture, info);\n        UploadEnvLevelsAsync(texture, data, info).then(() => {\n          texture.isReady = true;\n          texture.onLoadedObservable.notifyObservers(texture);\n          texture.onLoadedObservable.clear();\n          if (onLoad) {\n            onLoad();\n          }\n        }, reason => {\n          onError === null || onError === void 0 ? void 0 : onError(\"Can not upload environment levels\", reason);\n        });\n      } catch (e) {\n        onError === null || onError === void 0 ? void 0 : onError(\"Can not upload environment file\", e);\n      }\n    } else if (onError) {\n      onError(\"Can not parse the environment file\", null);\n    }\n  }\n  /**\n   * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\n   */\n  loadData() {\n    throw \".env not supported in 2d.\";\n  }\n}\n// Register the loader.\nEngine._TextureLoaders.push(new _ENVTextureLoader());","map":{"version":3,"mappings":";AAAA,SAASA,UAAU,EAAEC,oBAAoB,EAAEC,kBAAkB,QAAQ,0CAAwC;AAE7G,SAASC,MAAM,QAAQ,4BAA0B;AAIjD;;;;AAIA;AACA,OAAM,MAAOC,iBAAiB;EAA9BC;IACI;;;IAGgB,oBAAe,GAAG,KAAK;EAgE3C;EA9DI;;;;;EAKOC,OAAO,CAACC,SAAiB;IAC5B,OAAOA,SAAS,CAACC,QAAQ,CAAC,MAAM,CAAC;EACrC;EAEA;;;;;;;;EAQOC,YAAY,CACfC,IAAyC,EACzCC,OAAwB,EACxBC,iBAA0B,EAC1BC,MAAsC,EACtCC,OAA8D;IAE9D,IAAIC,KAAK,CAACC,OAAO,CAACN,IAAI,CAAC,EAAE;MACrB;;IAGJ,MAAMO,IAAI,GAAGjB,UAAU,CAACU,IAAI,CAAC;IAC7B,IAAIO,IAAI,EAAE;MACNN,OAAO,CAACO,KAAK,GAAGD,IAAI,CAACC,KAAK;MAC1BP,OAAO,CAACQ,MAAM,GAAGF,IAAI,CAACC,KAAK;MAE3B,IAAI;QACAhB,kBAAkB,CAACS,OAAO,EAAEM,IAAI,CAAC;QACjChB,oBAAoB,CAACU,OAAO,EAAED,IAAI,EAAEO,IAAI,CAAC,CAACG,IAAI,CAC1C,MAAK;UACDT,OAAO,CAACU,OAAO,GAAG,IAAI;UACtBV,OAAO,CAACW,kBAAkB,CAACC,eAAe,CAACZ,OAAO,CAAC;UACnDA,OAAO,CAACW,kBAAkB,CAACE,KAAK,EAAE;UAClC,IAAIX,MAAM,EAAE;YACRA,MAAM,EAAE;;QAEhB,CAAC,EACAY,MAAM,IAAI;UACPX,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAG,mCAAmC,EAAEW,MAAM,CAAC;QAC1D,CAAC,CACJ;OACJ,CAAC,OAAOC,CAAC,EAAE;QACRZ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAG,iCAAiC,EAAEY,CAAC,CAAC;;KAEtD,MAAM,IAAIZ,OAAO,EAAE;MAChBA,OAAO,CAAC,oCAAoC,EAAE,IAAI,CAAC;;EAE3D;EAEA;;;EAGOa,QAAQ;IACX,MAAM,2BAA2B;EACrC;;AAGJ;AACAxB,MAAM,CAACyB,eAAe,CAACC,IAAI,CAAC,IAAIzB,iBAAiB,EAAE,CAAC","names":["GetEnvInfo","UploadEnvLevelsAsync","UploadEnvSpherical","Engine","_ENVTextureLoader","constructor","canLoad","extension","endsWith","loadCubeData","data","texture","createPolynomials","onLoad","onError","Array","isArray","info","width","height","then","isReady","onLoadedObservable","notifyObservers","clear","reason","e","loadData","_TextureLoaders","push"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/Loaders/envTextureLoader.ts"],"sourcesContent":["import { GetEnvInfo, UploadEnvLevelsAsync, UploadEnvSpherical } from \"../../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Engine } from \"../../../Engines/engine\";\r\nimport type { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../../../Materials/Textures/internalTextureLoader\";\r\n\r\n/**\r\n * Implementation of the ENV Texture Loader.\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _ENVTextureLoader implements IInternalTextureLoader {\r\n    /**\r\n     * Defines whether the loader supports cascade loading the different faces.\r\n     */\r\n    public readonly supportCascades = false;\r\n\r\n    /**\r\n     * This returns if the loader support the current file information.\r\n     * @param extension defines the file extension of the file being loaded\r\n     * @returns true if the loader can load the specified file\r\n     */\r\n    public canLoad(extension: string): boolean {\r\n        return extension.endsWith(\".env\");\r\n    }\r\n\r\n    /**\r\n     * Uploads the cube texture data to the WebGL texture. It has already been bound.\r\n     * @param data contains the texture data\r\n     * @param texture defines the BabylonJS internal texture\r\n     * @param createPolynomials will be true if polynomials have been requested\r\n     * @param onLoad defines the callback to trigger once the texture is ready\r\n     * @param onError defines the callback to trigger in case of error\r\n     */\r\n    public loadCubeData(\r\n        data: ArrayBufferView | ArrayBufferView[],\r\n        texture: InternalTexture,\r\n        createPolynomials: boolean,\r\n        onLoad: Nullable<(data?: any) => void>,\r\n        onError: Nullable<(message?: string, exception?: any) => void>\r\n    ): void {\r\n        if (Array.isArray(data)) {\r\n            return;\r\n        }\r\n\r\n        const info = GetEnvInfo(data);\r\n        if (info) {\r\n            texture.width = info.width;\r\n            texture.height = info.width;\r\n\r\n            try {\r\n                UploadEnvSpherical(texture, info);\r\n                UploadEnvLevelsAsync(texture, data, info).then(\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        texture.onLoadedObservable.notifyObservers(texture);\r\n                        texture.onLoadedObservable.clear();\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    (reason) => {\r\n                        onError?.(\"Can not upload environment levels\", reason);\r\n                    }\r\n                );\r\n            } catch (e) {\r\n                onError?.(\"Can not upload environment file\", e);\r\n            }\r\n        } else if (onError) {\r\n            onError(\"Can not parse the environment file\", null);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Uploads the 2D texture data to the WebGL texture. It has already been bound once in the callback.\r\n     */\r\n    public loadData(): void {\r\n        throw \".env not supported in 2d.\";\r\n    }\r\n}\r\n\r\n// Register the loader.\r\nEngine._TextureLoaders.push(new _ENVTextureLoader());\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}