{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { AnimationKeyInterpolation } from \"./animationKey.js\";\nimport { AnimationRange } from \"./animationRange.js\";\nimport { Node } from \"../node.js\";\nimport { Size } from \"../Maths/math.size.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _IAnimationState {}\n/**\n * Class used to store any kind of animation\n */\nexport class Animation {\n  /**\n   * Initializes the animation\n   * @param name Name of the animation\n   * @param targetProperty Property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param dataType The data type of the animation\n   * @param loopMode The loop mode of the animation\n   * @param enableBlending Specifies if blending should be enabled\n   */\n  constructor( /**Name of the animation */\n  name, /**Property to animate */\n  targetProperty, /**The frames per second of the animation */\n  framePerSecond, /**The data type of the animation */\n  dataType, /**The loop mode of the animation */\n  loopMode, /**Specifies if blending should be enabled */\n  enableBlending) {\n    this.name = name;\n    this.targetProperty = targetProperty;\n    this.framePerSecond = framePerSecond;\n    this.dataType = dataType;\n    this.loopMode = loopMode;\n    this.enableBlending = enableBlending;\n    /**\n     * Stores the easing function of the animation\n     */\n    this._easingFunction = null;\n    /**\n     * @internal Internal use only\n     */\n    this._runtimeAnimations = new Array();\n    /**\n     * The set of event that will be linked to this animation\n     */\n    this._events = new Array();\n    /**\n     * Stores the blending speed of the animation\n     */\n    this.blendingSpeed = 0.01;\n    /**\n     * Stores the animation ranges for the animation\n     */\n    this._ranges = {};\n    this.targetPropertyPath = targetProperty.split(\".\");\n    this.dataType = dataType;\n    this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n    this.uniqueId = Animation._UniqueIdGenerator++;\n  }\n  /**\n   * @internal Internal use\n   */\n  static _PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n    let dataType = undefined;\n    if (!isNaN(parseFloat(from)) && isFinite(from)) {\n      dataType = Animation.ANIMATIONTYPE_FLOAT;\n    } else if (from instanceof Quaternion) {\n      dataType = Animation.ANIMATIONTYPE_QUATERNION;\n    } else if (from instanceof Vector3) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR3;\n    } else if (from instanceof Vector2) {\n      dataType = Animation.ANIMATIONTYPE_VECTOR2;\n    } else if (from instanceof Color3) {\n      dataType = Animation.ANIMATIONTYPE_COLOR3;\n    } else if (from instanceof Color4) {\n      dataType = Animation.ANIMATIONTYPE_COLOR4;\n    } else if (from instanceof Size) {\n      dataType = Animation.ANIMATIONTYPE_SIZE;\n    }\n    if (dataType == undefined) {\n      return null;\n    }\n    const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n    const keys = [{\n      frame: 0,\n      value: from\n    }, {\n      frame: totalFrame,\n      value: to\n    }];\n    animation.setKeys(keys);\n    if (easingFunction !== undefined) {\n      animation.setEasingFunction(easingFunction);\n    }\n    return animation;\n  }\n  /**\n   * Sets up an animation\n   * @param property The property to animate\n   * @param animationType The animation type to apply\n   * @param framePerSecond The frames per second of the animation\n   * @param easingFunction The easing function used in the animation\n   * @returns The created animation\n   */\n  static CreateAnimation(property, animationType, framePerSecond, easingFunction) {\n    const animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\n    animation.setEasingFunction(easingFunction);\n    return animation;\n  }\n  /**\n   * Create and start an animation on a node\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param target defines the target where the animation will take place\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second yo use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when animation end\n   * @param scene defines the hosting scene\n   * @returns the animatable created for this animation\n   */\n  static CreateAndStartAnimation(name, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    if (target.getScene) {\n      scene = target.getScene();\n    }\n    if (!scene) {\n      return null;\n    }\n    return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Create and start an animation on a node and its descendants\n   * @param name defines the name of the global animation that will be run on all nodes\n   * @param node defines the root node where the animation will take place\n   * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\n   * @param targetProperty defines property to animate\n   * @param framePerSecond defines the number of frame per second to use\n   * @param totalFrame defines the number of frames in total\n   * @param from defines the initial value\n   * @param to defines the final value\n   * @param loopMode defines which loop mode you want to use (off by default)\n   * @param easingFunction defines the easing function to use (linear by default)\n   * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\n   * @returns the list of animatables created for all nodes\n   * @example https://www.babylonjs-playground.com/#MH0VLI\n   */\n  static CreateAndStartHierarchyAnimation(name, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    const scene = node.getScene();\n    return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Creates a new animation, merges it with the existing animations and starts it\n   * @param name Name of the animation\n   * @param node Node which contains the scene that begins the animations\n   * @param targetProperty Specifies which property to animate\n   * @param framePerSecond The frames per second of the animation\n   * @param totalFrame The total number of frames\n   * @param from The frame at the beginning of the animation\n   * @param to The frame at the end of the animation\n   * @param loopMode Specifies the loop mode of the animation\n   * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\n   * @param onAnimationEnd Callback to run once the animation is complete\n   * @returns Nullable animation\n   */\n  static CreateMergeAndStartAnimation(name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n    const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n    if (!animation) {\n      return null;\n    }\n    node.animations.push(animation);\n    return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\n  }\n  /**\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\n   * @param sourceAnimation defines the Animation containing keyframes to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the Animation to convert\n   * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\n   * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\n   * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\n   */\n  static MakeAnimationAdditive(sourceAnimation, referenceFrame = 0, range, cloneOriginal = false, clonedName) {\n    let animation = sourceAnimation;\n    if (cloneOriginal) {\n      animation = sourceAnimation.clone();\n      animation.name = clonedName || animation.name;\n    }\n    if (!animation._keys.length) {\n      return animation;\n    }\n    referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\n    let startIndex = 0;\n    const firstKey = animation._keys[0];\n    let endIndex = animation._keys.length - 1;\n    const lastKey = animation._keys[endIndex];\n    const valueStore = {\n      referenceValue: firstKey.value,\n      referencePosition: TmpVectors.Vector3[0],\n      referenceQuaternion: TmpVectors.Quaternion[0],\n      referenceScaling: TmpVectors.Vector3[1],\n      keyPosition: TmpVectors.Vector3[2],\n      keyQuaternion: TmpVectors.Quaternion[1],\n      keyScaling: TmpVectors.Vector3[3]\n    };\n    let referenceFound = false;\n    let from = firstKey.frame;\n    let to = lastKey.frame;\n    if (range) {\n      const rangeValue = animation.getRange(range);\n      if (rangeValue) {\n        from = rangeValue.from;\n        to = rangeValue.to;\n      }\n    }\n    let fromKeyFound = firstKey.frame === from;\n    let toKeyFound = lastKey.frame === to;\n    // There's only one key, so use it\n    if (animation._keys.length === 1) {\n      const value = animation._getKeyValue(animation._keys[0]);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    }\n    // Reference frame is before the first frame, so just use the first frame\n    else if (referenceFrame <= firstKey.frame) {\n      const value = animation._getKeyValue(firstKey.value);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    }\n    // Reference frame is after the last frame, so just use the last frame\n    else if (referenceFrame >= lastKey.frame) {\n      const value = animation._getKeyValue(lastKey.value);\n      valueStore.referenceValue = value.clone ? value.clone() : value;\n      referenceFound = true;\n    }\n    // Find key bookends, create them if they don't exist\n    let index = 0;\n    while (!referenceFound || !fromKeyFound || !toKeyFound && index < animation._keys.length - 1) {\n      const currentKey = animation._keys[index];\n      const nextKey = animation._keys[index + 1];\n      // If reference frame wasn't found yet, check if we can interpolate to it\n      if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\n        let value;\n        if (referenceFrame === currentKey.frame) {\n          value = animation._getKeyValue(currentKey.value);\n        } else if (referenceFrame === nextKey.frame) {\n          value = animation._getKeyValue(nextKey.value);\n        } else {\n          const animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n          value = animation._interpolate(referenceFrame, animationState);\n        }\n        valueStore.referenceValue = value.clone ? value.clone() : value;\n        referenceFound = true;\n      }\n      // If from key wasn't found yet, check if we can interpolate to it\n      if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\n        if (from === currentKey.frame) {\n          startIndex = index;\n        } else if (from === nextKey.frame) {\n          startIndex = index + 1;\n        } else {\n          const animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n          const value = animation._interpolate(from, animationState);\n          const key = {\n            frame: from,\n            value: value.clone ? value.clone() : value\n          };\n          animation._keys.splice(index + 1, 0, key);\n          startIndex = index + 1;\n        }\n        fromKeyFound = true;\n      }\n      // If to key wasn't found yet, check if we can interpolate to it\n      if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\n        if (to === currentKey.frame) {\n          endIndex = index;\n        } else if (to === nextKey.frame) {\n          endIndex = index + 1;\n        } else {\n          const animationState = {\n            key: index,\n            repeatCount: 0,\n            loopMode: this.ANIMATIONLOOPMODE_CONSTANT\n          };\n          const value = animation._interpolate(to, animationState);\n          const key = {\n            frame: to,\n            value: value.clone ? value.clone() : value\n          };\n          animation._keys.splice(index + 1, 0, key);\n          endIndex = index + 1;\n        }\n        toKeyFound = true;\n      }\n      index++;\n    }\n    // Conjugate the quaternion\n    if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\n      valueStore.referenceValue.normalize().conjugateInPlace();\n    }\n    // Decompose matrix and conjugate the quaternion\n    else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n      valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\n      valueStore.referenceQuaternion.normalize().conjugateInPlace();\n    }\n    // Subtract the reference value from all of the key values\n    for (index = startIndex; index <= endIndex; index++) {\n      const key = animation._keys[index];\n      // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\n      if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\n        continue;\n      }\n      switch (animation.dataType) {\n        case Animation.ANIMATIONTYPE_MATRIX:\n          key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\n          valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\n          valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\n          valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\n          Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          valueStore.referenceValue.multiplyToRef(key.value, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_VECTOR2:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.value.subtractToRef(valueStore.referenceValue, key.value);\n          break;\n        case Animation.ANIMATIONTYPE_SIZE:\n          key.value.width -= valueStore.referenceValue.width;\n          key.value.height -= valueStore.referenceValue.height;\n          break;\n        default:\n          key.value -= valueStore.referenceValue;\n      }\n    }\n    return animation;\n  }\n  /**\n   * Transition property of an host to the target Value\n   * @param property The property to transition\n   * @param targetValue The target Value of the property\n   * @param host The object where the property to animate belongs\n   * @param scene Scene used to run the animation\n   * @param frameRate Framerate (in frame/s) to use\n   * @param transition The transition type we want to use\n   * @param duration The duration of the animation, in milliseconds\n   * @param onAnimationEnd Callback trigger at the end of the animation\n   * @returns Nullable animation\n   */\n  static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {\n    if (duration <= 0) {\n      host[property] = targetValue;\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n      return null;\n    }\n    const endFrame = frameRate * (duration / 1000);\n    transition.setKeys([{\n      frame: 0,\n      value: host[property].clone ? host[property].clone() : host[property]\n    }, {\n      frame: endFrame,\n      value: targetValue\n    }]);\n    if (!host.animations) {\n      host.animations = [];\n    }\n    host.animations.push(transition);\n    const animation = scene.beginAnimation(host, 0, endFrame, false);\n    animation.onAnimationEnd = onAnimationEnd;\n    return animation;\n  }\n  /**\n   * Return the array of runtime animations currently using this animation\n   */\n  get runtimeAnimations() {\n    return this._runtimeAnimations;\n  }\n  /**\n   * Specifies if any of the runtime animations are currently running\n   */\n  get hasRunningRuntimeAnimations() {\n    for (const runtimeAnimation of this._runtimeAnimations) {\n      if (!runtimeAnimation.isStopped()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  // Methods\n  /**\n   * Converts the animation to a string\n   * @param fullDetails support for multiple levels of logging within scene loading\n   * @returns String form of the animation\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n    ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\n    ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n    ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      let first = true;\n      for (const name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n        ret += name;\n      }\n      ret += \"}\";\n    }\n    return ret;\n  }\n  /**\n   * Add an event to this animation\n   * @param event Event to add\n   */\n  addEvent(event) {\n    this._events.push(event);\n    this._events.sort((a, b) => a.frame - b.frame);\n  }\n  /**\n   * Remove all events found at the given frame\n   * @param frame The frame to remove events from\n   */\n  removeEvents(frame) {\n    for (let index = 0; index < this._events.length; index++) {\n      if (this._events[index].frame === frame) {\n        this._events.splice(index, 1);\n        index--;\n      }\n    }\n  }\n  /**\n   * Retrieves all the events from the animation\n   * @returns Events from the animation\n   */\n  getEvents() {\n    return this._events;\n  }\n  /**\n   * Creates an animation range\n   * @param name Name of the animation range\n   * @param from Starting frame of the animation range\n   * @param to Ending frame of the animation\n   */\n  createRange(name, from, to) {\n    // check name not already in use; could happen for bones after serialized\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n    }\n  }\n  /**\n   * Deletes an animation range by name\n   * @param name Name of the animation range to delete\n   * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\n   */\n  deleteRange(name, deleteFrames = true) {\n    const range = this._ranges[name];\n    if (!range) {\n      return;\n    }\n    if (deleteFrames) {\n      const from = range.from;\n      const to = range.to;\n      // this loop MUST go high to low for multiple splices to work\n      for (let key = this._keys.length - 1; key >= 0; key--) {\n        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n          this._keys.splice(key, 1);\n        }\n      }\n    }\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  }\n  /**\n   * Gets the animation range by name, or null if not defined\n   * @param name Name of the animation range\n   * @returns Nullable animation range\n   */\n  getRange(name) {\n    return this._ranges[name];\n  }\n  /**\n   * Gets the key frames from the animation\n   * @returns The key frames of the animation\n   */\n  getKeys() {\n    return this._keys;\n  }\n  /**\n   * Gets the highest frame rate of the animation\n   * @returns Highest frame rate of the animation\n   */\n  getHighestFrame() {\n    let ret = 0;\n    for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n      if (ret < this._keys[key].frame) {\n        ret = this._keys[key].frame;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Gets the easing function of the animation\n   * @returns Easing function of the animation\n   */\n  getEasingFunction() {\n    return this._easingFunction;\n  }\n  /**\n   * Sets the easing function of the animation\n   * @param easingFunction A custom mathematical formula for animation\n   */\n  setEasingFunction(easingFunction) {\n    this._easingFunction = easingFunction;\n  }\n  /**\n   * Interpolates a scalar linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n  floatInterpolateFunction(startValue, endValue, gradient) {\n    return Scalar.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a scalar cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated scalar value\n   */\n  floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a quaternion using a spherical linear interpolation\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n  quaternionInterpolateFunction(startValue, endValue, gradient) {\n    return Quaternion.Slerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a quaternion cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation curve\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated quaternion value\n   */\n  quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n  }\n  /**\n   * Interpolates a Vector3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated scalar value\n   */\n  vector3InterpolateFunction(startValue, endValue, gradient) {\n    return Vector3.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Vector3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns InterpolatedVector3 value\n   */\n  vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a Vector2 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n  vector2InterpolateFunction(startValue, endValue, gradient) {\n    return Vector2.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Vector2 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate (value between 0 and 1)\n   * @returns Interpolated Vector2 value\n   */\n  vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a size linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Size value\n   */\n  sizeInterpolateFunction(startValue, endValue, gradient) {\n    return Size.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color3 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n  color3InterpolateFunction(startValue, endValue, gradient) {\n    return Color3.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color3 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n  color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * Interpolates a Color4 linearly\n   * @param startValue Start value of the animation curve\n   * @param endValue End value of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns Interpolated Color3 value\n   */\n  color4InterpolateFunction(startValue, endValue, gradient) {\n    return Color4.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Interpolates a Color4 cubically\n   * @param startValue Start value of the animation curve\n   * @param outTangent End tangent of the animation\n   * @param endValue End value of the animation curve\n   * @param inTangent Start tangent of the animation curve\n   * @param gradient Scalar amount to interpolate\n   * @returns interpolated value\n   */\n  color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {\n    return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n  }\n  /**\n   * @internal Internal use only\n   */\n  _getKeyValue(value) {\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  }\n  /**\n   * Evaluate the animation value at a given frame\n   * @param currentFrame defines the frame where we want to evaluate the animation\n   * @returns the animation value\n   */\n  evaluate(currentFrame) {\n    return this._interpolate(currentFrame, {\n      key: 0,\n      repeatCount: 0,\n      loopMode: Animation.ANIMATIONLOOPMODE_CONSTANT\n    });\n  }\n  /**\n   * @internal Internal use only\n   */\n  _interpolate(currentFrame, state) {\n    if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\n      return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\n    }\n    const keys = this._keys;\n    const keysLength = keys.length;\n    let key = state.key;\n    while (key >= 0 && currentFrame < keys[key].frame) {\n      --key;\n    }\n    while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\n      ++key;\n    }\n    state.key = key;\n    if (key < 0) {\n      return this._getKeyValue(keys[0].value);\n    } else if (key + 1 > keysLength - 1) {\n      return this._getKeyValue(keys[keysLength - 1].value);\n    }\n    const startKey = keys[key];\n    const endKey = keys[key + 1];\n    const startValue = this._getKeyValue(startKey.value);\n    const endValue = this._getKeyValue(endKey.value);\n    if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\n      if (endKey.frame > currentFrame) {\n        return startValue;\n      } else {\n        return endValue;\n      }\n    }\n    const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n    const frameDelta = endKey.frame - startKey.frame;\n    // gradient : percent of currentFrame between the frame inf and the frame sup\n    let gradient = (currentFrame - startKey.frame) / frameDelta;\n    // check for easingFunction and correction of gradient\n    const easingFunction = this.getEasingFunction();\n    if (easingFunction !== null) {\n      gradient = easingFunction.ease(gradient);\n    }\n    switch (this.dataType) {\n      // Float\n      case Animation.ANIMATIONTYPE_FLOAT:\n        {\n          const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return floatValue;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return state.offsetValue * state.repeatCount + floatValue;\n          }\n          break;\n        }\n      // Quaternion\n      case Animation.ANIMATIONTYPE_QUATERNION:\n        {\n          const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return quatValue;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\n          }\n          return quatValue;\n        }\n      // Vector3\n      case Animation.ANIMATIONTYPE_VECTOR3:\n        {\n          const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return vec3Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return vec3Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Vector2\n      case Animation.ANIMATIONTYPE_VECTOR2:\n        {\n          const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return vec2Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return vec2Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Size\n      case Animation.ANIMATIONTYPE_SIZE:\n        {\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return this.sizeInterpolateFunction(startValue, endValue, gradient);\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Color3\n      case Animation.ANIMATIONTYPE_COLOR3:\n        {\n          const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return color3Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return color3Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Color4\n      case Animation.ANIMATIONTYPE_COLOR4:\n        {\n          const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              return color4Value;\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              return color4Value.add(state.offsetValue.scale(state.repeatCount));\n          }\n          break;\n        }\n      // Matrix\n      case Animation.ANIMATIONTYPE_MATRIX:\n        {\n          switch (state.loopMode) {\n            case Animation.ANIMATIONLOOPMODE_CYCLE:\n            case Animation.ANIMATIONLOOPMODE_CONSTANT:\n              {\n                if (Animation.AllowMatricesInterpolation) {\n                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\n                }\n                return startValue;\n              }\n            case Animation.ANIMATIONLOOPMODE_RELATIVE:\n              {\n                return startValue;\n              }\n          }\n          break;\n        }\n    }\n    return 0;\n  }\n  /**\n   * Defines the function to use to interpolate matrices\n   * @param startValue defines the start matrix\n   * @param endValue defines the end matrix\n   * @param gradient defines the gradient between both matrices\n   * @param result defines an optional target matrix where to store the interpolation\n   * @returns the interpolated matrix\n   */\n  matrixInterpolateFunction(startValue, endValue, gradient, result) {\n    if (Animation.AllowMatrixDecomposeForInterpolation) {\n      if (result) {\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n      }\n      return Matrix.DecomposeLerp(startValue, endValue, gradient);\n    }\n    if (result) {\n      Matrix.LerpToRef(startValue, endValue, gradient, result);\n      return result;\n    }\n    return Matrix.Lerp(startValue, endValue, gradient);\n  }\n  /**\n   * Makes a copy of the animation\n   * @returns Cloned animation\n   */\n  clone() {\n    const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n    clone.enableBlending = this.enableBlending;\n    clone.blendingSpeed = this.blendingSpeed;\n    if (this._keys) {\n      clone.setKeys(this._keys);\n    }\n    if (this._ranges) {\n      clone._ranges = {};\n      for (const name in this._ranges) {\n        const range = this._ranges[name];\n        if (!range) {\n          continue;\n        }\n        clone._ranges[name] = range.clone();\n      }\n    }\n    return clone;\n  }\n  /**\n   * Sets the key frames of the animation\n   * @param values The animation key frames to set\n   */\n  setKeys(values) {\n    this._keys = values.slice(0);\n  }\n  /**\n   * Serializes the animation to an object\n   * @returns Serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.property = this.targetProperty;\n    serializationObject.framePerSecond = this.framePerSecond;\n    serializationObject.dataType = this.dataType;\n    serializationObject.loopBehavior = this.loopMode;\n    serializationObject.enableBlending = this.enableBlending;\n    serializationObject.blendingSpeed = this.blendingSpeed;\n    const dataType = this.dataType;\n    serializationObject.keys = [];\n    const keys = this.getKeys();\n    for (let index = 0; index < keys.length; index++) {\n      const animationKey = keys[index];\n      const key = {};\n      key.frame = animationKey.frame;\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          key.values = [animationKey.value];\n          if (animationKey.inTangent !== undefined) {\n            key.values.push(animationKey.inTangent);\n          }\n          if (animationKey.outTangent !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.outTangent);\n          }\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.interpolation);\n          }\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n        case Animation.ANIMATIONTYPE_MATRIX:\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        case Animation.ANIMATIONTYPE_COLOR3:\n        case Animation.ANIMATIONTYPE_COLOR4:\n          key.values = animationKey.value.asArray();\n          if (animationKey.inTangent != undefined) {\n            key.values.push(animationKey.inTangent.asArray());\n          }\n          if (animationKey.outTangent != undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.outTangent.asArray());\n          }\n          if (animationKey.interpolation !== undefined) {\n            if (animationKey.inTangent === undefined) {\n              key.values.push(undefined);\n            }\n            if (animationKey.outTangent === undefined) {\n              key.values.push(undefined);\n            }\n            key.values.push(animationKey.interpolation);\n          }\n          break;\n      }\n      serializationObject.keys.push(key);\n    }\n    serializationObject.ranges = [];\n    for (const name in this._ranges) {\n      const source = this._ranges[name];\n      if (!source) {\n        continue;\n      }\n      const range = {};\n      range.name = name;\n      range.from = source.from;\n      range.to = source.to;\n      serializationObject.ranges.push(range);\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  static _UniversalLerp(left, right, amount) {\n    const constructor = left.constructor;\n    if (constructor.Lerp) {\n      // Lerp supported\n      return constructor.Lerp(left, right, amount);\n    } else if (constructor.Slerp) {\n      // Slerp supported\n      return constructor.Slerp(left, right, amount);\n    } else if (left.toFixed) {\n      // Number\n      return left * (1.0 - amount) + amount * right;\n    } else {\n      // Blending not supported\n      return right;\n    }\n  }\n  /**\n   * Parses an animation object and creates an animation\n   * @param parsedAnimation Parsed animation object\n   * @returns Animation object\n   */\n  static Parse(parsedAnimation) {\n    const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n    const dataType = parsedAnimation.dataType;\n    const keys = [];\n    let data;\n    let index;\n    if (parsedAnimation.enableBlending) {\n      animation.enableBlending = parsedAnimation.enableBlending;\n    }\n    if (parsedAnimation.blendingSpeed) {\n      animation.blendingSpeed = parsedAnimation.blendingSpeed;\n    }\n    for (index = 0; index < parsedAnimation.keys.length; index++) {\n      const key = parsedAnimation.keys[index];\n      let inTangent = undefined;\n      let outTangent = undefined;\n      let interpolation = undefined;\n      switch (dataType) {\n        case Animation.ANIMATIONTYPE_FLOAT:\n          data = key.values[0];\n          if (key.values.length >= 2) {\n            inTangent = key.values[1];\n          }\n          if (key.values.length >= 3) {\n            outTangent = key.values[2];\n          }\n          if (key.values.length >= 4) {\n            interpolation = key.values[3];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_QUATERNION:\n          data = Quaternion.FromArray(key.values);\n          if (key.values.length >= 8) {\n            const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\n            if (!_inTangent.equals(Quaternion.Zero())) {\n              inTangent = _inTangent;\n            }\n          }\n          if (key.values.length >= 12) {\n            const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\n            if (!_outTangent.equals(Quaternion.Zero())) {\n              outTangent = _outTangent;\n            }\n          }\n          if (key.values.length >= 13) {\n            interpolation = key.values[12];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_MATRIX:\n          data = Matrix.FromArray(key.values);\n          if (key.values.length >= 17) {\n            interpolation = key.values[16];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_COLOR3:\n          data = Color3.FromArray(key.values);\n          if (key.values[3]) {\n            inTangent = Color3.FromArray(key.values[3]);\n          }\n          if (key.values[4]) {\n            outTangent = Color3.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n          break;\n        case Animation.ANIMATIONTYPE_COLOR4:\n          data = Color4.FromArray(key.values);\n          if (key.values[4]) {\n            inTangent = Color4.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            outTangent = Color4.FromArray(key.values[5]);\n          }\n          if (key.values[6]) {\n            interpolation = Color4.FromArray(key.values[6]);\n          }\n          break;\n        case Animation.ANIMATIONTYPE_VECTOR3:\n        default:\n          data = Vector3.FromArray(key.values);\n          if (key.values[3]) {\n            inTangent = Vector3.FromArray(key.values[3]);\n          }\n          if (key.values[4]) {\n            outTangent = Vector3.FromArray(key.values[4]);\n          }\n          if (key.values[5]) {\n            interpolation = key.values[5];\n          }\n          break;\n      }\n      const keyData = {};\n      keyData.frame = key.frame;\n      keyData.value = data;\n      if (inTangent != undefined) {\n        keyData.inTangent = inTangent;\n      }\n      if (outTangent != undefined) {\n        keyData.outTangent = outTangent;\n      }\n      if (interpolation != undefined) {\n        keyData.interpolation = interpolation;\n      }\n      keys.push(keyData);\n    }\n    animation.setKeys(keys);\n    if (parsedAnimation.ranges) {\n      for (index = 0; index < parsedAnimation.ranges.length; index++) {\n        data = parsedAnimation.ranges[index];\n        animation.createRange(data.name, data.from, data.to);\n      }\n    }\n    return animation;\n  }\n  /**\n   * Appends the serialized animations from the source animations\n   * @param source Source containing the animations\n   * @param destination Target to store the animations\n   */\n  static AppendSerializedAnimations(source, destination) {\n    SerializationHelper.AppendSerializedAnimations(source, destination);\n  }\n  /**\n   * Creates a new animation or an array of animations from a snippet saved in a remote file\n   * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @returns a promise that will resolve to the new animation or an array of animations\n   */\n  static ParseFromFileAsync(name, url) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            let serializationObject = JSON.parse(request.responseText);\n            if (serializationObject.animations) {\n              serializationObject = serializationObject.animations;\n            }\n            if (serializationObject.length) {\n              const output = new Array();\n              for (const serializedAnimation of serializationObject) {\n                output.push(this.Parse(serializedAnimation));\n              }\n              resolve(output);\n            } else {\n              const output = this.Parse(serializationObject);\n              if (name) {\n                output.name = name;\n              }\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the animation\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates an animation or an array of animations from a snippet saved by the Inspector\n   * @param snippetId defines the snippet to load\n   * @returns a promise that will resolve to the new animation or a new array of animations\n   */\n  static ParseFromSnippetAsync(snippetId) {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            if (snippet.animations) {\n              const serializationObject = JSON.parse(snippet.animations);\n              const outputs = new Array();\n              for (const serializedAnimation of serializationObject.animations) {\n                const output = this.Parse(serializedAnimation);\n                output.snippetId = snippetId;\n                outputs.push(output);\n              }\n              resolve(outputs);\n            } else {\n              const serializationObject = JSON.parse(snippet.animation);\n              const output = this.Parse(serializationObject);\n              output.snippetId = snippetId;\n              resolve(output);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\nAnimation._UniqueIdGenerator = 0;\n/**\n * Use matrix interpolation instead of using direct key value when animating matrices\n */\nAnimation.AllowMatricesInterpolation = false;\n/**\n * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\n */\nAnimation.AllowMatrixDecomposeForInterpolation = true;\n/** Define the Url to load snippets */\nAnimation.SnippetUrl = `https://snippet.babylonjs.com`;\n// Statics\n/**\n * Float animation type\n */\nAnimation.ANIMATIONTYPE_FLOAT = 0;\n/**\n * Vector3 animation type\n */\nAnimation.ANIMATIONTYPE_VECTOR3 = 1;\n/**\n * Quaternion animation type\n */\nAnimation.ANIMATIONTYPE_QUATERNION = 2;\n/**\n * Matrix animation type\n */\nAnimation.ANIMATIONTYPE_MATRIX = 3;\n/**\n * Color3 animation type\n */\nAnimation.ANIMATIONTYPE_COLOR3 = 4;\n/**\n * Color3 animation type\n */\nAnimation.ANIMATIONTYPE_COLOR4 = 7;\n/**\n * Vector2 animation type\n */\nAnimation.ANIMATIONTYPE_VECTOR2 = 5;\n/**\n * Size animation type\n */\nAnimation.ANIMATIONTYPE_SIZE = 6;\n/**\n * Relative Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_RELATIVE = 0;\n/**\n * Cycle Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_CYCLE = 1;\n/**\n * Constant Loop Mode\n */\nAnimation.ANIMATIONLOOPMODE_CONSTANT = 2;\n/**\n * Creates an animation or an array of animations from a snippet saved by the Inspector\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load\n * @returns a promise that will resolve to the new animation or a new array of animations\n */\nAnimation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\nRegisterClass(\"BABYLON.Animation\", Animation);\nNode._AnimationRangeFactory = (name, from, to) => new AnimationRange(name, from, to);","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Vector2","Matrix","TmpVectors","Color3","Color4","Scalar","SerializationHelper","RegisterClass","AnimationKeyInterpolation","AnimationRange","Node","Size","WebRequest","_IAnimationState","Animation","constructor","name","targetProperty","framePerSecond","dataType","loopMode","enableBlending","Array","targetPropertyPath","split","undefined","ANIMATIONLOOPMODE_CYCLE","uniqueId","_UniqueIdGenerator","_PrepareAnimation","totalFrame","from","to","easingFunction","isNaN","parseFloat","isFinite","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_COLOR3","ANIMATIONTYPE_COLOR4","ANIMATIONTYPE_SIZE","animation","keys","frame","value","setKeys","setEasingFunction","CreateAnimation","property","animationType","ANIMATIONLOOPMODE_CONSTANT","CreateAndStartAnimation","target","onAnimationEnd","scene","getScene","beginDirectAnimation","CreateAndStartHierarchyAnimation","node","directDescendantsOnly","beginDirectHierarchyAnimation","CreateMergeAndStartAnimation","animations","push","beginAnimation","MakeAnimationAdditive","sourceAnimation","referenceFrame","range","cloneOriginal","clonedName","clone","_keys","length","startIndex","firstKey","endIndex","lastKey","valueStore","referenceValue","referencePosition","referenceQuaternion","referenceScaling","keyPosition","keyQuaternion","keyScaling","referenceFound","rangeValue","getRange","fromKeyFound","toKeyFound","_getKeyValue","index","currentKey","nextKey","animationState","key","repeatCount","_interpolate","splice","normalize","conjugateInPlace","ANIMATIONTYPE_MATRIX","decompose","subtractInPlace","divideInPlace","multiplyToRef","ComposeToRef","subtractToRef","width","height","TransitionTo","targetValue","host","frameRate","transition","duration","endFrame","runtimeAnimations","_runtimeAnimations","hasRunningRuntimeAnimations","runtimeAnimation","isStopped","toString","fullDetails","ret","_ranges","Object","first","addEvent","event","_events","sort","a","b","removeEvents","getEvents","createRange","deleteRange","deleteFrames","getKeys","getHighestFrame","nKeys","getEasingFunction","_easingFunction","floatInterpolateFunction","startValue","endValue","gradient","Lerp","floatInterpolateFunctionWithTangents","outTangent","inTangent","Hermite","quaternionInterpolateFunction","Slerp","quaternionInterpolateFunctionWithTangents","vector3InterpolateFunction","vector3InterpolateFunctionWithTangents","vector2InterpolateFunction","vector2InterpolateFunctionWithTangents","sizeInterpolateFunction","color3InterpolateFunction","color3InterpolateFunctionWithTangents","color4InterpolateFunction","color4InterpolateFunctionWithTangents","evaluate","currentFrame","state","highLimitValue","keysLength","startKey","endKey","interpolation","STEP","useTangent","frameDelta","ease","floatValue","ANIMATIONLOOPMODE_RELATIVE","offsetValue","quatValue","scale","addInPlace","vec3Value","add","vec2Value","color3Value","color4Value","AllowMatricesInterpolation","matrixInterpolateFunction","workValue","result","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","join","blendingSpeed","values","slice","serialize","serializationObject","loopBehavior","animationKey","asArray","ranges","source","_UniversalLerp","left","right","amount","toFixed","Parse","parsedAnimation","data","FromArray","_inTangent","equals","Zero","_outTangent","keyData","AppendSerializedAnimations","destination","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","JSON","parse","responseText","output","serializedAnimation","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","outputs","SnippetUrl","replace","_AnimationRangeFactory"],"sourceRoot":"","sources":["../../../../lts/core/generated/Animations/animation.ts"],"sourcesContent":["import type { IEasingFunction, EasingFunction } from \"./easing\";\r\nimport { Vector3, Quaternion, Vector2, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\nimport { AnimationKeyInterpolation } from \"./animationKey\";\r\nimport { AnimationRange } from \"./animationRange\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport { Node } from \"../node\";\r\nimport type { IAnimatable } from \"./animatable.interface\";\r\nimport { Size } from \"../Maths/math.size\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare type Animatable = import(\"./animatable\").Animatable;\r\ndeclare type RuntimeAnimation = import(\"./runtimeAnimation\").RuntimeAnimation;\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _IAnimationState {\r\n    key: number;\r\n    repeatCount: number;\r\n    workValue?: any;\r\n    loopMode?: number;\r\n    offsetValue?: any;\r\n    highLimitValue?: any;\r\n}\r\n\r\n/**\r\n * Class used to store any kind of animation\r\n */\r\nexport class Animation {\r\n    private static _UniqueIdGenerator = 0;\r\n\r\n    /**\r\n     * Use matrix interpolation instead of using direct key value when animating matrices\r\n     */\r\n    public static AllowMatricesInterpolation = false;\r\n\r\n    /**\r\n     * When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower\r\n     */\r\n    public static AllowMatrixDecomposeForInterpolation = true;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the animation (the uniqueness is solely among other animations)\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the animation was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Stores the key frames of the animation\r\n     */\r\n    private _keys: Array<IAnimationKey>;\r\n\r\n    /**\r\n     * Stores the easing function of the animation\r\n     */\r\n    private _easingFunction: Nullable<IEasingFunction> = null;\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n\r\n    /**\r\n     * The set of event that will be linked to this animation\r\n     */\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * Stores an array of target property paths\r\n     */\r\n    public targetPropertyPath: string[];\r\n\r\n    /**\r\n     * Stores the blending speed of the animation\r\n     */\r\n    public blendingSpeed = 0.01;\r\n\r\n    /**\r\n     * Stores the animation ranges for the animation\r\n     */\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    /**\r\n     * @internal Internal use\r\n     */\r\n    public static _PrepareAnimation(\r\n        name: string,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction\r\n    ): Nullable<Animation> {\r\n        let dataType = undefined;\r\n\r\n        if (!isNaN(parseFloat(from)) && isFinite(from)) {\r\n            dataType = Animation.ANIMATIONTYPE_FLOAT;\r\n        } else if (from instanceof Quaternion) {\r\n            dataType = Animation.ANIMATIONTYPE_QUATERNION;\r\n        } else if (from instanceof Vector3) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR3;\r\n        } else if (from instanceof Vector2) {\r\n            dataType = Animation.ANIMATIONTYPE_VECTOR2;\r\n        } else if (from instanceof Color3) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR3;\r\n        } else if (from instanceof Color4) {\r\n            dataType = Animation.ANIMATIONTYPE_COLOR4;\r\n        } else if (from instanceof Size) {\r\n            dataType = Animation.ANIMATIONTYPE_SIZE;\r\n        }\r\n\r\n        if (dataType == undefined) {\r\n            return null;\r\n        }\r\n\r\n        const animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\r\n\r\n        const keys: Array<IAnimationKey> = [\r\n            { frame: 0, value: from },\r\n            { frame: totalFrame, value: to },\r\n        ];\r\n        animation.setKeys(keys);\r\n\r\n        if (easingFunction !== undefined) {\r\n            animation.setEasingFunction(easingFunction);\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Sets up an animation\r\n     * @param property The property to animate\r\n     * @param animationType The animation type to apply\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param easingFunction The easing function used in the animation\r\n     * @returns The created animation\r\n     */\r\n    public static CreateAnimation(property: string, animationType: number, framePerSecond: number, easingFunction: EasingFunction): Animation {\r\n        const animation: Animation = new Animation(property + \"Animation\", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n        animation.setEasingFunction(easingFunction);\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param target defines the target where the animation will take place\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second yo use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when animation end\r\n     * @param scene defines the hosting scene\r\n     * @returns the animatable created for this animation\r\n     */\r\n    public static CreateAndStartAnimation(\r\n        name: string,\r\n        target: any,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void,\r\n        scene?: Scene\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        if (target.getScene) {\r\n            scene = target.getScene();\r\n        }\r\n\r\n        if (!scene) {\r\n            return null;\r\n        }\r\n\r\n        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Create and start an animation on a node and its descendants\r\n     * @param name defines the name of the global animation that will be run on all nodes\r\n     * @param node defines the root node where the animation will take place\r\n     * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used\r\n     * @param targetProperty defines property to animate\r\n     * @param framePerSecond defines the number of frame per second to use\r\n     * @param totalFrame defines the number of frames in total\r\n     * @param from defines the initial value\r\n     * @param to defines the final value\r\n     * @param loopMode defines which loop mode you want to use (off by default)\r\n     * @param easingFunction defines the easing function to use (linear by default)\r\n     * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n     * @returns the list of animatables created for all nodes\r\n     * @example https://www.babylonjs-playground.com/#MH0VLI\r\n     */\r\n    public static CreateAndStartHierarchyAnimation(\r\n        name: string,\r\n        node: Node,\r\n        directDescendantsOnly: boolean,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable[]> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        const scene = node.getScene();\r\n        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, merges it with the existing animations and starts it\r\n     * @param name Name of the animation\r\n     * @param node Node which contains the scene that begins the animations\r\n     * @param targetProperty Specifies which property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param totalFrame The total number of frames\r\n     * @param from The frame at the beginning of the animation\r\n     * @param to The frame at the end of the animation\r\n     * @param loopMode Specifies the loop mode of the animation\r\n     * @param easingFunction (Optional) The easing function of the animation, which allow custom mathematical formulas for animations\r\n     * @param onAnimationEnd Callback to run once the animation is complete\r\n     * @returns Nullable animation\r\n     */\r\n    public static CreateMergeAndStartAnimation(\r\n        name: string,\r\n        node: Node,\r\n        targetProperty: string,\r\n        framePerSecond: number,\r\n        totalFrame: number,\r\n        from: any,\r\n        to: any,\r\n        loopMode?: number,\r\n        easingFunction?: EasingFunction,\r\n        onAnimationEnd?: () => void\r\n    ): Nullable<Animatable> {\r\n        const animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\r\n\r\n        if (!animation) {\r\n            return null;\r\n        }\r\n\r\n        node.animations.push(animation);\r\n\r\n        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1.0, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimation defines the Animation containing keyframes to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Animation to convert\r\n     * @param cloneOriginal defines whether or not to clone the animation and convert the clone or convert the original animation (default is false)\r\n     * @param clonedName defines the name of the resulting cloned Animation if cloneOriginal is true\r\n     * @returns a new Animation if cloneOriginal is true or the original Animation if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimation: Animation, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): Animation {\r\n        let animation = sourceAnimation;\r\n\r\n        if (cloneOriginal) {\r\n            animation = sourceAnimation.clone();\r\n            animation.name = clonedName || animation.name;\r\n        }\r\n\r\n        if (!animation._keys.length) {\r\n            return animation;\r\n        }\r\n\r\n        referenceFrame = referenceFrame >= 0 ? referenceFrame : 0;\r\n        let startIndex = 0;\r\n        const firstKey = animation._keys[0];\r\n        let endIndex = animation._keys.length - 1;\r\n        const lastKey = animation._keys[endIndex];\r\n        const valueStore = {\r\n            referenceValue: firstKey.value,\r\n            referencePosition: TmpVectors.Vector3[0],\r\n            referenceQuaternion: TmpVectors.Quaternion[0],\r\n            referenceScaling: TmpVectors.Vector3[1],\r\n            keyPosition: TmpVectors.Vector3[2],\r\n            keyQuaternion: TmpVectors.Quaternion[1],\r\n            keyScaling: TmpVectors.Vector3[3],\r\n        };\r\n        let referenceFound = false;\r\n        let from = firstKey.frame;\r\n        let to = lastKey.frame;\r\n        if (range) {\r\n            const rangeValue = animation.getRange(range);\r\n\r\n            if (rangeValue) {\r\n                from = rangeValue.from;\r\n                to = rangeValue.to;\r\n            }\r\n        }\r\n        let fromKeyFound = firstKey.frame === from;\r\n        let toKeyFound = lastKey.frame === to;\r\n\r\n        // There's only one key, so use it\r\n        if (animation._keys.length === 1) {\r\n            const value = animation._getKeyValue(animation._keys[0]);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is before the first frame, so just use the first frame\r\n        else if (referenceFrame <= firstKey.frame) {\r\n            const value = animation._getKeyValue(firstKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Reference frame is after the last frame, so just use the last frame\r\n        else if (referenceFrame >= lastKey.frame) {\r\n            const value = animation._getKeyValue(lastKey.value);\r\n            valueStore.referenceValue = value.clone ? value.clone() : value;\r\n            referenceFound = true;\r\n        }\r\n\r\n        // Find key bookends, create them if they don't exist\r\n        let index = 0;\r\n        while (!referenceFound || !fromKeyFound || (!toKeyFound && index < animation._keys.length - 1)) {\r\n            const currentKey = animation._keys[index];\r\n            const nextKey = animation._keys[index + 1];\r\n\r\n            // If reference frame wasn't found yet, check if we can interpolate to it\r\n            if (!referenceFound && referenceFrame >= currentKey.frame && referenceFrame <= nextKey.frame) {\r\n                let value;\r\n\r\n                if (referenceFrame === currentKey.frame) {\r\n                    value = animation._getKeyValue(currentKey.value);\r\n                } else if (referenceFrame === nextKey.frame) {\r\n                    value = animation._getKeyValue(nextKey.value);\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    value = animation._interpolate(referenceFrame, animationState);\r\n                }\r\n\r\n                valueStore.referenceValue = value.clone ? value.clone() : value;\r\n                referenceFound = true;\r\n            }\r\n\r\n            // If from key wasn't found yet, check if we can interpolate to it\r\n            if (!fromKeyFound && from >= currentKey.frame && from <= nextKey.frame) {\r\n                if (from === currentKey.frame) {\r\n                    startIndex = index;\r\n                } else if (from === nextKey.frame) {\r\n                    startIndex = index + 1;\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    const value = animation._interpolate(from, animationState);\r\n                    const key: IAnimationKey = {\r\n                        frame: from,\r\n                        value: value.clone ? value.clone() : value,\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    startIndex = index + 1;\r\n                }\r\n\r\n                fromKeyFound = true;\r\n            }\r\n\r\n            // If to key wasn't found yet, check if we can interpolate to it\r\n            if (!toKeyFound && to >= currentKey.frame && to <= nextKey.frame) {\r\n                if (to === currentKey.frame) {\r\n                    endIndex = index;\r\n                } else if (to === nextKey.frame) {\r\n                    endIndex = index + 1;\r\n                } else {\r\n                    const animationState = {\r\n                        key: index,\r\n                        repeatCount: 0,\r\n                        loopMode: this.ANIMATIONLOOPMODE_CONSTANT,\r\n                    };\r\n                    const value = animation._interpolate(to, animationState);\r\n                    const key: IAnimationKey = {\r\n                        frame: to,\r\n                        value: value.clone ? value.clone() : value,\r\n                    };\r\n                    animation._keys.splice(index + 1, 0, key);\r\n                    endIndex = index + 1;\r\n                }\r\n\r\n                toKeyFound = true;\r\n            }\r\n\r\n            index++;\r\n        }\r\n\r\n        // Conjugate the quaternion\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            valueStore.referenceValue.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Decompose matrix and conjugate the quaternion\r\n        else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);\r\n            valueStore.referenceQuaternion.normalize().conjugateInPlace();\r\n        }\r\n\r\n        // Subtract the reference value from all of the key values\r\n        for (index = startIndex; index <= endIndex; index++) {\r\n            const key = animation._keys[index];\r\n\r\n            // If this key was duplicated to create a frame 0 key, skip it because its value has already been updated\r\n            if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {\r\n                continue;\r\n            }\r\n\r\n            switch (animation.dataType) {\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);\r\n                    valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);\r\n                    valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);\r\n                    valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);\r\n                    Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    valueStore.referenceValue.multiplyToRef(key.value, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_VECTOR2:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.value.subtractToRef(valueStore.referenceValue, key.value);\r\n                    break;\r\n\r\n                case Animation.ANIMATIONTYPE_SIZE:\r\n                    key.value.width -= valueStore.referenceValue.width;\r\n                    key.value.height -= valueStore.referenceValue.height;\r\n                    break;\r\n\r\n                default:\r\n                    key.value -= valueStore.referenceValue;\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Transition property of an host to the target Value\r\n     * @param property The property to transition\r\n     * @param targetValue The target Value of the property\r\n     * @param host The object where the property to animate belongs\r\n     * @param scene Scene used to run the animation\r\n     * @param frameRate Framerate (in frame/s) to use\r\n     * @param transition The transition type we want to use\r\n     * @param duration The duration of the animation, in milliseconds\r\n     * @param onAnimationEnd Callback trigger at the end of the animation\r\n     * @returns Nullable animation\r\n     */\r\n    public static TransitionTo(\r\n        property: string,\r\n        targetValue: any,\r\n        host: any,\r\n        scene: Scene,\r\n        frameRate: number,\r\n        transition: Animation,\r\n        duration: number,\r\n        onAnimationEnd: Nullable<() => void> = null\r\n    ): Nullable<Animatable> {\r\n        if (duration <= 0) {\r\n            host[property] = targetValue;\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n            return null;\r\n        }\r\n\r\n        const endFrame: number = frameRate * (duration / 1000);\r\n\r\n        transition.setKeys([\r\n            {\r\n                frame: 0,\r\n                value: host[property].clone ? host[property].clone() : host[property],\r\n            },\r\n            {\r\n                frame: endFrame,\r\n                value: targetValue,\r\n            },\r\n        ]);\r\n\r\n        if (!host.animations) {\r\n            host.animations = [];\r\n        }\r\n\r\n        host.animations.push(transition);\r\n\r\n        const animation: Animatable = scene.beginAnimation(host, 0, endFrame, false);\r\n        animation.onAnimationEnd = onAnimationEnd;\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Return the array of runtime animations currently using this animation\r\n     */\r\n    public get runtimeAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Specifies if any of the runtime animations are currently running\r\n     */\r\n    public get hasRunningRuntimeAnimations(): boolean {\r\n        for (const runtimeAnimation of this._runtimeAnimations) {\r\n            if (!runtimeAnimation.isStopped()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Initializes the animation\r\n     * @param name Name of the animation\r\n     * @param targetProperty Property to animate\r\n     * @param framePerSecond The frames per second of the animation\r\n     * @param dataType The data type of the animation\r\n     * @param loopMode The loop mode of the animation\r\n     * @param enableBlending Specifies if blending should be enabled\r\n     */\r\n    constructor(\r\n        /**Name of the animation */\r\n        public name: string,\r\n        /**Property to animate */\r\n        public targetProperty: string,\r\n        /**The frames per second of the animation */\r\n        public framePerSecond: number,\r\n        /**The data type of the animation */\r\n        public dataType: number,\r\n        /**The loop mode of the animation */\r\n        public loopMode?: number,\r\n        /**Specifies if blending should be enabled */\r\n        public enableBlending?: boolean\r\n    ) {\r\n        this.targetPropertyPath = targetProperty.split(\".\");\r\n        this.dataType = dataType;\r\n        this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\r\n        this.uniqueId = Animation._UniqueIdGenerator++;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Converts the animation to a string\r\n     * @param fullDetails support for multiple levels of logging within scene loading\r\n     * @returns String form of the animation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\r\n        ret += \", datatype: \" + [\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"][this.dataType];\r\n        ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\r\n        ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Add an event to this animation\r\n     * @param event Event to add\r\n     */\r\n    public addEvent(event: AnimationEvent): void {\r\n        this._events.push(event);\r\n        this._events.sort((a, b) => a.frame - b.frame);\r\n    }\r\n\r\n    /**\r\n     * Remove all events found at the given frame\r\n     * @param frame The frame to remove events from\r\n     */\r\n    public removeEvents(frame: number): void {\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            if (this._events[index].frame === frame) {\r\n                this._events.splice(index, 1);\r\n                index--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves all the events from the animation\r\n     * @returns Events from the animation\r\n     */\r\n    public getEvents(): AnimationEvent[] {\r\n        return this._events;\r\n    }\r\n\r\n    /**\r\n     * Creates an animation range\r\n     * @param name Name of the animation range\r\n     * @param from Starting frame of the animation range\r\n     * @param to Ending frame of the animation\r\n     */\r\n    public createRange(name: string, from: number, to: number): void {\r\n        // check name not already in use; could happen for bones after serialized\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes an animation range by name\r\n     * @param name Name of the animation range to delete\r\n     * @param deleteFrames Specifies if the key frames for the range should also be deleted (true) or not (false)\r\n     */\r\n    public deleteRange(name: string, deleteFrames = true): void {\r\n        const range = this._ranges[name];\r\n        if (!range) {\r\n            return;\r\n        }\r\n        if (deleteFrames) {\r\n            const from = range.from;\r\n            const to = range.to;\r\n\r\n            // this loop MUST go high to low for multiple splices to work\r\n            for (let key = this._keys.length - 1; key >= 0; key--) {\r\n                if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\r\n                    this._keys.splice(key, 1);\r\n                }\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets the animation range by name, or null if not defined\r\n     * @param name Name of the animation range\r\n     * @returns Nullable animation range\r\n     */\r\n    public getRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name];\r\n    }\r\n\r\n    /**\r\n     * Gets the key frames from the animation\r\n     * @returns The key frames of the animation\r\n     */\r\n    public getKeys(): Array<IAnimationKey> {\r\n        return this._keys;\r\n    }\r\n\r\n    /**\r\n     * Gets the highest frame rate of the animation\r\n     * @returns Highest frame rate of the animation\r\n     */\r\n    public getHighestFrame(): number {\r\n        let ret = 0;\r\n\r\n        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {\r\n            if (ret < this._keys[key].frame) {\r\n                ret = this._keys[key].frame;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the easing function of the animation\r\n     * @returns Easing function of the animation\r\n     */\r\n    public getEasingFunction(): Nullable<IEasingFunction> {\r\n        return this._easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Sets the easing function of the animation\r\n     * @param easingFunction A custom mathematical formula for animation\r\n     */\r\n    public setEasingFunction(easingFunction: Nullable<IEasingFunction>): void {\r\n        this._easingFunction = easingFunction;\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunction(startValue: number, endValue: number, gradient: number): number {\r\n        return Scalar.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a scalar cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public floatInterpolateFunctionWithTangents(startValue: number, outTangent: number, endValue: number, inTangent: number, gradient: number): number {\r\n        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion using a spherical linear interpolation\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunction(startValue: Quaternion, endValue: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Slerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a quaternion cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated quaternion value\r\n     */\r\n    public quaternionInterpolateFunctionWithTangents(startValue: Quaternion, outTangent: Quaternion, endValue: Quaternion, inTangent: Quaternion, gradient: number): Quaternion {\r\n        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated scalar value\r\n     */\r\n    public vector3InterpolateFunction(startValue: Vector3, endValue: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns InterpolatedVector3 value\r\n     */\r\n    public vector3InterpolateFunctionWithTangents(startValue: Vector3, outTangent: Vector3, endValue: Vector3, inTangent: Vector3, gradient: number): Vector3 {\r\n        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunction(startValue: Vector2, endValue: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Vector2 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate (value between 0 and 1)\r\n     * @returns Interpolated Vector2 value\r\n     */\r\n    public vector2InterpolateFunctionWithTangents(startValue: Vector2, outTangent: Vector2, endValue: Vector2, inTangent: Vector2, gradient: number): Vector2 {\r\n        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a size linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Size value\r\n     */\r\n    public sizeInterpolateFunction(startValue: Size, endValue: Size, gradient: number): Size {\r\n        return Size.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color3InterpolateFunction(startValue: Color3, endValue: Color3, gradient: number): Color3 {\r\n        return Color3.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color3 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color3InterpolateFunctionWithTangents(startValue: Color3, outTangent: Color3, endValue: Color3, inTangent: Color3, gradient: number): Color3 {\r\n        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 linearly\r\n     * @param startValue Start value of the animation curve\r\n     * @param endValue End value of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns Interpolated Color3 value\r\n     */\r\n    public color4InterpolateFunction(startValue: Color4, endValue: Color4, gradient: number): Color4 {\r\n        return Color4.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Interpolates a Color4 cubically\r\n     * @param startValue Start value of the animation curve\r\n     * @param outTangent End tangent of the animation\r\n     * @param endValue End value of the animation curve\r\n     * @param inTangent Start tangent of the animation curve\r\n     * @param gradient Scalar amount to interpolate\r\n     * @returns interpolated value\r\n     */\r\n    public color4InterpolateFunctionWithTangents(startValue: Color4, outTangent: Color4, endValue: Color4, inTangent: Color4, gradient: number): Color4 {\r\n        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _getKeyValue(value: any): any {\r\n        if (typeof value === \"function\") {\r\n            return value();\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Evaluate the animation value at a given frame\r\n     * @param currentFrame defines the frame where we want to evaluate the animation\r\n     * @returns the animation value\r\n     */\r\n    public evaluate(currentFrame: number) {\r\n        return this._interpolate(currentFrame, {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: Animation.ANIMATIONLOOPMODE_CONSTANT,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _interpolate(currentFrame: number, state: _IAnimationState): any {\r\n        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {\r\n            return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;\r\n        }\r\n\r\n        const keys = this._keys;\r\n        const keysLength = keys.length;\r\n\r\n        let key = state.key;\r\n\r\n        while (key >= 0 && currentFrame < keys[key].frame) {\r\n            --key;\r\n        }\r\n\r\n        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {\r\n            ++key;\r\n        }\r\n\r\n        state.key = key;\r\n\r\n        if (key < 0) {\r\n            return this._getKeyValue(keys[0].value);\r\n        } else if (key + 1 > keysLength - 1) {\r\n            return this._getKeyValue(keys[keysLength - 1].value);\r\n        }\r\n\r\n        const startKey = keys[key];\r\n        const endKey = keys[key + 1];\r\n        const startValue = this._getKeyValue(startKey.value);\r\n        const endValue = this._getKeyValue(endKey.value);\r\n        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {\r\n            if (endKey.frame > currentFrame) {\r\n                return startValue;\r\n            } else {\r\n                return endValue;\r\n            }\r\n        }\r\n\r\n        const useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\r\n        const frameDelta = endKey.frame - startKey.frame;\r\n\r\n        // gradient : percent of currentFrame between the frame inf and the frame sup\r\n        let gradient = (currentFrame - startKey.frame) / frameDelta;\r\n\r\n        // check for easingFunction and correction of gradient\r\n        const easingFunction = this.getEasingFunction();\r\n        if (easingFunction !== null) {\r\n            gradient = easingFunction.ease(gradient);\r\n        }\r\n\r\n        switch (this.dataType) {\r\n            // Float\r\n            case Animation.ANIMATIONTYPE_FLOAT: {\r\n                const floatValue = useTangent\r\n                    ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient)\r\n                    : this.floatInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return floatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return state.offsetValue * state.repeatCount + floatValue;\r\n                }\r\n                break;\r\n            }\r\n            // Quaternion\r\n            case Animation.ANIMATIONTYPE_QUATERNION: {\r\n                const quatValue = useTangent\r\n                    ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.quaternionInterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return quatValue;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n\r\n                return quatValue;\r\n            }\r\n            // Vector3\r\n            case Animation.ANIMATIONTYPE_VECTOR3: {\r\n                const vec3Value = useTangent\r\n                    ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return vec3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return vec3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Vector2\r\n            case Animation.ANIMATIONTYPE_VECTOR2: {\r\n                const vec2Value = useTangent\r\n                    ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.vector2InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return vec2Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return vec2Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Size\r\n            case Animation.ANIMATIONTYPE_SIZE: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient);\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color3\r\n            case Animation.ANIMATIONTYPE_COLOR3: {\r\n                const color3Value = useTangent\r\n                    ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color3InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return color3Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return color3Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Color4\r\n            case Animation.ANIMATIONTYPE_COLOR4: {\r\n                const color4Value = useTangent\r\n                    ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient)\r\n                    : this.color4InterpolateFunction(startValue, endValue, gradient);\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT:\r\n                        return color4Value;\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE:\r\n                        return color4Value.add(state.offsetValue.scale(state.repeatCount));\r\n                }\r\n                break;\r\n            }\r\n            // Matrix\r\n            case Animation.ANIMATIONTYPE_MATRIX: {\r\n                switch (state.loopMode) {\r\n                    case Animation.ANIMATIONLOOPMODE_CYCLE:\r\n                    case Animation.ANIMATIONLOOPMODE_CONSTANT: {\r\n                        if (Animation.AllowMatricesInterpolation) {\r\n                            return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);\r\n                        }\r\n                        return startValue;\r\n                    }\r\n                    case Animation.ANIMATIONLOOPMODE_RELATIVE: {\r\n                        return startValue;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the function to use to interpolate matrices\r\n     * @param startValue defines the start matrix\r\n     * @param endValue defines the end matrix\r\n     * @param gradient defines the gradient between both matrices\r\n     * @param result defines an optional target matrix where to store the interpolation\r\n     * @returns the interpolated matrix\r\n     */\r\n    public matrixInterpolateFunction(startValue: Matrix, endValue: Matrix, gradient: number, result?: Matrix): Matrix {\r\n        if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n            if (result) {\r\n                Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\r\n                return result;\r\n            }\r\n            return Matrix.DecomposeLerp(startValue, endValue, gradient);\r\n        }\r\n\r\n        if (result) {\r\n            Matrix.LerpToRef(startValue, endValue, gradient, result);\r\n            return result;\r\n        }\r\n        return Matrix.Lerp(startValue, endValue, gradient);\r\n    }\r\n\r\n    /**\r\n     * Makes a copy of the animation\r\n     * @returns Cloned animation\r\n     */\r\n    public clone(): Animation {\r\n        const clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\r\n\r\n        clone.enableBlending = this.enableBlending;\r\n        clone.blendingSpeed = this.blendingSpeed;\r\n\r\n        if (this._keys) {\r\n            clone.setKeys(this._keys);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            clone._ranges = {};\r\n            for (const name in this._ranges) {\r\n                const range = this._ranges[name];\r\n                if (!range) {\r\n                    continue;\r\n                }\r\n                clone._ranges[name] = range.clone();\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Sets the key frames of the animation\r\n     * @param values The animation key frames to set\r\n     */\r\n    public setKeys(values: Array<IAnimationKey>): void {\r\n        this._keys = values.slice(0);\r\n    }\r\n\r\n    /**\r\n     * Serializes the animation to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.property = this.targetProperty;\r\n        serializationObject.framePerSecond = this.framePerSecond;\r\n        serializationObject.dataType = this.dataType;\r\n        serializationObject.loopBehavior = this.loopMode;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        const dataType = this.dataType;\r\n        serializationObject.keys = [];\r\n        const keys = this.getKeys();\r\n        for (let index = 0; index < keys.length; index++) {\r\n            const animationKey = keys[index];\r\n\r\n            const key: any = {};\r\n            key.frame = animationKey.frame;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    key.values = [animationKey.value];\r\n                    if (animationKey.inTangent !== undefined) {\r\n                        key.values.push(animationKey.inTangent);\r\n                    }\r\n                    if (animationKey.outTangent !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent);\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    key.values = animationKey.value.asArray();\r\n                    if (animationKey.inTangent != undefined) {\r\n                        key.values.push(animationKey.inTangent.asArray());\r\n                    }\r\n                    if (animationKey.outTangent != undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.outTangent.asArray());\r\n                    }\r\n                    if (animationKey.interpolation !== undefined) {\r\n                        if (animationKey.inTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        if (animationKey.outTangent === undefined) {\r\n                            key.values.push(undefined);\r\n                        }\r\n                        key.values.push(animationKey.interpolation);\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            serializationObject.keys.push(key);\r\n        }\r\n\r\n        serializationObject.ranges = [];\r\n        for (const name in this._ranges) {\r\n            const source = this._ranges[name];\r\n\r\n            if (!source) {\r\n                continue;\r\n            }\r\n            const range: any = {};\r\n            range.name = name;\r\n            range.from = source.from;\r\n            range.to = source.to;\r\n            serializationObject.ranges.push(range);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n    /**\r\n     * Relative Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_RELATIVE = 0;\r\n    /**\r\n     * Cycle Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CYCLE = 1;\r\n    /**\r\n     * Constant Loop Mode\r\n     */\r\n    public static readonly ANIMATIONLOOPMODE_CONSTANT = 2;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _UniversalLerp(left: any, right: any, amount: number): any {\r\n        const constructor = left.constructor;\r\n        if (constructor.Lerp) {\r\n            // Lerp supported\r\n            return constructor.Lerp(left, right, amount);\r\n        } else if (constructor.Slerp) {\r\n            // Slerp supported\r\n            return constructor.Slerp(left, right, amount);\r\n        } else if (left.toFixed) {\r\n            // Number\r\n            return left * (1.0 - amount) + amount * right;\r\n        } else {\r\n            // Blending not supported\r\n            return right;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses an animation object and creates an animation\r\n     * @param parsedAnimation Parsed animation object\r\n     * @returns Animation object\r\n     */\r\n    public static Parse(parsedAnimation: any): Animation {\r\n        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\r\n\r\n        const dataType = parsedAnimation.dataType;\r\n        const keys: Array<IAnimationKey> = [];\r\n        let data;\r\n        let index: number;\r\n\r\n        if (parsedAnimation.enableBlending) {\r\n            animation.enableBlending = parsedAnimation.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimation.blendingSpeed) {\r\n            animation.blendingSpeed = parsedAnimation.blendingSpeed;\r\n        }\r\n\r\n        for (index = 0; index < parsedAnimation.keys.length; index++) {\r\n            const key = parsedAnimation.keys[index];\r\n            let inTangent: any = undefined;\r\n            let outTangent: any = undefined;\r\n            let interpolation: any = undefined;\r\n\r\n            switch (dataType) {\r\n                case Animation.ANIMATIONTYPE_FLOAT:\r\n                    data = key.values[0];\r\n                    if (key.values.length >= 2) {\r\n                        inTangent = key.values[1];\r\n                    }\r\n                    if (key.values.length >= 3) {\r\n                        outTangent = key.values[2];\r\n                    }\r\n                    if (key.values.length >= 4) {\r\n                        interpolation = key.values[3];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_QUATERNION:\r\n                    data = Quaternion.FromArray(key.values);\r\n                    if (key.values.length >= 8) {\r\n                        const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));\r\n                        if (!_inTangent.equals(Quaternion.Zero())) {\r\n                            inTangent = _inTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 12) {\r\n                        const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));\r\n                        if (!_outTangent.equals(Quaternion.Zero())) {\r\n                            outTangent = _outTangent;\r\n                        }\r\n                    }\r\n                    if (key.values.length >= 13) {\r\n                        interpolation = key.values[12];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_MATRIX:\r\n                    data = Matrix.FromArray(key.values);\r\n                    if (key.values.length >= 17) {\r\n                        interpolation = key.values[16];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR3:\r\n                    data = Color3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Color3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Color3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_COLOR4:\r\n                    data = Color4.FromArray(key.values);\r\n                    if (key.values[4]) {\r\n                        inTangent = Color4.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        outTangent = Color4.FromArray(key.values[5]);\r\n                    }\r\n                    if (key.values[6]) {\r\n                        interpolation = Color4.FromArray(key.values[6]);\r\n                    }\r\n                    break;\r\n                case Animation.ANIMATIONTYPE_VECTOR3:\r\n                default:\r\n                    data = Vector3.FromArray(key.values);\r\n                    if (key.values[3]) {\r\n                        inTangent = Vector3.FromArray(key.values[3]);\r\n                    }\r\n                    if (key.values[4]) {\r\n                        outTangent = Vector3.FromArray(key.values[4]);\r\n                    }\r\n                    if (key.values[5]) {\r\n                        interpolation = key.values[5];\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            const keyData: any = {};\r\n            keyData.frame = key.frame;\r\n            keyData.value = data;\r\n\r\n            if (inTangent != undefined) {\r\n                keyData.inTangent = inTangent;\r\n            }\r\n            if (outTangent != undefined) {\r\n                keyData.outTangent = outTangent;\r\n            }\r\n            if (interpolation != undefined) {\r\n                keyData.interpolation = interpolation;\r\n            }\r\n            keys.push(keyData);\r\n        }\r\n\r\n        animation.setKeys(keys);\r\n\r\n        if (parsedAnimation.ranges) {\r\n            for (index = 0; index < parsedAnimation.ranges.length; index++) {\r\n                data = parsedAnimation.ranges[index];\r\n                animation.createRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n\r\n        return animation;\r\n    }\r\n\r\n    /**\r\n     * Appends the serialized animations from the source animations\r\n     * @param source Source containing the animations\r\n     * @param destination Target to store the animations\r\n     */\r\n    public static AppendSerializedAnimations(source: IAnimatable, destination: any): void {\r\n        SerializationHelper.AppendSerializedAnimations(source, destination);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation or an array of animations from a snippet saved in a remote file\r\n     * @param name defines the name of the animation to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @returns a promise that will resolve to the new animation or an array of animations\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let serializationObject = JSON.parse(request.responseText);\r\n                        if (serializationObject.animations) {\r\n                            serializationObject = serializationObject.animations;\r\n                        }\r\n\r\n                        if (serializationObject.length) {\r\n                            const output = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject) {\r\n                                output.push(this.Parse(serializedAnimation));\r\n                            }\r\n\r\n                            resolve(output);\r\n                        } else {\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            if (name) {\r\n                                output.name = name;\r\n                            }\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the animation\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string): Promise<Animation | Array<Animation>> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n\r\n                        if (snippet.animations) {\r\n                            const serializationObject = JSON.parse(snippet.animations);\r\n                            const outputs = new Array<Animation>();\r\n                            for (const serializedAnimation of serializationObject.animations) {\r\n                                const output = this.Parse(serializedAnimation);\r\n                                output.snippetId = snippetId;\r\n                                outputs.push(output);\r\n                            }\r\n\r\n                            resolve(outputs);\r\n                        } else {\r\n                            const serializationObject = JSON.parse(snippet.animation);\r\n                            const output = this.Parse(serializationObject);\r\n\r\n                            output.snippetId = snippetId;\r\n\r\n                            resolve(output);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates an animation or an array of animations from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @returns a promise that will resolve to the new animation or a new array of animations\r\n     */\r\n    public static CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.Animation\", Animation);\r\nNode._AnimationRangeFactory = (name: string, from: number, to: number) => new AnimationRange(name, from, to);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}