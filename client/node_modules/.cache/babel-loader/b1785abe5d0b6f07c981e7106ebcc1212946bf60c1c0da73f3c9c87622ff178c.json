{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"reflectionFunction\";\nconst shader = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0); \n}\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{\nfloat lon=atan(direction.z,direction.x);\nfloat lat=acos(direction.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(1.0-s,t,0); \n}\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\nvec3 r=normalize(reflect(cameraToVertex,worldNormal));\nr=vec3(reflectionMatrix*vec4(r,0));\nfloat lon=atan(r.z,r.x);\nfloat lat=acos(r.y);\nvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\nfloat s=sphereCoords.x*0.5+0.5;\nfloat t=sphereCoords.y;\nreturn vec3(s,t,0);\n}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(vec3(view*worldPos));\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\nvec3 r=reflect(viewDir,viewNormal);\nr=vec3(reflectionMatrix*vec4(r,0));\nr.z=r.z-1.0;\nfloat m=2.0*length(r);\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\n}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=worldPos.xyz-eyePosition;\nvec3 coords=normalize(reflect(viewDir,worldNormal));\nreturn vec3(reflectionMatrix*vec4(coords,1));\n}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{\nvec3 viewDir=normalize(worldPos.xyz-eyePosition);\nvec3 coords=reflect(viewDir,worldNormal);\ncoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\ncoords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;\n}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*(view*worldPos));\n}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{\nreturn vec3(reflectionMatrix*vec4(positionW,1.));\n}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\nreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const reflectionFunction = {\n  name,\n  shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,8BAA4B;AAExD,MAAMC,IAAI,GAAG,oBAAoB;AACjC,MAAMC,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiHd;AACD;AACAF,WAAW,CAACG,oBAAoB,CAACF,IAAI,CAAC,GAAGC,MAAM;AAC/C;AACA,OAAO,MAAME,kBAAkB,GAAG;EAAEH,IAAI;EAAEC;AAAM,CAAE","names":["ShaderStore","name","shader","IncludesShadersStore","reflectionFunction"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/ShadersInclude/reflectionFunction.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"reflectionFunction\";\nconst shader = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\r{\rfloat lon=atan(direction.z,direction.x);\rfloat lat=acos(direction.y);\rvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\rfloat s=sphereCoords.x*0.5+0.5;\rfloat t=sphereCoords.y;\rreturn vec3(s,t,0); \r}\rvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\r{\rfloat lon=atan(direction.z,direction.x);\rfloat lat=acos(direction.y);\rvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\rfloat s=sphereCoords.x*0.5+0.5;\rfloat t=sphereCoords.y;\rreturn vec3(1.0-s,t,0); \r}\rvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\r{\rvec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);\rvec3 r=normalize(reflect(cameraToVertex,worldNormal));\rr=vec3(reflectionMatrix*vec4(r,0));\rfloat lon=atan(r.z,r.x);\rfloat lat=acos(r.y);\rvec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;\rfloat s=sphereCoords.x*0.5+0.5;\rfloat t=sphereCoords.y;\rreturn vec3(s,t,0);\r}\rvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\r{\rvec3 viewDir=normalize(vec3(view*worldPos));\rvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\rvec3 r=reflect(viewDir,viewNormal);\rr=vec3(reflectionMatrix*vec4(r,0));\rr.z=r.z-1.0;\rfloat m=2.0*length(r);\rreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\r}\rvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\r{\rvec3 viewDir=worldPos.xyz-eyePosition;\rvec3 coords=normalize(reflect(viewDir,worldNormal));\rreturn vec3(reflectionMatrix*vec4(coords,1));\r}\rvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\r{\rvec3 viewDir=normalize(worldPos.xyz-eyePosition);\rvec3 coords=reflect(viewDir,worldNormal);\rcoords=vec3(reflectionMatrix*vec4(coords,0));\r#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\r#endif\nreturn coords;\r}\rvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\r{\rvec3 viewDir=normalize(worldPos.xyz-eyePosition);\rvec3 coords=reflect(viewDir,worldNormal);\rcoords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);\rcoords=vec3(reflectionMatrix*vec4(coords,0));\r#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\r#endif\nreturn coords;\r}\rvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\r{\rreturn vec3(reflectionMatrix*(view*worldPos));\r}\rvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\r{\rreturn vec3(reflectionMatrix*vec4(positionW,1.));\r}\r#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\r{\r#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\rreturn computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\r#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);\rreturn computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\r#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\r#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\r#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\r#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\r#endif\n}\r#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const reflectionFunction = { name, shader };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}