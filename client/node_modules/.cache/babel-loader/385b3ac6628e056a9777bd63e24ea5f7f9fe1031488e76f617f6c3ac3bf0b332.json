{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Matrix, Vector3, Quaternion } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { Frustum } from \"../Maths/math.frustum.js\";\n\n/**\n * This is the base class of all the camera used in the application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class Camera extends Node {\n  /**\n   * Instantiates a new camera object.\n   * This should not be used directly but through the inherited cameras: ArcRotate, Free...\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n   * @param name Defines the name of the camera in the scene\n   * @param position Defines the position of the camera\n   * @param scene Defines the scene the camera belongs too\n   * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, scene);\n    /** @internal */\n    this._position = Vector3.Zero();\n    this._upVector = Vector3.Up();\n    /**\n     * Define the current limit on the left side for an orthographic camera\n     * In scene unit\n     */\n    this._orthoLeft = null;\n    /**\n     * Define the current limit on the right side for an orthographic camera\n     * In scene unit\n     */\n    this._orthoRight = null;\n    /**\n     * Define the current limit on the bottom side for an orthographic camera\n     * In scene unit\n     */\n    this._orthoBottom = null;\n    /**\n     * Define the current limit on the top side for an orthographic camera\n     * In scene unit\n     */\n    this._orthoTop = null;\n    /**\n     * Field Of View is set in Radians. (default is 0.8)\n     */\n    this.fov = 0.8;\n    /**\n     * Projection plane tilt around the X axis (horizontal), set in Radians. (default is 0)\n     * Can be used to make vertical lines in world space actually vertical on the screen.\n     * See https://forum.babylonjs.com/t/add-vertical-shift-to-3ds-max-exporter-babylon-cameras/17480\n     */\n    this.projectionPlaneTilt = 0;\n    /**\n     * Define the minimum distance the camera can see from.\n     * This is important to note that the depth buffer are not infinite and the closer it starts\n     * the more your scene might encounter depth fighting issue.\n     */\n    this.minZ = 1;\n    /**\n     * Define the maximum distance the camera can see to.\n     * This is important to note that the depth buffer are not infinite and the further it end\n     * the more your scene might encounter depth fighting issue.\n     */\n    this.maxZ = 10000.0;\n    /**\n     * Define the default inertia of the camera.\n     * This helps giving a smooth feeling to the camera movement.\n     */\n    this.inertia = 0.9;\n    /**\n     * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)\n     */\n    this._mode = Camera.PERSPECTIVE_CAMERA;\n    /**\n     * Define whether the camera is intermediate.\n     * This is useful to not present the output directly to the screen in case of rig without post process for instance\n     */\n    this.isIntermediate = false;\n    /**\n     * Define the viewport of the camera.\n     * This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.\n     */\n    this.viewport = new Viewport(0, 0, 1.0, 1.0);\n    /**\n     * Restricts the camera to viewing objects with the same layerMask.\n     * A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0\n     */\n    this.layerMask = 0x0fffffff;\n    /**\n     * fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)\n     */\n    this.fovMode = Camera.FOVMODE_VERTICAL_FIXED;\n    /**\n     * Rig mode of the camera.\n     * This is useful to create the camera with two \"eyes\" instead of one to create VR or stereoscopic scenes.\n     * This is normally controlled byt the camera themselves as internal use.\n     */\n    this.cameraRigMode = Camera.RIG_MODE_NONE;\n    /**\n     * Defines the list of custom render target which are rendered to and then used as the input to this camera's render. Eg. display another camera view on a TV in the main scene\n     * This is pretty helpful if you wish to make a camera render to a texture you could reuse somewhere\n     * else in the scene. (Eg. security camera)\n     *\n     * To change the final output target of the camera, camera.outputRenderTarget should be used instead (eg. webXR renders to a render target corresponding to an HMD)\n     */\n    this.customRenderTargets = new Array();\n    /**\n     * When set, the camera will render to this render target instead of the default canvas\n     *\n     * If the desire is to use the output of a camera as a texture in the scene consider using camera.customRenderTargets instead\n     */\n    this.outputRenderTarget = null;\n    /**\n     * Observable triggered when the camera view matrix has changed.\n     */\n    this.onViewMatrixChangedObservable = new Observable();\n    /**\n     * Observable triggered when the camera Projection matrix has changed.\n     */\n    this.onProjectionMatrixChangedObservable = new Observable();\n    /**\n     * Observable triggered when the inputs have been processed.\n     */\n    this.onAfterCheckInputsObservable = new Observable();\n    /**\n     * Observable triggered when reset has been called and applied to the camera.\n     */\n    this.onRestoreStateObservable = new Observable();\n    /**\n     * Is this camera a part of a rig system?\n     */\n    this.isRigCamera = false;\n    /** @internal */\n    this._rigCameras = new Array();\n    this._webvrViewMatrix = Matrix.Identity();\n    /** @internal */\n    this._skipRendering = false;\n    /** @internal */\n    this._projectionMatrix = new Matrix();\n    /** @internal */\n    this._postProcesses = new Array();\n    /** @internal */\n    this._activeMeshes = new SmartArray(256);\n    this._globalPosition = Vector3.Zero();\n    /** @internal */\n    this._computedViewMatrix = Matrix.Identity();\n    this._doNotComputeProjectionMatrix = false;\n    this._transformMatrix = Matrix.Zero();\n    this._refreshFrustumPlanes = true;\n    this._absoluteRotation = Quaternion.Identity();\n    /** @internal */\n    this._isCamera = true;\n    /** @internal */\n    this._isLeftCamera = false;\n    /** @internal */\n    this._isRightCamera = false;\n    this.getScene().addCamera(this);\n    if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {\n      this.getScene().activeCamera = this;\n    }\n    this.position = position;\n    this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);\n  }\n  /**\n   * Define the current local position of the camera in the scene\n   */\n  get position() {\n    return this._position;\n  }\n  set position(newPosition) {\n    this._position = newPosition;\n  }\n  /**\n   * The vector the camera should consider as up.\n   * (default is Vector3(0, 1, 0) aka Vector3.Up())\n   */\n  set upVector(vec) {\n    this._upVector = vec;\n  }\n  get upVector() {\n    return this._upVector;\n  }\n  /**\n   * The screen area in scene units squared\n   */\n  get screenArea() {\n    var _a, _b, _c, _d;\n    let x = 0;\n    let y = 0;\n    if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n      if (this.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {\n        y = this.minZ * 2 * Math.tan(this.fov / 2);\n        x = this.getEngine().getAspectRatio(this) * y;\n      } else {\n        x = this.minZ * 2 * Math.tan(this.fov / 2);\n        y = x / this.getEngine().getAspectRatio(this);\n      }\n    } else {\n      const halfWidth = this.getEngine().getRenderWidth() / 2.0;\n      const halfHeight = this.getEngine().getRenderHeight() / 2.0;\n      x = ((_a = this.orthoRight) !== null && _a !== void 0 ? _a : halfWidth) - ((_b = this.orthoLeft) !== null && _b !== void 0 ? _b : -halfWidth);\n      y = ((_c = this.orthoTop) !== null && _c !== void 0 ? _c : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);\n    }\n    return x * y;\n  }\n  set orthoLeft(value) {\n    this._orthoLeft = value;\n    for (const rigCamera of this._rigCameras) {\n      rigCamera.orthoLeft = value;\n    }\n  }\n  get orthoLeft() {\n    return this._orthoLeft;\n  }\n  set orthoRight(value) {\n    this._orthoRight = value;\n    for (const rigCamera of this._rigCameras) {\n      rigCamera.orthoRight = value;\n    }\n  }\n  get orthoRight() {\n    return this._orthoRight;\n  }\n  set orthoBottom(value) {\n    this._orthoBottom = value;\n    for (const rigCamera of this._rigCameras) {\n      rigCamera.orthoBottom = value;\n    }\n  }\n  get orthoBottom() {\n    return this._orthoBottom;\n  }\n  set orthoTop(value) {\n    this._orthoTop = value;\n    for (const rigCamera of this._rigCameras) {\n      rigCamera.orthoTop = value;\n    }\n  }\n  get orthoTop() {\n    return this._orthoTop;\n  }\n  set mode(mode) {\n    this._mode = mode;\n    // Pass the mode down to the rig cameras\n    for (const rigCamera of this._rigCameras) {\n      rigCamera.mode = mode;\n    }\n  }\n  get mode() {\n    return this._mode;\n  }\n  /**\n   * Store current camera state (fov, position, etc..)\n   * @returns the camera\n   */\n  storeState() {\n    this._stateStored = true;\n    this._storedFov = this.fov;\n    return this;\n  }\n  /**\n   * Restores the camera state values if it has been stored. You must call storeState() first\n   */\n  _restoreStateValues() {\n    if (!this._stateStored) {\n      return false;\n    }\n    this.fov = this._storedFov;\n    return true;\n  }\n  /**\n   * Restored camera state. You must call storeState() first.\n   * @returns true if restored and false otherwise\n   */\n  restoreState() {\n    if (this._restoreStateValues()) {\n      this.onRestoreStateObservable.notifyObservers(this);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Gets the class name of the camera.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Camera\";\n  }\n  /**\n   * Gets a string representation of the camera useful for debug purpose.\n   * @param fullDetails Defines that a more verbose level of logging is required\n   * @returns the string representation\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    ret += \", type: \" + this.getClassName();\n    if (this.animations) {\n      for (let i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n    return ret;\n  }\n  /**\n   * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.\n   */\n  applyVerticalCorrection() {\n    const rot = this.absoluteRotation.toEulerAngles();\n    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;\n  }\n  /**\n   * Gets the current world space position of the camera.\n   */\n  get globalPosition() {\n    return this._globalPosition;\n  }\n  /**\n   * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)\n   * @returns the active meshe list\n   */\n  getActiveMeshes() {\n    return this._activeMeshes;\n  }\n  /**\n   * Check whether a mesh is part of the current active mesh list of the camera\n   * @param mesh Defines the mesh to check\n   * @returns true if active, false otherwise\n   */\n  isActiveMesh(mesh) {\n    return this._activeMeshes.indexOf(mesh) !== -1;\n  }\n  /**\n   * Is this camera ready to be used/rendered\n   * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)\n   * @returns true if the camera is ready\n   */\n  isReady(completeCheck = false) {\n    if (completeCheck) {\n      for (const pp of this._postProcesses) {\n        if (pp && !pp.isReady()) {\n          return false;\n        }\n      }\n    }\n    return super.isReady(completeCheck);\n  }\n  /** @internal */\n  _initCache() {\n    super._initCache();\n    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.mode = undefined;\n    this._cache.minZ = undefined;\n    this._cache.maxZ = undefined;\n    this._cache.fov = undefined;\n    this._cache.fovMode = undefined;\n    this._cache.aspectRatio = undefined;\n    this._cache.orthoLeft = undefined;\n    this._cache.orthoRight = undefined;\n    this._cache.orthoBottom = undefined;\n    this._cache.orthoTop = undefined;\n    this._cache.renderWidth = undefined;\n    this._cache.renderHeight = undefined;\n  }\n  /**\n   * @internal\n   */\n  _updateCache(ignoreParentClass) {\n    if (!ignoreParentClass) {\n      super._updateCache();\n    }\n    this._cache.position.copyFrom(this.position);\n    this._cache.upVector.copyFrom(this.upVector);\n  }\n  /** @internal */\n  _isSynchronized() {\n    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();\n  }\n  /** @internal */\n  _isSynchronizedViewMatrix() {\n    if (!super._isSynchronized()) {\n      return false;\n    }\n    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();\n  }\n  /** @internal */\n  _isSynchronizedProjectionMatrix() {\n    let check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;\n    if (!check) {\n      return false;\n    }\n    const engine = this.getEngine();\n    if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n      check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;\n    } else {\n      check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();\n    }\n    return check;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * This function is here because typescript removes the typing of the last function.\n   * @param _ignored defines an ignored parameter kept for backward compatibility.\n   * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(_ignored, _noPreventDefault) {}\n  /**\n   * Detach the current controls from the specified dom element.\n   * This function is here because typescript removes the typing of the last function.\n   * @param _ignored defines an ignored parameter kept for backward compatibility.\n   */\n  detachControl(_ignored) {}\n  /**\n   * Update the camera state according to the different inputs gathered during the frame.\n   */\n  update() {\n    this._checkInputs();\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      this._updateRigCameras();\n    }\n  }\n  /** @internal */\n  _checkInputs() {\n    this.onAfterCheckInputsObservable.notifyObservers(this);\n  }\n  /** @internal */\n  get rigCameras() {\n    return this._rigCameras;\n  }\n  /**\n   * Gets the post process used by the rig cameras\n   */\n  get rigPostProcess() {\n    return this._rigPostProcess;\n  }\n  /**\n   * Internal, gets the first post process.\n   * @returns the first post process to be run on this camera.\n   */\n  _getFirstPostProcess() {\n    for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {\n      if (this._postProcesses[ppIndex] !== null) {\n        return this._postProcesses[ppIndex];\n      }\n    }\n    return null;\n  }\n  _cascadePostProcessesToRigCams() {\n    // invalidate framebuffer\n    const firstPostProcess = this._getFirstPostProcess();\n    if (firstPostProcess) {\n      firstPostProcess.markTextureDirty();\n    }\n    // glue the rigPostProcess to the end of the user postprocesses & assign to each sub-camera\n    for (let i = 0, len = this._rigCameras.length; i < len; i++) {\n      const cam = this._rigCameras[i];\n      const rigPostProcess = cam._rigPostProcess;\n      // for VR rig, there does not have to be a post process\n      if (rigPostProcess) {\n        const isPass = rigPostProcess.getEffectName() === \"pass\";\n        if (isPass) {\n          // any rig which has a PassPostProcess for rig[0], cannot be isIntermediate when there are also user postProcesses\n          cam.isIntermediate = this._postProcesses.length === 0;\n        }\n        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);\n        rigPostProcess.markTextureDirty();\n      } else {\n        cam._postProcesses = this._postProcesses.slice(0);\n      }\n    }\n  }\n  /**\n   * Attach a post process to the camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess\n   * @param postProcess The post process to attach to the camera\n   * @param insertAt The position of the post process in case several of them are in use in the scene\n   * @returns the position the post process has been inserted at\n   */\n  attachPostProcess(postProcess, insertAt = null) {\n    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {\n      Logger.Error(\"You're trying to reuse a post process not defined as reusable.\");\n      return 0;\n    }\n    if (insertAt == null || insertAt < 0) {\n      this._postProcesses.push(postProcess);\n    } else if (this._postProcesses[insertAt] === null) {\n      this._postProcesses[insertAt] = postProcess;\n    } else {\n      this._postProcesses.splice(insertAt, 0, postProcess);\n    }\n    this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\n    // Update prePass\n    if (this._scene.prePassRenderer) {\n      this._scene.prePassRenderer.markAsDirty();\n    }\n    return this._postProcesses.indexOf(postProcess);\n  }\n  /**\n   * Detach a post process to the camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess\n   * @param postProcess The post process to detach from the camera\n   */\n  detachPostProcess(postProcess) {\n    const idx = this._postProcesses.indexOf(postProcess);\n    if (idx !== -1) {\n      this._postProcesses[idx] = null;\n    }\n    // Update prePass\n    if (this._scene.prePassRenderer) {\n      this._scene.prePassRenderer.markAsDirty();\n    }\n    this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\n  }\n  /**\n   * Gets the current world matrix of the camera\n   */\n  getWorldMatrix() {\n    if (this._isSynchronizedViewMatrix()) {\n      return this._worldMatrix;\n    }\n    // Getting the the view matrix will also compute the world matrix.\n    this.getViewMatrix();\n    return this._worldMatrix;\n  }\n  /** @internal */\n  _getViewMatrix() {\n    return Matrix.Identity();\n  }\n  /**\n   * Gets the current view matrix of the camera.\n   * @param force forces the camera to recompute the matrix without looking at the cached state\n   * @returns the view matrix\n   */\n  getViewMatrix(force) {\n    if (!force && this._isSynchronizedViewMatrix()) {\n      return this._computedViewMatrix;\n    }\n    this.updateCache();\n    this._computedViewMatrix = this._getViewMatrix();\n    this._currentRenderId = this.getScene().getRenderId();\n    this._childUpdateId++;\n    this._refreshFrustumPlanes = true;\n    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {\n      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);\n    }\n    // Notify parent camera if rig camera is changed\n    if (this.parent && this.parent.onViewMatrixChangedObservable) {\n      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);\n    }\n    this.onViewMatrixChangedObservable.notifyObservers(this);\n    this._computedViewMatrix.invertToRef(this._worldMatrix);\n    return this._computedViewMatrix;\n  }\n  /**\n   * Freeze the projection matrix.\n   * It will prevent the cache check of the camera projection compute and can speed up perf\n   * if no parameter of the camera are meant to change\n   * @param projection Defines manually a projection if necessary\n   */\n  freezeProjectionMatrix(projection) {\n    this._doNotComputeProjectionMatrix = true;\n    if (projection !== undefined) {\n      this._projectionMatrix = projection;\n    }\n  }\n  /**\n   * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.\n   */\n  unfreezeProjectionMatrix() {\n    this._doNotComputeProjectionMatrix = false;\n  }\n  /**\n   * Gets the current projection matrix of the camera.\n   * @param force forces the camera to recompute the matrix without looking at the cached state\n   * @returns the projection matrix\n   */\n  getProjectionMatrix(force) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {\n      return this._projectionMatrix;\n    }\n    // Cache\n    this._cache.mode = this.mode;\n    this._cache.minZ = this.minZ;\n    this._cache.maxZ = this.maxZ;\n    // Matrix\n    this._refreshFrustumPlanes = true;\n    const engine = this.getEngine();\n    const scene = this.getScene();\n    const reverseDepth = engine.useReverseDepthBuffer;\n    if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n      this._cache.fov = this.fov;\n      this._cache.fovMode = this.fovMode;\n      this._cache.aspectRatio = engine.getAspectRatio(this);\n      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;\n      if (this.minZ <= 0) {\n        this.minZ = 0.1;\n      }\n      let getProjectionMatrix;\n      if (scene.useRightHandedSystem) {\n        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;\n      } else {\n        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;\n      }\n      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);\n    } else {\n      const halfWidth = engine.getRenderWidth() / 2.0;\n      const halfHeight = engine.getRenderHeight() / 2.0;\n      if (scene.useRightHandedSystem) {\n        Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);\n      } else {\n        Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);\n      }\n      this._cache.orthoLeft = this.orthoLeft;\n      this._cache.orthoRight = this.orthoRight;\n      this._cache.orthoBottom = this.orthoBottom;\n      this._cache.orthoTop = this.orthoTop;\n      this._cache.renderWidth = engine.getRenderWidth();\n      this._cache.renderHeight = engine.getRenderHeight();\n    }\n    this.onProjectionMatrixChangedObservable.notifyObservers(this);\n    return this._projectionMatrix;\n  }\n  /**\n   * Gets the transformation matrix (ie. the multiplication of view by projection matrices)\n   * @returns a Matrix\n   */\n  getTransformationMatrix() {\n    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n    return this._transformMatrix;\n  }\n  _updateFrustumPlanes() {\n    if (!this._refreshFrustumPlanes) {\n      return;\n    }\n    this.getTransformationMatrix();\n    if (!this._frustumPlanes) {\n      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n    } else {\n      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n    }\n    this._refreshFrustumPlanes = false;\n  }\n  /**\n   * Checks if a cullable object (mesh...) is in the camera frustum\n   * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check\n   * @param target The object to check\n   * @param checkRigCameras If the rig cameras should be checked (eg. with webVR camera both eyes should be checked) (Default: false)\n   * @returns true if the object is in frustum otherwise false\n   */\n  isInFrustum(target, checkRigCameras = false) {\n    this._updateFrustumPlanes();\n    if (checkRigCameras && this.rigCameras.length > 0) {\n      let result = false;\n      this.rigCameras.forEach(cam => {\n        cam._updateFrustumPlanes();\n        result = result || target.isInFrustum(cam._frustumPlanes);\n      });\n      return result;\n    } else {\n      return target.isInFrustum(this._frustumPlanes);\n    }\n  }\n  /**\n   * Checks if a cullable object (mesh...) is in the camera frustum\n   * Unlike isInFrustum this checks the full bounding box\n   * @param target The object to check\n   * @returns true if the object is in frustum otherwise false\n   */\n  isCompletelyInFrustum(target) {\n    this._updateFrustumPlanes();\n    return target.isCompletelyInFrustum(this._frustumPlanes);\n  }\n  /**\n   * Gets a ray in the forward direction from the camera.\n   * @param length Defines the length of the ray to create\n   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\n   * @param origin Defines the start point of the ray which defaults to the camera position\n   * @returns the forward ray\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getForwardRay(length = 100, transform, origin) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Gets a ray in the forward direction from the camera.\n   * @param refRay the ray to (re)use when setting the values\n   * @param length Defines the length of the ray to create\n   * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\n   * @param origin Defines the start point of the ray which defaults to the camera position\n   * @returns the forward ray\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getForwardRayToRef(refRay, length = 100, transform, origin) {\n    throw _WarnImport(\"Ray\");\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    // Observables\n    this.onViewMatrixChangedObservable.clear();\n    this.onProjectionMatrixChangedObservable.clear();\n    this.onAfterCheckInputsObservable.clear();\n    this.onRestoreStateObservable.clear();\n    // Inputs\n    if (this.inputs) {\n      this.inputs.clear();\n    }\n    // Animations\n    this.getScene().stopAnimation(this);\n    // Remove from scene\n    this.getScene().removeCamera(this);\n    while (this._rigCameras.length > 0) {\n      const camera = this._rigCameras.pop();\n      if (camera) {\n        camera.dispose();\n      }\n    }\n    if (this._parentContainer) {\n      const index = this._parentContainer.cameras.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.cameras.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    // Postprocesses\n    if (this._rigPostProcess) {\n      this._rigPostProcess.dispose(this);\n      this._rigPostProcess = null;\n      this._postProcesses.length = 0;\n    } else if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      this._rigPostProcess = null;\n      this._postProcesses.length = 0;\n    } else {\n      let i = this._postProcesses.length;\n      while (--i >= 0) {\n        const postProcess = this._postProcesses[i];\n        if (postProcess) {\n          postProcess.dispose(this);\n        }\n      }\n    }\n    // Render targets\n    let i = this.customRenderTargets.length;\n    while (--i >= 0) {\n      this.customRenderTargets[i].dispose();\n    }\n    this.customRenderTargets.length = 0;\n    // Active Meshes\n    this._activeMeshes.dispose();\n    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   * Gets the left camera of a rig setup in case of Rigged Camera\n   */\n  get isLeftCamera() {\n    return this._isLeftCamera;\n  }\n  /**\n   * Gets the right camera of a rig setup in case of Rigged Camera\n   */\n  get isRightCamera() {\n    return this._isRightCamera;\n  }\n  /**\n   * Gets the left camera of a rig setup in case of Rigged Camera\n   */\n  get leftCamera() {\n    if (this._rigCameras.length < 1) {\n      return null;\n    }\n    return this._rigCameras[0];\n  }\n  /**\n   * Gets the right camera of a rig setup in case of Rigged Camera\n   */\n  get rightCamera() {\n    if (this._rigCameras.length < 2) {\n      return null;\n    }\n    return this._rigCameras[1];\n  }\n  /**\n   * Gets the left camera target of a rig setup in case of Rigged Camera\n   * @returns the target position\n   */\n  getLeftTarget() {\n    if (this._rigCameras.length < 1) {\n      return null;\n    }\n    return this._rigCameras[0].getTarget();\n  }\n  /**\n   * Gets the right camera target of a rig setup in case of Rigged Camera\n   * @returns the target position\n   */\n  getRightTarget() {\n    if (this._rigCameras.length < 2) {\n      return null;\n    }\n    return this._rigCameras[1].getTarget();\n  }\n  /**\n   * @internal\n   */\n  setCameraRigMode(mode, rigParams) {\n    if (this.cameraRigMode === mode) {\n      return;\n    }\n    while (this._rigCameras.length > 0) {\n      const camera = this._rigCameras.pop();\n      if (camera) {\n        camera.dispose();\n      }\n    }\n    this.cameraRigMode = mode;\n    this._cameraRigParams = {};\n    //we have to implement stereo camera calcultating left and right viewpoints from interaxialDistance and target,\n    //not from a given angle as it is now, but until that complete code rewriting provisional stereoHalfAngle value is introduced\n    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;\n    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);\n    // create the rig cameras, unless none\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      const leftCamera = this.createRigCamera(this.name + \"_L\", 0);\n      if (leftCamera) {\n        leftCamera._isLeftCamera = true;\n      }\n      const rightCamera = this.createRigCamera(this.name + \"_R\", 1);\n      if (rightCamera) {\n        rightCamera._isRightCamera = true;\n      }\n      if (leftCamera && rightCamera) {\n        this._rigCameras.push(leftCamera);\n        this._rigCameras.push(rightCamera);\n      }\n    }\n    this._setRigMode(rigParams);\n    this._cascadePostProcessesToRigCams();\n    this.update();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _setRigMode(rigParams) {\n    // no-op\n  }\n  /** @internal */\n  _getVRProjectionMatrix() {\n    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);\n    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);\n    return this._projectionMatrix;\n  }\n  _updateCameraRotationMatrix() {\n    //Here for WebVR\n  }\n  _updateWebVRCameraRotationMatrix() {\n    //Here for WebVR\n  }\n  /**\n   * This function MUST be overwritten by the different WebVR cameras available.\n   * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\n   * @internal\n   */\n  _getWebVRProjectionMatrix() {\n    return Matrix.Identity();\n  }\n  /**\n   * This function MUST be overwritten by the different WebVR cameras available.\n   * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\n   * @internal\n   */\n  _getWebVRViewMatrix() {\n    return Matrix.Identity();\n  }\n  /**\n   * @internal\n   */\n  setCameraRigParameter(name, value) {\n    if (!this._cameraRigParams) {\n      this._cameraRigParams = {};\n    }\n    this._cameraRigParams[name] = value;\n    //provisionnally:\n    if (name === \"interaxialDistance\") {\n      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);\n    }\n  }\n  /**\n   * needs to be overridden by children so sub has required properties to be copied\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createRigCamera(name, cameraIndex) {\n    return null;\n  }\n  /**\n   * May need to be overridden by children\n   * @internal\n   */\n  _updateRigCameras() {\n    for (let i = 0; i < this._rigCameras.length; i++) {\n      this._rigCameras[i].minZ = this.minZ;\n      this._rigCameras[i].maxZ = this.maxZ;\n      this._rigCameras[i].fov = this.fov;\n      this._rigCameras[i].upVector.copyFrom(this.upVector);\n    }\n    // only update viewport when ANAGLYPH\n    if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {\n      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;\n    }\n  }\n  /** @internal */\n  _setupInputs() {}\n  /**\n   * Serialiaze the camera setup to a json representation\n   * @returns the JSON representation\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.uniqueId = this.uniqueId;\n    // Type\n    serializationObject.type = this.getClassName();\n    // Parent\n    if (this.parent) {\n      this.parent._serializeAsParent(serializationObject);\n    }\n    if (this.inputs) {\n      this.inputs.serialize(serializationObject);\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    serializationObject.isEnabled = this.isEnabled();\n    return serializationObject;\n  }\n  /**\n   * Clones the current camera.\n   * @param name The cloned camera name\n   * @param newParent The cloned camera's new parent (none by default)\n   * @returns the cloned camera\n   */\n  clone(name, newParent = null) {\n    const camera = SerializationHelper.Clone(Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);\n    camera.name = name;\n    camera.parent = newParent;\n    this.onClonedObservable.notifyObservers(camera);\n    return camera;\n  }\n  /**\n   * Gets the direction of the camera relative to a given local axis.\n   * @param localAxis Defines the reference axis to provide a relative direction.\n   * @returns the direction\n   */\n  getDirection(localAxis) {\n    const result = Vector3.Zero();\n    this.getDirectionToRef(localAxis, result);\n    return result;\n  }\n  /**\n   * Returns the current camera absolute rotation\n   */\n  get absoluteRotation() {\n    this.getWorldMatrix().decompose(undefined, this._absoluteRotation);\n    return this._absoluteRotation;\n  }\n  /**\n   * Gets the direction of the camera relative to a given local axis into a passed vector.\n   * @param localAxis Defines the reference axis to provide a relative direction.\n   * @param result Defines the vector to store the result in\n   */\n  getDirectionToRef(localAxis, result) {\n    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\n  }\n  /**\n   * Gets a camera constructor for a given camera type\n   * @param type The type of the camera to construct (should be equal to one of the camera class name)\n   * @param name The name of the camera the result will be able to instantiate\n   * @param scene The scene the result will construct the camera in\n   * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes\n   * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side\n   * @returns a factory method to construct the camera\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {\n    const constructorFunc = Node.Construct(type, name, scene, {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      interaxial_distance: interaxial_distance,\n      isStereoscopicSideBySide: isStereoscopicSideBySide\n    });\n    if (constructorFunc) {\n      return constructorFunc;\n    }\n    // Default to universal camera\n    return () => Camera._CreateDefaultParsedCamera(name, scene);\n  }\n  /**\n   * Compute the world  matrix of the camera.\n   * @returns the camera world matrix\n   */\n  computeWorldMatrix() {\n    return this.getWorldMatrix();\n  }\n  /**\n   * Parse a JSON and creates the camera from the parsed information\n   * @param parsedCamera The JSON to parse\n   * @param scene The scene to instantiate the camera in\n   * @returns the newly constructed camera\n   */\n  static Parse(parsedCamera, scene) {\n    const type = parsedCamera.type;\n    const construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);\n    const camera = SerializationHelper.Parse(construct, parsedCamera, scene);\n    // Parent\n    if (parsedCamera.parentId !== undefined) {\n      camera._waitingParentId = parsedCamera.parentId;\n    }\n    // Parent instance index\n    if (parsedCamera.parentInstanceIndex !== undefined) {\n      camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;\n    }\n    //If camera has an input manager, let it parse inputs settings\n    if (camera.inputs) {\n      camera.inputs.parse(parsedCamera);\n      camera._setupInputs();\n    }\n    if (parsedCamera.upVector) {\n      camera.upVector = Vector3.FromArray(parsedCamera.upVector); // need to force the upVector\n    }\n\n    if (camera.setPosition) {\n      // need to force position\n      camera.position.copyFromFloats(0, 0, 0);\n      camera.setPosition(Vector3.FromArray(parsedCamera.position));\n    }\n    // Target\n    if (parsedCamera.target) {\n      if (camera.setTarget) {\n        camera.setTarget(Vector3.FromArray(parsedCamera.target));\n      }\n    }\n    // Apply 3d rig, when found\n    if (parsedCamera.cameraRigMode) {\n      const rigParams = parsedCamera.interaxial_distance ? {\n        interaxialDistance: parsedCamera.interaxial_distance\n      } : {};\n      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);\n    }\n    // Animations\n    if (parsedCamera.animations) {\n      for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {\n        const parsedAnimation = parsedCamera.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          camera.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      Node.ParseAnimationRanges(camera, parsedCamera, scene);\n    }\n    if (parsedCamera.autoAnimate) {\n      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1.0);\n    }\n    // Check if isEnabled is defined to be back compatible with prior serialized versions.\n    if (parsedCamera.isEnabled !== undefined) {\n      camera.setEnabled(parsedCamera.isEnabled);\n    }\n    return camera;\n  }\n}\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nCamera._CreateDefaultParsedCamera = (name, scene) => {\n  throw _WarnImport(\"UniversalCamera\");\n};\n/**\n * This is the default projection mode used by the cameras.\n * It helps recreating a feeling of perspective and better appreciate depth.\n * This is the best way to simulate real life cameras.\n */\nCamera.PERSPECTIVE_CAMERA = 0;\n/**\n * This helps creating camera with an orthographic mode.\n * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.\n */\nCamera.ORTHOGRAPHIC_CAMERA = 1;\n/**\n * This is the default FOV mode for perspective cameras.\n * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.\n */\nCamera.FOVMODE_VERTICAL_FIXED = 0;\n/**\n * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.\n */\nCamera.FOVMODE_HORIZONTAL_FIXED = 1;\n/**\n * This specifies there is no need for a camera rig.\n * Basically only one eye is rendered corresponding to the camera.\n */\nCamera.RIG_MODE_NONE = 0;\n/**\n * Simulates a camera Rig with one blue eye and one red eye.\n * This can be use with 3d blue and red glasses.\n */\nCamera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;\n/**\n * Defines that both eyes of the camera will be rendered side by side with a parallel target.\n */\nCamera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;\n/**\n * Defines that both eyes of the camera will be rendered side by side with a none parallel target.\n */\nCamera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;\n/**\n * Defines that both eyes of the camera will be rendered over under each other.\n */\nCamera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;\n/**\n * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.\n */\nCamera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;\n/**\n * Defines that both eyes of the camera should be renderered in a VR mode (carbox).\n */\nCamera.RIG_MODE_VR = 20;\n/**\n * Defines that both eyes of the camera should be renderered in a VR mode (webVR).\n */\nCamera.RIG_MODE_WEBVR = 21;\n/**\n * Custom rig mode allowing rig cameras to be populated manually with any number of cameras\n */\nCamera.RIG_MODE_CUSTOM = 22;\n/**\n * Defines if by default attaching controls should prevent the default javascript event to continue.\n */\nCamera.ForceAttachControlToAlwaysPreventDefault = false;\n__decorate([serializeAsVector3(\"position\")], Camera.prototype, \"_position\", void 0);\n__decorate([serializeAsVector3(\"upVector\")], Camera.prototype, \"_upVector\", void 0);\n__decorate([serialize()], Camera.prototype, \"orthoLeft\", null);\n__decorate([serialize()], Camera.prototype, \"orthoRight\", null);\n__decorate([serialize()], Camera.prototype, \"orthoBottom\", null);\n__decorate([serialize()], Camera.prototype, \"orthoTop\", null);\n__decorate([serialize()], Camera.prototype, \"fov\", void 0);\n__decorate([serialize()], Camera.prototype, \"projectionPlaneTilt\", void 0);\n__decorate([serialize()], Camera.prototype, \"minZ\", void 0);\n__decorate([serialize()], Camera.prototype, \"maxZ\", void 0);\n__decorate([serialize()], Camera.prototype, \"inertia\", void 0);\n__decorate([serialize()], Camera.prototype, \"mode\", null);\n__decorate([serialize()], Camera.prototype, \"layerMask\", void 0);\n__decorate([serialize()], Camera.prototype, \"fovMode\", void 0);\n__decorate([serialize()], Camera.prototype, \"cameraRigMode\", void 0);\n__decorate([serialize()], Camera.prototype, \"interaxialDistance\", void 0);\n__decorate([serialize()], Camera.prototype, \"isStereoscopicSideBySide\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","serializeAsVector3","SmartArray","Tools","Observable","Matrix","Vector3","Quaternion","Node","Logger","GetClass","_WarnImport","Viewport","Frustum","Camera","constructor","name","position","scene","setActiveOnSceneIfNoneActive","Zero","Up","PERSPECTIVE_CAMERA","FOVMODE_VERTICAL_FIXED","RIG_MODE_NONE","Array","Identity","getScene","addCamera","activeCamera","renderPassId","getEngine","createRenderPassId","_position","newPosition","upVector","vec","_upVector","screenArea","x","y","mode","fovMode","minZ","Math","tan","fov","getAspectRatio","halfWidth","getRenderWidth","halfHeight","getRenderHeight","orthoRight","orthoLeft","orthoTop","orthoBottom","value","_orthoLeft","rigCamera","_rigCameras","_orthoRight","_orthoBottom","_orthoTop","_mode","storeState","_stateStored","_storedFov","_restoreStateValues","restoreState","onRestoreStateObservable","notifyObservers","getClassName","toString","fullDetails","ret","animations","i","length","applyVerticalCorrection","rot","absoluteRotation","toEulerAngles","projectionPlaneTilt","_scene","useRightHandedSystem","globalPosition","_globalPosition","getActiveMeshes","_activeMeshes","isActiveMesh","mesh","indexOf","isReady","completeCheck","pp","_postProcesses","_initCache","_cache","Number","MAX_VALUE","undefined","maxZ","aspectRatio","renderWidth","renderHeight","_updateCache","ignoreParentClass","copyFrom","_isSynchronized","_isSynchronizedViewMatrix","_isSynchronizedProjectionMatrix","equals","isSynchronizedWithParent","check","engine","attachControl","_ignored","_noPreventDefault","detachControl","update","_checkInputs","cameraRigMode","_updateRigCameras","onAfterCheckInputsObservable","rigCameras","rigPostProcess","_rigPostProcess","_getFirstPostProcess","ppIndex","_cascadePostProcessesToRigCams","firstPostProcess","markTextureDirty","len","cam","isPass","getEffectName","isIntermediate","slice","concat","attachPostProcess","postProcess","insertAt","isReusable","Error","push","splice","prePassRenderer","markAsDirty","detachPostProcess","idx","getWorldMatrix","_worldMatrix","getViewMatrix","_getViewMatrix","force","_computedViewMatrix","updateCache","_currentRenderId","getRenderId","_childUpdateId","_refreshFrustumPlanes","_cameraRigParams","vrPreViewMatrix","multiplyToRef","parent","onViewMatrixChangedObservable","invertToRef","freezeProjectionMatrix","projection","_doNotComputeProjectionMatrix","_projectionMatrix","unfreezeProjectionMatrix","getProjectionMatrix","reverseDepth","useReverseDepthBuffer","PerspectiveFovRHToRef","PerspectiveFovLHToRef","isNDCHalfZRange","OrthoOffCenterRHToRef","OrthoOffCenterLHToRef","onProjectionMatrixChangedObservable","getTransformationMatrix","_transformMatrix","_updateFrustumPlanes","_frustumPlanes","GetPlanes","GetPlanesToRef","isInFrustum","target","checkRigCameras","result","forEach","isCompletelyInFrustum","getForwardRay","transform","origin","getForwardRayToRef","refRay","dispose","doNotRecurse","disposeMaterialAndTextures","clear","inputs","stopAnimation","removeCamera","camera","pop","_parentContainer","index","cameras","customRenderTargets","releaseRenderPassId","isLeftCamera","_isLeftCamera","isRightCamera","_isRightCamera","leftCamera","rightCamera","getLeftTarget","getTarget","getRightTarget","setCameraRigMode","rigParams","interaxialDistance","stereoHalfAngle","ToRadians","createRigCamera","_setRigMode","_getVRProjectionMatrix","vrMetrics","aspectRatioFov","vrWorkMatrix","vrHMatrix","_updateCameraRotationMatrix","_updateWebVRCameraRotationMatrix","_getWebVRProjectionMatrix","_getWebVRViewMatrix","setCameraRigParameter","cameraIndex","RIG_MODE_STEREOSCOPIC_ANAGLYPH","viewport","_setupInputs","serializationObject","Serialize","uniqueId","type","_serializeAsParent","AppendSerializedAnimations","ranges","serializeAnimationRanges","isEnabled","clone","newParent","Clone","GetConstructorFromName","isStereoscopicSideBySide","onClonedObservable","getDirection","localAxis","getDirectionToRef","decompose","_absoluteRotation","TransformNormalToRef","interaxial_distance","constructorFunc","Construct","_CreateDefaultParsedCamera","computeWorldMatrix","Parse","parsedCamera","construct","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","parse","FromArray","setPosition","copyFromFloats","setTarget","animationIndex","parsedAnimation","internalClass","ParseAnimationRanges","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","setEnabled","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Cameras/camera.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ICullable } from \"../Culling/boundingInfo\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { Frustum } from \"../Maths/math.frustum\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare type PostProcess = import(\"../PostProcesses/postProcess\").PostProcess;\r\ndeclare type RenderTargetTexture = import(\"../Materials/Textures/renderTargetTexture\").RenderTargetTexture;\r\ndeclare type FreeCamera = import(\"./freeCamera\").FreeCamera;\r\ndeclare type TargetCamera = import(\"./targetCamera\").TargetCamera;\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n/**\r\n * This is the base class of all the camera used in the application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class Camera extends Node {\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateDefaultParsedCamera = (name: string, scene: Scene): Camera => {\r\n        throw _WarnImport(\"UniversalCamera\");\r\n    };\r\n\r\n    /**\r\n     * This is the default projection mode used by the cameras.\r\n     * It helps recreating a feeling of perspective and better appreciate depth.\r\n     * This is the best way to simulate real life cameras.\r\n     */\r\n    public static readonly PERSPECTIVE_CAMERA = Constants.PERSPECTIVE_CAMERA;\r\n    /**\r\n     * This helps creating camera with an orthographic mode.\r\n     * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.\r\n     */\r\n    public static readonly ORTHOGRAPHIC_CAMERA = Constants.ORTHOGRAPHIC_CAMERA;\r\n\r\n    /**\r\n     * This is the default FOV mode for perspective cameras.\r\n     * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.\r\n     */\r\n    public static readonly FOVMODE_VERTICAL_FIXED = Constants.FOVMODE_VERTICAL_FIXED;\r\n    /**\r\n     * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.\r\n     */\r\n    public static readonly FOVMODE_HORIZONTAL_FIXED = Constants.FOVMODE_HORIZONTAL_FIXED;\r\n\r\n    /**\r\n     * This specifies there is no need for a camera rig.\r\n     * Basically only one eye is rendered corresponding to the camera.\r\n     */\r\n    public static readonly RIG_MODE_NONE = Constants.RIG_MODE_NONE;\r\n    /**\r\n     * Simulates a camera Rig with one blue eye and one red eye.\r\n     * This can be use with 3d blue and red glasses.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_ANAGLYPH = Constants.RIG_MODE_STEREOSCOPIC_ANAGLYPH;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered side by side with a parallel target.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered side by side with a none parallel target.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered over under each other.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_OVERUNDER = Constants.RIG_MODE_STEREOSCOPIC_OVERUNDER;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_INTERLACED = Constants.RIG_MODE_STEREOSCOPIC_INTERLACED;\r\n    /**\r\n     * Defines that both eyes of the camera should be renderered in a VR mode (carbox).\r\n     */\r\n    public static readonly RIG_MODE_VR = Constants.RIG_MODE_VR;\r\n    /**\r\n     * Defines that both eyes of the camera should be renderered in a VR mode (webVR).\r\n     */\r\n    public static readonly RIG_MODE_WEBVR = Constants.RIG_MODE_WEBVR;\r\n    /**\r\n     * Custom rig mode allowing rig cameras to be populated manually with any number of cameras\r\n     */\r\n    public static readonly RIG_MODE_CUSTOM = Constants.RIG_MODE_CUSTOM;\r\n\r\n    /**\r\n     * Defines if by default attaching controls should prevent the default javascript event to continue.\r\n     */\r\n    public static ForceAttachControlToAlwaysPreventDefault = false;\r\n\r\n    /**\r\n     * Define the input manager associated with the camera.\r\n     */\r\n    public inputs: CameraInputsManager<Camera>;\r\n\r\n    /** @internal */\r\n    @serializeAsVector3(\"position\")\r\n    public _position = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current local position of the camera in the scene\r\n     */\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._position = newPosition;\r\n    }\r\n\r\n    @serializeAsVector3(\"upVector\")\r\n    protected _upVector = Vector3.Up();\r\n\r\n    /**\r\n     * The vector the camera should consider as up.\r\n     * (default is Vector3(0, 1, 0) aka Vector3.Up())\r\n     */\r\n    public set upVector(vec: Vector3) {\r\n        this._upVector = vec;\r\n    }\r\n\r\n    public get upVector() {\r\n        return this._upVector;\r\n    }\r\n\r\n    /**\r\n     * The screen area in scene units squared\r\n     */\r\n    public get screenArea(): number {\r\n        let x = 0;\r\n        let y = 0;\r\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\r\n            if (this.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {\r\n                y = this.minZ * 2 * Math.tan(this.fov / 2);\r\n                x = this.getEngine().getAspectRatio(this) * y;\r\n            } else {\r\n                x = this.minZ * 2 * Math.tan(this.fov / 2);\r\n                y = x / this.getEngine().getAspectRatio(this);\r\n            }\r\n        } else {\r\n            const halfWidth = this.getEngine().getRenderWidth() / 2.0;\r\n            const halfHeight = this.getEngine().getRenderHeight() / 2.0;\r\n\r\n            x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);\r\n            y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);\r\n        }\r\n\r\n        return x * y;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the left side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoLeft: Nullable<number> = null;\r\n\r\n    public set orthoLeft(value: Nullable<number>) {\r\n        this._orthoLeft = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoLeft = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoLeft(): Nullable<number> {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the right side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoRight: Nullable<number> = null;\r\n\r\n    public set orthoRight(value: Nullable<number>) {\r\n        this._orthoRight = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoRight = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoRight(): Nullable<number> {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the bottom side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoBottom: Nullable<number> = null;\r\n\r\n    public set orthoBottom(value: Nullable<number>) {\r\n        this._orthoBottom = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoBottom = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoBottom(): Nullable<number> {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    /**\r\n     * Define the current limit on the top side for an orthographic camera\r\n     * In scene unit\r\n     */\r\n    private _orthoTop: Nullable<number> = null;\r\n\r\n    public set orthoTop(value: Nullable<number>) {\r\n        this._orthoTop = value;\r\n\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.orthoTop = value;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get orthoTop(): Nullable<number> {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    /**\r\n     * Field Of View is set in Radians. (default is 0.8)\r\n     */\r\n    @serialize()\r\n    public fov = 0.8;\r\n\r\n    /**\r\n     * Projection plane tilt around the X axis (horizontal), set in Radians. (default is 0)\r\n     * Can be used to make vertical lines in world space actually vertical on the screen.\r\n     * See https://forum.babylonjs.com/t/add-vertical-shift-to-3ds-max-exporter-babylon-cameras/17480\r\n     */\r\n    @serialize()\r\n    public projectionPlaneTilt = 0;\r\n\r\n    /**\r\n     * Define the minimum distance the camera can see from.\r\n     * This is important to note that the depth buffer are not infinite and the closer it starts\r\n     * the more your scene might encounter depth fighting issue.\r\n     */\r\n    @serialize()\r\n    public minZ = 1;\r\n\r\n    /**\r\n     * Define the maximum distance the camera can see to.\r\n     * This is important to note that the depth buffer are not infinite and the further it end\r\n     * the more your scene might encounter depth fighting issue.\r\n     */\r\n    @serialize()\r\n    public maxZ = 10000.0;\r\n\r\n    /**\r\n     * Define the default inertia of the camera.\r\n     * This helps giving a smooth feeling to the camera movement.\r\n     */\r\n    @serialize()\r\n    public inertia = 0.9;\r\n\r\n    /**\r\n     * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)\r\n     */\r\n    private _mode = Camera.PERSPECTIVE_CAMERA;\r\n    set mode(mode: number) {\r\n        this._mode = mode;\r\n\r\n        // Pass the mode down to the rig cameras\r\n        for (const rigCamera of this._rigCameras) {\r\n            rigCamera.mode = mode;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Define whether the camera is intermediate.\r\n     * This is useful to not present the output directly to the screen in case of rig without post process for instance\r\n     */\r\n    public isIntermediate = false;\r\n\r\n    /**\r\n     * Define the viewport of the camera.\r\n     * This correspond to the portion of the screen the camera will render to in normalized 0 to 1 unit.\r\n     */\r\n    public viewport = new Viewport(0, 0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0\r\n     */\r\n    @serialize()\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)\r\n     */\r\n    @serialize()\r\n    public fovMode: number = Camera.FOVMODE_VERTICAL_FIXED;\r\n\r\n    /**\r\n     * Rig mode of the camera.\r\n     * This is useful to create the camera with two \"eyes\" instead of one to create VR or stereoscopic scenes.\r\n     * This is normally controlled byt the camera themselves as internal use.\r\n     */\r\n    @serialize()\r\n    public cameraRigMode = Camera.RIG_MODE_NONE;\r\n\r\n    /**\r\n     * Defines the distance between both \"eyes\" in case of a RIG\r\n     */\r\n    @serialize()\r\n    public interaxialDistance: number;\r\n\r\n    /**\r\n     * Defines if stereoscopic rendering is done side by side or over under.\r\n     */\r\n    @serialize()\r\n    public isStereoscopicSideBySide: boolean;\r\n\r\n    /**\r\n     * Defines the list of custom render target which are rendered to and then used as the input to this camera's render. Eg. display another camera view on a TV in the main scene\r\n     * This is pretty helpful if you wish to make a camera render to a texture you could reuse somewhere\r\n     * else in the scene. (Eg. security camera)\r\n     *\r\n     * To change the final output target of the camera, camera.outputRenderTarget should be used instead (eg. webXR renders to a render target corresponding to an HMD)\r\n     */\r\n    public customRenderTargets = new Array<RenderTargetTexture>();\r\n    /**\r\n     * When set, the camera will render to this render target instead of the default canvas\r\n     *\r\n     * If the desire is to use the output of a camera as a texture in the scene consider using camera.customRenderTargets instead\r\n     */\r\n    public outputRenderTarget: Nullable<RenderTargetTexture> = null;\r\n\r\n    /**\r\n     * Observable triggered when the camera view matrix has changed.\r\n     */\r\n    public onViewMatrixChangedObservable = new Observable<Camera>();\r\n    /**\r\n     * Observable triggered when the camera Projection matrix has changed.\r\n     */\r\n    public onProjectionMatrixChangedObservable = new Observable<Camera>();\r\n    /**\r\n     * Observable triggered when the inputs have been processed.\r\n     */\r\n    public onAfterCheckInputsObservable = new Observable<Camera>();\r\n    /**\r\n     * Observable triggered when reset has been called and applied to the camera.\r\n     */\r\n    public onRestoreStateObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * Is this camera a part of a rig system?\r\n     */\r\n    public isRigCamera: boolean = false;\r\n\r\n    /**\r\n     * If isRigCamera set to true this will be set with the parent camera.\r\n     * The parent camera is not (!) necessarily the .parent of this camera (like in the case of XR)\r\n     */\r\n    public rigParent?: Camera;\r\n\r\n    /**\r\n     * Render pass id used by the camera to render into the main framebuffer\r\n     */\r\n    public renderPassId: number;\r\n\r\n    /** @internal */\r\n    public _cameraRigParams: any;\r\n    /** @internal */\r\n    public _rigCameras = new Array<Camera>();\r\n    /** @internal */\r\n    public _rigPostProcess: Nullable<PostProcess>;\r\n\r\n    protected _webvrViewMatrix = Matrix.Identity();\r\n    /** @internal */\r\n    public _skipRendering = false;\r\n\r\n    /** @internal */\r\n    public _projectionMatrix = new Matrix();\r\n\r\n    /** @internal */\r\n    public _postProcesses = new Array<Nullable<PostProcess>>();\r\n\r\n    /** @internal */\r\n    public _activeMeshes = new SmartArray<AbstractMesh>(256);\r\n\r\n    protected _globalPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _computedViewMatrix = Matrix.Identity();\r\n    private _doNotComputeProjectionMatrix = false;\r\n    private _transformMatrix = Matrix.Zero();\r\n    private _frustumPlanes: Plane[];\r\n    private _refreshFrustumPlanes = true;\r\n    private _storedFov: number;\r\n    private _stateStored: boolean;\r\n    private _absoluteRotation: Quaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * Instantiates a new camera object.\r\n     * This should not be used directly but through the inherited cameras: ArcRotate, Free...\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the position of the camera\r\n     * @param scene Defines the scene the camera belongs too\r\n     * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, scene);\r\n\r\n        this.getScene().addCamera(this);\r\n\r\n        if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {\r\n            this.getScene().activeCamera = this;\r\n        }\r\n\r\n        this.position = position;\r\n        this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);\r\n    }\r\n\r\n    /**\r\n     * Store current camera state (fov, position, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._stateStored = true;\r\n        this._storedFov = this.fov;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restores the camera state values if it has been stored. You must call storeState() first\r\n     */\r\n    protected _restoreStateValues(): boolean {\r\n        if (!this._stateStored) {\r\n            return false;\r\n        }\r\n\r\n        this.fov = this._storedFov;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first.\r\n     * @returns true if restored and false otherwise\r\n     */\r\n    public restoreState(): boolean {\r\n        if (this._restoreStateValues()) {\r\n            this.onRestoreStateObservable.notifyObservers(this);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the camera.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Camera\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isCamera = true;\r\n\r\n    /**\r\n     * Gets a string representation of the camera useful for debug purpose.\r\n     * @param fullDetails Defines that a more verbose level of logging is required\r\n     * @returns the string representation\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.\r\n     */\r\n    public applyVerticalCorrection() {\r\n        const rot = this.absoluteRotation.toEulerAngles();\r\n\r\n        this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;\r\n    }\r\n\r\n    /**\r\n     * Gets the current world space position of the camera.\r\n     */\r\n    public get globalPosition(): Vector3 {\r\n        return this._globalPosition;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)\r\n     * @returns the active meshe list\r\n     */\r\n    public getActiveMeshes(): SmartArray<AbstractMesh> {\r\n        return this._activeMeshes;\r\n    }\r\n\r\n    /**\r\n     * Check whether a mesh is part of the current active mesh list of the camera\r\n     * @param mesh Defines the mesh to check\r\n     * @returns true if active, false otherwise\r\n     */\r\n    public isActiveMesh(mesh: Mesh): boolean {\r\n        return this._activeMeshes.indexOf(mesh) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Is this camera ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)\r\n     * @returns true if the camera is ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        if (completeCheck) {\r\n            for (const pp of this._postProcesses) {\r\n                if (pp && !pp.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return super.isReady(completeCheck);\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n\r\n        this._cache.mode = undefined;\r\n        this._cache.minZ = undefined;\r\n        this._cache.maxZ = undefined;\r\n\r\n        this._cache.fov = undefined;\r\n        this._cache.fovMode = undefined;\r\n        this._cache.aspectRatio = undefined;\r\n\r\n        this._cache.orthoLeft = undefined;\r\n        this._cache.orthoRight = undefined;\r\n        this._cache.orthoBottom = undefined;\r\n        this._cache.orthoTop = undefined;\r\n        this._cache.renderWidth = undefined;\r\n        this._cache.renderHeight = undefined;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        this._cache.position.copyFrom(this.position);\r\n        this._cache.upVector.copyFrom(this.upVector);\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronized(): boolean {\r\n        return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronized()) {\r\n            return false;\r\n        }\r\n\r\n        return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronizedProjectionMatrix(): boolean {\r\n        let check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;\r\n\r\n        if (!check) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this.getEngine();\r\n\r\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\r\n            check =\r\n                this._cache.fov === this.fov &&\r\n                this._cache.fovMode === this.fovMode &&\r\n                this._cache.aspectRatio === engine.getAspectRatio(this) &&\r\n                this._cache.projectionPlaneTilt === this.projectionPlaneTilt;\r\n        } else {\r\n            check =\r\n                this._cache.orthoLeft === this.orthoLeft &&\r\n                this._cache.orthoRight === this.orthoRight &&\r\n                this._cache.orthoBottom === this.orthoBottom &&\r\n                this._cache.orthoTop === this.orthoTop &&\r\n                this._cache.renderWidth === engine.getRenderWidth() &&\r\n                this._cache.renderHeight === engine.getRenderHeight();\r\n        }\r\n\r\n        return check;\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * This function is here because typescript removes the typing of the last function.\r\n     * @param _ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(_ignored?: any, _noPreventDefault?: boolean): void {}\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     */\r\n    public detachControl(ignored?: any): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     * This function is here because typescript removes the typing of the last function.\r\n     * @param _ignored defines an ignored parameter kept for backward compatibility.\r\n     */\r\n    public detachControl(_ignored?: any): void {}\r\n\r\n    /**\r\n     * Update the camera state according to the different inputs gathered during the frame.\r\n     */\r\n    public update(): void {\r\n        this._checkInputs();\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            this._updateRigCameras();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        this.onAfterCheckInputsObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** @internal */\r\n    public get rigCameras(): Camera[] {\r\n        return this._rigCameras;\r\n    }\r\n\r\n    /**\r\n     * Gets the post process used by the rig cameras\r\n     */\r\n    public get rigPostProcess(): Nullable<PostProcess> {\r\n        return this._rigPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Internal, gets the first post process.\r\n     * @returns the first post process to be run on this camera.\r\n     */\r\n    public _getFirstPostProcess(): Nullable<PostProcess> {\r\n        for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {\r\n            if (this._postProcesses[ppIndex] !== null) {\r\n                return this._postProcesses[ppIndex];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _cascadePostProcessesToRigCams(): void {\r\n        // invalidate framebuffer\r\n        const firstPostProcess = this._getFirstPostProcess();\r\n        if (firstPostProcess) {\r\n            firstPostProcess.markTextureDirty();\r\n        }\r\n\r\n        // glue the rigPostProcess to the end of the user postprocesses & assign to each sub-camera\r\n        for (let i = 0, len = this._rigCameras.length; i < len; i++) {\r\n            const cam = this._rigCameras[i];\r\n            const rigPostProcess = cam._rigPostProcess;\r\n\r\n            // for VR rig, there does not have to be a post process\r\n            if (rigPostProcess) {\r\n                const isPass = rigPostProcess.getEffectName() === \"pass\";\r\n                if (isPass) {\r\n                    // any rig which has a PassPostProcess for rig[0], cannot be isIntermediate when there are also user postProcesses\r\n                    cam.isIntermediate = this._postProcesses.length === 0;\r\n                }\r\n                cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);\r\n                rigPostProcess.markTextureDirty();\r\n            } else {\r\n                cam._postProcesses = this._postProcesses.slice(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach a post process to the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess\r\n     * @param postProcess The post process to attach to the camera\r\n     * @param insertAt The position of the post process in case several of them are in use in the scene\r\n     * @returns the position the post process has been inserted at\r\n     */\r\n    public attachPostProcess(postProcess: PostProcess, insertAt: Nullable<number> = null): number {\r\n        if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {\r\n            Logger.Error(\"You're trying to reuse a post process not defined as reusable.\");\r\n            return 0;\r\n        }\r\n\r\n        if (insertAt == null || insertAt < 0) {\r\n            this._postProcesses.push(postProcess);\r\n        } else if (this._postProcesses[insertAt] === null) {\r\n            this._postProcesses[insertAt] = postProcess;\r\n        } else {\r\n            this._postProcesses.splice(insertAt, 0, postProcess);\r\n        }\r\n        this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\r\n\r\n        // Update prePass\r\n        if (this._scene.prePassRenderer) {\r\n            this._scene.prePassRenderer.markAsDirty();\r\n        }\r\n\r\n        return this._postProcesses.indexOf(postProcess);\r\n    }\r\n\r\n    /**\r\n     * Detach a post process to the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess\r\n     * @param postProcess The post process to detach from the camera\r\n     */\r\n    public detachPostProcess(postProcess: PostProcess): void {\r\n        const idx = this._postProcesses.indexOf(postProcess);\r\n        if (idx !== -1) {\r\n            this._postProcesses[idx] = null;\r\n        }\r\n\r\n        // Update prePass\r\n        if (this._scene.prePassRenderer) {\r\n            this._scene.prePassRenderer.markAsDirty();\r\n        }\r\n\r\n        this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\r\n    }\r\n\r\n    /**\r\n     * Gets the current world matrix of the camera\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._isSynchronizedViewMatrix()) {\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        // Getting the the view matrix will also compute the world matrix.\r\n        this.getViewMatrix();\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    /**\r\n     * Gets the current view matrix of the camera.\r\n     * @param force forces the camera to recompute the matrix without looking at the cached state\r\n     * @returns the view matrix\r\n     */\r\n    public getViewMatrix(force?: boolean): Matrix {\r\n        if (!force && this._isSynchronizedViewMatrix()) {\r\n            return this._computedViewMatrix;\r\n        }\r\n\r\n        this.updateCache();\r\n        this._computedViewMatrix = this._getViewMatrix();\r\n        this._currentRenderId = this.getScene().getRenderId();\r\n        this._childUpdateId++;\r\n\r\n        this._refreshFrustumPlanes = true;\r\n\r\n        if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {\r\n            this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);\r\n        }\r\n\r\n        // Notify parent camera if rig camera is changed\r\n        if (this.parent && (this.parent as Camera).onViewMatrixChangedObservable) {\r\n            (this.parent as Camera).onViewMatrixChangedObservable.notifyObservers(this.parent as Camera);\r\n        }\r\n\r\n        this.onViewMatrixChangedObservable.notifyObservers(this);\r\n\r\n        this._computedViewMatrix.invertToRef(this._worldMatrix);\r\n\r\n        return this._computedViewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Freeze the projection matrix.\r\n     * It will prevent the cache check of the camera projection compute and can speed up perf\r\n     * if no parameter of the camera are meant to change\r\n     * @param projection Defines manually a projection if necessary\r\n     */\r\n    public freezeProjectionMatrix(projection?: Matrix): void {\r\n        this._doNotComputeProjectionMatrix = true;\r\n        if (projection !== undefined) {\r\n            this._projectionMatrix = projection;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.\r\n     */\r\n    public unfreezeProjectionMatrix(): void {\r\n        this._doNotComputeProjectionMatrix = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current projection matrix of the camera.\r\n     * @param force forces the camera to recompute the matrix without looking at the cached state\r\n     * @returns the projection matrix\r\n     */\r\n    public getProjectionMatrix(force?: boolean): Matrix {\r\n        if (this._doNotComputeProjectionMatrix || (!force && this._isSynchronizedProjectionMatrix())) {\r\n            return this._projectionMatrix;\r\n        }\r\n\r\n        // Cache\r\n        this._cache.mode = this.mode;\r\n        this._cache.minZ = this.minZ;\r\n        this._cache.maxZ = this.maxZ;\r\n\r\n        // Matrix\r\n        this._refreshFrustumPlanes = true;\r\n\r\n        const engine = this.getEngine();\r\n        const scene = this.getScene();\r\n        const reverseDepth = engine.useReverseDepthBuffer;\r\n        if (this.mode === Camera.PERSPECTIVE_CAMERA) {\r\n            this._cache.fov = this.fov;\r\n            this._cache.fovMode = this.fovMode;\r\n            this._cache.aspectRatio = engine.getAspectRatio(this);\r\n            this._cache.projectionPlaneTilt = this.projectionPlaneTilt;\r\n\r\n            if (this.minZ <= 0) {\r\n                this.minZ = 0.1;\r\n            }\r\n\r\n            let getProjectionMatrix: (\r\n                fov: number,\r\n                aspect: number,\r\n                znear: number,\r\n                zfar: number,\r\n                result: Matrix,\r\n                isVerticalFovFixed: boolean,\r\n                halfZRange: boolean,\r\n                projectionPlaneTilt: number,\r\n                reverseDepthBufferMode: boolean\r\n            ) => void;\r\n            if (scene.useRightHandedSystem) {\r\n                getProjectionMatrix = Matrix.PerspectiveFovRHToRef;\r\n            } else {\r\n                getProjectionMatrix = Matrix.PerspectiveFovLHToRef;\r\n            }\r\n\r\n            getProjectionMatrix(\r\n                this.fov,\r\n                engine.getAspectRatio(this),\r\n                reverseDepth ? this.maxZ : this.minZ,\r\n                reverseDepth ? this.minZ : this.maxZ,\r\n                this._projectionMatrix,\r\n                this.fovMode === Camera.FOVMODE_VERTICAL_FIXED,\r\n                engine.isNDCHalfZRange,\r\n                this.projectionPlaneTilt,\r\n                reverseDepth\r\n            );\r\n        } else {\r\n            const halfWidth = engine.getRenderWidth() / 2.0;\r\n            const halfHeight = engine.getRenderHeight() / 2.0;\r\n            if (scene.useRightHandedSystem) {\r\n                Matrix.OrthoOffCenterRHToRef(\r\n                    this.orthoLeft ?? -halfWidth,\r\n                    this.orthoRight ?? halfWidth,\r\n                    this.orthoBottom ?? -halfHeight,\r\n                    this.orthoTop ?? halfHeight,\r\n                    reverseDepth ? this.maxZ : this.minZ,\r\n                    reverseDepth ? this.minZ : this.maxZ,\r\n                    this._projectionMatrix,\r\n                    engine.isNDCHalfZRange\r\n                );\r\n            } else {\r\n                Matrix.OrthoOffCenterLHToRef(\r\n                    this.orthoLeft ?? -halfWidth,\r\n                    this.orthoRight ?? halfWidth,\r\n                    this.orthoBottom ?? -halfHeight,\r\n                    this.orthoTop ?? halfHeight,\r\n                    reverseDepth ? this.maxZ : this.minZ,\r\n                    reverseDepth ? this.minZ : this.maxZ,\r\n                    this._projectionMatrix,\r\n                    engine.isNDCHalfZRange\r\n                );\r\n            }\r\n\r\n            this._cache.orthoLeft = this.orthoLeft;\r\n            this._cache.orthoRight = this.orthoRight;\r\n            this._cache.orthoBottom = this.orthoBottom;\r\n            this._cache.orthoTop = this.orthoTop;\r\n            this._cache.renderWidth = engine.getRenderWidth();\r\n            this._cache.renderHeight = engine.getRenderHeight();\r\n        }\r\n\r\n        this.onProjectionMatrixChangedObservable.notifyObservers(this);\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix (ie. the multiplication of view by projection matrices)\r\n     * @returns a Matrix\r\n     */\r\n    public getTransformationMatrix(): Matrix {\r\n        this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\r\n        return this._transformMatrix;\r\n    }\r\n\r\n    private _updateFrustumPlanes(): void {\r\n        if (!this._refreshFrustumPlanes) {\r\n            return;\r\n        }\r\n\r\n        this.getTransformationMatrix();\r\n\r\n        if (!this._frustumPlanes) {\r\n            this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\r\n        } else {\r\n            Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\r\n        }\r\n\r\n        this._refreshFrustumPlanes = false;\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check\r\n     * @param target The object to check\r\n     * @param checkRigCameras If the rig cameras should be checked (eg. with webVR camera both eyes should be checked) (Default: false)\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isInFrustum(target: ICullable, checkRigCameras = false): boolean {\r\n        this._updateFrustumPlanes();\r\n\r\n        if (checkRigCameras && this.rigCameras.length > 0) {\r\n            let result = false;\r\n            this.rigCameras.forEach((cam) => {\r\n                cam._updateFrustumPlanes();\r\n                result = result || target.isInFrustum(cam._frustumPlanes);\r\n            });\r\n            return result;\r\n        } else {\r\n            return target.isInFrustum(this._frustumPlanes);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param target The object to check\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(target: ICullable): boolean {\r\n        this._updateFrustumPlanes();\r\n\r\n        return target.isCompletelyInFrustum(this._frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets a ray in the forward direction from the camera.\r\n     * @param length Defines the length of the ray to create\r\n     * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\r\n     * @param origin Defines the start point of the ray which defaults to the camera position\r\n     * @returns the forward ray\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getForwardRay(length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Gets a ray in the forward direction from the camera.\r\n     * @param refRay the ray to (re)use when setting the values\r\n     * @param length Defines the length of the ray to create\r\n     * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\r\n     * @param origin Defines the start point of the ray which defaults to the camera position\r\n     * @returns the forward ray\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getForwardRayToRef(refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n        throw _WarnImport(\"Ray\");\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Observables\r\n        this.onViewMatrixChangedObservable.clear();\r\n        this.onProjectionMatrixChangedObservable.clear();\r\n        this.onAfterCheckInputsObservable.clear();\r\n        this.onRestoreStateObservable.clear();\r\n\r\n        // Inputs\r\n        if (this.inputs) {\r\n            this.inputs.clear();\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeCamera(this);\r\n        while (this._rigCameras.length > 0) {\r\n            const camera = this._rigCameras.pop();\r\n            if (camera) {\r\n                camera.dispose();\r\n            }\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.cameras.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.cameras.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Postprocesses\r\n        if (this._rigPostProcess) {\r\n            this._rigPostProcess.dispose(this);\r\n            this._rigPostProcess = null;\r\n            this._postProcesses.length = 0;\r\n        } else if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            this._rigPostProcess = null;\r\n            this._postProcesses.length = 0;\r\n        } else {\r\n            let i = this._postProcesses.length;\r\n            while (--i >= 0) {\r\n                const postProcess = this._postProcesses[i];\r\n                if (postProcess) {\r\n                    postProcess.dispose(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Render targets\r\n        let i = this.customRenderTargets.length;\r\n        while (--i >= 0) {\r\n            this.customRenderTargets[i].dispose();\r\n        }\r\n        this.customRenderTargets.length = 0;\r\n\r\n        // Active Meshes\r\n        this._activeMeshes.dispose();\r\n\r\n        this.getScene().getEngine().releaseRenderPassId(this.renderPassId);\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /** @internal */\r\n    public _isLeftCamera = false;\r\n    /**\r\n     * Gets the left camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get isLeftCamera(): boolean {\r\n        return this._isLeftCamera;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isRightCamera = false;\r\n    /**\r\n     * Gets the right camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get isRightCamera(): boolean {\r\n        return this._isRightCamera;\r\n    }\r\n\r\n    /**\r\n     * Gets the left camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get leftCamera(): Nullable<FreeCamera> {\r\n        if (this._rigCameras.length < 1) {\r\n            return null;\r\n        }\r\n        return <FreeCamera>this._rigCameras[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the right camera of a rig setup in case of Rigged Camera\r\n     */\r\n    public get rightCamera(): Nullable<FreeCamera> {\r\n        if (this._rigCameras.length < 2) {\r\n            return null;\r\n        }\r\n        return <FreeCamera>this._rigCameras[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the left camera target of a rig setup in case of Rigged Camera\r\n     * @returns the target position\r\n     */\r\n    public getLeftTarget(): Nullable<Vector3> {\r\n        if (this._rigCameras.length < 1) {\r\n            return null;\r\n        }\r\n        return (<TargetCamera>this._rigCameras[0]).getTarget();\r\n    }\r\n\r\n    /**\r\n     * Gets the right camera target of a rig setup in case of Rigged Camera\r\n     * @returns the target position\r\n     */\r\n    public getRightTarget(): Nullable<Vector3> {\r\n        if (this._rigCameras.length < 2) {\r\n            return null;\r\n        }\r\n        return (<TargetCamera>this._rigCameras[1]).getTarget();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setCameraRigMode(mode: number, rigParams: any): void {\r\n        if (this.cameraRigMode === mode) {\r\n            return;\r\n        }\r\n\r\n        while (this._rigCameras.length > 0) {\r\n            const camera = this._rigCameras.pop();\r\n\r\n            if (camera) {\r\n                camera.dispose();\r\n            }\r\n        }\r\n        this.cameraRigMode = mode;\r\n        this._cameraRigParams = {};\r\n        //we have to implement stereo camera calcultating left and right viewpoints from interaxialDistance and target,\r\n        //not from a given angle as it is now, but until that complete code rewriting provisional stereoHalfAngle value is introduced\r\n        this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;\r\n        this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);\r\n\r\n        // create the rig cameras, unless none\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const leftCamera = this.createRigCamera(this.name + \"_L\", 0);\r\n            if (leftCamera) {\r\n                leftCamera._isLeftCamera = true;\r\n            }\r\n            const rightCamera = this.createRigCamera(this.name + \"_R\", 1);\r\n            if (rightCamera) {\r\n                rightCamera._isRightCamera = true;\r\n            }\r\n            if (leftCamera && rightCamera) {\r\n                this._rigCameras.push(leftCamera);\r\n                this._rigCameras.push(rightCamera);\r\n            }\r\n        }\r\n\r\n        this._setRigMode(rigParams);\r\n\r\n        this._cascadePostProcessesToRigCams();\r\n        this.update();\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setRigMode(rigParams: any) {\r\n        // no-op\r\n    }\r\n\r\n    /** @internal */\r\n    public _getVRProjectionMatrix(): Matrix {\r\n        Matrix.PerspectiveFovLHToRef(\r\n            this._cameraRigParams.vrMetrics.aspectRatioFov,\r\n            this._cameraRigParams.vrMetrics.aspectRatio,\r\n            this.minZ,\r\n            this.maxZ,\r\n            this._cameraRigParams.vrWorkMatrix,\r\n            true,\r\n            this.getEngine().isNDCHalfZRange\r\n        );\r\n        this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        //Here for WebVR\r\n    }\r\n\r\n    protected _updateWebVRCameraRotationMatrix() {\r\n        //Here for WebVR\r\n    }\r\n\r\n    /**\r\n     * This function MUST be overwritten by the different WebVR cameras available.\r\n     * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\r\n     * @internal\r\n     */\r\n    public _getWebVRProjectionMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    /**\r\n     * This function MUST be overwritten by the different WebVR cameras available.\r\n     * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\r\n     * @internal\r\n     */\r\n    public _getWebVRViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setCameraRigParameter(name: string, value: any) {\r\n        if (!this._cameraRigParams) {\r\n            this._cameraRigParams = {};\r\n        }\r\n        this._cameraRigParams[name] = value;\r\n        //provisionnally:\r\n        if (name === \"interaxialDistance\") {\r\n            this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * needs to be overridden by children so sub has required properties to be copied\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * May need to be overridden by children\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        for (let i = 0; i < this._rigCameras.length; i++) {\r\n            this._rigCameras[i].minZ = this.minZ;\r\n            this._rigCameras[i].maxZ = this.maxZ;\r\n            this._rigCameras[i].fov = this.fov;\r\n            this._rigCameras[i].upVector.copyFrom(this.upVector);\r\n        }\r\n\r\n        // only update viewport when ANAGLYPH\r\n        if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {\r\n            this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _setupInputs() {}\r\n\r\n    /**\r\n     * Serialiaze the camera setup to a json representation\r\n     * @returns the JSON representation\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getClassName();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        if (this.inputs) {\r\n            this.inputs.serialize(serializationObject);\r\n        }\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clones the current camera.\r\n     * @param name The cloned camera name\r\n     * @param newParent The cloned camera's new parent (none by default)\r\n     * @returns the cloned camera\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Camera {\r\n        const camera = SerializationHelper.Clone(\r\n            Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide),\r\n            this\r\n        );\r\n        camera.name = name;\r\n        camera.parent = newParent;\r\n\r\n        this.onClonedObservable.notifyObservers(camera);\r\n\r\n        return camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the direction of the camera relative to a given local axis.\r\n     * @param localAxis Defines the reference axis to provide a relative direction.\r\n     * @returns the direction\r\n     */\r\n    public getDirection(localAxis: Vector3): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the current camera absolute rotation\r\n     */\r\n    public get absoluteRotation(): Quaternion {\r\n        this.getWorldMatrix().decompose(undefined, this._absoluteRotation);\r\n\r\n        return this._absoluteRotation;\r\n    }\r\n\r\n    /**\r\n     * Gets the direction of the camera relative to a given local axis into a passed vector.\r\n     * @param localAxis Defines the reference axis to provide a relative direction.\r\n     * @param result Defines the vector to store the result in\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, result: Vector3): void {\r\n        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\r\n    }\r\n\r\n    /**\r\n     * Gets a camera constructor for a given camera type\r\n     * @param type The type of the camera to construct (should be equal to one of the camera class name)\r\n     * @param name The name of the camera the result will be able to instantiate\r\n     * @param scene The scene the result will construct the camera in\r\n     * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes\r\n     * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side\r\n     * @returns a factory method to construct the camera\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    static GetConstructorFromName(type: string, name: string, scene: Scene, interaxial_distance: number = 0, isStereoscopicSideBySide: boolean = true): () => Camera {\r\n        const constructorFunc = Node.Construct(type, name, scene, {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            interaxial_distance: interaxial_distance,\r\n            isStereoscopicSideBySide: isStereoscopicSideBySide,\r\n        });\r\n\r\n        if (constructorFunc) {\r\n            return <() => Camera>constructorFunc;\r\n        }\r\n\r\n        // Default to universal camera\r\n        return () => Camera._CreateDefaultParsedCamera(name, scene);\r\n    }\r\n\r\n    /**\r\n     * Compute the world  matrix of the camera.\r\n     * @returns the camera world matrix\r\n     */\r\n    public computeWorldMatrix(): Matrix {\r\n        return this.getWorldMatrix();\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON and creates the camera from the parsed information\r\n     * @param parsedCamera The JSON to parse\r\n     * @param scene The scene to instantiate the camera in\r\n     * @returns the newly constructed camera\r\n     */\r\n    public static Parse(parsedCamera: any, scene: Scene): Camera {\r\n        const type = parsedCamera.type;\r\n        const construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);\r\n\r\n        const camera = SerializationHelper.Parse(construct, parsedCamera, scene);\r\n\r\n        // Parent\r\n        if (parsedCamera.parentId !== undefined) {\r\n            camera._waitingParentId = parsedCamera.parentId;\r\n        }\r\n\r\n        // Parent instance index\r\n        if (parsedCamera.parentInstanceIndex !== undefined) {\r\n            camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;\r\n        }\r\n\r\n        //If camera has an input manager, let it parse inputs settings\r\n        if (camera.inputs) {\r\n            camera.inputs.parse(parsedCamera);\r\n\r\n            camera._setupInputs();\r\n        }\r\n\r\n        if (parsedCamera.upVector) {\r\n            camera.upVector = Vector3.FromArray(parsedCamera.upVector); // need to force the upVector\r\n        }\r\n\r\n        if ((<any>camera).setPosition) {\r\n            // need to force position\r\n            camera.position.copyFromFloats(0, 0, 0);\r\n            (<any>camera).setPosition(Vector3.FromArray(parsedCamera.position));\r\n        }\r\n\r\n        // Target\r\n        if (parsedCamera.target) {\r\n            if ((<any>camera).setTarget) {\r\n                (<any>camera).setTarget(Vector3.FromArray(parsedCamera.target));\r\n            }\r\n        }\r\n\r\n        // Apply 3d rig, when found\r\n        if (parsedCamera.cameraRigMode) {\r\n            const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};\r\n            camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedCamera.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedCamera.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    camera.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(camera, parsedCamera, scene);\r\n        }\r\n\r\n        if (parsedCamera.autoAnimate) {\r\n            scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedCamera.isEnabled !== undefined) {\r\n            camera.setEnabled(parsedCamera.isEnabled);\r\n        }\r\n\r\n        return camera;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}