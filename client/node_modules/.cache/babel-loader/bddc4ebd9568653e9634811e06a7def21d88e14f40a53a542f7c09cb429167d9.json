{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Material } from \"./material.js\";\nimport { MaterialPluginEvent } from \"./materialPluginEvent.js\";\nconst rxOption = new RegExp(\"^([gimus]+)!\");\n/**\n * Class that manages the plugins of a material\n * @since 5.0\n */\nexport class MaterialPluginManager {\n  /**\n   * Creates a new instance of the plugin manager\n   * @param material material that this manager will manage the plugins for\n   */\n  constructor(material) {\n    this._plugins = [];\n    this._activePlugins = [];\n    this._activePluginsForExtraEvents = [];\n    this._material = material;\n    this._scene = material.getScene();\n    this._engine = this._scene.getEngine();\n  }\n  /**\n   * @internal\n   */\n  _addPlugin(plugin) {\n    for (let i = 0; i < this._plugins.length; ++i) {\n      if (this._plugins[i].name === plugin.name) {\n        throw `Plugin \"${plugin.name}\" already added to the material \"${this._material.name}\"!`;\n      }\n    }\n    if (this._material._uniformBufferLayoutBuilt) {\n      throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\n    }\n    const pluginClassName = plugin.getClassName();\n    if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\n      MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\n    }\n    this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);\n    this._plugins.push(plugin);\n    this._plugins.sort((a, b) => a.priority - b.priority);\n    this._codeInjectionPoints = {};\n    const defineNamesFromPlugins = {};\n    defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\n      type: \"boolean\",\n      default: true\n    };\n    for (const plugin of this._plugins) {\n      plugin.collectDefines(defineNamesFromPlugins);\n      this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\n      this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\n    }\n    this._defineNamesFromPlugins = defineNamesFromPlugins;\n  }\n  /**\n   * @internal\n   */\n  _activatePlugin(plugin) {\n    if (this._activePlugins.indexOf(plugin) === -1) {\n      this._activePlugins.push(plugin);\n      this._activePlugins.sort((a, b) => a.priority - b.priority);\n      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\n      this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\n      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\n      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\n      if (plugin.registerForExtraEvents) {\n        this._activePluginsForExtraEvents.push(plugin);\n        this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\n        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\n        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\n        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\n      }\n    }\n  }\n  /**\n   * Gets a plugin from the list of plugins managed by this manager\n   * @param name name of the plugin\n   * @returns the plugin if found, else null\n   */\n  getPlugin(name) {\n    for (let i = 0; i < this._plugins.length; ++i) {\n      if (this._plugins[i].name === name) {\n        return this._plugins[i];\n      }\n    }\n    return null;\n  }\n  _handlePluginEventIsReadyForSubMesh(eventData) {\n    let isReady = true;\n    for (const plugin of this._activePlugins) {\n      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\n    }\n    eventData.isReadyForSubMesh = isReady;\n  }\n  _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\n    }\n  }\n  _handlePluginEventPrepareDefines(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\n    }\n  }\n  _handlePluginEventHardBindForSubMesh(eventData) {\n    for (const plugin of this._activePluginsForExtraEvents) {\n      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\n    }\n  }\n  _handlePluginEventBindForSubMesh(eventData) {\n    for (const plugin of this._activePlugins) {\n      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\n    }\n  }\n  _handlePluginEventHasRenderTargetTextures(eventData) {\n    let hasRenderTargetTextures = false;\n    for (const plugin of this._activePluginsForExtraEvents) {\n      hasRenderTargetTextures = plugin.hasRenderTargetTextures();\n      if (hasRenderTargetTextures) {\n        break;\n      }\n    }\n    eventData.hasRenderTargetTextures = hasRenderTargetTextures;\n  }\n  _handlePluginEventFillRenderTargetTextures(eventData) {\n    for (const plugin of this._activePluginsForExtraEvents) {\n      plugin.fillRenderTargetTextures(eventData.renderTargets);\n    }\n  }\n  _handlePluginEvent(id, info) {\n    switch (id) {\n      case MaterialPluginEvent.GetActiveTextures:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            plugin.getActiveTextures(eventData.activeTextures);\n          }\n          break;\n        }\n      case MaterialPluginEvent.GetAnimatables:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            plugin.getAnimatables(eventData.animatables);\n          }\n          break;\n        }\n      case MaterialPluginEvent.HasTexture:\n        {\n          const eventData = info;\n          let hasTexture = false;\n          for (const plugin of this._activePlugins) {\n            hasTexture = plugin.hasTexture(eventData.texture);\n            if (hasTexture) {\n              break;\n            }\n          }\n          eventData.hasTexture = hasTexture;\n          break;\n        }\n      case MaterialPluginEvent.Disposed:\n        {\n          const eventData = info;\n          for (const plugin of this._plugins) {\n            plugin.dispose(eventData.forceDisposeTextures);\n          }\n          break;\n        }\n      case MaterialPluginEvent.GetDefineNames:\n        {\n          const eventData = info;\n          eventData.defineNames = this._defineNamesFromPlugins;\n          break;\n        }\n      case MaterialPluginEvent.PrepareEffect:\n        {\n          const eventData = info;\n          for (const plugin of this._activePlugins) {\n            eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\n            plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\n          }\n          if (this._uniformList.length > 0) {\n            eventData.uniforms.push(...this._uniformList);\n          }\n          if (this._samplerList.length > 0) {\n            eventData.samplers.push(...this._samplerList);\n          }\n          if (this._uboList.length > 0) {\n            eventData.uniformBuffersNames.push(...this._uboList);\n          }\n          eventData.customCode = this._injectCustomCode(eventData.customCode);\n          break;\n        }\n      case MaterialPluginEvent.PrepareUniformBuffer:\n        {\n          const eventData = info;\n          this._uboDeclaration = \"\";\n          this._vertexDeclaration = \"\";\n          this._fragmentDeclaration = \"\";\n          this._uniformList = [];\n          this._samplerList = [];\n          this._uboList = [];\n          for (const plugin of this._plugins) {\n            const uniforms = plugin.getUniforms();\n            if (uniforms) {\n              if (uniforms.ubo) {\n                for (const uniform of uniforms.ubo) {\n                  eventData.ubo.addUniform(uniform.name, uniform.size);\n                  this._uboDeclaration += `${uniform.type} ${uniform.name};\\r\\n`;\n                  this._uniformList.push(uniform.name);\n                }\n              }\n              if (uniforms.vertex) {\n                this._vertexDeclaration += uniforms.vertex + \"\\r\\n\";\n              }\n              if (uniforms.fragment) {\n                this._fragmentDeclaration += uniforms.fragment + \"\\r\\n\";\n              }\n            }\n            plugin.getSamplers(this._samplerList);\n            plugin.getUniformBuffersNames(this._uboList);\n          }\n          break;\n        }\n    }\n  }\n  _collectPointNames(shaderType, customCode) {\n    if (!customCode) {\n      return;\n    }\n    for (const pointName in customCode) {\n      if (!this._codeInjectionPoints[shaderType]) {\n        this._codeInjectionPoints[shaderType] = {};\n      }\n      this._codeInjectionPoints[shaderType][pointName] = true;\n    }\n  }\n  _injectCustomCode(existingCallback) {\n    return (shaderType, code) => {\n      var _a;\n      if (existingCallback) {\n        code = existingCallback(shaderType, code);\n      }\n      if (this._uboDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\n      }\n      if (this._vertexDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\n      }\n      if (this._fragmentDeclaration) {\n        code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\n      }\n      const points = (_a = this._codeInjectionPoints) === null || _a === void 0 ? void 0 : _a[shaderType];\n      if (!points) {\n        return code;\n      }\n      for (let pointName in points) {\n        let injectedCode = \"\";\n        for (const plugin of this._activePlugins) {\n          const customCode = plugin.getCustomCode(shaderType);\n          if (customCode === null || customCode === void 0 ? void 0 : customCode[pointName]) {\n            injectedCode += customCode[pointName] + \"\\r\\n\";\n          }\n        }\n        if (injectedCode.length > 0) {\n          if (pointName.charAt(0) === \"!\") {\n            // pointName is a regular expression\n            pointName = pointName.substring(1);\n            let regexFlags = \"g\";\n            if (pointName.charAt(0) === \"!\") {\n              // no flags\n              regexFlags = \"\";\n              pointName = pointName.substring(1);\n            } else {\n              // get the flag(s)\n              const matchOption = rxOption.exec(pointName);\n              if (matchOption && matchOption.length >= 2) {\n                regexFlags = matchOption[1];\n                pointName = pointName.substring(regexFlags.length + 1);\n              }\n            }\n            if (regexFlags.indexOf(\"g\") < 0) {\n              // we force the \"g\" flag so that the regexp object is stateful!\n              regexFlags += \"g\";\n            }\n            const sourceCode = code;\n            const rx = new RegExp(pointName, regexFlags);\n            let match = rx.exec(sourceCode);\n            while (match !== null) {\n              let newCode = injectedCode;\n              for (let i = 0; i < match.length; ++i) {\n                newCode = newCode.replace(\"$\" + i, match[i]);\n              }\n              code = code.replace(match[0], newCode);\n              match = rx.exec(sourceCode);\n            }\n          } else {\n            const fullPointName = \"#define \" + pointName;\n            code = code.replace(fullPointName, \"\\r\\n\" + injectedCode + \"\\r\\n\" + fullPointName);\n          }\n        }\n      }\n      return code;\n    };\n  }\n}\n/** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\nMaterialPluginManager._MaterialPluginClassToMainDefine = {};\nMaterialPluginManager._MaterialPluginCounter = 0;\nconst plugins = [];\nlet inited = false;\n/**\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\n * @param pluginName The plugin name\n * @param factory The factory function which allows to create the plugin\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function RegisterMaterialPlugin(pluginName, factory) {\n  if (!inited) {\n    Material.OnEventObservable.add(material => {\n      for (const [, factory] of plugins) {\n        factory(material);\n      }\n    }, MaterialPluginEvent.Created);\n    inited = true;\n  }\n  const existing = plugins.filter(([name, _factory]) => name === pluginName);\n  if (existing.length > 0) {\n    existing[0][1] = factory;\n  } else {\n    plugins.push([pluginName, factory]);\n  }\n}\n/**\n * Removes a material plugin from the list of global plugins.\n * @param pluginName The plugin name\n * @returns true if the plugin has been removed, else false\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function UnregisterMaterialPlugin(pluginName) {\n  for (let i = 0; i < plugins.length; ++i) {\n    if (plugins[i][0] === pluginName) {\n      plugins.splice(i, 1);\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Clear the list of global material plugins\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function UnregisterAllMaterialPlugins() {\n  plugins.length = 0;\n}","map":{"version":3,"mappings":"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","names":["Material","MaterialPluginEvent","rxOption","RegExp","MaterialPluginManager","constructor","material","_material","_scene","getScene","_engine","getEngine","_addPlugin","plugin","i","_plugins","length","name","_uniformBufferLayoutBuilt","pluginClassName","getClassName","_MaterialPluginClassToMainDefine","_MaterialPluginCounter","_callbackPluginEventGeneric","_handlePluginEvent","bind","push","sort","a","b","priority","_codeInjectionPoints","defineNamesFromPlugins","type","default","collectDefines","_collectPointNames","getCustomCode","_defineNamesFromPlugins","_activatePlugin","_activePlugins","indexOf","_callbackPluginEventIsReadyForSubMesh","_handlePluginEventIsReadyForSubMesh","_callbackPluginEventPrepareDefinesBeforeAttributes","_handlePluginEventPrepareDefinesBeforeAttributes","_callbackPluginEventPrepareDefines","_handlePluginEventPrepareDefines","_callbackPluginEventBindForSubMesh","_handlePluginEventBindForSubMesh","registerForExtraEvents","_activePluginsForExtraEvents","_callbackPluginEventHasRenderTargetTextures","_handlePluginEventHasRenderTargetTextures","_callbackPluginEventFillRenderTargetTextures","_handlePluginEventFillRenderTargetTextures","_callbackPluginEventHardBindForSubMesh","_handlePluginEventHardBindForSubMesh","getPlugin","eventData","isReady","isReadyForSubMesh","defines","subMesh","prepareDefinesBeforeAttributes","mesh","prepareDefines","hardBindForSubMesh","_uniformBuffer","bindForSubMesh","hasRenderTargetTextures","fillRenderTargetTextures","renderTargets","id","info","GetActiveTextures","getActiveTextures","activeTextures","GetAnimatables","getAnimatables","animatables","HasTexture","hasTexture","texture","Disposed","dispose","forceDisposeTextures","GetDefineNames","defineNames","PrepareEffect","fallbackRank","addFallbacks","fallbacks","getAttributes","attributes","_uniformList","uniforms","_samplerList","samplers","_uboList","uniformBuffersNames","customCode","_injectCustomCode","PrepareUniformBuffer","_uboDeclaration","_vertexDeclaration","_fragmentDeclaration","getUniforms","ubo","uniform","addUniform","size","vertex","fragment","getSamplers","getUniformBuffersNames","shaderType","pointName","existingCallback","code","replace","points","injectedCode","charAt","substring","regexFlags","matchOption","exec","sourceCode","rx","match","newCode","fullPointName","plugins","inited","RegisterMaterialPlugin","pluginName","factory","OnEventObservable","add","Created","existing","filter","_factory","UnregisterMaterialPlugin","splice","UnregisterAllMaterialPlugins"],"sourceRoot":"","sources":["../../../../lts/core/generated/Materials/materialPluginManager.ts"],"sourcesContent":["import type { ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport type {\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginDisposed,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginHardBindForSubMesh,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginFillRenderTargetTextures,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type MaterialPluginBase = import(\"./materialPluginBase\").MaterialPluginBase;\r\n\r\ndeclare module \"./material\" {\r\n    export interface Material {\r\n        /**\r\n         * Plugin manager for this material\r\n         */\r\n        pluginManager?: MaterialPluginManager;\r\n    }\r\n}\r\n\r\nconst rxOption = new RegExp(\"^([gimus]+)!\");\r\n\r\n/**\r\n * Class that manages the plugins of a material\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginManager {\r\n    /** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\r\n    private static _MaterialPluginClassToMainDefine: { [name: string]: string } = {};\r\n    private static _MaterialPluginCounter: number = 0;\r\n\r\n    protected _material: Material;\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    protected _plugins: MaterialPluginBase[] = [];\r\n    protected _activePlugins: MaterialPluginBase[] = [];\r\n    protected _activePluginsForExtraEvents: MaterialPluginBase[] = [];\r\n    protected _codeInjectionPoints: { [shaderType: string]: { [codeName: string]: boolean } };\r\n    protected _defineNamesFromPlugins?: { [name: string]: { type: string; default: any } };\r\n    protected _uboDeclaration: string;\r\n    protected _vertexDeclaration: string;\r\n    protected _fragmentDeclaration: string;\r\n    protected _uniformList: string[];\r\n    protected _samplerList: string[];\r\n    protected _uboList: string[];\r\n\r\n    /**\r\n     * Creates a new instance of the plugin manager\r\n     * @param material material that this manager will manage the plugins for\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material;\r\n        this._scene = material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addPlugin(plugin: MaterialPluginBase): void {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === plugin.name) {\r\n                throw `Plugin \"${plugin.name}\" already added to the material \"${this._material.name}\"!`;\r\n            }\r\n        }\r\n\r\n        if (this._material._uniformBufferLayoutBuilt) {\r\n            throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\r\n        }\r\n\r\n        const pluginClassName = plugin.getClassName();\r\n        if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\r\n            MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\r\n        }\r\n\r\n        this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);\r\n\r\n        this._plugins.push(plugin);\r\n        this._plugins.sort((a, b) => a.priority - b.priority);\r\n\r\n        this._codeInjectionPoints = {};\r\n\r\n        const defineNamesFromPlugins: { [name: string]: { type: string; default: any } } = {};\r\n        defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\r\n            type: \"boolean\",\r\n            default: true,\r\n        };\r\n\r\n        for (const plugin of this._plugins) {\r\n            plugin.collectDefines(defineNamesFromPlugins);\r\n            this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\r\n            this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\r\n        }\r\n\r\n        this._defineNamesFromPlugins = defineNamesFromPlugins;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activatePlugin(plugin: MaterialPluginBase): void {\r\n        if (this._activePlugins.indexOf(plugin) === -1) {\r\n            this._activePlugins.push(plugin);\r\n            this._activePlugins.sort((a, b) => a.priority - b.priority);\r\n\r\n            this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\r\n            this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\r\n            this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\r\n            this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\r\n\r\n            if (plugin.registerForExtraEvents) {\r\n                this._activePluginsForExtraEvents.push(plugin);\r\n                this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\r\n                this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a plugin from the list of plugins managed by this manager\r\n     * @param name name of the plugin\r\n     * @returns the plugin if found, else null\r\n     */\r\n    public getPlugin(name: string): Nullable<MaterialPluginBase> {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === name) {\r\n                return this._plugins[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _handlePluginEventIsReadyForSubMesh(eventData: MaterialPluginIsReadyForSubMesh): void {\r\n        let isReady = true;\r\n        for (const plugin of this._activePlugins) {\r\n            isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n        eventData.isReadyForSubMesh = isReady;\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefinesBeforeAttributes(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefines(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHardBindForSubMesh(eventData: MaterialPluginHardBindForSubMesh): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventBindForSubMesh(eventData: MaterialPluginBindForSubMesh): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHasRenderTargetTextures(eventData: MaterialPluginHasRenderTargetTextures): void {\r\n        let hasRenderTargetTextures = false;\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            hasRenderTargetTextures = plugin.hasRenderTargetTextures();\r\n            if (hasRenderTargetTextures) {\r\n                break;\r\n            }\r\n        }\r\n        eventData.hasRenderTargetTextures = hasRenderTargetTextures;\r\n    }\r\n\r\n    protected _handlePluginEventFillRenderTargetTextures(eventData: MaterialPluginFillRenderTargetTextures): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.fillRenderTargetTextures(eventData.renderTargets);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEvent(\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ): void {\r\n        switch (id) {\r\n            case MaterialPluginEvent.GetActiveTextures: {\r\n                const eventData = info as MaterialPluginGetActiveTextures;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getActiveTextures(eventData.activeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetAnimatables: {\r\n                const eventData = info as MaterialPluginGetAnimatables;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getAnimatables(eventData.animatables);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.HasTexture: {\r\n                const eventData = info as MaterialPluginHasTexture;\r\n                let hasTexture = false;\r\n                for (const plugin of this._activePlugins) {\r\n                    hasTexture = plugin.hasTexture(eventData.texture);\r\n                    if (hasTexture) {\r\n                        break;\r\n                    }\r\n                }\r\n                eventData.hasTexture = hasTexture;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.Disposed: {\r\n                const eventData = info as MaterialPluginDisposed;\r\n                for (const plugin of this._plugins) {\r\n                    plugin.dispose(eventData.forceDisposeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetDefineNames: {\r\n                const eventData = info as MaterialPluginGetDefineNames;\r\n                eventData.defineNames = this._defineNamesFromPlugins;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareEffect: {\r\n                const eventData = info as MaterialPluginPrepareEffect;\r\n                for (const plugin of this._activePlugins) {\r\n                    eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\r\n                    plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\r\n                }\r\n                if (this._uniformList.length > 0) {\r\n                    eventData.uniforms.push(...this._uniformList);\r\n                }\r\n                if (this._samplerList.length > 0) {\r\n                    eventData.samplers.push(...this._samplerList);\r\n                }\r\n                if (this._uboList.length > 0) {\r\n                    eventData.uniformBuffersNames.push(...this._uboList);\r\n                }\r\n                eventData.customCode = this._injectCustomCode(eventData.customCode);\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareUniformBuffer: {\r\n                const eventData = info as MaterialPluginPrepareUniformBuffer;\r\n                this._uboDeclaration = \"\";\r\n                this._vertexDeclaration = \"\";\r\n                this._fragmentDeclaration = \"\";\r\n                this._uniformList = [];\r\n                this._samplerList = [];\r\n                this._uboList = [];\r\n                for (const plugin of this._plugins) {\r\n                    const uniforms = plugin.getUniforms();\r\n                    if (uniforms) {\r\n                        if (uniforms.ubo) {\r\n                            for (const uniform of uniforms.ubo) {\r\n                                eventData.ubo.addUniform(uniform.name, uniform.size);\r\n                                this._uboDeclaration += `${uniform.type} ${uniform.name};\\r\\n`;\r\n                                this._uniformList.push(uniform.name);\r\n                            }\r\n                        }\r\n                        if (uniforms.vertex) {\r\n                            this._vertexDeclaration += uniforms.vertex + \"\\r\\n\";\r\n                        }\r\n                        if (uniforms.fragment) {\r\n                            this._fragmentDeclaration += uniforms.fragment + \"\\r\\n\";\r\n                        }\r\n                    }\r\n                    plugin.getSamplers(this._samplerList);\r\n                    plugin.getUniformBuffersNames(this._uboList);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _collectPointNames(shaderType: string, customCode: Nullable<{ [pointName: string]: string }> | undefined): void {\r\n        if (!customCode) {\r\n            return;\r\n        }\r\n        for (const pointName in customCode) {\r\n            if (!this._codeInjectionPoints[shaderType]) {\r\n                this._codeInjectionPoints[shaderType] = {};\r\n            }\r\n            this._codeInjectionPoints[shaderType][pointName] = true;\r\n        }\r\n    }\r\n\r\n    protected _injectCustomCode(existingCallback?: (shaderType: string, code: string) => string): ShaderCustomProcessingFunction {\r\n        return (shaderType: string, code: string) => {\r\n            if (existingCallback) {\r\n                code = existingCallback(shaderType, code);\r\n            }\r\n            if (this._uboDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\r\n            }\r\n            if (this._vertexDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\r\n            }\r\n            if (this._fragmentDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\r\n            }\r\n            const points = this._codeInjectionPoints?.[shaderType];\r\n            if (!points) {\r\n                return code;\r\n            }\r\n            for (let pointName in points) {\r\n                let injectedCode = \"\";\r\n                for (const plugin of this._activePlugins) {\r\n                    const customCode = plugin.getCustomCode(shaderType);\r\n                    if (customCode?.[pointName]) {\r\n                        injectedCode += customCode[pointName] + \"\\r\\n\";\r\n                    }\r\n                }\r\n                if (injectedCode.length > 0) {\r\n                    if (pointName.charAt(0) === \"!\") {\r\n                        // pointName is a regular expression\r\n                        pointName = pointName.substring(1);\r\n\r\n                        let regexFlags = \"g\";\r\n                        if (pointName.charAt(0) === \"!\") {\r\n                            // no flags\r\n                            regexFlags = \"\";\r\n                            pointName = pointName.substring(1);\r\n                        } else {\r\n                            // get the flag(s)\r\n                            const matchOption = rxOption.exec(pointName);\r\n                            if (matchOption && matchOption.length >= 2) {\r\n                                regexFlags = matchOption[1];\r\n                                pointName = pointName.substring(regexFlags.length + 1);\r\n                            }\r\n                        }\r\n\r\n                        if (regexFlags.indexOf(\"g\") < 0) {\r\n                            // we force the \"g\" flag so that the regexp object is stateful!\r\n                            regexFlags += \"g\";\r\n                        }\r\n\r\n                        const sourceCode = code;\r\n                        const rx = new RegExp(pointName, regexFlags);\r\n                        let match = rx.exec(sourceCode);\r\n                        while (match !== null) {\r\n                            let newCode = injectedCode;\r\n                            for (let i = 0; i < match.length; ++i) {\r\n                                newCode = newCode.replace(\"$\" + i, match[i]);\r\n                            }\r\n                            code = code.replace(match[0], newCode);\r\n                            match = rx.exec(sourceCode);\r\n                        }\r\n                    } else {\r\n                        const fullPointName = \"#define \" + pointName;\r\n                        code = code.replace(fullPointName, \"\\r\\n\" + injectedCode + \"\\r\\n\" + fullPointName);\r\n                    }\r\n                }\r\n            }\r\n            return code;\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Type for plugin material factories.\r\n */\r\nexport type PluginMaterialFactory = (material: Material) => Nullable<MaterialPluginBase>;\r\n\r\nconst plugins: Array<[string, PluginMaterialFactory]> = [];\r\nlet inited = false;\r\n\r\n/**\r\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\r\n * @param pluginName The plugin name\r\n * @param factory The factory function which allows to create the plugin\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RegisterMaterialPlugin(pluginName: string, factory: PluginMaterialFactory): void {\r\n    if (!inited) {\r\n        Material.OnEventObservable.add((material: Material) => {\r\n            for (const [, factory] of plugins) {\r\n                factory(material);\r\n            }\r\n        }, MaterialPluginEvent.Created);\r\n        inited = true;\r\n    }\r\n    const existing = plugins.filter(([name, _factory]) => name === pluginName);\r\n    if (existing.length > 0) {\r\n        existing[0][1] = factory;\r\n    } else {\r\n        plugins.push([pluginName, factory]);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a material plugin from the list of global plugins.\r\n * @param pluginName The plugin name\r\n * @returns true if the plugin has been removed, else false\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterMaterialPlugin(pluginName: string): boolean {\r\n    for (let i = 0; i < plugins.length; ++i) {\r\n        if (plugins[i][0] === pluginName) {\r\n            plugins.splice(i, 1);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Clear the list of global material plugins\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterAllMaterialPlugins(): void {\r\n    plugins.length = 0;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}