{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nclass CircleBuffer {\n  constructor(numSamples, initializer) {\n    this._samples = [];\n    this._idx = 0;\n    for (let idx = 0; idx < numSamples; ++idx) {\n      this._samples.push(initializer ? initializer() : Vector2.Zero());\n    }\n  }\n  get length() {\n    return this._samples.length;\n  }\n  push(x, y) {\n    this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\n    this.at(0).copyFromFloats(x, y);\n  }\n  at(idx) {\n    if (idx >= this._samples.length) {\n      throw new Error(\"Index out of bounds\");\n    }\n    return this._samples[(this._idx + idx) % this._samples.length];\n  }\n}\nclass FirstStepDetector {\n  constructor() {\n    this._samples = new CircleBuffer(20);\n    this._entropy = 0;\n    this.onFirstStepDetected = new Observable();\n  }\n  update(posX, posY, forwardX, forwardY) {\n    this._samples.push(posX, posY);\n    const origin = this._samples.at(0);\n    this._entropy *= this._entropyDecayFactor;\n    this._entropy += Vector2.Distance(origin, this._samples.at(1));\n    if (this._entropy > this._entropyThreshold) {\n      return;\n    }\n    let samePointIdx;\n    for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\n      if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\n        break;\n      }\n    }\n    if (samePointIdx === this._samples.length) {\n      return;\n    }\n    let apexDistSquared = -1;\n    let apexIdx = 0;\n    for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {\n      distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\n      if (distSquared > apexDistSquared) {\n        apexIdx = idx;\n        apexDistSquared = distSquared;\n      }\n    }\n    if (apexDistSquared < this._apexSquaredDistanceThreshold) {\n      return;\n    }\n    const apex = this._samples.at(apexIdx);\n    const axis = apex.subtract(origin);\n    axis.normalize();\n    const vec = TmpVectors.Vector2[0];\n    let dot;\n    let sample;\n    let sumSquaredProjectionDistances = 0;\n    for (let idx = 1; idx < samePointIdx; ++idx) {\n      sample = this._samples.at(idx);\n      sample.subtractToRef(origin, vec);\n      dot = Vector2.Dot(axis, vec);\n      sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\n    }\n    if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\n      return;\n    }\n    const forwardVec = TmpVectors.Vector3[0];\n    forwardVec.set(forwardX, forwardY, 0);\n    const axisVec = TmpVectors.Vector3[1];\n    axisVec.set(axis.x, axis.y, 0);\n    const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\n    const leftApex = origin.clone();\n    const rightApex = origin.clone();\n    apex.subtractToRef(origin, axis);\n    if (isApexLeft) {\n      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\n      axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\n    } else {\n      axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\n      axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\n    }\n    this.onFirstStepDetected.notifyObservers({\n      leftApex: leftApex,\n      rightApex: rightApex,\n      currentPosition: origin,\n      currentStepDirection: isApexLeft ? \"right\" : \"left\"\n    });\n  }\n  reset() {\n    for (let idx = 0; idx < this._samples.length; ++idx) {\n      this._samples.at(idx).copyFromFloats(0, 0);\n    }\n  }\n  get _samePointCheckStartIdx() {\n    return Math.floor(this._samples.length / 3);\n  }\n  get _samePointSquaredDistanceThreshold() {\n    return 0.03 * 0.03;\n  }\n  get _apexSquaredDistanceThreshold() {\n    return 0.09 * 0.09;\n  }\n  get _squaredProjectionDistanceThreshold() {\n    return 0.03 * 0.03;\n  }\n  get _axisToApexShrinkFactor() {\n    return 0.8;\n  }\n  get _axisToApexExtendFactor() {\n    return -1.6;\n  }\n  get _entropyDecayFactor() {\n    return 0.93;\n  }\n  get _entropyThreshold() {\n    return 0.4;\n  }\n}\nclass WalkingTracker {\n  constructor(leftApex, rightApex, currentPosition, currentStepDirection) {\n    this._leftApex = new Vector2();\n    this._rightApex = new Vector2();\n    this._currentPosition = new Vector2();\n    this._axis = new Vector2();\n    this._axisLength = -1;\n    this._forward = new Vector2();\n    this._steppingLeft = false;\n    this._t = -1;\n    this._maxT = -1;\n    this._maxTPosition = new Vector2();\n    this._vitality = 0;\n    this.onMovement = new Observable();\n    this.onFootfall = new Observable();\n    this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\n  }\n  _reset(leftApex, rightApex, currentPosition, steppingLeft) {\n    this._leftApex.copyFrom(leftApex);\n    this._rightApex.copyFrom(rightApex);\n    this._steppingLeft = steppingLeft;\n    if (this._steppingLeft) {\n      this._leftApex.subtractToRef(this._rightApex, this._axis);\n      this._forward.copyFromFloats(-this._axis.y, this._axis.x);\n    } else {\n      this._rightApex.subtractToRef(this._leftApex, this._axis);\n      this._forward.copyFromFloats(this._axis.y, -this._axis.x);\n    }\n    this._axisLength = this._axis.length();\n    this._forward.scaleInPlace(1 / this._axisLength);\n    this._updateTAndVitality(currentPosition.x, currentPosition.y);\n    this._maxT = this._t;\n    this._maxTPosition.copyFrom(currentPosition);\n    this._vitality = 1;\n  }\n  _updateTAndVitality(x, y) {\n    this._currentPosition.copyFromFloats(x, y);\n    if (this._steppingLeft) {\n      this._currentPosition.subtractInPlace(this._rightApex);\n    } else {\n      this._currentPosition.subtractInPlace(this._leftApex);\n    }\n    const priorT = this._t;\n    const dot = Vector2.Dot(this._currentPosition, this._axis);\n    this._t = dot / (this._axisLength * this._axisLength);\n    const projDistSquared = this._currentPosition.lengthSquared() - dot / this._axisLength * (dot / this._axisLength);\n    // TODO: Extricate the magic.\n    this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\n  }\n  update(x, y) {\n    if (this._vitality < this._vitalityThreshold) {\n      return false;\n    }\n    const priorT = this._t;\n    this._updateTAndVitality(x, y);\n    if (this._t > this._maxT) {\n      this._maxT = this._t;\n      this._maxTPosition.copyFromFloats(x, y);\n    }\n    if (this._vitality < this._vitalityThreshold) {\n      return false;\n    }\n    if (this._t > priorT) {\n      this.onMovement.notifyObservers({\n        deltaT: this._t - priorT\n      });\n      if (priorT < 0.5 && this._t >= 0.5) {\n        this.onFootfall.notifyObservers({\n          foot: this._steppingLeft ? \"left\" : \"right\"\n        });\n      }\n    }\n    if (this._t < 0.95 * this._maxT) {\n      this._currentPosition.copyFromFloats(x, y);\n      if (this._steppingLeft) {\n        this._leftApex.copyFrom(this._maxTPosition);\n      } else {\n        this._rightApex.copyFrom(this._maxTPosition);\n      }\n      this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\n    }\n    if (this._axisLength < 0.03) {\n      return false;\n    }\n    return true;\n  }\n  get _vitalityThreshold() {\n    return 0.1;\n  }\n  get forward() {\n    return this._forward;\n  }\n}\nclass Walker {\n  constructor(engine) {\n    this._detector = new FirstStepDetector();\n    this._walker = null;\n    this._movement = new Vector2();\n    this._millisecondsSinceLastUpdate = Walker._MillisecondsPerUpdate;\n    this.movementThisFrame = Vector3.Zero();\n    this._engine = engine;\n    this._detector.onFirstStepDetected.add(event => {\n      if (!this._walker) {\n        this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\n        this._walker.onFootfall.add(() => {\n          console.log(\"Footfall!\");\n        });\n        this._walker.onMovement.add(event => {\n          this._walker.forward.scaleAndAddToRef(0.024 * event.deltaT, this._movement);\n        });\n      }\n    });\n  }\n  static get _MillisecondsPerUpdate() {\n    // 15 FPS\n    return 1000 / 15;\n  }\n  update(position, forward) {\n    forward.y = 0;\n    forward.normalize();\n    // Enforce reduced framerate\n    this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\n    if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\n      this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\n      this._detector.update(position.x, position.z, forward.x, forward.z);\n      if (this._walker) {\n        const updated = this._walker.update(position.x, position.z);\n        if (!updated) {\n          this._walker = null;\n        }\n      }\n      this._movement.scaleInPlace(0.85);\n    }\n    this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\n  }\n}\n/**\n * A module that will enable VR locomotion by detecting when the user walks in place.\n */\nexport class WebXRWalkingLocomotion extends WebXRAbstractFeature {\n  /**\n   * Construct a new Walking Locomotion feature.\n   * @param sessionManager manager for the current XR session\n   * @param options creation options, prominently including the vector target for locomotion\n   */\n  constructor(sessionManager, options) {\n    super(sessionManager);\n    this._up = new Vector3();\n    this._forward = new Vector3();\n    this._position = new Vector3();\n    this._movement = new Vector3();\n    this._sessionManager = sessionManager;\n    this.locomotionTarget = options.locomotionTarget;\n    if (this._isLocomotionTargetWebXRCamera) {\n      Logger.Warn(\"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\");\n    }\n  }\n  /**\n   * The module's name.\n   */\n  static get Name() {\n    return WebXRFeatureName.WALKING_LOCOMOTION;\n  }\n  /**\n   * The (Babylon) version of this module.\n   * This is an integer representing the implementation version.\n   * This number has no external basis.\n   */\n  static get Version() {\n    return 1;\n  }\n  /**\n   * The target to be articulated by walking locomotion.\n   * When the walking locomotion feature detects walking in place, this element's\n   * X and Z coordinates will be modified to reflect locomotion. This target should\n   * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n   * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n   * of the WebXRCamera directly and is thus discouraged.\n   */\n  get locomotionTarget() {\n    return this._locomotionTarget;\n  }\n  /**\n   * The target to be articulated by walking locomotion.\n   * When the walking locomotion feature detects walking in place, this element's\n   * X and Z coordinates will be modified to reflect locomotion. This target should\n   * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\n   * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\n   * of the WebXRCamera directly and is thus discouraged.\n   */\n  set locomotionTarget(locomotionTarget) {\n    this._locomotionTarget = locomotionTarget;\n    this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\n  }\n  /**\n   * Checks whether this feature is compatible with the current WebXR session.\n   * Walking locomotion is only compatible with \"immersive-vr\" sessions.\n   * @returns true if compatible, false otherwise\n   */\n  isCompatible() {\n    return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\n  }\n  /**\n   * Attaches the feature.\n   * Typically called automatically by the features manager.\n   * @returns true if attach succeeded, false otherwise\n   */\n  attach() {\n    if (!this.isCompatible || !super.attach()) {\n      return false;\n    }\n    this._walker = new Walker(this._sessionManager.scene.getEngine());\n    return true;\n  }\n  /**\n   * Detaches the feature.\n   * Typically called automatically by the features manager.\n   * @returns true if detach succeeded, false otherwise\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    this._walker = null;\n    return true;\n  }\n  _onXRFrame(frame) {\n    const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\n    if (!pose) {\n      return;\n    }\n    const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\n    const m = pose.transform.matrix;\n    this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\n    this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\n    this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);\n    // Compute the nape position\n    this._forward.scaleAndAddToRef(0.05, this._position);\n    this._up.scaleAndAddToRef(-0.05, this._position);\n    this._walker.update(this._position, this._forward);\n    this._movement.copyFrom(this._walker.movementThisFrame);\n    if (!this._isLocomotionTargetWebXRCamera) {\n      Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\n    }\n    this.locomotionTarget.position.addInPlace(this._movement);\n  }\n}\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRWalkingLocomotion.Name, (xrSessionManager, options) => {\n  return () => new WebXRWalkingLocomotion(xrSessionManager, options);\n}, WebXRWalkingLocomotion.Version, false);","map":{"version":3,"mappings":"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","names":["TmpVectors","Vector2","Vector3","Logger","Observable","WebXRFeatureName","WebXRFeaturesManager","WebXRAbstractFeature","CircleBuffer","constructor","numSamples","initializer","idx","_samples","push","Zero","length","x","y","_idx","at","copyFromFloats","Error","FirstStepDetector","update","posX","posY","forwardX","forwardY","origin","_entropy","_entropyDecayFactor","Distance","_entropyThreshold","samePointIdx","_samePointCheckStartIdx","DistanceSquared","_samePointSquaredDistanceThreshold","apexDistSquared","apexIdx","distSquared","_apexSquaredDistanceThreshold","apex","axis","subtract","normalize","vec","dot","sample","sumSquaredProjectionDistances","subtractToRef","Dot","lengthSquared","_squaredProjectionDistanceThreshold","forwardVec","set","axisVec","isApexLeft","Cross","z","leftApex","clone","rightApex","scaleAndAddToRef","_axisToApexShrinkFactor","_axisToApexExtendFactor","onFirstStepDetected","notifyObservers","currentPosition","currentStepDirection","reset","Math","floor","WalkingTracker","_reset","steppingLeft","_leftApex","copyFrom","_rightApex","_steppingLeft","_axis","_forward","_axisLength","scaleInPlace","_updateTAndVitality","_maxT","_t","_maxTPosition","_vitality","_currentPosition","subtractInPlace","priorT","projDistSquared","max","_vitalityThreshold","onMovement","deltaT","onFootfall","foot","forward","Walker","engine","_MillisecondsPerUpdate","_engine","_detector","add","event","_walker","console","log","_movement","position","_millisecondsSinceLastUpdate","getDeltaTime","updated","movementThisFrame","WebXRWalkingLocomotion","sessionManager","options","_sessionManager","locomotionTarget","_isLocomotionTargetWebXRCamera","Warn","Name","WALKING_LOCOMOTION","Version","_locomotionTarget","getClassName","isCompatible","sessionMode","undefined","attach","scene","getEngine","detach","_onXRFrame","frame","pose","getViewerPose","baseReferenceSpace","handednessScalar","getScene","useRightHandedSystem","m","transform","matrix","_up","_position","TransformNormalToRef","getWorldMatrix","addInPlace","AddWebXRFeature","xrSessionManager"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRWalkingLocomotion.ts"],"sourcesContent":["import type { Engine } from \"../../Engines/engine\";\r\nimport { TmpVectors, Vector2, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { WebXRCamera } from \"../webXRCamera\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\n\r\nclass CircleBuffer {\r\n    private _samples: Array<Vector2> = [];\r\n    private _idx: number = 0;\r\n\r\n    constructor(numSamples: number, initializer?: () => Vector2) {\r\n        for (let idx = 0; idx < numSamples; ++idx) {\r\n            this._samples.push(initializer ? initializer() : Vector2.Zero());\r\n        }\r\n    }\r\n\r\n    public get length() {\r\n        return this._samples.length;\r\n    }\r\n\r\n    public push(x: number, y: number) {\r\n        this._idx = (this._idx + this._samples.length - 1) % this._samples.length;\r\n        this.at(0).copyFromFloats(x, y);\r\n    }\r\n\r\n    public at(idx: number) {\r\n        if (idx >= this._samples.length) {\r\n            throw new Error(\"Index out of bounds\");\r\n        }\r\n        return this._samples[(this._idx + idx) % this._samples.length];\r\n    }\r\n}\r\n\r\ninterface IDetectedStep {\r\n    leftApex: Vector2;\r\n    rightApex: Vector2;\r\n    currentPosition: Vector2;\r\n    currentStepDirection: \"left\" | \"right\";\r\n}\r\n\r\nclass FirstStepDetector {\r\n    private _samples = new CircleBuffer(20);\r\n    private _entropy = 0;\r\n\r\n    public onFirstStepDetected: Observable<IDetectedStep> = new Observable<IDetectedStep>();\r\n\r\n    public update(posX: number, posY: number, forwardX: number, forwardY: number) {\r\n        this._samples.push(posX, posY);\r\n        const origin = this._samples.at(0);\r\n\r\n        this._entropy *= this._entropyDecayFactor;\r\n        this._entropy += Vector2.Distance(origin, this._samples.at(1));\r\n        if (this._entropy > this._entropyThreshold) {\r\n            return;\r\n        }\r\n\r\n        let samePointIdx;\r\n        for (samePointIdx = this._samePointCheckStartIdx; samePointIdx < this._samples.length; ++samePointIdx) {\r\n            if (Vector2.DistanceSquared(origin, this._samples.at(samePointIdx)) < this._samePointSquaredDistanceThreshold) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (samePointIdx === this._samples.length) {\r\n            return;\r\n        }\r\n\r\n        let apexDistSquared = -1;\r\n        let apexIdx = 0;\r\n        for (let distSquared, idx = 1; idx < samePointIdx; ++idx) {\r\n            distSquared = Vector2.DistanceSquared(origin, this._samples.at(idx));\r\n            if (distSquared > apexDistSquared) {\r\n                apexIdx = idx;\r\n                apexDistSquared = distSquared;\r\n            }\r\n        }\r\n\r\n        if (apexDistSquared < this._apexSquaredDistanceThreshold) {\r\n            return;\r\n        }\r\n\r\n        const apex = this._samples.at(apexIdx);\r\n        const axis = apex.subtract(origin);\r\n        axis.normalize();\r\n\r\n        const vec = TmpVectors.Vector2[0];\r\n        let dot;\r\n        let sample;\r\n        let sumSquaredProjectionDistances = 0;\r\n        for (let idx = 1; idx < samePointIdx; ++idx) {\r\n            sample = this._samples.at(idx);\r\n            sample.subtractToRef(origin, vec);\r\n            dot = Vector2.Dot(axis, vec);\r\n            sumSquaredProjectionDistances += vec.lengthSquared() - dot * dot;\r\n        }\r\n\r\n        if (sumSquaredProjectionDistances > samePointIdx * this._squaredProjectionDistanceThreshold) {\r\n            return;\r\n        }\r\n\r\n        const forwardVec = TmpVectors.Vector3[0];\r\n        forwardVec.set(forwardX, forwardY, 0);\r\n        const axisVec = TmpVectors.Vector3[1];\r\n        axisVec.set(axis.x, axis.y, 0);\r\n        const isApexLeft = Vector3.Cross(forwardVec, axisVec).z > 0;\r\n        const leftApex = origin.clone();\r\n        const rightApex = origin.clone();\r\n        apex.subtractToRef(origin, axis);\r\n        if (isApexLeft) {\r\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, leftApex);\r\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, rightApex);\r\n        } else {\r\n            axis.scaleAndAddToRef(this._axisToApexExtendFactor, leftApex);\r\n            axis.scaleAndAddToRef(this._axisToApexShrinkFactor, rightApex);\r\n        }\r\n        this.onFirstStepDetected.notifyObservers({\r\n            leftApex: leftApex,\r\n            rightApex: rightApex,\r\n            currentPosition: origin,\r\n            currentStepDirection: isApexLeft ? \"right\" : \"left\",\r\n        });\r\n    }\r\n\r\n    public reset() {\r\n        for (let idx = 0; idx < this._samples.length; ++idx) {\r\n            this._samples.at(idx).copyFromFloats(0, 0);\r\n        }\r\n    }\r\n\r\n    private get _samePointCheckStartIdx() {\r\n        return Math.floor(this._samples.length / 3);\r\n    }\r\n\r\n    private get _samePointSquaredDistanceThreshold() {\r\n        return 0.03 * 0.03;\r\n    }\r\n\r\n    private get _apexSquaredDistanceThreshold() {\r\n        return 0.09 * 0.09;\r\n    }\r\n\r\n    private get _squaredProjectionDistanceThreshold() {\r\n        return 0.03 * 0.03;\r\n    }\r\n\r\n    private get _axisToApexShrinkFactor() {\r\n        return 0.8;\r\n    }\r\n\r\n    private get _axisToApexExtendFactor() {\r\n        return -1.6;\r\n    }\r\n\r\n    private get _entropyDecayFactor() {\r\n        return 0.93;\r\n    }\r\n\r\n    private get _entropyThreshold() {\r\n        return 0.4;\r\n    }\r\n}\r\n\r\nclass WalkingTracker {\r\n    private _leftApex = new Vector2();\r\n    private _rightApex = new Vector2();\r\n    private _currentPosition = new Vector2();\r\n    private _axis = new Vector2();\r\n    private _axisLength = -1;\r\n    private _forward = new Vector2();\r\n    private _steppingLeft = false;\r\n    private _t = -1;\r\n    private _maxT = -1;\r\n    private _maxTPosition = new Vector2();\r\n    private _vitality = 0;\r\n\r\n    public onMovement = new Observable<{ deltaT: number }>();\r\n    public onFootfall = new Observable<{ foot: \"left\" | \"right\" }>();\r\n\r\n    constructor(leftApex: Vector2, rightApex: Vector2, currentPosition: Vector2, currentStepDirection: \"left\" | \"right\") {\r\n        this._reset(leftApex, rightApex, currentPosition, currentStepDirection === \"left\");\r\n    }\r\n\r\n    private _reset(leftApex: Vector2, rightApex: Vector2, currentPosition: Vector2, steppingLeft: boolean) {\r\n        this._leftApex.copyFrom(leftApex);\r\n        this._rightApex.copyFrom(rightApex);\r\n        this._steppingLeft = steppingLeft;\r\n\r\n        if (this._steppingLeft) {\r\n            this._leftApex.subtractToRef(this._rightApex, this._axis);\r\n            this._forward.copyFromFloats(-this._axis.y, this._axis.x);\r\n        } else {\r\n            this._rightApex.subtractToRef(this._leftApex, this._axis);\r\n            this._forward.copyFromFloats(this._axis.y, -this._axis.x);\r\n        }\r\n        this._axisLength = this._axis.length();\r\n        this._forward.scaleInPlace(1 / this._axisLength);\r\n\r\n        this._updateTAndVitality(currentPosition.x, currentPosition.y);\r\n        this._maxT = this._t;\r\n        this._maxTPosition.copyFrom(currentPosition);\r\n\r\n        this._vitality = 1;\r\n    }\r\n\r\n    private _updateTAndVitality(x: number, y: number) {\r\n        this._currentPosition.copyFromFloats(x, y);\r\n\r\n        if (this._steppingLeft) {\r\n            this._currentPosition.subtractInPlace(this._rightApex);\r\n        } else {\r\n            this._currentPosition.subtractInPlace(this._leftApex);\r\n        }\r\n        const priorT = this._t;\r\n        const dot = Vector2.Dot(this._currentPosition, this._axis);\r\n        this._t = dot / (this._axisLength * this._axisLength);\r\n        const projDistSquared = this._currentPosition.lengthSquared() - (dot / this._axisLength) * (dot / this._axisLength);\r\n\r\n        // TODO: Extricate the magic.\r\n        this._vitality *= 0.92 - 100 * Math.max(projDistSquared - 0.0016, 0) + Math.max(this._t - priorT, 0);\r\n    }\r\n\r\n    public update(x: number, y: number) {\r\n        if (this._vitality < this._vitalityThreshold) {\r\n            return false;\r\n        }\r\n\r\n        const priorT = this._t;\r\n        this._updateTAndVitality(x, y);\r\n\r\n        if (this._t > this._maxT) {\r\n            this._maxT = this._t;\r\n            this._maxTPosition.copyFromFloats(x, y);\r\n        }\r\n\r\n        if (this._vitality < this._vitalityThreshold) {\r\n            return false;\r\n        }\r\n\r\n        if (this._t > priorT) {\r\n            this.onMovement.notifyObservers({ deltaT: this._t - priorT });\r\n\r\n            if (priorT < 0.5 && this._t >= 0.5) {\r\n                this.onFootfall.notifyObservers({ foot: this._steppingLeft ? \"left\" : \"right\" });\r\n            }\r\n        }\r\n\r\n        if (this._t < 0.95 * this._maxT) {\r\n            this._currentPosition.copyFromFloats(x, y);\r\n            if (this._steppingLeft) {\r\n                this._leftApex.copyFrom(this._maxTPosition);\r\n            } else {\r\n                this._rightApex.copyFrom(this._maxTPosition);\r\n            }\r\n            this._reset(this._leftApex, this._rightApex, this._currentPosition, !this._steppingLeft);\r\n        }\r\n\r\n        if (this._axisLength < 0.03) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private get _vitalityThreshold() {\r\n        return 0.1;\r\n    }\r\n\r\n    get forward() {\r\n        return this._forward;\r\n    }\r\n}\r\n\r\nclass Walker {\r\n    private _engine: Engine;\r\n    private _detector = new FirstStepDetector();\r\n    private _walker: Nullable<WalkingTracker> = null;\r\n    private _movement = new Vector2();\r\n    private _millisecondsSinceLastUpdate: number = Walker._MillisecondsPerUpdate;\r\n\r\n    private static get _MillisecondsPerUpdate(): number {\r\n        // 15 FPS\r\n        return 1000 / 15;\r\n    }\r\n\r\n    public movementThisFrame: Vector3 = Vector3.Zero();\r\n\r\n    constructor(engine: Engine) {\r\n        this._engine = engine;\r\n        this._detector.onFirstStepDetected.add((event) => {\r\n            if (!this._walker) {\r\n                this._walker = new WalkingTracker(event.leftApex, event.rightApex, event.currentPosition, event.currentStepDirection);\r\n                this._walker.onFootfall.add(() => {\r\n                    console.log(\"Footfall!\");\r\n                });\r\n                this._walker.onMovement.add((event) => {\r\n                    this._walker!.forward.scaleAndAddToRef(0.024 * event.deltaT, this._movement);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    public update(position: Vector3, forward: Vector3) {\r\n        forward.y = 0;\r\n        forward.normalize();\r\n\r\n        // Enforce reduced framerate\r\n        this._millisecondsSinceLastUpdate += this._engine.getDeltaTime();\r\n        if (this._millisecondsSinceLastUpdate >= Walker._MillisecondsPerUpdate) {\r\n            this._millisecondsSinceLastUpdate -= Walker._MillisecondsPerUpdate;\r\n            this._detector.update(position.x, position.z, forward.x, forward.z);\r\n            if (this._walker) {\r\n                const updated = this._walker.update(position.x, position.z);\r\n                if (!updated) {\r\n                    this._walker = null;\r\n                }\r\n            }\r\n            this._movement.scaleInPlace(0.85);\r\n        }\r\n\r\n        this.movementThisFrame.set(this._movement.x, 0, this._movement.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Options for the walking locomotion feature.\r\n */\r\nexport interface IWebXRWalkingLocomotionOptions {\r\n    /**\r\n     * The target to be moved by walking locomotion. This should be the transform node\r\n     * which is the root of the XR space (i.e., the WebXRCamera's parent node). However,\r\n     * for simple cases and legacy purposes, articulating the WebXRCamera itself is also\r\n     * supported as a deprecated feature.\r\n     */\r\n    locomotionTarget: WebXRCamera | TransformNode;\r\n}\r\n\r\n/**\r\n * A module that will enable VR locomotion by detecting when the user walks in place.\r\n */\r\nexport class WebXRWalkingLocomotion extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name.\r\n     */\r\n    public static get Name(): string {\r\n        return WebXRFeatureName.WALKING_LOCOMOTION;\r\n    }\r\n\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number has no external basis.\r\n     */\r\n    public static get Version(): number {\r\n        return 1;\r\n    }\r\n\r\n    private _sessionManager: WebXRSessionManager;\r\n    private _up: Vector3 = new Vector3();\r\n    private _forward: Vector3 = new Vector3();\r\n    private _position: Vector3 = new Vector3();\r\n    private _movement: Vector3 = new Vector3();\r\n    private _walker: Nullable<Walker>;\r\n\r\n    private _locomotionTarget: WebXRCamera | TransformNode;\r\n    private _isLocomotionTargetWebXRCamera: boolean;\r\n\r\n    /**\r\n     * The target to be articulated by walking locomotion.\r\n     * When the walking locomotion feature detects walking in place, this element's\r\n     * X and Z coordinates will be modified to reflect locomotion. This target should\r\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\r\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\r\n     * of the WebXRCamera directly and is thus discouraged.\r\n     */\r\n    public get locomotionTarget(): WebXRCamera | TransformNode {\r\n        return this._locomotionTarget;\r\n    }\r\n\r\n    /**\r\n     * The target to be articulated by walking locomotion.\r\n     * When the walking locomotion feature detects walking in place, this element's\r\n     * X and Z coordinates will be modified to reflect locomotion. This target should\r\n     * be either the XR space's origin (i.e., the parent node of the WebXRCamera) or\r\n     * the WebXRCamera itself. Note that the WebXRCamera path will modify the position\r\n     * of the WebXRCamera directly and is thus discouraged.\r\n     */\r\n    public set locomotionTarget(locomotionTarget: WebXRCamera | TransformNode) {\r\n        this._locomotionTarget = locomotionTarget;\r\n        this._isLocomotionTargetWebXRCamera = this._locomotionTarget.getClassName() === \"WebXRCamera\";\r\n    }\r\n\r\n    /**\r\n     * Construct a new Walking Locomotion feature.\r\n     * @param sessionManager manager for the current XR session\r\n     * @param options creation options, prominently including the vector target for locomotion\r\n     */\r\n    public constructor(sessionManager: WebXRSessionManager, options: IWebXRWalkingLocomotionOptions) {\r\n        super(sessionManager);\r\n        this._sessionManager = sessionManager;\r\n        this.locomotionTarget = options.locomotionTarget;\r\n        if (this._isLocomotionTargetWebXRCamera) {\r\n            Logger.Warn(\r\n                \"Using walking locomotion directly on a WebXRCamera may have unintended interactions with other XR techniques. Using an XR space parent is highly recommended\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether this feature is compatible with the current WebXR session.\r\n     * Walking locomotion is only compatible with \"immersive-vr\" sessions.\r\n     * @returns true if compatible, false otherwise\r\n     */\r\n    public isCompatible(): boolean {\r\n        return this._sessionManager.sessionMode === undefined || this._sessionManager.sessionMode === \"immersive-vr\";\r\n    }\r\n\r\n    /**\r\n     * Attaches the feature.\r\n     * Typically called automatically by the features manager.\r\n     * @returns true if attach succeeded, false otherwise\r\n     */\r\n    public attach(): boolean {\r\n        if (!this.isCompatible || !super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._walker = new Walker(this._sessionManager.scene.getEngine());\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Detaches the feature.\r\n     * Typically called automatically by the features manager.\r\n     * @returns true if detach succeeded, false otherwise\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        this._walker = null;\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame): void {\r\n        const pose = frame.getViewerPose(this._sessionManager.baseReferenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n\r\n        const handednessScalar = this.locomotionTarget.getScene().useRightHandedSystem ? 1 : -1;\r\n\r\n        const m = pose.transform.matrix;\r\n        this._up.copyFromFloats(m[4], m[5], handednessScalar * m[6]);\r\n        this._forward.copyFromFloats(m[8], m[9], handednessScalar * m[10]);\r\n        this._position.copyFromFloats(m[12], m[13], handednessScalar * m[14]);\r\n\r\n        // Compute the nape position\r\n        this._forward.scaleAndAddToRef(0.05, this._position);\r\n        this._up.scaleAndAddToRef(-0.05, this._position);\r\n        this._walker!.update(this._position, this._forward);\r\n        this._movement.copyFrom(this._walker!.movementThisFrame);\r\n        if (!this._isLocomotionTargetWebXRCamera) {\r\n            Vector3.TransformNormalToRef(this._movement, this.locomotionTarget.getWorldMatrix(), this._movement);\r\n        }\r\n        this.locomotionTarget.position.addInPlace(this._movement);\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRWalkingLocomotion.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRWalkingLocomotion(xrSessionManager, options);\r\n    },\r\n    WebXRWalkingLocomotion.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}