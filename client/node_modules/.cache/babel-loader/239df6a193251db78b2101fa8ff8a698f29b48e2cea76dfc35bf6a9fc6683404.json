{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags.js\";\nimport { IsBase64DataUrl } from \"../Misc/fileTools.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * Mode that determines how to handle old animation groups before loading new ones.\n */\nexport var SceneLoaderAnimationGroupLoadingMode;\n(function (SceneLoaderAnimationGroupLoadingMode) {\n  /**\n   * Reset all old animations to initial state then dispose them.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Clean\"] = 0] = \"Clean\";\n  /**\n   * Stop all old animations.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Stop\"] = 1] = \"Stop\";\n  /**\n   * Restart old animations from first frame.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"Sync\"] = 2] = \"Sync\";\n  /**\n   * Old animations remains untouched.\n   */\n  SceneLoaderAnimationGroupLoadingMode[SceneLoaderAnimationGroupLoadingMode[\"NoSync\"] = 3] = \"NoSync\";\n})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));\n/**\n * Class used to load scene from various file formats using registered plugins\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\n */\nexport class SceneLoader {\n  /**\n   * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\n   */\n  static get ForceFullSceneLoadingForIncremental() {\n    return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\n  }\n  static set ForceFullSceneLoadingForIncremental(value) {\n    SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\n  }\n  /**\n   * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\n   */\n  static get ShowLoadingScreen() {\n    return SceneLoaderFlags.ShowLoadingScreen;\n  }\n  static set ShowLoadingScreen(value) {\n    SceneLoaderFlags.ShowLoadingScreen = value;\n  }\n  /**\n   * Defines the current logging level (while loading the scene)\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static get loggingLevel() {\n    return SceneLoaderFlags.loggingLevel;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static set loggingLevel(value) {\n    SceneLoaderFlags.loggingLevel = value;\n  }\n  /**\n   * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\n   */\n  static get CleanBoneMatrixWeights() {\n    return SceneLoaderFlags.CleanBoneMatrixWeights;\n  }\n  static set CleanBoneMatrixWeights(value) {\n    SceneLoaderFlags.CleanBoneMatrixWeights = value;\n  }\n  /**\n   * Gets the default plugin (used to load Babylon files)\n   * @returns the .babylon plugin\n   */\n  static GetDefaultPlugin() {\n    return SceneLoader._RegisteredPlugins[\".babylon\"];\n  }\n  static _GetPluginForExtension(extension) {\n    const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\n    if (registeredPlugin) {\n      return registeredPlugin;\n    }\n    Logger.Warn(\"Unable to find a plugin to load \" + extension + \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\");\n    return SceneLoader.GetDefaultPlugin();\n  }\n  static _GetPluginForDirectLoad(data) {\n    for (const extension in SceneLoader._RegisteredPlugins) {\n      const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\n      if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n        return SceneLoader._RegisteredPlugins[extension];\n      }\n    }\n    return SceneLoader.GetDefaultPlugin();\n  }\n  static _GetPluginForFilename(sceneFilename) {\n    const queryStringPosition = sceneFilename.indexOf(\"?\");\n    if (queryStringPosition !== -1) {\n      sceneFilename = sceneFilename.substring(0, queryStringPosition);\n    }\n    const dotPosition = sceneFilename.lastIndexOf(\".\");\n    const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\n    return SceneLoader._GetPluginForExtension(extension);\n  }\n  static _GetDirectLoad(sceneFilename) {\n    if (sceneFilename.substr(0, 5) === \"data:\") {\n      return sceneFilename.substr(5);\n    }\n    return null;\n  }\n  static _FormatErrorMessage(fileInfo, message, exception) {\n    let errorMessage = \"Unable to load from \" + fileInfo.url;\n    if (message) {\n      errorMessage += `: ${message}`;\n    } else if (exception) {\n      errorMessage += `: ${exception}`;\n    }\n    return errorMessage;\n  }\n  static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension) {\n    const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\n    const registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.url) : SceneLoader._GetPluginForFilename(fileInfo.url);\n    let plugin;\n    if (registeredPlugin.plugin.createPlugin !== undefined) {\n      plugin = registeredPlugin.plugin.createPlugin();\n    } else {\n      plugin = registeredPlugin.plugin;\n    }\n    if (!plugin) {\n      throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\n    }\n    SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\n    // Check if we have a direct load url. If the plugin is registered to handle\n    // it or it's not a base64 data url, then pass it through the direct load path.\n    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {\n      if (plugin.directLoad) {\n        const result = plugin.directLoad(scene, directLoad);\n        if (result.then) {\n          result.then(data => {\n            onSuccess(plugin, data);\n          }).catch(error => {\n            onError(\"Error in directLoad of _loadData: \" + error, error);\n          });\n        } else {\n          onSuccess(plugin, result);\n        }\n      } else {\n        onSuccess(plugin, directLoad);\n      }\n      return plugin;\n    }\n    const useArrayBuffer = registeredPlugin.isBinary;\n    const dataCallback = (data, responseURL) => {\n      if (scene.isDisposed) {\n        onError(\"Scene has been disposed\");\n        return;\n      }\n      onSuccess(plugin, data, responseURL);\n    };\n    let request = null;\n    let pluginDisposed = false;\n    const onDisposeObservable = plugin.onDisposeObservable;\n    if (onDisposeObservable) {\n      onDisposeObservable.add(() => {\n        pluginDisposed = true;\n        if (request) {\n          request.abort();\n          request = null;\n        }\n        onDispose();\n      });\n    }\n    const manifestChecked = () => {\n      if (pluginDisposed) {\n        return;\n      }\n      const errorCallback = (request, exception) => {\n        onError(request === null || request === void 0 ? void 0 : request.statusText, exception);\n      };\n      const fileOrUrl = fileInfo.file || fileInfo.url;\n      request = plugin.loadFile ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback) : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\n    };\n    const engine = scene.getEngine();\n    let canUseOfflineSupport = engine.enableOfflineSupport;\n    if (canUseOfflineSupport) {\n      // Also check for exceptions\n      let exceptionFound = false;\n      for (const regex of scene.disableOfflineSupportExceptionRules) {\n        if (regex.test(fileInfo.url)) {\n          exceptionFound = true;\n          break;\n        }\n      }\n      canUseOfflineSupport = !exceptionFound;\n    }\n    if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\n      // Checking if a manifest file has been set for this scene and if offline mode has been requested\n      scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\n    } else {\n      manifestChecked();\n    }\n    return plugin;\n  }\n  static _GetFileInfo(rootUrl, sceneFilename) {\n    let url;\n    let name;\n    let file = null;\n    if (!sceneFilename) {\n      url = rootUrl;\n      name = Tools.GetFilename(rootUrl);\n      rootUrl = Tools.GetFolderPath(rootUrl);\n    } else if (sceneFilename.name) {\n      const sceneFile = sceneFilename;\n      url = `file:${sceneFile.name}`;\n      name = sceneFile.name;\n      file = sceneFile;\n    } else if (typeof sceneFilename === \"string\" && sceneFilename.startsWith(\"data:\")) {\n      url = sceneFilename;\n      name = \"\";\n    } else {\n      const filename = sceneFilename;\n      if (filename.substr(0, 1) === \"/\") {\n        Tools.Error(\"Wrong sceneFilename parameter\");\n        return null;\n      }\n      url = rootUrl + filename;\n      name = filename;\n    }\n    return {\n      url: url,\n      rootUrl: rootUrl,\n      name: name,\n      file: file\n    };\n  }\n  // Public functions\n  /**\n   * Gets a plugin that can load the given extension\n   * @param extension defines the extension to load\n   * @returns a plugin or null if none works\n   */\n  static GetPluginForExtension(extension) {\n    return SceneLoader._GetPluginForExtension(extension).plugin;\n  }\n  /**\n   * Gets a boolean indicating that the given extension can be loaded\n   * @param extension defines the extension to load\n   * @returns true if the extension is supported\n   */\n  static IsPluginForExtensionAvailable(extension) {\n    return !!SceneLoader._RegisteredPlugins[extension];\n  }\n  /**\n   * Adds a new plugin to the list of registered plugins\n   * @param plugin defines the plugin to add\n   */\n  static RegisterPlugin(plugin) {\n    if (typeof plugin.extensions === \"string\") {\n      const extension = plugin.extensions;\n      SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n        plugin: plugin,\n        isBinary: false\n      };\n    } else {\n      const extensions = plugin.extensions;\n      Object.keys(extensions).forEach(extension => {\n        SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\n          plugin: plugin,\n          isBinary: extensions[extension].isBinary\n        };\n      });\n    }\n  }\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static ImportMesh(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to import mesh to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback: \" + e, e);\n      }\n    } : undefined;\n    const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\n      scene.importedMeshesFiles.push(fileInfo.url);\n      if (onSuccess) {\n        try {\n          onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback: \" + e, e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {\n      if (plugin.rewriteRootURL) {\n        fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\n      }\n      if (plugin.importMesh) {\n        const syncedPlugin = plugin;\n        const meshes = new Array();\n        const particleSystems = new Array();\n        const skeletons = new Array();\n        if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler(meshes, particleSystems, skeletons, [], [], [], []);\n      } else {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(result => {\n          scene.loadingPluginName = plugin.name;\n          successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  }\n  /**\n   * Import meshes into a scene\n   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\n   */\n  static ImportMeshAsync(meshNames, rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\n        resolve({\n          meshes: meshes,\n          particleSystems: particleSystems,\n          skeletons: skeletons,\n          animationGroups: animationGroups,\n          transformNodes: transformNodes,\n          geometries: geometries,\n          lights: lights\n        });\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static Load(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!engine) {\n      Tools.Error(\"No engine available\");\n      return null;\n    }\n    return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\n  }\n  /**\n   * Load a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param engine is the instance of BABYLON.Engine to use to create the scene\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded scene\n   */\n  static LoadAsync(rootUrl, sceneFilename = \"\", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.Load(rootUrl, sceneFilename, engine, scene => {\n        resolve(scene);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static Append(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to append to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\n      this._ShowingLoadingScreen = true;\n      scene.getEngine().displayLoadingUI();\n      scene.executeWhenReady(() => {\n        scene.getEngine().hideLoadingUI();\n        this._ShowingLoadingScreen = false;\n      });\n    }\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n    const successHandler = () => {\n      if (onSuccess) {\n        try {\n          onSuccess(scene);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n      if (plugin.load) {\n        const syncedPlugin = plugin;\n        if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler();\n      } else {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {\n          scene.loadingPluginName = plugin.name;\n          successHandler();\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  }\n  /**\n   * Append a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The given scene\n   */\n  static AppendAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.Append(rootUrl, sceneFilename, scene, scene => {\n        resolve(scene);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded plugin\n   */\n  static LoadAssetContainer(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to load asset container to\");\n      return null;\n    }\n    const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\n    if (!fileInfo) {\n      return null;\n    }\n    const loadingToken = {};\n    scene.addPendingData(loadingToken);\n    const disposeHandler = () => {\n      scene.removePendingData(loadingToken);\n    };\n    const errorHandler = (message, exception) => {\n      const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\n      if (onError) {\n        onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\n      } else {\n        Logger.Error(errorMessage);\n        // should the exception be thrown?\n      }\n\n      disposeHandler();\n    };\n    const progressHandler = onProgress ? event => {\n      try {\n        onProgress(event);\n      } catch (e) {\n        errorHandler(\"Error in onProgress callback\", e);\n      }\n    } : undefined;\n    const successHandler = assets => {\n      if (onSuccess) {\n        try {\n          onSuccess(assets);\n        } catch (e) {\n          errorHandler(\"Error in onSuccess callback\", e);\n        }\n      }\n      scene.removePendingData(loadingToken);\n    };\n    return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {\n      if (plugin.loadAssetContainer) {\n        const syncedPlugin = plugin;\n        const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\n        if (!assetContainer) {\n          return;\n        }\n        scene.loadingPluginName = plugin.name;\n        successHandler(assetContainer);\n      } else if (plugin.loadAssetContainerAsync) {\n        const asyncedPlugin = plugin;\n        asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(assetContainer => {\n          scene.loadingPluginName = plugin.name;\n          successHandler(assetContainer);\n        }).catch(error => {\n          errorHandler(error.message, error);\n        });\n      } else {\n        errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\n      }\n    }, progressHandler, errorHandler, disposeHandler, pluginExtension);\n  }\n  /**\n   * Load a scene into an asset container\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\n   * @param scene is the instance of Scene to append to\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns The loaded asset container\n   */\n  static LoadAssetContainerAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, assetContainer => {\n        resolve(assetContainer);\n      }, onProgress, (scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   */\n  static ImportAnimations(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to load animations to\");\n      return;\n    }\n    if (overwriteAnimations) {\n      // Reset, stop and dispose all animations before loading new ones\n      for (const animatable of scene.animatables) {\n        animatable.reset();\n      }\n      scene.stopAllAnimations();\n      scene.animationGroups.slice().forEach(animationGroup => {\n        animationGroup.dispose();\n      });\n      const nodes = scene.getNodes();\n      nodes.forEach(node => {\n        if (node.animations) {\n          node.animations = [];\n        }\n      });\n    } else {\n      switch (animationGroupLoadingMode) {\n        case SceneLoaderAnimationGroupLoadingMode.Clean:\n          scene.animationGroups.slice().forEach(animationGroup => {\n            animationGroup.dispose();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.Stop:\n          scene.animationGroups.forEach(animationGroup => {\n            animationGroup.stop();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.Sync:\n          scene.animationGroups.forEach(animationGroup => {\n            animationGroup.reset();\n            animationGroup.restart();\n          });\n          break;\n        case SceneLoaderAnimationGroupLoadingMode.NoSync:\n          // nothing to do\n          break;\n        default:\n          Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\n          return;\n      }\n    }\n    const startingIndexForNewAnimatables = scene.animatables.length;\n    const onAssetContainerLoaded = container => {\n      container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\n      container.dispose();\n      scene.onAnimationFileImportedObservable.notifyObservers(scene);\n      if (onSuccess) {\n        onSuccess(scene);\n      }\n    };\n    this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\n  }\n  /**\n   * Import animations from a file into a scene\n   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\n   * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\n   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\n   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\n   * @param onSuccess a callback with the scene when import succeeds\n   * @param onProgress a callback with a progress event for each file being loaded\n   * @param onError a callback with the scene, a message, and possibly an exception when import fails\n   * @param pluginExtension the extension used to determine the plugin\n   * @returns the updated scene with imported animations\n   */\n  static ImportAnimationsAsync(rootUrl, sceneFilename = \"\", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onSuccess = null, onProgress = null,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  onError = null, pluginExtension = null) {\n    return new Promise((resolve, reject) => {\n      SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, _scene => {\n        resolve(_scene);\n      }, onProgress, (_scene, message, exception) => {\n        reject(exception || new Error(message));\n      }, pluginExtension);\n    });\n  }\n}\n/**\n * No logging while loading\n */\nSceneLoader.NO_LOGGING = 0;\n/**\n * Minimal logging while loading\n */\nSceneLoader.MINIMAL_LOGGING = 1;\n/**\n * Summary logging while loading\n */\nSceneLoader.SUMMARY_LOGGING = 2;\n/**\n * Detailed logging while loading\n */\nSceneLoader.DETAILED_LOGGING = 3;\n// Members\n/**\n * Event raised when a plugin is used to load a scene\n */\nSceneLoader.OnPluginActivatedObservable = new Observable();\nSceneLoader._RegisteredPlugins = {};\nSceneLoader._ShowingLoadingScreen = false;","map":{"version":3,"mappings":"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","names":["Tools","Observable","Scene","Engine","EngineStore","Logger","SceneLoaderFlags","IsBase64DataUrl","RuntimeError","ErrorCodes","SceneLoaderAnimationGroupLoadingMode","SceneLoader","ForceFullSceneLoadingForIncremental","value","ShowLoadingScreen","loggingLevel","CleanBoneMatrixWeights","GetDefaultPlugin","_RegisteredPlugins","_GetPluginForExtension","extension","registeredPlugin","Warn","_GetPluginForDirectLoad","data","plugin","canDirectLoad","_GetPluginForFilename","sceneFilename","queryStringPosition","indexOf","substring","dotPosition","lastIndexOf","length","toLowerCase","_GetDirectLoad","substr","_FormatErrorMessage","fileInfo","message","exception","errorMessage","url","_LoadData","scene","onSuccess","onProgress","onError","onDispose","pluginExtension","directLoad","createPlugin","undefined","OnPluginActivatedObservable","notifyObservers","result","then","catch","error","useArrayBuffer","isBinary","dataCallback","responseURL","isDisposed","request","pluginDisposed","onDisposeObservable","add","abort","manifestChecked","errorCallback","statusText","fileOrUrl","file","loadFile","_loadFile","engine","getEngine","canUseOfflineSupport","enableOfflineSupport","exceptionFound","regex","disableOfflineSupportExceptionRules","test","OfflineProviderFactory","offlineProvider","disableManifestCheck","_GetFileInfo","rootUrl","name","GetFilename","GetFolderPath","sceneFile","startsWith","filename","Error","GetPluginForExtension","IsPluginForExtensionAvailable","RegisterPlugin","extensions","Object","keys","forEach","ImportMesh","meshNames","LastCreatedScene","loadingToken","addPendingData","disposeHandler","removePendingData","errorHandler","SceneLoaderError","progressHandler","event","e","successHandler","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","importedMeshesFiles","push","rewriteRootURL","importMesh","syncedPlugin","Array","loadingPluginName","asyncedPlugin","importMeshAsync","ImportMeshAsync","Promise","resolve","reject","Load","LastCreatedEngine","Append","LoadAsync","_ShowingLoadingScreen","displayLoadingUI","executeWhenReady","hideLoadingUI","load","loadAsync","AppendAsync","LoadAssetContainer","assets","loadAssetContainer","assetContainer","loadAssetContainerAsync","LoadAssetContainerAsync","ImportAnimations","overwriteAnimations","animationGroupLoadingMode","Clean","targetConverter","animatable","animatables","reset","stopAllAnimations","slice","animationGroup","dispose","nodes","getNodes","node","animations","Stop","stop","Sync","restart","NoSync","startingIndexForNewAnimatables","onAssetContainerLoaded","container","mergeAnimationsTo","onAnimationFileImportedObservable","ImportAnimationsAsync","_scene"],"sourceRoot":"","sources":["../../../../lts/core/generated/Loading/sceneLoader.ts"],"sourcesContent":["import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { AnimationGroup } from \"../Animations/animationGroup\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SceneLoaderFlags } from \"./sceneLoaderFlags\";\r\nimport type { IFileRequest } from \"../Misc/fileRequest\";\r\nimport type { WebRequest } from \"../Misc/webRequest\";\r\nimport type { LoadFileError } from \"../Misc/fileTools\";\r\nimport { IsBase64DataUrl } from \"../Misc/fileTools\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\n/**\r\n * Type used for the success callback of ImportMesh\r\n */\r\nexport type SceneLoaderSuccessCallback = (\r\n    meshes: AbstractMesh[],\r\n    particleSystems: IParticleSystem[],\r\n    skeletons: Skeleton[],\r\n    animationGroups: AnimationGroup[],\r\n    transformNodes: TransformNode[],\r\n    geometries: Geometry[],\r\n    lights: Light[]\r\n) => void;\r\n\r\n/**\r\n * Interface used for the result of ImportMeshAsync\r\n */\r\nexport interface ISceneLoaderAsyncResult {\r\n    /**\r\n     * The array of loaded meshes\r\n     */\r\n    readonly meshes: AbstractMesh[];\r\n\r\n    /**\r\n     * The array of loaded particle systems\r\n     */\r\n    readonly particleSystems: IParticleSystem[];\r\n\r\n    /**\r\n     * The array of loaded skeletons\r\n     */\r\n    readonly skeletons: Skeleton[];\r\n\r\n    /**\r\n     * The array of loaded animation groups\r\n     */\r\n    readonly animationGroups: AnimationGroup[];\r\n\r\n    /**\r\n     * The array of loaded transform nodes\r\n     */\r\n    readonly transformNodes: TransformNode[];\r\n\r\n    /**\r\n     * The array of loaded geometries\r\n     */\r\n    readonly geometries: Geometry[];\r\n\r\n    /**\r\n     * The array of loaded lights\r\n     */\r\n    readonly lights: Light[];\r\n}\r\n\r\n/**\r\n * Interface used to represent data loading progression\r\n */\r\nexport interface ISceneLoaderProgressEvent {\r\n    /**\r\n     * Defines if data length to load can be evaluated\r\n     */\r\n    readonly lengthComputable: boolean;\r\n\r\n    /**\r\n     * Defines the loaded data length\r\n     */\r\n    readonly loaded: number;\r\n\r\n    /**\r\n     * Defines the data length to load\r\n     */\r\n    readonly total: number;\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugins to define supported file extensions\r\n */\r\nexport interface ISceneLoaderPluginExtensions {\r\n    /**\r\n     * Defines the list of supported extensions\r\n     */\r\n    [extension: string]: {\r\n        isBinary: boolean;\r\n    };\r\n}\r\n\r\n/**\r\n * Interface used by SceneLoader plugin factory\r\n */\r\nexport interface ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the factory\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Function called to create a new plugin\r\n     * @returns the new plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n}\r\n\r\n/**\r\n * Interface used to define the base of ISceneLoaderPlugin and ISceneLoaderPluginAsync\r\n */\r\nexport interface ISceneLoaderPluginBase {\r\n    /**\r\n     * The friendly name of this plugin.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The file extensions supported by this plugin.\r\n     */\r\n    extensions: string | ISceneLoaderPluginExtensions;\r\n\r\n    /**\r\n     * The callback called when loading from a url.\r\n     * @param scene scene loading this url\r\n     * @param fileOrUrl file or url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     */\r\n    loadFile?(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: any, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest;\r\n\r\n    /**\r\n     * The callback that returns true if the data can be directly loaded.\r\n     * @param data string containing the file data\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    canDirectLoad?(data: string): boolean;\r\n\r\n    /**\r\n     * The callback that returns the data to pass to the plugin if the data can be directly loaded.\r\n     * @param scene scene loading this data\r\n     * @param data string containing the data\r\n     * @returns data to pass to the plugin\r\n     */\r\n    directLoad?(scene: Scene, data: string): any;\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n}\r\n\r\n/**\r\n * Interface used to define a SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPlugin extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @param particleSystems The particle systems array to import into\r\n     * @param skeletons The skeletons array to import into\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    importMesh(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        meshes: AbstractMesh[],\r\n        particleSystems: IParticleSystem[],\r\n        skeletons: Skeleton[],\r\n        onError?: (message: string, exception?: any) => void\r\n    ): boolean;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    load(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): boolean;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onError The callback when import fails\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainer(scene: Scene, data: any, rootUrl: string, onError?: (message: string, exception?: any) => void): AssetContainer;\r\n}\r\n\r\n/**\r\n * Interface used to define an async SceneLoader plugin\r\n */\r\nexport interface ISceneLoaderPluginAsync extends ISceneLoaderPluginBase {\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded objects (e.g. meshes, particle systems, skeletons, animation groups, etc.)\r\n     */\r\n    importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult>;\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns Nothing\r\n     */\r\n    loadAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void>;\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param onProgress The callback when the load progresses\r\n     * @param fileName Defines the name of the file to load\r\n     * @returns The loaded asset container\r\n     */\r\n    loadAssetContainerAsync(scene: Scene, data: any, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<AssetContainer>;\r\n}\r\n\r\n/**\r\n * Mode that determines how to handle old animation groups before loading new ones.\r\n */\r\nexport enum SceneLoaderAnimationGroupLoadingMode {\r\n    /**\r\n     * Reset all old animations to initial state then dispose them.\r\n     */\r\n    Clean = 0,\r\n\r\n    /**\r\n     * Stop all old animations.\r\n     */\r\n    Stop = 1,\r\n\r\n    /**\r\n     * Restart old animations from first frame.\r\n     */\r\n    Sync = 2,\r\n\r\n    /**\r\n     * Old animations remains untouched.\r\n     */\r\n    NoSync = 3,\r\n}\r\n\r\n/**\r\n * Defines a plugin registered by the SceneLoader\r\n */\r\ninterface IRegisteredPlugin {\r\n    /**\r\n     * Defines the plugin to use\r\n     */\r\n    plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory;\r\n    /**\r\n     * Defines if the plugin supports binary data\r\n     */\r\n    isBinary: boolean;\r\n}\r\n\r\n/**\r\n * Defines file information\r\n */\r\ninterface IFileInfo {\r\n    /**\r\n     * Gets the file url\r\n     */\r\n    url: string;\r\n    /**\r\n     * Gets the root url\r\n     */\r\n    rootUrl: string;\r\n    /**\r\n     * Gets filename\r\n     */\r\n    name: string;\r\n    /**\r\n     * Gets the file\r\n     */\r\n    file: Nullable<File>;\r\n}\r\n\r\n/**\r\n * Class used to load scene from various file formats using registered plugins\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\r\n */\r\nexport class SceneLoader {\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly NO_LOGGING = Constants.SCENELOADER_NO_LOGGING;\r\n\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly MINIMAL_LOGGING = Constants.SCENELOADER_MINIMAL_LOGGING;\r\n\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SUMMARY_LOGGING = Constants.SCENELOADER_SUMMARY_LOGGING;\r\n\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly DETAILED_LOGGING = Constants.SCENELOADER_DETAILED_LOGGING;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data\r\n     */\r\n    public static get ForceFullSceneLoadingForIncremental() {\r\n        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;\r\n    }\r\n\r\n    public static set ForceFullSceneLoadingForIncremental(value: boolean) {\r\n        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene\r\n     */\r\n    public static get ShowLoadingScreen(): boolean {\r\n        return SceneLoaderFlags.ShowLoadingScreen;\r\n    }\r\n\r\n    public static set ShowLoadingScreen(value: boolean) {\r\n        SceneLoaderFlags.ShowLoadingScreen = value;\r\n    }\r\n\r\n    /**\r\n     * Defines the current logging level (while loading the scene)\r\n     * @ignorenaming\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static get loggingLevel(): number {\r\n        return SceneLoaderFlags.loggingLevel;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static set loggingLevel(value: number) {\r\n        SceneLoaderFlags.loggingLevel = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or set a boolean indicating if matrix weights must be cleaned upon loading\r\n     */\r\n    public static get CleanBoneMatrixWeights(): boolean {\r\n        return SceneLoaderFlags.CleanBoneMatrixWeights;\r\n    }\r\n\r\n    public static set CleanBoneMatrixWeights(value: boolean) {\r\n        SceneLoaderFlags.CleanBoneMatrixWeights = value;\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Event raised when a plugin is used to load a scene\r\n     */\r\n    public static OnPluginActivatedObservable = new Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>();\r\n\r\n    private static _RegisteredPlugins: { [extension: string]: IRegisteredPlugin } = {};\r\n\r\n    private static _ShowingLoadingScreen = false;\r\n\r\n    /**\r\n     * Gets the default plugin (used to load Babylon files)\r\n     * @returns the .babylon plugin\r\n     */\r\n    public static GetDefaultPlugin(): IRegisteredPlugin {\r\n        return SceneLoader._RegisteredPlugins[\".babylon\"];\r\n    }\r\n\r\n    private static _GetPluginForExtension(extension: string): IRegisteredPlugin {\r\n        const registeredPlugin = SceneLoader._RegisteredPlugins[extension];\r\n        if (registeredPlugin) {\r\n            return registeredPlugin;\r\n        }\r\n        Logger.Warn(\r\n            \"Unable to find a plugin to load \" +\r\n                extension +\r\n                \" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes\"\r\n        );\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForDirectLoad(data: string): IRegisteredPlugin {\r\n        for (const extension in SceneLoader._RegisteredPlugins) {\r\n            const plugin = SceneLoader._RegisteredPlugins[extension].plugin;\r\n\r\n            if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\r\n                return SceneLoader._RegisteredPlugins[extension];\r\n            }\r\n        }\r\n\r\n        return SceneLoader.GetDefaultPlugin();\r\n    }\r\n\r\n    private static _GetPluginForFilename(sceneFilename: string): IRegisteredPlugin {\r\n        const queryStringPosition = sceneFilename.indexOf(\"?\");\r\n\r\n        if (queryStringPosition !== -1) {\r\n            sceneFilename = sceneFilename.substring(0, queryStringPosition);\r\n        }\r\n\r\n        const dotPosition = sceneFilename.lastIndexOf(\".\");\r\n\r\n        const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();\r\n        return SceneLoader._GetPluginForExtension(extension);\r\n    }\r\n\r\n    private static _GetDirectLoad(sceneFilename: string): Nullable<string> {\r\n        if (sceneFilename.substr(0, 5) === \"data:\") {\r\n            return sceneFilename.substr(5);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _FormatErrorMessage(fileInfo: IFileInfo, message?: string, exception?: any): string {\r\n        let errorMessage = \"Unable to load from \" + fileInfo.url;\r\n\r\n        if (message) {\r\n            errorMessage += `: ${message}`;\r\n        } else if (exception) {\r\n            errorMessage += `: ${exception}`;\r\n        }\r\n\r\n        return errorMessage;\r\n    }\r\n\r\n    private static _LoadData(\r\n        fileInfo: IFileInfo,\r\n        scene: Scene,\r\n        onSuccess: (plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync, data: any, responseURL?: string) => void,\r\n        onProgress: ((event: ISceneLoaderProgressEvent) => void) | undefined,\r\n        onError: (message?: string, exception?: any) => void,\r\n        onDispose: () => void,\r\n        pluginExtension: Nullable<string>\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);\r\n        const registeredPlugin = pluginExtension\r\n            ? SceneLoader._GetPluginForExtension(pluginExtension)\r\n            : directLoad\r\n            ? SceneLoader._GetPluginForDirectLoad(fileInfo.url)\r\n            : SceneLoader._GetPluginForFilename(fileInfo.url);\r\n\r\n        let plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync;\r\n        if ((registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin !== undefined) {\r\n            plugin = (registeredPlugin.plugin as ISceneLoaderPluginFactory).createPlugin();\r\n        } else {\r\n            plugin = <any>registeredPlugin.plugin;\r\n        }\r\n\r\n        if (!plugin) {\r\n            throw \"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.\";\r\n        }\r\n\r\n        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);\r\n\r\n        // Check if we have a direct load url. If the plugin is registered to handle\r\n        // it or it's not a base64 data url, then pass it through the direct load path.\r\n        if (directLoad && ((plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url)) || !IsBase64DataUrl(fileInfo.url))) {\r\n            if (plugin.directLoad) {\r\n                const result = plugin.directLoad(scene, directLoad);\r\n                if (result.then) {\r\n                    result\r\n                        .then((data: any) => {\r\n                            onSuccess(plugin, data);\r\n                        })\r\n                        .catch((error: any) => {\r\n                            onError(\"Error in directLoad of _loadData: \" + error, error);\r\n                        });\r\n                } else {\r\n                    onSuccess(plugin, result);\r\n                }\r\n            } else {\r\n                onSuccess(plugin, directLoad);\r\n            }\r\n            return plugin;\r\n        }\r\n\r\n        const useArrayBuffer = registeredPlugin.isBinary;\r\n\r\n        const dataCallback = (data: any, responseURL?: string) => {\r\n            if (scene.isDisposed) {\r\n                onError(\"Scene has been disposed\");\r\n                return;\r\n            }\r\n\r\n            onSuccess(plugin, data, responseURL);\r\n        };\r\n\r\n        let request: Nullable<IFileRequest> = null;\r\n        let pluginDisposed = false;\r\n        const onDisposeObservable = (plugin as any).onDisposeObservable as Observable<ISceneLoaderPlugin | ISceneLoaderPluginAsync>;\r\n        if (onDisposeObservable) {\r\n            onDisposeObservable.add(() => {\r\n                pluginDisposed = true;\r\n\r\n                if (request) {\r\n                    request.abort();\r\n                    request = null;\r\n                }\r\n\r\n                onDispose();\r\n            });\r\n        }\r\n\r\n        const manifestChecked = () => {\r\n            if (pluginDisposed) {\r\n                return;\r\n            }\r\n\r\n            const errorCallback = (request?: WebRequest, exception?: LoadFileError) => {\r\n                onError(request?.statusText, exception);\r\n            };\r\n\r\n            const fileOrUrl = fileInfo.file || fileInfo.url;\r\n            request = plugin.loadFile\r\n                ? plugin.loadFile(scene, fileOrUrl, dataCallback, onProgress, useArrayBuffer, errorCallback)\r\n                : scene._loadFile(fileOrUrl, dataCallback, onProgress, true, useArrayBuffer, errorCallback);\r\n        };\r\n\r\n        const engine = scene.getEngine();\r\n        let canUseOfflineSupport = engine.enableOfflineSupport;\r\n        if (canUseOfflineSupport) {\r\n            // Also check for exceptions\r\n            let exceptionFound = false;\r\n            for (const regex of scene.disableOfflineSupportExceptionRules) {\r\n                if (regex.test(fileInfo.url)) {\r\n                    exceptionFound = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            canUseOfflineSupport = !exceptionFound;\r\n        }\r\n\r\n        if (canUseOfflineSupport && Engine.OfflineProviderFactory) {\r\n            // Checking if a manifest file has been set for this scene and if offline mode has been requested\r\n            scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);\r\n        } else {\r\n            manifestChecked();\r\n        }\r\n\r\n        return plugin;\r\n    }\r\n\r\n    private static _GetFileInfo(rootUrl: string, sceneFilename: string | File): Nullable<IFileInfo> {\r\n        let url: string;\r\n        let name: string;\r\n        let file: Nullable<File> = null;\r\n\r\n        if (!sceneFilename) {\r\n            url = rootUrl;\r\n            name = Tools.GetFilename(rootUrl);\r\n            rootUrl = Tools.GetFolderPath(rootUrl);\r\n        } else if ((sceneFilename as File).name) {\r\n            const sceneFile = sceneFilename as File;\r\n            url = `file:${sceneFile.name}`;\r\n            name = sceneFile.name;\r\n            file = sceneFile;\r\n        } else if (typeof sceneFilename === \"string\" && sceneFilename.startsWith(\"data:\")) {\r\n            url = sceneFilename;\r\n            name = \"\";\r\n        } else {\r\n            const filename = sceneFilename as string;\r\n            if (filename.substr(0, 1) === \"/\") {\r\n                Tools.Error(\"Wrong sceneFilename parameter\");\r\n                return null;\r\n            }\r\n\r\n            url = rootUrl + filename;\r\n            name = filename;\r\n        }\r\n\r\n        return {\r\n            url: url,\r\n            rootUrl: rootUrl,\r\n            name: name,\r\n            file: file,\r\n        };\r\n    }\r\n\r\n    // Public functions\r\n\r\n    /**\r\n     * Gets a plugin that can load the given extension\r\n     * @param extension defines the extension to load\r\n     * @returns a plugin or null if none works\r\n     */\r\n    public static GetPluginForExtension(extension: string): ISceneLoaderPlugin | ISceneLoaderPluginAsync | ISceneLoaderPluginFactory {\r\n        return SceneLoader._GetPluginForExtension(extension).plugin;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the given extension can be loaded\r\n     * @param extension defines the extension to load\r\n     * @returns true if the extension is supported\r\n     */\r\n    public static IsPluginForExtensionAvailable(extension: string): boolean {\r\n        return !!SceneLoader._RegisteredPlugins[extension];\r\n    }\r\n\r\n    /**\r\n     * Adds a new plugin to the list of registered plugins\r\n     * @param plugin defines the plugin to add\r\n     */\r\n    public static RegisterPlugin(plugin: ISceneLoaderPlugin | ISceneLoaderPluginAsync): void {\r\n        if (typeof plugin.extensions === \"string\") {\r\n            const extension = <string>plugin.extensions;\r\n            SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\r\n                plugin: plugin,\r\n                isBinary: false,\r\n            };\r\n        } else {\r\n            const extensions = <ISceneLoaderPluginExtensions>plugin.extensions;\r\n            Object.keys(extensions).forEach((extension) => {\r\n                SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {\r\n                    plugin: plugin,\r\n                    isBinary: extensions[extension].isBinary,\r\n                };\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static ImportMesh(\r\n        meshNames: any,\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<SceneLoaderSuccessCallback> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to import mesh to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene.addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback: \" + e, e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler: SceneLoaderSuccessCallback = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n            scene.importedMeshesFiles.push(fileInfo.url);\r\n\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback: \" + e, e);\r\n                }\r\n            }\r\n\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data, responseURL) => {\r\n                if (plugin.rewriteRootURL) {\r\n                    fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);\r\n                }\r\n\r\n                if ((<any>plugin).importMesh) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    const meshes = new Array<AbstractMesh>();\r\n                    const particleSystems = new Array<IParticleSystem>();\r\n                    const skeletons = new Array<Skeleton>();\r\n\r\n                    if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(meshes, particleSystems, skeletons, [], [], [], []);\r\n                } else {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then((result) => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler(\r\n                                result.meshes,\r\n                                result.particleSystems,\r\n                                result.skeletons,\r\n                                result.animationGroups,\r\n                                result.transformNodes,\r\n                                result.geometries,\r\n                                result.lights\r\n                            );\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Import meshes into a scene\r\n     * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups\r\n     */\r\n    public static ImportMeshAsync(\r\n        meshNames: any,\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportMesh(\r\n                meshNames,\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: particleSystems,\r\n                        skeletons: skeletons,\r\n                        animationGroups: animationGroups,\r\n                        transformNodes: transformNodes,\r\n                        geometries: geometries,\r\n                        lights: lights,\r\n                    });\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Load(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        engine: Nullable<Engine> = EngineStore.LastCreatedEngine,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!engine) {\r\n            Tools.Error(\"No engine available\");\r\n            return null;\r\n        }\r\n\r\n        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Load a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param engine is the instance of BABYLON.Engine to use to create the scene\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded scene\r\n     */\r\n    public static LoadAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        engine: Nullable<Engine> = EngineStore.LastCreatedEngine,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Load(\r\n                rootUrl,\r\n                sceneFilename,\r\n                engine,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static Append(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to append to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene.addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {\r\n            this._ShowingLoadingScreen = true;\r\n            scene.getEngine().displayLoadingUI();\r\n            scene.executeWhenReady(() => {\r\n                scene.getEngine().hideLoadingUI();\r\n                this._ShowingLoadingScreen = false;\r\n            });\r\n        }\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback\", e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler = () => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(scene);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data) => {\r\n                if ((<any>plugin).load) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler();\r\n                } else {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then(() => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler();\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Append a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The given scene\r\n     */\r\n    public static AppendAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.Append(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (scene) => {\r\n                    resolve(scene);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded plugin\r\n     */\r\n    public static LoadAssetContainer(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onSuccess: Nullable<(assets: AssetContainer) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Nullable<ISceneLoaderPlugin | ISceneLoaderPluginAsync> {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load asset container to\");\r\n            return null;\r\n        }\r\n\r\n        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);\r\n        if (!fileInfo) {\r\n            return null;\r\n        }\r\n\r\n        const loadingToken = {};\r\n        scene.addPendingData(loadingToken);\r\n\r\n        const disposeHandler = () => {\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);\r\n\r\n            if (onError) {\r\n                onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));\r\n            } else {\r\n                Logger.Error(errorMessage);\r\n                // should the exception be thrown?\r\n            }\r\n\r\n            disposeHandler();\r\n        };\r\n\r\n        const progressHandler = onProgress\r\n            ? (event: ISceneLoaderProgressEvent) => {\r\n                  try {\r\n                      onProgress(event);\r\n                  } catch (e) {\r\n                      errorHandler(\"Error in onProgress callback\", e);\r\n                  }\r\n              }\r\n            : undefined;\r\n\r\n        const successHandler = (assets: AssetContainer) => {\r\n            if (onSuccess) {\r\n                try {\r\n                    onSuccess(assets);\r\n                } catch (e) {\r\n                    errorHandler(\"Error in onSuccess callback\", e);\r\n                }\r\n            }\r\n\r\n            scene.removePendingData(loadingToken);\r\n        };\r\n\r\n        return SceneLoader._LoadData(\r\n            fileInfo,\r\n            scene,\r\n            (plugin, data) => {\r\n                if ((<any>plugin).loadAssetContainer) {\r\n                    const syncedPlugin = <ISceneLoaderPlugin>plugin;\r\n                    const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);\r\n                    if (!assetContainer) {\r\n                        return;\r\n                    }\r\n\r\n                    scene.loadingPluginName = plugin.name;\r\n                    successHandler(assetContainer);\r\n                } else if ((<any>plugin).loadAssetContainerAsync) {\r\n                    const asyncedPlugin = <ISceneLoaderPluginAsync>plugin;\r\n                    asyncedPlugin\r\n                        .loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name)\r\n                        .then((assetContainer) => {\r\n                            scene.loadingPluginName = plugin.name;\r\n                            successHandler(assetContainer);\r\n                        })\r\n                        .catch((error) => {\r\n                            errorHandler(error.message, error);\r\n                        });\r\n                } else {\r\n                    errorHandler(\"LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.\");\r\n                }\r\n            },\r\n            progressHandler,\r\n            errorHandler,\r\n            disposeHandler,\r\n            pluginExtension\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Load a scene into an asset container\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene (default: empty string)\r\n     * @param scene is the instance of Scene to append to\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns The loaded asset container\r\n     */\r\n    public static LoadAssetContainerAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<AssetContainer> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.LoadAssetContainer(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                (assetContainer) => {\r\n                    resolve(assetContainer);\r\n                },\r\n                onProgress,\r\n                (scene, message, exception) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     */\r\n    public static ImportAnimations(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        overwriteAnimations = true,\r\n        animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n        targetConverter: Nullable<(target: any) => any> = null,\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): void {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to load animations to\");\r\n            return;\r\n        }\r\n\r\n        if (overwriteAnimations) {\r\n            // Reset, stop and dispose all animations before loading new ones\r\n            for (const animatable of scene.animatables) {\r\n                animatable.reset();\r\n            }\r\n            scene.stopAllAnimations();\r\n            scene.animationGroups.slice().forEach((animationGroup) => {\r\n                animationGroup.dispose();\r\n            });\r\n            const nodes = scene.getNodes();\r\n            nodes.forEach((node) => {\r\n                if (node.animations) {\r\n                    node.animations = [];\r\n                }\r\n            });\r\n        } else {\r\n            switch (animationGroupLoadingMode) {\r\n                case SceneLoaderAnimationGroupLoadingMode.Clean:\r\n                    scene.animationGroups.slice().forEach((animationGroup) => {\r\n                        animationGroup.dispose();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Stop:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.stop();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.Sync:\r\n                    scene.animationGroups.forEach((animationGroup) => {\r\n                        animationGroup.reset();\r\n                        animationGroup.restart();\r\n                    });\r\n                    break;\r\n                case SceneLoaderAnimationGroupLoadingMode.NoSync:\r\n                    // nothing to do\r\n                    break;\r\n                default:\r\n                    Logger.Error(\"Unknown animation group loading mode value '\" + animationGroupLoadingMode + \"'\");\r\n                    return;\r\n            }\r\n        }\r\n\r\n        const startingIndexForNewAnimatables = scene.animatables.length;\r\n\r\n        const onAssetContainerLoaded = (container: AssetContainer) => {\r\n            container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);\r\n\r\n            container.dispose();\r\n\r\n            scene.onAnimationFileImportedObservable.notifyObservers(scene);\r\n\r\n            if (onSuccess) {\r\n                onSuccess(scene);\r\n            }\r\n        };\r\n\r\n        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);\r\n    }\r\n\r\n    /**\r\n     * Import animations from a file into a scene\r\n     * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)\r\n     * @param sceneFilename a string that defines the name of the scene file or starts with \"data:\" following by the stringified version of the scene or a File object (default: empty string)\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise\r\n     * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones\r\n     * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)\r\n     * @param onSuccess a callback with the scene when import succeeds\r\n     * @param onProgress a callback with a progress event for each file being loaded\r\n     * @param onError a callback with the scene, a message, and possibly an exception when import fails\r\n     * @param pluginExtension the extension used to determine the plugin\r\n     * @returns the updated scene with imported animations\r\n     */\r\n    public static ImportAnimationsAsync(\r\n        rootUrl: string,\r\n        sceneFilename: string | File = \"\",\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        overwriteAnimations = true,\r\n        animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean,\r\n        targetConverter: Nullable<(target: any) => any> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onSuccess: Nullable<(scene: Scene) => void> = null,\r\n        onProgress: Nullable<(event: ISceneLoaderProgressEvent) => void> = null,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        onError: Nullable<(scene: Scene, message: string, exception?: any) => void> = null,\r\n        pluginExtension: Nullable<string> = null\r\n    ): Promise<Scene> {\r\n        return new Promise((resolve, reject) => {\r\n            SceneLoader.ImportAnimations(\r\n                rootUrl,\r\n                sceneFilename,\r\n                scene,\r\n                overwriteAnimations,\r\n                animationGroupLoadingMode,\r\n                targetConverter,\r\n                (_scene: Scene) => {\r\n                    resolve(_scene);\r\n                },\r\n                onProgress,\r\n                (_scene: Scene, message: string, exception: any) => {\r\n                    reject(exception || new Error(message));\r\n                },\r\n                pluginExtension\r\n            );\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}