{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\n/**\n * Particle emitter emitting particles from a custom list of positions.\n */\nexport class CustomParticleEmitter {\n  /**\n   * Creates a new instance CustomParticleEmitter\n   */\n  constructor() {\n    /**\n     * Gets or sets the position generator that will create the initial position of each particle.\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\n     */\n    this.particlePositionGenerator = () => {};\n    /**\n     * Gets or sets the destination generator that will create the final destination of each particle.\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\n     */\n    this.particleDestinationGenerator = () => {};\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    const tmpVector = TmpVectors.Vector3[0];\n    if (this.particleDestinationGenerator) {\n      this.particleDestinationGenerator(-1, particle, tmpVector);\n      // Get direction\n      const diffVector = TmpVectors.Vector3[1];\n      tmpVector.subtractToRef(particle.position, diffVector);\n      diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\n    } else {\n      tmpVector.set(0, 0, 0);\n    }\n    if (isLocal) {\n      directionToUpdate.copyFrom(tmpVector);\n      return;\n    }\n    Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const tmpVector = TmpVectors.Vector3[0];\n    if (this.particlePositionGenerator) {\n      this.particlePositionGenerator(-1, particle, tmpVector);\n    } else {\n      tmpVector.set(0, 0, 0);\n    }\n    if (isLocal) {\n      positionToUpdate.copyFrom(tmpVector);\n      return;\n    }\n    Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new CustomParticleEmitter();\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  applyToShader(uboOrEffect) {}\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  buildUniformLayout(ubo) {}\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define CUSTOMEMITTER\";\n  }\n  /**\n   * Returns the string \"PointParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"CustomParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  parse(serializationObject) {}\n}","map":{"version":3,"mappings":"AAAA,SAASA,UAAU,QAAQ,0BAAwB;AAEnD,SAASC,OAAO,EAAEC,UAAU,QAAQ,4BAA0B;AAM9D;;;AAGA,OAAM,MAAOC,qBAAqB;EAa9B;;;EAGAC;IAfA;;;;IAIO,8BAAyB,GAAgF,MAAK,CAAE,CAAC;IAExH;;;;IAIO,iCAA4B,GAAmF,MAAK,CAAE,CAAC;EAK/G;EAEf;;;;;;;EAOOC,sBAAsB,CAACC,WAAmB,EAAEC,iBAA0B,EAAEC,QAAkB,EAAEC,OAAgB;IAC/G,MAAMC,SAAS,GAAGR,UAAU,CAACD,OAAO,CAAC,CAAC,CAAC;IAEvC,IAAI,IAAI,CAACU,4BAA4B,EAAE;MACnC,IAAI,CAACA,4BAA4B,CAAC,CAAC,CAAC,EAAEH,QAAQ,EAAEE,SAAS,CAAC;MAE1D;MACA,MAAME,UAAU,GAAGV,UAAU,CAACD,OAAO,CAAC,CAAC,CAAC;MACxCS,SAAS,CAACG,aAAa,CAACL,QAAQ,CAACM,QAAQ,EAAEF,UAAU,CAAC;MAEtDA,UAAU,CAACG,UAAU,CAAC,CAAC,GAAGP,QAAQ,CAACQ,QAAQ,EAAEN,SAAS,CAAC;KAC1D,MAAM;MACHA,SAAS,CAACO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAG1B,IAAIR,OAAO,EAAE;MACTF,iBAAiB,CAACW,QAAQ,CAACR,SAAS,CAAC;MACrC;;IAGJT,OAAO,CAACkB,oBAAoB,CAACT,SAAS,EAAEJ,WAAW,EAAEC,iBAAiB,CAAC;EAC3E;EAEA;;;;;;;EAOOa,qBAAqB,CAACd,WAAmB,EAAEe,gBAAyB,EAAEb,QAAkB,EAAEC,OAAgB;IAC7G,MAAMC,SAAS,GAAGR,UAAU,CAACD,OAAO,CAAC,CAAC,CAAC;IAEvC,IAAI,IAAI,CAACqB,yBAAyB,EAAE;MAChC,IAAI,CAACA,yBAAyB,CAAC,CAAC,CAAC,EAAEd,QAAQ,EAAEE,SAAS,CAAC;KAC1D,MAAM;MACHA,SAAS,CAACO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAG1B,IAAIR,OAAO,EAAE;MACTY,gBAAgB,CAACH,QAAQ,CAACR,SAAS,CAAC;MACpC;;IAGJT,OAAO,CAACsB,yBAAyB,CAACb,SAAS,EAAEJ,WAAW,EAAEe,gBAAgB,CAAC;EAC/E;EAEA;;;;EAIOG,KAAK;IACR,MAAMC,MAAM,GAAG,IAAItB,qBAAqB,EAAE;IAE1CH,UAAU,CAAC0B,QAAQ,CAAC,IAAI,EAAED,MAAM,CAAC;IAEjC,OAAOA,MAAM;EACjB;EAEA;;;;EAIA;EACOE,aAAa,CAACC,WAA8C,GAAS;EAE5E;;;;EAIA;EACOC,kBAAkB,CAACC,GAAkB,GAAS;EAErD;;;;EAIOC,gBAAgB;IACnB,OAAO,uBAAuB;EAClC;EAEA;;;;EAIOC,YAAY;IACf,OAAO,uBAAuB;EAClC;EAEA;;;;EAIOC,SAAS;IACZ,MAAMC,mBAAmB,GAAQ,EAAE;IAEnCA,mBAAmB,CAACC,IAAI,GAAG,IAAI,CAACH,YAAY,EAAE;IAE9C,OAAOE,mBAAmB;EAC9B;EAEA;;;;EAIA;EACOE,KAAK,CAACF,mBAAwB,GAAS","names":["DeepCopier","Vector3","TmpVectors","CustomParticleEmitter","constructor","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","tmpVector","particleDestinationGenerator","diffVector","subtractToRef","position","scaleToRef","lifeTime","set","copyFrom","TransformNormalToRef","startPositionFunction","positionToUpdate","particlePositionGenerator","TransformCoordinatesToRef","clone","newOne","DeepCopy","applyToShader","uboOrEffect","buildUniformLayout","ubo","getEffectDefines","getClassName","serialize","serializationObject","type","parse"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/EmitterTypes/customParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Particle } from \"../particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from a custom list of positions.\r\n */\r\nexport class CustomParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Gets or sets the position generator that will create the initial position of each particle.\r\n     * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particlePositionGenerator: (index: number, particle: Nullable<Particle>, outPosition: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Gets or sets the destination generator that will create the final destination of each particle.\r\n     *  * Index will be provided when used with GPU particle. Particle will be provided when used with CPU particles\r\n     */\r\n    public particleDestinationGenerator: (index: number, particle: Nullable<Particle>, outDestination: Vector3) => void = () => {};\r\n\r\n    /**\r\n     * Creates a new instance CustomParticleEmitter\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particleDestinationGenerator) {\r\n            this.particleDestinationGenerator(-1, particle, tmpVector);\r\n\r\n            // Get direction\r\n            const diffVector = TmpVectors.Vector3[1];\r\n            tmpVector.subtractToRef(particle.position, diffVector);\r\n\r\n            diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const tmpVector = TmpVectors.Vector3[0];\r\n\r\n        if (this.particlePositionGenerator) {\r\n            this.particlePositionGenerator(-1, particle, tmpVector);\r\n        } else {\r\n            tmpVector.set(0, 0, 0);\r\n        }\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFrom(tmpVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CustomParticleEmitter {\r\n        const newOne = new CustomParticleEmitter();\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {}\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public buildUniformLayout(ubo: UniformBuffer): void {}\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CUSTOMEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CustomParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public parse(serializationObject: any): void {}\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}