{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { Light } from \"@babylonjs/core/Lights/light.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"KHR_lights_punctual\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_lights {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n    delete this._lights;\n  }\n  /** @internal */\n  onLoading() {\n    const extensions = this._loader.gltf.extensions;\n    if (extensions && extensions[this.name]) {\n      const extension = extensions[this.name];\n      this._lights = extension.lights;\n      ArrayItem.Assign(this._lights);\n    }\n  }\n  /**\n   * @internal\n   */\n  loadNodeAsync(context, node, assign) {\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n      return this._loader.loadNodeAsync(context, node, babylonMesh => {\n        let babylonLight;\n        const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n        const name = light.name || babylonMesh.name;\n        this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\n        switch (light.type) {\n          case \"directional\" /* DIRECTIONAL */:\n            {\n              babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\n              break;\n            }\n          case \"point\" /* POINT */:\n            {\n              babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\n              break;\n            }\n          case \"spot\" /* SPOT */:\n            {\n              const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\n              babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;\n              babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;\n              babylonLight = babylonSpotLight;\n              break;\n            }\n          default:\n            {\n              this._loader.babylonScene._blockEntityCollection = false;\n              throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\n            }\n        }\n        babylonLight._parentContainer = this._loader._assetContainer;\n        this._loader.babylonScene._blockEntityCollection = false;\n        light._babylonLight = babylonLight;\n        babylonLight.falloffType = Light.FALLOFF_GLTF;\n        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n        babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n        babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\n        babylonLight.parent = babylonMesh;\n        this._loader._babylonLights.push(babylonLight);\n        GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n        assign(babylonMesh);\n      });\n    });\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new KHR_lights(loader));","map":{"version":3,"mappings":"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","names":["Vector3","Color3","DirectionalLight","PointLight","SpotLight","Light","GLTFLoader","ArrayItem","NAME","KHR_lights","constructor","loader","_loader","enabled","isExtensionUsed","dispose","_lights","onLoading","extensions","gltf","name","extension","lights","Assign","loadNodeAsync","context","node","assign","LoadExtensionAsync","extensionContext","babylonMesh","babylonLight","light","Get","babylonScene","_blockEntityCollection","_assetContainer","type","Backward","Zero","babylonSpotLight","angle","spot","outerConeAngle","Math","PI","innerAngle","innerConeAngle","Error","_parentContainer","_babylonLight","falloffType","FALLOFF_GLTF","diffuse","color","FromArray","White","intensity","undefined","range","Number","MAX_VALUE","parent","_babylonLights","push","AddPointerMetadata","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_lights_punctual.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IKHRLightsPunctual_LightReference } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { INode, IKHRLightsPunctual_Light } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IKHRLightsPunctual_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as any;\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRLightsPunctual_LightReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.type) {\r\n                    case KHRLightsPunctual_LightType.DIRECTIONAL: {\r\n                        babylonLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.POINT: {\r\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.SPOT: {\r\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\r\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\r\n                        babylonLight = babylonSpotLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonLight;\r\n\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\r\n                babylonLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_lights(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}