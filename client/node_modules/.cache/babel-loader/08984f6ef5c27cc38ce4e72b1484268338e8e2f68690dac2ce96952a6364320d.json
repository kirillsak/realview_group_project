{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\n * @param markerOpen opening marker\n * @param markerClose closing marker\n * @param block code block to parse\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\n */\nexport function ExtractBetweenMarkers(markerOpen, markerClose, block, startIndex) {\n  let currPos = startIndex,\n    openMarkers = 0,\n    waitForChar = \"\";\n  while (currPos < block.length) {\n    const currChar = block.charAt(currPos);\n    if (!waitForChar) {\n      switch (currChar) {\n        case markerOpen:\n          openMarkers++;\n          break;\n        case markerClose:\n          openMarkers--;\n          break;\n        case '\"':\n        case \"'\":\n        case \"`\":\n          waitForChar = currChar;\n          break;\n        case \"/\":\n          if (currPos + 1 < block.length) {\n            const nextChar = block.charAt(currPos + 1);\n            if (nextChar === \"/\") {\n              waitForChar = \"\\n\";\n            } else if (nextChar === \"*\") {\n              waitForChar = \"*/\";\n            }\n          }\n          break;\n      }\n    } else {\n      if (currChar === waitForChar) {\n        if (waitForChar === '\"' || waitForChar === \"'\") {\n          block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n        } else {\n          waitForChar = \"\";\n        }\n      } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n        block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n        if (waitForChar === \"\") {\n          currPos++;\n        }\n      }\n    }\n    currPos++;\n    if (openMarkers === 0) {\n      break;\n    }\n  }\n  return openMarkers === 0 ? currPos - 1 : -1;\n}\n/**\n * Parses a string and skip whitespaces\n * @param s string to parse\n * @param index index where to start parsing\n * @returns the index after all whitespaces have been skipped\n */\nexport function SkipWhitespaces(s, index) {\n  while (index < s.length) {\n    const c = s[index];\n    if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\n      break;\n    }\n    index++;\n  }\n  return index;\n}\n/**\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\n * @param c character to check\n * @returns true if the character is an identifier character\n */\nexport function IsIdentifierChar(c) {\n  const v = c.charCodeAt(0);\n  return v >= 48 && v <= 57 ||\n  // 0-9\n  v >= 65 && v <= 90 ||\n  // A-Z\n  v >= 97 && v <= 122 ||\n  // a-z\n  v == 95; // _\n}\n/**\n * Removes the comments of a code block\n * @param block code block to parse\n * @returns block with the comments removed\n */\nexport function RemoveComments(block) {\n  let currPos = 0,\n    waitForChar = \"\",\n    inComments = false;\n  const s = [];\n  while (currPos < block.length) {\n    const currChar = block.charAt(currPos);\n    if (!waitForChar) {\n      switch (currChar) {\n        case '\"':\n        case \"'\":\n        case \"`\":\n          waitForChar = currChar;\n          break;\n        case \"/\":\n          if (currPos + 1 < block.length) {\n            const nextChar = block.charAt(currPos + 1);\n            if (nextChar === \"/\") {\n              waitForChar = \"\\n\";\n              inComments = true;\n            } else if (nextChar === \"*\") {\n              waitForChar = \"*/\";\n              inComments = true;\n            }\n          }\n          break;\n      }\n      if (!inComments) {\n        s.push(currChar);\n      }\n    } else {\n      if (currChar === waitForChar) {\n        if (waitForChar === '\"' || waitForChar === \"'\") {\n          block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\n          s.push(currChar);\n        } else {\n          waitForChar = \"\";\n          inComments = false;\n        }\n      } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\n        block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\n        if (waitForChar === \"\") {\n          inComments = false;\n          currPos++;\n        }\n      } else {\n        if (!inComments) {\n          s.push(currChar);\n        }\n      }\n    }\n    currPos++;\n  }\n  return s.join(\"\");\n}\n/**\n * Finds the first occurrence of a character in a string going backward\n * @param s the string to parse\n * @param index starting index in the string\n * @param c the character to find\n * @returns the index of the character if found, else -1\n */\nexport function FindBackward(s, index, c) {\n  while (index >= 0 && s.charAt(index) !== c) {\n    index--;\n  }\n  return index;\n}\n/**\n * Escapes a string so that it is usable as a regular expression\n * @param s string to escape\n * @returns escaped string\n */\nexport function EscapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}","map":{"version":3,"mappings":"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","names":["ExtractBetweenMarkers","markerOpen","markerClose","block","startIndex","currPos","openMarkers","waitForChar","length","currChar","charAt","nextChar","SkipWhitespaces","s","index","c","IsIdentifierChar","v","charCodeAt","RemoveComments","inComments","push","join","FindBackward","EscapeRegExp","replace"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/codeStringParsingTools.ts"],"sourcesContent":["/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}