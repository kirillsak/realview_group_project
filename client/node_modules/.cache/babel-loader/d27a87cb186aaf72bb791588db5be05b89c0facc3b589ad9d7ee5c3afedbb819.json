{"ast":null,"code":"/**\n * This class implement a typical dictionary using a string as key and the generic type T as value.\n * The underlying implementation relies on an associative array to ensure the best performances.\n * The value can be anything including 'null' but except 'undefined'\n */\nexport class StringDictionary {\n  constructor() {\n    this._count = 0;\n    this._data = {};\n  }\n  /**\n   * This will clear this dictionary and copy the content from the 'source' one.\n   * If the T value is a custom object, it won't be copied/cloned, the same object will be used\n   * @param source the dictionary to take the content from and copy to this dictionary\n   */\n  copyFrom(source) {\n    this.clear();\n    source.forEach((t, v) => this.add(t, v));\n  }\n  /**\n   * Get a value based from its key\n   * @param key the given key to get the matching value from\n   * @returns the value if found, otherwise undefined is returned\n   */\n  get(key) {\n    const val = this._data[key];\n    if (val !== undefined) {\n      return val;\n    }\n    return undefined;\n  }\n  /**\n   * Get a value from its key or add it if it doesn't exist.\n   * This method will ensure you that a given key/data will be present in the dictionary.\n   * @param key the given key to get the matching value from\n   * @param factory the factory that will create the value if the key is not present in the dictionary.\n   * The factory will only be invoked if there's no data for the given key.\n   * @returns the value corresponding to the key.\n   */\n  getOrAddWithFactory(key, factory) {\n    let val = this.get(key);\n    if (val !== undefined) {\n      return val;\n    }\n    val = factory(key);\n    if (val) {\n      this.add(key, val);\n    }\n    return val;\n  }\n  /**\n   * Get a value from its key if present in the dictionary otherwise add it\n   * @param key the key to get the value from\n   * @param val if there's no such key/value pair in the dictionary add it with this value\n   * @returns the value corresponding to the key\n   */\n  getOrAdd(key, val) {\n    const curVal = this.get(key);\n    if (curVal !== undefined) {\n      return curVal;\n    }\n    this.add(key, val);\n    return val;\n  }\n  /**\n   * Check if there's a given key in the dictionary\n   * @param key the key to check for\n   * @returns true if the key is present, false otherwise\n   */\n  contains(key) {\n    return this._data[key] !== undefined;\n  }\n  /**\n   * Add a new key and its corresponding value\n   * @param key the key to add\n   * @param value the value corresponding to the key\n   * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\n   */\n  add(key, value) {\n    if (this._data[key] !== undefined) {\n      return false;\n    }\n    this._data[key] = value;\n    ++this._count;\n    return true;\n  }\n  /**\n   * Update a specific value associated to a key\n   * @param key defines the key to use\n   * @param value defines the value to store\n   * @returns true if the value was updated (or false if the key was not found)\n   */\n  set(key, value) {\n    if (this._data[key] === undefined) {\n      return false;\n    }\n    this._data[key] = value;\n    return true;\n  }\n  /**\n   * Get the element of the given key and remove it from the dictionary\n   * @param key defines the key to search\n   * @returns the value associated with the key or null if not found\n   */\n  getAndRemove(key) {\n    const val = this.get(key);\n    if (val !== undefined) {\n      delete this._data[key];\n      --this._count;\n      return val;\n    }\n    return null;\n  }\n  /**\n   * Remove a key/value from the dictionary.\n   * @param key the key to remove\n   * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary\n   */\n  remove(key) {\n    if (this.contains(key)) {\n      delete this._data[key];\n      --this._count;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Clear the whole content of the dictionary\n   */\n  clear() {\n    this._data = {};\n    this._count = 0;\n  }\n  /**\n   * Gets the current count\n   */\n  get count() {\n    return this._count;\n  }\n  /**\n   * Execute a callback on each key/val of the dictionary.\n   * Note that you can remove any element in this dictionary in the callback implementation\n   * @param callback the callback to execute on a given key/value pair\n   */\n  forEach(callback) {\n    for (const cur in this._data) {\n      const val = this._data[cur];\n      callback(cur, val);\n    }\n  }\n  /**\n   * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\n   * If the callback returns null or undefined the method will iterate to the next key/value pair\n   * Note that you can remove any element in this dictionary in the callback implementation\n   * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\n   * @returns the first item\n   */\n  first(callback) {\n    for (const cur in this._data) {\n      const val = this._data[cur];\n      const res = callback(cur, val);\n      if (res) {\n        return res;\n      }\n    }\n    return null;\n  }\n}","map":{"version":3,"mappings":"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","names":["StringDictionary","constructor","copyFrom","source","clear","forEach","t","v","add","get","key","val","_data","undefined","getOrAddWithFactory","factory","getOrAdd","curVal","contains","value","_count","set","getAndRemove","remove","count","callback","cur","first","res"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/stringDictionary.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\n\r\n/**\r\n * This class implement a typical dictionary using a string as key and the generic type T as value.\r\n * The underlying implementation relies on an associative array to ensure the best performances.\r\n * The value can be anything including 'null' but except 'undefined'\r\n */\r\nexport class StringDictionary<T> {\r\n    /**\r\n     * This will clear this dictionary and copy the content from the 'source' one.\r\n     * If the T value is a custom object, it won't be copied/cloned, the same object will be used\r\n     * @param source the dictionary to take the content from and copy to this dictionary\r\n     */\r\n    public copyFrom(source: StringDictionary<T>) {\r\n        this.clear();\r\n        source.forEach((t, v) => this.add(t, v));\r\n    }\r\n\r\n    /**\r\n     * Get a value based from its key\r\n     * @param key the given key to get the matching value from\r\n     * @returns the value if found, otherwise undefined is returned\r\n     */\r\n    public get(key: string): T | undefined {\r\n        const val = this._data[key];\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Get a value from its key or add it if it doesn't exist.\r\n     * This method will ensure you that a given key/data will be present in the dictionary.\r\n     * @param key the given key to get the matching value from\r\n     * @param factory the factory that will create the value if the key is not present in the dictionary.\r\n     * The factory will only be invoked if there's no data for the given key.\r\n     * @returns the value corresponding to the key.\r\n     */\r\n    public getOrAddWithFactory(key: string, factory: (key: string) => T): T {\r\n        let val = this.get(key);\r\n        if (val !== undefined) {\r\n            return val;\r\n        }\r\n\r\n        val = factory(key);\r\n        if (val) {\r\n            this.add(key, val);\r\n        }\r\n\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Get a value from its key if present in the dictionary otherwise add it\r\n     * @param key the key to get the value from\r\n     * @param val if there's no such key/value pair in the dictionary add it with this value\r\n     * @returns the value corresponding to the key\r\n     */\r\n    public getOrAdd(key: string, val: T): T {\r\n        const curVal = this.get(key);\r\n        if (curVal !== undefined) {\r\n            return curVal;\r\n        }\r\n\r\n        this.add(key, val);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Check if there's a given key in the dictionary\r\n     * @param key the key to check for\r\n     * @returns true if the key is present, false otherwise\r\n     */\r\n    public contains(key: string): boolean {\r\n        return this._data[key] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Add a new key and its corresponding value\r\n     * @param key the key to add\r\n     * @param value the value corresponding to the key\r\n     * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\r\n     */\r\n    public add(key: string, value: T): boolean {\r\n        if (this._data[key] !== undefined) {\r\n            return false;\r\n        }\r\n        this._data[key] = value;\r\n        ++this._count;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Update a specific value associated to a key\r\n     * @param key defines the key to use\r\n     * @param value defines the value to store\r\n     * @returns true if the value was updated (or false if the key was not found)\r\n     */\r\n    public set(key: string, value: T): boolean {\r\n        if (this._data[key] === undefined) {\r\n            return false;\r\n        }\r\n        this._data[key] = value;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the element of the given key and remove it from the dictionary\r\n     * @param key defines the key to search\r\n     * @returns the value associated with the key or null if not found\r\n     */\r\n    public getAndRemove(key: string): Nullable<T> {\r\n        const val = this.get(key);\r\n        if (val !== undefined) {\r\n            delete this._data[key];\r\n            --this._count;\r\n            return val;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Remove a key/value from the dictionary.\r\n     * @param key the key to remove\r\n     * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary\r\n     */\r\n    public remove(key: string): boolean {\r\n        if (this.contains(key)) {\r\n            delete this._data[key];\r\n            --this._count;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Clear the whole content of the dictionary\r\n     */\r\n    public clear() {\r\n        this._data = {};\r\n        this._count = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current count\r\n     */\r\n    public get count() {\r\n        return this._count;\r\n    }\r\n\r\n    /**\r\n     * Execute a callback on each key/val of the dictionary.\r\n     * Note that you can remove any element in this dictionary in the callback implementation\r\n     * @param callback the callback to execute on a given key/value pair\r\n     */\r\n    public forEach(callback: (key: string, val: T) => void) {\r\n        for (const cur in this._data) {\r\n            const val = this._data[cur];\r\n            callback(cur, val);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\r\n     * If the callback returns null or undefined the method will iterate to the next key/value pair\r\n     * Note that you can remove any element in this dictionary in the callback implementation\r\n     * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\r\n     * @returns the first item\r\n     */\r\n    public first<TRes>(callback: (key: string, val: T) => TRes) {\r\n        for (const cur in this._data) {\r\n            const val = this._data[cur];\r\n            const res = callback(cur, val);\r\n            if (res) {\r\n                return res;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _count = 0;\r\n    private _data: { [key: string]: T } = {};\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}