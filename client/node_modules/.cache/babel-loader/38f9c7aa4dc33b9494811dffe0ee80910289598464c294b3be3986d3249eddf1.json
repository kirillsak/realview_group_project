{"ast":null,"code":"import { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector.js\";\n/**\n * A behavior that allows a transform node to stick to a surface position/orientation\n * @since 5.0.0\n */\nexport class SurfaceMagnetismBehavior {\n  constructor() {\n    this._attachPointLocalOffset = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._hit = false;\n    /**\n     * Distance offset from the hit point to place the target at, along the hit normal.\n     */\n    this.hitNormalOffset = 0.05;\n    /**\n     * Spatial mapping meshes to collide with\n     */\n    this.meshes = [];\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 250;\n    /**\n     * If true, pitch and roll are omitted.\n     */\n    this.keepOrientationVertical = true;\n    /**\n     * Is this behavior reacting to pointer events\n     */\n    this.enabled = true;\n    /**\n     * Maximum distance for the node to stick to the surface\n     */\n    this.maxStickingDistance = 0.8;\n  }\n  /**\n   * Name of the behavior\n   */\n  get name() {\n    return \"SurfaceMagnetism\";\n  }\n  /**\n   * Function called when the behavior needs to be initialized (after attaching it to a target)\n   */\n  init() {}\n  /**\n   * Attaches the behavior to a transform node\n   * @param target defines the target where the behavior is attached to\n   * @param scene the scene\n   */\n  attach(target, scene) {\n    this._attachedMesh = target;\n    this._scene = scene || target.getScene();\n    if (!this._attachedMesh.rotationQuaternion) {\n      this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\n    }\n    this.updateAttachPoint();\n    this._workingPosition.copyFrom(this._attachedMesh.position);\n    this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\n    this._addObservables();\n  }\n  /**\n   * Detaches the behavior\n   */\n  detach() {\n    this._attachedMesh = null;\n    this._removeObservables();\n  }\n  _getTargetPose(pickingInfo) {\n    if (!this._attachedMesh) {\n      return null;\n    }\n    if (pickingInfo && pickingInfo.hit) {\n      const pickedNormal = pickingInfo.getNormal(true, true);\n      const pickedPoint = pickingInfo.pickedPoint;\n      if (!pickedNormal || !pickedPoint) {\n        return null;\n      }\n      pickedNormal.normalize();\n      const worldTarget = TmpVectors.Vector3[0];\n      worldTarget.copyFrom(pickedNormal);\n      worldTarget.scaleInPlace(this.hitNormalOffset);\n      worldTarget.addInPlace(pickedPoint);\n      if (this._attachedMesh.parent) {\n        TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\n        Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\n      }\n      return {\n        position: worldTarget,\n        quaternion: Quaternion.RotationYawPitchRoll(-Math.atan2(pickedNormal.x, -pickedNormal.z), this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)), 0)\n      };\n    }\n    return null;\n  }\n  /**\n   * Updates the attach point with the current geometry extents of the attached mesh\n   */\n  updateAttachPoint() {\n    this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\n  }\n  /**\n   * Finds the intersection point of the given ray onto the meshes and updates the target.\n   * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\n   * If no mesh of `meshes` are hit, this does nothing.\n   * @param pickInfo The input pickingInfo that will be used to intersect the meshes\n   * @returns a boolean indicating if we found a hit to stick to\n   */\n  findAndUpdateTarget(pickInfo) {\n    this._hit = false;\n    if (!pickInfo.ray) {\n      return false;\n    }\n    const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\n    if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\n      const pose = this._getTargetPose(subPicking);\n      if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\n        this._workingPosition.copyFrom(pose.position);\n        this._workingQuaternion.copyFrom(pose.quaternion);\n        this._hit = true;\n      }\n    }\n    return this._hit;\n  }\n  _getAttachPointOffsetToRef(ref) {\n    if (!this._attachedMesh) {\n      ref.setAll(0);\n      return;\n    }\n    const storedQuat = TmpVectors.Quaternion[0];\n    storedQuat.copyFrom(this._attachedMesh.rotationQuaternion);\n    this._attachedMesh.rotationQuaternion.copyFromFloats(0, 0, 0, 1);\n    this._attachedMesh.computeWorldMatrix();\n    const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\n    const center = TmpVectors.Vector3[0];\n    boundingMinMax.max.addToRef(boundingMinMax.min, center);\n    center.scaleInPlace(0.5);\n    center.z = boundingMinMax.max.z;\n    // We max the z coordinate because we want the attach point to be on the back of the mesh\n    const invWorld = TmpVectors.Matrix[0];\n    this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\n    Vector3.TransformCoordinatesToRef(center, invWorld, ref);\n    this._attachedMesh.rotationQuaternion.copyFrom(storedQuat);\n  }\n  _updateTransformToGoal(elapsed) {\n    if (!this._attachedMesh || !this._hit) {\n      return;\n    }\n    const oldParent = this._attachedMesh.parent;\n    this._attachedMesh.setParent(null);\n    const worldOffset = TmpVectors.Vector3[0];\n    Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\n    if (!this.interpolatePose) {\n      this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\n      this._attachedMesh.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    }\n    // position\n    const interpolatedPosition = new Vector3();\n    Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\n    this._attachedMesh.position.copyFrom(interpolatedPosition);\n    // rotation\n    const currentRotation = new Quaternion();\n    currentRotation.copyFrom(this._attachedMesh.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion);\n    this._attachedMesh.setParent(oldParent);\n  }\n  _addObservables() {\n    this._pointerObserver = this._scene.onPointerObservable.add(pointerInfo => {\n      if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\n        this.findAndUpdateTarget(pointerInfo.pickInfo);\n      }\n    });\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n      const tick = Date.now();\n      this._updateTransformToGoal(tick - this._lastTick);\n      this._lastTick = tick;\n    });\n  }\n  _removeObservables() {\n    this._scene.onPointerObservable.remove(this._pointerObserver);\n    this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    this._pointerObserver = null;\n    this._onBeforeRender = null;\n  }\n}","map":{"version":3,"mappings":"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","names":["PointerEventTypes","Quaternion","TmpVectors","Vector3","SurfaceMagnetismBehavior","constructor","name","init","attach","target","scene","_attachedMesh","_scene","getScene","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","updateAttachPoint","_workingPosition","copyFrom","position","_workingQuaternion","_addObservables","detach","_removeObservables","_getTargetPose","pickingInfo","hit","pickedNormal","getNormal","pickedPoint","normalize","worldTarget","scaleInPlace","hitNormalOffset","addInPlace","parent","Matrix","getWorldMatrix","invert","TransformNormalToRef","quaternion","Math","atan2","keepOrientationVertical","sqrt","_getAttachPointOffsetToRef","_attachPointLocalOffset","findAndUpdateTarget","pickInfo","_hit","ray","subPicking","intersectsMeshes","meshes","pickedMesh","pose","Distance","maxStickingDistance","ref","setAll","storedQuat","copyFromFloats","computeWorldMatrix","boundingMinMax","getHierarchyBoundingVectors","center","max","addToRef","min","invWorld","invertToRef","TransformCoordinatesToRef","_updateTransformToGoal","elapsed","oldParent","setParent","worldOffset","interpolatePose","subtractInPlace","interpolatedPosition","SmoothToRef","lerpTime","currentRotation","_pointerObserver","onPointerObservable","add","pointerInfo","enabled","type","POINTERMOVE","_lastTick","Date","now","_onBeforeRender","onBeforeRenderObservable","tick","remove"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/surfaceMagnetismBehavior.ts"],"sourcesContent":["import type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Quaternion, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Behavior } from \"../behavior\";\r\n\r\n/**\r\n * A behavior that allows a transform node to stick to a surface position/orientation\r\n * @since 5.0.0\r\n */\r\nexport class SurfaceMagnetismBehavior implements Behavior<Mesh> {\r\n    private _scene: Scene;\r\n    private _attachedMesh: Nullable<Mesh>;\r\n    private _attachPointLocalOffset: Vector3 = new Vector3();\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n    private _hit = false;\r\n\r\n    /**\r\n     * Distance offset from the hit point to place the target at, along the hit normal.\r\n     */\r\n    public hitNormalOffset: number = 0.05;\r\n\r\n    /**\r\n     * Name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"SurfaceMagnetism\";\r\n    }\r\n\r\n    /**\r\n     * Spatial mapping meshes to collide with\r\n     */\r\n    public meshes: AbstractMesh[] = [];\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (after attaching it to a target)\r\n     */\r\n    public init(): void {}\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 250;\r\n\r\n    /**\r\n     * If true, pitch and roll are omitted.\r\n     */\r\n    public keepOrientationVertical = true;\r\n\r\n    /**\r\n     * Is this behavior reacting to pointer events\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * Maximum distance for the node to stick to the surface\r\n     */\r\n    public maxStickingDistance = 0.8;\r\n\r\n    /**\r\n     * Attaches the behavior to a transform node\r\n     * @param target defines the target where the behavior is attached to\r\n     * @param scene the scene\r\n     */\r\n    public attach(target: Mesh, scene?: Scene): void {\r\n        this._attachedMesh = target;\r\n        this._scene = scene || target.getScene();\r\n        if (!this._attachedMesh.rotationQuaternion) {\r\n            this._attachedMesh.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._attachedMesh.rotation.y, this._attachedMesh.rotation.x, this._attachedMesh.rotation.z);\r\n        }\r\n        this.updateAttachPoint();\r\n\r\n        this._workingPosition.copyFrom(this._attachedMesh.position);\r\n        this._workingQuaternion.copyFrom(this._attachedMesh.rotationQuaternion);\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior\r\n     */\r\n    public detach(): void {\r\n        this._attachedMesh = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    private _getTargetPose(pickingInfo: PickingInfo): Nullable<{ position: Vector3; quaternion: Quaternion }> {\r\n        if (!this._attachedMesh) {\r\n            return null;\r\n        }\r\n\r\n        if (pickingInfo && pickingInfo.hit) {\r\n            const pickedNormal = pickingInfo.getNormal(true, true);\r\n            const pickedPoint = pickingInfo.pickedPoint;\r\n\r\n            if (!pickedNormal || !pickedPoint) {\r\n                return null;\r\n            }\r\n            pickedNormal.normalize();\r\n\r\n            const worldTarget = TmpVectors.Vector3[0];\r\n            worldTarget.copyFrom(pickedNormal);\r\n            worldTarget.scaleInPlace(this.hitNormalOffset);\r\n            worldTarget.addInPlace(pickedPoint);\r\n\r\n            if (this._attachedMesh.parent) {\r\n                TmpVectors.Matrix[0].copyFrom(this._attachedMesh.parent.getWorldMatrix()).invert();\r\n                Vector3.TransformNormalToRef(worldTarget, TmpVectors.Matrix[0], worldTarget);\r\n            }\r\n\r\n            return {\r\n                position: worldTarget,\r\n                quaternion: Quaternion.RotationYawPitchRoll(\r\n                    -Math.atan2(pickedNormal.x, -pickedNormal.z),\r\n                    this.keepOrientationVertical ? 0 : Math.atan2(pickedNormal.y, Math.sqrt(pickedNormal.z * pickedNormal.z + pickedNormal.x * pickedNormal.x)),\r\n                    0\r\n                ),\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Updates the attach point with the current geometry extents of the attached mesh\r\n     */\r\n    public updateAttachPoint() {\r\n        this._getAttachPointOffsetToRef(this._attachPointLocalOffset);\r\n    }\r\n\r\n    /**\r\n     * Finds the intersection point of the given ray onto the meshes and updates the target.\r\n     * Transformation will be interpolated according to `interpolatePose` and `lerpTime` properties.\r\n     * If no mesh of `meshes` are hit, this does nothing.\r\n     * @param pickInfo The input pickingInfo that will be used to intersect the meshes\r\n     * @returns a boolean indicating if we found a hit to stick to\r\n     */\r\n    public findAndUpdateTarget(pickInfo: PickingInfo): boolean {\r\n        this._hit = false;\r\n        if (!pickInfo.ray) {\r\n            return false;\r\n        }\r\n\r\n        const subPicking = pickInfo.ray.intersectsMeshes(this.meshes)[0];\r\n\r\n        if (this._attachedMesh && subPicking && subPicking.hit && subPicking.pickedMesh) {\r\n            const pose = this._getTargetPose(subPicking);\r\n            if (pose && Vector3.Distance(this._attachedMesh.position, pose.position) < this.maxStickingDistance) {\r\n                this._workingPosition.copyFrom(pose.position);\r\n                this._workingQuaternion.copyFrom(pose.quaternion);\r\n                this._hit = true;\r\n            }\r\n        }\r\n\r\n        return this._hit;\r\n    }\r\n\r\n    private _getAttachPointOffsetToRef(ref: Vector3) {\r\n        if (!this._attachedMesh) {\r\n            ref.setAll(0);\r\n            return;\r\n        }\r\n\r\n        const storedQuat = TmpVectors.Quaternion[0];\r\n        storedQuat.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        this._attachedMesh.rotationQuaternion!.copyFromFloats(0, 0, 0, 1);\r\n        this._attachedMesh.computeWorldMatrix();\r\n        const boundingMinMax = this._attachedMesh.getHierarchyBoundingVectors();\r\n        const center = TmpVectors.Vector3[0];\r\n        boundingMinMax.max.addToRef(boundingMinMax.min, center);\r\n        center.scaleInPlace(0.5);\r\n        center.z = boundingMinMax.max.z;\r\n        // We max the z coordinate because we want the attach point to be on the back of the mesh\r\n        const invWorld = TmpVectors.Matrix[0];\r\n        this._attachedMesh.getWorldMatrix().invertToRef(invWorld);\r\n        Vector3.TransformCoordinatesToRef(center, invWorld, ref);\r\n        this._attachedMesh.rotationQuaternion!.copyFrom(storedQuat);\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this._attachedMesh || !this._hit) {\r\n            return;\r\n        }\r\n\r\n        const oldParent = this._attachedMesh.parent;\r\n        this._attachedMesh.setParent(null);\r\n\r\n        const worldOffset = TmpVectors.Vector3[0];\r\n        Vector3.TransformNormalToRef(this._attachPointLocalOffset, this._attachedMesh.getWorldMatrix(), worldOffset);\r\n\r\n        if (!this.interpolatePose) {\r\n            this._attachedMesh.position.copyFrom(this._workingPosition).subtractInPlace(worldOffset);\r\n            this._attachedMesh.rotationQuaternion!.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const interpolatedPosition = new Vector3();\r\n        Vector3.SmoothToRef(this._attachedMesh.position, this._workingPosition, elapsed, this.lerpTime, interpolatedPosition);\r\n        this._attachedMesh.position.copyFrom(interpolatedPosition);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this._attachedMesh.rotationQuaternion!);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this._attachedMesh.rotationQuaternion!);\r\n\r\n        this._attachedMesh.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._pointerObserver = this._scene.onPointerObservable.add((pointerInfo) => {\r\n            if (this.enabled && pointerInfo.type == PointerEventTypes.POINTERMOVE && pointerInfo.pickInfo) {\r\n                this.findAndUpdateTarget(pointerInfo.pickInfo);\r\n            }\r\n        });\r\n\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            const tick = Date.now();\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        this._scene.onPointerObservable.remove(this._pointerObserver);\r\n        this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        this._pointerObserver = null;\r\n        this._onBeforeRender = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}