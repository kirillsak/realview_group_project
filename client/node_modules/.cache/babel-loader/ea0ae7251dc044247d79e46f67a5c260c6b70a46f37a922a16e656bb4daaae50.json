{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\n/**\n * Class used to store bounding box information\n */\nexport class BoundingBox {\n  /**\n   * Creates a new bounding box\n   * @param min defines the minimum vector (in local space)\n   * @param max defines the maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  constructor(min, max, worldMatrix) {\n    /**\n     * Gets the 8 vectors representing the bounding box in local space\n     */\n    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the center of the bounding box in local space\n     */\n    this.center = Vector3.Zero();\n    /**\n     * Gets the center of the bounding box in world space\n     */\n    this.centerWorld = Vector3.Zero();\n    /**\n     * Gets the extend size in local space\n     */\n    this.extendSize = Vector3.Zero();\n    /**\n     * Gets the extend size in world space\n     */\n    this.extendSizeWorld = Vector3.Zero();\n    /**\n     * Gets the OBB (object bounding box) directions\n     */\n    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);\n    /**\n     * Gets the 8 vectors representing the bounding box in world space\n     */\n    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);\n    /**\n     * Gets the minimum vector in world space\n     */\n    this.minimumWorld = Vector3.Zero();\n    /**\n     * Gets the maximum vector in world space\n     */\n    this.maximumWorld = Vector3.Zero();\n    /**\n     * Gets the minimum vector in local space\n     */\n    this.minimum = Vector3.Zero();\n    /**\n     * Gets the maximum vector in local space\n     */\n    this.maximum = Vector3.Zero();\n    /** @internal */\n    this._drawWrapperFront = null;\n    /** @internal */\n    this._drawWrapperBack = null;\n    this.reConstruct(min, max, worldMatrix);\n  }\n  // Methods\n  /**\n   * Recreates the entire bounding box from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  reConstruct(min, max, worldMatrix) {\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const vectors = this.vectors;\n    this.minimum.copyFromFloats(minX, minY, minZ);\n    this.maximum.copyFromFloats(maxX, maxY, maxZ);\n    vectors[0].copyFromFloats(minX, minY, minZ);\n    vectors[1].copyFromFloats(maxX, maxY, maxZ);\n    vectors[2].copyFromFloats(maxX, minY, minZ);\n    vectors[3].copyFromFloats(minX, maxY, minZ);\n    vectors[4].copyFromFloats(minX, minY, maxZ);\n    vectors[5].copyFromFloats(maxX, maxY, minZ);\n    vectors[6].copyFromFloats(minX, maxY, maxZ);\n    vectors[7].copyFromFloats(maxX, minY, maxZ);\n    // OBB\n    max.addToRef(min, this.center).scaleInPlace(0.5);\n    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\n    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\n    this._update(this._worldMatrix);\n  }\n  /**\n   * Scale the current bounding box by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding box\n   */\n  scale(factor) {\n    const tmpVectors = BoundingBox._TmpVector3;\n    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\n    const len = diff.length();\n    diff.normalizeFromLength(len);\n    const distance = len * factor;\n    const newRadius = diff.scaleInPlace(distance * 0.5);\n    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\n    const max = this.center.addToRef(newRadius, tmpVectors[2]);\n    this.reConstruct(min, max, this._worldMatrix);\n    return this;\n  }\n  /**\n   * Gets the world matrix of the bounding box\n   * @returns a matrix\n   */\n  getWorldMatrix() {\n    return this._worldMatrix;\n  }\n  /**\n   * @internal\n   */\n  _update(world) {\n    const minWorld = this.minimumWorld;\n    const maxWorld = this.maximumWorld;\n    const directions = this.directions;\n    const vectorsWorld = this.vectorsWorld;\n    const vectors = this.vectors;\n    if (!world.isIdentity()) {\n      minWorld.setAll(Number.MAX_VALUE);\n      maxWorld.setAll(-Number.MAX_VALUE);\n      for (let index = 0; index < 8; ++index) {\n        const v = vectorsWorld[index];\n        Vector3.TransformCoordinatesToRef(vectors[index], world, v);\n        minWorld.minimizeInPlace(v);\n        maxWorld.maximizeInPlace(v);\n      }\n      // Extend\n      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\n      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\n    } else {\n      minWorld.copyFrom(this.minimum);\n      maxWorld.copyFrom(this.maximum);\n      for (let index = 0; index < 8; ++index) {\n        vectorsWorld[index].copyFrom(vectors[index]);\n      }\n      // Extend\n      this.extendSizeWorld.copyFrom(this.extendSize);\n      this.centerWorld.copyFrom(this.center);\n    }\n    Vector3.FromArrayToRef(world.m, 0, directions[0]);\n    Vector3.FromArrayToRef(world.m, 4, directions[1]);\n    Vector3.FromArrayToRef(world.m, 8, directions[2]);\n    this._worldMatrix = world;\n  }\n  /**\n   * Tests if the bounding box is intersecting the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n  isInFrustum(frustumPlanes) {\n    return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n  }\n  /**\n   * Tests if the bounding box is entirely inside the frustum planes\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n  }\n  /**\n   * Tests if a point is inside the bounding box\n   * @param point defines the point to test\n   * @returns true if the point is inside the bounding box\n   */\n  intersectsPoint(point) {\n    const min = this.minimumWorld;\n    const max = this.maximumWorld;\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    const pointX = point.x,\n      pointY = point.y,\n      pointZ = point.z;\n    const delta = -Epsilon;\n    if (maxX - pointX < delta || delta > pointX - minX) {\n      return false;\n    }\n    if (maxY - pointY < delta || delta > pointY - minY) {\n      return false;\n    }\n    if (maxZ - pointZ < delta || delta > pointZ - minZ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Tests if the bounding box intersects with a bounding sphere\n   * @param sphere defines the sphere to test\n   * @returns true if there is an intersection\n   */\n  intersectsSphere(sphere) {\n    return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n  }\n  /**\n   * Tests if the bounding box intersects with a box defined by a min and max vectors\n   * @param min defines the min vector to use\n   * @param max defines the max vector to use\n   * @returns true if there is an intersection\n   */\n  intersectsMinMax(min, max) {\n    const myMin = this.minimumWorld;\n    const myMax = this.maximumWorld;\n    const myMinX = myMin.x,\n      myMinY = myMin.y,\n      myMinZ = myMin.z,\n      myMaxX = myMax.x,\n      myMaxY = myMax.y,\n      myMaxZ = myMax.z;\n    const minX = min.x,\n      minY = min.y,\n      minZ = min.z,\n      maxX = max.x,\n      maxY = max.y,\n      maxZ = max.z;\n    if (myMaxX < minX || myMinX > maxX) {\n      return false;\n    }\n    if (myMaxY < minY || myMinY > maxY) {\n      return false;\n    }\n    if (myMaxZ < minZ || myMinZ > maxZ) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Disposes the resources of the class\n   */\n  dispose() {\n    var _a, _b;\n    (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();\n  }\n  // Statics\n  /**\n   * Tests if two bounding boxes are intersections\n   * @param box0 defines the first box to test\n   * @param box1 defines the second box to test\n   * @returns true if there is an intersection\n   */\n  static Intersects(box0, box1) {\n    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\n  }\n  /**\n   * Tests if a bounding box defines by a min/max vectors intersects a sphere\n   * @param minPoint defines the minimum vector of the bounding box\n   * @param maxPoint defines the maximum vector of the bounding box\n   * @param sphereCenter defines the sphere center\n   * @param sphereRadius defines the sphere radius\n   * @returns true if there is an intersection\n   */\n  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {\n    const vector = BoundingBox._TmpVector3[0];\n    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\n    const num = Vector3.DistanceSquared(sphereCenter, vector);\n    return num <= sphereRadius * sphereRadius;\n  }\n  /**\n   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an inclusion\n   */\n  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {\n    for (let p = 0; p < 6; ++p) {\n      const frustumPlane = frustumPlanes[p];\n      for (let i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Tests if a bounding box defined with 8 vectors intersects frustum planes\n   * @param boundingVectors defines an array of 8 vectors representing a bounding box\n   * @param frustumPlanes defines the frustum planes to test\n   * @returns true if there is an intersection\n   */\n  static IsInFrustum(boundingVectors, frustumPlanes) {\n    for (let p = 0; p < 6; ++p) {\n      let canReturnFalse = true;\n      const frustumPlane = frustumPlanes[p];\n      for (let i = 0; i < 8; ++i) {\n        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\n          canReturnFalse = false;\n          break;\n        }\n      }\n      if (canReturnFalse) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nBoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);","map":{"version":3,"mappings":"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","names":["ArrayTools","Matrix","Vector3","Epsilon","BoundingBox","constructor","min","max","worldMatrix","BuildArray","Zero","reConstruct","minX","x","minY","y","minZ","z","maxX","maxY","maxZ","vectors","minimum","copyFromFloats","maximum","addToRef","center","scaleInPlace","subtractToRef","extendSize","_worldMatrix","IdentityReadOnly","_update","scale","factor","tmpVectors","_TmpVector3","diff","len","length","normalizeFromLength","distance","newRadius","getWorldMatrix","world","minWorld","minimumWorld","maxWorld","maximumWorld","directions","vectorsWorld","isIdentity","setAll","Number","MAX_VALUE","index","v","TransformCoordinatesToRef","minimizeInPlace","maximizeInPlace","extendSizeWorld","centerWorld","copyFrom","FromArrayToRef","m","isInFrustum","frustumPlanes","IsInFrustum","isCompletelyInFrustum","IsCompletelyInFrustum","intersectsPoint","point","pointX","pointY","pointZ","delta","intersectsSphere","sphere","IntersectsSphere","radiusWorld","intersectsMinMax","myMin","myMax","myMinX","myMinY","myMinZ","myMaxX","myMaxY","myMaxZ","dispose","_drawWrapperFront","_drawWrapperBack","Intersects","box0","box1","minPoint","maxPoint","sphereCenter","sphereRadius","vector","ClampToRef","num","DistanceSquared","boundingVectors","p","frustumPlane","i","dotCoordinate","canReturnFalse"],"sourceRoot":"","sources":["../../../../lts/core/generated/Culling/boundingBox.ts"],"sourcesContent":["import type { DeepImmutable, Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { BoundingSphere } from \"../Culling/boundingSphere\";\r\n\r\nimport type { ICullable } from \"./boundingInfo\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\ndeclare type DrawWrapper = import(\"../Materials/drawWrapper\").DrawWrapper;\r\n\r\n/**\r\n * Class used to store bounding box information\r\n */\r\nexport class BoundingBox implements ICullable {\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in local space\r\n     */\r\n    public readonly vectors: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the center of the bounding box in local space\r\n     */\r\n    public readonly center: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the center of the bounding box in world space\r\n     */\r\n    public readonly centerWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in local space\r\n     */\r\n    public readonly extendSize: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the extend size in world space\r\n     */\r\n    public readonly extendSizeWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the OBB (object bounding box) directions\r\n     */\r\n    public readonly directions: Vector3[] = ArrayTools.BuildArray(3, Vector3.Zero);\r\n    /**\r\n     * Gets the 8 vectors representing the bounding box in world space\r\n     */\r\n    public readonly vectorsWorld: Vector3[] = ArrayTools.BuildArray(8, Vector3.Zero);\r\n    /**\r\n     * Gets the minimum vector in world space\r\n     */\r\n    public readonly minimumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in world space\r\n     */\r\n    public readonly maximumWorld: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the minimum vector in local space\r\n     */\r\n    public readonly minimum: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Gets the maximum vector in local space\r\n     */\r\n    public readonly maximum: Vector3 = Vector3.Zero();\r\n\r\n    private _worldMatrix: DeepImmutable<Matrix>;\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _tag: number;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Creates a new bounding box\r\n     * @param min defines the minimum vector (in local space)\r\n     * @param max defines the maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Recreates the entire bounding box from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const vectors = this.vectors;\r\n\r\n        this.minimum.copyFromFloats(minX, minY, minZ);\r\n        this.maximum.copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[0].copyFromFloats(minX, minY, minZ);\r\n        vectors[1].copyFromFloats(maxX, maxY, maxZ);\r\n        vectors[2].copyFromFloats(maxX, minY, minZ);\r\n        vectors[3].copyFromFloats(minX, maxY, minZ);\r\n        vectors[4].copyFromFloats(minX, minY, maxZ);\r\n        vectors[5].copyFromFloats(maxX, maxY, minZ);\r\n        vectors[6].copyFromFloats(minX, maxY, maxZ);\r\n        vectors[7].copyFromFloats(maxX, minY, maxZ);\r\n\r\n        // OBB\r\n        max.addToRef(min, this.center).scaleInPlace(0.5);\r\n        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);\r\n\r\n        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;\r\n\r\n        this._update(this._worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding box by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding box\r\n     */\r\n    public scale(factor: number): BoundingBox {\r\n        const tmpVectors = BoundingBox._TmpVector3;\r\n        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);\r\n        const len = diff.length();\r\n        diff.normalizeFromLength(len);\r\n        const distance = len * factor;\r\n        const newRadius = diff.scaleInPlace(distance * 0.5);\r\n\r\n        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);\r\n        const max = this.center.addToRef(newRadius, tmpVectors[2]);\r\n\r\n        this.reConstruct(min, max, this._worldMatrix);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the world matrix of the bounding box\r\n     * @returns a matrix\r\n     */\r\n    public getWorldMatrix(): DeepImmutable<Matrix> {\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _update(world: DeepImmutable<Matrix>): void {\r\n        const minWorld = this.minimumWorld;\r\n        const maxWorld = this.maximumWorld;\r\n        const directions = this.directions;\r\n        const vectorsWorld = this.vectorsWorld;\r\n        const vectors = this.vectors;\r\n\r\n        if (!world.isIdentity()) {\r\n            minWorld.setAll(Number.MAX_VALUE);\r\n            maxWorld.setAll(-Number.MAX_VALUE);\r\n\r\n            for (let index = 0; index < 8; ++index) {\r\n                const v = vectorsWorld[index];\r\n                Vector3.TransformCoordinatesToRef(vectors[index], world, v);\r\n                minWorld.minimizeInPlace(v);\r\n                maxWorld.maximizeInPlace(v);\r\n            }\r\n\r\n            // Extend\r\n            maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);\r\n            maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);\r\n        } else {\r\n            minWorld.copyFrom(this.minimum);\r\n            maxWorld.copyFrom(this.maximum);\r\n            for (let index = 0; index < 8; ++index) {\r\n                vectorsWorld[index].copyFrom(vectors[index]);\r\n            }\r\n\r\n            // Extend\r\n            this.extendSizeWorld.copyFrom(this.extendSize);\r\n            this.centerWorld.copyFrom(this.center);\r\n        }\r\n\r\n        Vector3.FromArrayToRef(world.m, 0, directions[0]);\r\n        Vector3.FromArrayToRef(world.m, 4, directions[1]);\r\n        Vector3.FromArrayToRef(world.m, 8, directions[2]);\r\n\r\n        this._worldMatrix = world;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is intersecting the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box is entirely inside the frustum planes\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Tests if a point is inside the bounding box\r\n     * @param point defines the point to test\r\n     * @returns true if the point is inside the bounding box\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        const min = this.minimumWorld;\r\n        const max = this.maximumWorld;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        const pointX = point.x,\r\n            pointY = point.y,\r\n            pointZ = point.z;\r\n        const delta = -Epsilon;\r\n\r\n        if (maxX - pointX < delta || delta > pointX - minX) {\r\n            return false;\r\n        }\r\n\r\n        if (maxY - pointY < delta || delta > pointY - minY) {\r\n            return false;\r\n        }\r\n\r\n        if (maxZ - pointZ < delta || delta > pointZ - minZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a bounding sphere\r\n     * @param sphere defines the sphere to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>): boolean {\r\n        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if the bounding box intersects with a box defined by a min and max vectors\r\n     * @param min defines the min vector to use\r\n     * @param max defines the max vector to use\r\n     * @returns true if there is an intersection\r\n     */\r\n    public intersectsMinMax(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>): boolean {\r\n        const myMin = this.minimumWorld;\r\n        const myMax = this.maximumWorld;\r\n        const myMinX = myMin.x,\r\n            myMinY = myMin.y,\r\n            myMinZ = myMin.z,\r\n            myMaxX = myMax.x,\r\n            myMaxY = myMax.y,\r\n            myMaxZ = myMax.z;\r\n        const minX = min.x,\r\n            minY = min.y,\r\n            minZ = min.z,\r\n            maxX = max.x,\r\n            maxY = max.y,\r\n            maxZ = max.z;\r\n        if (myMaxX < minX || myMinX > maxX) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxY < minY || myMinY > maxY) {\r\n            return false;\r\n        }\r\n\r\n        if (myMaxZ < minZ || myMinZ > maxZ) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the class\r\n     */\r\n    public dispose(): void {\r\n        this._drawWrapperFront?.dispose();\r\n        this._drawWrapperBack?.dispose();\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Tests if two bounding boxes are intersections\r\n     * @param box0 defines the first box to test\r\n     * @param box1 defines the second box to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static Intersects(box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean {\r\n        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defines by a min/max vectors intersects a sphere\r\n     * @param minPoint defines the minimum vector of the bounding box\r\n     * @param maxPoint defines the maximum vector of the bounding box\r\n     * @param sphereCenter defines the sphere center\r\n     * @param sphereRadius defines the sphere radius\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IntersectsSphere(minPoint: DeepImmutable<Vector3>, maxPoint: DeepImmutable<Vector3>, sphereCenter: DeepImmutable<Vector3>, sphereRadius: number): boolean {\r\n        const vector = BoundingBox._TmpVector3[0];\r\n        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);\r\n        const num = Vector3.DistanceSquared(sphereCenter, vector);\r\n        return num <= sphereRadius * sphereRadius;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an inclusion\r\n     */\r\n    public static IsCompletelyInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Tests if a bounding box defined with 8 vectors intersects frustum planes\r\n     * @param boundingVectors defines an array of 8 vectors representing a bounding box\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @returns true if there is an intersection\r\n     */\r\n    public static IsInFrustum(boundingVectors: Array<DeepImmutable<Vector3>>, frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        for (let p = 0; p < 6; ++p) {\r\n            let canReturnFalse = true;\r\n            const frustumPlane = frustumPlanes[p];\r\n            for (let i = 0; i < 8; ++i) {\r\n                if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {\r\n                    canReturnFalse = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (canReturnFalse) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}