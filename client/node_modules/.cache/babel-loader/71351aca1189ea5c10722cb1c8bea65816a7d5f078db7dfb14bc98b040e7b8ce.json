{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces.js\";\nimport { Quaternion, Vector3, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { Camera } from \"@babylonjs/core/Cameras/camera.js\";\nimport { FreeCamera } from \"@babylonjs/core/Cameras/freeCamera.js\";\nimport { Animation } from \"@babylonjs/core/Animations/animation.js\";\nimport { Bone } from \"@babylonjs/core/Bones/bone.js\";\nimport { Skeleton } from \"@babylonjs/core/Bones/skeleton.js\";\nimport { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { Material } from \"@babylonjs/core/Materials/material.js\";\nimport { MultiMaterial } from \"@babylonjs/core/Materials/multiMaterial.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { SubMesh } from \"@babylonjs/core/Meshes/subMesh.js\";\nimport { AbstractMesh } from \"@babylonjs/core/Meshes/abstractMesh.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { HemisphericLight } from \"@babylonjs/core/Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"@babylonjs/core/Lights/directionalLight.js\";\nimport { PointLight } from \"@babylonjs/core/Lights/pointLight.js\";\nimport { SpotLight } from \"@babylonjs/core/Lights/spotLight.js\";\nimport { GLTFUtils } from \"./glTFLoaderUtils.js\";\nimport { GLTFFileLoader } from \"../glTFFileLoader.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\n/**\n * Tokenizer. Used for shaders compatibility\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\n */\nvar ETokenType;\n(function (ETokenType) {\n  ETokenType[ETokenType[\"IDENTIFIER\"] = 1] = \"IDENTIFIER\";\n  ETokenType[ETokenType[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n  ETokenType[ETokenType[\"END_OF_INPUT\"] = 3] = \"END_OF_INPUT\";\n})(ETokenType || (ETokenType = {}));\nclass Tokenizer {\n  constructor(toParse) {\n    this._pos = 0;\n    this.currentToken = ETokenType.UNKNOWN;\n    this.currentIdentifier = \"\";\n    this.currentString = \"\";\n    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;\n    this._toParse = toParse;\n    this._maxPos = toParse.length;\n  }\n  getNextToken() {\n    if (this.isEnd()) {\n      return ETokenType.END_OF_INPUT;\n    }\n    this.currentString = this.read();\n    this.currentToken = ETokenType.UNKNOWN;\n    if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\n      this.currentToken = ETokenType.IDENTIFIER;\n      this.currentIdentifier = this.currentString;\n      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === \"_\")) {\n        this.currentIdentifier += this.currentString;\n        this.forward();\n      }\n    }\n    return this.currentToken;\n  }\n  peek() {\n    return this._toParse[this._pos];\n  }\n  read() {\n    return this._toParse[this._pos++];\n  }\n  forward() {\n    this._pos++;\n  }\n  isEnd() {\n    return this._pos >= this._maxPos;\n  }\n}\n/**\n * Values\n */\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\nconst babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\nconst babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\n/**\n * Parse\n * @param parsedBuffers\n * @param gltfRuntime\n */\nconst parseBuffers = (parsedBuffers, gltfRuntime) => {\n  for (const buf in parsedBuffers) {\n    const parsedBuffer = parsedBuffers[buf];\n    gltfRuntime.buffers[buf] = parsedBuffer;\n    gltfRuntime.buffersCount++;\n  }\n};\nconst parseShaders = (parsedShaders, gltfRuntime) => {\n  for (const sha in parsedShaders) {\n    const parsedShader = parsedShaders[sha];\n    gltfRuntime.shaders[sha] = parsedShader;\n    gltfRuntime.shaderscount++;\n  }\n};\nconst parseObject = (parsedObjects, runtimeProperty, gltfRuntime) => {\n  for (const object in parsedObjects) {\n    const parsedObject = parsedObjects[object];\n    gltfRuntime[runtimeProperty][object] = parsedObject;\n  }\n};\n/**\n * Utils\n * @param buffer\n */\nconst normalizeUVs = buffer => {\n  if (!buffer) {\n    return;\n  }\n  for (let i = 0; i < buffer.length / 2; i++) {\n    buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\n  }\n};\nconst getAttribute = attributeParameter => {\n  if (attributeParameter.semantic === \"NORMAL\") {\n    return \"normal\";\n  } else if (attributeParameter.semantic === \"POSITION\") {\n    return \"position\";\n  } else if (attributeParameter.semantic === \"JOINT\") {\n    return \"matricesIndices\";\n  } else if (attributeParameter.semantic === \"WEIGHT\") {\n    return \"matricesWeights\";\n  } else if (attributeParameter.semantic === \"COLOR\") {\n    return \"color\";\n  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\n    const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\n    return \"uv\" + (channel === 0 ? \"\" : channel + 1);\n  }\n  return null;\n};\n/**\n * Loads and creates animations\n * @param gltfRuntime\n */\nconst loadAnimations = gltfRuntime => {\n  for (const anim in gltfRuntime.animations) {\n    const animation = gltfRuntime.animations[anim];\n    if (!animation.channels || !animation.samplers) {\n      continue;\n    }\n    let lastAnimation = null;\n    for (let i = 0; i < animation.channels.length; i++) {\n      // Get parameters and load buffers\n      const channel = animation.channels[i];\n      const sampler = animation.samplers[channel.sampler];\n      if (!sampler) {\n        continue;\n      }\n      let inputData = null;\n      let outputData = null;\n      if (animation.parameters) {\n        inputData = animation.parameters[sampler.input];\n        outputData = animation.parameters[sampler.output];\n      } else {\n        inputData = sampler.input;\n        outputData = sampler.output;\n      }\n      const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\n      const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\n      const targetId = channel.target.id;\n      let targetNode = gltfRuntime.scene.getNodeById(targetId);\n      if (targetNode === null) {\n        targetNode = gltfRuntime.scene.getNodeByName(targetId);\n      }\n      if (targetNode === null) {\n        Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\n        continue;\n      }\n      const isBone = targetNode instanceof Bone;\n      // Get target path (position, rotation or scaling)\n      let targetPath = channel.target.path;\n      const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\n      if (targetPathIndex !== -1) {\n        targetPath = babylonAnimationPaths[targetPathIndex];\n      }\n      // Determine animation type\n      let animationType = Animation.ANIMATIONTYPE_MATRIX;\n      if (!isBone) {\n        if (targetPath === \"rotationQuaternion\") {\n          animationType = Animation.ANIMATIONTYPE_QUATERNION;\n          targetNode.rotationQuaternion = new Quaternion();\n        } else {\n          animationType = Animation.ANIMATIONTYPE_VECTOR3;\n        }\n      }\n      // Create animation and key frames\n      let babylonAnimation = null;\n      const keys = [];\n      let arrayOffset = 0;\n      let modifyKey = false;\n      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\n        babylonAnimation = lastAnimation;\n        modifyKey = true;\n      }\n      if (!modifyKey) {\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n        babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\n        gltfRuntime.scene._blockEntityCollection = false;\n      }\n      // For each frame\n      for (let j = 0; j < bufferInput.length; j++) {\n        let value = null;\n        if (targetPath === \"rotationQuaternion\") {\n          // VEC4\n          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\n          arrayOffset += 4;\n        } else {\n          // Position and scaling are VEC3\n          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\n          arrayOffset += 3;\n        }\n        if (isBone) {\n          const bone = targetNode;\n          let translation = Vector3.Zero();\n          let rotationQuaternion = new Quaternion();\n          let scaling = Vector3.Zero();\n          // Warning on decompose\n          let mat = bone.getBaseMatrix();\n          if (modifyKey && lastAnimation) {\n            mat = lastAnimation.getKeys()[j].value;\n          }\n          mat.decompose(scaling, rotationQuaternion, translation);\n          if (targetPath === \"position\") {\n            translation = value;\n          } else if (targetPath === \"rotationQuaternion\") {\n            rotationQuaternion = value;\n          } else {\n            scaling = value;\n          }\n          value = Matrix.Compose(scaling, rotationQuaternion, translation);\n        }\n        if (!modifyKey) {\n          keys.push({\n            frame: bufferInput[j],\n            value: value\n          });\n        } else if (lastAnimation) {\n          lastAnimation.getKeys()[j].value = value;\n        }\n      }\n      // Finish\n      if (!modifyKey && babylonAnimation) {\n        babylonAnimation.setKeys(keys);\n        targetNode.animations.push(babylonAnimation);\n      }\n      lastAnimation = babylonAnimation;\n      gltfRuntime.scene.stopAnimation(targetNode);\n      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\n    }\n  }\n};\n/**\n * Returns the bones transformation matrix\n * @param node\n */\nconst configureBoneTransformation = node => {\n  let mat = null;\n  if (node.translation || node.rotation || node.scale) {\n    const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\n    const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\n    const position = Vector3.FromArray(node.translation || [0, 0, 0]);\n    mat = Matrix.Compose(scale, rotation, position);\n  } else {\n    mat = Matrix.FromArray(node.matrix);\n  }\n  return mat;\n};\n/**\n * Returns the parent bone\n * @param gltfRuntime\n * @param skins\n * @param jointName\n * @param newSkeleton\n */\nconst getParentBone = (gltfRuntime, skins, jointName, newSkeleton) => {\n  // Try to find\n  for (let i = 0; i < newSkeleton.bones.length; i++) {\n    if (newSkeleton.bones[i].name === jointName) {\n      return newSkeleton.bones[i];\n    }\n  }\n  // Not found, search in gltf nodes\n  const nodes = gltfRuntime.nodes;\n  for (const nde in nodes) {\n    const node = nodes[nde];\n    if (!node.jointName) {\n      continue;\n    }\n    const children = node.children;\n    for (let i = 0; i < children.length; i++) {\n      const child = gltfRuntime.nodes[children[i]];\n      if (!child.jointName) {\n        continue;\n      }\n      if (child.jointName === jointName) {\n        const mat = configureBoneTransformation(node);\n        const bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\n        bone.id = nde;\n        return bone;\n      }\n    }\n  }\n  return null;\n};\n/**\n * Returns the appropriate root node\n * @param nodesToRoot\n * @param id\n */\nconst getNodeToRoot = (nodesToRoot, id) => {\n  for (let i = 0; i < nodesToRoot.length; i++) {\n    const nodeToRoot = nodesToRoot[i];\n    for (let j = 0; j < nodeToRoot.node.children.length; j++) {\n      const child = nodeToRoot.node.children[j];\n      if (child === id) {\n        return nodeToRoot.bone;\n      }\n    }\n  }\n  return null;\n};\n/**\n * Returns the node with the joint name\n * @param gltfRuntime\n * @param jointName\n */\nconst getJointNode = (gltfRuntime, jointName) => {\n  const nodes = gltfRuntime.nodes;\n  let node = nodes[jointName];\n  if (node) {\n    return {\n      node: node,\n      id: jointName\n    };\n  }\n  for (const nde in nodes) {\n    node = nodes[nde];\n    if (node.jointName === jointName) {\n      return {\n        node: node,\n        id: nde\n      };\n    }\n  }\n  return null;\n};\n/**\n * Checks if a nodes is in joints\n * @param skins\n * @param id\n */\nconst nodeIsInJoints = (skins, id) => {\n  for (let i = 0; i < skins.jointNames.length; i++) {\n    if (skins.jointNames[i] === id) {\n      return true;\n    }\n  }\n  return false;\n};\n/**\n * Fills the nodes to root for bones and builds hierarchy\n * @param gltfRuntime\n * @param newSkeleton\n * @param skins\n * @param nodesToRoot\n */\nconst getNodesToRoot = (gltfRuntime, newSkeleton, skins, nodesToRoot) => {\n  // Creates nodes for root\n  for (const nde in gltfRuntime.nodes) {\n    const node = gltfRuntime.nodes[nde];\n    const id = nde;\n    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\n      continue;\n    }\n    // Create node to root bone\n    const mat = configureBoneTransformation(node);\n    const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\n    bone.id = id;\n    nodesToRoot.push({\n      bone: bone,\n      node: node,\n      id: id\n    });\n  }\n  // Parenting\n  for (let i = 0; i < nodesToRoot.length; i++) {\n    const nodeToRoot = nodesToRoot[i];\n    const children = nodeToRoot.node.children;\n    for (let j = 0; j < children.length; j++) {\n      let child = null;\n      for (let k = 0; k < nodesToRoot.length; k++) {\n        if (nodesToRoot[k].id === children[j]) {\n          child = nodesToRoot[k];\n          break;\n        }\n      }\n      if (child) {\n        child.bone._parent = nodeToRoot.bone;\n        nodeToRoot.bone.children.push(child.bone);\n      }\n    }\n  }\n};\n/**\n * Imports a skeleton\n * @param gltfRuntime\n * @param skins\n * @param mesh\n * @param newSkeleton\n */\nconst importSkeleton = (gltfRuntime, skins, mesh, newSkeleton) => {\n  if (!newSkeleton) {\n    newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\n  }\n  if (!skins.babylonSkeleton) {\n    return newSkeleton;\n  }\n  // Find the root bones\n  const nodesToRoot = [];\n  const nodesToRootToAdd = [];\n  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\n  newSkeleton.bones = [];\n  // Joints\n  for (let i = 0; i < skins.jointNames.length; i++) {\n    const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n    if (!jointNode) {\n      continue;\n    }\n    const node = jointNode.node;\n    if (!node) {\n      Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\n      continue;\n    }\n    const id = jointNode.id;\n    // Optimize, if the bone already exists...\n    const existingBone = gltfRuntime.scene.getBoneById(id);\n    if (existingBone) {\n      newSkeleton.bones.push(existingBone);\n      continue;\n    }\n    // Search for parent bone\n    let foundBone = false;\n    let parentBone = null;\n    for (let j = 0; j < i; j++) {\n      const jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\n      if (!jointNode) {\n        continue;\n      }\n      const joint = jointNode.node;\n      if (!joint) {\n        Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\n        continue;\n      }\n      const children = joint.children;\n      if (!children) {\n        continue;\n      }\n      foundBone = false;\n      for (let k = 0; k < children.length; k++) {\n        if (children[k] === id) {\n          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\n          foundBone = true;\n          break;\n        }\n      }\n      if (foundBone) {\n        break;\n      }\n    }\n    // Create bone\n    const mat = configureBoneTransformation(node);\n    if (!parentBone && nodesToRoot.length > 0) {\n      parentBone = getNodeToRoot(nodesToRoot, id);\n      if (parentBone) {\n        if (nodesToRootToAdd.indexOf(parentBone) === -1) {\n          nodesToRootToAdd.push(parentBone);\n        }\n      }\n    }\n    const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\n    bone.id = id;\n  }\n  // Polish\n  const bones = newSkeleton.bones;\n  newSkeleton.bones = [];\n  for (let i = 0; i < skins.jointNames.length; i++) {\n    const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\n    if (!jointNode) {\n      continue;\n    }\n    for (let j = 0; j < bones.length; j++) {\n      if (bones[j].id === jointNode.id) {\n        newSkeleton.bones.push(bones[j]);\n        break;\n      }\n    }\n  }\n  newSkeleton.prepare();\n  // Finish\n  for (let i = 0; i < nodesToRootToAdd.length; i++) {\n    newSkeleton.bones.push(nodesToRootToAdd[i]);\n  }\n  return newSkeleton;\n};\n/**\n * Imports a mesh and its geometries\n * @param gltfRuntime\n * @param node\n * @param meshes\n * @param id\n * @param newMesh\n */\nconst importMesh = (gltfRuntime, node, meshes, id, newMesh) => {\n  if (!newMesh) {\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n    newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\n    newMesh._parentContainer = gltfRuntime.assetContainer;\n    gltfRuntime.scene._blockEntityCollection = false;\n    newMesh.id = id;\n  }\n  if (!node.babylonNode) {\n    return newMesh;\n  }\n  const subMaterials = [];\n  let vertexData = null;\n  const verticesStarts = new Array();\n  const verticesCounts = new Array();\n  const indexStarts = new Array();\n  const indexCounts = new Array();\n  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n    const meshId = meshes[meshIndex];\n    const mesh = gltfRuntime.meshes[meshId];\n    if (!mesh) {\n      continue;\n    }\n    // Positions, normals and UVs\n    for (let i = 0; i < mesh.primitives.length; i++) {\n      // Temporary vertex data\n      const tempVertexData = new VertexData();\n      const primitive = mesh.primitives[i];\n      if (primitive.mode !== 4) {\n        // continue;\n      }\n      const attributes = primitive.attributes;\n      let accessor = null;\n      let buffer = null;\n      // Set positions, normal and uvs\n      for (const semantic in attributes) {\n        // Link accessor and buffer view\n        accessor = gltfRuntime.accessors[attributes[semantic]];\n        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n        if (semantic === \"NORMAL\") {\n          tempVertexData.normals = new Float32Array(buffer.length);\n          tempVertexData.normals.set(buffer);\n        } else if (semantic === \"POSITION\") {\n          if (GLTFFileLoader.HomogeneousCoordinates) {\n            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\n            for (let j = 0; j < buffer.length; j += 4) {\n              tempVertexData.positions[j] = buffer[j];\n              tempVertexData.positions[j + 1] = buffer[j + 1];\n              tempVertexData.positions[j + 2] = buffer[j + 2];\n            }\n          } else {\n            tempVertexData.positions = new Float32Array(buffer.length);\n            tempVertexData.positions.set(buffer);\n          }\n          verticesCounts.push(tempVertexData.positions.length);\n        } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\n          const channel = Number(semantic.split(\"_\")[1]);\n          const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\n          const uvs = new Float32Array(buffer.length);\n          uvs.set(buffer);\n          normalizeUVs(uvs);\n          tempVertexData.set(uvs, uvKind);\n        } else if (semantic === \"JOINT\") {\n          tempVertexData.matricesIndices = new Float32Array(buffer.length);\n          tempVertexData.matricesIndices.set(buffer);\n        } else if (semantic === \"WEIGHT\") {\n          tempVertexData.matricesWeights = new Float32Array(buffer.length);\n          tempVertexData.matricesWeights.set(buffer);\n        } else if (semantic === \"COLOR\") {\n          tempVertexData.colors = new Float32Array(buffer.length);\n          tempVertexData.colors.set(buffer);\n        }\n      }\n      // Indices\n      accessor = gltfRuntime.accessors[primitive.indices];\n      if (accessor) {\n        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\n        tempVertexData.indices = new Int32Array(buffer.length);\n        tempVertexData.indices.set(buffer);\n        indexCounts.push(tempVertexData.indices.length);\n      } else {\n        // Set indices on the fly\n        const indices = [];\n        for (let j = 0; j < tempVertexData.positions.length / 3; j++) {\n          indices.push(j);\n        }\n        tempVertexData.indices = new Int32Array(indices);\n        indexCounts.push(tempVertexData.indices.length);\n      }\n      if (!vertexData) {\n        vertexData = tempVertexData;\n      } else {\n        vertexData.merge(tempVertexData);\n      }\n      // Sub material\n      const material = gltfRuntime.scene.getMaterialById(primitive.material);\n      subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\n      // Update vertices start and index start\n      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\n      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\n    }\n  }\n  let material;\n  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n  if (subMaterials.length > 1) {\n    material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\n    material.subMaterials = subMaterials;\n  } else {\n    material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\n  }\n  if (subMaterials.length === 1) {\n    material = subMaterials[0];\n  }\n  material._parentContainer = gltfRuntime.assetContainer;\n  if (!newMesh.material) {\n    newMesh.material = material;\n  }\n  // Apply geometry\n  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);\n  newMesh.computeWorldMatrix(true);\n  gltfRuntime.scene._blockEntityCollection = false;\n  // Apply submeshes\n  newMesh.subMeshes = [];\n  let index = 0;\n  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n    const meshId = meshes[meshIndex];\n    const mesh = gltfRuntime.meshes[meshId];\n    if (!mesh) {\n      continue;\n    }\n    for (let i = 0; i < mesh.primitives.length; i++) {\n      if (mesh.primitives[i].mode !== 4) {\n        //continue;\n      }\n      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\n      index++;\n    }\n  }\n  // Finish\n  return newMesh;\n};\n/**\n * Configure node transformation from position, rotation and scaling\n * @param newNode\n * @param position\n * @param rotation\n * @param scaling\n */\nconst configureNode = (newNode, position, rotation, scaling) => {\n  if (newNode.position) {\n    newNode.position = position;\n  }\n  if (newNode.rotationQuaternion || newNode.rotation) {\n    newNode.rotationQuaternion = rotation;\n  }\n  if (newNode.scaling) {\n    newNode.scaling = scaling;\n  }\n};\n/**\n * Configures node from transformation matrix\n * @param newNode\n * @param node\n */\nconst configureNodeFromMatrix = (newNode, node) => {\n  if (node.matrix) {\n    const position = new Vector3(0, 0, 0);\n    const rotation = new Quaternion();\n    const scaling = new Vector3(0, 0, 0);\n    const mat = Matrix.FromArray(node.matrix);\n    mat.decompose(scaling, rotation, position);\n    configureNode(newNode, position, rotation, scaling);\n  } else if (node.translation && node.rotation && node.scale) {\n    configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\n  }\n  newNode.computeWorldMatrix(true);\n};\n/**\n * Imports a node\n * @param gltfRuntime\n * @param node\n * @param id\n */\nconst importNode = (gltfRuntime, node, id) => {\n  let lastNode = null;\n  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\n    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\n      return null;\n    }\n  }\n  // Meshes\n  if (node.skin) {\n    if (node.meshes) {\n      const skin = gltfRuntime.skins[node.skin];\n      const newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);\n      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\n      if (newMesh.skeleton === null) {\n        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\n        if (!skin.babylonSkeleton) {\n          skin.babylonSkeleton = newMesh.skeleton;\n        }\n      }\n      lastNode = newMesh;\n    }\n  } else if (node.meshes) {\n    /**\n     * Improve meshes property\n     */\n    const newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);\n    lastNode = newMesh;\n  }\n  // Lights\n  else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n    const light = gltfRuntime.lights[node.light];\n    if (light) {\n      if (light.type === \"ambient\") {\n        const ambienLight = light[light.type];\n        const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        hemiLight.name = node.name || \"\";\n        if (ambienLight.color) {\n          hemiLight.diffuse = Color3.FromArray(ambienLight.color);\n        }\n        lastNode = hemiLight;\n      } else if (light.type === \"directional\") {\n        const directionalLight = light[light.type];\n        const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        dirLight.name = node.name || \"\";\n        if (directionalLight.color) {\n          dirLight.diffuse = Color3.FromArray(directionalLight.color);\n        }\n        lastNode = dirLight;\n      } else if (light.type === \"point\") {\n        const pointLight = light[light.type];\n        const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\n        ptLight.name = node.name || \"\";\n        if (pointLight.color) {\n          ptLight.diffuse = Color3.FromArray(pointLight.color);\n        }\n        lastNode = ptLight;\n      } else if (light.type === \"spot\") {\n        const spotLight = light[light.type];\n        const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\n        spLight.name = node.name || \"\";\n        if (spotLight.color) {\n          spLight.diffuse = Color3.FromArray(spotLight.color);\n        }\n        if (spotLight.fallOfAngle) {\n          spLight.angle = spotLight.fallOfAngle;\n        }\n        if (spotLight.fallOffExponent) {\n          spLight.exponent = spotLight.fallOffExponent;\n        }\n        lastNode = spLight;\n      }\n    }\n  }\n  // Cameras\n  else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\n    const camera = gltfRuntime.cameras[node.camera];\n    if (camera) {\n      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n      if (camera.type === \"orthographic\") {\n        const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n        orthoCamera.name = node.name || \"\";\n        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\n        orthoCamera.attachControl();\n        lastNode = orthoCamera;\n        orthoCamera._parentContainer = gltfRuntime.assetContainer;\n      } else if (camera.type === \"perspective\") {\n        const perspectiveCamera = camera[camera.type];\n        const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\n        persCamera.name = node.name || \"\";\n        persCamera.attachControl();\n        if (!perspectiveCamera.aspectRatio) {\n          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\n        }\n        if (perspectiveCamera.znear && perspectiveCamera.zfar) {\n          persCamera.maxZ = perspectiveCamera.zfar;\n          persCamera.minZ = perspectiveCamera.znear;\n        }\n        lastNode = persCamera;\n        persCamera._parentContainer = gltfRuntime.assetContainer;\n      }\n      gltfRuntime.scene._blockEntityCollection = false;\n    }\n  }\n  // Empty node\n  if (!node.jointName) {\n    if (node.babylonNode) {\n      return node.babylonNode;\n    } else if (lastNode === null) {\n      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n      const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\n      dummy._parentContainer = gltfRuntime.assetContainer;\n      gltfRuntime.scene._blockEntityCollection = false;\n      node.babylonNode = dummy;\n      lastNode = dummy;\n    }\n  }\n  if (lastNode !== null) {\n    if (node.matrix && lastNode instanceof Mesh) {\n      configureNodeFromMatrix(lastNode, node);\n    } else {\n      const translation = node.translation || [0, 0, 0];\n      const rotation = node.rotation || [0, 0, 0, 1];\n      const scale = node.scale || [1, 1, 1];\n      configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\n    }\n    lastNode.updateCache(true);\n    node.babylonNode = lastNode;\n  }\n  return lastNode;\n};\n/**\n * Traverses nodes and creates them\n * @param gltfRuntime\n * @param id\n * @param parent\n * @param meshIncluded\n */\nconst traverseNodes = (gltfRuntime, id, parent, meshIncluded = false) => {\n  const node = gltfRuntime.nodes[id];\n  let newNode = null;\n  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\n    if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\n      meshIncluded = true;\n    } else {\n      meshIncluded = false;\n    }\n  } else {\n    meshIncluded = true;\n  }\n  if (!node.jointName && meshIncluded) {\n    newNode = importNode(gltfRuntime, node, id);\n    if (newNode !== null) {\n      newNode.id = id;\n      newNode.parent = parent;\n    }\n  }\n  if (node.children) {\n    for (let i = 0; i < node.children.length; i++) {\n      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\n    }\n  }\n};\n/**\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\n * @param gltfRuntime\n */\nconst postLoad = gltfRuntime => {\n  // Nodes\n  let currentScene = gltfRuntime.currentScene;\n  if (currentScene) {\n    for (let i = 0; i < currentScene.nodes.length; i++) {\n      traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n    }\n  } else {\n    for (const thing in gltfRuntime.scenes) {\n      currentScene = gltfRuntime.scenes[thing];\n      for (let i = 0; i < currentScene.nodes.length; i++) {\n        traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n      }\n    }\n  }\n  // Set animations\n  loadAnimations(gltfRuntime);\n  for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\n    const skeleton = gltfRuntime.scene.skeletons[i];\n    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\n  }\n};\n/**\n * onBind shaderrs callback to set uniforms and matrices\n * @param mesh\n * @param gltfRuntime\n * @param unTreatedUniforms\n * @param shaderMaterial\n * @param technique\n * @param material\n * @param onSuccess\n */\nconst onBindShaderMaterial = (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) => {\n  const materialValues = material.values || technique.parameters;\n  for (const unif in unTreatedUniforms) {\n    const uniform = unTreatedUniforms[unif];\n    const type = uniform.type;\n    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\n      if (uniform.semantic && !uniform.source && !uniform.node) {\n        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\n      } else if (uniform.semantic && (uniform.source || uniform.node)) {\n        let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\n        if (source === null) {\n          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\n        }\n        if (source === null) {\n          continue;\n        }\n        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\n      }\n    } else {\n      const value = materialValues[technique.uniforms[unif]];\n      if (!value) {\n        continue;\n      }\n      if (type === EParameterType.SAMPLER_2D) {\n        const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\n        if (texture === null || texture === undefined) {\n          continue;\n        }\n        shaderMaterial.getEffect().setTexture(unif, texture);\n      } else {\n        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\n      }\n    }\n  }\n  onSuccess(shaderMaterial);\n};\n/**\n * Prepare uniforms to send the only one time\n * Loads the appropriate textures\n * @param gltfRuntime\n * @param shaderMaterial\n * @param technique\n * @param material\n */\nconst prepareShaderMaterialUniforms = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) => {\n  const materialValues = material.values || technique.parameters;\n  const techniqueUniforms = technique.uniforms;\n  /**\n   * Prepare values here (not matrices)\n   */\n  for (const unif in unTreatedUniforms) {\n    const uniform = unTreatedUniforms[unif];\n    const type = uniform.type;\n    let value = materialValues[techniqueUniforms[unif]];\n    if (value === undefined) {\n      // In case the value is the same for all materials\n      value = uniform.value;\n    }\n    if (!value) {\n      continue;\n    }\n    const onLoadTexture = uniformName => {\n      return texture => {\n        if (uniform.value && uniformName) {\n          // Static uniform\n          shaderMaterial.setTexture(uniformName, texture);\n          delete unTreatedUniforms[uniformName];\n        }\n      };\n    };\n    // Texture (sampler2D)\n    if (type === EParameterType.SAMPLER_2D) {\n      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\n    }\n    // Others\n    else {\n      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\n        // Static uniform\n        delete unTreatedUniforms[unif];\n      }\n    }\n  }\n};\n/**\n * Shader compilation failed\n * @param program\n * @param shaderMaterial\n * @param onError\n */\nconst onShaderCompileError = (program, shaderMaterial, onError) => {\n  return (effect, error) => {\n    shaderMaterial.dispose(true);\n    onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\n  };\n};\n/**\n * Shader compilation success\n * @param gltfRuntime\n * @param shaderMaterial\n * @param technique\n * @param material\n * @param unTreatedUniforms\n * @param onSuccess\n */\nconst onShaderCompileSuccess = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) => {\n  return _ => {\n    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\n    shaderMaterial.onBind = mesh => {\n      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\n    };\n  };\n};\n/**\n * Returns the appropriate uniform if already handled by babylon\n * @param tokenizer\n * @param technique\n */\nconst parseShaderUniforms = (tokenizer, technique, unTreatedUniforms) => {\n  for (const unif in technique.uniforms) {\n    const uniform = technique.uniforms[unif];\n    const uniformParameter = technique.parameters[uniform];\n    if (tokenizer.currentIdentifier === unif) {\n      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\n        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n        if (transformIndex !== -1) {\n          delete unTreatedUniforms[unif];\n          return babylonTransforms[transformIndex];\n        }\n      }\n    }\n  }\n  return tokenizer.currentIdentifier;\n};\n/**\n * All shaders loaded. Create materials one by one\n * @param gltfRuntime\n */\nconst importMaterials = gltfRuntime => {\n  // Create materials\n  for (const mat in gltfRuntime.materials) {\n    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, () => {}, () => {});\n  }\n};\n/**\n * Implementation of the base glTF spec\n * @internal\n */\nexport class GLTFLoaderBase {\n  static CreateRuntime(parsedData, scene, rootUrl) {\n    const gltfRuntime = {\n      extensions: {},\n      accessors: {},\n      buffers: {},\n      bufferViews: {},\n      meshes: {},\n      lights: {},\n      cameras: {},\n      nodes: {},\n      images: {},\n      textures: {},\n      shaders: {},\n      programs: {},\n      samplers: {},\n      techniques: {},\n      materials: {},\n      animations: {},\n      skins: {},\n      extensionsUsed: [],\n      scenes: {},\n      buffersCount: 0,\n      shaderscount: 0,\n      scene: scene,\n      rootUrl: rootUrl,\n      loadedBufferCount: 0,\n      loadedBufferViews: {},\n      loadedShaderCount: 0,\n      importOnlyMeshes: false,\n      dummyNodes: [],\n      assetContainer: null\n    };\n    // Parse\n    if (parsedData.extensions) {\n      parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\n    }\n    if (parsedData.extensionsUsed) {\n      parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\n    }\n    if (parsedData.buffers) {\n      parseBuffers(parsedData.buffers, gltfRuntime);\n    }\n    if (parsedData.bufferViews) {\n      parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\n    }\n    if (parsedData.accessors) {\n      parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\n    }\n    if (parsedData.meshes) {\n      parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\n    }\n    if (parsedData.lights) {\n      parseObject(parsedData.lights, \"lights\", gltfRuntime);\n    }\n    if (parsedData.cameras) {\n      parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\n    }\n    if (parsedData.nodes) {\n      parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\n    }\n    if (parsedData.images) {\n      parseObject(parsedData.images, \"images\", gltfRuntime);\n    }\n    if (parsedData.textures) {\n      parseObject(parsedData.textures, \"textures\", gltfRuntime);\n    }\n    if (parsedData.shaders) {\n      parseShaders(parsedData.shaders, gltfRuntime);\n    }\n    if (parsedData.programs) {\n      parseObject(parsedData.programs, \"programs\", gltfRuntime);\n    }\n    if (parsedData.samplers) {\n      parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\n    }\n    if (parsedData.techniques) {\n      parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\n    }\n    if (parsedData.materials) {\n      parseObject(parsedData.materials, \"materials\", gltfRuntime);\n    }\n    if (parsedData.animations) {\n      parseObject(parsedData.animations, \"animations\", gltfRuntime);\n    }\n    if (parsedData.skins) {\n      parseObject(parsedData.skins, \"skins\", gltfRuntime);\n    }\n    if (parsedData.scenes) {\n      gltfRuntime.scenes = parsedData.scenes;\n    }\n    if (parsedData.scene && parsedData.scenes) {\n      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\n    }\n    return gltfRuntime;\n  }\n  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {\n    const buffer = gltfRuntime.buffers[id];\n    if (Tools.IsBase64(buffer.uri)) {\n      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, data => onSuccess(new Uint8Array(data)), onProgress, undefined, true, request => {\n        if (request) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  }\n  static LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {\n    const texture = gltfRuntime.textures[id];\n    if (!texture || !texture.source) {\n      onError(\"\");\n      return;\n    }\n    if (texture.babylonTexture) {\n      onSuccess(null);\n      return;\n    }\n    const source = gltfRuntime.images[texture.source];\n    if (Tools.IsBase64(source.uri)) {\n      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, data => onSuccess(new Uint8Array(data)), undefined, undefined, true, request => {\n        if (request) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  }\n  static CreateTextureAsync(gltfRuntime, id, buffer, onSuccess) {\n    const texture = gltfRuntime.textures[id];\n    if (texture.babylonTexture) {\n      onSuccess(texture.babylonTexture);\n      return;\n    }\n    const sampler = gltfRuntime.samplers[texture.sampler];\n    const createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\n    const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\n    const blob = buffer == null ? new Blob() : new Blob([buffer]);\n    const blobURL = URL.createObjectURL(blob);\n    const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\n    const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\n    if (sampler.wrapS !== undefined) {\n      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\n    }\n    if (sampler.wrapT !== undefined) {\n      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\n    }\n    newTexture.name = id;\n    texture.babylonTexture = newTexture;\n    onSuccess(newTexture);\n  }\n  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {\n    const shader = gltfRuntime.shaders[id];\n    if (Tools.IsBase64(shader.uri)) {\n      const shaderString = atob(shader.uri.split(\",\")[1]);\n      if (onSuccess) {\n        onSuccess(shaderString);\n      }\n    } else {\n      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, request => {\n        if (request && onError) {\n          onError(request.status + \" \" + request.statusText);\n        }\n      });\n    }\n  }\n  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n    const material = gltfRuntime.materials[id];\n    if (!material.technique) {\n      if (onError) {\n        onError(\"No technique found.\");\n      }\n      return;\n    }\n    const technique = gltfRuntime.techniques[material.technique];\n    if (!technique) {\n      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\n      const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\n      defaultMaterial._parentContainer = gltfRuntime.assetContainer;\n      gltfRuntime.scene._blockEntityCollection = false;\n      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\n      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n      onSuccess(defaultMaterial);\n      return;\n    }\n    const program = gltfRuntime.programs[technique.program];\n    const states = technique.states;\n    const vertexShader = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\n    const pixelShader = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\n    let newVertexShader = \"\";\n    let newPixelShader = \"\";\n    const vertexTokenizer = new Tokenizer(vertexShader);\n    const pixelTokenizer = new Tokenizer(pixelShader);\n    const unTreatedUniforms = {};\n    const uniforms = [];\n    const attributes = [];\n    const samplers = [];\n    // Fill uniform, sampler2D and attributes\n    for (const unif in technique.uniforms) {\n      const uniform = technique.uniforms[unif];\n      const uniformParameter = technique.parameters[uniform];\n      unTreatedUniforms[unif] = uniformParameter;\n      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\n        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\n        if (transformIndex !== -1) {\n          uniforms.push(babylonTransforms[transformIndex]);\n          delete unTreatedUniforms[unif];\n        } else {\n          uniforms.push(unif);\n        }\n      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\n        samplers.push(unif);\n      } else {\n        uniforms.push(unif);\n      }\n    }\n    for (const attr in technique.attributes) {\n      const attribute = technique.attributes[attr];\n      const attributeParameter = technique.parameters[attribute];\n      if (attributeParameter.semantic) {\n        const name = getAttribute(attributeParameter);\n        if (name) {\n          attributes.push(name);\n        }\n      }\n    }\n    // Configure vertex shader\n    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\n      const tokenType = vertexTokenizer.currentToken;\n      if (tokenType !== ETokenType.IDENTIFIER) {\n        newVertexShader += vertexTokenizer.currentString;\n        continue;\n      }\n      let foundAttribute = false;\n      for (const attr in technique.attributes) {\n        const attribute = technique.attributes[attr];\n        const attributeParameter = technique.parameters[attribute];\n        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\n          newVertexShader += getAttribute(attributeParameter);\n          foundAttribute = true;\n          break;\n        }\n      }\n      if (foundAttribute) {\n        continue;\n      }\n      newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\n    }\n    // Configure pixel shader\n    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\n      const tokenType = pixelTokenizer.currentToken;\n      if (tokenType !== ETokenType.IDENTIFIER) {\n        newPixelShader += pixelTokenizer.currentString;\n        continue;\n      }\n      newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\n    }\n    // Create shader material\n    const shaderPath = {\n      vertex: program.vertexShader + id,\n      fragment: program.fragmentShader + id\n    };\n    const options = {\n      attributes: attributes,\n      uniforms: uniforms,\n      samplers: samplers,\n      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1\n    };\n    Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\n    Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\n    const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\n    shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\n    shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\n    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\n    if (states && states.functions) {\n      const functions = states.functions;\n      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\n        shaderMaterial.backFaceCulling = false;\n      }\n      const blendFunc = functions.blendFuncSeparate;\n      if (blendFunc) {\n        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\n        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\n        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_ADD;\n        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\n        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\n        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {\n          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\n        }\n      }\n    }\n  }\n}\n/**\n * glTF V1 Loader\n * @internal\n * @deprecated\n */\nexport class GLTFLoader {\n  static RegisterExtension(extension) {\n    if (GLTFLoader.Extensions[extension.name]) {\n      Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\n      return;\n    }\n    GLTFLoader.Extensions[extension.name] = extension;\n  }\n  dispose() {\n    // do nothing\n  }\n  _importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {\n    scene.useRightHandedSystem = true;\n    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, gltfRuntime => {\n      gltfRuntime.assetContainer = assetContainer;\n      gltfRuntime.importOnlyMeshes = true;\n      if (meshesNames === \"\") {\n        gltfRuntime.importMeshesNames = [];\n      } else if (typeof meshesNames === \"string\") {\n        gltfRuntime.importMeshesNames = [meshesNames];\n      } else if (meshesNames && !(meshesNames instanceof Array)) {\n        gltfRuntime.importMeshesNames = [meshesNames];\n      } else {\n        gltfRuntime.importMeshesNames = [];\n        Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\n      }\n      // Create nodes\n      this._createNodes(gltfRuntime);\n      const meshes = new Array();\n      const skeletons = new Array();\n      // Fill arrays of meshes and skeletons\n      for (const nde in gltfRuntime.nodes) {\n        const node = gltfRuntime.nodes[nde];\n        if (node.babylonNode instanceof AbstractMesh) {\n          meshes.push(node.babylonNode);\n        }\n      }\n      for (const skl in gltfRuntime.skins) {\n        const skin = gltfRuntime.skins[skl];\n        if (skin.babylonSkeleton instanceof Skeleton) {\n          skeletons.push(skin.babylonSkeleton);\n        }\n      }\n      // Load buffers, shaders, materials, etc.\n      this._loadBuffersAsync(gltfRuntime, () => {\n        this._loadShadersAsync(gltfRuntime, () => {\n          importMaterials(gltfRuntime);\n          postLoad(gltfRuntime);\n          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\n            onSuccess(meshes, skeletons);\n          }\n        });\n      });\n      if (GLTFFileLoader.IncrementalLoading && onSuccess) {\n        onSuccess(meshes, skeletons);\n      }\n    }, onError);\n    return true;\n  }\n  /**\n   * Imports one or more meshes from a loaded gltf file and adds them to the scene\n   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n   * @param scene the scene the meshes should be added to\n   * @param assetContainer defines the asset container to use (can be null)\n   * @param data gltf data containing information of the meshes in a loaded file\n   * @param rootUrl root url to load from\n   * @param onProgress event that fires when loading progress has occured\n   * @returns a promise containg the loaded meshes, particles, skeletons and animations\n   */\n  importMeshAsync(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {\n    return new Promise((resolve, reject) => {\n      this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, (meshes, skeletons) => {\n        resolve({\n          meshes: meshes,\n          particleSystems: [],\n          skeletons: skeletons,\n          animationGroups: [],\n          lights: [],\n          transformNodes: [],\n          geometries: []\n        });\n      }, onProgress, message => {\n        reject(new Error(message));\n      });\n    });\n  }\n  _loadAsync(scene, data, rootUrl, onSuccess, onProgress, onError) {\n    scene.useRightHandedSystem = true;\n    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, gltfRuntime => {\n      // Load runtime extensios\n      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {\n        // Create nodes\n        this._createNodes(gltfRuntime);\n        // Load buffers, shaders, materials, etc.\n        this._loadBuffersAsync(gltfRuntime, () => {\n          this._loadShadersAsync(gltfRuntime, () => {\n            importMaterials(gltfRuntime);\n            postLoad(gltfRuntime);\n            if (!GLTFFileLoader.IncrementalLoading) {\n              onSuccess();\n            }\n          });\n        });\n        if (GLTFFileLoader.IncrementalLoading) {\n          onSuccess();\n        }\n      }, onError);\n    }, onError);\n  }\n  /**\n   * Imports all objects from a loaded gltf file and adds them to the scene\n   * @param scene the scene the objects should be added to\n   * @param data gltf data containing information of the meshes in a loaded file\n   * @param rootUrl root url to load from\n   * @param onProgress event that fires when loading progress has occured\n   * @returns a promise which completes when objects have been loaded to the scene\n   */\n  loadAsync(scene, data, rootUrl, onProgress) {\n    return new Promise((resolve, reject) => {\n      this._loadAsync(scene, data, rootUrl, () => {\n        resolve();\n      }, onProgress, message => {\n        reject(new Error(message));\n      });\n    });\n  }\n  _loadShadersAsync(gltfRuntime, onload) {\n    let hasShaders = false;\n    const processShader = (sha, shader) => {\n      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, shaderString => {\n        if (shaderString instanceof ArrayBuffer) {\n          return;\n        }\n        gltfRuntime.loadedShaderCount++;\n        if (shaderString) {\n          Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\n        }\n        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\n          onload();\n        }\n      }, () => {\n        Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\n      });\n    };\n    for (const sha in gltfRuntime.shaders) {\n      hasShaders = true;\n      const shader = gltfRuntime.shaders[sha];\n      if (shader) {\n        processShader.bind(this, sha, shader)();\n      } else {\n        Tools.Error(\"No shader named: \" + sha);\n      }\n    }\n    if (!hasShaders) {\n      onload();\n    }\n  }\n  _loadBuffersAsync(gltfRuntime, onLoad) {\n    let hasBuffers = false;\n    const processBuffer = (buf, buffer) => {\n      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, bufferView => {\n        gltfRuntime.loadedBufferCount++;\n        if (bufferView) {\n          if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\n            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\n          }\n\n          gltfRuntime.loadedBufferViews[buf] = bufferView;\n        }\n        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\n          onLoad();\n        }\n      }, () => {\n        Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\n      });\n    };\n    for (const buf in gltfRuntime.buffers) {\n      hasBuffers = true;\n      const buffer = gltfRuntime.buffers[buf];\n      if (buffer) {\n        processBuffer.bind(this, buf, buffer)();\n      } else {\n        Tools.Error(\"No buffer named: \" + buf);\n      }\n    }\n    if (!hasBuffers) {\n      onLoad();\n    }\n  }\n  _createNodes(gltfRuntime) {\n    let currentScene = gltfRuntime.currentScene;\n    if (currentScene) {\n      // Only one scene even if multiple scenes are defined\n      for (let i = 0; i < currentScene.nodes.length; i++) {\n        traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n      }\n    } else {\n      // Load all scenes\n      for (const thing in gltfRuntime.scenes) {\n        currentScene = gltfRuntime.scenes[thing];\n        for (let i = 0; i < currentScene.nodes.length; i++) {\n          traverseNodes(gltfRuntime, currentScene.nodes[i], null);\n        }\n      }\n    }\n  }\n}\nGLTFLoader.Extensions = {};\n/** @internal */\nexport class GLTFLoaderExtension {\n  constructor(name) {\n    this._name = name;\n  }\n  get name() {\n    return this._name;\n  }\n  /**\n   * Defines an override for loading the runtime\n   * Return true to stop further extensions from loading the runtime\n   * @param scene\n   * @param data\n   * @param rootUrl\n   * @param onSuccess\n   * @param onError\n   */\n  loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {\n    return false;\n  }\n  /**\n   * Defines an onverride for creating gltf runtime\n   * Return true to stop further extensions from creating the runtime\n   * @param gltfRuntime\n   * @param onSuccess\n   * @param onError\n   */\n  loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {\n    return false;\n  }\n  /**\n   * Defines an override for loading buffers\n   * Return true to stop further extensions from loading this buffer\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   * @param onProgress\n   */\n  loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {\n    return false;\n  }\n  /**\n   * Defines an override for loading texture buffers\n   * Return true to stop further extensions from loading this texture data\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   */\n  loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {\n    return false;\n  }\n  /**\n   * Defines an override for creating textures\n   * Return true to stop further extensions from loading this texture\n   * @param gltfRuntime\n   * @param id\n   * @param buffer\n   * @param onSuccess\n   * @param onError\n   */\n  createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {\n    return false;\n  }\n  /**\n   * Defines an override for loading shader strings\n   * Return true to stop further extensions from loading this shader data\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   */\n  loadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {\n    return false;\n  }\n  /**\n   * Defines an override for loading materials\n   * Return true to stop further extensions from loading this material\n   * @param gltfRuntime\n   * @param id\n   * @param onSuccess\n   * @param onError\n   */\n  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n    return false;\n  }\n  // ---------\n  // Utilities\n  // ---------\n  static LoadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\n    }, () => {\n      setTimeout(() => {\n        if (!onSuccess) {\n          return;\n        }\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\n      });\n    });\n  }\n  static LoadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\n    }, () => {\n      setTimeout(() => {\n        onSuccess();\n      });\n    });\n  }\n  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n    }, () => {\n      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\n    });\n  }\n  static LoadTextureAsync(gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, buffer => {\n      if (buffer) {\n        GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n      }\n    }, onError);\n  }\n  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n    }, () => {\n      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  }\n  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n    }, () => {\n      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  }\n  static _LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n    }, () => {\n      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\n    });\n  }\n  static _CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {\n    GLTFLoaderExtension._ApplyExtensions(loaderExtension => {\n      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\n    }, () => {\n      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\n    });\n  }\n  static _ApplyExtensions(func, defaultFunc) {\n    for (const extensionName in GLTFLoader.Extensions) {\n      const loaderExtension = GLTFLoader.Extensions[extensionName];\n      if (func(loaderExtension)) {\n        return;\n      }\n    }\n    defaultFunc();\n  }\n}\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();","map":{"version":3,"mappings":"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","names":["EParameterType","ETextureFilterType","ECullingType","EBlendingFunction","EShaderType","Quaternion","Vector3","Matrix","Color3","Tools","Camera","FreeCamera","Animation","Bone","Skeleton","Effect","Material","MultiMaterial","StandardMaterial","ShaderMaterial","Texture","VertexData","VertexBuffer","Geometry","SubMesh","AbstractMesh","Mesh","HemisphericLight","DirectionalLight","PointLight","SpotLight","GLTFUtils","GLTFFileLoader","Constants","ETokenType","Tokenizer","constructor","toParse","UNKNOWN","_toParse","_maxPos","length","getNextToken","isEnd","END_OF_INPUT","currentString","read","currentToken","isLetterOrDigitPattern","test","IDENTIFIER","currentIdentifier","peek","forward","_pos","glTFTransforms","babylonTransforms","glTFAnimationPaths","babylonAnimationPaths","parseBuffers","parsedBuffers","gltfRuntime","buf","parsedBuffer","buffers","buffersCount","parseShaders","parsedShaders","sha","parsedShader","shaders","shaderscount","parseObject","parsedObjects","runtimeProperty","object","parsedObject","normalizeUVs","buffer","i","getAttribute","attributeParameter","semantic","indexOf","channel","Number","split","loadAnimations","anim","animations","animation","channels","samplers","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","GetBufferFromAccessor","accessors","bufferOutput","targetId","target","id","targetNode","scene","getNodeById","getNodeByName","Warn","isBone","targetPath","path","targetPathIndex","animationType","ANIMATIONTYPE_MATRIX","ANIMATIONTYPE_QUATERNION","rotationQuaternion","ANIMATIONTYPE_VECTOR3","babylonAnimation","keys","arrayOffset","modifyKey","getKeys","_blockEntityCollection","assetContainer","ANIMATIONLOOPMODE_CYCLE","j","value","FromArray","bone","translation","Zero","scaling","mat","getBaseMatrix","decompose","Compose","push","frame","setKeys","stopAnimation","beginAnimation","configureBoneTransformation","node","rotation","scale","position","matrix","getParentBone","skins","jointName","newSkeleton","bones","name","nodes","nde","children","child","getNodeToRoot","nodesToRoot","nodeToRoot","getJointNode","nodeIsInJoints","jointNames","getNodesToRoot","k","_parent","importSkeleton","mesh","babylonSkeleton","nodesToRootToAdd","jointNode","existingBone","getBoneById","foundBone","parentBone","joint","prepare","importMesh","meshes","newMesh","_parentContainer","babylonNode","subMaterials","vertexData","verticesStarts","Array","verticesCounts","indexStarts","indexCounts","meshIndex","meshId","primitives","tempVertexData","primitive","mode","attributes","accessor","normals","Float32Array","set","HomogeneousCoordinates","positions","uvKind","UVKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","material","getMaterialById","GetDefaultMaterial","computeWorldMatrix","subMeshes","index","AddToMesh","configureNode","newNode","configureNodeFromMatrix","importNode","lastNode","importOnlyMeshes","skin","importMeshesNames","skeleton","getLastSkeletonById","light","lights","type","ambienLight","hemiLight","color","diffuse","directionalLight","dirLight","pointLight","ptLight","spotLight","spLight","fallOfAngle","angle","fallOffExponent","exponent","camera","cameras","orthoCamera","ORTHOGRAPHIC_CAMERA","attachControl","perspectiveCamera","persCamera","aspectRatio","getEngine","getRenderWidth","getRenderHeight","znear","zfar","maxZ","minZ","dummy","updateCache","traverseNodes","parent","meshIncluded","postLoad","currentScene","thing","scenes","skeletons","MAX_VALUE","onBindShaderMaterial","unTreatedUniforms","shaderMaterial","technique","onSuccess","materialValues","values","unif","uniform","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","source","SetMatrix","getEffect","uniforms","SAMPLER_2D","texture","textures","babylonTexture","undefined","setTexture","SetUniform","prepareShaderMaterialUniforms","techniqueUniforms","onLoadTexture","uniformName","GLTFLoaderExtension","LoadTextureAsync","onShaderCompileError","program","onError","effect","error","dispose","onShaderCompileSuccess","_","onBind","parseShaderUniforms","tokenizer","uniformParameter","transformIndex","importMaterials","materials","LoadMaterialAsync","GLTFLoaderBase","CreateRuntime","parsedData","rootUrl","extensions","bufferViews","images","programs","techniques","extensionsUsed","loadedBufferCount","loadedBufferViews","loadedShaderCount","dummyNodes","LoadBufferAsync","onProgress","IsBase64","uri","setTimeout","Uint8Array","DecodeBase64","LoadFile","data","request","status","statusText","LoadTextureBufferAsync","CreateTextureAsync","createMipMaps","minFilter","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","samplingMode","BILINEAR_SAMPLINGMODE","blob","Blob","blobURL","URL","createObjectURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","GetWrapMode","wrapT","wrapV","LoadShaderStringAsync","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","CounterClockWiseSideOrientation","states","vertexShader","ShadersStore","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","pixelTokenizer","attr","attribute","tokenType","foundAttribute","shaderPath","vertex","fragment","options","needAlphaBlending","enable","onCompiled","functions","cullFace","BACK","backFaceCulling","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","GLTFLoader","RegisterExtension","extension","Extensions","Error","_importMeshAsync","meshesNames","useRightHandedSystem","LoadRuntimeAsync","_createNodes","skl","_loadBuffersAsync","_loadShadersAsync","IncrementalLoading","importMeshAsync","Promise","resolve","reject","particleSystems","animationGroups","transformNodes","geometries","message","_loadAsync","LoadRuntimeExtensionsAsync","loadAsync","onload","hasShaders","processShader","ArrayBuffer","VERTEX","bind","onLoad","hasBuffers","processBuffer","bufferView","byteLength","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","_ApplyExtensions","loaderExtension","json","_LoadTextureBufferAsync","_CreateTextureAsync","func","defaultFunc","extensionName","_CreateGLTF1Loader"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/glTF/1.0/glTFLoader.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst babylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst babylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst parseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst parseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst parseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst normalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst getAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst loadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = babylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst configureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n */\r\nconst getParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = configureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n */\r\nconst getNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n */\r\nconst getJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n */\r\nconst nodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst getNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = configureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n */\r\nconst importSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = getJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = configureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = getNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n */\r\nconst importMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts = new Array<number>();\r\n    const verticesCounts = new Array<number>();\r\n    const indexStarts = new Array<number>();\r\n    const indexCounts = new Array<number>();\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    normalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        (material as MultiMaterial).subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst configureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst configureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        configureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        configureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n */\r\nconst importNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = importMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            configureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            configureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst traverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = importNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst postLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    loadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst onBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, <Effect>shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                (<Effect>shaderMaterial.getEffect()).setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(<Effect>shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst prepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n */\r\nconst onShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n */\r\nconst onShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n */\r\nconst parseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return babylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst importMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @internal\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            parseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            parseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            parseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            parseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            parseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            parseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            parseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            parseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            parseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            parseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            parseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            parseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            parseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            parseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            parseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            parseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            parseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            parseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(babylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = getAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += getAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes = new Array<AbstractMesh>();\r\n                const skeletons = new Array<Skeleton>();\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(<AbstractMesh>node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        importMaterials(gltfRuntime);\r\n                        postLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                importMaterials(gltfRuntime);\r\n                                postLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = <IGLTFScene>gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    traverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     */\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     */\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}