{"ast":null,"code":"import { Scalar } from \"./math.scalar.js\";\nimport { ToLinearSpace, ToGammaSpace } from \"./math.constants.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * Class used to hold a RGB color\n */\nexport class Color3 {\n  /**\n   * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n   * @param r defines the red component (between 0 and 1, default is 0)\n   * @param g defines the green component (between 0 and 1, default is 0)\n   * @param b defines the blue component (between 0 and 1, default is 0)\n   */\n  constructor(\n  /**\n   * Defines the red component (between 0 and 1, default is 0)\n   */\n  r = 0,\n  /**\n   * Defines the green component (between 0 and 1, default is 0)\n   */\n  g = 0,\n  /**\n   * Defines the blue component (between 0 and 1, default is 0)\n   */\n  b = 0) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n  /**\n   * Creates a string with the Color3 current values\n   * @returns the string representation of the Color3 object\n   */\n  toString() {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n  }\n  /**\n   * Returns the string \"Color3\"\n   * @returns \"Color3\"\n   */\n  getClassName() {\n    return \"Color3\";\n  }\n  /**\n   * Compute the Color3 hash code\n   * @returns an unique number that can be used to hash Color3 objects\n   */\n  getHashCode() {\n    let hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    return hash;\n  }\n  // Operators\n  /**\n   * Stores in the given array from the given starting index the red, green, blue values as successive elements\n   * @param array defines the array where to store the r,g,b components\n   * @param index defines an optional index in the target array to define where to start storing values\n   * @returns the current Color3 object\n   */\n  toArray(array, index = 0) {\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    return this;\n  }\n  /**\n   * Update the current color with values stored in an array from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns the current Color3 object\n   */\n  fromArray(array, offset = 0) {\n    Color3.FromArrayToRef(array, offset, this);\n    return this;\n  }\n  /**\n   * Returns a new Color4 object from the current Color3 and the given alpha\n   * @param alpha defines the alpha component on the new Color4 object (default is 1)\n   * @returns a new Color4 object\n   */\n  toColor4(alpha = 1) {\n    return new Color4(this.r, this.g, this.b, alpha);\n  }\n  /**\n   * Returns a new array populated with 3 numeric elements : red, green and blue values\n   * @returns the new array\n   */\n  asArray() {\n    return [this.r, this.g, this.b];\n  }\n  /**\n   * Returns the luminance value\n   * @returns a float value\n   */\n  toLuminance() {\n    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n  }\n  /**\n   * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n   * @param otherColor defines the second operand\n   * @returns the new Color3 object\n   */\n  multiply(otherColor) {\n    return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n  }\n  /**\n   * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines the Color3 object where to store the result\n   * @returns the current Color3\n   */\n  multiplyToRef(otherColor, result) {\n    result.r = this.r * otherColor.r;\n    result.g = this.g * otherColor.g;\n    result.b = this.b * otherColor.b;\n    return this;\n  }\n  /**\n   * Determines equality between Color3 objects\n   * @param otherColor defines the second operand\n   * @returns true if the rgb values are equal to the given ones\n   */\n  equals(otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n  }\n  /**\n   * Determines equality between the current Color3 object and a set of r,b,g values\n   * @param r defines the red component to check\n   * @param g defines the green component to check\n   * @param b defines the blue component to check\n   * @returns true if the rgb values are equal to the given ones\n   */\n  equalsFloats(r, g, b) {\n    return this.r === r && this.g === g && this.b === b;\n  }\n  /**\n   * Creates a new Color3 with the current Color3 values multiplied by scale\n   * @param scale defines the scaling factor to apply\n   * @returns a new Color3 object\n   */\n  scale(scale) {\n    return new Color3(this.r * scale, this.g * scale, this.b * scale);\n  }\n  /**\n   * Multiplies the Color3 values by the float \"scale\"\n   * @param scale defines the scaling factor to apply\n   * @returns the current updated Color3\n   */\n  scaleInPlace(scale) {\n    this.r *= scale;\n    this.g *= scale;\n    this.b *= scale;\n    return this;\n  }\n  /**\n   * Multiplies the rgb values by scale and stores the result into \"result\"\n   * @param scale defines the scaling factor\n   * @param result defines the Color3 object where to store the result\n   * @returns the unmodified current Color3\n   */\n  scaleToRef(scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    return this;\n  }\n  /**\n   * Scale the current Color3 values by a factor and add the result to a given Color3\n   * @param scale defines the scale factor\n   * @param result defines color to store the result into\n   * @returns the unmodified current Color3\n   */\n  scaleAndAddToRef(scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    return this;\n  }\n  /**\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\n   * @param min defines minimum clamping value (default is 0)\n   * @param max defines maximum clamping value (default is 1)\n   * @param result defines color to store the result into\n   * @returns the original Color3\n   */\n  clampToRef(min = 0, max = 1, result) {\n    result.r = Scalar.Clamp(this.r, min, max);\n    result.g = Scalar.Clamp(this.g, min, max);\n    result.b = Scalar.Clamp(this.b, min, max);\n    return this;\n  }\n  /**\n   * Creates a new Color3 set with the added values of the current Color3 and of the given one\n   * @param otherColor defines the second operand\n   * @returns the new Color3\n   */\n  add(otherColor) {\n    return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n  }\n  /**\n   * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines Color3 object to store the result into\n   * @returns the unmodified current Color3\n   */\n  addToRef(otherColor, result) {\n    result.r = this.r + otherColor.r;\n    result.g = this.g + otherColor.g;\n    result.b = this.b + otherColor.b;\n    return this;\n  }\n  /**\n   * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n   * @param otherColor defines the second operand\n   * @returns the new Color3\n   */\n  subtract(otherColor) {\n    return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n  }\n  /**\n   * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n   * @param otherColor defines the second operand\n   * @param result defines Color3 object to store the result into\n   * @returns the unmodified current Color3\n   */\n  subtractToRef(otherColor, result) {\n    result.r = this.r - otherColor.r;\n    result.g = this.g - otherColor.g;\n    result.b = this.b - otherColor.b;\n    return this;\n  }\n  /**\n   * Copy the current object\n   * @returns a new Color3 copied the current one\n   */\n  clone() {\n    return new Color3(this.r, this.g, this.b);\n  }\n  /**\n   * Copies the rgb values from the source in the current Color3\n   * @param source defines the source Color3 object\n   * @returns the updated Color3 object\n   */\n  copyFrom(source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    return this;\n  }\n  /**\n   * Updates the Color3 rgb values from the given floats\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @returns the current Color3 object\n   */\n  copyFromFloats(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  }\n  /**\n   * Updates the Color3 rgb values from the given floats\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @returns the current Color3 object\n   */\n  set(r, g, b) {\n    return this.copyFromFloats(r, g, b);\n  }\n  /**\n   * Compute the Color3 hexadecimal code as a string\n   * @returns a string containing the hexadecimal representation of the Color3 object\n   */\n  toHexString() {\n    const intR = Math.round(this.r * 255);\n    const intG = Math.round(this.g * 255);\n    const intB = Math.round(this.b * 255);\n    return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n  }\n  /**\n   * Computes a new Color3 converted from the current one to linear space\n   * @returns a new Color3 object\n   */\n  toLinearSpace() {\n    const convertedColor = new Color3();\n    this.toLinearSpaceToRef(convertedColor);\n    return convertedColor;\n  }\n  /**\n   * Converts current color in rgb space to HSV values\n   * @returns a new color3 representing the HSV values\n   */\n  toHSV() {\n    const result = new Color3();\n    this.toHSVToRef(result);\n    return result;\n  }\n  /**\n   * Converts current color in rgb space to HSV values\n   * @param result defines the Color3 where to store the HSV values\n   */\n  toHSVToRef(result) {\n    const r = this.r;\n    const g = this.g;\n    const b = this.b;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const v = max;\n    const dm = max - min;\n    if (max !== 0) {\n      s = dm / max;\n    }\n    if (max != min) {\n      if (max == r) {\n        h = (g - b) / dm;\n        if (g < b) {\n          h += 6;\n        }\n      } else if (max == g) {\n        h = (b - r) / dm + 2;\n      } else if (max == b) {\n        h = (r - g) / dm + 4;\n      }\n      h *= 60;\n    }\n    result.r = h;\n    result.g = s;\n    result.b = v;\n  }\n  /**\n   * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color3 object where to store the linear space version\n   * @returns the unmodified Color3\n   */\n  toLinearSpaceToRef(convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToLinearSpace);\n    convertedColor.g = Math.pow(this.g, ToLinearSpace);\n    convertedColor.b = Math.pow(this.b, ToLinearSpace);\n    return this;\n  }\n  /**\n   * Computes a new Color3 converted from the current one to gamma space\n   * @returns a new Color3 object\n   */\n  toGammaSpace() {\n    const convertedColor = new Color3();\n    this.toGammaSpaceToRef(convertedColor);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color3 object where to store the gamma space version\n   * @returns the unmodified Color3\n   */\n  toGammaSpaceToRef(convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToGammaSpace);\n    convertedColor.g = Math.pow(this.g, ToGammaSpace);\n    convertedColor.b = Math.pow(this.b, ToGammaSpace);\n    return this;\n  }\n  /**\n   * Converts Hue, saturation and value to a Color3 (RGB)\n   * @param hue defines the hue\n   * @param saturation defines the saturation\n   * @param value defines the value\n   * @param result defines the Color3 where to store the RGB values\n   */\n  static HSVtoRGBToRef(hue, saturation, value, result) {\n    const chroma = value * saturation;\n    const h = hue / 60;\n    const x = chroma * (1 - Math.abs(h % 2 - 1));\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (h >= 0 && h <= 1) {\n      r = chroma;\n      g = x;\n    } else if (h >= 1 && h <= 2) {\n      r = x;\n      g = chroma;\n    } else if (h >= 2 && h <= 3) {\n      g = chroma;\n      b = x;\n    } else if (h >= 3 && h <= 4) {\n      g = x;\n      b = chroma;\n    } else if (h >= 4 && h <= 5) {\n      r = x;\n      b = chroma;\n    } else if (h >= 5 && h <= 6) {\n      r = chroma;\n      b = x;\n    }\n    const m = value - chroma;\n    result.set(r + m, g + m, b + m);\n  }\n  /**\n   * Converts Hue, saturation and value to a new Color3 (RGB)\n   * @param hue defines the hue (value between 0 and 360)\n   * @param saturation defines the saturation (value between 0 and 1)\n   * @param value defines the value (value between 0 and 1)\n   * @returns a new Color3 object\n   */\n  static FromHSV(hue, saturation, value) {\n    const result = new Color3(0, 0, 0);\n    Color3.HSVtoRGBToRef(hue, saturation, value, result);\n    return result;\n  }\n  /**\n   * Creates a new Color3 from the string containing valid hexadecimal values\n   * @param hex defines a string containing valid hexadecimal values\n   * @returns a new Color3 object\n   */\n  static FromHexString(hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n      return new Color3(0, 0, 0);\n    }\n    const r = parseInt(hex.substring(1, 3), 16);\n    const g = parseInt(hex.substring(3, 5), 16);\n    const b = parseInt(hex.substring(5, 7), 16);\n    return Color3.FromInts(r, g, b);\n  }\n  /**\n   * Creates a new Color3 from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns a new Color3 object\n   */\n  static FromArray(array, offset = 0) {\n    return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n  }\n  /**\n   * Creates a new Color3 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @param result defines the target Color3 object\n   */\n  static FromArrayToRef(array, offset = 0, result) {\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n  }\n  /**\n   * Creates a new Color3 from integer values (< 256)\n   * @param r defines the red component to read from (value between 0 and 255)\n   * @param g defines the green component to read from (value between 0 and 255)\n   * @param b defines the blue component to read from (value between 0 and 255)\n   * @returns a new Color3 object\n   */\n  static FromInts(r, g, b) {\n    return new Color3(r / 255.0, g / 255.0, b / 255.0);\n  }\n  /**\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n   * @param start defines the start Color3 value\n   * @param end defines the end Color3 value\n   * @param amount defines the gradient value between start and end\n   * @returns a new Color3 object\n   */\n  static Lerp(start, end, amount) {\n    const result = new Color3(0.0, 0.0, 0.0);\n    Color3.LerpToRef(start, end, amount, result);\n    return result;\n  }\n  /**\n   * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @param result defines the Color3 object where to store the result\n   */\n  static LerpToRef(left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n  }\n  /**\n   * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent Color3\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent Color3\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns the new Color3\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n    return new Color3(r, g, b);\n  }\n  /**\n   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const result = Color3.Black();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  }\n  /**\n   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n    const t2 = time * time;\n    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n  }\n  /**\n   * Returns a Color3 value containing a red color\n   * @returns a new Color3 object\n   */\n  static Red() {\n    return new Color3(1, 0, 0);\n  }\n  /**\n   * Returns a Color3 value containing a green color\n   * @returns a new Color3 object\n   */\n  static Green() {\n    return new Color3(0, 1, 0);\n  }\n  /**\n   * Returns a Color3 value containing a blue color\n   * @returns a new Color3 object\n   */\n  static Blue() {\n    return new Color3(0, 0, 1);\n  }\n  /**\n   * Returns a Color3 value containing a black color\n   * @returns a new Color3 object\n   */\n  static Black() {\n    return new Color3(0, 0, 0);\n  }\n  /**\n   * Gets a Color3 value containing a black color that must not be updated\n   */\n  static get BlackReadOnly() {\n    return Color3._BlackReadOnly;\n  }\n  /**\n   * Returns a Color3 value containing a white color\n   * @returns a new Color3 object\n   */\n  static White() {\n    return new Color3(1, 1, 1);\n  }\n  /**\n   * Returns a Color3 value containing a purple color\n   * @returns a new Color3 object\n   */\n  static Purple() {\n    return new Color3(0.5, 0, 0.5);\n  }\n  /**\n   * Returns a Color3 value containing a magenta color\n   * @returns a new Color3 object\n   */\n  static Magenta() {\n    return new Color3(1, 0, 1);\n  }\n  /**\n   * Returns a Color3 value containing a yellow color\n   * @returns a new Color3 object\n   */\n  static Yellow() {\n    return new Color3(1, 1, 0);\n  }\n  /**\n   * Returns a Color3 value containing a gray color\n   * @returns a new Color3 object\n   */\n  static Gray() {\n    return new Color3(0.5, 0.5, 0.5);\n  }\n  /**\n   * Returns a Color3 value containing a teal color\n   * @returns a new Color3 object\n   */\n  static Teal() {\n    return new Color3(0, 1.0, 1.0);\n  }\n  /**\n   * Returns a Color3 value containing a random color\n   * @returns a new Color3 object\n   */\n  static Random() {\n    return new Color3(Math.random(), Math.random(), Math.random());\n  }\n}\n// Statics\nColor3._BlackReadOnly = Color3.Black();\n/**\n * Class used to hold a RBGA color\n */\nexport class Color4 {\n  /**\n   * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n   * @param r defines the red component (between 0 and 1, default is 0)\n   * @param g defines the green component (between 0 and 1, default is 0)\n   * @param b defines the blue component (between 0 and 1, default is 0)\n   * @param a defines the alpha component (between 0 and 1, default is 1)\n   */\n  constructor(\n  /**\n   * Defines the red component (between 0 and 1, default is 0)\n   */\n  r = 0,\n  /**\n   * Defines the green component (between 0 and 1, default is 0)\n   */\n  g = 0,\n  /**\n   * Defines the blue component (between 0 and 1, default is 0)\n   */\n  b = 0,\n  /**\n   * Defines the alpha component (between 0 and 1, default is 1)\n   */\n  a = 1) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n  // Operators\n  /**\n   * Adds in place the given Color4 values to the current Color4 object\n   * @param right defines the second operand\n   * @returns the current updated Color4 object\n   */\n  addInPlace(right) {\n    this.r += right.r;\n    this.g += right.g;\n    this.b += right.b;\n    this.a += right.a;\n    return this;\n  }\n  /**\n   * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n   * @returns the new array\n   */\n  asArray() {\n    return [this.r, this.g, this.b, this.a];\n  }\n  /**\n   * Stores from the starting index in the given array the Color4 successive values\n   * @param array defines the array where to store the r,g,b components\n   * @param index defines an optional index in the target array to define where to start storing values\n   * @returns the current Color4 object\n   */\n  toArray(array, index = 0) {\n    array[index] = this.r;\n    array[index + 1] = this.g;\n    array[index + 2] = this.b;\n    array[index + 3] = this.a;\n    return this;\n  }\n  /**\n   * Update the current color with values stored in an array from the starting index of the given array\n   * @param array defines the source array\n   * @param offset defines an offset in the source array\n   * @returns the current Color4 object\n   */\n  fromArray(array, offset = 0) {\n    Color4.FromArrayToRef(array, offset, this);\n    return this;\n  }\n  /**\n   * Determines equality between Color4 objects\n   * @param otherColor defines the second operand\n   * @returns true if the rgba values are equal to the given ones\n   */\n  equals(otherColor) {\n    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\n  }\n  /**\n   * Creates a new Color4 set with the added values of the current Color4 and of the given one\n   * @param right defines the second operand\n   * @returns a new Color4 object\n   */\n  add(right) {\n    return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n  }\n  /**\n   * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n   * @param right defines the second operand\n   * @returns a new Color4 object\n   */\n  subtract(right) {\n    return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n  }\n  /**\n   * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n   * @param right defines the second operand\n   * @param result defines the Color4 object where to store the result\n   * @returns the current Color4 object\n   */\n  subtractToRef(right, result) {\n    result.r = this.r - right.r;\n    result.g = this.g - right.g;\n    result.b = this.b - right.b;\n    result.a = this.a - right.a;\n    return this;\n  }\n  /**\n   * Creates a new Color4 with the current Color4 values multiplied by scale\n   * @param scale defines the scaling factor to apply\n   * @returns a new Color4 object\n   */\n  scale(scale) {\n    return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n  }\n  /**\n   * Multiplies the Color4 values by the float \"scale\"\n   * @param scale defines the scaling factor to apply\n   * @returns the current updated Color4\n   */\n  scaleInPlace(scale) {\n    this.r *= scale;\n    this.g *= scale;\n    this.b *= scale;\n    this.a *= scale;\n    return this;\n  }\n  /**\n   * Multiplies the current Color4 values by scale and stores the result in \"result\"\n   * @param scale defines the scaling factor to apply\n   * @param result defines the Color4 object where to store the result\n   * @returns the current unmodified Color4\n   */\n  scaleToRef(scale, result) {\n    result.r = this.r * scale;\n    result.g = this.g * scale;\n    result.b = this.b * scale;\n    result.a = this.a * scale;\n    return this;\n  }\n  /**\n   * Scale the current Color4 values by a factor and add the result to a given Color4\n   * @param scale defines the scale factor\n   * @param result defines the Color4 object where to store the result\n   * @returns the unmodified current Color4\n   */\n  scaleAndAddToRef(scale, result) {\n    result.r += this.r * scale;\n    result.g += this.g * scale;\n    result.b += this.b * scale;\n    result.a += this.a * scale;\n    return this;\n  }\n  /**\n   * Clamps the rgb values by the min and max values and stores the result into \"result\"\n   * @param min defines minimum clamping value (default is 0)\n   * @param max defines maximum clamping value (default is 1)\n   * @param result defines color to store the result into.\n   * @returns the current Color4\n   */\n  clampToRef(min = 0, max = 1, result) {\n    result.r = Scalar.Clamp(this.r, min, max);\n    result.g = Scalar.Clamp(this.g, min, max);\n    result.b = Scalar.Clamp(this.b, min, max);\n    result.a = Scalar.Clamp(this.a, min, max);\n    return this;\n  }\n  /**\n   * Multiply an Color4 value by another and return a new Color4 object\n   * @param color defines the Color4 value to multiply by\n   * @returns a new Color4 object\n   */\n  multiply(color) {\n    return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n  }\n  /**\n   * Multiply a Color4 value by another and push the result in a reference value\n   * @param color defines the Color4 value to multiply by\n   * @param result defines the Color4 to fill the result in\n   * @returns the result Color4\n   */\n  multiplyToRef(color, result) {\n    result.r = this.r * color.r;\n    result.g = this.g * color.g;\n    result.b = this.b * color.b;\n    result.a = this.a * color.a;\n    return result;\n  }\n  /**\n   * Creates a string with the Color4 current values\n   * @returns the string representation of the Color4 object\n   */\n  toString() {\n    return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n  }\n  /**\n   * Returns the string \"Color4\"\n   * @returns \"Color4\"\n   */\n  getClassName() {\n    return \"Color4\";\n  }\n  /**\n   * Compute the Color4 hash code\n   * @returns an unique number that can be used to hash Color4 objects\n   */\n  getHashCode() {\n    let hash = this.r * 255 | 0;\n    hash = hash * 397 ^ (this.g * 255 | 0);\n    hash = hash * 397 ^ (this.b * 255 | 0);\n    hash = hash * 397 ^ (this.a * 255 | 0);\n    return hash;\n  }\n  /**\n   * Creates a new Color4 copied from the current one\n   * @returns a new Color4 object\n   */\n  clone() {\n    return new Color4(this.r, this.g, this.b, this.a);\n  }\n  /**\n   * Copies the given Color4 values into the current one\n   * @param source defines the source Color4 object\n   * @returns the current updated Color4 object\n   */\n  copyFrom(source) {\n    this.r = source.r;\n    this.g = source.g;\n    this.b = source.b;\n    this.a = source.a;\n    return this;\n  }\n  /**\n   * Copies the given float values into the current one\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @param a defines the alpha component to read from\n   * @returns the current updated Color4 object\n   */\n  copyFromFloats(r, g, b, a) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n    return this;\n  }\n  /**\n   * Copies the given float values into the current one\n   * @param r defines the red component to read from\n   * @param g defines the green component to read from\n   * @param b defines the blue component to read from\n   * @param a defines the alpha component to read from\n   * @returns the current updated Color4 object\n   */\n  set(r, g, b, a) {\n    return this.copyFromFloats(r, g, b, a);\n  }\n  /**\n   * Compute the Color4 hexadecimal code as a string\n   * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\n   * @returns a string containing the hexadecimal representation of the Color4 object\n   */\n  toHexString(returnAsColor3 = false) {\n    const intR = Math.round(this.r * 255);\n    const intG = Math.round(this.g * 255);\n    const intB = Math.round(this.b * 255);\n    if (returnAsColor3) {\n      return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\n    }\n    const intA = Math.round(this.a * 255);\n    return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\n  }\n  /**\n   * Computes a new Color4 converted from the current one to linear space\n   * @returns a new Color4 object\n   */\n  toLinearSpace() {\n    const convertedColor = new Color4();\n    this.toLinearSpaceToRef(convertedColor);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color4 object where to store the linear space version\n   * @returns the unmodified Color4\n   */\n  toLinearSpaceToRef(convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToLinearSpace);\n    convertedColor.g = Math.pow(this.g, ToLinearSpace);\n    convertedColor.b = Math.pow(this.b, ToLinearSpace);\n    convertedColor.a = this.a;\n    return this;\n  }\n  /**\n   * Computes a new Color4 converted from the current one to gamma space\n   * @returns a new Color4 object\n   */\n  toGammaSpace() {\n    const convertedColor = new Color4();\n    this.toGammaSpaceToRef(convertedColor);\n    return convertedColor;\n  }\n  /**\n   * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n   * @param convertedColor defines the Color4 object where to store the gamma space version\n   * @returns the unmodified Color4\n   */\n  toGammaSpaceToRef(convertedColor) {\n    convertedColor.r = Math.pow(this.r, ToGammaSpace);\n    convertedColor.g = Math.pow(this.g, ToGammaSpace);\n    convertedColor.b = Math.pow(this.b, ToGammaSpace);\n    convertedColor.a = this.a;\n    return this;\n  }\n  // Statics\n  /**\n   * Creates a new Color4 from the string containing valid hexadecimal values.\n   *\n   * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\n   *\n   * When a hex string without alpha is passed, the resulting Color4 has\n   * its alpha value set to 1.0.\n   *\n   * An invalid string results in a Color with all its channels set to 0.0,\n   * i.e. \"transparent black\".\n   *\n   * @param hex defines a string containing valid hexadecimal values\n   * @returns a new Color4 object\n   */\n  static FromHexString(hex) {\n    if (hex.substring(0, 1) !== \"#\" || hex.length !== 9 && hex.length !== 7) {\n      return new Color4(0.0, 0.0, 0.0, 0.0);\n    }\n    const r = parseInt(hex.substring(1, 3), 16);\n    const g = parseInt(hex.substring(3, 5), 16);\n    const b = parseInt(hex.substring(5, 7), 16);\n    const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\n    return Color4.FromInts(r, g, b, a);\n  }\n  /**\n   * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @returns a new Color4 object\n   */\n  static Lerp(left, right, amount) {\n    const result = new Color4(0.0, 0.0, 0.0, 0.0);\n    Color4.LerpToRef(left, right, amount, result);\n    return result;\n  }\n  /**\n   * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n   * @param left defines the start value\n   * @param right defines the end value\n   * @param amount defines the gradient factor\n   * @param result defines the Color4 object where to store data\n   */\n  static LerpToRef(left, right, amount, result) {\n    result.r = left.r + (right.r - left.r) * amount;\n    result.g = left.g + (right.g - left.g) * amount;\n    result.b = left.b + (right.b - left.b) * amount;\n    result.a = left.a + (right.a - left.a) * amount;\n  }\n  /**\n   * Interpolate between two Color4 using Hermite interpolation\n   * @param value1 defines first Color4\n   * @param tangent1 defines the incoming tangent\n   * @param value2 defines second Color4\n   * @param tangent2 defines the outgoing tangent\n   * @param amount defines the target Color4\n   * @returns the new interpolated Color4\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\n    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\n    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\n    const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\n    return new Color4(r, g, b, a);\n  }\n  /**\n   * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const result = new Color4();\n    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\n    return result;\n  }\n  /**\n   * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @param result define where to store the derivative\n   */\n  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {\n    const t2 = time * time;\n    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\n    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\n    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\n    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\n  }\n  /**\n   * Creates a new Color4 from a Color3 and an alpha value\n   * @param color3 defines the source Color3 to read from\n   * @param alpha defines the alpha component (1.0 by default)\n   * @returns a new Color4 object\n   */\n  static FromColor3(color3, alpha = 1.0) {\n    return new Color4(color3.r, color3.g, color3.b, alpha);\n  }\n  /**\n   * Creates a new Color4 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @returns a new Color4 object\n   */\n  static FromArray(array, offset = 0) {\n    return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n  }\n  /**\n   * Creates a new Color4 from the starting index element of the given array\n   * @param array defines the source array to read from\n   * @param offset defines the offset in the source array\n   * @param result defines the target Color4 object\n   */\n  static FromArrayToRef(array, offset = 0, result) {\n    result.r = array[offset];\n    result.g = array[offset + 1];\n    result.b = array[offset + 2];\n    result.a = array[offset + 3];\n  }\n  /**\n   * Creates a new Color3 from integer values (< 256)\n   * @param r defines the red component to read from (value between 0 and 255)\n   * @param g defines the green component to read from (value between 0 and 255)\n   * @param b defines the blue component to read from (value between 0 and 255)\n   * @param a defines the alpha component to read from (value between 0 and 255)\n   * @returns a new Color3 object\n   */\n  static FromInts(r, g, b, a) {\n    return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n  }\n  /**\n   * Check the content of a given array and convert it to an array containing RGBA data\n   * If the original array was already containing count * 4 values then it is returned directly\n   * @param colors defines the array to check\n   * @param count defines the number of RGBA data to expect\n   * @returns an array containing count * 4 values (RGBA)\n   */\n  static CheckColors4(colors, count) {\n    // Check if color3 was used\n    if (colors.length === count * 3) {\n      const colors4 = [];\n      for (let index = 0; index < colors.length; index += 3) {\n        const newIndex = index / 3 * 4;\n        colors4[newIndex] = colors[index];\n        colors4[newIndex + 1] = colors[index + 1];\n        colors4[newIndex + 2] = colors[index + 2];\n        colors4[newIndex + 3] = 1.0;\n      }\n      return colors4;\n    }\n    return colors;\n  }\n}\n/**\n * @internal\n */\nexport class TmpColors {}\nTmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);\nTmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\nRegisterClass(\"BABYLON.Color3\", Color3);\nRegisterClass(\"BABYLON.Color4\", Color4);","map":{"version":3,"mappings":"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","names":["Scalar","ToLinearSpace","ToGammaSpace","ArrayTools","RegisterClass","Color3","constructor","r","g","b","toString","getClassName","getHashCode","hash","toArray","array","index","fromArray","offset","FromArrayToRef","toColor4","alpha","Color4","asArray","toLuminance","multiply","otherColor","multiplyToRef","result","equals","equalsFloats","scale","scaleInPlace","scaleToRef","scaleAndAddToRef","clampToRef","min","max","Clamp","add","addToRef","subtract","subtractToRef","clone","copyFrom","source","copyFromFloats","set","toHexString","intR","Math","round","intG","intB","ToHex","toLinearSpace","convertedColor","toLinearSpaceToRef","toHSV","toHSVToRef","h","s","v","dm","pow","toGammaSpace","toGammaSpaceToRef","HSVtoRGBToRef","hue","saturation","value","chroma","x","abs","m","FromHSV","FromHexString","hex","substring","length","parseInt","FromInts","FromArray","Lerp","start","end","amount","LerpToRef","left","right","Hermite","value1","tangent1","value2","tangent2","squared","cubed","part1","part2","part3","part4","Hermite1stDerivative","time","Black","Hermite1stDerivativeToRef","t2","Red","Green","Blue","BlackReadOnly","_BlackReadOnly","White","Purple","Magenta","Yellow","Gray","Teal","Random","random","a","addInPlace","color","returnAsColor3","intA","FromColor3","color3","CheckColors4","colors","count","colors4","newIndex","TmpColors","BuildArray"],"sourceRoot":"","sources":["../../../../lts/core/generated/Maths/math.color.ts"],"sourcesContent":["import type { DeepImmutable, FloatArray } from \"../types\";\r\nimport { Scalar } from \"./math.scalar\";\r\nimport { ToLinearSpace, ToGammaSpace } from \"./math.constants\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * Class used to hold a RGB color\r\n */\r\nexport class Color3 {\r\n    /**\r\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the red component (between 0 and 1, default is 0)\r\n         */\r\n        public r: number = 0,\r\n        /**\r\n         * Defines the green component (between 0 and 1, default is 0)\r\n         */\r\n        public g: number = 0,\r\n        /**\r\n         * Defines the blue component (between 0 and 1, default is 0)\r\n         */\r\n        public b: number = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Creates a string with the Color3 current values\r\n     * @returns the string representation of the Color3 object\r\n     */\r\n    public toString(): string {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Color3\"\r\n     * @returns \"Color3\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Color3\";\r\n    }\r\n\r\n    /**\r\n     * Compute the Color3 hash code\r\n     * @returns an unique number that can be used to hash Color3 objects\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = (this.r * 255) | 0;\r\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\r\n        return hash;\r\n    }\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color3 object\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Color3 {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current color with values stored in an array from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns the current Color3 object\r\n     */\r\n    public fromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color3 {\r\n        Color3.FromArrayToRef(array, offset, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 object from the current Color3 and the given alpha\r\n     * @param alpha defines the alpha component on the new Color4 object (default is 1)\r\n     * @returns a new Color4 object\r\n     */\r\n    public toColor4(alpha: number = 1): Color4 {\r\n        return new Color4(this.r, this.g, this.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\r\n     * @returns the new array\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.r, this.g, this.b];\r\n    }\r\n\r\n    /**\r\n     * Returns the luminance value\r\n     * @returns a float value\r\n     */\r\n    public toLuminance(): number {\r\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\r\n    }\r\n\r\n    /**\r\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3 object\r\n     */\r\n    public multiply(otherColor: DeepImmutable<Color3>): Color3 {\r\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the current Color3\r\n     */\r\n    public multiplyToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3 {\r\n        result.r = this.r * otherColor.r;\r\n        result.g = this.g * otherColor.g;\r\n        result.b = this.b * otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between Color3 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    public equals(otherColor: DeepImmutable<Color3>): boolean {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between the current Color3 object and a set of r,b,g values\r\n     * @param r defines the red component to check\r\n     * @param g defines the green component to check\r\n     * @param b defines the blue component to check\r\n     * @returns true if the rgb values are equal to the given ones\r\n     */\r\n    public equalsFloats(r: number, g: number, b: number): boolean {\r\n        return this.r === r && this.g === g && this.b === b;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with the current Color3 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color3 object\r\n     */\r\n    public scale(scale: number): Color3 {\r\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Color3 values by the float \"scale\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns the current updated Color3\r\n     */\r\n    public scaleInPlace(scale: number): Color3 {\r\n        this.r *= scale;\r\n        this.g *= scale;\r\n        this.b *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the rgb values by scale and stores the result into \"result\"\r\n     * @param scale defines the scaling factor\r\n     * @param result defines the Color3 object where to store the result\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public scaleToRef(scale: number, result: Color3): Color3 {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Color3 values by a factor and add the result to a given Color3\r\n     * @param scale defines the scale factor\r\n     * @param result defines color to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Color3): Color3 {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into\r\n     * @returns the original Color3\r\n     */\r\n    public clampToRef(min: number = 0, max: number = 1, result: Color3): Color3 {\r\n        result.r = Scalar.Clamp(this.r, min, max);\r\n        result.g = Scalar.Clamp(this.g, min, max);\r\n        result.b = Scalar.Clamp(this.b, min, max);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    public add(otherColor: DeepImmutable<Color3>): Color3 {\r\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public addToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3 {\r\n        result.r = this.r + otherColor.r;\r\n        result.g = this.g + otherColor.g;\r\n        result.b = this.b + otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\r\n     * @param otherColor defines the second operand\r\n     * @returns the new Color3\r\n     */\r\n    public subtract(otherColor: DeepImmutable<Color3>): Color3 {\r\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\r\n    }\r\n\r\n    /**\r\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\r\n     * @param otherColor defines the second operand\r\n     * @param result defines Color3 object to store the result into\r\n     * @returns the unmodified current Color3\r\n     */\r\n    public subtractToRef(otherColor: DeepImmutable<Color3>, result: Color3): Color3 {\r\n        result.r = this.r - otherColor.r;\r\n        result.g = this.g - otherColor.g;\r\n        result.b = this.b - otherColor.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy the current object\r\n     * @returns a new Color3 copied the current one\r\n     */\r\n    public clone(): Color3 {\r\n        return new Color3(this.r, this.g, this.b);\r\n    }\r\n\r\n    /**\r\n     * Copies the rgb values from the source in the current Color3\r\n     * @param source defines the source Color3 object\r\n     * @returns the updated Color3 object\r\n     */\r\n    public copyFrom(source: DeepImmutable<Color3>): Color3 {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    public copyFromFloats(r: number, g: number, b: number): Color3 {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the Color3 rgb values from the given floats\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @returns the current Color3 object\r\n     */\r\n    public set(r: number, g: number, b: number): Color3 {\r\n        return this.copyFromFloats(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Compute the Color3 hexadecimal code as a string\r\n     * @returns a string containing the hexadecimal representation of the Color3 object\r\n     */\r\n    public toHexString(): string {\r\n        const intR = Math.round(this.r * 255);\r\n        const intG = Math.round(this.g * 255);\r\n        const intB = Math.round(this.b * 255);\r\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color3 converted from the current one to linear space\r\n     * @returns a new Color3 object\r\n     */\r\n    public toLinearSpace(): Color3 {\r\n        const convertedColor = new Color3();\r\n        this.toLinearSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts current color in rgb space to HSV values\r\n     * @returns a new color3 representing the HSV values\r\n     */\r\n    public toHSV(): Color3 {\r\n        const result = new Color3();\r\n\r\n        this.toHSVToRef(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Converts current color in rgb space to HSV values\r\n     * @param result defines the Color3 where to store the HSV values\r\n     */\r\n    public toHSVToRef(result: Color3) {\r\n        const r = this.r;\r\n        const g = this.g;\r\n        const b = this.b;\r\n\r\n        const max = Math.max(r, g, b);\r\n        const min = Math.min(r, g, b);\r\n        let h = 0;\r\n        let s = 0;\r\n        const v = max;\r\n\r\n        const dm = max - min;\r\n\r\n        if (max !== 0) {\r\n            s = dm / max;\r\n        }\r\n\r\n        if (max != min) {\r\n            if (max == r) {\r\n                h = (g - b) / dm;\r\n                if (g < b) {\r\n                    h += 6;\r\n                }\r\n            } else if (max == g) {\r\n                h = (b - r) / dm + 2;\r\n            } else if (max == b) {\r\n                h = (r - g) / dm + 4;\r\n            }\r\n            h *= 60;\r\n        }\r\n\r\n        result.r = h;\r\n        result.g = s;\r\n        result.b = v;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the linear space version\r\n     * @returns the unmodified Color3\r\n     */\r\n    public toLinearSpaceToRef(convertedColor: Color3): Color3 {\r\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\r\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\r\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color3 converted from the current one to gamma space\r\n     * @returns a new Color3 object\r\n     */\r\n    public toGammaSpace(): Color3 {\r\n        const convertedColor = new Color3();\r\n        this.toGammaSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color3 object where to store the gamma space version\r\n     * @returns the unmodified Color3\r\n     */\r\n    public toGammaSpaceToRef(convertedColor: Color3): Color3 {\r\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\r\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\r\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    private static _BlackReadOnly = Color3.Black() as DeepImmutable<Color3>;\r\n\r\n    /**\r\n     * Converts Hue, saturation and value to a Color3 (RGB)\r\n     * @param hue defines the hue\r\n     * @param saturation defines the saturation\r\n     * @param value defines the value\r\n     * @param result defines the Color3 where to store the RGB values\r\n     */\r\n    public static HSVtoRGBToRef(hue: number, saturation: number, value: number, result: Color3) {\r\n        const chroma = value * saturation;\r\n        const h = hue / 60;\r\n        const x = chroma * (1 - Math.abs((h % 2) - 1));\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n\r\n        if (h >= 0 && h <= 1) {\r\n            r = chroma;\r\n            g = x;\r\n        } else if (h >= 1 && h <= 2) {\r\n            r = x;\r\n            g = chroma;\r\n        } else if (h >= 2 && h <= 3) {\r\n            g = chroma;\r\n            b = x;\r\n        } else if (h >= 3 && h <= 4) {\r\n            g = x;\r\n            b = chroma;\r\n        } else if (h >= 4 && h <= 5) {\r\n            r = x;\r\n            b = chroma;\r\n        } else if (h >= 5 && h <= 6) {\r\n            r = chroma;\r\n            b = x;\r\n        }\r\n\r\n        const m = value - chroma;\r\n        result.set(r + m, g + m, b + m);\r\n    }\r\n\r\n    /**\r\n     * Converts Hue, saturation and value to a new Color3 (RGB)\r\n     * @param hue defines the hue (value between 0 and 360)\r\n     * @param saturation defines the saturation (value between 0 and 1)\r\n     * @param value defines the value (value between 0 and 1)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromHSV(hue: number, saturation: number, value: number): Color3 {\r\n        const result = new Color3(0, 0, 0);\r\n        Color3.HSVtoRGBToRef(hue, saturation, value, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the string containing valid hexadecimal values\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromHexString(hex: string): Color3 {\r\n        if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\r\n            return new Color3(0, 0, 0);\r\n        }\r\n\r\n        const r = parseInt(hex.substring(1, 3), 16);\r\n        const g = parseInt(hex.substring(3, 5), 16);\r\n        const b = parseInt(hex.substring(5, 7), 16);\r\n\r\n        return Color3.FromInts(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color3 {\r\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the target Color3 object\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number = 0, result: Color3) {\r\n        result.r = array[offset];\r\n        result.g = array[offset + 1];\r\n        result.b = array[offset + 2];\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from integer values (< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromInts(r: number, g: number, b: number): Color3 {\r\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param start defines the start Color3 value\r\n     * @param end defines the end Color3 value\r\n     * @param amount defines the gradient value between start and end\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Lerp(start: DeepImmutable<Color3>, end: DeepImmutable<Color3>, amount: number): Color3 {\r\n        const result = new Color3(0.0, 0.0, 0.0);\r\n        Color3.LerpToRef(start, end, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color3 object where to store the result\r\n     */\r\n    public static LerpToRef(left: DeepImmutable<Color3>, right: DeepImmutable<Color3>, amount: number, result: Color3): void {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent Color3\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent Color3\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns the new Color3\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Color3>, tangent1: DeepImmutable<Color3>, value2: DeepImmutable<Color3>, tangent2: DeepImmutable<Color3>, amount: number): Color3 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\r\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\r\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\r\n        return new Color3(r, g, b);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Color3>,\r\n        tangent1: DeepImmutable<Color3>,\r\n        value2: DeepImmutable<Color3>,\r\n        tangent2: DeepImmutable<Color3>,\r\n        time: number\r\n    ): Color3 {\r\n        const result = Color3.Black();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Color3>,\r\n        tangent1: DeepImmutable<Color3>,\r\n        value2: DeepImmutable<Color3>,\r\n        tangent2: DeepImmutable<Color3>,\r\n        time: number,\r\n        result: Color3\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\r\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\r\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\r\n    }\r\n\r\n    /**\r\n     * Returns a Color3 value containing a red color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Red(): Color3 {\r\n        return new Color3(1, 0, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a green color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Green(): Color3 {\r\n        return new Color3(0, 1, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a blue color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Blue(): Color3 {\r\n        return new Color3(0, 0, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a black color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Black(): Color3 {\r\n        return new Color3(0, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets a Color3 value containing a black color that must not be updated\r\n     */\r\n    public static get BlackReadOnly(): DeepImmutable<Color3> {\r\n        return Color3._BlackReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Returns a Color3 value containing a white color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static White(): Color3 {\r\n        return new Color3(1, 1, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a purple color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Purple(): Color3 {\r\n        return new Color3(0.5, 0, 0.5);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a magenta color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Magenta(): Color3 {\r\n        return new Color3(1, 0, 1);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a yellow color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Yellow(): Color3 {\r\n        return new Color3(1, 1, 0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a gray color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Gray(): Color3 {\r\n        return new Color3(0.5, 0.5, 0.5);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a teal color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Teal(): Color3 {\r\n        return new Color3(0, 1.0, 1.0);\r\n    }\r\n    /**\r\n     * Returns a Color3 value containing a random color\r\n     * @returns a new Color3 object\r\n     */\r\n    public static Random(): Color3 {\r\n        return new Color3(Math.random(), Math.random(), Math.random());\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to hold a RBGA color\r\n */\r\nexport class Color4 {\r\n    /**\r\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\r\n     * @param r defines the red component (between 0 and 1, default is 0)\r\n     * @param g defines the green component (between 0 and 1, default is 0)\r\n     * @param b defines the blue component (between 0 and 1, default is 0)\r\n     * @param a defines the alpha component (between 0 and 1, default is 1)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the red component (between 0 and 1, default is 0)\r\n         */\r\n        public r: number = 0,\r\n        /**\r\n         * Defines the green component (between 0 and 1, default is 0)\r\n         */\r\n        public g: number = 0,\r\n        /**\r\n         * Defines the blue component (between 0 and 1, default is 0)\r\n         */\r\n        public b: number = 0,\r\n        /**\r\n         * Defines the alpha component (between 0 and 1, default is 1)\r\n         */\r\n        public a: number = 1\r\n    ) {}\r\n\r\n    // Operators\r\n\r\n    /**\r\n     * Adds in place the given Color4 values to the current Color4 object\r\n     * @param right defines the second operand\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public addInPlace(right: DeepImmutable<Color4>): Color4 {\r\n        this.r += right.r;\r\n        this.g += right.g;\r\n        this.b += right.b;\r\n        this.a += right.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\r\n     * @returns the new array\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.r, this.g, this.b, this.a];\r\n    }\r\n\r\n    /**\r\n     * Stores from the starting index in the given array the Color4 successive values\r\n     * @param array defines the array where to store the r,g,b components\r\n     * @param index defines an optional index in the target array to define where to start storing values\r\n     * @returns the current Color4 object\r\n     */\r\n    public toArray(array: FloatArray, index: number = 0): Color4 {\r\n        array[index] = this.r;\r\n        array[index + 1] = this.g;\r\n        array[index + 2] = this.b;\r\n        array[index + 3] = this.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Update the current color with values stored in an array from the starting index of the given array\r\n     * @param array defines the source array\r\n     * @param offset defines an offset in the source array\r\n     * @returns the current Color4 object\r\n     */\r\n    public fromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color4 {\r\n        Color4.FromArrayToRef(array, offset, this);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines equality between Color4 objects\r\n     * @param otherColor defines the second operand\r\n     * @returns true if the rgba values are equal to the given ones\r\n     */\r\n    public equals(otherColor: DeepImmutable<Color4>): boolean {\r\n        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\r\n     * @param right defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    public add(right: DeepImmutable<Color4>): Color4 {\r\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\r\n     * @param right defines the second operand\r\n     * @returns a new Color4 object\r\n     */\r\n    public subtract(right: DeepImmutable<Color4>): Color4 {\r\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\r\n    }\r\n\r\n    /**\r\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\r\n     * @param right defines the second operand\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the current Color4 object\r\n     */\r\n    public subtractToRef(right: DeepImmutable<Color4>, result: Color4): Color4 {\r\n        result.r = this.r - right.r;\r\n        result.g = this.g - right.g;\r\n        result.b = this.b - right.b;\r\n        result.a = this.a - right.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 with the current Color4 values multiplied by scale\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns a new Color4 object\r\n     */\r\n    public scale(scale: number): Color4 {\r\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\r\n    }\r\n\r\n    /**\r\n     * Multiplies the Color4 values by the float \"scale\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @returns the current updated Color4\r\n     */\r\n    public scaleInPlace(scale: number): Color4 {\r\n        this.r *= scale;\r\n        this.g *= scale;\r\n        this.b *= scale;\r\n        this.a *= scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\r\n     * @param scale defines the scaling factor to apply\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the current unmodified Color4\r\n     */\r\n    public scaleToRef(scale: number, result: Color4): Color4 {\r\n        result.r = this.r * scale;\r\n        result.g = this.g * scale;\r\n        result.b = this.b * scale;\r\n        result.a = this.a * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current Color4 values by a factor and add the result to a given Color4\r\n     * @param scale defines the scale factor\r\n     * @param result defines the Color4 object where to store the result\r\n     * @returns the unmodified current Color4\r\n     */\r\n    public scaleAndAddToRef(scale: number, result: Color4): Color4 {\r\n        result.r += this.r * scale;\r\n        result.g += this.g * scale;\r\n        result.b += this.b * scale;\r\n        result.a += this.a * scale;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\r\n     * @param min defines minimum clamping value (default is 0)\r\n     * @param max defines maximum clamping value (default is 1)\r\n     * @param result defines color to store the result into.\r\n     * @returns the current Color4\r\n     */\r\n    public clampToRef(min: number = 0, max: number = 1, result: Color4): Color4 {\r\n        result.r = Scalar.Clamp(this.r, min, max);\r\n        result.g = Scalar.Clamp(this.g, min, max);\r\n        result.b = Scalar.Clamp(this.b, min, max);\r\n        result.a = Scalar.Clamp(this.a, min, max);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Multiply an Color4 value by another and return a new Color4 object\r\n     * @param color defines the Color4 value to multiply by\r\n     * @returns a new Color4 object\r\n     */\r\n    public multiply(color: Color4): Color4 {\r\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\r\n    }\r\n\r\n    /**\r\n     * Multiply a Color4 value by another and push the result in a reference value\r\n     * @param color defines the Color4 value to multiply by\r\n     * @param result defines the Color4 to fill the result in\r\n     * @returns the result Color4\r\n     */\r\n    public multiplyToRef(color: Color4, result: Color4): Color4 {\r\n        result.r = this.r * color.r;\r\n        result.g = this.g * color.g;\r\n        result.b = this.b * color.b;\r\n        result.a = this.a * color.a;\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a string with the Color4 current values\r\n     * @returns the string representation of the Color4 object\r\n     */\r\n    public toString(): string {\r\n        return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Color4\"\r\n     * @returns \"Color4\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Color4\";\r\n    }\r\n\r\n    /**\r\n     * Compute the Color4 hash code\r\n     * @returns an unique number that can be used to hash Color4 objects\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = (this.r * 255) | 0;\r\n        hash = (hash * 397) ^ ((this.g * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.b * 255) | 0);\r\n        hash = (hash * 397) ^ ((this.a * 255) | 0);\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 copied from the current one\r\n     * @returns a new Color4 object\r\n     */\r\n    public clone(): Color4 {\r\n        return new Color4(this.r, this.g, this.b, this.a);\r\n    }\r\n\r\n    /**\r\n     * Copies the given Color4 values into the current one\r\n     * @param source defines the source Color4 object\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public copyFrom(source: Color4): Color4 {\r\n        this.r = source.r;\r\n        this.g = source.g;\r\n        this.b = source.b;\r\n        this.a = source.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public copyFromFloats(r: number, g: number, b: number, a: number): Color4 {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n        this.a = a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copies the given float values into the current one\r\n     * @param r defines the red component to read from\r\n     * @param g defines the green component to read from\r\n     * @param b defines the blue component to read from\r\n     * @param a defines the alpha component to read from\r\n     * @returns the current updated Color4 object\r\n     */\r\n    public set(r: number, g: number, b: number, a: number): Color4 {\r\n        return this.copyFromFloats(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Compute the Color4 hexadecimal code as a string\r\n     * @param returnAsColor3 defines if the string should only contains RGB values (off by default)\r\n     * @returns a string containing the hexadecimal representation of the Color4 object\r\n     */\r\n    public toHexString(returnAsColor3 = false): string {\r\n        const intR = Math.round(this.r * 255);\r\n        const intG = Math.round(this.g * 255);\r\n        const intB = Math.round(this.b * 255);\r\n\r\n        if (returnAsColor3) {\r\n            return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);\r\n        }\r\n\r\n        const intA = Math.round(this.a * 255);\r\n        return \"#\" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color4 converted from the current one to linear space\r\n     * @returns a new Color4 object\r\n     */\r\n    public toLinearSpace(): Color4 {\r\n        const convertedColor = new Color4();\r\n        this.toLinearSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the linear space version\r\n     * @returns the unmodified Color4\r\n     */\r\n    public toLinearSpaceToRef(convertedColor: Color4): Color4 {\r\n        convertedColor.r = Math.pow(this.r, ToLinearSpace);\r\n        convertedColor.g = Math.pow(this.g, ToLinearSpace);\r\n        convertedColor.b = Math.pow(this.b, ToLinearSpace);\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes a new Color4 converted from the current one to gamma space\r\n     * @returns a new Color4 object\r\n     */\r\n    public toGammaSpace(): Color4 {\r\n        const convertedColor = new Color4();\r\n        this.toGammaSpaceToRef(convertedColor);\r\n        return convertedColor;\r\n    }\r\n\r\n    /**\r\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\r\n     * @param convertedColor defines the Color4 object where to store the gamma space version\r\n     * @returns the unmodified Color4\r\n     */\r\n    public toGammaSpaceToRef(convertedColor: Color4): Color4 {\r\n        convertedColor.r = Math.pow(this.r, ToGammaSpace);\r\n        convertedColor.g = Math.pow(this.g, ToGammaSpace);\r\n        convertedColor.b = Math.pow(this.b, ToGammaSpace);\r\n        convertedColor.a = this.a;\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new Color4 from the string containing valid hexadecimal values.\r\n     *\r\n     * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.\r\n     *\r\n     * When a hex string without alpha is passed, the resulting Color4 has\r\n     * its alpha value set to 1.0.\r\n     *\r\n     * An invalid string results in a Color with all its channels set to 0.0,\r\n     * i.e. \"transparent black\".\r\n     *\r\n     * @param hex defines a string containing valid hexadecimal values\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromHexString(hex: string): Color4 {\r\n        if (hex.substring(0, 1) !== \"#\" || (hex.length !== 9 && hex.length !== 7)) {\r\n            return new Color4(0.0, 0.0, 0.0, 0.0);\r\n        }\r\n\r\n        const r = parseInt(hex.substring(1, 3), 16);\r\n        const g = parseInt(hex.substring(3, 5), 16);\r\n        const b = parseInt(hex.substring(5, 7), 16);\r\n        const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;\r\n\r\n        return Color4.FromInts(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @returns a new Color4 object\r\n     */\r\n    public static Lerp(left: DeepImmutable<Color4>, right: DeepImmutable<Color4>, amount: number): Color4 {\r\n        const result = new Color4(0.0, 0.0, 0.0, 0.0);\r\n        Color4.LerpToRef(left, right, amount, result);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\r\n     * @param left defines the start value\r\n     * @param right defines the end value\r\n     * @param amount defines the gradient factor\r\n     * @param result defines the Color4 object where to store data\r\n     */\r\n    public static LerpToRef(left: DeepImmutable<Color4>, right: DeepImmutable<Color4>, amount: number, result: Color4): void {\r\n        result.r = left.r + (right.r - left.r) * amount;\r\n        result.g = left.g + (right.g - left.g) * amount;\r\n        result.b = left.b + (right.b - left.b) * amount;\r\n        result.a = left.a + (right.a - left.a) * amount;\r\n    }\r\n\r\n    /**\r\n     * Interpolate between two Color4 using Hermite interpolation\r\n     * @param value1 defines first Color4\r\n     * @param tangent1 defines the incoming tangent\r\n     * @param value2 defines second Color4\r\n     * @param tangent2 defines the outgoing tangent\r\n     * @param amount defines the target Color4\r\n     * @returns the new interpolated Color4\r\n     */\r\n    public static Hermite(value1: DeepImmutable<Color4>, tangent1: DeepImmutable<Color4>, value2: DeepImmutable<Color4>, tangent2: DeepImmutable<Color4>, amount: number): Color4 {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;\r\n        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;\r\n        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;\r\n        const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;\r\n        return new Color4(r, g, b, a);\r\n    }\r\n\r\n    /**\r\n     * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(\r\n        value1: DeepImmutable<Color4>,\r\n        tangent1: DeepImmutable<Color4>,\r\n        value2: DeepImmutable<Color4>,\r\n        tangent2: DeepImmutable<Color4>,\r\n        time: number\r\n    ): Color4 {\r\n        const result = new Color4();\r\n\r\n        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @param result define where to store the derivative\r\n     */\r\n    public static Hermite1stDerivativeToRef(\r\n        value1: DeepImmutable<Color4>,\r\n        tangent1: DeepImmutable<Color4>,\r\n        value2: DeepImmutable<Color4>,\r\n        tangent2: DeepImmutable<Color4>,\r\n        time: number,\r\n        result: Color4\r\n    ) {\r\n        const t2 = time * time;\r\n\r\n        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;\r\n        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;\r\n        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;\r\n        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from a Color3 and an alpha value\r\n     * @param color3 defines the source Color3 to read from\r\n     * @param alpha defines the alpha component (1.0 by default)\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromColor3(color3: DeepImmutable<Color3>, alpha: number = 1.0): Color4 {\r\n        return new Color4(color3.r, color3.g, color3.b, alpha);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @returns a new Color4 object\r\n     */\r\n    public static FromArray(array: DeepImmutable<ArrayLike<number>>, offset: number = 0): Color4 {\r\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color4 from the starting index element of the given array\r\n     * @param array defines the source array to read from\r\n     * @param offset defines the offset in the source array\r\n     * @param result defines the target Color4 object\r\n     */\r\n    public static FromArrayToRef(array: DeepImmutable<ArrayLike<number>>, offset: number = 0, result: Color4) {\r\n        result.r = array[offset];\r\n        result.g = array[offset + 1];\r\n        result.b = array[offset + 2];\r\n        result.a = array[offset + 3];\r\n    }\r\n\r\n    /**\r\n     * Creates a new Color3 from integer values (< 256)\r\n     * @param r defines the red component to read from (value between 0 and 255)\r\n     * @param g defines the green component to read from (value between 0 and 255)\r\n     * @param b defines the blue component to read from (value between 0 and 255)\r\n     * @param a defines the alpha component to read from (value between 0 and 255)\r\n     * @returns a new Color3 object\r\n     */\r\n    public static FromInts(r: number, g: number, b: number, a: number): Color4 {\r\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\r\n    }\r\n\r\n    /**\r\n     * Check the content of a given array and convert it to an array containing RGBA data\r\n     * If the original array was already containing count * 4 values then it is returned directly\r\n     * @param colors defines the array to check\r\n     * @param count defines the number of RGBA data to expect\r\n     * @returns an array containing count * 4 values (RGBA)\r\n     */\r\n    public static CheckColors4(colors: number[], count: number): number[] {\r\n        // Check if color3 was used\r\n        if (colors.length === count * 3) {\r\n            const colors4 = [];\r\n            for (let index = 0; index < colors.length; index += 3) {\r\n                const newIndex = (index / 3) * 4;\r\n                colors4[newIndex] = colors[index];\r\n                colors4[newIndex + 1] = colors[index + 1];\r\n                colors4[newIndex + 2] = colors[index + 2];\r\n                colors4[newIndex + 3] = 1.0;\r\n            }\r\n\r\n            return colors4;\r\n        }\r\n\r\n        return colors;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class TmpColors {\r\n    public static Color3: Color3[] = ArrayTools.BuildArray(3, Color3.Black);\r\n    public static Color4: Color4[] = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));\r\n}\r\n\r\nRegisterClass(\"BABYLON.Color3\", Color3);\r\nRegisterClass(\"BABYLON.Color4\", Color4);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}