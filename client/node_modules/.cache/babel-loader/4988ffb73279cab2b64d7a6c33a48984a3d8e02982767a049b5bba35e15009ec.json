{"ast":null,"code":"import { TransformNode } from \"../Meshes/transformNode.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Axis } from \"../Maths/math.js\";\n/**\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\n */\nexport class TextureDome extends TransformNode {\n  /**\n   * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\n   * @param name Element's name, child elements will append suffixes for their own names.\n   * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\n   * @param options An object containing optional or exposed sub element properties\n   * @param options.resolution\n   * @param options.clickToPlay\n   * @param options.autoPlay\n   * @param options.loop\n   * @param options.size\n   * @param options.poster\n   * @param options.faceForward\n   * @param options.useDirectMapping\n   * @param options.halfDomeMode\n   * @param options.crossEyeMode\n   * @param options.generateMipMaps\n   * @param options.mesh\n   * @param scene\n   * @param onError\n   */\n  constructor(name, textureUrlOrElement, options, scene,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  onError = null) {\n    super(name, scene);\n    this.onError = onError;\n    this._halfDome = false;\n    this._crossEye = false;\n    this._useDirectMapping = false;\n    this._textureMode = TextureDome.MODE_MONOSCOPIC;\n    /**\n     * Oberserver used in Stereoscopic VR Mode.\n     */\n    this._onBeforeCameraRenderObserver = null;\n    /**\n     * Observable raised when an error occurred while loading the texture\n     */\n    this.onLoadErrorObservable = new Observable();\n    /**\n     * Observable raised when the texture finished loading\n     */\n    this.onLoadObservable = new Observable();\n    scene = this.getScene();\n    // set defaults and manage values\n    name = name || \"textureDome\";\n    options.resolution = Math.abs(options.resolution) | 0 || 32;\n    options.clickToPlay = Boolean(options.clickToPlay);\n    options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\n    options.loop = options.loop === undefined ? true : Boolean(options.loop);\n    options.size = Math.abs(options.size) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\n    if (options.useDirectMapping === undefined) {\n      this._useDirectMapping = true;\n    } else {\n      this._useDirectMapping = options.useDirectMapping;\n    }\n    if (options.faceForward === undefined) {\n      options.faceForward = true;\n    }\n    this._setReady(false);\n    if (!options.mesh) {\n      this._mesh = CreateSphere(name + \"_mesh\", {\n        segments: options.resolution,\n        diameter: options.size,\n        updatable: false,\n        sideOrientation: Mesh.BACKSIDE\n      }, scene);\n    } else {\n      this._mesh = options.mesh;\n    }\n    // configure material\n    const material = this._material = new BackgroundMaterial(name + \"_material\", scene);\n    material.useEquirectangularFOV = true;\n    material.fovMultiplier = 1.0;\n    material.opacityFresnel = false;\n    const texture = this._initTexture(textureUrlOrElement, scene, options);\n    this.texture = texture;\n    // configure mesh\n    this._mesh.material = material;\n    this._mesh.parent = this;\n    // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\n    this._halfDomeMask = CreateSphere(\"\", {\n      slice: 0.5,\n      diameter: options.size * 0.98,\n      segments: options.resolution * 2,\n      sideOrientation: Mesh.BACKSIDE\n    }, scene);\n    this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\n    // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\n    this._halfDomeMask.parent = this._mesh;\n    this._halfDome = !!options.halfDomeMode;\n    // enable or disable according to the settings\n    this._halfDomeMask.setEnabled(this._halfDome);\n    this._crossEye = !!options.crossEyeMode;\n    // create\n    this._texture.anisotropicFilteringLevel = 1;\n    this._texture.onLoadObservable.addOnce(() => {\n      this._setReady(true);\n    });\n    // Initial rotation\n    if (options.faceForward && scene.activeCamera) {\n      const camera = scene.activeCamera;\n      const forward = Vector3.Forward();\n      const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\n      direction.normalize();\n      this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\n    }\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Gets the texture being displayed on the sphere\n   */\n  get texture() {\n    return this._texture;\n  }\n  /**\n   * Sets the texture being displayed on the sphere\n   */\n  set texture(newTexture) {\n    if (this._texture === newTexture) {\n      return;\n    }\n    this._texture = newTexture;\n    if (this._useDirectMapping) {\n      this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._material.diffuseTexture = this._texture;\n    } else {\n      this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\n      this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n      this._material.reflectionTexture = this._texture;\n    }\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Gets the mesh used for the dome.\n   */\n  get mesh() {\n    return this._mesh;\n  }\n  /**\n   * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\n   * Also see the options.resolution property.\n   */\n  get fovMultiplier() {\n    return this._material.fovMultiplier;\n  }\n  set fovMultiplier(value) {\n    this._material.fovMultiplier = value;\n  }\n  /**\n   * Gets or set the current texture mode for the texture. It can be:\n   * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n   * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n   * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n   */\n  get textureMode() {\n    return this._textureMode;\n  }\n  /**\n   * Sets the current texture mode for the texture. It can be:\n   * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\n   * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\n   * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\n   */\n  set textureMode(value) {\n    if (this._textureMode === value) {\n      return;\n    }\n    this._changeTextureMode(value);\n  }\n  /**\n   * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\n   */\n  get halfDome() {\n    return this._halfDome;\n  }\n  /**\n   * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\n   */\n  set halfDome(enabled) {\n    this._halfDome = enabled;\n    this._halfDomeMask.setEnabled(enabled);\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\n   */\n  set crossEye(enabled) {\n    this._crossEye = enabled;\n    this._changeTextureMode(this._textureMode);\n  }\n  /**\n   * Is it a cross-eye texture?\n   */\n  get crossEye() {\n    return this._crossEye;\n  }\n  /**\n   * The background material of this dome.\n   */\n  get material() {\n    return this._material;\n  }\n  _changeTextureMode(value) {\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    this._textureMode = value;\n    // Default Setup and Reset.\n    this._texture.uScale = 1;\n    this._texture.vScale = 1;\n    this._texture.uOffset = 0;\n    this._texture.vOffset = 0;\n    this._texture.vAng = 0;\n    switch (value) {\n      case TextureDome.MODE_MONOSCOPIC:\n        if (this._halfDome) {\n          this._texture.uScale = 2;\n          this._texture.uOffset = -1;\n        }\n        break;\n      case TextureDome.MODE_SIDEBYSIDE:\n        {\n          // in half-dome mode the uScale should be double of 360 texture\n          // Use 0.99999 to boost perf by not switching program\n          this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\n          const rightOffset = this._halfDome ? 0.0 : 0.5;\n          const leftOffset = this._halfDome ? -0.5 : 0.0;\n          this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(camera => {\n            let isRightCamera = camera.isRightCamera;\n            if (this._crossEye) {\n              isRightCamera = !isRightCamera;\n            }\n            if (isRightCamera) {\n              this._texture.uOffset = rightOffset;\n            } else {\n              this._texture.uOffset = leftOffset;\n            }\n          });\n          break;\n        }\n      case TextureDome.MODE_TOPBOTTOM:\n        // in half-dome mode the vScale should be double of 360 texture\n        // Use 0.99999 to boost perf by not switching program\n        this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\n        this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add(camera => {\n          let isRightCamera = camera.isRightCamera;\n          // allow \"cross-eye\" if left and right were switched in this mode\n          if (this._crossEye) {\n            isRightCamera = !isRightCamera;\n          }\n          this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\n        });\n        break;\n    }\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    this._texture.dispose();\n    this._mesh.dispose();\n    this._material.dispose();\n    this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n    this.onLoadErrorObservable.clear();\n    this.onLoadObservable.clear();\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n}\n/**\n * Define the source as a Monoscopic panoramic 360/180.\n */\nTextureDome.MODE_MONOSCOPIC = 0;\n/**\n * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\n */\nTextureDome.MODE_TOPBOTTOM = 1;\n/**\n * Define the source as a Stereoscopic Side by Side panoramic 360/180.\n */\nTextureDome.MODE_SIDEBYSIDE = 2;","map":{"version":3,"mappings":"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","names":["TransformNode","Mesh","Texture","BackgroundMaterial","CreateSphere","Observable","Vector3","Axis","TextureDome","constructor","name","textureUrlOrElement","options","scene","onError","MODE_MONOSCOPIC","getScene","resolution","Math","abs","clickToPlay","Boolean","autoPlay","undefined","loop","size","activeCamera","maxZ","useDirectMapping","_useDirectMapping","faceForward","_setReady","mesh","_mesh","segments","diameter","updatable","sideOrientation","BACKSIDE","material","_material","useEquirectangularFOV","fovMultiplier","opacityFresnel","texture","_initTexture","parent","_halfDomeMask","slice","rotate","X","PI","_halfDome","halfDomeMode","setEnabled","_crossEye","crossEyeMode","_texture","anisotropicFilteringLevel","onLoadObservable","addOnce","camera","forward","Forward","direction","TransformNormal","getViewMatrix","normalize","rotation","y","acos","Dot","_changeTextureMode","_textureMode","newTexture","wrapU","CLAMP_ADDRESSMODE","wrapV","diffuseTexture","coordinatesMode","FIXED_EQUIRECTANGULAR_MIRRORED_MODE","reflectionTexture","value","textureMode","halfDome","enabled","crossEye","_scene","onBeforeCameraRenderObservable","remove","_onBeforeCameraRenderObserver","uScale","vScale","uOffset","vOffset","vAng","MODE_SIDEBYSIDE","rightOffset","leftOffset","add","isRightCamera","MODE_TOPBOTTOM","dispose","doNotRecurse","disposeMaterialAndTextures","onLoadErrorObservable","clear"],"sourceRoot":"","sources":["../../../../lts/core/generated/Helpers/textureDome.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { BackgroundMaterial } from \"../Materials/Background/backgroundMaterial\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Axis } from \"../Maths/math\";\r\n\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\n\r\n/**\r\n * Display a 360/180 degree texture on an approximately spherical surface, useful for VR applications or skyboxes.\r\n * As a subclass of TransformNode, this allow parenting to the camera or multiple textures with different locations in the scene.\r\n * This class achieves its effect with a Texture and a correctly configured BackgroundMaterial on an inverted sphere.\r\n * Potential additions to this helper include zoom and and non-infinite distance rendering effects.\r\n */\r\nexport abstract class TextureDome<T extends Texture> extends TransformNode {\r\n    /**\r\n     * Define the source as a Monoscopic panoramic 360/180.\r\n     */\r\n    public static readonly MODE_MONOSCOPIC = 0;\r\n    /**\r\n     * Define the source as a Stereoscopic TopBottom/OverUnder panoramic 360/180.\r\n     */\r\n    public static readonly MODE_TOPBOTTOM = 1;\r\n    /**\r\n     * Define the source as a Stereoscopic Side by Side panoramic 360/180.\r\n     */\r\n    public static readonly MODE_SIDEBYSIDE = 2;\r\n\r\n    private _halfDome: boolean = false;\r\n    private _crossEye: boolean = false;\r\n\r\n    protected _useDirectMapping = false;\r\n\r\n    /**\r\n     * The texture being displayed on the sphere\r\n     */\r\n    protected _texture: T;\r\n\r\n    /**\r\n     * Gets the texture being displayed on the sphere\r\n     */\r\n    public get texture(): T {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the texture being displayed on the sphere\r\n     */\r\n    public set texture(newTexture: T) {\r\n        if (this._texture === newTexture) {\r\n            return;\r\n        }\r\n        this._texture = newTexture;\r\n        if (this._useDirectMapping) {\r\n            this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.diffuseTexture = this._texture;\r\n        } else {\r\n            this._texture.coordinatesMode = Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE; // matches orientation\r\n            this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n            this._material.reflectionTexture = this._texture;\r\n        }\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * The skybox material\r\n     */\r\n    protected _material: BackgroundMaterial;\r\n\r\n    /**\r\n     * The surface used for the dome\r\n     */\r\n    protected _mesh: Mesh;\r\n    /**\r\n     * Gets the mesh used for the dome.\r\n     */\r\n    public get mesh(): Mesh {\r\n        return this._mesh;\r\n    }\r\n\r\n    /**\r\n     * A mesh that will be used to mask the back of the dome in case it is a 180 degree movie.\r\n     */\r\n    private _halfDomeMask: Mesh;\r\n\r\n    /**\r\n     * The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values \"zoom in\" and higher values \"zoom out\".\r\n     * Also see the options.resolution property.\r\n     */\r\n    public get fovMultiplier(): number {\r\n        return this._material.fovMultiplier;\r\n    }\r\n    public set fovMultiplier(value: number) {\r\n        this._material.fovMultiplier = value;\r\n    }\r\n\r\n    protected _textureMode = TextureDome.MODE_MONOSCOPIC;\r\n    /**\r\n     * Gets or set the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public get textureMode(): number {\r\n        return this._textureMode;\r\n    }\r\n    /**\r\n     * Sets the current texture mode for the texture. It can be:\r\n     * * TextureDome.MODE_MONOSCOPIC : Define the texture source as a Monoscopic panoramic 360.\r\n     * * TextureDome.MODE_TOPBOTTOM  : Define the texture source as a Stereoscopic TopBottom/OverUnder panoramic 360.\r\n     * * TextureDome.MODE_SIDEBYSIDE : Define the texture source as a Stereoscopic Side by Side panoramic 360.\r\n     */\r\n    public set textureMode(value: number) {\r\n        if (this._textureMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._changeTextureMode(value);\r\n    }\r\n\r\n    /**\r\n     * Is it a 180 degrees dome (half dome) or 360 texture (full dome)\r\n     */\r\n    public get halfDome(): boolean {\r\n        return this._halfDome;\r\n    }\r\n\r\n    /**\r\n     * Set the halfDome mode. If set, only the front (180 degrees) will be displayed and the back will be blacked out.\r\n     */\r\n    public set halfDome(enabled: boolean) {\r\n        this._halfDome = enabled;\r\n        this._halfDomeMask.setEnabled(enabled);\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Set the cross-eye mode. If set, images that can be seen when crossing eyes will render correctly\r\n     */\r\n    public set crossEye(enabled: boolean) {\r\n        this._crossEye = enabled;\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    /**\r\n     * Is it a cross-eye texture?\r\n     */\r\n    public get crossEye(): boolean {\r\n        return this._crossEye;\r\n    }\r\n\r\n    /**\r\n     * The background material of this dome.\r\n     */\r\n    public get material(): BackgroundMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Oberserver used in Stereoscopic VR Mode.\r\n     */\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    /**\r\n     * Observable raised when an error occurred while loading the texture\r\n     */\r\n    public onLoadErrorObservable = new Observable<string>();\r\n    /**\r\n     * Observable raised when the texture finished loading\r\n     */\r\n    public onLoadObservable = new Observable<void>();\r\n\r\n    /**\r\n     * Create an instance of this class and pass through the parameters to the relevant classes- Texture, StandardMaterial, and Mesh.\r\n     * @param name Element's name, child elements will append suffixes for their own names.\r\n     * @param textureUrlOrElement defines the url(s) or the (video) HTML element to use\r\n     * @param options An object containing optional or exposed sub element properties\r\n     * @param options.resolution\r\n     * @param options.clickToPlay\r\n     * @param options.autoPlay\r\n     * @param options.loop\r\n     * @param options.size\r\n     * @param options.poster\r\n     * @param options.faceForward\r\n     * @param options.useDirectMapping\r\n     * @param options.halfDomeMode\r\n     * @param options.crossEyeMode\r\n     * @param options.generateMipMaps\r\n     * @param options.mesh\r\n     * @param scene\r\n     * @param onError\r\n     */\r\n    constructor(\r\n        name: string,\r\n        textureUrlOrElement: string | string[] | HTMLVideoElement,\r\n        options: {\r\n            resolution?: number;\r\n            clickToPlay?: boolean;\r\n            autoPlay?: boolean;\r\n            loop?: boolean;\r\n            size?: number;\r\n            poster?: string;\r\n            faceForward?: boolean;\r\n            useDirectMapping?: boolean;\r\n            halfDomeMode?: boolean;\r\n            crossEyeMode?: boolean;\r\n            generateMipMaps?: boolean;\r\n            mesh?: Mesh;\r\n        },\r\n        scene: Scene,\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        protected onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(name, scene);\r\n\r\n        scene = this.getScene();\r\n\r\n        // set defaults and manage values\r\n        name = name || \"textureDome\";\r\n        options.resolution = Math.abs(options.resolution as any) | 0 || 32;\r\n        options.clickToPlay = Boolean(options.clickToPlay);\r\n        options.autoPlay = options.autoPlay === undefined ? true : Boolean(options.autoPlay);\r\n        options.loop = options.loop === undefined ? true : Boolean(options.loop);\r\n        options.size = Math.abs(options.size as any) || (scene.activeCamera ? scene.activeCamera.maxZ * 0.48 : 1000);\r\n\r\n        if (options.useDirectMapping === undefined) {\r\n            this._useDirectMapping = true;\r\n        } else {\r\n            this._useDirectMapping = options.useDirectMapping;\r\n        }\r\n\r\n        if (options.faceForward === undefined) {\r\n            options.faceForward = true;\r\n        }\r\n\r\n        this._setReady(false);\r\n        if (!options.mesh) {\r\n            this._mesh = CreateSphere(name + \"_mesh\", { segments: options.resolution, diameter: options.size, updatable: false, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        } else {\r\n            this._mesh = options.mesh;\r\n        }\r\n        // configure material\r\n        const material = (this._material = new BackgroundMaterial(name + \"_material\", scene));\r\n        material.useEquirectangularFOV = true;\r\n        material.fovMultiplier = 1.0;\r\n        material.opacityFresnel = false;\r\n\r\n        const texture = this._initTexture(textureUrlOrElement, scene, options);\r\n        this.texture = texture;\r\n\r\n        // configure mesh\r\n        this._mesh.material = material;\r\n        this._mesh.parent = this;\r\n\r\n        // create a (disabled until needed) mask to cover unneeded segments of 180 texture.\r\n        this._halfDomeMask = CreateSphere(\"\", { slice: 0.5, diameter: options.size * 0.98, segments: options.resolution * 2, sideOrientation: Mesh.BACKSIDE }, scene);\r\n        this._halfDomeMask.rotate(Axis.X, -Math.PI / 2);\r\n        // set the parent, so it will always be positioned correctly AND will be disposed when the main sphere is disposed\r\n        this._halfDomeMask.parent = this._mesh;\r\n        this._halfDome = !!options.halfDomeMode;\r\n        // enable or disable according to the settings\r\n        this._halfDomeMask.setEnabled(this._halfDome);\r\n        this._crossEye = !!options.crossEyeMode;\r\n\r\n        // create\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n        this._texture.onLoadObservable.addOnce(() => {\r\n            this._setReady(true);\r\n        });\r\n\r\n        // Initial rotation\r\n        if (options.faceForward && scene.activeCamera) {\r\n            const camera = scene.activeCamera;\r\n\r\n            const forward = Vector3.Forward();\r\n            const direction = Vector3.TransformNormal(forward, camera.getViewMatrix());\r\n            direction.normalize();\r\n\r\n            this.rotation.y = Math.acos(Vector3.Dot(forward, direction));\r\n        }\r\n\r\n        this._changeTextureMode(this._textureMode);\r\n    }\r\n\r\n    protected abstract _initTexture(urlsOrElement: string | string[] | HTMLElement, scene: Scene, options: any): T;\r\n\r\n    protected _changeTextureMode(value: number): void {\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this._textureMode = value;\r\n\r\n        // Default Setup and Reset.\r\n        this._texture.uScale = 1;\r\n        this._texture.vScale = 1;\r\n        this._texture.uOffset = 0;\r\n        this._texture.vOffset = 0;\r\n        this._texture.vAng = 0;\r\n\r\n        switch (value) {\r\n            case TextureDome.MODE_MONOSCOPIC:\r\n                if (this._halfDome) {\r\n                    this._texture.uScale = 2;\r\n                    this._texture.uOffset = -1;\r\n                }\r\n                break;\r\n            case TextureDome.MODE_SIDEBYSIDE: {\r\n                // in half-dome mode the uScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.uScale = this._halfDome ? 0.99999 : 0.5;\r\n                const rightOffset = this._halfDome ? 0.0 : 0.5;\r\n                const leftOffset = this._halfDome ? -0.5 : 0.0;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    if (isRightCamera) {\r\n                        this._texture.uOffset = rightOffset;\r\n                    } else {\r\n                        this._texture.uOffset = leftOffset;\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case TextureDome.MODE_TOPBOTTOM:\r\n                // in half-dome mode the vScale should be double of 360 texture\r\n                // Use 0.99999 to boost perf by not switching program\r\n                this._texture.vScale = this._halfDome ? 0.99999 : 0.5;\r\n                this._onBeforeCameraRenderObserver = this._scene.onBeforeCameraRenderObservable.add((camera) => {\r\n                    let isRightCamera = camera.isRightCamera;\r\n                    // allow \"cross-eye\" if left and right were switched in this mode\r\n                    if (this._crossEye) {\r\n                        isRightCamera = !isRightCamera;\r\n                    }\r\n                    this._texture.vOffset = isRightCamera ? 0.5 : 0.0;\r\n                });\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        this._texture.dispose();\r\n        this._mesh.dispose();\r\n        this._material.dispose();\r\n\r\n        this._scene.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\r\n        this.onLoadErrorObservable.clear();\r\n        this.onLoadObservable.clear();\r\n\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}