{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Matrix } from \"../../Maths/math.vector.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { RandomGUID } from \"../../Misc/guid.js\";\nimport \"../../Misc/fileTools.js\";\nimport { ThinTexture } from \"./thinTexture.js\";\n/**\n * Base class of all the textures in babylon.\n * It groups all the common properties the materials, post process, lights... might need\n * in order to make a correct use of the texture.\n */\nexport class BaseTexture extends ThinTexture {\n  /**\n   * Instantiates a new BaseTexture.\n   * Base class of all the textures in babylon.\n   * It groups all the common properties the materials, post process, lights... might need\n   * in order to make a correct use of the texture.\n   * @param sceneOrEngine Define the scene or engine the texture belongs to\n   * @param internalTexture Define the internal texture associated with the texture\n   */\n  constructor(sceneOrEngine, internalTexture = null) {\n    super(null);\n    /**\n     * Gets or sets an object used to store user defined information.\n     */\n    this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n    this.reservedDataStore = null;\n    this._hasAlpha = false;\n    this._getAlphaFromRGB = false;\n    /**\n     * Intensity or strength of the texture.\n     * It is commonly used by materials to fine tune the intensity of the texture\n     */\n    this.level = 1;\n    this._coordinatesIndex = 0;\n    /**\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\n     */\n    this.optimizeUVAllocation = true;\n    this._coordinatesMode = 0;\n    /**\n     * | Value | Type               | Description |\n     * | ----- | ------------------ | ----------- |\n     * | 0     | CLAMP_ADDRESSMODE  |             |\n     * | 1     | WRAP_ADDRESSMODE   |             |\n     * | 2     | MIRROR_ADDRESSMODE |             |\n     */\n    this.wrapR = 1;\n    /**\n     * With compliant hardware and browser (supporting anisotropic filtering)\n     * this defines the level of anisotropic filtering in the texture.\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\n     */\n    this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n    /** @internal */\n    this._isCube = false;\n    this._gammaSpace = true;\n    /**\n     * Is Z inverted in the texture (useful in a cube texture).\n     */\n    this.invertZ = false;\n    /**\n     * @internal\n     */\n    this.lodLevelInAlpha = false;\n    /**\n     * Define if the texture is a render target.\n     */\n    this.isRenderTarget = false;\n    /** @internal */\n    this._prefiltered = false;\n    /** @internal */\n    this._forceSerialize = false;\n    /**\n     * Define the list of animation attached to the texture.\n     */\n    this.animations = new Array();\n    /**\n     * An event triggered when the texture is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._onDisposeObserver = null;\n    this._scene = null;\n    /** @internal */\n    this._uid = null;\n    /** @internal */\n    this._parentContainer = null;\n    this._loadingError = false;\n    if (sceneOrEngine) {\n      if (BaseTexture._IsScene(sceneOrEngine)) {\n        this._scene = sceneOrEngine;\n      } else {\n        this._engine = sceneOrEngine;\n      }\n    } else {\n      this._scene = EngineStore.LastCreatedScene;\n    }\n    if (this._scene) {\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.addTexture(this);\n      this._engine = this._scene.getEngine();\n    }\n    this._texture = internalTexture;\n    this._uid = null;\n  }\n  /**\n   * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\n   */\n  set hasAlpha(value) {\n    if (this._hasAlpha === value) {\n      return;\n    }\n    this._hasAlpha = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get hasAlpha() {\n    return this._hasAlpha;\n  }\n  /**\n   * Defines if the alpha value should be determined via the rgb values.\n   * If true the luminance of the pixel might be used to find the corresponding alpha value.\n   */\n  set getAlphaFromRGB(value) {\n    if (this._getAlphaFromRGB === value) {\n      return;\n    }\n    this._getAlphaFromRGB = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get getAlphaFromRGB() {\n    return this._getAlphaFromRGB;\n  }\n  /**\n   * Define the UV channel to use starting from 0 and defaulting to 0.\n   * This is part of the texture as textures usually maps to one uv set.\n   */\n  set coordinatesIndex(value) {\n    if (this._coordinatesIndex === value) {\n      return;\n    }\n    this._coordinatesIndex = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get coordinatesIndex() {\n    return this._coordinatesIndex;\n  }\n  /**\n   * How a texture is mapped.\n   *\n   * | Value | Type                                | Description |\n   * | ----- | ----------------------------------- | ----------- |\n   * | 0     | EXPLICIT_MODE                       |             |\n   * | 1     | SPHERICAL_MODE                      |             |\n   * | 2     | PLANAR_MODE                         |             |\n   * | 3     | CUBIC_MODE                          |             |\n   * | 4     | PROJECTION_MODE                     |             |\n   * | 5     | SKYBOX_MODE                         |             |\n   * | 6     | INVCUBIC_MODE                       |             |\n   * | 7     | EQUIRECTANGULAR_MODE                |             |\n   * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\n   * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\n   */\n  set coordinatesMode(value) {\n    if (this._coordinatesMode === value) {\n      return;\n    }\n    this._coordinatesMode = value;\n    if (this._scene) {\n      this._scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this);\n      });\n    }\n  }\n  get coordinatesMode() {\n    return this._coordinatesMode;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapU() {\n    return this._wrapU;\n  }\n  set wrapU(value) {\n    this._wrapU = value;\n  }\n  /**\n   * | Value | Type               | Description |\n   * | ----- | ------------------ | ----------- |\n   * | 0     | CLAMP_ADDRESSMODE  |             |\n   * | 1     | WRAP_ADDRESSMODE   |             |\n   * | 2     | MIRROR_ADDRESSMODE |             |\n   */\n  get wrapV() {\n    return this._wrapV;\n  }\n  set wrapV(value) {\n    this._wrapV = value;\n  }\n  /**\n   * Define if the texture is a cube texture or if false a 2d texture.\n   */\n  get isCube() {\n    if (!this._texture) {\n      return this._isCube;\n    }\n    return this._texture.isCube;\n  }\n  set isCube(value) {\n    if (!this._texture) {\n      this._isCube = value;\n    } else {\n      this._texture.isCube = value;\n    }\n  }\n  /**\n   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\n   */\n  get is3D() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is3D;\n  }\n  set is3D(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is3D = value;\n  }\n  /**\n   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\n   */\n  get is2DArray() {\n    if (!this._texture) {\n      return false;\n    }\n    return this._texture.is2DArray;\n  }\n  set is2DArray(value) {\n    if (!this._texture) {\n      return;\n    }\n    this._texture.is2DArray = value;\n  }\n  /**\n   * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\n   * HDR texture are usually stored in linear space.\n   * This only impacts the PBR and Background materials\n   */\n  get gammaSpace() {\n    if (!this._texture) {\n      return this._gammaSpace;\n    } else {\n      if (this._texture._gammaSpace === null) {\n        this._texture._gammaSpace = this._gammaSpace;\n      }\n    }\n    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\n  }\n  set gammaSpace(gamma) {\n    if (!this._texture) {\n      if (this._gammaSpace === gamma) {\n        return;\n      }\n      this._gammaSpace = gamma;\n    } else {\n      if (this._texture._gammaSpace === gamma) {\n        return;\n      }\n      this._texture._gammaSpace = gamma;\n    }\n    this._markAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Gets or sets whether or not the texture contains RGBD data.\n   */\n  get isRGBD() {\n    return this._texture != null && this._texture._isRGBD;\n  }\n  set isRGBD(value) {\n    if (this._texture) {\n      this._texture._isRGBD = value;\n    }\n  }\n  /**\n   * Are mip maps generated for this texture or not.\n   */\n  get noMipmap() {\n    return false;\n  }\n  /**\n   * With prefiltered texture, defined the offset used during the prefiltering steps.\n   */\n  get lodGenerationOffset() {\n    if (this._texture) {\n      return this._texture._lodGenerationOffset;\n    }\n    return 0.0;\n  }\n  set lodGenerationOffset(value) {\n    if (this._texture) {\n      this._texture._lodGenerationOffset = value;\n    }\n  }\n  /**\n   * With prefiltered texture, defined the scale used during the prefiltering steps.\n   */\n  get lodGenerationScale() {\n    if (this._texture) {\n      return this._texture._lodGenerationScale;\n    }\n    return 0.0;\n  }\n  set lodGenerationScale(value) {\n    if (this._texture) {\n      this._texture._lodGenerationScale = value;\n    }\n  }\n  /**\n   * With prefiltered texture, defined if the specular generation is based on a linear ramp.\n   * By default we are using a log2 of the linear roughness helping to keep a better resolution for\n   * average roughness values.\n   */\n  get linearSpecularLOD() {\n    if (this._texture) {\n      return this._texture._linearSpecularLOD;\n    }\n    return false;\n  }\n  set linearSpecularLOD(value) {\n    if (this._texture) {\n      this._texture._linearSpecularLOD = value;\n    }\n  }\n  /**\n   * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\n   * You can set the irradiance texture to rely on a texture instead of the spherical approach.\n   * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\n   */\n  get irradianceTexture() {\n    if (this._texture) {\n      return this._texture._irradianceTexture;\n    }\n    return null;\n  }\n  set irradianceTexture(value) {\n    if (this._texture) {\n      this._texture._irradianceTexture = value;\n    }\n  }\n  /**\n   * Define the unique id of the texture in the scene.\n   */\n  get uid() {\n    if (!this._uid) {\n      this._uid = RandomGUID();\n    }\n    return this._uid;\n  }\n  /**\n   * Return a string representation of the texture.\n   * @returns the texture as a string\n   */\n  toString() {\n    return this.name;\n  }\n  /**\n   * Get the class name of the texture.\n   * @returns \"BaseTexture\"\n   */\n  getClassName() {\n    return \"BaseTexture\";\n  }\n  /**\n   * Callback triggered when the texture has been disposed.\n   * Kept for back compatibility, you can use the onDisposeObservable instead.\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Define if the texture is preventing a material to render or not.\n   * If not and the texture is not ready, the engine will use a default black texture instead.\n   */\n  get isBlocking() {\n    return true;\n  }\n  /**\n   * Was there any loading error?\n   */\n  get loadingError() {\n    return this._loadingError;\n  }\n  /**\n   * If a loading error occurred this object will be populated with information about the error.\n   */\n  get errorObject() {\n    return this._errorObject;\n  }\n  /**\n   * Get the scene the texture belongs to.\n   * @returns the scene or null if undefined\n   */\n  getScene() {\n    return this._scene;\n  }\n  /** @internal */\n  _getEngine() {\n    return this._engine;\n  }\n  /**\n   * Checks if the texture has the same transform matrix than another texture\n   * @param texture texture to check against\n   * @returns true if the transforms are the same, else false\n   */\n  checkTransformsAreIdentical(texture) {\n    return texture !== null;\n  }\n  /**\n   * Get the texture transform matrix used to offset tile the texture for instance.\n   * @returns the transformation matrix\n   */\n  getTextureMatrix() {\n    return Matrix.IdentityReadOnly;\n  }\n  /**\n   * Get the texture reflection matrix used to rotate/transform the reflection.\n   * @returns the reflection matrix\n   */\n  getReflectionTextureMatrix() {\n    return Matrix.IdentityReadOnly;\n  }\n  /**\n   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\n   * @returns true if ready, not blocking or if there was an error loading the texture\n   */\n  isReadyOrNotBlocking() {\n    return !this.isBlocking || this.isReady() || this.loadingError;\n  }\n  /**\n   * Scales the texture if is `canRescale()`\n   * @param ratio the resize factor we want to use to rescale\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  scale(ratio) {}\n  /**\n   * Get if the texture can rescale.\n   */\n  get canRescale() {\n    return false;\n  }\n  /**\n   * @internal\n   */\n  _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\n    const texturesCache = engine.getLoadedTexturesCache();\n    for (let index = 0; index < texturesCache.length; index++) {\n      const texturesCacheEntry = texturesCache[index];\n      if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\n        if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\n          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n            if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n              if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\n                texturesCacheEntry.incrementReferences();\n                return texturesCacheEntry;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n  /** @internal */\n  _rebuild() {}\n  /**\n   * Clones the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    return null;\n  }\n  /**\n   * Get the texture underlying type (INT, FLOAT...)\n   */\n  get textureType() {\n    if (!this._texture) {\n      return 0;\n    }\n    return this._texture.type !== undefined ? this._texture.type : 0;\n  }\n  /**\n   * Get the texture underlying format (RGB, RGBA...)\n   */\n  get textureFormat() {\n    if (!this._texture) {\n      return 5;\n    }\n    return this._texture.format !== undefined ? this._texture.format : 5;\n  }\n  /**\n   * Indicates that textures need to be re-calculated for all materials\n   */\n  _markAllSubMeshesAsTexturesDirty() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    scene.markAllMaterialsAsDirty(1);\n  }\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\n   * This will returns an RGBA array buffer containing either in values (0-255) or\n   * float values (0-1) depending of the underlying buffer type.\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @param buffer defines a user defined buffer to fill with data (can be null)\n   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\n   * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\n   * @param x defines the region x coordinates to start reading from (default to 0)\n   * @param y defines the region y coordinates to start reading from (default to 0)\n   * @param width defines the region width to read from (default to the texture size at level)\n   * @param height defines the region width to read from (default to the texture size at level)\n   * @returns The Array buffer promise containing the pixels data.\n   */\n  readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {\n    if (!this._texture) {\n      return null;\n    }\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    const size = this.getSize();\n    let maxWidth = size.width;\n    let maxHeight = size.height;\n    if (level !== 0) {\n      maxWidth = maxWidth / Math.pow(2, level);\n      maxHeight = maxHeight / Math.pow(2, level);\n      maxWidth = Math.round(maxWidth);\n      maxHeight = Math.round(maxHeight);\n    }\n    width = Math.min(maxWidth, width);\n    height = Math.min(maxHeight, height);\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\n      }\n      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\n    } catch (e) {\n      return null;\n    }\n  }\n  /**\n   * @internal\n   */\n  _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {\n    if (!this._texture) {\n      return null;\n    }\n    const size = this.getSize();\n    let width = size.width;\n    let height = size.height;\n    const engine = this._getEngine();\n    if (!engine) {\n      return null;\n    }\n    if (level != 0) {\n      width = width / Math.pow(2, level);\n      height = height / Math.pow(2, level);\n      width = Math.round(width);\n      height = Math.round(height);\n    }\n    try {\n      if (this._texture.isCube) {\n        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\n      }\n      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\n    } catch (e) {\n      return null;\n    }\n  }\n  /** @internal */\n  get _lodTextureHigh() {\n    if (this._texture) {\n      return this._texture._lodTextureHigh;\n    }\n    return null;\n  }\n  /** @internal */\n  get _lodTextureMid() {\n    if (this._texture) {\n      return this._texture._lodTextureMid;\n    }\n    return null;\n  }\n  /** @internal */\n  get _lodTextureLow() {\n    if (this._texture) {\n      return this._texture._lodTextureLow;\n    }\n    return null;\n  }\n  /**\n   * Dispose the texture and release its associated resources.\n   */\n  dispose() {\n    if (this._scene) {\n      // Animations\n      if (this._scene.stopAnimation) {\n        this._scene.stopAnimation(this);\n      }\n      // Remove from scene\n      this._scene.removePendingData(this);\n      const index = this._scene.textures.indexOf(this);\n      if (index >= 0) {\n        this._scene.textures.splice(index, 1);\n      }\n      this._scene.onTextureRemovedObservable.notifyObservers(this);\n      this._scene = null;\n      if (this._parentContainer) {\n        const index = this._parentContainer.textures.indexOf(this);\n        if (index > -1) {\n          this._parentContainer.textures.splice(index, 1);\n        }\n        this._parentContainer = null;\n      }\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n    super.dispose();\n  }\n  /**\n   * Serialize the texture into a JSON representation that can be parsed later on.\n   * @param allowEmptyName True to force serialization even if name is empty. Default: false\n   * @returns the JSON representation of the texture\n   */\n  serialize(allowEmptyName = false) {\n    if (!this.name && !allowEmptyName) {\n      return null;\n    }\n    const serializationObject = SerializationHelper.Serialize(this);\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  }\n  /**\n   * Helper function to be called back once a list of texture contains only ready textures.\n   * @param textures Define the list of textures to wait for\n   * @param callback Define the callback triggered once the entire list will be ready\n   */\n  static WhenAllReady(textures, callback) {\n    let numRemaining = textures.length;\n    if (numRemaining === 0) {\n      callback();\n      return;\n    }\n    for (let i = 0; i < textures.length; i++) {\n      const texture = textures[i];\n      if (texture.isReady()) {\n        if (--numRemaining === 0) {\n          callback();\n        }\n      } else {\n        const onLoadObservable = texture.onLoadObservable;\n        if (onLoadObservable) {\n          onLoadObservable.addOnce(() => {\n            if (--numRemaining === 0) {\n              callback();\n            }\n          });\n        } else {\n          if (--numRemaining === 0) {\n            callback();\n          }\n        }\n      }\n    }\n  }\n  static _IsScene(sceneOrEngine) {\n    return sceneOrEngine.getClassName() === \"Scene\";\n  }\n}\n/**\n * Default anisotropic filtering level for the application.\n * It is set to 4 as a good tradeoff between perf and quality.\n */\nBaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n__decorate([serialize()], BaseTexture.prototype, \"uniqueId\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"name\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"metadata\", void 0);\n__decorate([serialize(\"hasAlpha\")], BaseTexture.prototype, \"_hasAlpha\", void 0);\n__decorate([serialize(\"getAlphaFromRGB\")], BaseTexture.prototype, \"_getAlphaFromRGB\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"level\", void 0);\n__decorate([serialize(\"coordinatesIndex\")], BaseTexture.prototype, \"_coordinatesIndex\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"optimizeUVAllocation\", void 0);\n__decorate([serialize(\"coordinatesMode\")], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"wrapU\", null);\n__decorate([serialize()], BaseTexture.prototype, \"wrapV\", null);\n__decorate([serialize()], BaseTexture.prototype, \"wrapR\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"isCube\", null);\n__decorate([serialize()], BaseTexture.prototype, \"is3D\", null);\n__decorate([serialize()], BaseTexture.prototype, \"is2DArray\", null);\n__decorate([serialize()], BaseTexture.prototype, \"gammaSpace\", null);\n__decorate([serialize()], BaseTexture.prototype, \"invertZ\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n__decorate([serialize()], BaseTexture.prototype, \"lodGenerationOffset\", null);\n__decorate([serialize()], BaseTexture.prototype, \"lodGenerationScale\", null);\n__decorate([serialize()], BaseTexture.prototype, \"linearSpecularLOD\", null);\n__decorate([serializeAsTexture()], BaseTexture.prototype, \"irradianceTexture\", null);\n__decorate([serialize()], BaseTexture.prototype, \"isRenderTarget\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","serializeAsTexture","Observable","Matrix","EngineStore","RandomGUID","ThinTexture","BaseTexture","constructor","sceneOrEngine","internalTexture","DEFAULT_ANISOTROPIC_FILTERING_LEVEL","Array","_IsScene","_scene","_engine","LastCreatedScene","uniqueId","getUniqueId","addTexture","getEngine","_texture","_uid","hasAlpha","value","_hasAlpha","markAllMaterialsAsDirty","mat","hasTexture","getAlphaFromRGB","_getAlphaFromRGB","coordinatesIndex","_coordinatesIndex","coordinatesMode","_coordinatesMode","wrapU","_wrapU","wrapV","_wrapV","isCube","_isCube","is3D","is2DArray","gammaSpace","_gammaSpace","_useSRGBBuffer","gamma","_markAllSubMeshesAsTexturesDirty","isRGBD","_isRGBD","noMipmap","lodGenerationOffset","_lodGenerationOffset","lodGenerationScale","_lodGenerationScale","linearSpecularLOD","_linearSpecularLOD","irradianceTexture","_irradianceTexture","uid","toString","name","getClassName","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","isBlocking","loadingError","_loadingError","errorObject","_errorObject","getScene","_getEngine","checkTransformsAreIdentical","texture","getTextureMatrix","IdentityReadOnly","getReflectionTextureMatrix","isReadyOrNotBlocking","isReady","scale","ratio","canRescale","_getFromCache","url","sampling","invertY","useSRGBBuffer","engine","correctedUseSRGBBuffer","_getUseSRGBBuffer","texturesCache","getLoadedTexturesCache","index","length","texturesCacheEntry","undefined","generateMipMaps","samplingMode","incrementReferences","_rebuild","clone","textureType","type","textureFormat","format","scene","readPixels","faceIndex","level","buffer","flushRenderer","noDataConversion","x","y","width","Number","MAX_VALUE","height","size","getSize","maxWidth","maxHeight","Math","pow","round","min","_readTexturePixels","e","_readPixelsSync","_readTexturePixelsSync","_lodTextureHigh","_lodTextureMid","_lodTextureLow","dispose","stopAnimation","removePendingData","textures","indexOf","splice","onTextureRemovedObservable","notifyObservers","_parentContainer","clear","metadata","allowEmptyName","serializationObject","Serialize","AppendSerializedAnimations","WhenAllReady","numRemaining","i","onLoadObservable","addOnce","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/baseTexture.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\ndeclare type Animation = import(\"../../Animations/animation\").Animation;\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    private _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | ThinEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}