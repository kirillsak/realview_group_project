{"ast":null,"code":"import { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\nimport { Matrix } from \"../Maths/math.js\";\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Observable } from \"../Misc/observable.js\";\n/**\n * Gizmo that enables viewing a camera\n */\nexport class CameraGizmo extends Gizmo {\n  /**\n   * Creates a CameraGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    super(gizmoLayer);\n    this._pointerObserver = null;\n    /**\n     * Event that fires each time the gizmo is clicked\n     */\n    this.onClickedObservable = new Observable();\n    this._camera = null;\n    this._invProjection = new Matrix();\n    this._material = new StandardMaterial(\"cameraGizmoMaterial\", this.gizmoLayer.utilityLayerScene);\n    this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!this._camera) {\n        return;\n      }\n      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n      if (this._isHovered && pointerInfo.event.button === 0) {\n        this.onClickedObservable.notifyObservers(this._camera);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n  }\n  /** Gets or sets a boolean indicating if frustum lines must be rendered (true by default)) */\n  get displayFrustum() {\n    return this._cameraLinesMesh.isEnabled();\n  }\n  set displayFrustum(value) {\n    this._cameraLinesMesh.setEnabled(value);\n  }\n  /**\n   * The camera that the gizmo is attached to\n   */\n  set camera(camera) {\n    this._camera = camera;\n    this.attachedNode = camera;\n    if (camera) {\n      // Create the mesh for the given camera\n      if (this._cameraMesh) {\n        this._cameraMesh.dispose();\n      }\n      if (this._cameraLinesMesh) {\n        this._cameraLinesMesh.dispose();\n      }\n      this._cameraMesh = CameraGizmo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);\n      this._cameraLinesMesh = CameraGizmo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene);\n      this._cameraMesh.getChildMeshes(false).forEach(m => {\n        m.material = this._material;\n      });\n      this._cameraMesh.parent = this._rootMesh;\n      this._cameraLinesMesh.parent = this._rootMesh;\n      if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ * 1.5) {\n        this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ * 1.5;\n      }\n      if (!this.attachedNode.reservedDataStore) {\n        this.attachedNode.reservedDataStore = {};\n      }\n      this.attachedNode.reservedDataStore.cameraGizmo = this;\n      // Add lighting to the camera gizmo\n      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));\n      this._update();\n    }\n  }\n  get camera() {\n    return this._camera;\n  }\n  /**\n   * Gets the material used to render the camera gizmo\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * @internal\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    super._update();\n    if (!this._camera) {\n      return;\n    }\n    // frustum matrix\n    this._camera.getProjectionMatrix().invertToRef(this._invProjection);\n    this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);\n    this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;\n    this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;\n    this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z;\n    // take care of coordinate system in camera scene to properly display the mesh with the good Y axis orientation in this scene\n    this._cameraMesh.parent = null;\n    this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);\n    this._cameraMesh.parent = this._rootMesh;\n  }\n  /**\n   * Disposes of the camera gizmo\n   */\n  dispose() {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    if (this._cameraMesh) {\n      this._cameraMesh.dispose();\n    }\n    if (this._cameraLinesMesh) {\n      this._cameraLinesMesh.dispose();\n    }\n    this._material.dispose();\n    super.dispose();\n  }\n  static _CreateCameraMesh(scene) {\n    const root = new Mesh(\"rootCameraGizmo\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    const box = CreateBox(root.name, {\n      width: 1.0,\n      height: 0.8,\n      depth: 0.5\n    }, scene);\n    box.parent = mesh;\n    const cyl1 = CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.8,\n      diameterBottom: 0.8\n    }, scene);\n    cyl1.parent = mesh;\n    cyl1.position.y = 0.3;\n    cyl1.position.x = -0.6;\n    cyl1.rotation.x = Math.PI * 0.5;\n    const cyl2 = CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.6,\n      diameterBottom: 0.6\n    }, scene);\n    cyl2.parent = mesh;\n    cyl2.position.y = 0.5;\n    cyl2.position.x = 0.4;\n    cyl2.rotation.x = Math.PI * 0.5;\n    const cyl3 = CreateCylinder(root.name, {\n      height: 0.5,\n      diameterTop: 0.5,\n      diameterBottom: 0.5\n    }, scene);\n    cyl3.parent = mesh;\n    cyl3.position.y = 0.0;\n    cyl3.position.x = 0.6;\n    cyl3.rotation.z = Math.PI * 0.5;\n    root.scaling.scaleInPlace(CameraGizmo._Scale);\n    mesh.position.x = -0.9;\n    return root;\n  }\n  static _CreateCameraFrustum(scene) {\n    const root = new Mesh(\"rootCameraGizmo\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    for (let y = 0; y < 4; y += 2) {\n      for (let x = 0; x < 4; x += 2) {\n        let line = CreateLines(\"lines\", {\n          points: [new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n        line = CreateLines(\"lines\", {\n          points: [new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n        line = CreateLines(\"lines\", {\n          points: [new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)]\n        }, scene);\n        line.parent = mesh;\n        line.alwaysSelectAsActiveMesh = true;\n        line.isPickable = false;\n      }\n    }\n    return root;\n  }\n}\n// Static helper methods\nCameraGizmo._Scale = 0.05;","map":{"version":3,"mappings":"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","names":["Vector3","Color3","Mesh","Gizmo","UtilityLayerRenderer","StandardMaterial","CreateBox","CreateCylinder","Matrix","CreateLines","PointerEventTypes","Observable","CameraGizmo","constructor","gizmoLayer","DefaultUtilityLayer","_material","utilityLayerScene","diffuseColor","specularColor","_pointerObserver","onPointerObservable","add","pointerInfo","_camera","_isHovered","pickInfo","_rootMesh","getChildMeshes","indexOf","pickedMesh","event","button","onClickedObservable","notifyObservers","POINTERDOWN","displayFrustum","_cameraLinesMesh","isEnabled","value","setEnabled","camera","attachedNode","_cameraMesh","dispose","_CreateCameraMesh","_CreateCameraFrustum","forEach","m","material","parent","activeCamera","maxZ","reservedDataStore","cameraGizmo","gizmoLight","_getSharedGizmoLight","includedOnlyMeshes","concat","_update","getProjectionMatrix","invertToRef","_invProjection","setPivotMatrix","scaling","x","y","z","rotation","Math","PI","getScene","useRightHandedSystem","clear","remove","scene","root","mesh","name","box","width","height","depth","cyl1","diameterTop","diameterBottom","position","cyl2","cyl3","scaleInPlace","_Scale","line","points","alwaysSelectAsActiveMesh","isPickable"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/cameraGizmo.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { CreateBox } from \"../Meshes/Builders/boxBuilder\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\nimport { Matrix } from \"../Maths/math\";\r\nimport { CreateLines } from \"../Meshes/Builders/linesBuilder\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\n\r\n/**\r\n * Interface for camera gizmo\r\n */\r\nexport interface ICameraGizmo extends IGizmo {\r\n    /** Event that fires each time the gizmo is clicked */\r\n    onClickedObservable: Observable<Camera>;\r\n    /** A boolean indicating if frustum lines must be rendered */\r\n    displayFrustum: boolean;\r\n    /** The camera that the gizmo is attached to */\r\n    camera: Nullable<Camera>;\r\n    /** The material used to render the camera gizmo */\r\n    readonly material: StandardMaterial;\r\n}\r\n\r\n/**\r\n * Gizmo that enables viewing a camera\r\n */\r\nexport class CameraGizmo extends Gizmo implements ICameraGizmo {\r\n    protected _cameraMesh: Mesh;\r\n    protected _cameraLinesMesh: Mesh;\r\n    protected _material: StandardMaterial;\r\n    protected _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\r\n    public onClickedObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * Creates a CameraGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer) {\r\n        super(gizmoLayer);\r\n\r\n        this._material = new StandardMaterial(\"cameraGizmoMaterial\", this.gizmoLayer.utilityLayerScene);\r\n        this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n        this._material.specularColor = new Color3(0.1, 0.1, 0.1);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this._camera) {\r\n                return;\r\n            }\r\n\r\n            this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(<Mesh>pointerInfo.pickInfo.pickedMesh) != -1);\r\n            if (this._isHovered && pointerInfo.event.button === 0) {\r\n                this.onClickedObservable.notifyObservers(this._camera);\r\n            }\r\n        }, PointerEventTypes.POINTERDOWN);\r\n    }\r\n    protected _camera: Nullable<Camera> = null;\r\n\r\n    /** Gets or sets a boolean indicating if frustum lines must be rendered (true by default)) */\r\n    public get displayFrustum() {\r\n        return this._cameraLinesMesh.isEnabled();\r\n    }\r\n    public set displayFrustum(value) {\r\n        this._cameraLinesMesh.setEnabled(value);\r\n    }\r\n\r\n    /**\r\n     * The camera that the gizmo is attached to\r\n     */\r\n    public set camera(camera: Nullable<Camera>) {\r\n        this._camera = camera;\r\n        this.attachedNode = camera;\r\n        if (camera) {\r\n            // Create the mesh for the given camera\r\n            if (this._cameraMesh) {\r\n                this._cameraMesh.dispose();\r\n            }\r\n            if (this._cameraLinesMesh) {\r\n                this._cameraLinesMesh.dispose();\r\n            }\r\n            this._cameraMesh = CameraGizmo._CreateCameraMesh(this.gizmoLayer.utilityLayerScene);\r\n            this._cameraLinesMesh = CameraGizmo._CreateCameraFrustum(this.gizmoLayer.utilityLayerScene);\r\n\r\n            this._cameraMesh.getChildMeshes(false).forEach((m) => {\r\n                m.material = this._material;\r\n            });\r\n            this._cameraMesh.parent = this._rootMesh;\r\n\r\n            this._cameraLinesMesh.parent = this._rootMesh;\r\n\r\n            if (this.gizmoLayer.utilityLayerScene.activeCamera && this.gizmoLayer.utilityLayerScene.activeCamera.maxZ < camera.maxZ * 1.5) {\r\n                this.gizmoLayer.utilityLayerScene.activeCamera.maxZ = camera.maxZ * 1.5;\r\n            }\r\n\r\n            if (!this.attachedNode!.reservedDataStore) {\r\n                this.attachedNode!.reservedDataStore = {};\r\n            }\r\n            this.attachedNode!.reservedDataStore.cameraGizmo = this;\r\n\r\n            // Add lighting to the camera gizmo\r\n            const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\r\n            gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._cameraMesh.getChildMeshes(false));\r\n\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    public get camera() {\r\n        return this._camera;\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the camera gizmo\r\n     */\r\n    public get material() {\r\n        return this._material;\r\n    }\r\n    /**\r\n     * @internal\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n\r\n    protected _update() {\r\n        super._update();\r\n        if (!this._camera) {\r\n            return;\r\n        }\r\n\r\n        // frustum matrix\r\n        this._camera.getProjectionMatrix().invertToRef(this._invProjection);\r\n        this._cameraLinesMesh.setPivotMatrix(this._invProjection, false);\r\n\r\n        this._cameraLinesMesh.scaling.x = 1 / this._rootMesh.scaling.x;\r\n        this._cameraLinesMesh.scaling.y = 1 / this._rootMesh.scaling.y;\r\n        this._cameraLinesMesh.scaling.z = 1 / this._rootMesh.scaling.z;\r\n\r\n        // take care of coordinate system in camera scene to properly display the mesh with the good Y axis orientation in this scene\r\n        this._cameraMesh.parent = null;\r\n        this._cameraMesh.rotation.y = Math.PI * 0.5 * (this._camera.getScene().useRightHandedSystem ? 1 : -1);\r\n        this._cameraMesh.parent = this._rootMesh;\r\n    }\r\n\r\n    // Static helper methods\r\n    private static _Scale = 0.05;\r\n    private _invProjection = new Matrix();\r\n\r\n    /**\r\n     * Disposes of the camera gizmo\r\n     */\r\n    public dispose() {\r\n        this.onClickedObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        if (this._cameraMesh) {\r\n            this._cameraMesh.dispose();\r\n        }\r\n        if (this._cameraLinesMesh) {\r\n            this._cameraLinesMesh.dispose();\r\n        }\r\n        this._material.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    private static _CreateCameraMesh(scene: Scene) {\r\n        const root = new Mesh(\"rootCameraGizmo\", scene);\r\n\r\n        const mesh = new Mesh(root.name, scene);\r\n        mesh.parent = root;\r\n\r\n        const box = CreateBox(root.name, { width: 1.0, height: 0.8, depth: 0.5 }, scene);\r\n        box.parent = mesh;\r\n\r\n        const cyl1 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.8, diameterBottom: 0.8 }, scene);\r\n        cyl1.parent = mesh;\r\n        cyl1.position.y = 0.3;\r\n        cyl1.position.x = -0.6;\r\n        cyl1.rotation.x = Math.PI * 0.5;\r\n\r\n        const cyl2 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.6, diameterBottom: 0.6 }, scene);\r\n        cyl2.parent = mesh;\r\n        cyl2.position.y = 0.5;\r\n        cyl2.position.x = 0.4;\r\n        cyl2.rotation.x = Math.PI * 0.5;\r\n\r\n        const cyl3 = CreateCylinder(root.name, { height: 0.5, diameterTop: 0.5, diameterBottom: 0.5 }, scene);\r\n        cyl3.parent = mesh;\r\n        cyl3.position.y = 0.0;\r\n        cyl3.position.x = 0.6;\r\n        cyl3.rotation.z = Math.PI * 0.5;\r\n\r\n        root.scaling.scaleInPlace(CameraGizmo._Scale);\r\n        mesh.position.x = -0.9;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateCameraFrustum(scene: Scene) {\r\n        const root = new Mesh(\"rootCameraGizmo\", scene);\r\n        const mesh = new Mesh(root.name, scene);\r\n        mesh.parent = root;\r\n\r\n        for (let y = 0; y < 4; y += 2) {\r\n            for (let x = 0; x < 4; x += 2) {\r\n                let line = CreateLines(\"lines\", { points: [new Vector3(-1 + x, -1 + y, -1), new Vector3(-1 + x, -1 + y, 1)] }, scene);\r\n                line.parent = mesh;\r\n                line.alwaysSelectAsActiveMesh = true;\r\n                line.isPickable = false;\r\n                line = CreateLines(\"lines\", { points: [new Vector3(-1, -1 + x, -1 + y), new Vector3(1, -1 + x, -1 + y)] }, scene);\r\n                line.parent = mesh;\r\n                line.alwaysSelectAsActiveMesh = true;\r\n                line.isPickable = false;\r\n                line = CreateLines(\"lines\", { points: [new Vector3(-1 + x, -1, -1 + y), new Vector3(-1 + x, 1, -1 + y)] }, scene);\r\n                line.parent = mesh;\r\n                line.alwaysSelectAsActiveMesh = true;\r\n                line.isPickable = false;\r\n            }\r\n        }\r\n\r\n        return root;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}