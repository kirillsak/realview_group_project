{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { Mesh } from \"./Meshes/mesh.js\";\nimport { Logger } from \"./Misc/logger.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\n/**\n * Set of assets to keep when moving a scene into an asset container.\n */\nexport class KeepAssets extends AbstractScene {}\n/**\n * Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function\n */\nexport class InstantiatedEntries {\n  constructor() {\n    /**\n     * List of new root nodes (eg. nodes with no parent)\n     */\n    this.rootNodes = [];\n    /**\n     * List of new skeletons\n     */\n    this.skeletons = [];\n    /**\n     * List of new animation groups\n     */\n    this.animationGroups = [];\n  }\n  /**\n   * Disposes the instantiated entries from the scene\n   */\n  dispose() {\n    this.rootNodes.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.rootNodes.length = 0;\n    this.skeletons.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.skeletons.length = 0;\n    this.animationGroups.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.animationGroups.length = 0;\n  }\n}\n/**\n * Container with a set of assets that can be added or removed from a scene.\n */\nexport class AssetContainer extends AbstractScene {\n  /**\n   * Instantiates an AssetContainer.\n   * @param scene The scene the AssetContainer belongs to.\n   */\n  constructor(scene) {\n    super();\n    this._wasAddedToScene = false;\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this.scene = scene;\n    this[\"sounds\"] = [];\n    this[\"effectLayers\"] = [];\n    this[\"layers\"] = [];\n    this[\"lensFlareSystems\"] = [];\n    this[\"proceduralTextures\"] = [];\n    this[\"reflectionProbes\"] = [];\n    scene.onDisposeObservable.add(() => {\n      if (!this._wasAddedToScene) {\n        this.dispose();\n      }\n    });\n    this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {\n      for (const geometry of this.geometries) {\n        geometry._rebuild();\n      }\n      for (const mesh of this.meshes) {\n        mesh._rebuild();\n      }\n      for (const system of this.particleSystems) {\n        system.rebuild();\n      }\n      for (const texture of this.textures) {\n        texture._rebuild();\n      }\n    });\n  }\n  /**\n   * Instantiate or clone all meshes and add the new ones to the scene.\n   * Skeletons and animation groups will all be cloned\n   * @param nameFunction defines an optional function used to get new names for clones\n   * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)\n   * @param options defines an optional list of options to control how to instantiate / clone models\n   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\n   * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone\n   * @returns a list of rootNodes, skeletons and animation groups that were duplicated\n   */\n  instantiateModelsToScene(nameFunction, cloneMaterials = false, options) {\n    const conversionMap = {};\n    const storeMap = {};\n    const result = new InstantiatedEntries();\n    const alreadySwappedSkeletons = [];\n    const alreadySwappedMaterials = [];\n    const localOptions = {\n      doNotInstantiate: true,\n      ...options\n    };\n    if (!localOptions.doNotInstantiate) {\n      // Always clone skinned meshes.\n      localOptions.doNotInstantiate = node => !!node.skeleton;\n    }\n    const onClone = (source, clone) => {\n      conversionMap[source.uniqueId] = clone.uniqueId;\n      storeMap[clone.uniqueId] = clone;\n      if (nameFunction) {\n        clone.name = nameFunction(source.name);\n      }\n      if (clone instanceof Mesh) {\n        const clonedMesh = clone;\n        if (clonedMesh.morphTargetManager) {\n          const oldMorphTargetManager = source.morphTargetManager;\n          clonedMesh.morphTargetManager = oldMorphTargetManager.clone();\n          for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {\n            const oldTarget = oldMorphTargetManager.getTarget(index);\n            const newTarget = clonedMesh.morphTargetManager.getTarget(index);\n            conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;\n            storeMap[newTarget.uniqueId] = newTarget;\n          }\n        }\n      }\n    };\n    this.transformNodes.forEach(o => {\n      if (localOptions.predicate && !localOptions.predicate(o)) {\n        return;\n      }\n      if (!o.parent) {\n        const newOne = o.instantiateHierarchy(null, localOptions, (source, clone) => {\n          onClone(source, clone);\n        });\n        if (newOne) {\n          result.rootNodes.push(newOne);\n        }\n      }\n    });\n    // check if there are instanced meshes in the array, to set their new source mesh\n    const instancesExist = this.meshes.some(m => m.getClassName() === \"InstancedMesh\");\n    const instanceSourceMap = [];\n    const onNewCreated = (source, clone) => {\n      onClone(source, clone);\n      if (clone.material) {\n        const mesh = clone;\n        if (mesh.material) {\n          if (cloneMaterials) {\n            const sourceMaterial = source.material;\n            if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {\n              let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : \"Clone of \" + sourceMaterial.name);\n              alreadySwappedMaterials.push(sourceMaterial);\n              conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;\n              storeMap[swap.uniqueId] = swap;\n              if (sourceMaterial.getClassName() === \"MultiMaterial\") {\n                const multi = sourceMaterial;\n                for (const material of multi.subMaterials) {\n                  if (!material) {\n                    continue;\n                  }\n                  swap = material.clone(nameFunction ? nameFunction(material.name) : \"Clone of \" + material.name);\n                  alreadySwappedMaterials.push(material);\n                  conversionMap[material.uniqueId] = swap.uniqueId;\n                  storeMap[swap.uniqueId] = swap;\n                }\n                multi.subMaterials = multi.subMaterials.map(m => m && storeMap[conversionMap[m.uniqueId]]);\n              }\n            }\n            if (mesh.getClassName() !== \"InstancedMesh\") {\n              mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];\n            }\n          } else {\n            if (mesh.material.getClassName() === \"MultiMaterial\") {\n              if (this.scene.multiMaterials.indexOf(mesh.material) === -1) {\n                this.scene.addMultiMaterial(mesh.material);\n              }\n            } else {\n              if (this.scene.materials.indexOf(mesh.material) === -1) {\n                this.scene.addMaterial(mesh.material);\n              }\n            }\n          }\n        }\n      }\n    };\n    this.meshes.forEach((o, idx) => {\n      if (localOptions.predicate && !localOptions.predicate(o)) {\n        return;\n      }\n      if (!o.parent) {\n        const isInstance = o.getClassName() === \"InstancedMesh\";\n        let sourceMap = undefined;\n        if (isInstance) {\n          const oInstance = o;\n          // find the right index for the source mesh\n          const sourceMesh = oInstance.sourceMesh;\n          const sourceMeshIndex = this.meshes.indexOf(sourceMesh);\n          if (sourceMeshIndex !== -1 && instanceSourceMap[sourceMeshIndex]) {\n            sourceMap = instanceSourceMap[sourceMeshIndex];\n          }\n        }\n        const newOne = isInstance ? o.instantiateHierarchy(null, {\n          ...localOptions,\n          newSourcedMesh: sourceMap\n        }, onNewCreated) : o.instantiateHierarchy(null, localOptions, onNewCreated);\n        if (newOne) {\n          if (instancesExist && newOne.getClassName() !== \"InstancedMesh\") {\n            instanceSourceMap[idx] = newOne;\n          }\n          result.rootNodes.push(newOne);\n        }\n      }\n    });\n    this.skeletons.forEach(s => {\n      if (localOptions.predicate && !localOptions.predicate(s)) {\n        return;\n      }\n      const clone = s.clone(nameFunction ? nameFunction(s.name) : \"Clone of \" + s.name);\n      for (const m of this.meshes) {\n        if (m.skeleton === s && !m.isAnInstance) {\n          const copy = storeMap[conversionMap[m.uniqueId]];\n          if (copy.isAnInstance) {\n            continue;\n          }\n          copy.skeleton = clone;\n          if (alreadySwappedSkeletons.indexOf(clone) !== -1) {\n            continue;\n          }\n          alreadySwappedSkeletons.push(clone);\n          // Check if bones are mesh linked\n          for (const bone of clone.bones) {\n            if (bone._linkedTransformNode) {\n              bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];\n            }\n          }\n        }\n      }\n      result.skeletons.push(clone);\n    });\n    this.animationGroups.forEach(o => {\n      if (localOptions.predicate && !localOptions.predicate(o)) {\n        return;\n      }\n      const clone = o.clone(nameFunction ? nameFunction(o.name) : \"Clone of \" + o.name, oldTarget => {\n        const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];\n        return newTarget || oldTarget;\n      });\n      result.animationGroups.push(clone);\n    });\n    return result;\n  }\n  /**\n   * Adds all the assets from the container to the scene.\n   */\n  addAllToScene() {\n    if (this._wasAddedToScene) {\n      return;\n    }\n    this._wasAddedToScene = true;\n    this.addToScene(null);\n    if (this.environmentTexture) {\n      this.scene.environmentTexture = this.environmentTexture;\n    }\n    for (const component of this.scene._serializableComponents) {\n      component.addFromContainer(this);\n    }\n    this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n    this._onContextRestoredObserver = null;\n  }\n  /**\n   * Adds assets from the container to the scene.\n   * @param predicate defines a predicate used to select which entity will be added (can be null)\n   */\n  addToScene(predicate = null) {\n    this.cameras.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addCamera(o);\n    });\n    this.lights.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addLight(o);\n    });\n    this.meshes.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addMesh(o);\n    });\n    this.skeletons.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addSkeleton(o);\n    });\n    this.animations.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addAnimation(o);\n    });\n    this.animationGroups.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addAnimationGroup(o);\n    });\n    this.multiMaterials.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addMultiMaterial(o);\n    });\n    this.materials.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addMaterial(o);\n    });\n    this.morphTargetManagers.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addMorphTargetManager(o);\n    });\n    this.geometries.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addGeometry(o);\n    });\n    this.transformNodes.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addTransformNode(o);\n    });\n    this.actionManagers.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addActionManager(o);\n    });\n    this.textures.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addTexture(o);\n    });\n    this.reflectionProbes.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.addReflectionProbe(o);\n    });\n  }\n  /**\n   * Removes all the assets in the container from the scene\n   */\n  removeAllFromScene() {\n    this._wasAddedToScene = false;\n    this.removeFromScene(null);\n    if (this.environmentTexture === this.scene.environmentTexture) {\n      this.scene.environmentTexture = null;\n    }\n    for (const component of this.scene._serializableComponents) {\n      component.removeFromContainer(this);\n    }\n  }\n  /**\n   * Removes assets in the container from the scene\n   * @param predicate defines a predicate used to select which entity will be added (can be null)\n   */\n  removeFromScene(predicate = null) {\n    this.cameras.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeCamera(o);\n    });\n    this.lights.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeLight(o);\n    });\n    this.meshes.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeMesh(o);\n    });\n    this.skeletons.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeSkeleton(o);\n    });\n    this.animations.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeAnimation(o);\n    });\n    this.animationGroups.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeAnimationGroup(o);\n    });\n    this.multiMaterials.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeMultiMaterial(o);\n    });\n    this.materials.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeMaterial(o);\n    });\n    this.morphTargetManagers.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeMorphTargetManager(o);\n    });\n    this.geometries.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeGeometry(o);\n    });\n    this.transformNodes.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeTransformNode(o);\n    });\n    this.actionManagers.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeActionManager(o);\n    });\n    this.textures.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeTexture(o);\n    });\n    this.reflectionProbes.forEach(o => {\n      if (predicate && !predicate(o)) {\n        return;\n      }\n      this.scene.removeReflectionProbe(o);\n    });\n  }\n  /**\n   * Disposes all the assets in the container\n   */\n  dispose() {\n    this.cameras.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.cameras.length = 0;\n    this.lights.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.lights.length = 0;\n    this.meshes.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.meshes.length = 0;\n    this.skeletons.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.skeletons.length = 0;\n    this.animationGroups.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.animationGroups.length = 0;\n    this.multiMaterials.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.multiMaterials.length = 0;\n    this.materials.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.materials.length = 0;\n    this.geometries.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.geometries.length = 0;\n    this.transformNodes.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.transformNodes.length = 0;\n    this.actionManagers.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.actionManagers.length = 0;\n    this.textures.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.textures.length = 0;\n    this.reflectionProbes.slice(0).forEach(o => {\n      o.dispose();\n    });\n    this.reflectionProbes.length = 0;\n    if (this.environmentTexture) {\n      this.environmentTexture.dispose();\n      this.environmentTexture = null;\n    }\n    for (const component of this.scene._serializableComponents) {\n      component.removeFromContainer(this, true);\n    }\n    if (this._onContextRestoredObserver) {\n      this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\n      this._onContextRestoredObserver = null;\n    }\n  }\n  _moveAssets(sourceAssets, targetAssets, keepAssets) {\n    if (!sourceAssets || !targetAssets) {\n      return;\n    }\n    for (const asset of sourceAssets) {\n      let move = true;\n      if (keepAssets) {\n        for (const keepAsset of keepAssets) {\n          if (asset === keepAsset) {\n            move = false;\n            break;\n          }\n        }\n      }\n      if (move) {\n        targetAssets.push(asset);\n        asset._parentContainer = this;\n      }\n    }\n  }\n  /**\n   * Removes all the assets contained in the scene and adds them to the container.\n   * @param keepAssets Set of assets to keep in the scene. (default: empty)\n   */\n  moveAllFromScene(keepAssets) {\n    this._wasAddedToScene = false;\n    if (keepAssets === undefined) {\n      keepAssets = new KeepAssets();\n    }\n    for (const key in this) {\n      if (Object.prototype.hasOwnProperty.call(this, key)) {\n        this[key] = this[key] || (key === \"_environmentTexture\" ? null : []);\n        this._moveAssets(this.scene[key], this[key], keepAssets[key]);\n      }\n    }\n    this.environmentTexture = this.scene.environmentTexture;\n    this.removeAllFromScene();\n  }\n  /**\n   * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.\n   * @returns the root mesh\n   */\n  createRootMesh() {\n    const rootMesh = new Mesh(\"assetContainerRootMesh\", this.scene);\n    this.meshes.forEach(m => {\n      if (!m.parent) {\n        rootMesh.addChild(m);\n      }\n    });\n    this.meshes.unshift(rootMesh);\n    return rootMesh;\n  }\n  /**\n   * Merge animations (direct and animation groups) from this asset container into a scene\n   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\n   * @param animatables set of animatables to retarget to a node from the scene\n   * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)\n   * @returns an array of the new AnimationGroup added to the scene (empty array if none)\n   */\n  mergeAnimationsTo(scene = EngineStore.LastCreatedScene, animatables, targetConverter = null) {\n    if (!scene) {\n      Logger.Error(\"No scene available to merge animations to\");\n      return [];\n    }\n    const _targetConverter = targetConverter ? targetConverter : target => {\n      let node = null;\n      const targetProperty = target.animations.length ? target.animations[0].targetProperty : \"\";\n      /*\n      BabylonJS adds special naming to targets that are children of nodes.\n      This name attempts to remove that special naming to get the parent nodes name in case the target\n      can't be found in the node tree\n      Ex: Torso_primitive0 likely points to a Mesh primitive. We take away primitive0 and are left with \"Torso\" which is the name\n      of the primitive's parent.\n      */\n      const name = target.name.split(\".\").join(\"\").split(\"_primitive\")[0];\n      switch (targetProperty) {\n        case \"position\":\n        case \"rotationQuaternion\":\n          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);\n          break;\n        case \"influence\":\n          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);\n          break;\n        default:\n          node = scene.getNodeByName(target.name) || scene.getNodeByName(name);\n      }\n      return node;\n    };\n    // Copy new node animations\n    const nodesInAC = this.getNodes();\n    nodesInAC.forEach(nodeInAC => {\n      const nodeInScene = _targetConverter(nodeInAC);\n      if (nodeInScene !== null) {\n        // Remove old animations with same target property as a new one\n        for (const animationInAC of nodeInAC.animations) {\n          // Doing treatment on an array for safety measure\n          const animationsWithSameProperty = nodeInScene.animations.filter(animationInScene => {\n            return animationInScene.targetProperty === animationInAC.targetProperty;\n          });\n          for (const animationWithSameProperty of animationsWithSameProperty) {\n            const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);\n            if (index > -1) {\n              nodeInScene.animations.splice(index, 1);\n            }\n          }\n        }\n        // Append new animations\n        nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);\n      }\n    });\n    const newAnimationGroups = new Array();\n    // Copy new animation groups\n    this.animationGroups.slice().forEach(animationGroupInAC => {\n      // Clone the animation group and all its animatables\n      newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));\n      // Remove animatables related to the asset container\n      animationGroupInAC.animatables.forEach(animatable => {\n        animatable.stop();\n      });\n    });\n    // Retarget animatables\n    animatables.forEach(animatable => {\n      const target = _targetConverter(animatable.target);\n      if (target) {\n        // Clone the animatable and retarget it\n        scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : undefined, undefined, true, undefined, animatable.onAnimationLoop ? animatable.onAnimationLoop : undefined);\n        // Stop animation for the target in the asset container\n        scene.stopAnimation(animatable.target);\n      }\n    });\n    return newAnimationGroups;\n  }\n}","map":{"version":3,"mappings":"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","names":["AbstractScene","Mesh","Logger","EngineStore","KeepAssets","InstantiatedEntries","constructor","dispose","rootNodes","slice","forEach","o","length","skeletons","animationGroups","AssetContainer","scene","LastCreatedScene","onDisposeObservable","add","_wasAddedToScene","_onContextRestoredObserver","getEngine","onContextRestoredObservable","geometry","geometries","_rebuild","mesh","meshes","system","particleSystems","rebuild","texture","textures","instantiateModelsToScene","nameFunction","cloneMaterials","options","conversionMap","storeMap","result","alreadySwappedSkeletons","alreadySwappedMaterials","localOptions","doNotInstantiate","node","skeleton","onClone","source","clone","uniqueId","name","clonedMesh","morphTargetManager","oldMorphTargetManager","index","numTargets","oldTarget","getTarget","newTarget","transformNodes","predicate","parent","newOne","instantiateHierarchy","push","instancesExist","some","m","getClassName","instanceSourceMap","onNewCreated","material","sourceMaterial","indexOf","swap","multi","subMaterials","map","multiMaterials","addMultiMaterial","materials","addMaterial","idx","isInstance","sourceMap","undefined","oInstance","sourceMesh","sourceMeshIndex","newSourcedMesh","s","isAnInstance","copy","bone","bones","_linkedTransformNode","addAllToScene","addToScene","environmentTexture","component","_serializableComponents","addFromContainer","remove","cameras","addCamera","lights","addLight","addMesh","addSkeleton","animations","addAnimation","addAnimationGroup","morphTargetManagers","addMorphTargetManager","addGeometry","addTransformNode","actionManagers","addActionManager","addTexture","reflectionProbes","addReflectionProbe","removeAllFromScene","removeFromScene","removeFromContainer","removeCamera","removeLight","removeMesh","removeSkeleton","removeAnimation","removeAnimationGroup","removeMultiMaterial","removeMaterial","removeMorphTargetManager","removeGeometry","removeTransformNode","removeActionManager","removeTexture","removeReflectionProbe","_moveAssets","sourceAssets","targetAssets","keepAssets","asset","move","keepAsset","_parentContainer","moveAllFromScene","key","Object","prototype","hasOwnProperty","call","createRootMesh","rootMesh","addChild","unshift","mergeAnimationsTo","animatables","targetConverter","Error","_targetConverter","target","targetProperty","split","join","getTransformNodeByName","getMorphTargetByName","getNodeByName","nodesInAC","getNodes","nodeInAC","nodeInScene","animationInAC","animationsWithSameProperty","filter","animationInScene","animationWithSameProperty","splice","concat","newAnimationGroups","Array","animationGroupInAC","animatable","stop","beginAnimation","fromFrame","toFrame","loopAnimation","speedRatio","onAnimationEnd","onAnimationLoop","stopAnimation"],"sourceRoot":"","sources":["../../../lts/core/generated/assetContainer.ts"],"sourcesContent":["import { AbstractScene } from \"./abstractScene\";\r\nimport type { Scene } from \"./scene\";\r\nimport { Mesh } from \"./Meshes/mesh\";\r\nimport type { TransformNode } from \"./Meshes/transformNode\";\r\nimport type { Skeleton } from \"./Bones/skeleton\";\r\nimport type { AnimationGroup } from \"./Animations/animationGroup\";\r\nimport type { Animatable } from \"./Animations/animatable\";\r\nimport type { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport type { Material } from \"./Materials/material\";\r\nimport { Logger } from \"./Misc/logger\";\r\nimport { EngineStore } from \"./Engines/engineStore\";\r\nimport type { Nullable } from \"./types\";\r\nimport type { Node } from \"./node\";\r\nimport type { Observer } from \"./Misc/observable\";\r\nimport type { ThinEngine } from \"./Engines/thinEngine\";\r\nimport type { InstancedMesh } from \"./Meshes/instancedMesh\";\r\n\r\n/**\r\n * Set of assets to keep when moving a scene into an asset container.\r\n */\r\nexport class KeepAssets extends AbstractScene {}\r\n\r\n/**\r\n * Class used to store the output of the AssetContainer.instantiateAllMeshesToScene function\r\n */\r\nexport class InstantiatedEntries {\r\n    /**\r\n     * List of new root nodes (eg. nodes with no parent)\r\n     */\r\n    public rootNodes: TransformNode[] = [];\r\n\r\n    /**\r\n     * List of new skeletons\r\n     */\r\n    public skeletons: Skeleton[] = [];\r\n\r\n    /**\r\n     * List of new animation groups\r\n     */\r\n    public animationGroups: AnimationGroup[] = [];\r\n\r\n    /**\r\n     * Disposes the instantiated entries from the scene\r\n     */\r\n    public dispose() {\r\n        this.rootNodes.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.rootNodes.length = 0;\r\n\r\n        this.skeletons.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.skeletons.length = 0;\r\n\r\n        this.animationGroups.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.animationGroups.length = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Container with a set of assets that can be added or removed from a scene.\r\n */\r\nexport class AssetContainer extends AbstractScene {\r\n    private _wasAddedToScene = false;\r\n    private _onContextRestoredObserver: Nullable<Observer<ThinEngine>>;\r\n\r\n    /**\r\n     * The scene the AssetContainer belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Instantiates an AssetContainer.\r\n     * @param scene The scene the AssetContainer belongs to.\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        super();\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n        this[\"sounds\"] = [];\r\n        this[\"effectLayers\"] = [];\r\n        this[\"layers\"] = [];\r\n        this[\"lensFlareSystems\"] = [];\r\n        this[\"proceduralTextures\"] = [];\r\n        this[\"reflectionProbes\"] = [];\r\n\r\n        scene.onDisposeObservable.add(() => {\r\n            if (!this._wasAddedToScene) {\r\n                this.dispose();\r\n            }\r\n        });\r\n\r\n        this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {\r\n            for (const geometry of this.geometries) {\r\n                geometry._rebuild();\r\n            }\r\n\r\n            for (const mesh of this.meshes) {\r\n                mesh._rebuild();\r\n            }\r\n\r\n            for (const system of this.particleSystems) {\r\n                system.rebuild();\r\n            }\r\n\r\n            for (const texture of this.textures) {\r\n                texture._rebuild();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Instantiate or clone all meshes and add the new ones to the scene.\r\n     * Skeletons and animation groups will all be cloned\r\n     * @param nameFunction defines an optional function used to get new names for clones\r\n     * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)\r\n     * @param options defines an optional list of options to control how to instantiate / clone models\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone\r\n     * @returns a list of rootNodes, skeletons and animation groups that were duplicated\r\n     */\r\n    public instantiateModelsToScene(\r\n        nameFunction?: (sourceName: string) => string,\r\n        cloneMaterials = false,\r\n        options?: { doNotInstantiate?: boolean | ((node: TransformNode) => boolean); predicate?: (entity: any) => boolean }\r\n    ): InstantiatedEntries {\r\n        const conversionMap: { [key: number]: number } = {};\r\n        const storeMap: { [key: number]: any } = {};\r\n        const result = new InstantiatedEntries();\r\n        const alreadySwappedSkeletons: Skeleton[] = [];\r\n        const alreadySwappedMaterials: Material[] = [];\r\n\r\n        const localOptions = {\r\n            doNotInstantiate: true,\r\n            ...options,\r\n        };\r\n\r\n        if (!localOptions.doNotInstantiate) {\r\n            // Always clone skinned meshes.\r\n            localOptions.doNotInstantiate = (node) => !!(node as AbstractMesh).skeleton;\r\n        }\r\n\r\n        const onClone = (source: TransformNode, clone: TransformNode) => {\r\n            conversionMap[source.uniqueId] = clone.uniqueId;\r\n            storeMap[clone.uniqueId] = clone;\r\n\r\n            if (nameFunction) {\r\n                clone.name = nameFunction(source.name);\r\n            }\r\n\r\n            if (clone instanceof Mesh) {\r\n                const clonedMesh = clone as Mesh;\r\n\r\n                if (clonedMesh.morphTargetManager) {\r\n                    const oldMorphTargetManager = (source as Mesh).morphTargetManager!;\r\n                    clonedMesh.morphTargetManager = oldMorphTargetManager.clone();\r\n\r\n                    for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {\r\n                        const oldTarget = oldMorphTargetManager.getTarget(index);\r\n                        const newTarget = clonedMesh.morphTargetManager.getTarget(index);\r\n\r\n                        conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;\r\n                        storeMap[newTarget.uniqueId] = newTarget;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this.transformNodes.forEach((o) => {\r\n            if (localOptions.predicate && !localOptions.predicate(o)) {\r\n                return;\r\n            }\r\n\r\n            if (!o.parent) {\r\n                const newOne = o.instantiateHierarchy(null, localOptions, (source, clone) => {\r\n                    onClone(source, clone);\r\n                });\r\n\r\n                if (newOne) {\r\n                    result.rootNodes.push(newOne);\r\n                }\r\n            }\r\n        });\r\n\r\n        // check if there are instanced meshes in the array, to set their new source mesh\r\n        const instancesExist = this.meshes.some((m) => m.getClassName() === \"InstancedMesh\");\r\n        const instanceSourceMap: TransformNode[] = [];\r\n\r\n        const onNewCreated = (source: TransformNode, clone: TransformNode) => {\r\n            onClone(source, clone);\r\n\r\n            if ((clone as any).material) {\r\n                const mesh = clone as AbstractMesh;\r\n\r\n                if (mesh.material) {\r\n                    if (cloneMaterials) {\r\n                        const sourceMaterial = (source as AbstractMesh).material!;\r\n\r\n                        if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {\r\n                            let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : \"Clone of \" + sourceMaterial.name)!;\r\n                            alreadySwappedMaterials.push(sourceMaterial);\r\n                            conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;\r\n                            storeMap[swap.uniqueId] = swap;\r\n\r\n                            if (sourceMaterial.getClassName() === \"MultiMaterial\") {\r\n                                const multi = sourceMaterial as MultiMaterial;\r\n\r\n                                for (const material of multi.subMaterials) {\r\n                                    if (!material) {\r\n                                        continue;\r\n                                    }\r\n                                    swap = material.clone(nameFunction ? nameFunction(material.name) : \"Clone of \" + material.name)!;\r\n                                    alreadySwappedMaterials.push(material);\r\n                                    conversionMap[material.uniqueId] = swap.uniqueId;\r\n                                    storeMap[swap.uniqueId] = swap;\r\n                                }\r\n\r\n                                multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);\r\n                            }\r\n                        }\r\n\r\n                        if (mesh.getClassName() !== \"InstancedMesh\") {\r\n                            mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];\r\n                        }\r\n                    } else {\r\n                        if (mesh.material.getClassName() === \"MultiMaterial\") {\r\n                            if (this.scene.multiMaterials.indexOf(mesh.material as MultiMaterial) === -1) {\r\n                                this.scene.addMultiMaterial(mesh.material as MultiMaterial);\r\n                            }\r\n                        } else {\r\n                            if (this.scene.materials.indexOf(mesh.material) === -1) {\r\n                                this.scene.addMaterial(mesh.material);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        this.meshes.forEach((o, idx) => {\r\n            if (localOptions.predicate && !localOptions.predicate(o)) {\r\n                return;\r\n            }\r\n\r\n            if (!o.parent) {\r\n                const isInstance = o.getClassName() === \"InstancedMesh\";\r\n                let sourceMap: Mesh | undefined = undefined;\r\n                if (isInstance) {\r\n                    const oInstance = o as InstancedMesh;\r\n                    // find the right index for the source mesh\r\n                    const sourceMesh = oInstance.sourceMesh;\r\n                    const sourceMeshIndex = this.meshes.indexOf(sourceMesh);\r\n                    if (sourceMeshIndex !== -1 && instanceSourceMap[sourceMeshIndex]) {\r\n                        sourceMap = instanceSourceMap[sourceMeshIndex] as Mesh;\r\n                    }\r\n                }\r\n                const newOne = isInstance\r\n                    ? (o as InstancedMesh).instantiateHierarchy(\r\n                          null,\r\n                          {\r\n                              ...localOptions,\r\n                              newSourcedMesh: sourceMap,\r\n                          },\r\n                          onNewCreated\r\n                      )\r\n                    : o.instantiateHierarchy(null, localOptions, onNewCreated);\r\n\r\n                if (newOne) {\r\n                    if (instancesExist && newOne.getClassName() !== \"InstancedMesh\") {\r\n                        instanceSourceMap[idx] = newOne;\r\n                    }\r\n                    result.rootNodes.push(newOne);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.skeletons.forEach((s) => {\r\n            if (localOptions.predicate && !localOptions.predicate(s)) {\r\n                return;\r\n            }\r\n\r\n            const clone = s.clone(nameFunction ? nameFunction(s.name) : \"Clone of \" + s.name);\r\n\r\n            for (const m of this.meshes) {\r\n                if (m.skeleton === s && !m.isAnInstance) {\r\n                    const copy = storeMap[conversionMap[m.uniqueId]] as Mesh;\r\n                    if (copy.isAnInstance) {\r\n                        continue;\r\n                    }\r\n                    copy.skeleton = clone;\r\n\r\n                    if (alreadySwappedSkeletons.indexOf(clone) !== -1) {\r\n                        continue;\r\n                    }\r\n\r\n                    alreadySwappedSkeletons.push(clone);\r\n\r\n                    // Check if bones are mesh linked\r\n                    for (const bone of clone.bones) {\r\n                        if (bone._linkedTransformNode) {\r\n                            bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            result.skeletons.push(clone);\r\n        });\r\n\r\n        this.animationGroups.forEach((o) => {\r\n            if (localOptions.predicate && !localOptions.predicate(o)) {\r\n                return;\r\n            }\r\n\r\n            const clone = o.clone(nameFunction ? nameFunction(o.name) : \"Clone of \" + o.name, (oldTarget) => {\r\n                const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];\r\n\r\n                return newTarget || oldTarget;\r\n            });\r\n\r\n            result.animationGroups.push(clone);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds all the assets from the container to the scene.\r\n     */\r\n    public addAllToScene() {\r\n        if (this._wasAddedToScene) {\r\n            return;\r\n        }\r\n\r\n        this._wasAddedToScene = true;\r\n\r\n        this.addToScene(null);\r\n\r\n        if (this.environmentTexture) {\r\n            this.scene.environmentTexture = this.environmentTexture;\r\n        }\r\n\r\n        for (const component of this.scene._serializableComponents) {\r\n            component.addFromContainer(this);\r\n        }\r\n\r\n        this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n        this._onContextRestoredObserver = null;\r\n    }\r\n\r\n    /**\r\n     * Adds assets from the container to the scene.\r\n     * @param predicate defines a predicate used to select which entity will be added (can be null)\r\n     */\r\n    public addToScene(predicate: Nullable<(entity: any) => boolean> = null) {\r\n        this.cameras.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addCamera(o);\r\n        });\r\n        this.lights.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addLight(o);\r\n        });\r\n        this.meshes.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addMesh(o);\r\n        });\r\n        this.skeletons.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addSkeleton(o);\r\n        });\r\n        this.animations.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addAnimation(o);\r\n        });\r\n        this.animationGroups.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addAnimationGroup(o);\r\n        });\r\n        this.multiMaterials.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addMultiMaterial(o);\r\n        });\r\n        this.materials.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addMaterial(o);\r\n        });\r\n        this.morphTargetManagers.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addMorphTargetManager(o);\r\n        });\r\n        this.geometries.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addGeometry(o);\r\n        });\r\n        this.transformNodes.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addTransformNode(o);\r\n        });\r\n        this.actionManagers.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addActionManager(o);\r\n        });\r\n        this.textures.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addTexture(o);\r\n        });\r\n        this.reflectionProbes.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.addReflectionProbe(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the assets in the container from the scene\r\n     */\r\n    public removeAllFromScene() {\r\n        this._wasAddedToScene = false;\r\n\r\n        this.removeFromScene(null);\r\n\r\n        if (this.environmentTexture === this.scene.environmentTexture) {\r\n            this.scene.environmentTexture = null;\r\n        }\r\n\r\n        for (const component of this.scene._serializableComponents) {\r\n            component.removeFromContainer(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes assets in the container from the scene\r\n     * @param predicate defines a predicate used to select which entity will be added (can be null)\r\n     */\r\n    public removeFromScene(predicate: Nullable<(entity: any) => boolean> = null) {\r\n        this.cameras.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeCamera(o);\r\n        });\r\n        this.lights.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeLight(o);\r\n        });\r\n        this.meshes.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeMesh(o);\r\n        });\r\n        this.skeletons.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeSkeleton(o);\r\n        });\r\n        this.animations.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeAnimation(o);\r\n        });\r\n        this.animationGroups.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeAnimationGroup(o);\r\n        });\r\n        this.multiMaterials.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeMultiMaterial(o);\r\n        });\r\n        this.materials.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeMaterial(o);\r\n        });\r\n        this.morphTargetManagers.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeMorphTargetManager(o);\r\n        });\r\n        this.geometries.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeGeometry(o);\r\n        });\r\n        this.transformNodes.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeTransformNode(o);\r\n        });\r\n        this.actionManagers.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeActionManager(o);\r\n        });\r\n        this.textures.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeTexture(o);\r\n        });\r\n        this.reflectionProbes.forEach((o) => {\r\n            if (predicate && !predicate(o)) {\r\n                return;\r\n            }\r\n            this.scene.removeReflectionProbe(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes all the assets in the container\r\n     */\r\n    public dispose() {\r\n        this.cameras.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.cameras.length = 0;\r\n\r\n        this.lights.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.lights.length = 0;\r\n\r\n        this.meshes.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.meshes.length = 0;\r\n\r\n        this.skeletons.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.skeletons.length = 0;\r\n\r\n        this.animationGroups.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.animationGroups.length = 0;\r\n\r\n        this.multiMaterials.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.multiMaterials.length = 0;\r\n\r\n        this.materials.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.materials.length = 0;\r\n\r\n        this.geometries.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.geometries.length = 0;\r\n\r\n        this.transformNodes.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.transformNodes.length = 0;\r\n\r\n        this.actionManagers.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.actionManagers.length = 0;\r\n\r\n        this.textures.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.textures.length = 0;\r\n\r\n        this.reflectionProbes.slice(0).forEach((o) => {\r\n            o.dispose();\r\n        });\r\n        this.reflectionProbes.length = 0;\r\n\r\n        if (this.environmentTexture) {\r\n            this.environmentTexture.dispose();\r\n            this.environmentTexture = null;\r\n        }\r\n\r\n        for (const component of this.scene._serializableComponents) {\r\n            component.removeFromContainer(this, true);\r\n        }\r\n\r\n        if (this._onContextRestoredObserver) {\r\n            this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);\r\n            this._onContextRestoredObserver = null;\r\n        }\r\n    }\r\n\r\n    private _moveAssets<T>(sourceAssets: T[], targetAssets: T[], keepAssets: T[]): void {\r\n        if (!sourceAssets || !targetAssets) {\r\n            return;\r\n        }\r\n\r\n        for (const asset of sourceAssets) {\r\n            let move = true;\r\n            if (keepAssets) {\r\n                for (const keepAsset of keepAssets) {\r\n                    if (asset === keepAsset) {\r\n                        move = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (move) {\r\n                targetAssets.push(asset);\r\n                (asset as any)._parentContainer = this;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the assets contained in the scene and adds them to the container.\r\n     * @param keepAssets Set of assets to keep in the scene. (default: empty)\r\n     */\r\n    public moveAllFromScene(keepAssets?: KeepAssets): void {\r\n        this._wasAddedToScene = false;\r\n\r\n        if (keepAssets === undefined) {\r\n            keepAssets = new KeepAssets();\r\n        }\r\n\r\n        for (const key in this) {\r\n            if (Object.prototype.hasOwnProperty.call(this, key)) {\r\n                (<any>this)[key] = (<any>this)[key] || (key === \"_environmentTexture\" ? null : []);\r\n                this._moveAssets((<any>this.scene)[key], (<any>this)[key], (<any>keepAssets)[key]);\r\n            }\r\n        }\r\n\r\n        this.environmentTexture = this.scene.environmentTexture;\r\n\r\n        this.removeAllFromScene();\r\n    }\r\n\r\n    /**\r\n     * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.\r\n     * @returns the root mesh\r\n     */\r\n    public createRootMesh() {\r\n        const rootMesh = new Mesh(\"assetContainerRootMesh\", this.scene);\r\n        this.meshes.forEach((m) => {\r\n            if (!m.parent) {\r\n                rootMesh.addChild(m);\r\n            }\r\n        });\r\n        this.meshes.unshift(rootMesh);\r\n        return rootMesh;\r\n    }\r\n\r\n    /**\r\n     * Merge animations (direct and animation groups) from this asset container into a scene\r\n     * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)\r\n     * @param animatables set of animatables to retarget to a node from the scene\r\n     * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)\r\n     * @returns an array of the new AnimationGroup added to the scene (empty array if none)\r\n     */\r\n    public mergeAnimationsTo(\r\n        scene: Nullable<Scene> = EngineStore.LastCreatedScene,\r\n        animatables: Animatable[],\r\n        targetConverter: Nullable<(target: any) => Nullable<Node>> = null\r\n    ): AnimationGroup[] {\r\n        if (!scene) {\r\n            Logger.Error(\"No scene available to merge animations to\");\r\n            return [];\r\n        }\r\n\r\n        const _targetConverter = targetConverter\r\n            ? targetConverter\r\n            : (target: any) => {\r\n                  let node = null;\r\n\r\n                  const targetProperty = target.animations.length ? target.animations[0].targetProperty : \"\";\r\n                  /*\r\n              BabylonJS adds special naming to targets that are children of nodes.\r\n              This name attempts to remove that special naming to get the parent nodes name in case the target\r\n              can't be found in the node tree\r\n\r\n              Ex: Torso_primitive0 likely points to a Mesh primitive. We take away primitive0 and are left with \"Torso\" which is the name\r\n              of the primitive's parent.\r\n          */\r\n                  const name = target.name.split(\".\").join(\"\").split(\"_primitive\")[0];\r\n\r\n                  switch (targetProperty) {\r\n                      case \"position\":\r\n                      case \"rotationQuaternion\":\r\n                          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);\r\n                          break;\r\n                      case \"influence\":\r\n                          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);\r\n                          break;\r\n                      default:\r\n                          node = scene.getNodeByName(target.name) || scene.getNodeByName(name);\r\n                  }\r\n\r\n                  return node;\r\n              };\r\n\r\n        // Copy new node animations\r\n        const nodesInAC = this.getNodes();\r\n        nodesInAC.forEach((nodeInAC) => {\r\n            const nodeInScene = _targetConverter(nodeInAC);\r\n            if (nodeInScene !== null) {\r\n                // Remove old animations with same target property as a new one\r\n                for (const animationInAC of nodeInAC.animations) {\r\n                    // Doing treatment on an array for safety measure\r\n                    const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {\r\n                        return animationInScene.targetProperty === animationInAC.targetProperty;\r\n                    });\r\n                    for (const animationWithSameProperty of animationsWithSameProperty) {\r\n                        const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);\r\n                        if (index > -1) {\r\n                            nodeInScene.animations.splice(index, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Append new animations\r\n                nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);\r\n            }\r\n        });\r\n\r\n        const newAnimationGroups = new Array<AnimationGroup>();\r\n\r\n        // Copy new animation groups\r\n        this.animationGroups.slice().forEach((animationGroupInAC) => {\r\n            // Clone the animation group and all its animatables\r\n            newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));\r\n\r\n            // Remove animatables related to the asset container\r\n            animationGroupInAC.animatables.forEach((animatable) => {\r\n                animatable.stop();\r\n            });\r\n        });\r\n\r\n        // Retarget animatables\r\n        animatables.forEach((animatable) => {\r\n            const target = _targetConverter(animatable.target);\r\n\r\n            if (target) {\r\n                // Clone the animatable and retarget it\r\n                scene.beginAnimation(\r\n                    target,\r\n                    animatable.fromFrame,\r\n                    animatable.toFrame,\r\n                    animatable.loopAnimation,\r\n                    animatable.speedRatio,\r\n                    animatable.onAnimationEnd ? animatable.onAnimationEnd : undefined,\r\n                    undefined,\r\n                    true,\r\n                    undefined,\r\n                    animatable.onAnimationLoop ? animatable.onAnimationLoop : undefined\r\n                );\r\n\r\n                // Stop animation for the target in the asset container\r\n                scene.stopAnimation(animatable.target);\r\n            }\r\n        });\r\n\r\n        return newAnimationGroups;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}