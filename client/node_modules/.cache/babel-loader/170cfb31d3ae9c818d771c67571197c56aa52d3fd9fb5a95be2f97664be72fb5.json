{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"./tools.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\n\n/**\n * Info about the .basis files\n */\nclass BasisFileInfo {}\n/**\n * Result of transcoding a basis file\n */\nclass TranscodeResult {}\n/**\n * Configuration options for the Basis transcoder\n */\nexport class BasisTranscodeConfiguration {}\n/**\n * @internal\n * Enum of basis transcoder formats\n */\nvar BASIS_FORMATS;\n(function (BASIS_FORMATS) {\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC1\"] = 0] = \"cTFETC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2\"] = 1] = \"cTFETC2\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC1\"] = 2] = \"cTFBC1\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC3\"] = 3] = \"cTFBC3\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC4\"] = 4] = \"cTFBC4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC5\"] = 5] = \"cTFBC5\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBC7\"] = 6] = \"cTFBC7\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_RGB\"] = 8] = \"cTFPVRTC1_4_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC1_4_RGBA\"] = 9] = \"cTFPVRTC1_4_RGBA\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFASTC_4x4\"] = 10] = \"cTFASTC_4x4\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFATC_RGB\"] = 11] = \"cTFATC_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFATC_RGBA_INTERPOLATED_ALPHA\"] = 12] = \"cTFATC_RGBA_INTERPOLATED_ALPHA\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFRGBA32\"] = 13] = \"cTFRGBA32\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFRGB565\"] = 14] = \"cTFRGB565\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFBGR565\"] = 15] = \"cTFBGR565\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFRGBA4444\"] = 16] = \"cTFRGBA4444\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFFXT1_RGB\"] = 17] = \"cTFFXT1_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC2_4_RGB\"] = 18] = \"cTFPVRTC2_4_RGB\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFPVRTC2_4_RGBA\"] = 19] = \"cTFPVRTC2_4_RGBA\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2_EAC_R11\"] = 20] = \"cTFETC2_EAC_R11\";\n  BASIS_FORMATS[BASIS_FORMATS[\"cTFETC2_EAC_RG11\"] = 21] = \"cTFETC2_EAC_RG11\";\n})(BASIS_FORMATS || (BASIS_FORMATS = {}));\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\nexport const BasisToolsOptions = {\n  /**\n   * URL to use when loading the basis transcoder\n   */\n  JSModuleURL: \"https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.js\",\n  /**\n   * URL to use when loading the wasm module for the transcoder\n   */\n  WasmModuleURL: \"https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.wasm\"\n};\n/**\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\n * @param engine\n * @returns internal format corresponding to the Basis format\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const GetInternalFormatFromBasisFormat = (basisFormat, engine) => {\n  let format;\n  switch (basisFormat) {\n    case BASIS_FORMATS.cTFETC1:\n      format = 36196;\n      break;\n    case BASIS_FORMATS.cTFBC1:\n      format = 33776;\n      break;\n    case BASIS_FORMATS.cTFBC4:\n      format = 33779;\n      break;\n    case BASIS_FORMATS.cTFASTC_4x4:\n      format = 37808;\n      break;\n    case BASIS_FORMATS.cTFETC2:\n      format = 37496;\n      break;\n    case BASIS_FORMATS.cTFBC7:\n      format = 36492;\n      break;\n  }\n  if (format === undefined) {\n    throw \"The chosen Basis transcoder format is not currently supported\";\n  }\n  return format;\n};\nlet _WorkerPromise = null;\nlet _Worker = null;\nlet _actionId = 0;\nconst _IgnoreSupportedFormats = false;\nconst _CreateWorkerAsync = () => {\n  if (!_WorkerPromise) {\n    _WorkerPromise = new Promise((res, reject) => {\n      if (_Worker) {\n        res(_Worker);\n      } else {\n        Tools.LoadFileAsync(BasisToolsOptions.WasmModuleURL).then(wasmBinary => {\n          if (typeof URL !== \"function\") {\n            return reject(\"Basis transcoder requires an environment with a URL constructor\");\n          }\n          const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunc})()`], {\n            type: \"application/javascript\"\n          }));\n          _Worker = new Worker(workerBlobUrl);\n          const initHandler = msg => {\n            if (msg.data.action === \"init\") {\n              _Worker.removeEventListener(\"message\", initHandler);\n              res(_Worker);\n            } else if (msg.data.action === \"error\") {\n              reject(msg.data.error || \"error initializing worker\");\n            }\n          };\n          _Worker.addEventListener(\"message\", initHandler);\n          _Worker.postMessage({\n            action: \"init\",\n            url: BasisToolsOptions.JSModuleURL,\n            wasmBinary: wasmBinary\n          });\n        }).catch(reject);\n      }\n    });\n  }\n  return _WorkerPromise;\n};\n/**\n * Transcodes a loaded image file to compressed pixel data\n * @param data image data to transcode\n * @param config configuration options for the transcoding\n * @returns a promise resulting in the transcoded image\n */\nexport const TranscodeAsync = (data, config) => {\n  const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n  return new Promise((res, rej) => {\n    _CreateWorkerAsync().then(() => {\n      const actionId = _actionId++;\n      const messageHandler = msg => {\n        if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\n          _Worker.removeEventListener(\"message\", messageHandler);\n          if (!msg.data.success) {\n            rej(\"Transcode is not supported on this device\");\n          } else {\n            res(msg.data);\n          }\n        }\n      };\n      _Worker.addEventListener(\"message\", messageHandler);\n      const dataViewCopy = new Uint8Array(dataView.byteLength);\n      dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\n      _Worker.postMessage({\n        action: \"transcode\",\n        id: actionId,\n        imageData: dataViewCopy,\n        config: config,\n        ignoreSupportedFormats: _IgnoreSupportedFormats\n      }, [dataViewCopy.buffer]);\n    }, error => {\n      rej(error);\n    });\n  });\n};\n/**\n * Binds a texture according to its underlying target.\n * @param texture texture to bind\n * @param engine the engine to bind the texture in\n */\nconst BindTexture = (texture, engine) => {\n  var _a, _b;\n  let target = (_a = engine._gl) === null || _a === void 0 ? void 0 : _a.TEXTURE_2D;\n  if (texture.isCube) {\n    target = (_b = engine._gl) === null || _b === void 0 ? void 0 : _b.TEXTURE_CUBE_MAP;\n  }\n  engine._bindTextureDirectly(target, texture, true);\n};\n/**\n * Loads a texture from the transcode result\n * @param texture texture load to\n * @param transcodeResult the result of transcoding the basis file to load from\n */\nexport const LoadTextureFromTranscodeResult = (texture, transcodeResult) => {\n  const engine = texture.getEngine();\n  for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\n    const rootImage = transcodeResult.fileInfo.images[i].levels[0];\n    texture._invertVScale = texture.invertY;\n    if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\n      // No compatable compressed format found, fallback to RGB\n      texture.type = 10;\n      texture.format = 4;\n      if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\n        // Create non power of two texture\n        const source = new InternalTexture(engine, InternalTextureSource.Temp);\n        texture._invertVScale = texture.invertY;\n        source.type = 10;\n        source.format = 4;\n        // Fallback requires aligned width/height\n        source.width = rootImage.width + 3 & ~3;\n        source.height = rootImage.height + 3 & ~3;\n        BindTexture(source, engine);\n        engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);\n        // Resize to power of two\n        engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(4), () => {\n          engine._releaseTexture(source);\n          BindTexture(texture, engine);\n        });\n      } else {\n        // Fallback is already inverted\n        texture._invertVScale = !texture.invertY;\n        // Upload directly\n        texture.width = rootImage.width + 3 & ~3;\n        texture.height = rootImage.height + 3 & ~3;\n        texture.samplingMode = 2;\n        BindTexture(texture, engine);\n        engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, 4, true);\n      }\n    } else {\n      texture.width = rootImage.width;\n      texture.height = rootImage.height;\n      texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\n      const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format, engine);\n      texture.format = format;\n      BindTexture(texture, engine);\n      // Upload all mip levels in the file\n      transcodeResult.fileInfo.images[i].levels.forEach((level, index) => {\n        engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\n      });\n      if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\n        Tools.Warn(\"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\");\n        texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\n        texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\n      }\n    }\n  }\n};\n/**\n * Used to load .Basis files\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\n */\nexport const BasisTools = {\n  /**\n   * URL to use when loading the basis transcoder\n   */\n  JSModuleURL: BasisToolsOptions.JSModuleURL,\n  /**\n   * URL to use when loading the wasm module for the transcoder\n   */\n  WasmModuleURL: BasisToolsOptions.WasmModuleURL,\n  /**\n   * Get the internal format to be passed to texImage2D corresponding to the .basis format value\n   * @param basisFormat format chosen from GetSupportedTranscodeFormat\n   * @returns internal format corresponding to the Basis format\n   */\n  GetInternalFormatFromBasisFormat,\n  /**\n   * Transcodes a loaded image file to compressed pixel data\n   * @param data image data to transcode\n   * @param config configuration options for the transcoding\n   * @returns a promise resulting in the transcoded image\n   */\n  TranscodeAsync,\n  /**\n   * Loads a texture from the transcode result\n   * @param texture texture load to\n   * @param transcodeResult the result of transcoding the basis file to load from\n   */\n  LoadTextureFromTranscodeResult\n};\nfunction workerFunc() {\n  const _BASIS_FORMAT = {\n    cTFETC1: 0,\n    cTFETC2: 1,\n    cTFBC1: 2,\n    cTFBC3: 3,\n    cTFBC4: 4,\n    cTFBC5: 5,\n    cTFBC7: 6,\n    cTFPVRTC1_4_RGB: 8,\n    cTFPVRTC1_4_RGBA: 9,\n    cTFASTC_4x4: 10,\n    cTFATC_RGB: 11,\n    cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n    cTFRGBA32: 13,\n    cTFRGB565: 14,\n    cTFBGR565: 15,\n    cTFRGBA4444: 16,\n    cTFFXT1_RGB: 17,\n    cTFPVRTC2_4_RGB: 18,\n    cTFPVRTC2_4_RGBA: 19,\n    cTFETC2_EAC_R11: 20,\n    cTFETC2_EAC_RG11: 21\n  };\n  let transcoderModulePromise = null;\n  onmessage = event => {\n    if (event.data.action === \"init\") {\n      // Load the transcoder if it hasn't been yet\n      if (!transcoderModulePromise) {\n        // make sure we loaded the script correctly\n        try {\n          importScripts(event.data.url);\n        } catch (e) {\n          postMessage({\n            action: \"error\",\n            error: e\n          });\n        }\n        transcoderModulePromise = BASIS({\n          // Override wasm binary\n          wasmBinary: event.data.wasmBinary\n        });\n      }\n      if (transcoderModulePromise !== null) {\n        transcoderModulePromise.then(m => {\n          BASIS = m;\n          m.initializeBasis();\n          postMessage({\n            action: \"init\"\n          });\n        });\n      }\n    } else if (event.data.action === \"transcode\") {\n      // Transcode the basis image and return the resulting pixels\n      const config = event.data.config;\n      const imgData = event.data.imageData;\n      const loadedFile = new BASIS.BasisFile(imgData);\n      const fileInfo = GetFileInfo(loadedFile);\n      let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\n      let needsConversion = false;\n      if (format === null) {\n        needsConversion = true;\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      }\n      // Begin transcode\n      let success = true;\n      if (!loadedFile.startTranscoding()) {\n        success = false;\n      }\n      const buffers = [];\n      for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\n        if (!success) {\n          break;\n        }\n        const image = fileInfo.images[imageIndex];\n        if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\n          let mipCount = image.levels.length;\n          if (config.loadMipmapLevels === false) {\n            mipCount = 1;\n          }\n          for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\n            const levelInfo = image.levels[levelIndex];\n            const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format, needsConversion);\n            if (!pixels) {\n              success = false;\n              break;\n            }\n            levelInfo.transcodedPixels = pixels;\n            buffers.push(levelInfo.transcodedPixels.buffer);\n          }\n        }\n      }\n      // Close file\n      loadedFile.close();\n      loadedFile.delete();\n      if (needsConversion) {\n        format = -1;\n      }\n      if (!success) {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id\n        });\n      } else {\n        postMessage({\n          action: \"transcode\",\n          success: success,\n          id: event.data.id,\n          fileInfo: fileInfo,\n          format: format\n        }, buffers);\n      }\n    }\n  };\n  /**\n   * Detects the supported transcode format for the file\n   * @param config transcode config\n   * @param fileInfo info about the file\n   * @returns the chosed format or null if none are supported\n   */\n  function GetSupportedTranscodeFormat(config, fileInfo) {\n    let format = null;\n    if (config.supportedCompressionFormats) {\n      if (config.supportedCompressionFormats.astc) {\n        format = _BASIS_FORMAT.cTFASTC_4x4;\n      } else if (config.supportedCompressionFormats.bc7) {\n        format = _BASIS_FORMAT.cTFBC7;\n      } else if (config.supportedCompressionFormats.s3tc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\n      } else if (config.supportedCompressionFormats.pvrtc) {\n        format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\n      } else if (config.supportedCompressionFormats.etc2) {\n        format = _BASIS_FORMAT.cTFETC2;\n      } else if (config.supportedCompressionFormats.etc1) {\n        format = _BASIS_FORMAT.cTFETC1;\n      } else {\n        format = _BASIS_FORMAT.cTFRGB565;\n      }\n    }\n    return format;\n  }\n  /**\n   * Retrieves information about the basis file eg. dimensions\n   * @param basisFile the basis file to get the info from\n   * @returns information about the basis file\n   */\n  function GetFileInfo(basisFile) {\n    const hasAlpha = basisFile.getHasAlpha();\n    const imageCount = basisFile.getNumImages();\n    const images = [];\n    for (let i = 0; i < imageCount; i++) {\n      const imageInfo = {\n        levels: []\n      };\n      const levelCount = basisFile.getNumLevels(i);\n      for (let level = 0; level < levelCount; level++) {\n        const levelInfo = {\n          width: basisFile.getImageWidth(i, level),\n          height: basisFile.getImageHeight(i, level)\n        };\n        imageInfo.levels.push(levelInfo);\n      }\n      images.push(imageInfo);\n    }\n    const info = {\n      hasAlpha,\n      images\n    };\n    return info;\n  }\n  function TranscodeLevel(loadedFile, imageIndex, levelIndex, format, convertToRgb565) {\n    const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\n    let dst = new Uint8Array(dstSize);\n    if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\n      return null;\n    }\n    // If no supported format is found, load as dxt and convert to rgb565\n    if (convertToRgb565) {\n      const alignedWidth = loadedFile.getImageWidth(imageIndex, levelIndex) + 3 & ~3;\n      const alignedHeight = loadedFile.getImageHeight(imageIndex, levelIndex) + 3 & ~3;\n      dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\n    }\n    return dst;\n  }\n  /**\n   * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\n   * An unoptimized version of dxtToRgb565.  Also, the floating\n   * point math used to compute the colors actually results in\n   * slightly different colors compared to hardware DXT decoders.\n   * @param src dxt src pixels\n   * @param srcByteOffset offset for the start of src\n   * @param  width aligned width of the image\n   * @param  height aligned height of the image\n   * @returns the converted pixels\n   */\n  function ConvertDxtToRgb565(src, srcByteOffset, width, height) {\n    const c = new Uint16Array(4);\n    const dst = new Uint16Array(width * height);\n    const blockWidth = width / 4;\n    const blockHeight = height / 4;\n    for (let blockY = 0; blockY < blockHeight; blockY++) {\n      for (let blockX = 0; blockX < blockWidth; blockX++) {\n        const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\n        c[0] = src[i] | src[i + 1] << 8;\n        c[1] = src[i + 2] | src[i + 3] << 8;\n        c[2] = (2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3 | (2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3 & 0xf800;\n        c[3] = (2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3 | (2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3 & 0x7e0 | (2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3 & 0xf800;\n        for (let row = 0; row < 4; row++) {\n          const m = src[i + 4 + row];\n          let dstI = (blockY * 4 + row) * width + blockX * 4;\n          dst[dstI++] = c[m & 0x3];\n          dst[dstI++] = c[m >> 2 & 0x3];\n          dst[dstI++] = c[m >> 4 & 0x3];\n          dst[dstI++] = c[m >> 6 & 0x3];\n        }\n      }\n    }\n    return dst;\n  }\n}\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\n  get: function () {\n    return BasisToolsOptions.JSModuleURL;\n  },\n  set: function (value) {\n    BasisToolsOptions.JSModuleURL = value;\n  }\n});\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\n  get: function () {\n    return BasisToolsOptions.WasmModuleURL;\n  },\n  set: function (value) {\n    BasisToolsOptions.WasmModuleURL = value;\n  }\n});","map":{"version":3,"mappings":"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","names":["Tools","Texture","InternalTexture","InternalTextureSource","Scalar","BasisFileInfo","TranscodeResult","BasisTranscodeConfiguration","BASIS_FORMATS","BasisToolsOptions","JSModuleURL","WasmModuleURL","GetInternalFormatFromBasisFormat","basisFormat","engine","format","cTFETC1","cTFBC1","cTFBC4","cTFASTC_4x4","cTFETC2","cTFBC7","undefined","_WorkerPromise","_Worker","_actionId","_IgnoreSupportedFormats","_CreateWorkerAsync","Promise","res","reject","LoadFileAsync","then","wasmBinary","URL","workerBlobUrl","createObjectURL","Blob","workerFunc","type","Worker","initHandler","msg","data","action","removeEventListener","error","addEventListener","postMessage","url","catch","TranscodeAsync","config","dataView","ArrayBuffer","Uint8Array","rej","actionId","messageHandler","id","success","dataViewCopy","byteLength","set","buffer","byteOffset","imageData","ignoreSupportedFormats","BindTexture","texture","target","_gl","TEXTURE_2D","isCube","TEXTURE_CUBE_MAP","_bindTextureDirectly","LoadTextureFromTranscodeResult","transcodeResult","getEngine","i","fileInfo","images","length","rootImage","levels","_invertVScale","invertY","cTFRGB565","_features","basisNeedsPOT","Log2","width","height","source","Temp","_uploadDataToTextureDirectly","Uint16Array","transcodedPixels","_rescaleTexture","scenes","_getInternalFormat","_releaseTexture","samplingMode","generateMipMaps","BasisTools","forEach","level","index","_uploadCompressedDataToTextureDirectly","Warn","_cachedWrapU","CLAMP_ADDRESSMODE","_cachedWrapV","_BASIS_FORMAT","cTFBC3","cTFBC5","cTFPVRTC1_4_RGB","cTFPVRTC1_4_RGBA","cTFATC_RGB","cTFATC_RGBA_INTERPOLATED_ALPHA","cTFRGBA32","cTFBGR565","cTFRGBA4444","cTFFXT1_RGB","cTFPVRTC2_4_RGB","cTFPVRTC2_4_RGBA","cTFETC2_EAC_R11","cTFETC2_EAC_RG11","transcoderModulePromise","onmessage","event","importScripts","e","BASIS","m","initializeBasis","imgData","loadedFile","BasisFile","GetFileInfo","GetSupportedTranscodeFormat","needsConversion","hasAlpha","startTranscoding","buffers","imageIndex","image","loadSingleImage","mipCount","loadMipmapLevels","levelIndex","levelInfo","pixels","TranscodeLevel","push","close","delete","supportedCompressionFormats","astc","bc7","s3tc","pvrtc","etc2","etc1","basisFile","getHasAlpha","imageCount","getNumImages","imageInfo","levelCount","getNumLevels","getImageWidth","getImageHeight","info","convertToRgb565","dstSize","getImageTranscodedSizeInBytes","dst","transcodeImage","alignedWidth","alignedHeight","ConvertDxtToRgb565","src","srcByteOffset","c","blockWidth","blockHeight","blockY","blockX","row","dstI","Object","defineProperty","get","value"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/basis.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * Info about the .basis files\r\n */\r\nclass BasisFileInfo {\r\n    /**\r\n     * If the file has alpha\r\n     */\r\n    public hasAlpha: boolean;\r\n    /**\r\n     * Info about each image of the basis file\r\n     */\r\n    public images: Array<{ levels: Array<{ width: number; height: number; transcodedPixels: ArrayBufferView }> }>;\r\n}\r\n\r\n/**\r\n * Result of transcoding a basis file\r\n */\r\nclass TranscodeResult {\r\n    /**\r\n     * Info about the .basis file\r\n     */\r\n    public fileInfo: BasisFileInfo;\r\n    /**\r\n     * Format to use when loading the file\r\n     */\r\n    public format: number;\r\n}\r\n\r\n/**\r\n * Configuration options for the Basis transcoder\r\n */\r\nexport class BasisTranscodeConfiguration {\r\n    /**\r\n     * Supported compression formats used to determine the supported output format of the transcoder\r\n     */\r\n    supportedCompressionFormats?: {\r\n        /**\r\n         * etc1 compression format\r\n         */\r\n        etc1?: boolean;\r\n        /**\r\n         * s3tc compression format\r\n         */\r\n        s3tc?: boolean;\r\n        /**\r\n         * pvrtc compression format\r\n         */\r\n        pvrtc?: boolean;\r\n        /**\r\n         * etc2 compression format\r\n         */\r\n        etc2?: boolean;\r\n        /**\r\n         * astc compression format\r\n         */\r\n        astc?: boolean;\r\n        /**\r\n         * bc7 compression format\r\n         */\r\n        bc7?: boolean;\r\n    };\r\n    /**\r\n     * If mipmap levels should be loaded for transcoded images (Default: true)\r\n     */\r\n    loadMipmapLevels?: boolean;\r\n    /**\r\n     * Index of a single image to load (Default: all images)\r\n     */\r\n    loadSingleImage?: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum of basis transcoder formats\r\n */\r\nenum BASIS_FORMATS {\r\n    cTFETC1 = 0,\r\n    cTFETC2 = 1,\r\n    cTFBC1 = 2,\r\n    cTFBC3 = 3,\r\n    cTFBC4 = 4,\r\n    cTFBC5 = 5,\r\n    cTFBC7 = 6,\r\n    cTFPVRTC1_4_RGB = 8,\r\n    cTFPVRTC1_4_RGBA = 9,\r\n    cTFASTC_4x4 = 10,\r\n    cTFATC_RGB = 11,\r\n    cTFATC_RGBA_INTERPOLATED_ALPHA = 12,\r\n    cTFRGBA32 = 13,\r\n    cTFRGB565 = 14,\r\n    cTFBGR565 = 15,\r\n    cTFRGBA4444 = 16,\r\n    cTFFXT1_RGB = 17,\r\n    cTFPVRTC2_4_RGB = 18,\r\n    cTFPVRTC2_4_RGBA = 19,\r\n    cTFETC2_EAC_R11 = 20,\r\n    cTFETC2_EAC_RG11 = 21,\r\n}\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisToolsOptions = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: \"https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.js\",\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: \"https://cdn.babylonjs.com/basisTranscoder/1/basis_transcoder.wasm\",\r\n};\r\n\r\n/**\r\n * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n * @param engine\r\n * @returns internal format corresponding to the Basis format\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nexport const GetInternalFormatFromBasisFormat = (basisFormat: number, engine: Engine) => {\r\n    let format;\r\n    switch (basisFormat) {\r\n        case BASIS_FORMATS.cTFETC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC1:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\r\n            break;\r\n        case BASIS_FORMATS.cTFASTC_4x4:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4;\r\n            break;\r\n        case BASIS_FORMATS.cTFETC2:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC;\r\n            break;\r\n        case BASIS_FORMATS.cTFBC7:\r\n            format = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM;\r\n            break;\r\n    }\r\n\r\n    if (format === undefined) {\r\n        throw \"The chosen Basis transcoder format is not currently supported\";\r\n    }\r\n\r\n    return format;\r\n};\r\n\r\nlet _WorkerPromise: Nullable<Promise<Worker>> = null;\r\nlet _Worker: Nullable<Worker> = null;\r\nlet _actionId = 0;\r\nconst _IgnoreSupportedFormats = false;\r\nconst _CreateWorkerAsync = () => {\r\n    if (!_WorkerPromise) {\r\n        _WorkerPromise = new Promise((res, reject) => {\r\n            if (_Worker) {\r\n                res(_Worker);\r\n            } else {\r\n                Tools.LoadFileAsync(BasisToolsOptions.WasmModuleURL)\r\n                    .then((wasmBinary) => {\r\n                        if (typeof URL !== \"function\") {\r\n                            return reject(\"Basis transcoder requires an environment with a URL constructor\");\r\n                        }\r\n                        const workerBlobUrl = URL.createObjectURL(new Blob([`(${workerFunc})()`], { type: \"application/javascript\" }));\r\n                        _Worker = new Worker(workerBlobUrl);\r\n\r\n                        const initHandler = (msg: any) => {\r\n                            if (msg.data.action === \"init\") {\r\n                                _Worker!.removeEventListener(\"message\", initHandler);\r\n                                res(_Worker!);\r\n                            } else if (msg.data.action === \"error\") {\r\n                                reject(msg.data.error || \"error initializing worker\");\r\n                            }\r\n                        };\r\n                        _Worker.addEventListener(\"message\", initHandler);\r\n                        _Worker.postMessage({ action: \"init\", url: BasisToolsOptions.JSModuleURL, wasmBinary: wasmBinary });\r\n                    })\r\n                    .catch(reject);\r\n            }\r\n        });\r\n    }\r\n    return _WorkerPromise;\r\n};\r\n\r\n/**\r\n * Transcodes a loaded image file to compressed pixel data\r\n * @param data image data to transcode\r\n * @param config configuration options for the transcoding\r\n * @returns a promise resulting in the transcoded image\r\n */\r\nexport const TranscodeAsync = (data: ArrayBuffer | ArrayBufferView, config: BasisTranscodeConfiguration): Promise<TranscodeResult> => {\r\n    const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n\r\n    return new Promise((res, rej) => {\r\n        _CreateWorkerAsync().then(\r\n            () => {\r\n                const actionId = _actionId++;\r\n                const messageHandler = (msg: any) => {\r\n                    if (msg.data.action === \"transcode\" && msg.data.id === actionId) {\r\n                        _Worker!.removeEventListener(\"message\", messageHandler);\r\n                        if (!msg.data.success) {\r\n                            rej(\"Transcode is not supported on this device\");\r\n                        } else {\r\n                            res(msg.data);\r\n                        }\r\n                    }\r\n                };\r\n                _Worker!.addEventListener(\"message\", messageHandler);\r\n\r\n                const dataViewCopy = new Uint8Array(dataView.byteLength);\r\n                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));\r\n                _Worker!.postMessage({ action: \"transcode\", id: actionId, imageData: dataViewCopy, config: config, ignoreSupportedFormats: _IgnoreSupportedFormats }, [\r\n                    dataViewCopy.buffer,\r\n                ]);\r\n            },\r\n            (error) => {\r\n                rej(error);\r\n            }\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Binds a texture according to its underlying target.\r\n * @param texture texture to bind\r\n * @param engine the engine to bind the texture in\r\n */\r\nconst BindTexture = (texture: InternalTexture, engine: Engine): void => {\r\n    let target = engine._gl?.TEXTURE_2D;\r\n    if (texture.isCube) {\r\n        target = engine._gl?.TEXTURE_CUBE_MAP;\r\n    }\r\n\r\n    engine._bindTextureDirectly(target, texture, true);\r\n};\r\n\r\n/**\r\n * Loads a texture from the transcode result\r\n * @param texture texture load to\r\n * @param transcodeResult the result of transcoding the basis file to load from\r\n */\r\nexport const LoadTextureFromTranscodeResult = (texture: InternalTexture, transcodeResult: TranscodeResult) => {\r\n    const engine = texture.getEngine() as Engine;\r\n    for (let i = 0; i < transcodeResult.fileInfo.images.length; i++) {\r\n        const rootImage = transcodeResult.fileInfo.images[i].levels[0];\r\n        texture._invertVScale = texture.invertY;\r\n        if (transcodeResult.format === -1 || transcodeResult.format === BASIS_FORMATS.cTFRGB565) {\r\n            // No compatable compressed format found, fallback to RGB\r\n            texture.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n            texture.format = Constants.TEXTUREFORMAT_RGB;\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(rootImage.width) % 1 !== 0 || Scalar.Log2(rootImage.height) % 1 !== 0)) {\r\n                // Create non power of two texture\r\n                const source = new InternalTexture(engine, InternalTextureSource.Temp);\r\n\r\n                texture._invertVScale = texture.invertY;\r\n                source.type = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;\r\n                source.format = Constants.TEXTUREFORMAT_RGB;\r\n                // Fallback requires aligned width/height\r\n                source.width = (rootImage.width + 3) & ~3;\r\n                source.height = (rootImage.height + 3) & ~3;\r\n                BindTexture(source, engine);\r\n                engine._uploadDataToTextureDirectly(source, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n\r\n                // Resize to power of two\r\n                engine._rescaleTexture(source, texture, engine.scenes[0], engine._getInternalFormat(Constants.TEXTUREFORMAT_RGB), () => {\r\n                    engine._releaseTexture(source);\r\n                    BindTexture(texture, engine);\r\n                });\r\n            } else {\r\n                // Fallback is already inverted\r\n                texture._invertVScale = !texture.invertY;\r\n\r\n                // Upload directly\r\n                texture.width = (rootImage.width + 3) & ~3;\r\n                texture.height = (rootImage.height + 3) & ~3;\r\n                texture.samplingMode = Constants.TEXTURE_LINEAR_LINEAR;\r\n                BindTexture(texture, engine);\r\n                engine._uploadDataToTextureDirectly(texture, new Uint16Array(rootImage.transcodedPixels.buffer), i, 0, Constants.TEXTUREFORMAT_RGB, true);\r\n            }\r\n        } else {\r\n            texture.width = rootImage.width;\r\n            texture.height = rootImage.height;\r\n            texture.generateMipMaps = transcodeResult.fileInfo.images[i].levels.length > 1;\r\n\r\n            const format = BasisTools.GetInternalFormatFromBasisFormat(transcodeResult.format!, engine);\r\n            texture.format = format;\r\n\r\n            BindTexture(texture, engine);\r\n\r\n            // Upload all mip levels in the file\r\n            transcodeResult.fileInfo.images[i].levels.forEach((level: any, index: number) => {\r\n                engine._uploadCompressedDataToTextureDirectly(texture, format, level.width, level.height, level.transcodedPixels, i, index);\r\n            });\r\n\r\n            if (engine._features.basisNeedsPOT && (Scalar.Log2(texture.width) % 1 !== 0 || Scalar.Log2(texture.height) % 1 !== 0)) {\r\n                Tools.Warn(\r\n                    \"Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1.\"\r\n                );\r\n                texture._cachedWrapU = Texture.CLAMP_ADDRESSMODE;\r\n                texture._cachedWrapV = Texture.CLAMP_ADDRESSMODE;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Used to load .Basis files\r\n * See https://github.com/BinomialLLC/basis_universal/tree/master/webgl\r\n */\r\nexport const BasisTools = {\r\n    /**\r\n     * URL to use when loading the basis transcoder\r\n     */\r\n    JSModuleURL: BasisToolsOptions.JSModuleURL,\r\n    /**\r\n     * URL to use when loading the wasm module for the transcoder\r\n     */\r\n    WasmModuleURL: BasisToolsOptions.WasmModuleURL,\r\n\r\n    /**\r\n     * Get the internal format to be passed to texImage2D corresponding to the .basis format value\r\n     * @param basisFormat format chosen from GetSupportedTranscodeFormat\r\n     * @returns internal format corresponding to the Basis format\r\n     */\r\n    GetInternalFormatFromBasisFormat,\r\n\r\n    /**\r\n     * Transcodes a loaded image file to compressed pixel data\r\n     * @param data image data to transcode\r\n     * @param config configuration options for the transcoding\r\n     * @returns a promise resulting in the transcoded image\r\n     */\r\n    TranscodeAsync,\r\n\r\n    /**\r\n     * Loads a texture from the transcode result\r\n     * @param texture texture load to\r\n     * @param transcodeResult the result of transcoding the basis file to load from\r\n     */\r\n    LoadTextureFromTranscodeResult,\r\n};\r\n\r\n// WorkerGlobalScope\r\ndeclare function importScripts(...urls: string[]): void;\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\ndeclare let BASIS: any;\r\nfunction workerFunc(): void {\r\n    const _BASIS_FORMAT = {\r\n        cTFETC1: 0,\r\n        cTFETC2: 1,\r\n        cTFBC1: 2,\r\n        cTFBC3: 3,\r\n        cTFBC4: 4,\r\n        cTFBC5: 5,\r\n        cTFBC7: 6,\r\n        cTFPVRTC1_4_RGB: 8,\r\n        cTFPVRTC1_4_RGBA: 9,\r\n        cTFASTC_4x4: 10,\r\n        cTFATC_RGB: 11,\r\n        cTFATC_RGBA_INTERPOLATED_ALPHA: 12,\r\n        cTFRGBA32: 13,\r\n        cTFRGB565: 14,\r\n        cTFBGR565: 15,\r\n        cTFRGBA4444: 16,\r\n        cTFFXT1_RGB: 17,\r\n        cTFPVRTC2_4_RGB: 18,\r\n        cTFPVRTC2_4_RGBA: 19,\r\n        cTFETC2_EAC_R11: 20,\r\n        cTFETC2_EAC_RG11: 21,\r\n    };\r\n    let transcoderModulePromise: Nullable<PromiseLike<any>> = null;\r\n    onmessage = (event) => {\r\n        if (event.data.action === \"init\") {\r\n            // Load the transcoder if it hasn't been yet\r\n            if (!transcoderModulePromise) {\r\n                // make sure we loaded the script correctly\r\n                try {\r\n                    importScripts(event.data.url);\r\n                } catch (e) {\r\n                    postMessage({ action: \"error\", error: e });\r\n                }\r\n                transcoderModulePromise = BASIS({\r\n                    // Override wasm binary\r\n                    wasmBinary: event.data.wasmBinary,\r\n                });\r\n            }\r\n            if (transcoderModulePromise !== null) {\r\n                transcoderModulePromise.then((m) => {\r\n                    BASIS = m;\r\n                    m.initializeBasis();\r\n                    postMessage({ action: \"init\" });\r\n                });\r\n            }\r\n        } else if (event.data.action === \"transcode\") {\r\n            // Transcode the basis image and return the resulting pixels\r\n            const config: BasisTranscodeConfiguration = event.data.config;\r\n            const imgData = event.data.imageData;\r\n            const loadedFile = new BASIS.BasisFile(imgData);\r\n            const fileInfo = GetFileInfo(loadedFile);\r\n            let format = event.data.ignoreSupportedFormats ? null : GetSupportedTranscodeFormat(event.data.config, fileInfo);\r\n\r\n            let needsConversion = false;\r\n            if (format === null) {\r\n                needsConversion = true;\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            }\r\n\r\n            // Begin transcode\r\n            let success = true;\r\n            if (!loadedFile.startTranscoding()) {\r\n                success = false;\r\n            }\r\n\r\n            const buffers: Array<any> = [];\r\n            for (let imageIndex = 0; imageIndex < fileInfo.images.length; imageIndex++) {\r\n                if (!success) {\r\n                    break;\r\n                }\r\n                const image = fileInfo.images[imageIndex];\r\n                if (config.loadSingleImage === undefined || config.loadSingleImage === imageIndex) {\r\n                    let mipCount = image.levels.length;\r\n                    if (config.loadMipmapLevels === false) {\r\n                        mipCount = 1;\r\n                    }\r\n                    for (let levelIndex = 0; levelIndex < mipCount; levelIndex++) {\r\n                        const levelInfo = image.levels[levelIndex];\r\n\r\n                        const pixels = TranscodeLevel(loadedFile, imageIndex, levelIndex, format!, needsConversion);\r\n                        if (!pixels) {\r\n                            success = false;\r\n                            break;\r\n                        }\r\n                        levelInfo.transcodedPixels = pixels;\r\n                        buffers.push(levelInfo.transcodedPixels.buffer);\r\n                    }\r\n                }\r\n            }\r\n            // Close file\r\n            loadedFile.close();\r\n            loadedFile.delete();\r\n\r\n            if (needsConversion) {\r\n                format = -1;\r\n            }\r\n            if (!success) {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id });\r\n            } else {\r\n                postMessage({ action: \"transcode\", success: success, id: event.data.id, fileInfo: fileInfo, format: format }, buffers);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Detects the supported transcode format for the file\r\n     * @param config transcode config\r\n     * @param fileInfo info about the file\r\n     * @returns the chosed format or null if none are supported\r\n     */\r\n    function GetSupportedTranscodeFormat(config: BasisTranscodeConfiguration, fileInfo: BasisFileInfo): Nullable<number> {\r\n        let format = null;\r\n        if (config.supportedCompressionFormats) {\r\n            if (config.supportedCompressionFormats.astc) {\r\n                format = _BASIS_FORMAT.cTFASTC_4x4;\r\n            } else if (config.supportedCompressionFormats.bc7) {\r\n                format = _BASIS_FORMAT.cTFBC7;\r\n            } else if (config.supportedCompressionFormats.s3tc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFBC3 : _BASIS_FORMAT.cTFBC1;\r\n            } else if (config.supportedCompressionFormats.pvrtc) {\r\n                format = fileInfo.hasAlpha ? _BASIS_FORMAT.cTFPVRTC1_4_RGBA : _BASIS_FORMAT.cTFPVRTC1_4_RGB;\r\n            } else if (config.supportedCompressionFormats.etc2) {\r\n                format = _BASIS_FORMAT.cTFETC2;\r\n            } else if (config.supportedCompressionFormats.etc1) {\r\n                format = _BASIS_FORMAT.cTFETC1;\r\n            } else {\r\n                format = _BASIS_FORMAT.cTFRGB565;\r\n            }\r\n        }\r\n        return format;\r\n    }\r\n\r\n    /**\r\n     * Retrieves information about the basis file eg. dimensions\r\n     * @param basisFile the basis file to get the info from\r\n     * @returns information about the basis file\r\n     */\r\n    function GetFileInfo(basisFile: any): BasisFileInfo {\r\n        const hasAlpha = basisFile.getHasAlpha();\r\n        const imageCount = basisFile.getNumImages();\r\n        const images = [];\r\n        for (let i = 0; i < imageCount; i++) {\r\n            const imageInfo = {\r\n                levels: [] as Array<any>,\r\n            };\r\n            const levelCount = basisFile.getNumLevels(i);\r\n            for (let level = 0; level < levelCount; level++) {\r\n                const levelInfo = {\r\n                    width: basisFile.getImageWidth(i, level),\r\n                    height: basisFile.getImageHeight(i, level),\r\n                };\r\n                imageInfo.levels.push(levelInfo);\r\n            }\r\n            images.push(imageInfo);\r\n        }\r\n        const info = { hasAlpha, images };\r\n        return info;\r\n    }\r\n\r\n    function TranscodeLevel(loadedFile: any, imageIndex: number, levelIndex: number, format: number, convertToRgb565: boolean): Nullable<Uint8Array | Uint16Array> {\r\n        const dstSize = loadedFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, format);\r\n        let dst: Uint8Array | Uint16Array = new Uint8Array(dstSize);\r\n        if (!loadedFile.transcodeImage(dst, imageIndex, levelIndex, format, 1, 0)) {\r\n            return null;\r\n        }\r\n        // If no supported format is found, load as dxt and convert to rgb565\r\n        if (convertToRgb565) {\r\n            const alignedWidth = (loadedFile.getImageWidth(imageIndex, levelIndex) + 3) & ~3;\r\n            const alignedHeight = (loadedFile.getImageHeight(imageIndex, levelIndex) + 3) & ~3;\r\n            dst = ConvertDxtToRgb565(dst, 0, alignedWidth, alignedHeight);\r\n        }\r\n        return dst;\r\n    }\r\n\r\n    /**\r\n     * From https://github.com/BinomialLLC/basis_universal/blob/master/webgl/texture/dxt-to-rgb565.js\r\n     * An unoptimized version of dxtToRgb565.  Also, the floating\r\n     * point math used to compute the colors actually results in\r\n     * slightly different colors compared to hardware DXT decoders.\r\n     * @param src dxt src pixels\r\n     * @param srcByteOffset offset for the start of src\r\n     * @param  width aligned width of the image\r\n     * @param  height aligned height of the image\r\n     * @returns the converted pixels\r\n     */\r\n    function ConvertDxtToRgb565(src: Uint8Array, srcByteOffset: number, width: number, height: number): Uint16Array {\r\n        const c = new Uint16Array(4);\r\n        const dst = new Uint16Array(width * height);\r\n\r\n        const blockWidth = width / 4;\r\n        const blockHeight = height / 4;\r\n        for (let blockY = 0; blockY < blockHeight; blockY++) {\r\n            for (let blockX = 0; blockX < blockWidth; blockX++) {\r\n                const i = srcByteOffset + 8 * (blockY * blockWidth + blockX);\r\n                c[0] = src[i] | (src[i + 1] << 8);\r\n                c[1] = src[i + 2] | (src[i + 3] << 8);\r\n                c[2] =\r\n                    ((2 * (c[0] & 0x1f) + 1 * (c[1] & 0x1f)) / 3) |\r\n                    (((2 * (c[0] & 0x7e0) + 1 * (c[1] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[0] & 0xf800) + 1 * (c[1] & 0xf800)) / 3) & 0xf800);\r\n                c[3] =\r\n                    ((2 * (c[1] & 0x1f) + 1 * (c[0] & 0x1f)) / 3) |\r\n                    (((2 * (c[1] & 0x7e0) + 1 * (c[0] & 0x7e0)) / 3) & 0x7e0) |\r\n                    (((2 * (c[1] & 0xf800) + 1 * (c[0] & 0xf800)) / 3) & 0xf800);\r\n                for (let row = 0; row < 4; row++) {\r\n                    const m = src[i + 4 + row];\r\n                    let dstI = (blockY * 4 + row) * width + blockX * 4;\r\n                    dst[dstI++] = c[m & 0x3];\r\n                    dst[dstI++] = c[(m >> 2) & 0x3];\r\n                    dst[dstI++] = c[(m >> 4) & 0x3];\r\n                    dst[dstI++] = c[(m >> 6) & 0x3];\r\n                }\r\n            }\r\n        }\r\n        return dst;\r\n    }\r\n}\r\n\r\nObject.defineProperty(BasisTools, \"JSModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.JSModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.JSModuleURL = value;\r\n    },\r\n});\r\n\r\nObject.defineProperty(BasisTools, \"WasmModuleURL\", {\r\n    get: function (this: null) {\r\n        return BasisToolsOptions.WasmModuleURL;\r\n    },\r\n    set: function (this: null, value: string) {\r\n        BasisToolsOptions.WasmModuleURL = value;\r\n    },\r\n});\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}