{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector.js\";\nimport { Scalar } from \"../../../Maths/math.scalar.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { PostProcess } from \"../../../PostProcesses/postProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess.js\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess.js\";\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\nimport \"../../../Shaders/standard.fragment.js\";\n/**\n * Standard rendering pipeline\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/standardRenderingPipeline\n */\nexport class StandardRenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\n   * @constructor\n   * @param name The rendering pipeline name\n   * @param scene The scene linked to this pipeline\n   * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\n   * @param cameras The array of cameras that the rendering pipeline will be attached to\n   */\n  constructor(name, scene, ratio, originalPostProcess = null, cameras) {\n    super(scene.getEngine(), name);\n    /**\n     * Post-process used to down scale an image x4\n     */\n    this.downSampleX4PostProcess = null;\n    /**\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\n     */\n    this.brightPassPostProcess = null;\n    /**\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\n     */\n    this.blurHPostProcesses = [];\n    /**\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\n     */\n    this.blurVPostProcesses = [];\n    /**\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\n     */\n    this.textureAdderPostProcess = null;\n    /**\n     * Post-process used to create volumetric lighting effect\n     */\n    this.volumetricLightPostProcess = null;\n    /**\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\n     */\n    this.volumetricLightSmoothXPostProcess = null;\n    /**\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\n     */\n    this.volumetricLightSmoothYPostProcess = null;\n    /**\n     * Post-process used to merge the volumetric light effect and the real scene color\n     */\n    this.volumetricLightMergePostProces = null;\n    /**\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\n     */\n    this.volumetricLightFinalPostProcess = null;\n    /**\n     * Base post-process used to calculate the average luminance of the final image for HDR\n     */\n    this.luminancePostProcess = null;\n    /**\n     * Post-processes used to create down sample post-processes in order to get\n     * the average luminance of the final image for HDR\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\n     */\n    this.luminanceDownSamplePostProcesses = [];\n    /**\n     * Post-process used to create a HDR effect (light adaptation)\n     */\n    this.hdrPostProcess = null;\n    /**\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\n     */\n    this.textureAdderFinalPostProcess = null;\n    /**\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\n     */\n    this.lensFlareFinalPostProcess = null;\n    /**\n     * Post-process used to merge the final HDR post-process and the real scene color\n     */\n    this.hdrFinalPostProcess = null;\n    /**\n     * Post-process used to create a lens flare effect\n     */\n    this.lensFlarePostProcess = null;\n    /**\n     * Post-process that merges the result of the lens flare post-process and the real scene color\n     */\n    this.lensFlareComposePostProcess = null;\n    /**\n     * Post-process used to create a motion blur effect\n     */\n    this.motionBlurPostProcess = null;\n    /**\n     * Post-process used to create a depth of field effect\n     */\n    this.depthOfFieldPostProcess = null;\n    /**\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\n     */\n    this.fxaaPostProcess = null;\n    /**\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\n     */\n    this.screenSpaceReflectionPostProcess = null;\n    // Values\n    /**\n     * Represents the brightness threshold in order to configure the illuminated surfaces\n     */\n    this.brightThreshold = 1.0;\n    /**\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\n     */\n    this.blurWidth = 512.0;\n    /**\n     * Sets if the blur for highlighted surfaces must be only horizontal\n     */\n    this.horizontalBlur = false;\n    /**\n     * Texture used typically to simulate \"dirty\" on camera lens\n     */\n    this.lensTexture = null;\n    /**\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\n     */\n    this.volumetricLightCoefficient = 0.2;\n    /**\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\n     */\n    this.volumetricLightPower = 4.0;\n    /**\n     * Used the set the blur intensity to smooth the volumetric lights\n     */\n    this.volumetricLightBlurScale = 64.0;\n    /**\n     * Light (spot or directional) used to generate the volumetric lights rays\n     * The source light must have a shadow generate so the pipeline can get its\n     * depth map\n     */\n    this.sourceLight = null;\n    /**\n     * For eye adaptation, represents the minimum luminance the eye can see\n     */\n    this.hdrMinimumLuminance = 1.0;\n    /**\n     * For eye adaptation, represents the decrease luminance speed\n     */\n    this.hdrDecreaseRate = 0.5;\n    /**\n     * For eye adaptation, represents the increase luminance speed\n     */\n    this.hdrIncreaseRate = 0.5;\n    /**\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\n     */\n    this.lensColorTexture = null;\n    /**\n     * The overall strength for the lens flare effect\n     */\n    this.lensFlareStrength = 20.0;\n    /**\n     * Dispersion coefficient for lens flare ghosts\n     */\n    this.lensFlareGhostDispersal = 1.4;\n    /**\n     * Main lens flare halo width\n     */\n    this.lensFlareHaloWidth = 0.7;\n    /**\n     * Based on the lens distortion effect, defines how much the lens flare result\n     * is distorted\n     */\n    this.lensFlareDistortionStrength = 16.0;\n    /**\n     * Configures the blur intensity used for for lens flare (halo)\n     */\n    this.lensFlareBlurWidth = 512.0;\n    /**\n     * Lens star texture must be used to simulate rays on the flares and is available\n     * in the documentation\n     */\n    this.lensStarTexture = null;\n    /**\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\n     * flare effect by taking account of the dirt texture\n     */\n    this.lensFlareDirtTexture = null;\n    /**\n     * Represents the focal length for the depth of field effect\n     */\n    this.depthOfFieldDistance = 10.0;\n    /**\n     * Represents the blur intensity for the blurred part of the depth of field effect\n     */\n    this.depthOfFieldBlurWidth = 64.0;\n    /**\n     * List of animations for the pipeline (IAnimatable implementation)\n     */\n    this.animations = [];\n    this._currentDepthOfFieldSource = null;\n    this._fixedExposure = 1.0;\n    this._currentExposure = 1.0;\n    this._hdrAutoExposure = false;\n    this._hdrCurrentLuminance = 1.0;\n    this._motionStrength = 1.0;\n    this._isObjectBasedMotionBlur = false;\n    this._camerasToBeAttached = [];\n    // Getters and setters\n    this._bloomEnabled = false;\n    this._depthOfFieldEnabled = false;\n    this._vlsEnabled = false;\n    this._lensFlareEnabled = false;\n    this._hdrEnabled = false;\n    this._motionBlurEnabled = false;\n    this._fxaaEnabled = false;\n    this._screenSpaceReflectionsEnabled = false;\n    this._motionBlurSamples = 64.0;\n    this._volumetricLightStepsCount = 50.0;\n    this._samples = 1;\n    this._cameras = cameras || scene.cameras;\n    this._cameras = this._cameras.slice();\n    this._camerasToBeAttached = this._cameras.slice();\n    // Initialize\n    this._scene = scene;\n    this._basePostProcess = originalPostProcess;\n    this._ratio = ratio;\n    // Misc\n    this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? 1 : 2;\n    // Finish\n    scene.postProcessRenderPipelineManager.addPipeline(this);\n    this._buildPipeline();\n  }\n  /**\n   * Gets the overall exposure used by the pipeline\n   */\n  get exposure() {\n    return this._fixedExposure;\n  }\n  /**\n   * Sets the overall exposure used by the pipeline\n   */\n  set exposure(value) {\n    this._fixedExposure = value;\n    this._currentExposure = value;\n  }\n  /**\n   * Gets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\n   */\n  get hdrAutoExposure() {\n    return this._hdrAutoExposure;\n  }\n  /**\n   * Sets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\n   */\n  set hdrAutoExposure(value) {\n    this._hdrAutoExposure = value;\n    if (this.hdrPostProcess) {\n      const defines = [\"#define HDR\"];\n      if (value) {\n        defines.push(\"#define AUTO_EXPOSURE\");\n      }\n      this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\n    }\n  }\n  /**\n   * Gets how much the image is blurred by the movement while using the motion blur post-process\n   */\n  get motionStrength() {\n    return this._motionStrength;\n  }\n  /**\n   * Sets how much the image is blurred by the movement while using the motion blur post-process\n   */\n  set motionStrength(strength) {\n    this._motionStrength = strength;\n    if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\n      this.motionBlurPostProcess.motionStrength = strength;\n    }\n  }\n  /**\n   * Gets whether or not the motion blur post-process is object based or screen based.\n   */\n  get objectBasedMotionBlur() {\n    return this._isObjectBasedMotionBlur;\n  }\n  /**\n   * Sets whether or not the motion blur post-process should be object based or screen based\n   */\n  set objectBasedMotionBlur(value) {\n    const shouldRebuild = this._isObjectBasedMotionBlur !== value;\n    this._isObjectBasedMotionBlur = value;\n    if (shouldRebuild) {\n      this._buildPipeline();\n    }\n  }\n  /**\n   * @ignore\n   * Specifies if the bloom pipeline is enabled\n   */\n  get BloomEnabled() {\n    return this._bloomEnabled;\n  }\n  set BloomEnabled(enabled) {\n    if (this._bloomEnabled === enabled) {\n      return;\n    }\n    this._bloomEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the depth of field pipeline is enabled\n   */\n  get DepthOfFieldEnabled() {\n    return this._depthOfFieldEnabled;\n  }\n  set DepthOfFieldEnabled(enabled) {\n    if (this._depthOfFieldEnabled === enabled) {\n      return;\n    }\n    this._depthOfFieldEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the lens flare pipeline is enabled\n   */\n  get LensFlareEnabled() {\n    return this._lensFlareEnabled;\n  }\n  set LensFlareEnabled(enabled) {\n    if (this._lensFlareEnabled === enabled) {\n      return;\n    }\n    this._lensFlareEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the HDR pipeline is enabled\n   */\n  get HDREnabled() {\n    return this._hdrEnabled;\n  }\n  set HDREnabled(enabled) {\n    if (this._hdrEnabled === enabled) {\n      return;\n    }\n    this._hdrEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the volumetric lights scattering effect is enabled\n   */\n  get VLSEnabled() {\n    return this._vlsEnabled;\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  set VLSEnabled(enabled) {\n    if (this._vlsEnabled === enabled) {\n      return;\n    }\n    if (enabled) {\n      const geometry = this._scene.enableGeometryBufferRenderer();\n      if (!geometry) {\n        Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\n        return;\n      }\n    }\n    this._vlsEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * @ignore\n   * Specifies if the motion blur effect is enabled\n   */\n  get MotionBlurEnabled() {\n    return this._motionBlurEnabled;\n  }\n  set MotionBlurEnabled(enabled) {\n    if (this._motionBlurEnabled === enabled) {\n      return;\n    }\n    this._motionBlurEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Specifies if anti-aliasing is enabled\n   */\n  get fxaaEnabled() {\n    return this._fxaaEnabled;\n  }\n  set fxaaEnabled(enabled) {\n    if (this._fxaaEnabled === enabled) {\n      return;\n    }\n    this._fxaaEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Specifies if screen space reflections are enabled.\n   */\n  get screenSpaceReflectionsEnabled() {\n    return this._screenSpaceReflectionsEnabled;\n  }\n  set screenSpaceReflectionsEnabled(enabled) {\n    if (this._screenSpaceReflectionsEnabled === enabled) {\n      return;\n    }\n    this._screenSpaceReflectionsEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Specifies the number of steps used to calculate the volumetric lights\n   * Typically in interval [50, 200]\n   */\n  get volumetricLightStepsCount() {\n    return this._volumetricLightStepsCount;\n  }\n  set volumetricLightStepsCount(count) {\n    if (this.volumetricLightPostProcess) {\n      this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\n    }\n    this._volumetricLightStepsCount = count;\n  }\n  /**\n   * Specifies the number of samples used for the motion blur effect\n   * Typically in interval [16, 64]\n   */\n  get motionBlurSamples() {\n    return this._motionBlurSamples;\n  }\n  set motionBlurSamples(samples) {\n    if (this.motionBlurPostProcess) {\n      if (this._isObjectBasedMotionBlur) {\n        this.motionBlurPostProcess.motionBlurSamples = samples;\n      } else {\n        this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\n      }\n    }\n    this._motionBlurSamples = samples;\n  }\n  /**\n   * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n   */\n  get samples() {\n    return this._samples;\n  }\n  set samples(sampleCount) {\n    if (this._samples === sampleCount) {\n      return;\n    }\n    this._samples = sampleCount;\n    this._buildPipeline();\n  }\n  _buildPipeline() {\n    const ratio = this._ratio;\n    const scene = this._scene;\n    this._disposePostProcesses();\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n      // get back cameras to be used to reattach pipeline\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n    this._reset();\n    // Create pass post-process\n    if (this._screenSpaceReflectionsEnabled) {\n      this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\"HDRPass\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n      this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {\n        this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;\n      });\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", () => this.screenSpaceReflectionPostProcess, true));\n    }\n    if (!this._basePostProcess) {\n      this.originalPostProcess = new PostProcess(\"HDRPass\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", this._floatTextureType);\n    } else {\n      this.originalPostProcess = this._basePostProcess;\n    }\n    this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\n    this.originalPostProcess.onApplyObservable.add(() => {\n      this._currentDepthOfFieldSource = this.originalPostProcess;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", () => this.originalPostProcess, true));\n    if (this._bloomEnabled) {\n      // Create down sample X4 post-process\n      this._createDownSampleX4PostProcess(scene, ratio / 4);\n      // Create bright pass post-process\n      this._createBrightPassPostProcess(scene, ratio / 4);\n      // Create gaussian blur post-processes (down sampling blurs)\n      this._createBlurPostProcesses(scene, ratio / 4, 1);\n      // Create texture adder post-process\n      this._createTextureAdderPostProcess(scene, ratio);\n      // Create depth-of-field source post-process\n      this.textureAdderFinalPostProcess = new PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBaseDepthOfFieldSource\", () => {\n        return this.textureAdderFinalPostProcess;\n      }, true));\n    }\n    if (this._vlsEnabled) {\n      // Create volumetric light\n      this._createVolumetricLightPostProcess(scene, ratio);\n      // Create volumetric light final post-process\n      this.volumetricLightFinalPostProcess = new PostProcess(\"HDRVLSFinal\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSFinal\", () => {\n        return this.volumetricLightFinalPostProcess;\n      }, true));\n    }\n    if (this._lensFlareEnabled) {\n      // Create lens flare post-process\n      this._createLensFlarePostProcess(scene, ratio);\n      // Create depth-of-field source post-process post lens-flare and disable it now\n      this.lensFlareFinalPostProcess = new PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", () => {\n        return this.lensFlareFinalPostProcess;\n      }, true));\n    }\n    if (this._hdrEnabled) {\n      // Create luminance\n      this._createLuminancePostProcesses(scene, this._floatTextureType);\n      // Create HDR\n      this._createHdrPostProcess(scene, ratio);\n      // Create depth-of-field source post-process post hdr and disable it now\n      this.hdrFinalPostProcess = new PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPostHDReDepthOfFieldSource\", () => {\n        return this.hdrFinalPostProcess;\n      }, true));\n    }\n    if (this._depthOfFieldEnabled) {\n      // Create gaussian blur used by depth-of-field\n      this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\n      // Create depth-of-field post-process\n      this._createDepthOfFieldPostProcess(scene, ratio);\n    }\n    if (this._motionBlurEnabled) {\n      // Create motion blur post-process\n      this._createMotionBlurPostProcess(scene, ratio);\n    }\n    if (this._fxaaEnabled) {\n      // Create fxaa post-process\n      this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRFxaa\", () => {\n        return this.fxaaPostProcess;\n      }, true));\n    }\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n    if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n  }\n  // Down Sample X4 Post-Process\n  _createDownSampleX4PostProcess(scene, ratio) {\n    const downSampleX4Offsets = new Array(32);\n    this.downSampleX4PostProcess = new PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DOWN_SAMPLE_X4\", this._floatTextureType);\n    this.downSampleX4PostProcess.onApply = effect => {\n      let id = 0;\n      const width = this.downSampleX4PostProcess.width;\n      const height = this.downSampleX4PostProcess.height;\n      for (let i = -2; i < 2; i++) {\n        for (let j = -2; j < 2; j++) {\n          downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\n          downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\n          id += 2;\n        }\n      }\n      effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDownSampleX4\", () => {\n      return this.downSampleX4PostProcess;\n    }, true));\n  }\n  // Brightpass Post-Process\n  _createBrightPassPostProcess(scene, ratio) {\n    const brightOffsets = new Array(8);\n    this.brightPassPostProcess = new PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define BRIGHT_PASS\", this._floatTextureType);\n    this.brightPassPostProcess.onApply = effect => {\n      const sU = 1.0 / this.brightPassPostProcess.width;\n      const sV = 1.0 / this.brightPassPostProcess.height;\n      brightOffsets[0] = -0.5 * sU;\n      brightOffsets[1] = 0.5 * sV;\n      brightOffsets[2] = 0.5 * sU;\n      brightOffsets[3] = 0.5 * sV;\n      brightOffsets[4] = -0.5 * sU;\n      brightOffsets[5] = -0.5 * sV;\n      brightOffsets[6] = 0.5 * sU;\n      brightOffsets[7] = -0.5 * sV;\n      effect.setArray2(\"dsOffsets\", brightOffsets);\n      effect.setFloat(\"brightThreshold\", this.brightThreshold);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBrightPass\", () => {\n      return this.brightPassPostProcess;\n    }, true));\n  }\n  // Create blur H&V post-processes\n  _createBlurPostProcesses(scene, ratio, indice, blurWidthKey = \"blurWidth\") {\n    const engine = scene.getEngine();\n    const blurX = new BlurPostProcess(\"HDRBlurH\" + \"_\" + indice, new Vector2(1, 0), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    const blurY = new BlurPostProcess(\"HDRBlurV\" + \"_\" + indice, new Vector2(0, 1), this[blurWidthKey], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, this._floatTextureType);\n    blurX.onActivateObservable.add(() => {\n      const dw = blurX.width / engine.getRenderWidth();\n      blurX.kernel = this[blurWidthKey] * dw;\n    });\n    blurY.onActivateObservable.add(() => {\n      const dw = blurY.height / engine.getRenderHeight();\n      blurY.kernel = this.horizontalBlur ? 64 * dw : this[blurWidthKey] * dw;\n    });\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurH\" + indice, () => {\n      return blurX;\n    }, true));\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRBlurV\" + indice, () => {\n      return blurY;\n    }, true));\n    this.blurHPostProcesses.push(blurX);\n    this.blurVPostProcesses.push(blurY);\n  }\n  // Create texture adder post-process\n  _createTextureAdderPostProcess(scene, ratio) {\n    this.textureAdderPostProcess = new PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define TEXTURE_ADDER\", this._floatTextureType);\n    this.textureAdderPostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"otherSampler\", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);\n      effect.setTexture(\"lensSampler\", this.lensTexture);\n      effect.setFloat(\"exposure\", this._currentExposure);\n      this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRTextureAdder\", () => {\n      return this.textureAdderPostProcess;\n    }, true));\n  }\n  _createVolumetricLightPostProcess(scene, ratio) {\n    const geometryRenderer = scene.enableGeometryBufferRenderer();\n    geometryRenderer.enablePosition = true;\n    const geometry = geometryRenderer.getGBuffer();\n    // Base post-process\n    this.volumetricLightPostProcess = new PostProcess(\"HDRVLS\", \"standard\", [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"], [\"shadowMapSampler\", \"positionSampler\"], ratio / 8, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\n    const depthValues = Vector2.Zero();\n    this.volumetricLightPostProcess.onApply = effect => {\n      if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {\n        const generator = this.sourceLight.getShadowGenerator();\n        effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\n        effect.setTexture(\"positionSampler\", geometry.textures[2]);\n        effect.setColor3(\"sunColor\", this.sourceLight.diffuse);\n        effect.setVector3(\"sunDirection\", this.sourceLight.getShadowDirection());\n        effect.setVector3(\"cameraPosition\", this._scene.activeCamera.globalPosition);\n        effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\n        effect.setFloat(\"scatteringCoefficient\", this.volumetricLightCoefficient);\n        effect.setFloat(\"scatteringPower\", this.volumetricLightPower);\n        depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);\n        depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);\n        effect.setVector2(\"depthValues\", depthValues);\n      }\n    };\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLS\", () => {\n      return this.volumetricLightPostProcess;\n    }, true));\n    // Smooth\n    this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\n    // Merge\n    this.volumetricLightMergePostProces = new PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLSMERGE\");\n    this.volumetricLightMergePostProces.onApply = effect => {\n      effect.setTextureFromPostProcess(\"originalSampler\", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);\n      this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;\n    };\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRVLSMerge\", () => {\n      return this.volumetricLightMergePostProces;\n    }, true));\n  }\n  // Create luminance\n  _createLuminancePostProcesses(scene, textureType) {\n    // Create luminance\n    let size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\n    this.luminancePostProcess = new PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], {\n      width: size,\n      height: size\n    }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LUMINANCE\", textureType);\n    const offsets = [];\n    this.luminancePostProcess.onApply = effect => {\n      const sU = 1.0 / this.luminancePostProcess.width;\n      const sV = 1.0 / this.luminancePostProcess.height;\n      offsets[0] = -0.5 * sU;\n      offsets[1] = 0.5 * sV;\n      offsets[2] = 0.5 * sU;\n      offsets[3] = 0.5 * sV;\n      offsets[4] = -0.5 * sU;\n      offsets[5] = -0.5 * sV;\n      offsets[6] = 0.5 * sU;\n      offsets[7] = -0.5 * sV;\n      effect.setArray2(\"lumOffsets\", offsets);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminance\", () => {\n      return this.luminancePostProcess;\n    }, true));\n    // Create down sample luminance\n    for (let i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\n      size = Math.pow(3, i);\n      let defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\n      if (i === 0) {\n        defines += \"#define FINAL_DOWN_SAMPLER\";\n      }\n      const postProcess = new PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], {\n        width: size,\n        height: size\n      }, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);\n      this.luminanceDownSamplePostProcesses.push(postProcess);\n    }\n    // Create callbacks and add effects\n    let lastLuminance = this.luminancePostProcess;\n    this.luminanceDownSamplePostProcesses.forEach((pp, index) => {\n      const downSampleOffsets = new Array(18);\n      pp.onApply = effect => {\n        if (!lastLuminance) {\n          return;\n        }\n        let id = 0;\n        for (let x = -1; x < 2; x++) {\n          for (let y = -1; y < 2; y++) {\n            downSampleOffsets[id] = x / lastLuminance.width;\n            downSampleOffsets[id + 1] = y / lastLuminance.height;\n            id += 2;\n          }\n        }\n        effect.setArray2(\"dsOffsets\", downSampleOffsets);\n        effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\n        if (index === this.luminanceDownSamplePostProcesses.length - 1) {\n          lastLuminance = this.luminancePostProcess;\n        } else {\n          lastLuminance = pp;\n        }\n      };\n      if (index === this.luminanceDownSamplePostProcesses.length - 1) {\n        pp.onAfterRender = () => {\n          const pixel = scene.getEngine().readPixels(0, 0, 1, 1);\n          const bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n          pixel.then(pixel => {\n            const data = new Uint8Array(pixel.buffer);\n            this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100.0;\n          });\n        };\n      }\n      this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLuminanceDownSample\" + index, () => {\n        return pp;\n      }, true));\n    });\n  }\n  // Create HDR post-process\n  _createHdrPostProcess(scene, ratio) {\n    const defines = [\"#define HDR\"];\n    if (this._hdrAutoExposure) {\n      defines.push(\"#define AUTO_EXPOSURE\");\n    }\n    this.hdrPostProcess = new PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines.join(\"\\n\"), 0);\n    let outputLiminance = 1;\n    let time = 0;\n    let lastTime = 0;\n    this.hdrPostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"textureAdderSampler\", this._currentDepthOfFieldSource);\n      time += scene.getEngine().getDeltaTime();\n      if (outputLiminance < 0) {\n        outputLiminance = this._hdrCurrentLuminance;\n      } else {\n        const dt = (lastTime - time) / 1000.0;\n        if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {\n          outputLiminance += this.hdrDecreaseRate * dt;\n        } else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {\n          outputLiminance -= this.hdrIncreaseRate * dt;\n        } else {\n          outputLiminance = this._hdrCurrentLuminance;\n        }\n      }\n      if (this.hdrAutoExposure) {\n        this._currentExposure = this._fixedExposure / outputLiminance;\n      } else {\n        outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);\n        effect.setFloat(\"averageLuminance\", outputLiminance);\n      }\n      lastTime = time;\n      this._currentDepthOfFieldSource = this.hdrFinalPostProcess;\n    };\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDR\", () => {\n      return this.hdrPostProcess;\n    }, true));\n  }\n  // Create lens flare post-process\n  _createLensFlarePostProcess(scene, ratio) {\n    this.lensFlarePostProcess = new PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], ratio / 2, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlare\", () => {\n      return this.lensFlarePostProcess;\n    }, true));\n    this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\n    this.lensFlareComposePostProcess = new PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE_COMPOSE\", 0);\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlareCompose\", () => {\n      return this.lensFlareComposePostProcess;\n    }, true));\n    const resolution = new Vector2(0, 0);\n    // Lens flare\n    this.lensFlarePostProcess.externalTextureSamplerBinding = true;\n    this.lensFlarePostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"textureSampler\", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);\n      effect.setTexture(\"lensColorSampler\", this.lensColorTexture);\n      effect.setFloat(\"strength\", this.lensFlareStrength);\n      effect.setFloat(\"ghostDispersal\", this.lensFlareGhostDispersal);\n      effect.setFloat(\"haloWidth\", this.lensFlareHaloWidth);\n      // Shift\n      resolution.x = this.lensFlarePostProcess.width;\n      resolution.y = this.lensFlarePostProcess.height;\n      effect.setVector2(\"resolution\", resolution);\n      effect.setFloat(\"distortionStrength\", this.lensFlareDistortionStrength);\n    };\n    // Compose\n    const scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    const scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n    this.lensFlareComposePostProcess.onApply = effect => {\n      if (!this._scene.activeCamera) {\n        return;\n      }\n      effect.setTextureFromPostProcess(\"otherSampler\", this.lensFlarePostProcess);\n      effect.setTexture(\"lensDirtSampler\", this.lensFlareDirtTexture);\n      effect.setTexture(\"lensStarSampler\", this.lensStarTexture);\n      // Lens start rotation matrix\n      const camerax = this._scene.activeCamera.getViewMatrix().getRow(0);\n      const cameraz = this._scene.activeCamera.getViewMatrix().getRow(2);\n      let camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\n      camRot *= 4.0;\n      const starRotation = Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n      const lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\n      effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\n      this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;\n    };\n  }\n  // Create depth-of-field post-process\n  _createDepthOfFieldPostProcess(scene, ratio) {\n    this.depthOfFieldPostProcess = new PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DEPTH_OF_FIELD\", 0);\n    this.depthOfFieldPostProcess.onApply = effect => {\n      effect.setTextureFromPostProcess(\"otherSampler\", this._currentDepthOfFieldSource);\n      effect.setTexture(\"depthSampler\", this._getDepthTexture());\n      effect.setFloat(\"distance\", this.depthOfFieldDistance);\n    };\n    // Add to pipeline\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRDepthOfField\", () => {\n      return this.depthOfFieldPostProcess;\n    }, true));\n  }\n  // Create motion blur post-process\n  _createMotionBlurPostProcess(scene, ratio) {\n    if (this._isObjectBasedMotionBlur) {\n      const mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, 0);\n      mb.motionStrength = this.motionStrength;\n      mb.motionBlurSamples = this.motionBlurSamples;\n      this.motionBlurPostProcess = mb;\n    } else {\n      this.motionBlurPostProcess = new PostProcess(\"HDRMotionBlur\", \"standard\", [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"], [\"depthSampler\"], ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), 0);\n      let motionScale = 0;\n      let prevViewProjection = Matrix.Identity();\n      const invViewProjection = Matrix.Identity();\n      let viewProjection = Matrix.Identity();\n      const screenSize = Vector2.Zero();\n      this.motionBlurPostProcess.onApply = effect => {\n        viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\n        viewProjection.invertToRef(invViewProjection);\n        effect.setMatrix(\"inverseViewProjection\", invViewProjection);\n        effect.setMatrix(\"prevViewProjection\", prevViewProjection);\n        prevViewProjection = viewProjection;\n        screenSize.x = this.motionBlurPostProcess.width;\n        screenSize.y = this.motionBlurPostProcess.height;\n        effect.setVector2(\"screenSize\", screenSize);\n        motionScale = scene.getEngine().getFps() / 60.0;\n        effect.setFloat(\"motionScale\", motionScale);\n        effect.setFloat(\"motionStrength\", this.motionStrength);\n        effect.setTexture(\"depthSampler\", this._getDepthTexture());\n      };\n    }\n    this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRMotionBlur\", () => {\n      return this.motionBlurPostProcess;\n    }, true));\n  }\n  _getDepthTexture() {\n    if (this._scene.getEngine().getCaps().drawBuffersExtension) {\n      const renderer = this._scene.enableGeometryBufferRenderer();\n      return renderer.getGBuffer().textures[0];\n    }\n    return this._scene.enableDepthRenderer().getDepthMap();\n  }\n  _disposePostProcesses() {\n    for (let i = 0; i < this._cameras.length; i++) {\n      const camera = this._cameras[i];\n      if (this.originalPostProcess) {\n        this.originalPostProcess.dispose(camera);\n      }\n      if (this.screenSpaceReflectionPostProcess) {\n        this.screenSpaceReflectionPostProcess.dispose(camera);\n      }\n      if (this.downSampleX4PostProcess) {\n        this.downSampleX4PostProcess.dispose(camera);\n      }\n      if (this.brightPassPostProcess) {\n        this.brightPassPostProcess.dispose(camera);\n      }\n      if (this.textureAdderPostProcess) {\n        this.textureAdderPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightPostProcess) {\n        this.volumetricLightPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightSmoothXPostProcess) {\n        this.volumetricLightSmoothXPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightSmoothYPostProcess) {\n        this.volumetricLightSmoothYPostProcess.dispose(camera);\n      }\n      if (this.volumetricLightMergePostProces) {\n        this.volumetricLightMergePostProces.dispose(camera);\n      }\n      if (this.volumetricLightFinalPostProcess) {\n        this.volumetricLightFinalPostProcess.dispose(camera);\n      }\n      if (this.lensFlarePostProcess) {\n        this.lensFlarePostProcess.dispose(camera);\n      }\n      if (this.lensFlareComposePostProcess) {\n        this.lensFlareComposePostProcess.dispose(camera);\n      }\n      for (let j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\n        this.luminanceDownSamplePostProcesses[j].dispose(camera);\n      }\n      if (this.luminancePostProcess) {\n        this.luminancePostProcess.dispose(camera);\n      }\n      if (this.hdrPostProcess) {\n        this.hdrPostProcess.dispose(camera);\n      }\n      if (this.hdrFinalPostProcess) {\n        this.hdrFinalPostProcess.dispose(camera);\n      }\n      if (this.depthOfFieldPostProcess) {\n        this.depthOfFieldPostProcess.dispose(camera);\n      }\n      if (this.motionBlurPostProcess) {\n        this.motionBlurPostProcess.dispose(camera);\n      }\n      if (this.fxaaPostProcess) {\n        this.fxaaPostProcess.dispose(camera);\n      }\n      for (let j = 0; j < this.blurHPostProcesses.length; j++) {\n        this.blurHPostProcesses[j].dispose(camera);\n      }\n      for (let j = 0; j < this.blurVPostProcesses.length; j++) {\n        this.blurVPostProcesses[j].dispose(camera);\n      }\n    }\n    this.originalPostProcess = null;\n    this.downSampleX4PostProcess = null;\n    this.brightPassPostProcess = null;\n    this.textureAdderPostProcess = null;\n    this.textureAdderFinalPostProcess = null;\n    this.volumetricLightPostProcess = null;\n    this.volumetricLightSmoothXPostProcess = null;\n    this.volumetricLightSmoothYPostProcess = null;\n    this.volumetricLightMergePostProces = null;\n    this.volumetricLightFinalPostProcess = null;\n    this.lensFlarePostProcess = null;\n    this.lensFlareComposePostProcess = null;\n    this.luminancePostProcess = null;\n    this.hdrPostProcess = null;\n    this.hdrFinalPostProcess = null;\n    this.depthOfFieldPostProcess = null;\n    this.motionBlurPostProcess = null;\n    this.fxaaPostProcess = null;\n    this.screenSpaceReflectionPostProcess = null;\n    this.luminanceDownSamplePostProcesses.length = 0;\n    this.blurHPostProcesses.length = 0;\n    this.blurVPostProcesses.length = 0;\n  }\n  /**\n   * Dispose of the pipeline and stop all post processes\n   */\n  dispose() {\n    this._disposePostProcesses();\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n    super.dispose();\n  }\n  /**\n   * Serialize the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    if (this.sourceLight) {\n      serializationObject.sourceLightId = this.sourceLight.id;\n    }\n    if (this.screenSpaceReflectionPostProcess) {\n      serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\n    }\n    serializationObject.customType = \"StandardRenderingPipeline\";\n    return serializationObject;\n  }\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n  static Parse(source, scene, rootUrl) {\n    const p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\n    if (source.sourceLightId) {\n      p.sourceLight = scene.getLightById(source.sourceLightId);\n    }\n    if (source.screenSpaceReflectionPostProcess) {\n      SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);\n    }\n    return p;\n  }\n}\n/**\n * Luminance steps\n */\nStandardRenderingPipeline.LuminanceSteps = 6;\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"brightThreshold\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"blurWidth\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"horizontalBlur\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"exposure\", null);\n__decorate([serializeAsTexture(\"lensTexture\")], StandardRenderingPipeline.prototype, \"lensTexture\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightCoefficient\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightPower\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightBlurScale\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrMinimumLuminance\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrDecreaseRate\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrIncreaseRate\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"hdrAutoExposure\", null);\n__decorate([serializeAsTexture(\"lensColorTexture\")], StandardRenderingPipeline.prototype, \"lensColorTexture\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareStrength\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareGhostDispersal\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareHaloWidth\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareDistortionStrength\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"lensFlareBlurWidth\", void 0);\n__decorate([serializeAsTexture(\"lensStarTexture\")], StandardRenderingPipeline.prototype, \"lensStarTexture\", void 0);\n__decorate([serializeAsTexture(\"lensFlareDirtTexture\")], StandardRenderingPipeline.prototype, \"lensFlareDirtTexture\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldDistance\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"depthOfFieldBlurWidth\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"motionStrength\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"objectBasedMotionBlur\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"_ratio\", void 0);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"BloomEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"LensFlareEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"HDREnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"VLSEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"fxaaEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"screenSpaceReflectionsEnabled\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"motionBlurSamples\", null);\n__decorate([serialize()], StandardRenderingPipeline.prototype, \"samples\", null);\nRegisterClass(\"BABYLON.StandardRenderingPipeline\", StandardRenderingPipeline);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsTexture","SerializationHelper","Logger","Vector2","Vector3","Matrix","Vector4","Scalar","Texture","PostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","BlurPostProcess","FxaaPostProcess","RegisterClass","MotionBlurPostProcess","ScreenSpaceReflectionPostProcess","StandardRenderingPipeline","constructor","name","scene","ratio","originalPostProcess","cameras","getEngine","_cameras","slice","_camerasToBeAttached","_scene","_basePostProcess","_ratio","_floatTextureType","getCaps","textureFloatRender","postProcessRenderPipelineManager","addPipeline","_buildPipeline","exposure","_fixedExposure","value","_currentExposure","hdrAutoExposure","_hdrAutoExposure","hdrPostProcess","defines","push","updateEffect","join","motionStrength","_motionStrength","strength","_isObjectBasedMotionBlur","motionBlurPostProcess","objectBasedMotionBlur","shouldRebuild","BloomEnabled","_bloomEnabled","enabled","DepthOfFieldEnabled","_depthOfFieldEnabled","LensFlareEnabled","_lensFlareEnabled","HDREnabled","_hdrEnabled","VLSEnabled","_vlsEnabled","geometry","enableGeometryBufferRenderer","Warn","MotionBlurEnabled","_motionBlurEnabled","fxaaEnabled","_fxaaEnabled","screenSpaceReflectionsEnabled","_screenSpaceReflectionsEnabled","volumetricLightStepsCount","_volumetricLightStepsCount","count","volumetricLightPostProcess","toFixed","motionBlurSamples","_motionBlurSamples","samples","_samples","sampleCount","_disposePostProcesses","detachCamerasFromRenderPipeline","_name","_reset","screenSpaceReflectionPostProcess","BILINEAR_SAMPLINGMODE","onApplyObservable","add","_currentDepthOfFieldSource","addEffect","autoClear","_createDownSampleX4PostProcess","_createBrightPassPostProcess","_createBlurPostProcesses","_createTextureAdderPostProcess","textureAdderFinalPostProcess","_createVolumetricLightPostProcess","volumetricLightFinalPostProcess","_createLensFlarePostProcess","lensFlareFinalPostProcess","_createLuminancePostProcesses","_createHdrPostProcess","hdrFinalPostProcess","_createDepthOfFieldPostProcess","_createMotionBlurPostProcess","fxaaPostProcess","attachCamerasToRenderPipeline","_enableMSAAOnFirstPostProcess","downSampleX4Offsets","Array","downSampleX4PostProcess","onApply","effect","id","width","height","i","j","setArray2","brightOffsets","brightPassPostProcess","sU","sV","setFloat","brightThreshold","indice","blurWidthKey","engine","blurX","blurY","onActivateObservable","dw","getRenderWidth","kernel","getRenderHeight","horizontalBlur","blurHPostProcesses","blurVPostProcesses","textureAdderPostProcess","setTextureFromPostProcess","setTexture","lensTexture","geometryRenderer","enablePosition","getGBuffer","depthValues","Zero","sourceLight","getShadowGenerator","activeCamera","generator","getShadowMap","textures","setColor3","diffuse","setVector3","getShadowDirection","globalPosition","setMatrix","getTransformMatrix","volumetricLightCoefficient","volumetricLightPower","x","getDepthMinZ","y","getDepthMaxZ","setVector2","volumetricLightMergePostProces","textureType","size","Math","pow","LuminanceSteps","luminancePostProcess","offsets","postProcess","luminanceDownSamplePostProcesses","lastLuminance","forEach","pp","index","downSampleOffsets","length","onAfterRender","pixel","readPixels","bit_shift","then","data","Uint8Array","buffer","_hdrCurrentLuminance","z","w","outputLiminance","time","lastTime","getDeltaTime","dt","hdrDecreaseRate","hdrIncreaseRate","Clamp","hdrMinimumLuminance","lensFlarePostProcess","lensFlareComposePostProcess","resolution","externalTextureSamplerBinding","lensColorTexture","lensFlareStrength","lensFlareGhostDispersal","lensFlareHaloWidth","lensFlareDistortionStrength","scaleBias1","FromValues","scaleBias2","lensFlareDirtTexture","lensStarTexture","camerax","getViewMatrix","getRow","cameraz","camRot","Dot","toVector3","starRotation","cos","sin","lensStarMatrix","multiply","depthOfFieldPostProcess","_getDepthTexture","depthOfFieldDistance","mb","motionScale","prevViewProjection","Identity","invViewProjection","viewProjection","screenSize","getProjectionMatrix","invertToRef","getFps","drawBuffersExtension","renderer","enableDepthRenderer","getDepthMap","camera","dispose","volumetricLightSmoothXPostProcess","volumetricLightSmoothYPostProcess","serializationObject","Serialize","sourceLightId","customType","Parse","source","rootUrl","p","getLightById","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/PostProcesses/RenderPipeline/Pipelines/standardRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize, serializeAsTexture, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix, Vector4 } from \"../../../Maths/math.vector\";\r\nimport { Scalar } from \"../../../Maths/math.scalar\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { BlurPostProcess } from \"../../../PostProcesses/blurPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport type { SpotLight } from \"../../../Lights/spotLight\";\r\nimport type { DirectionalLight } from \"../../../Lights/directionalLight\";\r\nimport type { GeometryBufferRenderer } from \"../../../Rendering/geometryBufferRenderer\";\r\n\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { MotionBlurPostProcess } from \"../../motionBlurPostProcess\";\r\nimport { ScreenSpaceReflectionPostProcess } from \"../../screenSpaceReflectionPostProcess\";\r\n\r\ndeclare type Animation = import(\"../../../Animations/animation\").Animation;\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\nimport \"../../../Shaders/standard.fragment\";\r\n/**\r\n * Standard rendering pipeline\r\n * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/standardRenderingPipeline\r\n */\r\nexport class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    /**\r\n     * Public members\r\n     */\r\n    // Post-processes\r\n    /**\r\n     * Post-process which contains the original scene color before the pipeline applies all the effects\r\n     */\r\n    public originalPostProcess: Nullable<PostProcess>;\r\n    /**\r\n     * Post-process used to down scale an image x4\r\n     */\r\n    public downSampleX4PostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to calculate the illuminated surfaces controlled by a threshold\r\n     */\r\n    public brightPassPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process array storing all the horizontal blur post-processes used by the pipeline\r\n     */\r\n    public blurHPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process array storing all the vertical blur post-processes used by the pipeline\r\n     */\r\n    public blurVPostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to add colors of 2 textures (typically brightness + real scene color)\r\n     */\r\n    public textureAdderPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Post-process used to create volumetric lighting effect\r\n     */\r\n    public volumetricLightPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the X axis\r\n     */\r\n    public volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to smooth the previous volumetric light post-process on the Y axis\r\n     */\r\n    public volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the volumetric light effect and the real scene color\r\n     */\r\n    public volumetricLightMergePostProces: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final volumetric light post-process (attach/detach for debug purpose)\r\n     */\r\n    public volumetricLightFinalPostProcess: Nullable<PostProcess> = null;\r\n\r\n    /**\r\n     * Base post-process used to calculate the average luminance of the final image for HDR\r\n     */\r\n    public luminancePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-processes used to create down sample post-processes in order to get\r\n     * the average luminance of the final image for HDR\r\n     * Array of length \"StandardRenderingPipeline.LuminanceSteps\"\r\n     */\r\n    public luminanceDownSamplePostProcesses: PostProcess[] = [];\r\n    /**\r\n     * Post-process used to create a HDR effect (light adaptation)\r\n     */\r\n    public hdrPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final texture adder post-process (attach/detach for debug purpose)\r\n     */\r\n    public textureAdderFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to store the final lens flare post-process (attach/detach for debug purpose)\r\n     */\r\n    public lensFlareFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to merge the final HDR post-process and the real scene color\r\n     */\r\n    public hdrFinalPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a lens flare effect\r\n     */\r\n    public lensFlarePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process that merges the result of the lens flare post-process and the real scene color\r\n     */\r\n    public lensFlareComposePostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a motion blur effect\r\n     */\r\n    public motionBlurPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * Post-process used to create a depth of field effect\r\n     */\r\n    public depthOfFieldPostProcess: Nullable<PostProcess> = null;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaaPostProcess: Nullable<FxaaPostProcess> = null;\r\n    /**\r\n     * Post-process used to simulate realtime reflections using the screen space and geometry renderer.\r\n     */\r\n    public screenSpaceReflectionPostProcess: Nullable<ScreenSpaceReflectionPostProcess> = null;\r\n\r\n    // Values\r\n\r\n    /**\r\n     * Represents the brightness threshold in order to configure the illuminated surfaces\r\n     */\r\n    @serialize()\r\n    public brightThreshold: number = 1.0;\r\n\r\n    /**\r\n     * Configures the blur intensity used for surexposed surfaces are highlighted surfaces (light halo)\r\n     */\r\n    @serialize()\r\n    public blurWidth: number = 512.0;\r\n    /**\r\n     * Sets if the blur for highlighted surfaces must be only horizontal\r\n     */\r\n    @serialize()\r\n    public horizontalBlur: boolean = false;\r\n\r\n    /**\r\n     * Gets the overall exposure used by the pipeline\r\n     */\r\n    @serialize()\r\n    public get exposure(): number {\r\n        return this._fixedExposure;\r\n    }\r\n    /**\r\n     * Sets the overall exposure used by the pipeline\r\n     */\r\n    public set exposure(value: number) {\r\n        this._fixedExposure = value;\r\n        this._currentExposure = value;\r\n    }\r\n\r\n    /**\r\n     * Texture used typically to simulate \"dirty\" on camera lens\r\n     */\r\n    @serializeAsTexture(\"lensTexture\")\r\n    public lensTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the offset coefficient based on Rayleigh principle. Typically in interval [-0.2, 0.2]\r\n     */\r\n    @serialize()\r\n    public volumetricLightCoefficient: number = 0.2;\r\n    /**\r\n     * The overall power of volumetric lights, typically in interval [0, 10] maximum\r\n     */\r\n    @serialize()\r\n    public volumetricLightPower: number = 4.0;\r\n    /**\r\n     * Used the set the blur intensity to smooth the volumetric lights\r\n     */\r\n    @serialize()\r\n    public volumetricLightBlurScale: number = 64.0;\r\n    /**\r\n     * Light (spot or directional) used to generate the volumetric lights rays\r\n     * The source light must have a shadow generate so the pipeline can get its\r\n     * depth map\r\n     */\r\n    public sourceLight: Nullable<SpotLight | DirectionalLight> = null;\r\n\r\n    /**\r\n     * For eye adaptation, represents the minimum luminance the eye can see\r\n     */\r\n    @serialize()\r\n    public hdrMinimumLuminance: number = 1.0;\r\n    /**\r\n     * For eye adaptation, represents the decrease luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrDecreaseRate: number = 0.5;\r\n    /**\r\n     * For eye adaptation, represents the increase luminance speed\r\n     */\r\n    @serialize()\r\n    public hdrIncreaseRate: number = 0.5;\r\n    /**\r\n     * Gets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    @serialize()\r\n    public get hdrAutoExposure(): boolean {\r\n        return this._hdrAutoExposure;\r\n    }\r\n    /**\r\n     * Sets whether or not the exposure of the overall pipeline should be automatically adjusted by the HDR post-process\r\n     */\r\n    public set hdrAutoExposure(value: boolean) {\r\n        this._hdrAutoExposure = value;\r\n        if (this.hdrPostProcess) {\r\n            const defines = [\"#define HDR\"];\r\n            if (value) {\r\n                defines.push(\"#define AUTO_EXPOSURE\");\r\n            }\r\n            this.hdrPostProcess.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lens color texture used by the lens flare effect. Mandatory if lens flare effect enabled\r\n     */\r\n    @serializeAsTexture(\"lensColorTexture\")\r\n    public lensColorTexture: Nullable<Texture> = null;\r\n    /**\r\n     * The overall strength for the lens flare effect\r\n     */\r\n    @serialize()\r\n    public lensFlareStrength: number = 20.0;\r\n    /**\r\n     * Dispersion coefficient for lens flare ghosts\r\n     */\r\n    @serialize()\r\n    public lensFlareGhostDispersal: number = 1.4;\r\n    /**\r\n     * Main lens flare halo width\r\n     */\r\n    @serialize()\r\n    public lensFlareHaloWidth: number = 0.7;\r\n    /**\r\n     * Based on the lens distortion effect, defines how much the lens flare result\r\n     * is distorted\r\n     */\r\n    @serialize()\r\n    public lensFlareDistortionStrength: number = 16.0;\r\n    /**\r\n     * Configures the blur intensity used for for lens flare (halo)\r\n     */\r\n    @serialize()\r\n    public lensFlareBlurWidth: number = 512.0;\r\n    /**\r\n     * Lens star texture must be used to simulate rays on the flares and is available\r\n     * in the documentation\r\n     */\r\n    @serializeAsTexture(\"lensStarTexture\")\r\n    public lensStarTexture: Nullable<Texture> = null;\r\n    /**\r\n     * As the \"lensTexture\" (can be the same texture or different), it is used to apply the lens\r\n     * flare effect by taking account of the dirt texture\r\n     */\r\n    @serializeAsTexture(\"lensFlareDirtTexture\")\r\n    public lensFlareDirtTexture: Nullable<Texture> = null;\r\n\r\n    /**\r\n     * Represents the focal length for the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldDistance: number = 10.0;\r\n    /**\r\n     * Represents the blur intensity for the blurred part of the depth of field effect\r\n     */\r\n    @serialize()\r\n    public depthOfFieldBlurWidth: number = 64.0;\r\n\r\n    /**\r\n     * Gets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    @serialize()\r\n    public get motionStrength(): number {\r\n        return this._motionStrength;\r\n    }\r\n    /**\r\n     * Sets how much the image is blurred by the movement while using the motion blur post-process\r\n     */\r\n    public set motionStrength(strength: number) {\r\n        this._motionStrength = strength;\r\n\r\n        if (this._isObjectBasedMotionBlur && this.motionBlurPostProcess) {\r\n            (this.motionBlurPostProcess as MotionBlurPostProcess).motionStrength = strength;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is object based or screen based.\r\n     */\r\n    @serialize()\r\n    public get objectBasedMotionBlur(): boolean {\r\n        return this._isObjectBasedMotionBlur;\r\n    }\r\n    /**\r\n     * Sets whether or not the motion blur post-process should be object based or screen based\r\n     */\r\n    public set objectBasedMotionBlur(value: boolean) {\r\n        const shouldRebuild = this._isObjectBasedMotionBlur !== value;\r\n        this._isObjectBasedMotionBlur = value;\r\n\r\n        if (shouldRebuild) {\r\n            this._buildPipeline();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * List of animations for the pipeline (IAnimatable implementation)\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * Private members\r\n     */\r\n    private _scene: Scene;\r\n    private _currentDepthOfFieldSource: Nullable<PostProcess> = null;\r\n    private _basePostProcess: Nullable<PostProcess>;\r\n\r\n    private _fixedExposure: number = 1.0;\r\n    private _currentExposure: number = 1.0;\r\n    private _hdrAutoExposure: boolean = false;\r\n    private _hdrCurrentLuminance: number = 1.0;\r\n    private _motionStrength: number = 1.0;\r\n    private _isObjectBasedMotionBlur: boolean = false;\r\n\r\n    private _floatTextureType: number;\r\n\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n\r\n    @serialize()\r\n    private _ratio: number;\r\n\r\n    // Getters and setters\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _vlsEnabled: boolean = false;\r\n    private _lensFlareEnabled: boolean = false;\r\n    private _hdrEnabled: boolean = false;\r\n    private _motionBlurEnabled: boolean = false;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _screenSpaceReflectionsEnabled: boolean = false;\r\n\r\n    private _motionBlurSamples: number = 64.0;\r\n    private _volumetricLightStepsCount: number = 50.0;\r\n    private _samples: number = 1;\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the bloom pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get BloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    public set BloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._bloomEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the depth of field pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get DepthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set DepthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._depthOfFieldEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the lens flare pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get LensFlareEnabled(): boolean {\r\n        return this._lensFlareEnabled;\r\n    }\r\n\r\n    public set LensFlareEnabled(enabled: boolean) {\r\n        if (this._lensFlareEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._lensFlareEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the HDR pipeline is enabled\r\n     */\r\n    @serialize()\r\n    public get HDREnabled(): boolean {\r\n        return this._hdrEnabled;\r\n    }\r\n\r\n    public set HDREnabled(enabled: boolean) {\r\n        if (this._hdrEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._hdrEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the volumetric lights scattering effect is enabled\r\n     */\r\n    @serialize()\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get VLSEnabled(): boolean {\r\n        return this._vlsEnabled;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set VLSEnabled(enabled) {\r\n        if (this._vlsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        if (enabled) {\r\n            const geometry = this._scene.enableGeometryBufferRenderer();\r\n            if (!geometry) {\r\n                Logger.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._vlsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Specifies if the motion blur effect is enabled\r\n     */\r\n    @serialize()\r\n    public get MotionBlurEnabled(): boolean {\r\n        return this._motionBlurEnabled;\r\n    }\r\n\r\n    public set MotionBlurEnabled(enabled: boolean) {\r\n        if (this._motionBlurEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._motionBlurEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if anti-aliasing is enabled\r\n     */\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._fxaaEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies if screen space reflections are enabled.\r\n     */\r\n    @serialize()\r\n    public get screenSpaceReflectionsEnabled(): boolean {\r\n        return this._screenSpaceReflectionsEnabled;\r\n    }\r\n\r\n    public set screenSpaceReflectionsEnabled(enabled: boolean) {\r\n        if (this._screenSpaceReflectionsEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._screenSpaceReflectionsEnabled = enabled;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of steps used to calculate the volumetric lights\r\n     * Typically in interval [50, 200]\r\n     */\r\n    @serialize()\r\n    public get volumetricLightStepsCount(): number {\r\n        return this._volumetricLightStepsCount;\r\n    }\r\n\r\n    public set volumetricLightStepsCount(count: number) {\r\n        if (this.volumetricLightPostProcess) {\r\n            this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\r\n        }\r\n\r\n        this._volumetricLightStepsCount = count;\r\n    }\r\n\r\n    /**\r\n     * Specifies the number of samples used for the motion blur effect\r\n     * Typically in interval [16, 64]\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    public set motionBlurSamples(samples: number) {\r\n        if (this.motionBlurPostProcess) {\r\n            if (this._isObjectBasedMotionBlur) {\r\n                (this.motionBlurPostProcess as MotionBlurPostProcess).motionBlurSamples = samples;\r\n            } else {\r\n                this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\r\n            }\r\n        }\r\n\r\n        this._motionBlurSamples = samples;\r\n    }\r\n\r\n    /**\r\n     * Specifies MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n\r\n        this._samples = sampleCount;\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Default pipeline should be used going forward but the standard pipeline will be kept for backwards compatibility.\r\n     * @constructor\r\n     * @param name The rendering pipeline name\r\n     * @param scene The scene linked to this pipeline\r\n     * @param ratio The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param originalPostProcess the custom original color post-process. Must be \"reusable\". Can be null.\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to\r\n     */\r\n    constructor(name: string, scene: Scene, ratio: number, originalPostProcess: Nullable<PostProcess> = null, cameras?: Camera[]) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        this._basePostProcess = originalPostProcess;\r\n        this._ratio = ratio;\r\n\r\n        // Misc\r\n        this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n        // Finish\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    private _buildPipeline(): void {\r\n        const ratio = this._ratio;\r\n        const scene = this._scene;\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n\r\n        // Create pass post-process\r\n        if (this._screenSpaceReflectionsEnabled) {\r\n            this.screenSpaceReflectionPostProcess = new ScreenSpaceReflectionPostProcess(\r\n                \"HDRPass\",\r\n                scene,\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                this._floatTextureType\r\n            );\r\n            this.screenSpaceReflectionPostProcess.onApplyObservable.add(() => {\r\n                this._currentDepthOfFieldSource = this.screenSpaceReflectionPostProcess;\r\n            });\r\n            this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRScreenSpaceReflections\", () => this.screenSpaceReflectionPostProcess, true));\r\n        }\r\n\r\n        if (!this._basePostProcess) {\r\n            this.originalPostProcess = new PostProcess(\r\n                \"HDRPass\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                this._floatTextureType\r\n            );\r\n        } else {\r\n            this.originalPostProcess = this._basePostProcess;\r\n        }\r\n\r\n        this.originalPostProcess.autoClear = !this.screenSpaceReflectionPostProcess;\r\n        this.originalPostProcess.onApplyObservable.add(() => {\r\n            this._currentDepthOfFieldSource = this.originalPostProcess;\r\n        });\r\n\r\n        this.addEffect(new PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", () => this.originalPostProcess, true));\r\n\r\n        if (this._bloomEnabled) {\r\n            // Create down sample X4 post-process\r\n            this._createDownSampleX4PostProcess(scene, ratio / 4);\r\n\r\n            // Create bright pass post-process\r\n            this._createBrightPassPostProcess(scene, ratio / 4);\r\n\r\n            // Create gaussian blur post-processes (down sampling blurs)\r\n            this._createBlurPostProcesses(scene, ratio / 4, 1);\r\n\r\n            // Create texture adder post-process\r\n            this._createTextureAdderPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process\r\n            this.textureAdderFinalPostProcess = new PostProcess(\r\n                \"HDRDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRBaseDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.textureAdderFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._vlsEnabled) {\r\n            // Create volumetric light\r\n            this._createVolumetricLightPostProcess(scene, ratio);\r\n\r\n            // Create volumetric light final post-process\r\n            this.volumetricLightFinalPostProcess = new PostProcess(\r\n                \"HDRVLSFinal\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRVLSFinal\",\r\n                    () => {\r\n                        return this.volumetricLightFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._lensFlareEnabled) {\r\n            // Create lens flare post-process\r\n            this._createLensFlarePostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post lens-flare and disable it now\r\n            this.lensFlareFinalPostProcess = new PostProcess(\r\n                \"HDRPostLensFlareDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRPostLensFlareDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.lensFlareFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._hdrEnabled) {\r\n            // Create luminance\r\n            this._createLuminancePostProcesses(scene, this._floatTextureType);\r\n\r\n            // Create HDR\r\n            this._createHdrPostProcess(scene, ratio);\r\n\r\n            // Create depth-of-field source post-process post hdr and disable it now\r\n            this.hdrFinalPostProcess = new PostProcess(\r\n                \"HDRPostHDReDepthOfFieldSource\",\r\n                \"standard\",\r\n                [],\r\n                [],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define PASS_POST_PROCESS\",\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRPostHDReDepthOfFieldSource\",\r\n                    () => {\r\n                        return this.hdrFinalPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._depthOfFieldEnabled) {\r\n            // Create gaussian blur used by depth-of-field\r\n            this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\r\n\r\n            // Create depth-of-field post-process\r\n            this._createDepthOfFieldPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._motionBlurEnabled) {\r\n            // Create motion blur post-process\r\n            this._createMotionBlurPostProcess(scene, ratio);\r\n        }\r\n\r\n        if (this._fxaaEnabled) {\r\n            // Create fxaa post-process\r\n            this.fxaaPostProcess = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRFxaa\",\r\n                    () => {\r\n                        return this.fxaaPostProcess;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this._samples) && this._samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n    }\r\n\r\n    // Down Sample X4 Post-Process\r\n    private _createDownSampleX4PostProcess(scene: Scene, ratio: number): void {\r\n        const downSampleX4Offsets = new Array<number>(32);\r\n        this.downSampleX4PostProcess = new PostProcess(\r\n            \"HDRDownSampleX4\",\r\n            \"standard\",\r\n            [\"dsOffsets\"],\r\n            [],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define DOWN_SAMPLE_X4\",\r\n            this._floatTextureType\r\n        );\r\n\r\n        this.downSampleX4PostProcess.onApply = (effect: Effect) => {\r\n            let id = 0;\r\n            const width = (<PostProcess>this.downSampleX4PostProcess).width;\r\n            const height = (<PostProcess>this.downSampleX4PostProcess).height;\r\n\r\n            for (let i = -2; i < 2; i++) {\r\n                for (let j = -2; j < 2; j++) {\r\n                    downSampleX4Offsets[id] = (i + 0.5) * (1.0 / width);\r\n                    downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / height);\r\n                    id += 2;\r\n                }\r\n            }\r\n\r\n            effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRDownSampleX4\",\r\n                () => {\r\n                    return this.downSampleX4PostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Brightpass Post-Process\r\n    private _createBrightPassPostProcess(scene: Scene, ratio: number): void {\r\n        const brightOffsets = new Array<number>(8);\r\n        this.brightPassPostProcess = new PostProcess(\r\n            \"HDRBrightPass\",\r\n            \"standard\",\r\n            [\"dsOffsets\", \"brightThreshold\"],\r\n            [],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define BRIGHT_PASS\",\r\n            this._floatTextureType\r\n        );\r\n\r\n        this.brightPassPostProcess.onApply = (effect: Effect) => {\r\n            const sU = 1.0 / (<PostProcess>this.brightPassPostProcess).width;\r\n            const sV = 1.0 / (<PostProcess>this.brightPassPostProcess).height;\r\n\r\n            brightOffsets[0] = -0.5 * sU;\r\n            brightOffsets[1] = 0.5 * sV;\r\n            brightOffsets[2] = 0.5 * sU;\r\n            brightOffsets[3] = 0.5 * sV;\r\n            brightOffsets[4] = -0.5 * sU;\r\n            brightOffsets[5] = -0.5 * sV;\r\n            brightOffsets[6] = 0.5 * sU;\r\n            brightOffsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"dsOffsets\", brightOffsets);\r\n            effect.setFloat(\"brightThreshold\", this.brightThreshold);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBrightPass\",\r\n                () => {\r\n                    return this.brightPassPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create blur H&V post-processes\r\n    private _createBlurPostProcesses(scene: Scene, ratio: number, indice: number, blurWidthKey: string = \"blurWidth\"): void {\r\n        const engine = scene.getEngine();\r\n\r\n        const blurX = new BlurPostProcess(\r\n            \"HDRBlurH\" + \"_\" + indice,\r\n            new Vector2(1, 0),\r\n            (<any>this)[blurWidthKey],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            this._floatTextureType\r\n        );\r\n        const blurY = new BlurPostProcess(\r\n            \"HDRBlurV\" + \"_\" + indice,\r\n            new Vector2(0, 1),\r\n            (<any>this)[blurWidthKey],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            this._floatTextureType\r\n        );\r\n\r\n        blurX.onActivateObservable.add(() => {\r\n            const dw = blurX.width / engine.getRenderWidth();\r\n            blurX.kernel = (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        blurY.onActivateObservable.add(() => {\r\n            const dw = blurY.height / engine.getRenderHeight();\r\n            blurY.kernel = this.horizontalBlur ? 64 * dw : (<any>this)[blurWidthKey] * dw;\r\n        });\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBlurH\" + indice,\r\n                () => {\r\n                    return blurX;\r\n                },\r\n                true\r\n            )\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRBlurV\" + indice,\r\n                () => {\r\n                    return blurY;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        this.blurHPostProcesses.push(blurX);\r\n        this.blurVPostProcesses.push(blurY);\r\n    }\r\n\r\n    // Create texture adder post-process\r\n    private _createTextureAdderPostProcess(scene: Scene, ratio: number): void {\r\n        this.textureAdderPostProcess = new PostProcess(\r\n            \"HDRTextureAdder\",\r\n            \"standard\",\r\n            [\"exposure\"],\r\n            [\"otherSampler\", \"lensSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define TEXTURE_ADDER\",\r\n            this._floatTextureType\r\n        );\r\n        this.textureAdderPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._vlsEnabled ? this._currentDepthOfFieldSource : this.originalPostProcess);\r\n            effect.setTexture(\"lensSampler\", this.lensTexture);\r\n\r\n            effect.setFloat(\"exposure\", this._currentExposure);\r\n\r\n            this._currentDepthOfFieldSource = this.textureAdderFinalPostProcess;\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRTextureAdder\",\r\n                () => {\r\n                    return this.textureAdderPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    private _createVolumetricLightPostProcess(scene: Scene, ratio: number): void {\r\n        const geometryRenderer = <GeometryBufferRenderer>scene.enableGeometryBufferRenderer();\r\n        geometryRenderer.enablePosition = true;\r\n\r\n        const geometry = geometryRenderer.getGBuffer();\r\n\r\n        // Base post-process\r\n        this.volumetricLightPostProcess = new PostProcess(\r\n            \"HDRVLS\",\r\n            \"standard\",\r\n            [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"],\r\n            [\"shadowMapSampler\", \"positionSampler\"],\r\n            ratio / 8,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1)\r\n        );\r\n\r\n        const depthValues = Vector2.Zero();\r\n\r\n        this.volumetricLightPostProcess.onApply = (effect: Effect) => {\r\n            if (this.sourceLight && this.sourceLight.getShadowGenerator() && this._scene.activeCamera) {\r\n                const generator = this.sourceLight.getShadowGenerator()!;\r\n\r\n                effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\r\n                effect.setTexture(\"positionSampler\", geometry.textures[2]);\r\n\r\n                effect.setColor3(\"sunColor\", this.sourceLight.diffuse);\r\n                effect.setVector3(\"sunDirection\", this.sourceLight.getShadowDirection());\r\n\r\n                effect.setVector3(\"cameraPosition\", this._scene.activeCamera.globalPosition);\r\n                effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\r\n\r\n                effect.setFloat(\"scatteringCoefficient\", this.volumetricLightCoefficient);\r\n                effect.setFloat(\"scatteringPower\", this.volumetricLightPower);\r\n\r\n                depthValues.x = this.sourceLight.getDepthMinZ(this._scene.activeCamera);\r\n                depthValues.y = this.sourceLight.getDepthMaxZ(this._scene.activeCamera);\r\n                effect.setVector2(\"depthValues\", depthValues);\r\n            }\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRVLS\",\r\n                () => {\r\n                    return this.volumetricLightPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        // Smooth\r\n        this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\r\n\r\n        // Merge\r\n        this.volumetricLightMergePostProces = new PostProcess(\r\n            \"HDRVLSMerge\",\r\n            \"standard\",\r\n            [],\r\n            [\"originalSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define VLSMERGE\"\r\n        );\r\n\r\n        this.volumetricLightMergePostProces.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"originalSampler\", this._bloomEnabled ? this.textureAdderFinalPostProcess : this.originalPostProcess);\r\n\r\n            this._currentDepthOfFieldSource = this.volumetricLightFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRVLSMerge\",\r\n                () => {\r\n                    return this.volumetricLightMergePostProces;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create luminance\r\n    private _createLuminancePostProcesses(scene: Scene, textureType: number): void {\r\n        // Create luminance\r\n        let size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\r\n        this.luminancePostProcess = new PostProcess(\r\n            \"HDRLuminance\",\r\n            \"standard\",\r\n            [\"lumOffsets\"],\r\n            [],\r\n            { width: size, height: size },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LUMINANCE\",\r\n            textureType\r\n        );\r\n\r\n        const offsets: number[] = [];\r\n        this.luminancePostProcess.onApply = (effect: Effect) => {\r\n            const sU = 1.0 / (<PostProcess>this.luminancePostProcess).width;\r\n            const sV = 1.0 / (<PostProcess>this.luminancePostProcess).height;\r\n\r\n            offsets[0] = -0.5 * sU;\r\n            offsets[1] = 0.5 * sV;\r\n            offsets[2] = 0.5 * sU;\r\n            offsets[3] = 0.5 * sV;\r\n            offsets[4] = -0.5 * sU;\r\n            offsets[5] = -0.5 * sV;\r\n            offsets[6] = 0.5 * sU;\r\n            offsets[7] = -0.5 * sV;\r\n\r\n            effect.setArray2(\"lumOffsets\", offsets);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLuminance\",\r\n                () => {\r\n                    return this.luminancePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        // Create down sample luminance\r\n        for (let i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\r\n            size = Math.pow(3, i);\r\n\r\n            let defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\r\n            if (i === 0) {\r\n                defines += \"#define FINAL_DOWN_SAMPLER\";\r\n            }\r\n\r\n            const postProcess = new PostProcess(\r\n                \"HDRLuminanceDownSample\" + i,\r\n                \"standard\",\r\n                [\"dsOffsets\", \"halfDestPixelSize\"],\r\n                [],\r\n                { width: size, height: size },\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                defines,\r\n                textureType\r\n            );\r\n            this.luminanceDownSamplePostProcesses.push(postProcess);\r\n        }\r\n\r\n        // Create callbacks and add effects\r\n        let lastLuminance: Nullable<PostProcess> = this.luminancePostProcess;\r\n\r\n        this.luminanceDownSamplePostProcesses.forEach((pp, index) => {\r\n            const downSampleOffsets = new Array<number>(18);\r\n\r\n            pp.onApply = (effect: Effect) => {\r\n                if (!lastLuminance) {\r\n                    return;\r\n                }\r\n\r\n                let id = 0;\r\n                for (let x = -1; x < 2; x++) {\r\n                    for (let y = -1; y < 2; y++) {\r\n                        downSampleOffsets[id] = x / lastLuminance.width;\r\n                        downSampleOffsets[id + 1] = y / lastLuminance.height;\r\n                        id += 2;\r\n                    }\r\n                }\r\n\r\n                effect.setArray2(\"dsOffsets\", downSampleOffsets);\r\n                effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\r\n\r\n                if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                    lastLuminance = this.luminancePostProcess;\r\n                } else {\r\n                    lastLuminance = pp;\r\n                }\r\n            };\r\n\r\n            if (index === this.luminanceDownSamplePostProcesses.length - 1) {\r\n                pp.onAfterRender = () => {\r\n                    const pixel = scene.getEngine().readPixels(0, 0, 1, 1);\r\n                    const bit_shift = new Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n                    pixel.then((pixel) => {\r\n                        const data = new Uint8Array(pixel.buffer);\r\n                        this._hdrCurrentLuminance = (data[0] * bit_shift.x + data[1] * bit_shift.y + data[2] * bit_shift.z + data[3] * bit_shift.w) / 100.0;\r\n                    });\r\n                };\r\n            }\r\n\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    scene.getEngine(),\r\n                    \"HDRLuminanceDownSample\" + index,\r\n                    () => {\r\n                        return pp;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n        });\r\n    }\r\n\r\n    // Create HDR post-process\r\n    private _createHdrPostProcess(scene: Scene, ratio: number): void {\r\n        const defines = [\"#define HDR\"];\r\n        if (this._hdrAutoExposure) {\r\n            defines.push(\"#define AUTO_EXPOSURE\");\r\n        }\r\n        this.hdrPostProcess = new PostProcess(\r\n            \"HDR\",\r\n            \"standard\",\r\n            [\"averageLuminance\"],\r\n            [\"textureAdderSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            defines.join(\"\\n\"),\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n\r\n        let outputLiminance = 1;\r\n        let time = 0;\r\n        let lastTime = 0;\r\n\r\n        this.hdrPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureAdderSampler\", this._currentDepthOfFieldSource);\r\n\r\n            time += scene.getEngine().getDeltaTime();\r\n\r\n            if (outputLiminance < 0) {\r\n                outputLiminance = this._hdrCurrentLuminance;\r\n            } else {\r\n                const dt = (lastTime - time) / 1000.0;\r\n\r\n                if (this._hdrCurrentLuminance < outputLiminance + this.hdrDecreaseRate * dt) {\r\n                    outputLiminance += this.hdrDecreaseRate * dt;\r\n                } else if (this._hdrCurrentLuminance > outputLiminance - this.hdrIncreaseRate * dt) {\r\n                    outputLiminance -= this.hdrIncreaseRate * dt;\r\n                } else {\r\n                    outputLiminance = this._hdrCurrentLuminance;\r\n                }\r\n            }\r\n\r\n            if (this.hdrAutoExposure) {\r\n                this._currentExposure = this._fixedExposure / outputLiminance;\r\n            } else {\r\n                outputLiminance = Scalar.Clamp(outputLiminance, this.hdrMinimumLuminance, 1e20);\r\n                effect.setFloat(\"averageLuminance\", outputLiminance);\r\n            }\r\n\r\n            lastTime = time;\r\n\r\n            this._currentDepthOfFieldSource = this.hdrFinalPostProcess;\r\n        };\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDR\",\r\n                () => {\r\n                    return this.hdrPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create lens flare post-process\r\n    private _createLensFlarePostProcess(scene: Scene, ratio: number): void {\r\n        this.lensFlarePostProcess = new PostProcess(\r\n            \"HDRLensFlare\",\r\n            \"standard\",\r\n            [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"],\r\n            [\"lensColorSampler\"],\r\n            ratio / 2,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LENS_FLARE\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLensFlare\",\r\n                () => {\r\n                    return this.lensFlarePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        this._createBlurPostProcesses(scene, ratio / 4, 2, \"lensFlareBlurWidth\");\r\n\r\n        this.lensFlareComposePostProcess = new PostProcess(\r\n            \"HDRLensFlareCompose\",\r\n            \"standard\",\r\n            [\"lensStarMatrix\"],\r\n            [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define LENS_FLARE_COMPOSE\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRLensFlareCompose\",\r\n                () => {\r\n                    return this.lensFlareComposePostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n\r\n        const resolution = new Vector2(0, 0);\r\n\r\n        // Lens flare\r\n        this.lensFlarePostProcess.externalTextureSamplerBinding = true;\r\n        this.lensFlarePostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"textureSampler\", this._bloomEnabled ? this.blurHPostProcesses[0] : this.originalPostProcess);\r\n            effect.setTexture(\"lensColorSampler\", this.lensColorTexture);\r\n            effect.setFloat(\"strength\", this.lensFlareStrength);\r\n            effect.setFloat(\"ghostDispersal\", this.lensFlareGhostDispersal);\r\n            effect.setFloat(\"haloWidth\", this.lensFlareHaloWidth);\r\n\r\n            // Shift\r\n            resolution.x = (<PostProcess>this.lensFlarePostProcess).width;\r\n            resolution.y = (<PostProcess>this.lensFlarePostProcess).height;\r\n            effect.setVector2(\"resolution\", resolution);\r\n\r\n            effect.setFloat(\"distortionStrength\", this.lensFlareDistortionStrength);\r\n        };\r\n\r\n        // Compose\r\n        const scaleBias1 = Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n\r\n        const scaleBias2 = Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\r\n\r\n        this.lensFlareComposePostProcess.onApply = (effect: Effect) => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this.lensFlarePostProcess);\r\n            effect.setTexture(\"lensDirtSampler\", this.lensFlareDirtTexture);\r\n            effect.setTexture(\"lensStarSampler\", this.lensStarTexture);\r\n\r\n            // Lens start rotation matrix\r\n            const camerax = <Vector4>this._scene.activeCamera.getViewMatrix().getRow(0);\r\n            const cameraz = <Vector4>this._scene.activeCamera.getViewMatrix().getRow(2);\r\n            let camRot = Vector3.Dot(camerax.toVector3(), new Vector3(1.0, 0.0, 0.0)) + Vector3.Dot(cameraz.toVector3(), new Vector3(0.0, 0.0, 1.0));\r\n            camRot *= 4.0;\r\n\r\n            const starRotation = Matrix.FromValues(\r\n                Math.cos(camRot) * 0.5,\r\n                -Math.sin(camRot),\r\n                0.0,\r\n                0.0,\r\n                Math.sin(camRot),\r\n                Math.cos(camRot) * 0.5,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0\r\n            );\r\n\r\n            const lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\r\n\r\n            effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\r\n\r\n            this._currentDepthOfFieldSource = this.lensFlareFinalPostProcess;\r\n        };\r\n    }\r\n\r\n    // Create depth-of-field post-process\r\n    private _createDepthOfFieldPostProcess(scene: Scene, ratio: number): void {\r\n        this.depthOfFieldPostProcess = new PostProcess(\r\n            \"HDRDepthOfField\",\r\n            \"standard\",\r\n            [\"distance\"],\r\n            [\"otherSampler\", \"depthSampler\"],\r\n            ratio,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            scene.getEngine(),\r\n            false,\r\n            \"#define DEPTH_OF_FIELD\",\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this.depthOfFieldPostProcess.onApply = (effect: Effect) => {\r\n            effect.setTextureFromPostProcess(\"otherSampler\", this._currentDepthOfFieldSource);\r\n            effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n\r\n            effect.setFloat(\"distance\", this.depthOfFieldDistance);\r\n        };\r\n\r\n        // Add to pipeline\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRDepthOfField\",\r\n                () => {\r\n                    return this.depthOfFieldPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    // Create motion blur post-process\r\n    private _createMotionBlurPostProcess(scene: Scene, ratio: number): void {\r\n        if (this._isObjectBasedMotionBlur) {\r\n            const mb = new MotionBlurPostProcess(\"HDRMotionBlur\", scene, ratio, null, Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, Constants.TEXTURETYPE_UNSIGNED_INT);\r\n            mb.motionStrength = this.motionStrength;\r\n            mb.motionBlurSamples = this.motionBlurSamples;\r\n            this.motionBlurPostProcess = mb;\r\n        } else {\r\n            this.motionBlurPostProcess = new PostProcess(\r\n                \"HDRMotionBlur\",\r\n                \"standard\",\r\n                [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"],\r\n                [\"depthSampler\"],\r\n                ratio,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                scene.getEngine(),\r\n                false,\r\n                \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1),\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n\r\n            let motionScale: number = 0;\r\n            let prevViewProjection = Matrix.Identity();\r\n            const invViewProjection = Matrix.Identity();\r\n            let viewProjection = Matrix.Identity();\r\n            const screenSize = Vector2.Zero();\r\n\r\n            this.motionBlurPostProcess.onApply = (effect: Effect) => {\r\n                viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\r\n\r\n                viewProjection.invertToRef(invViewProjection);\r\n                effect.setMatrix(\"inverseViewProjection\", invViewProjection);\r\n\r\n                effect.setMatrix(\"prevViewProjection\", prevViewProjection);\r\n                prevViewProjection = viewProjection;\r\n\r\n                screenSize.x = (<PostProcess>this.motionBlurPostProcess).width;\r\n                screenSize.y = (<PostProcess>this.motionBlurPostProcess).height;\r\n                effect.setVector2(\"screenSize\", screenSize);\r\n\r\n                motionScale = scene.getEngine().getFps() / 60.0;\r\n                effect.setFloat(\"motionScale\", motionScale);\r\n                effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n                effect.setTexture(\"depthSampler\", this._getDepthTexture());\r\n            };\r\n        }\r\n\r\n        this.addEffect(\r\n            new PostProcessRenderEffect(\r\n                scene.getEngine(),\r\n                \"HDRMotionBlur\",\r\n                () => {\r\n                    return this.motionBlurPostProcess;\r\n                },\r\n                true\r\n            )\r\n        );\r\n    }\r\n\r\n    private _getDepthTexture(): Texture {\r\n        if (this._scene.getEngine().getCaps().drawBuffersExtension) {\r\n            const renderer = <GeometryBufferRenderer>this._scene.enableGeometryBufferRenderer();\r\n            return renderer.getGBuffer().textures[0];\r\n        }\r\n\r\n        return this._scene.enableDepthRenderer().getDepthMap();\r\n    }\r\n\r\n    private _disposePostProcesses(): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.originalPostProcess) {\r\n                this.originalPostProcess.dispose(camera);\r\n            }\r\n            if (this.screenSpaceReflectionPostProcess) {\r\n                this.screenSpaceReflectionPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.downSampleX4PostProcess) {\r\n                this.downSampleX4PostProcess.dispose(camera);\r\n            }\r\n            if (this.brightPassPostProcess) {\r\n                this.brightPassPostProcess.dispose(camera);\r\n            }\r\n            if (this.textureAdderPostProcess) {\r\n                this.textureAdderPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.volumetricLightPostProcess) {\r\n                this.volumetricLightPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightSmoothXPostProcess) {\r\n                this.volumetricLightSmoothXPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightSmoothYPostProcess) {\r\n                this.volumetricLightSmoothYPostProcess.dispose(camera);\r\n            }\r\n            if (this.volumetricLightMergePostProces) {\r\n                this.volumetricLightMergePostProces.dispose(camera);\r\n            }\r\n            if (this.volumetricLightFinalPostProcess) {\r\n                this.volumetricLightFinalPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.lensFlarePostProcess) {\r\n                this.lensFlarePostProcess.dispose(camera);\r\n            }\r\n            if (this.lensFlareComposePostProcess) {\r\n                this.lensFlareComposePostProcess.dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\r\n                this.luminanceDownSamplePostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            if (this.luminancePostProcess) {\r\n                this.luminancePostProcess.dispose(camera);\r\n            }\r\n            if (this.hdrPostProcess) {\r\n                this.hdrPostProcess.dispose(camera);\r\n            }\r\n            if (this.hdrFinalPostProcess) {\r\n                this.hdrFinalPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.depthOfFieldPostProcess) {\r\n                this.depthOfFieldPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.motionBlurPostProcess) {\r\n                this.motionBlurPostProcess.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaaPostProcess) {\r\n                this.fxaaPostProcess.dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.blurHPostProcesses.length; j++) {\r\n                this.blurHPostProcesses[j].dispose(camera);\r\n            }\r\n\r\n            for (let j = 0; j < this.blurVPostProcesses.length; j++) {\r\n                this.blurVPostProcesses[j].dispose(camera);\r\n            }\r\n        }\r\n\r\n        this.originalPostProcess = null;\r\n        this.downSampleX4PostProcess = null;\r\n        this.brightPassPostProcess = null;\r\n        this.textureAdderPostProcess = null;\r\n        this.textureAdderFinalPostProcess = null;\r\n        this.volumetricLightPostProcess = null;\r\n        this.volumetricLightSmoothXPostProcess = null;\r\n        this.volumetricLightSmoothYPostProcess = null;\r\n        this.volumetricLightMergePostProces = null;\r\n        this.volumetricLightFinalPostProcess = null;\r\n        this.lensFlarePostProcess = null;\r\n        this.lensFlareComposePostProcess = null;\r\n        this.luminancePostProcess = null;\r\n        this.hdrPostProcess = null;\r\n        this.hdrFinalPostProcess = null;\r\n        this.depthOfFieldPostProcess = null;\r\n        this.motionBlurPostProcess = null;\r\n        this.fxaaPostProcess = null;\r\n        this.screenSpaceReflectionPostProcess = null;\r\n\r\n        this.luminanceDownSamplePostProcesses.length = 0;\r\n        this.blurHPostProcesses.length = 0;\r\n        this.blurVPostProcesses.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this._disposePostProcesses();\r\n\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        if (this.sourceLight) {\r\n            serializationObject.sourceLightId = this.sourceLight.id;\r\n        }\r\n\r\n        if (this.screenSpaceReflectionPostProcess) {\r\n            serializationObject.screenSpaceReflectionPostProcess = SerializationHelper.Serialize(this.screenSpaceReflectionPostProcess);\r\n        }\r\n\r\n        serializationObject.customType = \"StandardRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardRenderingPipeline {\r\n        const p = SerializationHelper.Parse(() => new StandardRenderingPipeline(source._name, scene, source._ratio), source, scene, rootUrl);\r\n\r\n        if (source.sourceLightId) {\r\n            p.sourceLight = <SpotLight | DirectionalLight>scene.getLightById(source.sourceLightId);\r\n        }\r\n\r\n        if (source.screenSpaceReflectionPostProcess) {\r\n            SerializationHelper.Parse(() => p.screenSpaceReflectionPostProcess, source.screenSpaceReflectionPostProcess, scene, rootUrl);\r\n        }\r\n\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Luminance steps\r\n     */\r\n    public static LuminanceSteps: number = 6;\r\n}\r\n\r\nRegisterClass(\"BABYLON.StandardRenderingPipeline\", StandardRenderingPipeline);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}