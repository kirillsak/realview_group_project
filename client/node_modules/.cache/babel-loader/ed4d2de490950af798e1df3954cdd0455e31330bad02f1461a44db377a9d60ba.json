{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\n/**\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\n */\nexport class VertexData {\n  constructor() {\n    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\n  }\n  /**\n   * Uses the passed data array to set the set the values for the specified kind of data\n   * @param data a linear array of floating numbers\n   * @param kind the type of data that is being set, eg positions, colors etc\n   */\n  set(data, kind) {\n    if (!data.length) {\n      Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\n    }\n    switch (kind) {\n      case VertexBuffer.PositionKind:\n        this.positions = data;\n        break;\n      case VertexBuffer.NormalKind:\n        this.normals = data;\n        break;\n      case VertexBuffer.TangentKind:\n        this.tangents = data;\n        break;\n      case VertexBuffer.UVKind:\n        this.uvs = data;\n        break;\n      case VertexBuffer.UV2Kind:\n        this.uvs2 = data;\n        break;\n      case VertexBuffer.UV3Kind:\n        this.uvs3 = data;\n        break;\n      case VertexBuffer.UV4Kind:\n        this.uvs4 = data;\n        break;\n      case VertexBuffer.UV5Kind:\n        this.uvs5 = data;\n        break;\n      case VertexBuffer.UV6Kind:\n        this.uvs6 = data;\n        break;\n      case VertexBuffer.ColorKind:\n        this.colors = data;\n        break;\n      case VertexBuffer.MatricesIndicesKind:\n        this.matricesIndices = data;\n        break;\n      case VertexBuffer.MatricesWeightsKind:\n        this.matricesWeights = data;\n        break;\n      case VertexBuffer.MatricesIndicesExtraKind:\n        this.matricesIndicesExtra = data;\n        break;\n      case VertexBuffer.MatricesWeightsExtraKind:\n        this.matricesWeightsExtra = data;\n        break;\n    }\n  }\n  /**\n   * Associates the vertexData to the passed Mesh.\n   * Sets it as updatable or not (default `false`)\n   * @param mesh the mesh the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns the VertexData\n   */\n  applyToMesh(mesh, updatable) {\n    this._applyTo(mesh, updatable, false);\n    return this;\n  }\n  /**\n   * Associates the vertexData to the passed Geometry.\n   * Sets it as updatable or not (default `false`)\n   * @param geometry the geometry the vertexData is applied to\n   * @param updatable when used and having the value true allows new data to update the vertexData\n   * @returns VertexData\n   */\n  applyToGeometry(geometry, updatable) {\n    this._applyTo(geometry, updatable, false);\n    return this;\n  }\n  /**\n   * Updates the associated mesh\n   * @param mesh the mesh to be updated\n   * @returns VertexData\n   */\n  updateMesh(mesh) {\n    this._update(mesh);\n    return this;\n  }\n  /**\n   * Updates the associated geometry\n   * @param geometry the geometry to be updated\n   * @returns VertexData.\n   */\n  updateGeometry(geometry) {\n    this._update(geometry);\n    return this;\n  }\n  /**\n   * @internal\n   */\n  *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {\n    if (this.positions) {\n      meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.normals) {\n      meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.tangents) {\n      meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs2) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs3) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs4) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs5) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.uvs6) {\n      meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.colors) {\n      meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesIndices) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesWeights) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n      if (isAsync) {\n        yield;\n      }\n    }\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null, updatable);\n      if (isAsync) {\n        yield;\n      }\n    } else {\n      meshOrGeometry.setIndices([], null);\n    }\n    return this;\n  }\n  _update(meshOrGeometry, updateExtends, makeItUnique) {\n    if (this.positions) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n    }\n    if (this.normals) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n    }\n    if (this.tangents) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n    }\n    if (this.uvs) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n    }\n    if (this.uvs2) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n    }\n    if (this.uvs3) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n    }\n    if (this.uvs4) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n    }\n    if (this.uvs5) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n    }\n    if (this.uvs6) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n    }\n    if (this.colors) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n    }\n    if (this.matricesIndices) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n    }\n    if (this.matricesWeights) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n    }\n    if (this.matricesIndicesExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n    }\n    if (this.matricesWeightsExtra) {\n      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n    }\n    if (this.indices) {\n      meshOrGeometry.setIndices(this.indices, null);\n    }\n    return this;\n  }\n  static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {\n    const coordinate = TmpVectors.Vector3[0];\n    const transformedCoordinate = TmpVectors.Vector3[1];\n    for (let index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(coordinates, index, coordinate);\n      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\n      coordinates[index] = transformedCoordinate.x;\n      coordinates[index + 1] = transformedCoordinate.y;\n      coordinates[index + 2] = transformedCoordinate.z;\n    }\n  }\n  static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {\n    const normal = TmpVectors.Vector3[0];\n    const transformedNormal = TmpVectors.Vector3[1];\n    for (let index = offset; index < offset + length; index += 3) {\n      Vector3.FromArrayToRef(normals, index, normal);\n      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n    }\n  }\n  static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {\n    const normal = TmpVectors.Vector4[0];\n    const transformedNormal = TmpVectors.Vector4[1];\n    for (let index = offset; index < offset + length; index += 4) {\n      Vector4.FromArrayToRef(normals, index, normal);\n      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\n      normals[index] = transformedNormal.x;\n      normals[index + 1] = transformedNormal.y;\n      normals[index + 2] = transformedNormal.z;\n      normals[index + 3] = transformedNormal.w;\n    }\n  }\n  static _FlipFaces(indices, offset = 0, length = indices.length) {\n    for (let index = offset; index < offset + length; index += 3) {\n      const tmp = indices[index + 1];\n      indices[index + 1] = indices[index + 2];\n      indices[index + 2] = tmp;\n    }\n  }\n  /**\n   * Transforms each position and each normal of the vertexData according to the passed Matrix\n   * @param matrix the transforming matrix\n   * @returns the VertexData\n   */\n  transform(matrix) {\n    const flip = matrix.determinant() < 0;\n    if (this.positions) {\n      VertexData._TransformVector3Coordinates(this.positions, matrix);\n    }\n    if (this.normals) {\n      VertexData._TransformVector3Normals(this.normals, matrix);\n    }\n    if (this.tangents) {\n      VertexData._TransformVector4Normals(this.tangents, matrix);\n    }\n    if (flip && this.indices) {\n      VertexData._FlipFaces(this.indices);\n    }\n    return this;\n  }\n  /**\n   * Merges the passed VertexData into the current one\n   * @param others the VertexData to be merged into the current one\n   * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\n   * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\n   * @returns the modified VertexData\n   */\n  merge(others, use32BitsIndices = false, forceCloneIndices = false) {\n    const vertexDatas = Array.isArray(others) ? others.map(other => [other, undefined]) : [[others, undefined]];\n    return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices));\n  }\n  /**\n   * @internal\n   */\n  *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices) {\n    var _a, _b, _c, _d;\n    this._validate();\n    const others = vertexDatas.map(vertexData => vertexData[0]);\n    for (const other of others) {\n      other._validate();\n      if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {\n        throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\n      }\n    }\n    const totalIndices = others.reduce((indexSum, vertexData) => {\n      var _a, _b;\n      return indexSum + ((_b = (_a = vertexData.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    }, (_b = (_a = this.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n    const sliceIndices = forceCloneIndices || others.some(vertexData => vertexData.indices === this.indices);\n    let indices = sliceIndices ? (_c = this.indices) === null || _c === void 0 ? void 0 : _c.slice() : this.indices;\n    if (totalIndices > 0) {\n      let indicesOffset = (_d = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _d !== void 0 ? _d : 0;\n      if (!indices) {\n        indices = new Array(totalIndices);\n      }\n      if (indices.length !== totalIndices) {\n        if (Array.isArray(indices)) {\n          indices.length = totalIndices;\n        } else {\n          const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\n          temp.set(indices);\n          indices = temp;\n        }\n        if (transform && transform.determinant() < 0) {\n          VertexData._FlipFaces(indices, 0, indicesOffset);\n        }\n      }\n      let positionsOffset = this.positions ? this.positions.length / 3 : 0;\n      for (const [other, transform] of vertexDatas) {\n        if (other.indices) {\n          for (let index = 0; index < other.indices.length; index++) {\n            indices[indicesOffset + index] = other.indices[index] + positionsOffset;\n          }\n          if (transform && transform.determinant() < 0) {\n            VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\n          }\n          // The call to _validate already checked for positions\n          positionsOffset += other.positions.length / 3;\n          indicesOffset += other.indices.length;\n          if (isAsync) {\n            yield;\n          }\n        }\n      }\n    }\n    this.indices = indices;\n    this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, this.positions, transform, vertexDatas.map(other => [other[0].positions, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, this.normals, transform, vertexDatas.map(other => [other[0].normals, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, this.tangents, transform, vertexDatas.map(other => [other[0].tangents, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, this.uvs, transform, vertexDatas.map(other => [other[0].uvs, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, this.uvs2, transform, vertexDatas.map(other => [other[0].uvs2, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, this.uvs3, transform, vertexDatas.map(other => [other[0].uvs3, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, this.uvs4, transform, vertexDatas.map(other => [other[0].uvs4, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, this.uvs5, transform, vertexDatas.map(other => [other[0].uvs5, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, this.uvs6, transform, vertexDatas.map(other => [other[0].uvs6, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, this.colors, transform, vertexDatas.map(other => [other[0].colors, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform, vertexDatas.map(other => [other[0].matricesIndices, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform, vertexDatas.map(other => [other[0].matricesWeights, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform, vertexDatas.map(other => [other[0].matricesIndicesExtra, other[1]]));\n    if (isAsync) {\n      yield;\n    }\n    this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform, vertexDatas.map(other => [other[0].matricesWeightsExtra, other[1]]));\n    return this;\n  }\n  static _MergeElement(kind, source, transform, others) {\n    const nonNullOthers = others.filter(other => other[0] !== null && other[0] !== undefined);\n    // If there is no source to copy and no other non-null sources then skip this element.\n    if (!source && nonNullOthers.length == 0) {\n      return source;\n    }\n    if (!source) {\n      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\n    }\n    const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\n    const transformRange = kind === VertexBuffer.PositionKind ? VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData._TransformVector4Normals : () => {};\n    if (source instanceof Float32Array) {\n      // use non-loop method when the source is Float32Array\n      const ret32 = new Float32Array(len);\n      ret32.set(source);\n      transform && transformRange(ret32, transform, 0, source.length);\n      let offset = source.length;\n      for (const [vertexData, transform] of nonNullOthers) {\n        ret32.set(vertexData, offset);\n        transform && transformRange(ret32, transform, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n      return ret32;\n    } else {\n      // don't use concat as it is super slow, just loop for other cases\n      const ret = new Array(len);\n      for (let i = 0; i < source.length; i++) {\n        ret[i] = source[i];\n      }\n      transform && transformRange(ret, transform, 0, source.length);\n      let offset = source.length;\n      for (const [vertexData, transform] of nonNullOthers) {\n        for (let i = 0; i < vertexData.length; i++) {\n          ret[offset + i] = vertexData[i];\n        }\n        transform && transformRange(ret, transform, offset, vertexData.length);\n        offset += vertexData.length;\n      }\n      return ret;\n    }\n  }\n  _validate() {\n    if (!this.positions) {\n      throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\n    }\n    const getElementCount = (kind, values) => {\n      const stride = VertexBuffer.DeduceStride(kind);\n      if (values.length % stride !== 0) {\n        throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\n      }\n      return values.length / stride;\n    };\n    const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\n    const validateElementCount = (kind, values) => {\n      const elementCount = getElementCount(kind, values);\n      if (elementCount !== positionsElementCount) {\n        throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\n      }\n    };\n    if (this.normals) {\n      validateElementCount(VertexBuffer.NormalKind, this.normals);\n    }\n    if (this.tangents) {\n      validateElementCount(VertexBuffer.TangentKind, this.tangents);\n    }\n    if (this.uvs) {\n      validateElementCount(VertexBuffer.UVKind, this.uvs);\n    }\n    if (this.uvs2) {\n      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\n    }\n    if (this.uvs3) {\n      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\n    }\n    if (this.uvs4) {\n      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\n    }\n    if (this.uvs5) {\n      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\n    }\n    if (this.uvs6) {\n      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\n    }\n    if (this.colors) {\n      validateElementCount(VertexBuffer.ColorKind, this.colors);\n    }\n    if (this.matricesIndices) {\n      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\n    }\n    if (this.matricesWeights) {\n      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\n    }\n    if (this.matricesIndicesExtra) {\n      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\n    }\n    if (this.matricesWeightsExtra) {\n      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\n    }\n  }\n  /**\n   * Serializes the VertexData\n   * @returns a serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    if (this.positions) {\n      serializationObject.positions = this.positions;\n    }\n    if (this.normals) {\n      serializationObject.normals = this.normals;\n    }\n    if (this.tangents) {\n      serializationObject.tangents = this.tangents;\n    }\n    if (this.uvs) {\n      serializationObject.uvs = this.uvs;\n    }\n    if (this.uvs2) {\n      serializationObject.uvs2 = this.uvs2;\n    }\n    if (this.uvs3) {\n      serializationObject.uvs3 = this.uvs3;\n    }\n    if (this.uvs4) {\n      serializationObject.uvs4 = this.uvs4;\n    }\n    if (this.uvs5) {\n      serializationObject.uvs5 = this.uvs5;\n    }\n    if (this.uvs6) {\n      serializationObject.uvs6 = this.uvs6;\n    }\n    if (this.colors) {\n      serializationObject.colors = this.colors;\n    }\n    if (this.matricesIndices) {\n      serializationObject.matricesIndices = this.matricesIndices;\n      serializationObject.matricesIndices._isExpanded = true;\n    }\n    if (this.matricesWeights) {\n      serializationObject.matricesWeights = this.matricesWeights;\n    }\n    if (this.matricesIndicesExtra) {\n      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\n      serializationObject.matricesIndicesExtra._isExpanded = true;\n    }\n    if (this.matricesWeightsExtra) {\n      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\n    }\n    serializationObject.indices = this.indices;\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Extracts the vertexData from a mesh\n   * @param mesh the mesh from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n  static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n  }\n  /**\n   * Extracts the vertexData from the geometry\n   * @param geometry the geometry from which to extract the VertexData\n   * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\n   * @param forceCopy indicating that the VertexData must be cloned, optional, default false\n   * @returns the object VertexData associated to the passed mesh\n   */\n  static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {\n    return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n  }\n  static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {\n    const result = new VertexData();\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\n      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n    }\n    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n    }\n    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\n    return result;\n  }\n  /**\n   * Creates the VertexData for a Ribbon\n   * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\n   * * pathArray array of paths, each of which an array of successive Vector3\n   * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\n   * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\n   * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\n   * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\n   * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\n   * @param options.pathArray\n   * @param options.closeArray\n   * @param options.closePath\n   * @param options.offset\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @param options.invertUV\n   * @param options.uvs\n   * @param options.colors\n   * @returns the VertexData of the ribbon\n   * @deprecated use CreateRibbonVertexData instead\n   */\n  static CreateRibbon(options) {\n    throw _WarnImport(\"ribbonBuilder\");\n  }\n  /**\n   * Creates the VertexData for a box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * size sets the width, height and depth of the box to the value of size, optional default 1\n   * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n   * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\n   */\n  static CreateBox(options) {\n    throw _WarnImport(\"boxBuilder\");\n  }\n  /**\n   * Creates the VertexData for a tiled box\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * faceTiles sets the pattern, tile size and number of tiles for a face\n   * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n   * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param options.pattern\n   * @param options.width\n   * @param options.height\n   * @param options.depth\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.sideOrientation\n   * @returns the VertexData of the box\n   * @deprecated Please use CreateTiledBoxVertexData instead\n   */\n  static CreateTiledBox(options) {\n    throw _WarnImport(\"tiledBoxBuilder\");\n  }\n  /**\n   * Creates the VertexData for a tiled plane\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * pattern a limited pattern arrangement depending on the number\n   * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n   * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n   * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.pattern\n   * @param options.tileSize\n   * @param options.tileWidth\n   * @param options.tileHeight\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.alignHorizontal\n   * @param options.alignVertical\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the tiled plane\n   * @deprecated use CreateTiledPlaneVertexData instead\n   */\n  static CreateTiledPlane(options) {\n    throw _WarnImport(\"tiledPlaneBuilder\");\n  }\n  /**\n   * Creates the VertexData for an ellipsoid, defaults to a sphere\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * segments sets the number of horizontal strips optional, default 32\n   * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n   * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n   * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n   * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n   * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n   * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.segments\n   * @param options.diameter\n   * @param options.diameterX\n   * @param options.diameterY\n   * @param options.diameterZ\n   * @param options.arc\n   * @param options.slice\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the ellipsoid\n   * @deprecated use CreateSphereVertexData instead\n   */\n  static CreateSphere(options) {\n    throw _WarnImport(\"sphereBuilder\");\n  }\n  /**\n   * Creates the VertexData for a cylinder, cone or prism\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * height sets the height (y direction) of the cylinder, optional, default 2\n   * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\n   * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\n   * * diameter sets the diameter of the top and bottom of the cone, optional default 1\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * subdivisions` the number of rings along the cylinder height, optional, default 1\n   * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\n   * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.height\n   * @param options.diameterTop\n   * @param options.diameterBottom\n   * @param options.diameter\n   * @param options.tessellation\n   * @param options.subdivisions\n   * @param options.arc\n   * @param options.faceColors\n   * @param options.faceUV\n   * @param options.hasRings\n   * @param options.enclose\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the cylinder, cone or prism\n   * @deprecated please use CreateCylinderVertexData instead\n   */\n  static CreateCylinder(options) {\n    throw _WarnImport(\"cylinderBuilder\");\n  }\n  /**\n   * Creates the VertexData for a torus\n   * @param options an object used to set the following optional parameters for the box, required but can be empty\n   * * diameter the diameter of the torus, optional default 1\n   * * thickness the diameter of the tube forming the torus, optional default 0.5\n   * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.diameter\n   * @param options.thickness\n   * @param options.tessellation\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the torus\n   * @deprecated use CreateTorusVertexData instead\n   */\n  static CreateTorus(options) {\n    throw _WarnImport(\"torusBuilder\");\n  }\n  /**\n   * Creates the VertexData of the LineSystem\n   * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\n   *  - lines an array of lines, each line being an array of successive Vector3\n   *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\n   * @param options.lines\n   * @param options.colors\n   * @returns the VertexData of the LineSystem\n   * @deprecated use CreateLineSystemVertexData instead\n   */\n  static CreateLineSystem(options) {\n    throw _WarnImport(\"linesBuilder\");\n  }\n  /**\n   * Create the VertexData for a DashedLines\n   * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\n   *  - points an array successive Vector3\n   *  - dashSize the size of the dashes relative to the dash number, optional, default 3\n   *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\n   *  - dashNb the intended total number of dashes, optional, default 200\n   * @param options.points\n   * @param options.dashSize\n   * @param options.gapSize\n   * @param options.dashNb\n   * @returns the VertexData for the DashedLines\n   * @deprecated use CreateDashedLinesVertexData instead\n   */\n  static CreateDashedLines(options) {\n    throw _WarnImport(\"linesBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Ground\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   *  - width the width (x direction) of the ground, optional, default 1\n   *  - height the height (z direction) of the ground, optional, default 1\n   *  - subdivisions the number of subdivisions per side, optional, default 1\n   * @param options.width\n   * @param options.height\n   * @param options.subdivisions\n   * @param options.subdivisionsX\n   * @param options.subdivisionsY\n   * @returns the VertexData of the Ground\n   * @deprecated Please use CreateGroundVertexData instead\n   */\n  static CreateGround(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n   * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n   * * xmin the ground minimum X coordinate, optional, default -1\n   * * zmin the ground minimum Z coordinate, optional, default -1\n   * * xmax the ground maximum X coordinate, optional, default 1\n   * * zmax the ground maximum Z coordinate, optional, default 1\n   * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n   * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n   * @param options.xmin\n   * @param options.zmin\n   * @param options.xmax\n   * @param options.zmax\n   * @param options.subdivisions\n   * @param options.subdivisions.w\n   * @param options.subdivisions.h\n   * @param options.precision\n   * @param options.precision.w\n   * @param options.precision.h\n   * @returns the VertexData of the TiledGround\n   * @deprecated use CreateTiledGroundVertexData instead\n   */\n  static CreateTiledGround(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData of the Ground designed from a heightmap\n   * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n   * * width the width (x direction) of the ground\n   * * height the height (z direction) of the ground\n   * * subdivisions the number of subdivisions per side\n   * * minHeight the minimum altitude on the ground, optional, default 0\n   * * maxHeight the maximum altitude on the ground, optional default 1\n   * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n   * * buffer the array holding the image color data\n   * * bufferWidth the width of image\n   * * bufferHeight the height of image\n   * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n   * @param options.width\n   * @param options.height\n   * @param options.subdivisions\n   * @param options.minHeight\n   * @param options.maxHeight\n   * @param options.colorFilter\n   * @param options.buffer\n   * @param options.bufferWidth\n   * @param options.bufferHeight\n   * @param options.alphaFilter\n   * @returns the VertexData of the Ground designed from a heightmap\n   * @deprecated use CreateGroundFromHeightMapVertexData instead\n   */\n  static CreateGroundFromHeightMap(options) {\n    throw _WarnImport(\"groundBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Plane\n   * @param options an object used to set the following optional parameters for the plane, required but can be empty\n   * * size sets the width and height of the plane to the value of size, optional default 1\n   * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\n   * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.size\n   * @param options.width\n   * @param options.height\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated use CreatePlaneVertexData instead\n   */\n  static CreatePlane(options) {\n    throw _WarnImport(\"planeBuilder\");\n  }\n  /**\n   * Creates the VertexData of the Disc or regular Polygon\n   * @param options an object used to set the following optional parameters for the disc, required but can be empty\n   * * radius the radius of the disc, optional default 0.5\n   * * tessellation the number of polygon sides, optional, default 64\n   * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.tessellation\n   * @param options.arc\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the box\n   * @deprecated use CreateDiscVertexData instead\n   */\n  static CreateDisc(options) {\n    throw _WarnImport(\"discBuilder\");\n  }\n  /**\n   * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\n   * All parameters are provided by CreatePolygon as needed\n   * @param polygon a mesh built from polygonTriangulation.build()\n   * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\n   * @returns the VertexData of the Polygon\n   * @deprecated use CreatePolygonVertexData instead\n   */\n  static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {\n    throw _WarnImport(\"polygonBuilder\");\n  }\n  /**\n   * Creates the VertexData of the IcoSphere\n   * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\n   * * radius the radius of the IcoSphere, optional default 1\n   * * radiusX allows stretching in the x direction, optional, default radius\n   * * radiusY allows stretching in the y direction, optional, default radius\n   * * radiusZ allows stretching in the z direction, optional, default radius\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.radiusX\n   * @param options.radiusY\n   * @param options.radiusZ\n   * @param options.flat\n   * @param options.subdivisions\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the IcoSphere\n   * @deprecated use CreateIcoSphereVertexData instead\n   */\n  static CreateIcoSphere(options) {\n    throw _WarnImport(\"icoSphereBuilder\");\n  }\n  // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n  /**\n   * Creates the VertexData for a Polyhedron\n   * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\n   * * type provided types are:\n   *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n   *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n   * * size the size of the IcoSphere, optional default 1\n   * * sizeX allows stretching in the x direction, optional, default size\n   * * sizeY allows stretching in the y direction, optional, default size\n   * * sizeZ allows stretching in the z direction, optional, default size\n   * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\n   * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\n   * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\n   * * flat when true creates a flat shaded mesh, optional, default true\n   * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.type\n   * @param options.size\n   * @param options.sizeX\n   * @param options.sizeY\n   * @param options.sizeZ\n   * @param options.custom\n   * @param options.faceUV\n   * @param options.faceColors\n   * @param options.flat\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the Polyhedron\n   * @deprecated use CreatePolyhedronVertexData instead\n   */\n  static CreatePolyhedron(options) {\n    throw _WarnImport(\"polyhedronBuilder\");\n  }\n  /**\n   * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n   * @param options an object used to set the following optional parameters for the capsule, required but can be empty\n   * @returns the VertexData of the Capsule\n   * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\n   */\n  static CreateCapsule(options = {\n    orientation: Vector3.Up(),\n    subdivisions: 2,\n    tessellation: 16,\n    height: 1,\n    radius: 0.25,\n    capSubdivisions: 6\n  }) {\n    throw _WarnImport(\"capsuleBuilder\");\n  }\n  // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n  /**\n   * Creates the VertexData for a TorusKnot\n   * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\n   * * radius the radius of the torus knot, optional, default 2\n   * * tube the thickness of the tube, optional, default 0.5\n   * * radialSegments the number of sides on each tube segments, optional, default 32\n   * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\n   * * p the number of windings around the z axis, optional,  default 2\n   * * q the number of windings around the x axis, optional,  default 3\n   * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n   * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n   * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n   * @param options.radius\n   * @param options.tube\n   * @param options.radialSegments\n   * @param options.tubularSegments\n   * @param options.p\n   * @param options.q\n   * @param options.sideOrientation\n   * @param options.frontUVs\n   * @param options.backUVs\n   * @returns the VertexData of the Torus Knot\n   * @deprecated use CreateTorusKnotVertexData instead\n   */\n  static CreateTorusKnot(options) {\n    throw _WarnImport(\"torusKnotBuilder\");\n  }\n  // Tools\n  /**\n   * Compute normals for given positions and indices\n   * @param positions an array of vertex positions, [...., x, y, z, ......]\n   * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\n   * @param normals an array of vertex normals, [...., x, y, z, ......]\n   * @param options an object used to set the following optional parameters for the TorusKnot, optional\n   * * facetNormals : optional array of facet normals (vector3)\n   * * facetPositions : optional array of facet positions (vector3)\n   * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\n   * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\n   * * bInfo : optional bounding info, required for facetPartitioning computation\n   * * bbSize : optional bounding box size data, required for facetPartitioning computation\n   * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\n   * * useRightHandedSystem: optional boolean to for right handed system computation\n   * * depthSort : optional boolean to enable the facet depth sort computation\n   * * distanceTo : optional Vector3 to compute the facet depth from this location\n   * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\n   * @param options.facetNormals\n   * @param options.facetPositions\n   * @param options.facetPartitioning\n   * @param options.ratio\n   * @param options.bInfo\n   * @param options.bbSize\n   * @param options.subDiv\n   * @param options.useRightHandedSystem\n   * @param options.depthSort\n   * @param options.distanceTo\n   * @param options.depthSortedFacets\n   */\n  static ComputeNormals(positions, indices, normals, options) {\n    // temporary scalar variables\n    let index = 0; // facet index\n    let p1p2x = 0.0; // p1p2 vector x coordinate\n    let p1p2y = 0.0; // p1p2 vector y coordinate\n    let p1p2z = 0.0; // p1p2 vector z coordinate\n    let p3p2x = 0.0; // p3p2 vector x coordinate\n    let p3p2y = 0.0; // p3p2 vector y coordinate\n    let p3p2z = 0.0; // p3p2 vector z coordinate\n    let faceNormalx = 0.0; // facet normal x coordinate\n    let faceNormaly = 0.0; // facet normal y coordinate\n    let faceNormalz = 0.0; // facet normal z coordinate\n    let length = 0.0; // facet normal length before normalization\n    let v1x = 0; // vector1 x index in the positions array\n    let v1y = 0; // vector1 y index in the positions array\n    let v1z = 0; // vector1 z index in the positions array\n    let v2x = 0; // vector2 x index in the positions array\n    let v2y = 0; // vector2 y index in the positions array\n    let v2z = 0; // vector2 z index in the positions array\n    let v3x = 0; // vector3 x index in the positions array\n    let v3y = 0; // vector3 y index in the positions array\n    let v3z = 0; // vector3 z index in the positions array\n    let computeFacetNormals = false;\n    let computeFacetPositions = false;\n    let computeFacetPartitioning = false;\n    let computeDepthSort = false;\n    let faceNormalSign = 1;\n    let ratio = 0;\n    let distanceTo = null;\n    if (options) {\n      computeFacetNormals = options.facetNormals ? true : false;\n      computeFacetPositions = options.facetPositions ? true : false;\n      computeFacetPartitioning = options.facetPartitioning ? true : false;\n      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\n      ratio = options.ratio || 0;\n      computeDepthSort = options.depthSort ? true : false;\n      distanceTo = options.distanceTo;\n      if (computeDepthSort) {\n        if (distanceTo === undefined) {\n          distanceTo = Vector3.Zero();\n        }\n      }\n    }\n    // facetPartitioning reinit if needed\n    let xSubRatio = 0;\n    let ySubRatio = 0;\n    let zSubRatio = 0;\n    let subSq = 0;\n    if (computeFacetPartitioning && options && options.bbSize) {\n      //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\n      //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\n      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;\n      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;\n      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;\n      subSq = options.subDiv.max * options.subDiv.max;\n      options.facetPartitioning.length = 0;\n    }\n    // reset the normals\n    for (index = 0; index < positions.length; index++) {\n      normals[index] = 0.0;\n    }\n    // Loop : 1 indice triplet = 1 facet\n    const nbFaces = indices.length / 3 | 0;\n    for (index = 0; index < nbFaces; index++) {\n      // get the indexes of the coordinates of each vertex of the facet\n      v1x = indices[index * 3] * 3;\n      v1y = v1x + 1;\n      v1z = v1x + 2;\n      v2x = indices[index * 3 + 1] * 3;\n      v2y = v2x + 1;\n      v2z = v2x + 2;\n      v3x = indices[index * 3 + 2] * 3;\n      v3y = v3x + 1;\n      v3z = v3x + 2;\n      p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n      p1p2y = positions[v1y] - positions[v2y];\n      p1p2z = positions[v1z] - positions[v2z];\n      p3p2x = positions[v3x] - positions[v2x];\n      p3p2y = positions[v3y] - positions[v2y];\n      p3p2z = positions[v3z] - positions[v2z];\n      // compute the face normal with the cross product\n      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\n      // normalize this normal and store it in the array facetData\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      if (computeFacetNormals && options) {\n        options.facetNormals[index].x = faceNormalx;\n        options.facetNormals[index].y = faceNormaly;\n        options.facetNormals[index].z = faceNormalz;\n      }\n      if (computeFacetPositions && options) {\n        // compute and the facet barycenter coordinates in the array facetPositions\n        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n      }\n      if (computeFacetPartitioning && options) {\n        // store the facet indexes in arrays in the main facetPartitioning array :\n        // compute each facet vertex (+ facet barycenter) index in the partiniong array\n        const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\n        const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\n        const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\n        const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n        const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n        const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n        const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\n        // push each facet index in each block containing the vertex\n        options.facetPartitioning[block_idx_v1].push(index);\n        if (block_idx_v2 != block_idx_v1) {\n          options.facetPartitioning[block_idx_v2].push(index);\n        }\n        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n          options.facetPartitioning[block_idx_v3].push(index);\n        }\n        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n          options.facetPartitioning[block_idx_o].push(index);\n        }\n      }\n      if (computeDepthSort && options && options.facetPositions) {\n        const dsf = options.depthSortedFacets[index];\n        dsf.ind = index * 3;\n        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);\n      }\n      // compute the normals anyway\n      normals[v1x] += faceNormalx; // accumulate all the normals per face\n      normals[v1y] += faceNormaly;\n      normals[v1z] += faceNormalz;\n      normals[v2x] += faceNormalx;\n      normals[v2y] += faceNormaly;\n      normals[v2z] += faceNormalz;\n      normals[v3x] += faceNormalx;\n      normals[v3y] += faceNormaly;\n      normals[v3z] += faceNormalz;\n    }\n    // last normalization of each normal\n    for (index = 0; index < normals.length / 3; index++) {\n      faceNormalx = normals[index * 3];\n      faceNormaly = normals[index * 3 + 1];\n      faceNormalz = normals[index * 3 + 2];\n      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n      length = length === 0 ? 1.0 : length;\n      faceNormalx /= length;\n      faceNormaly /= length;\n      faceNormalz /= length;\n      normals[index * 3] = faceNormalx;\n      normals[index * 3 + 1] = faceNormaly;\n      normals[index * 3 + 2] = faceNormalz;\n    }\n  }\n  /**\n   * @internal\n   */\n  static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n    const li = indices.length;\n    const ln = normals.length;\n    let i;\n    let n;\n    sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\n    switch (sideOrientation) {\n      case VertexData.FRONTSIDE:\n        // nothing changed\n        break;\n      case VertexData.BACKSIDE:\n        // indices\n        for (i = 0; i < li; i += 3) {\n          const tmp = indices[i];\n          indices[i] = indices[i + 2];\n          indices[i + 2] = tmp;\n        }\n        // normals\n        for (n = 0; n < ln; n++) {\n          normals[n] = -normals[n];\n        }\n        break;\n      case VertexData.DOUBLESIDE:\n        {\n          // positions\n          const lp = positions.length;\n          const l = lp / 3;\n          for (let p = 0; p < lp; p++) {\n            positions[lp + p] = positions[p];\n          }\n          // indices\n          for (i = 0; i < li; i += 3) {\n            indices[i + li] = indices[i + 2] + l;\n            indices[i + 1 + li] = indices[i + 1] + l;\n            indices[i + 2 + li] = indices[i] + l;\n          }\n          // normals\n          for (n = 0; n < ln; n++) {\n            normals[ln + n] = -normals[n];\n          }\n          // uvs\n          const lu = uvs.length;\n          let u = 0;\n          for (u = 0; u < lu; u++) {\n            uvs[u + lu] = uvs[u];\n          }\n          frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\n          u = 0;\n          for (i = 0; i < lu / 2; i++) {\n            uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n            uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n            uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n            uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n            u += 2;\n          }\n          break;\n        }\n    }\n  }\n  /**\n   * Applies VertexData created from the imported parameters to the geometry\n   * @param parsedVertexData the parsed data from an imported file\n   * @param geometry the geometry to apply the VertexData to\n   */\n  static ImportVertexData(parsedVertexData, geometry) {\n    const vertexData = new VertexData();\n    // positions\n    const positions = parsedVertexData.positions;\n    if (positions) {\n      vertexData.set(positions, VertexBuffer.PositionKind);\n    }\n    // normals\n    const normals = parsedVertexData.normals;\n    if (normals) {\n      vertexData.set(normals, VertexBuffer.NormalKind);\n    }\n    // tangents\n    const tangents = parsedVertexData.tangents;\n    if (tangents) {\n      vertexData.set(tangents, VertexBuffer.TangentKind);\n    }\n    // uvs\n    const uvs = parsedVertexData.uvs;\n    if (uvs) {\n      vertexData.set(uvs, VertexBuffer.UVKind);\n    }\n    // uv2s\n    const uv2s = parsedVertexData.uv2s;\n    if (uv2s) {\n      vertexData.set(uv2s, VertexBuffer.UV2Kind);\n    }\n    // uv3s\n    const uv3s = parsedVertexData.uv3s;\n    if (uv3s) {\n      vertexData.set(uv3s, VertexBuffer.UV3Kind);\n    }\n    // uv4s\n    const uv4s = parsedVertexData.uv4s;\n    if (uv4s) {\n      vertexData.set(uv4s, VertexBuffer.UV4Kind);\n    }\n    // uv5s\n    const uv5s = parsedVertexData.uv5s;\n    if (uv5s) {\n      vertexData.set(uv5s, VertexBuffer.UV5Kind);\n    }\n    // uv6s\n    const uv6s = parsedVertexData.uv6s;\n    if (uv6s) {\n      vertexData.set(uv6s, VertexBuffer.UV6Kind);\n    }\n    // colors\n    const colors = parsedVertexData.colors;\n    if (colors) {\n      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\n    }\n    // matricesIndices\n    const matricesIndices = parsedVertexData.matricesIndices;\n    if (matricesIndices) {\n      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\n    }\n    // matricesWeights\n    const matricesWeights = parsedVertexData.matricesWeights;\n    if (matricesWeights) {\n      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\n    }\n    // indices\n    const indices = parsedVertexData.indices;\n    if (indices) {\n      vertexData.indices = indices;\n    }\n    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n  }\n}\n/**\n * Mesh side orientation : usually the external or front surface\n */\nVertexData.FRONTSIDE = 0;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\nVertexData.BACKSIDE = 1;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\nVertexData.DOUBLESIDE = 2;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\nVertexData.DEFAULTSIDE = 0;\n__decorate([nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))], VertexData, \"_TransformVector3Coordinates\", null);\n__decorate([nativeOverride.filter((...[normals]) => !Array.isArray(normals))], VertexData, \"_TransformVector3Normals\", null);\n__decorate([nativeOverride.filter((...[normals]) => !Array.isArray(normals))], VertexData, \"_TransformVector4Normals\", null);\n__decorate([nativeOverride.filter((...[indices]) => !Array.isArray(indices))], VertexData, \"_FlipFaces\", null);","map":{"version":3,"mappings":"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","names":["Vector3","Vector4","TmpVectors","VertexBuffer","_WarnImport","Color4","Logger","nativeOverride","makeSyncFunction","runCoroutineSync","RuntimeError","ErrorCodes","VertexData","constructor","_applyToCoroutine","bind","set","data","kind","length","Warn","PositionKind","positions","NormalKind","normals","TangentKind","tangents","UVKind","uvs","UV2Kind","uvs2","UV3Kind","uvs3","UV4Kind","uvs4","UV5Kind","uvs5","UV6Kind","uvs6","ColorKind","colors","MatricesIndicesKind","matricesIndices","MatricesWeightsKind","matricesWeights","MatricesIndicesExtraKind","matricesIndicesExtra","MatricesWeightsExtraKind","matricesWeightsExtra","applyToMesh","mesh","updatable","_applyTo","applyToGeometry","geometry","updateMesh","_update","updateGeometry","meshOrGeometry","isAsync","setVerticesData","indices","setIndices","updateExtends","makeItUnique","updateVerticesData","_TransformVector3Coordinates","coordinates","transformation","offset","coordinate","transformedCoordinate","index","FromArrayToRef","TransformCoordinatesToRef","x","y","z","_TransformVector3Normals","normal","transformedNormal","TransformNormalToRef","_TransformVector4Normals","w","_FlipFaces","tmp","transform","matrix","flip","determinant","merge","others","use32BitsIndices","forceCloneIndices","vertexDatas","Array","isArray","map","other","undefined","_mergeCoroutine","_validate","vertexData","Error","totalIndices","reduce","indexSum","sliceIndices","some","slice","indicesOffset","temp","Uint32Array","Uint16Array","positionsOffset","_MergeElement","source","nonNullOthers","filter","len","sumLen","elements","transformRange","Float32Array","ret32","ret","i","MeshInvalidPositionsError","getElementCount","values","stride","DeduceStride","positionsElementCount","validateElementCount","elementCount","serialize","serializationObject","_isExpanded","ExtractFromMesh","copyWhenShared","forceCopy","_ExtractFrom","ExtractFromGeometry","result","isVerticesDataPresent","getVerticesData","getIndices","CreateRibbon","options","CreateBox","CreateTiledBox","CreateTiledPlane","CreateSphere","CreateCylinder","CreateTorus","CreateLineSystem","CreateDashedLines","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreatePlane","CreateDisc","CreatePolygon","polygon","sideOrientation","fUV","fColors","frontUVs","backUVs","wrap","CreateIcoSphere","CreatePolyhedron","CreateCapsule","orientation","Up","subdivisions","tessellation","height","radius","capSubdivisions","CreateTorusKnot","ComputeNormals","p1p2x","p1p2y","p1p2z","p3p2x","p3p2y","p3p2z","faceNormalx","faceNormaly","faceNormalz","v1x","v1y","v1z","v2x","v2y","v2z","v3x","v3y","v3z","computeFacetNormals","computeFacetPositions","computeFacetPartitioning","computeDepthSort","faceNormalSign","ratio","distanceTo","facetNormals","facetPositions","facetPartitioning","useRightHandedSystem","depthSort","Zero","xSubRatio","ySubRatio","zSubRatio","subSq","bbSize","subDiv","X","Y","Z","max","nbFaces","Math","sqrt","ox","floor","bInfo","minimum","oy","oz","b1x","b1y","b1z","b2x","b2y","b2z","b3x","b3y","b3z","block_idx_v1","block_idx_v2","block_idx_v3","block_idx_o","push","dsf","depthSortedFacets","ind","sqDistance","DistanceSquared","_ComputeSides","li","ln","n","DEFAULTSIDE","FRONTSIDE","BACKSIDE","DOUBLESIDE","lp","l","p","lu","u","ImportVertexData","parsedVertexData","uv2s","uv3s","uv4s","uv5s","uv6s","CheckColors4","setAllVerticesData","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/mesh.vertexData.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Nullable, FloatArray, IndicesArray, DeepImmutable } from \"../types\";\r\nimport type { Matrix, Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3, Vector4, TmpVectors } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { nativeOverride } from \"../Misc/decorators\";\r\nimport type { Coroutine } from \"../Misc/coroutine\";\r\nimport { makeSyncFunction, runCoroutineSync } from \"../Misc/coroutine\";\r\nimport type { ICreateCapsuleOptions } from \"./Builders/capsuleBuilder\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\n\r\ndeclare type Geometry = import(\"../Meshes/geometry\").Geometry;\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\ndeclare type PolyhedronData = import(\"./geodesicMesh\").PolyhedronData;\r\n\r\n/**\r\n * Define an interface for all classes that will get and set the data on vertices\r\n */\r\nexport interface IGetSetVerticesData {\r\n    /**\r\n     * Gets a boolean indicating if specific vertex data is present\r\n     * @param kind defines the vertex data kind to use\r\n     * @returns true is data kind is present\r\n     */\r\n    isVerticesDataPresent(kind: string): boolean;\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray>;\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the indices array or an empty array if the mesh has no geometry\r\n     */\r\n    getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray>;\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    setVerticesData(kind: string, data: FloatArray, updatable: boolean): void;\r\n    /**\r\n     * Update a specific associated vertex buffer\r\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\r\n     */\r\n    updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): void;\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    setIndices(indices: IndicesArray, totalVertices: Nullable<number>, updatable?: boolean): void;\r\n}\r\n\r\n/**\r\n * This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance\r\n */\r\nexport class VertexData {\r\n    /**\r\n     * Mesh side orientation : usually the external or front surface\r\n     */\r\n    public static readonly FRONTSIDE = 0;\r\n    /**\r\n     * Mesh side orientation : usually the internal or back surface\r\n     */\r\n    public static readonly BACKSIDE = 1;\r\n    /**\r\n     * Mesh side orientation : both internal and external or front and back surfaces\r\n     */\r\n    public static readonly DOUBLESIDE = 2;\r\n    /**\r\n     * Mesh side orientation : by default, `FRONTSIDE`\r\n     */\r\n    public static readonly DEFAULTSIDE = 0;\r\n\r\n    /**\r\n     * An array of the x, y, z position of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public positions: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public normals: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]\r\n     */\r\n    public tangents: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs2: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs3: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs4: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs5: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]\r\n     */\r\n    public uvs6: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]\r\n     */\r\n    public colors: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).\r\n     */\r\n    public matricesIndices: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array containing the list of weights defining the weight of each indexed matrix in the final computation\r\n     */\r\n    public matricesWeights: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible indices\r\n     */\r\n    public matricesIndicesExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array extending the number of possible weights when the number of indices is extended\r\n     */\r\n    public matricesWeightsExtra: Nullable<FloatArray>;\r\n\r\n    /**\r\n     * An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]\r\n     */\r\n    public indices: Nullable<IndicesArray>;\r\n\r\n    /**\r\n     * Uses the passed data array to set the set the values for the specified kind of data\r\n     * @param data a linear array of floating numbers\r\n     * @param kind the type of data that is being set, eg positions, colors etc\r\n     */\r\n    public set(data: FloatArray, kind: string) {\r\n        if (!data.length) {\r\n            Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);\r\n        }\r\n\r\n        switch (kind) {\r\n            case VertexBuffer.PositionKind:\r\n                this.positions = data;\r\n                break;\r\n            case VertexBuffer.NormalKind:\r\n                this.normals = data;\r\n                break;\r\n            case VertexBuffer.TangentKind:\r\n                this.tangents = data;\r\n                break;\r\n            case VertexBuffer.UVKind:\r\n                this.uvs = data;\r\n                break;\r\n            case VertexBuffer.UV2Kind:\r\n                this.uvs2 = data;\r\n                break;\r\n            case VertexBuffer.UV3Kind:\r\n                this.uvs3 = data;\r\n                break;\r\n            case VertexBuffer.UV4Kind:\r\n                this.uvs4 = data;\r\n                break;\r\n            case VertexBuffer.UV5Kind:\r\n                this.uvs5 = data;\r\n                break;\r\n            case VertexBuffer.UV6Kind:\r\n                this.uvs6 = data;\r\n                break;\r\n            case VertexBuffer.ColorKind:\r\n                this.colors = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesKind:\r\n                this.matricesIndices = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsKind:\r\n                this.matricesWeights = data;\r\n                break;\r\n            case VertexBuffer.MatricesIndicesExtraKind:\r\n                this.matricesIndicesExtra = data;\r\n                break;\r\n            case VertexBuffer.MatricesWeightsExtraKind:\r\n                this.matricesWeightsExtra = data;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Mesh.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param mesh the mesh the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns the VertexData\r\n     */\r\n    public applyToMesh(mesh: Mesh, updatable?: boolean): VertexData {\r\n        this._applyTo(mesh, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Associates the vertexData to the passed Geometry.\r\n     * Sets it as updatable or not (default `false`)\r\n     * @param geometry the geometry the vertexData is applied to\r\n     * @param updatable when used and having the value true allows new data to update the vertexData\r\n     * @returns VertexData\r\n     */\r\n    public applyToGeometry(geometry: Geometry, updatable?: boolean): VertexData {\r\n        this._applyTo(geometry, updatable, false);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated mesh\r\n     * @param mesh the mesh to be updated\r\n     * @returns VertexData\r\n     */\r\n    public updateMesh(mesh: Mesh): VertexData {\r\n        this._update(mesh);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Updates the associated geometry\r\n     * @param geometry the geometry to be updated\r\n     * @returns VertexData.\r\n     */\r\n    public updateGeometry(geometry: Geometry): VertexData {\r\n        this._update(geometry);\r\n        return this;\r\n    }\r\n\r\n    private readonly _applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_applyToCoroutine(meshOrGeometry: IGetSetVerticesData, updatable: boolean = false, isAsync: boolean): Coroutine<VertexData> {\r\n        if (this.positions) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null, updatable);\r\n            if (isAsync) {\r\n                yield;\r\n            }\r\n        } else {\r\n            meshOrGeometry.setIndices([], null);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _update(meshOrGeometry: IGetSetVerticesData, updateExtends?: boolean, makeItUnique?: boolean): VertexData {\r\n        if (this.positions) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.normals) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.colors) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\r\n        }\r\n\r\n        if (this.indices) {\r\n            meshOrGeometry.setIndices(this.indices, null);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    @nativeOverride.filter((...[coordinates]: Parameters<typeof VertexData._TransformVector3Coordinates>) => !Array.isArray(coordinates))\r\n    private static _TransformVector3Coordinates(coordinates: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = coordinates.length) {\r\n        const coordinate = TmpVectors.Vector3[0];\r\n        const transformedCoordinate = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(coordinates, index, coordinate);\r\n            Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);\r\n            coordinates[index] = transformedCoordinate.x;\r\n            coordinates[index + 1] = transformedCoordinate.y;\r\n            coordinates[index + 2] = transformedCoordinate.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector3Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector3Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector3[0];\r\n        const transformedNormal = TmpVectors.Vector3[1];\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            Vector3.FromArrayToRef(normals, index, normal);\r\n            Vector3.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[normals]: Parameters<typeof VertexData._TransformVector4Normals>) => !Array.isArray(normals))\r\n    private static _TransformVector4Normals(normals: FloatArray, transformation: DeepImmutable<Matrix>, offset = 0, length = normals.length) {\r\n        const normal = TmpVectors.Vector4[0];\r\n        const transformedNormal = TmpVectors.Vector4[1];\r\n        for (let index = offset; index < offset + length; index += 4) {\r\n            Vector4.FromArrayToRef(normals, index, normal);\r\n            Vector4.TransformNormalToRef(normal, transformation, transformedNormal);\r\n            normals[index] = transformedNormal.x;\r\n            normals[index + 1] = transformedNormal.y;\r\n            normals[index + 2] = transformedNormal.z;\r\n            normals[index + 3] = transformedNormal.w;\r\n        }\r\n    }\r\n\r\n    @nativeOverride.filter((...[indices]: Parameters<typeof VertexData._FlipFaces>) => !Array.isArray(indices))\r\n    private static _FlipFaces(indices: IndicesArray, offset = 0, length = indices.length) {\r\n        for (let index = offset; index < offset + length; index += 3) {\r\n            const tmp = indices[index + 1];\r\n            indices[index + 1] = indices[index + 2];\r\n            indices[index + 2] = tmp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transforms each position and each normal of the vertexData according to the passed Matrix\r\n     * @param matrix the transforming matrix\r\n     * @returns the VertexData\r\n     */\r\n    public transform(matrix: Matrix): VertexData {\r\n        const flip = matrix.determinant() < 0;\r\n        if (this.positions) {\r\n            VertexData._TransformVector3Coordinates(this.positions, matrix);\r\n        }\r\n\r\n        if (this.normals) {\r\n            VertexData._TransformVector3Normals(this.normals, matrix);\r\n        }\r\n\r\n        if (this.tangents) {\r\n            VertexData._TransformVector4Normals(this.tangents, matrix);\r\n        }\r\n\r\n        if (flip && this.indices) {\r\n            VertexData._FlipFaces(this.indices);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Merges the passed VertexData into the current one\r\n     * @param others the VertexData to be merged into the current one\r\n     * @param use32BitsIndices defines a boolean indicating if indices must be store in a 32 bits array\r\n     * @param forceCloneIndices defines a boolean indicating if indices are forced to be cloned\r\n     * @returns the modified VertexData\r\n     */\r\n    public merge(others: VertexData | VertexData[], use32BitsIndices = false, forceCloneIndices = false) {\r\n        const vertexDatas: [vertexData: VertexData, transform?: Matrix][] = Array.isArray(others) ? others.map((other) => [other, undefined]) : [[others, undefined]];\r\n        return runCoroutineSync(this._mergeCoroutine(undefined, vertexDatas, use32BitsIndices, false, forceCloneIndices));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public *_mergeCoroutine(\r\n        transform: Matrix | undefined,\r\n        vertexDatas: (readonly [vertexData: VertexData, transform?: Matrix])[],\r\n        use32BitsIndices = false,\r\n        isAsync: boolean,\r\n        forceCloneIndices: boolean\r\n    ): Coroutine<VertexData> {\r\n        this._validate();\r\n\r\n        const others = vertexDatas.map((vertexData) => vertexData[0]);\r\n\r\n        for (const other of others) {\r\n            other._validate();\r\n\r\n            if (\r\n                !this.normals !== !other.normals ||\r\n                !this.tangents !== !other.tangents ||\r\n                !this.uvs !== !other.uvs ||\r\n                !this.uvs2 !== !other.uvs2 ||\r\n                !this.uvs3 !== !other.uvs3 ||\r\n                !this.uvs4 !== !other.uvs4 ||\r\n                !this.uvs5 !== !other.uvs5 ||\r\n                !this.uvs6 !== !other.uvs6 ||\r\n                !this.colors !== !other.colors ||\r\n                !this.matricesIndices !== !other.matricesIndices ||\r\n                !this.matricesWeights !== !other.matricesWeights ||\r\n                !this.matricesIndicesExtra !== !other.matricesIndicesExtra ||\r\n                !this.matricesWeightsExtra !== !other.matricesWeightsExtra\r\n            ) {\r\n                throw new Error(\"Cannot merge vertex data that do not have the same set of attributes\");\r\n            }\r\n        }\r\n\r\n        const totalIndices = others.reduce((indexSum, vertexData) => indexSum + (vertexData.indices?.length ?? 0), this.indices?.length ?? 0);\r\n        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === this.indices);\r\n        let indices = sliceIndices ? this.indices?.slice() : this.indices;\r\n        if (totalIndices > 0) {\r\n            let indicesOffset = indices?.length ?? 0;\r\n\r\n            if (!indices) {\r\n                indices = new Array<number>(totalIndices);\r\n            }\r\n\r\n            if (indices.length !== totalIndices) {\r\n                if (Array.isArray(indices)) {\r\n                    indices.length = totalIndices;\r\n                } else {\r\n                    const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);\r\n                    temp.set(indices);\r\n                    indices = temp;\r\n                }\r\n\r\n                if (transform && transform.determinant() < 0) {\r\n                    VertexData._FlipFaces(indices, 0, indicesOffset);\r\n                }\r\n            }\r\n\r\n            let positionsOffset = this.positions ? this.positions.length / 3 : 0;\r\n            for (const [other, transform] of vertexDatas) {\r\n                if (other.indices) {\r\n                    for (let index = 0; index < other.indices.length; index++) {\r\n                        indices[indicesOffset + index] = other.indices[index] + positionsOffset;\r\n                    }\r\n\r\n                    if (transform && transform.determinant() < 0) {\r\n                        VertexData._FlipFaces(indices, indicesOffset, other.indices.length);\r\n                    }\r\n\r\n                    // The call to _validate already checked for positions\r\n                    positionsOffset += other.positions!.length / 3;\r\n                    indicesOffset += other.indices.length;\r\n\r\n                    if (isAsync) {\r\n                        yield;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.indices = indices!;\r\n\r\n        this.positions = VertexData._MergeElement(\r\n            VertexBuffer.PositionKind,\r\n            this.positions,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].positions, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.normals = VertexData._MergeElement(\r\n            VertexBuffer.NormalKind,\r\n            this.normals,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].normals, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.tangents = VertexData._MergeElement(\r\n            VertexBuffer.TangentKind,\r\n            this.tangents,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].tangents, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs = VertexData._MergeElement(\r\n            VertexBuffer.UVKind,\r\n            this.uvs,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs2 = VertexData._MergeElement(\r\n            VertexBuffer.UV2Kind,\r\n            this.uvs2,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs2, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs3 = VertexData._MergeElement(\r\n            VertexBuffer.UV3Kind,\r\n            this.uvs3,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs3, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs4 = VertexData._MergeElement(\r\n            VertexBuffer.UV4Kind,\r\n            this.uvs4,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs4, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs5 = VertexData._MergeElement(\r\n            VertexBuffer.UV5Kind,\r\n            this.uvs5,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs5, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.uvs6 = VertexData._MergeElement(\r\n            VertexBuffer.UV6Kind,\r\n            this.uvs6,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].uvs6, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.colors = VertexData._MergeElement(\r\n            VertexBuffer.ColorKind,\r\n            this.colors,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].colors, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesIndices = VertexData._MergeElement(\r\n            VertexBuffer.MatricesIndicesKind,\r\n            this.matricesIndices,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesIndices, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesWeights = VertexData._MergeElement(\r\n            VertexBuffer.MatricesWeightsKind,\r\n            this.matricesWeights,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesWeights, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesIndicesExtra = VertexData._MergeElement(\r\n            VertexBuffer.MatricesIndicesExtraKind,\r\n            this.matricesIndicesExtra,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesIndicesExtra, other[1]])\r\n        );\r\n        if (isAsync) {\r\n            yield;\r\n        }\r\n        this.matricesWeightsExtra = VertexData._MergeElement(\r\n            VertexBuffer.MatricesWeightsExtraKind,\r\n            this.matricesWeightsExtra,\r\n            transform,\r\n            vertexDatas.map((other) => [other[0].matricesWeightsExtra, other[1]])\r\n        );\r\n\r\n        return this;\r\n    }\r\n\r\n    private static _MergeElement(\r\n        kind: string,\r\n        source: Nullable<FloatArray>,\r\n        transform: Matrix | undefined,\r\n        others: readonly (readonly [element: Nullable<FloatArray>, transform?: Matrix])[]\r\n    ): Nullable<FloatArray> {\r\n        const nonNullOthers = others.filter((other): other is [element: FloatArray, transform?: Matrix] => other[0] !== null && other[0] !== undefined);\r\n\r\n        // If there is no source to copy and no other non-null sources then skip this element.\r\n        if (!source && nonNullOthers.length == 0) {\r\n            return source;\r\n        }\r\n\r\n        if (!source) {\r\n            return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));\r\n        }\r\n\r\n        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);\r\n\r\n        const transformRange =\r\n            kind === VertexBuffer.PositionKind\r\n                ? VertexData._TransformVector3Coordinates\r\n                : kind === VertexBuffer.NormalKind\r\n                ? VertexData._TransformVector3Normals\r\n                : kind === VertexBuffer.TangentKind\r\n                ? VertexData._TransformVector4Normals\r\n                : () => {};\r\n\r\n        if (source instanceof Float32Array) {\r\n            // use non-loop method when the source is Float32Array\r\n            const ret32 = new Float32Array(len);\r\n            ret32.set(source);\r\n            transform && transformRange(ret32, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                ret32.set(vertexData, offset);\r\n                transform && transformRange(ret32, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret32;\r\n        } else {\r\n            // don't use concat as it is super slow, just loop for other cases\r\n            const ret = new Array<number>(len);\r\n            for (let i = 0; i < source.length; i++) {\r\n                ret[i] = source[i];\r\n            }\r\n            transform && transformRange(ret, transform, 0, source.length);\r\n\r\n            let offset = source.length;\r\n            for (const [vertexData, transform] of nonNullOthers) {\r\n                for (let i = 0; i < vertexData.length; i++) {\r\n                    ret[offset + i] = vertexData[i];\r\n                }\r\n                transform && transformRange(ret, transform, offset, vertexData.length);\r\n                offset += vertexData.length;\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    private _validate(): void {\r\n        if (!this.positions) {\r\n            throw new RuntimeError(\"Positions are required\", ErrorCodes.MeshInvalidPositionsError);\r\n        }\r\n\r\n        const getElementCount = (kind: string, values: FloatArray) => {\r\n            const stride = VertexBuffer.DeduceStride(kind);\r\n            if (values.length % stride !== 0) {\r\n                throw new Error(\"The \" + kind + \"s array count must be a multiple of \" + stride);\r\n            }\r\n\r\n            return values.length / stride;\r\n        };\r\n\r\n        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);\r\n\r\n        const validateElementCount = (kind: string, values: FloatArray) => {\r\n            const elementCount = getElementCount(kind, values);\r\n            if (elementCount !== positionsElementCount) {\r\n                throw new Error(\"The \" + kind + \"s element count (\" + elementCount + \") does not match the positions count (\" + positionsElementCount + \")\");\r\n            }\r\n        };\r\n\r\n        if (this.normals) {\r\n            validateElementCount(VertexBuffer.NormalKind, this.normals);\r\n        }\r\n        if (this.tangents) {\r\n            validateElementCount(VertexBuffer.TangentKind, this.tangents);\r\n        }\r\n        if (this.uvs) {\r\n            validateElementCount(VertexBuffer.UVKind, this.uvs);\r\n        }\r\n        if (this.uvs2) {\r\n            validateElementCount(VertexBuffer.UV2Kind, this.uvs2);\r\n        }\r\n        if (this.uvs3) {\r\n            validateElementCount(VertexBuffer.UV3Kind, this.uvs3);\r\n        }\r\n        if (this.uvs4) {\r\n            validateElementCount(VertexBuffer.UV4Kind, this.uvs4);\r\n        }\r\n        if (this.uvs5) {\r\n            validateElementCount(VertexBuffer.UV5Kind, this.uvs5);\r\n        }\r\n        if (this.uvs6) {\r\n            validateElementCount(VertexBuffer.UV6Kind, this.uvs6);\r\n        }\r\n        if (this.colors) {\r\n            validateElementCount(VertexBuffer.ColorKind, this.colors);\r\n        }\r\n        if (this.matricesIndices) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);\r\n        }\r\n        if (this.matricesWeights) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);\r\n        }\r\n        if (this.matricesIndicesExtra) {\r\n            validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);\r\n        }\r\n        if (this.matricesWeightsExtra) {\r\n            validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the VertexData\r\n     * @returns a serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (this.positions) {\r\n            serializationObject.positions = this.positions;\r\n        }\r\n\r\n        if (this.normals) {\r\n            serializationObject.normals = this.normals;\r\n        }\r\n\r\n        if (this.tangents) {\r\n            serializationObject.tangents = this.tangents;\r\n        }\r\n\r\n        if (this.uvs) {\r\n            serializationObject.uvs = this.uvs;\r\n        }\r\n\r\n        if (this.uvs2) {\r\n            serializationObject.uvs2 = this.uvs2;\r\n        }\r\n\r\n        if (this.uvs3) {\r\n            serializationObject.uvs3 = this.uvs3;\r\n        }\r\n\r\n        if (this.uvs4) {\r\n            serializationObject.uvs4 = this.uvs4;\r\n        }\r\n\r\n        if (this.uvs5) {\r\n            serializationObject.uvs5 = this.uvs5;\r\n        }\r\n\r\n        if (this.uvs6) {\r\n            serializationObject.uvs6 = this.uvs6;\r\n        }\r\n\r\n        if (this.colors) {\r\n            serializationObject.colors = this.colors;\r\n        }\r\n\r\n        if (this.matricesIndices) {\r\n            serializationObject.matricesIndices = this.matricesIndices;\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeights) {\r\n            serializationObject.matricesWeights = this.matricesWeights;\r\n        }\r\n\r\n        if (this.matricesIndicesExtra) {\r\n            serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\r\n            serializationObject.matricesIndicesExtra._isExpanded = true;\r\n        }\r\n\r\n        if (this.matricesWeightsExtra) {\r\n            serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\r\n        }\r\n\r\n        serializationObject.indices = this.indices;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Extracts the vertexData from a mesh\r\n     * @param mesh the mesh from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Extracts the vertexData from the geometry\r\n     * @param geometry the geometry from which to extract the VertexData\r\n     * @param copyWhenShared defines if the VertexData must be cloned when the geometry is shared between multiple meshes, optional, default false\r\n     * @param forceCopy indicating that the VertexData must be cloned, optional, default false\r\n     * @returns the object VertexData associated to the passed mesh\r\n     */\r\n    public static ExtractFromGeometry(geometry: Geometry, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    private static _ExtractFrom(meshOrGeometry: IGetSetVerticesData, copyWhenShared?: boolean, forceCopy?: boolean): VertexData {\r\n        const result = new VertexData();\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {\r\n            result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\r\n            result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\r\n        }\r\n\r\n        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ribbon\r\n     * @param options an object used to set the following optional parameters for the ribbon, required but can be empty\r\n     * * pathArray array of paths, each of which an array of successive Vector3\r\n     * * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false\r\n     * * closePath creates a seam between the first and the last points of each path of the path array, optional, default false\r\n     * * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * * invertUV swaps in the U and V coordinates when applying a texture, optional, default false\r\n     * * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional\r\n     * * colors a linear array, of length 4 * number of vertices, of custom color values, optional\r\n     * @param options.pathArray\r\n     * @param options.closeArray\r\n     * @param options.closePath\r\n     * @param options.offset\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @param options.invertUV\r\n     * @param options.uvs\r\n     * @param options.colors\r\n     * @returns the VertexData of the ribbon\r\n     * @deprecated use CreateRibbonVertexData instead\r\n     */\r\n    public static CreateRibbon(options: {\r\n        pathArray: Vector3[][];\r\n        closeArray?: boolean;\r\n        closePath?: boolean;\r\n        offset?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        invertUV?: boolean;\r\n        uvs?: Vector2[];\r\n        colors?: Color4[];\r\n    }): VertexData {\r\n        throw _WarnImport(\"ribbonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n     * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateBoxVertexData from the BoxBuilder file instead\r\n     */\r\n    public static CreateBox(options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"boxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled box\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * faceTiles sets the pattern, tile size and number of tiles for a face\r\n     * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n     * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param options.pattern\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.depth\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.sideOrientation\r\n     * @returns the VertexData of the box\r\n     * @deprecated Please use CreateTiledBoxVertexData instead\r\n     */\r\n    public static CreateTiledBox(options: {\r\n        pattern?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledBoxBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a tiled plane\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * pattern a limited pattern arrangement depending on the number\r\n     * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n     * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n     * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.pattern\r\n     * @param options.tileSize\r\n     * @param options.tileWidth\r\n     * @param options.tileHeight\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.alignHorizontal\r\n     * @param options.alignVertical\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the tiled plane\r\n     * @deprecated use CreateTiledPlaneVertexData instead\r\n     */\r\n    public static CreateTiledPlane(options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"tiledPlaneBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * segments sets the number of horizontal strips optional, default 32\r\n     * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n     * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n     * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n     * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n     * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n     * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.segments\r\n     * @param options.diameter\r\n     * @param options.diameterX\r\n     * @param options.diameterY\r\n     * @param options.diameterZ\r\n     * @param options.arc\r\n     * @param options.slice\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the ellipsoid\r\n     * @deprecated use CreateSphereVertexData instead\r\n     */\r\n    public static CreateSphere(options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"sphereBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a cylinder, cone or prism\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * height sets the height (y direction) of the cylinder, optional, default 2\r\n     * * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter\r\n     * * diameter sets the diameter of the top and bottom of the cone, optional default 1\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * subdivisions` the number of rings along the cylinder height, optional, default 1\r\n     * * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * hasRings when true makes each subdivision independently treated as a face for faceUV and faceColors, optional, default false\r\n     * * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.height\r\n     * @param options.diameterTop\r\n     * @param options.diameterBottom\r\n     * @param options.diameter\r\n     * @param options.tessellation\r\n     * @param options.subdivisions\r\n     * @param options.arc\r\n     * @param options.faceColors\r\n     * @param options.faceUV\r\n     * @param options.hasRings\r\n     * @param options.enclose\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the cylinder, cone or prism\r\n     * @deprecated please use CreateCylinderVertexData instead\r\n     */\r\n    public static CreateCylinder(options: {\r\n        height?: number;\r\n        diameterTop?: number;\r\n        diameterBottom?: number;\r\n        diameter?: number;\r\n        tessellation?: number;\r\n        subdivisions?: number;\r\n        arc?: number;\r\n        faceColors?: Color4[];\r\n        faceUV?: Vector4[];\r\n        hasRings?: boolean;\r\n        enclose?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"cylinderBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a torus\r\n     * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n     * * diameter the diameter of the torus, optional default 1\r\n     * * thickness the diameter of the tube forming the torus, optional default 0.5\r\n     * * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.diameter\r\n     * @param options.thickness\r\n     * @param options.tessellation\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the torus\r\n     * @deprecated use CreateTorusVertexData instead\r\n     */\r\n    public static CreateTorus(options: {\r\n        diameter?: number;\r\n        thickness?: number;\r\n        tessellation?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the LineSystem\r\n     * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n     *  - lines an array of lines, each line being an array of successive Vector3\r\n     *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n     * @param options.lines\r\n     * @param options.colors\r\n     * @returns the VertexData of the LineSystem\r\n     * @deprecated use CreateLineSystemVertexData instead\r\n     */\r\n    public static CreateLineSystem(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Create the VertexData for a DashedLines\r\n     * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n     *  - points an array successive Vector3\r\n     *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n     *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n     *  - dashNb the intended total number of dashes, optional, default 200\r\n     * @param options.points\r\n     * @param options.dashSize\r\n     * @param options.gapSize\r\n     * @param options.dashNb\r\n     * @returns the VertexData for the DashedLines\r\n     * @deprecated use CreateDashedLinesVertexData instead\r\n     */\r\n    public static CreateDashedLines(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n        throw _WarnImport(\"linesBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Ground\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     *  - width the width (x direction) of the ground, optional, default 1\r\n     *  - height the height (z direction) of the ground, optional, default 1\r\n     *  - subdivisions the number of subdivisions per side, optional, default 1\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.subdivisionsX\r\n     * @param options.subdivisionsY\r\n     * @returns the VertexData of the Ground\r\n     * @deprecated Please use CreateGroundVertexData instead\r\n     */\r\n    public static CreateGround(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n     * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n     * * xmin the ground minimum X coordinate, optional, default -1\r\n     * * zmin the ground minimum Z coordinate, optional, default -1\r\n     * * xmax the ground maximum X coordinate, optional, default 1\r\n     * * zmax the ground maximum Z coordinate, optional, default 1\r\n     * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n     * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n     * @param options.xmin\r\n     * @param options.zmin\r\n     * @param options.xmax\r\n     * @param options.zmax\r\n     * @param options.subdivisions\r\n     * @param options.subdivisions.w\r\n     * @param options.subdivisions.h\r\n     * @param options.precision\r\n     * @param options.precision.w\r\n     * @param options.precision.h\r\n     * @returns the VertexData of the TiledGround\r\n     * @deprecated use CreateTiledGroundVertexData instead\r\n     */\r\n    public static CreateTiledGround(options: {\r\n        xmin: number;\r\n        zmin: number;\r\n        xmax: number;\r\n        zmax: number;\r\n        subdivisions?: { w: number; h: number };\r\n        precision?: { w: number; h: number };\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Ground designed from a heightmap\r\n     * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n     * * width the width (x direction) of the ground\r\n     * * height the height (z direction) of the ground\r\n     * * subdivisions the number of subdivisions per side\r\n     * * minHeight the minimum altitude on the ground, optional, default 0\r\n     * * maxHeight the maximum altitude on the ground, optional default 1\r\n     * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n     * * buffer the array holding the image color data\r\n     * * bufferWidth the width of image\r\n     * * bufferHeight the height of image\r\n     * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.subdivisions\r\n     * @param options.minHeight\r\n     * @param options.maxHeight\r\n     * @param options.colorFilter\r\n     * @param options.buffer\r\n     * @param options.bufferWidth\r\n     * @param options.bufferHeight\r\n     * @param options.alphaFilter\r\n     * @returns the VertexData of the Ground designed from a heightmap\r\n     * @deprecated use CreateGroundFromHeightMapVertexData instead\r\n     */\r\n    public static CreateGroundFromHeightMap(options: {\r\n        width: number;\r\n        height: number;\r\n        subdivisions: number;\r\n        minHeight: number;\r\n        maxHeight: number;\r\n        colorFilter: Color3;\r\n        buffer: Uint8Array;\r\n        bufferWidth: number;\r\n        bufferHeight: number;\r\n        alphaFilter: number;\r\n    }): VertexData {\r\n        throw _WarnImport(\"groundBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Plane\r\n     * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n     * * size sets the width and height of the plane to the value of size, optional default 1\r\n     * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n     * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.size\r\n     * @param options.width\r\n     * @param options.height\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreatePlaneVertexData instead\r\n     */\r\n    public static CreatePlane(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"planeBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the Disc or regular Polygon\r\n     * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n     * * radius the radius of the disc, optional default 0.5\r\n     * * tessellation the number of polygon sides, optional, default 64\r\n     * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tessellation\r\n     * @param options.arc\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the box\r\n     * @deprecated use CreateDiscVertexData instead\r\n     */\r\n    public static CreateDisc(options: { radius?: number; tessellation?: number; arc?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n        throw _WarnImport(\"discBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n     * All parameters are provided by CreatePolygon as needed\r\n     * @param polygon a mesh built from polygonTriangulation.build()\r\n     * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param wrap a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n     * @returns the VertexData of the Polygon\r\n     * @deprecated use CreatePolygonVertexData instead\r\n     */\r\n    public static CreatePolygon(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrap?: boolean): VertexData {\r\n        throw _WarnImport(\"polygonBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData of the IcoSphere\r\n     * @param options an object used to set the following optional parameters for the IcoSphere, required but can be empty\r\n     * * radius the radius of the IcoSphere, optional default 1\r\n     * * radiusX allows stretching in the x direction, optional, default radius\r\n     * * radiusY allows stretching in the y direction, optional, default radius\r\n     * * radiusZ allows stretching in the z direction, optional, default radius\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.radiusX\r\n     * @param options.radiusY\r\n     * @param options.radiusZ\r\n     * @param options.flat\r\n     * @param options.subdivisions\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the IcoSphere\r\n     * @deprecated use CreateIcoSphereVertexData instead\r\n     */\r\n    public static CreateIcoSphere(options: {\r\n        radius?: number;\r\n        radiusX?: number;\r\n        radiusY?: number;\r\n        radiusZ?: number;\r\n        flat?: boolean;\r\n        subdivisions?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"icoSphereBuilder\");\r\n    }\r\n\r\n    // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\r\n    /**\r\n     * Creates the VertexData for a Polyhedron\r\n     * @param options an object used to set the following optional parameters for the polyhedron, required but can be empty\r\n     * * type provided types are:\r\n     *  * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n     *  * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n     * * size the size of the IcoSphere, optional default 1\r\n     * * sizeX allows stretching in the x direction, optional, default size\r\n     * * sizeY allows stretching in the y direction, optional, default size\r\n     * * sizeZ allows stretching in the z direction, optional, default size\r\n     * * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor\r\n     * * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n     * * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n     * * flat when true creates a flat shaded mesh, optional, default true\r\n     * * subdivisions increasing the subdivisions increases the number of faces, optional, default 4\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.type\r\n     * @param options.size\r\n     * @param options.sizeX\r\n     * @param options.sizeY\r\n     * @param options.sizeZ\r\n     * @param options.custom\r\n     * @param options.faceUV\r\n     * @param options.faceColors\r\n     * @param options.flat\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Polyhedron\r\n     * @deprecated use CreatePolyhedronVertexData instead\r\n     */\r\n    public static CreatePolyhedron(options: {\r\n        type?: number;\r\n        size?: number;\r\n        sizeX?: number;\r\n        sizeY?: number;\r\n        sizeZ?: number;\r\n        custom?: any;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        flat?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"polyhedronBuilder\");\r\n    }\r\n\r\n    /**\r\n     * Creates the VertexData for a Capsule, inspired from https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n     * @param options an object used to set the following optional parameters for the capsule, required but can be empty\r\n     * @returns the VertexData of the Capsule\r\n     * @deprecated Please use CreateCapsuleVertexData from the capsuleBuilder file instead\r\n     */\r\n    public static CreateCapsule(\r\n        options: ICreateCapsuleOptions = {\r\n            orientation: Vector3.Up(),\r\n            subdivisions: 2,\r\n            tessellation: 16,\r\n            height: 1,\r\n            radius: 0.25,\r\n            capSubdivisions: 6,\r\n        }\r\n    ): VertexData {\r\n        throw _WarnImport(\"capsuleBuilder\");\r\n    }\r\n\r\n    // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n    /**\r\n     * Creates the VertexData for a TorusKnot\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, required but can be empty\r\n     * * radius the radius of the torus knot, optional, default 2\r\n     * * tube the thickness of the tube, optional, default 0.5\r\n     * * radialSegments the number of sides on each tube segments, optional, default 32\r\n     * * tubularSegments the number of tubes to decompose the knot into, optional, default 32\r\n     * * p the number of windings around the z axis, optional,  default 2\r\n     * * q the number of windings around the x axis, optional,  default 3\r\n     * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n     * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n     * @param options.radius\r\n     * @param options.tube\r\n     * @param options.radialSegments\r\n     * @param options.tubularSegments\r\n     * @param options.p\r\n     * @param options.q\r\n     * @param options.sideOrientation\r\n     * @param options.frontUVs\r\n     * @param options.backUVs\r\n     * @returns the VertexData of the Torus Knot\r\n     * @deprecated use CreateTorusKnotVertexData instead\r\n     */\r\n    public static CreateTorusKnot(options: {\r\n        radius?: number;\r\n        tube?: number;\r\n        radialSegments?: number;\r\n        tubularSegments?: number;\r\n        p?: number;\r\n        q?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n    }): VertexData {\r\n        throw _WarnImport(\"torusKnotBuilder\");\r\n    }\r\n\r\n    // Tools\r\n\r\n    /**\r\n     * Compute normals for given positions and indices\r\n     * @param positions an array of vertex positions, [...., x, y, z, ......]\r\n     * @param indices an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]\r\n     * @param normals an array of vertex normals, [...., x, y, z, ......]\r\n     * @param options an object used to set the following optional parameters for the TorusKnot, optional\r\n     * * facetNormals : optional array of facet normals (vector3)\r\n     * * facetPositions : optional array of facet positions (vector3)\r\n     * * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\r\n     * * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\r\n     * * bInfo : optional bounding info, required for facetPartitioning computation\r\n     * * bbSize : optional bounding box size data, required for facetPartitioning computation\r\n     * * subDiv : optional partitioning data about subdivisions on  each axis (int), required for facetPartitioning computation\r\n     * * useRightHandedSystem: optional boolean to for right handed system computation\r\n     * * depthSort : optional boolean to enable the facet depth sort computation\r\n     * * distanceTo : optional Vector3 to compute the facet depth from this location\r\n     * * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location\r\n     * @param options.facetNormals\r\n     * @param options.facetPositions\r\n     * @param options.facetPartitioning\r\n     * @param options.ratio\r\n     * @param options.bInfo\r\n     * @param options.bbSize\r\n     * @param options.subDiv\r\n     * @param options.useRightHandedSystem\r\n     * @param options.depthSort\r\n     * @param options.distanceTo\r\n     * @param options.depthSortedFacets\r\n     */\r\n    public static ComputeNormals(\r\n        positions: any,\r\n        indices: any,\r\n        normals: any,\r\n        options?: {\r\n            facetNormals?: any;\r\n            facetPositions?: any;\r\n            facetPartitioning?: any;\r\n            ratio?: number;\r\n            bInfo?: any;\r\n            bbSize?: Vector3;\r\n            subDiv?: any;\r\n            useRightHandedSystem?: boolean;\r\n            depthSort?: boolean;\r\n            distanceTo?: Vector3;\r\n            depthSortedFacets?: any;\r\n        }\r\n    ): void {\r\n        // temporary scalar variables\r\n        let index = 0; // facet index\r\n        let p1p2x = 0.0; // p1p2 vector x coordinate\r\n        let p1p2y = 0.0; // p1p2 vector y coordinate\r\n        let p1p2z = 0.0; // p1p2 vector z coordinate\r\n        let p3p2x = 0.0; // p3p2 vector x coordinate\r\n        let p3p2y = 0.0; // p3p2 vector y coordinate\r\n        let p3p2z = 0.0; // p3p2 vector z coordinate\r\n        let faceNormalx = 0.0; // facet normal x coordinate\r\n        let faceNormaly = 0.0; // facet normal y coordinate\r\n        let faceNormalz = 0.0; // facet normal z coordinate\r\n        let length = 0.0; // facet normal length before normalization\r\n        let v1x = 0; // vector1 x index in the positions array\r\n        let v1y = 0; // vector1 y index in the positions array\r\n        let v1z = 0; // vector1 z index in the positions array\r\n        let v2x = 0; // vector2 x index in the positions array\r\n        let v2y = 0; // vector2 y index in the positions array\r\n        let v2z = 0; // vector2 z index in the positions array\r\n        let v3x = 0; // vector3 x index in the positions array\r\n        let v3y = 0; // vector3 y index in the positions array\r\n        let v3z = 0; // vector3 z index in the positions array\r\n        let computeFacetNormals = false;\r\n        let computeFacetPositions = false;\r\n        let computeFacetPartitioning = false;\r\n        let computeDepthSort = false;\r\n        let faceNormalSign = 1;\r\n        let ratio = 0;\r\n        let distanceTo: Nullable<Vector3> = null;\r\n        if (options) {\r\n            computeFacetNormals = options.facetNormals ? true : false;\r\n            computeFacetPositions = options.facetPositions ? true : false;\r\n            computeFacetPartitioning = options.facetPartitioning ? true : false;\r\n            faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;\r\n            ratio = options.ratio || 0;\r\n            computeDepthSort = options.depthSort ? true : false;\r\n            distanceTo = <Vector3>options.distanceTo;\r\n            if (computeDepthSort) {\r\n                if (distanceTo === undefined) {\r\n                    distanceTo = Vector3.Zero();\r\n                }\r\n            }\r\n        }\r\n\r\n        // facetPartitioning reinit if needed\r\n        let xSubRatio = 0;\r\n        let ySubRatio = 0;\r\n        let zSubRatio = 0;\r\n        let subSq = 0;\r\n        if (computeFacetPartitioning && options && options.bbSize) {\r\n            //let bbSizeMax = options.bbSize.x > options.bbSize.y ? options.bbSize.x : options.bbSize.y;\r\n            //bbSizeMax = bbSizeMax > options.bbSize.z ? bbSizeMax : options.bbSize.z;\r\n            xSubRatio = (options.subDiv.X * ratio) / options.bbSize.x;\r\n            ySubRatio = (options.subDiv.Y * ratio) / options.bbSize.y;\r\n            zSubRatio = (options.subDiv.Z * ratio) / options.bbSize.z;\r\n            subSq = options.subDiv.max * options.subDiv.max;\r\n            options.facetPartitioning.length = 0;\r\n        }\r\n\r\n        // reset the normals\r\n        for (index = 0; index < positions.length; index++) {\r\n            normals[index] = 0.0;\r\n        }\r\n\r\n        // Loop : 1 indice triplet = 1 facet\r\n        const nbFaces = (indices.length / 3) | 0;\r\n        for (index = 0; index < nbFaces; index++) {\r\n            // get the indexes of the coordinates of each vertex of the facet\r\n            v1x = indices[index * 3] * 3;\r\n            v1y = v1x + 1;\r\n            v1z = v1x + 2;\r\n            v2x = indices[index * 3 + 1] * 3;\r\n            v2y = v2x + 1;\r\n            v2z = v2x + 2;\r\n            v3x = indices[index * 3 + 2] * 3;\r\n            v3y = v3x + 1;\r\n            v3z = v3x + 2;\r\n\r\n            p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\r\n            p1p2y = positions[v1y] - positions[v2y];\r\n            p1p2z = positions[v1z] - positions[v2z];\r\n\r\n            p3p2x = positions[v3x] - positions[v2x];\r\n            p3p2y = positions[v3y] - positions[v2y];\r\n            p3p2z = positions[v3z] - positions[v2z];\r\n\r\n            // compute the face normal with the cross product\r\n            faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\r\n            faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\r\n            faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\r\n            // normalize this normal and store it in the array facetData\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            if (computeFacetNormals && options) {\r\n                options.facetNormals[index].x = faceNormalx;\r\n                options.facetNormals[index].y = faceNormaly;\r\n                options.facetNormals[index].z = faceNormalz;\r\n            }\r\n\r\n            if (computeFacetPositions && options) {\r\n                // compute and the facet barycenter coordinates in the array facetPositions\r\n                options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\r\n                options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\r\n                options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\r\n            }\r\n\r\n            if (computeFacetPartitioning && options) {\r\n                // store the facet indexes in arrays in the main facetPartitioning array :\r\n                // compute each facet vertex (+ facet barycenter) index in the partiniong array\r\n                const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n                const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);\r\n                const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);\r\n                const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);\r\n\r\n                const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\r\n                const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\r\n                const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\r\n                const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\r\n\r\n                options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\r\n                options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\r\n                options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\r\n                options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\r\n\r\n                // push each facet index in each block containing the vertex\r\n                options.facetPartitioning[block_idx_v1].push(index);\r\n                if (block_idx_v2 != block_idx_v1) {\r\n                    options.facetPartitioning[block_idx_v2].push(index);\r\n                }\r\n                if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\r\n                    options.facetPartitioning[block_idx_v3].push(index);\r\n                }\r\n                if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\r\n                    options.facetPartitioning[block_idx_o].push(index);\r\n                }\r\n            }\r\n\r\n            if (computeDepthSort && options && options.facetPositions) {\r\n                const dsf = options.depthSortedFacets[index];\r\n                dsf.ind = index * 3;\r\n                dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo!);\r\n            }\r\n\r\n            // compute the normals anyway\r\n            normals[v1x] += faceNormalx; // accumulate all the normals per face\r\n            normals[v1y] += faceNormaly;\r\n            normals[v1z] += faceNormalz;\r\n            normals[v2x] += faceNormalx;\r\n            normals[v2y] += faceNormaly;\r\n            normals[v2z] += faceNormalz;\r\n            normals[v3x] += faceNormalx;\r\n            normals[v3y] += faceNormaly;\r\n            normals[v3z] += faceNormalz;\r\n        }\r\n        // last normalization of each normal\r\n        for (index = 0; index < normals.length / 3; index++) {\r\n            faceNormalx = normals[index * 3];\r\n            faceNormaly = normals[index * 3 + 1];\r\n            faceNormalz = normals[index * 3 + 2];\r\n\r\n            length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\r\n            length = length === 0 ? 1.0 : length;\r\n            faceNormalx /= length;\r\n            faceNormaly /= length;\r\n            faceNormalz /= length;\r\n\r\n            normals[index * 3] = faceNormalx;\r\n            normals[index * 3 + 1] = faceNormaly;\r\n            normals[index * 3 + 2] = faceNormalz;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ComputeSides(\r\n        sideOrientation: number,\r\n        positions: FloatArray,\r\n        indices: FloatArray | IndicesArray,\r\n        normals: FloatArray,\r\n        uvs: FloatArray,\r\n        frontUVs?: Vector4,\r\n        backUVs?: Vector4\r\n    ) {\r\n        const li: number = indices.length;\r\n        const ln: number = normals.length;\r\n        let i: number;\r\n        let n: number;\r\n        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n        switch (sideOrientation) {\r\n            case VertexData.FRONTSIDE:\r\n                // nothing changed\r\n                break;\r\n\r\n            case VertexData.BACKSIDE:\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    const tmp = indices[i];\r\n                    indices[i] = indices[i + 2];\r\n                    indices[i + 2] = tmp;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[n] = -normals[n];\r\n                }\r\n                break;\r\n\r\n            case VertexData.DOUBLESIDE: {\r\n                // positions\r\n                const lp: number = positions.length;\r\n                const l: number = lp / 3;\r\n                for (let p = 0; p < lp; p++) {\r\n                    positions[lp + p] = positions[p];\r\n                }\r\n                // indices\r\n                for (i = 0; i < li; i += 3) {\r\n                    indices[i + li] = indices[i + 2] + l;\r\n                    indices[i + 1 + li] = indices[i + 1] + l;\r\n                    indices[i + 2 + li] = indices[i] + l;\r\n                }\r\n                // normals\r\n                for (n = 0; n < ln; n++) {\r\n                    normals[ln + n] = -normals[n];\r\n                }\r\n\r\n                // uvs\r\n                const lu: number = uvs.length;\r\n                let u: number = 0;\r\n                for (u = 0; u < lu; u++) {\r\n                    uvs[u + lu] = uvs[u];\r\n                }\r\n                frontUVs = frontUVs ? frontUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                backUVs = backUVs ? backUVs : new Vector4(0.0, 0.0, 1.0, 1.0);\r\n                u = 0;\r\n                for (i = 0; i < lu / 2; i++) {\r\n                    uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\r\n                    uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\r\n                    uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\r\n                    uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\r\n                    u += 2;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies VertexData created from the imported parameters to the geometry\r\n     * @param parsedVertexData the parsed data from an imported file\r\n     * @param geometry the geometry to apply the VertexData to\r\n     */\r\n    public static ImportVertexData(parsedVertexData: any, geometry: Geometry) {\r\n        const vertexData = new VertexData();\r\n\r\n        // positions\r\n        const positions = parsedVertexData.positions;\r\n        if (positions) {\r\n            vertexData.set(positions, VertexBuffer.PositionKind);\r\n        }\r\n\r\n        // normals\r\n        const normals = parsedVertexData.normals;\r\n        if (normals) {\r\n            vertexData.set(normals, VertexBuffer.NormalKind);\r\n        }\r\n\r\n        // tangents\r\n        const tangents = parsedVertexData.tangents;\r\n        if (tangents) {\r\n            vertexData.set(tangents, VertexBuffer.TangentKind);\r\n        }\r\n\r\n        // uvs\r\n        const uvs = parsedVertexData.uvs;\r\n        if (uvs) {\r\n            vertexData.set(uvs, VertexBuffer.UVKind);\r\n        }\r\n\r\n        // uv2s\r\n        const uv2s = parsedVertexData.uv2s;\r\n        if (uv2s) {\r\n            vertexData.set(uv2s, VertexBuffer.UV2Kind);\r\n        }\r\n\r\n        // uv3s\r\n        const uv3s = parsedVertexData.uv3s;\r\n        if (uv3s) {\r\n            vertexData.set(uv3s, VertexBuffer.UV3Kind);\r\n        }\r\n\r\n        // uv4s\r\n        const uv4s = parsedVertexData.uv4s;\r\n        if (uv4s) {\r\n            vertexData.set(uv4s, VertexBuffer.UV4Kind);\r\n        }\r\n\r\n        // uv5s\r\n        const uv5s = parsedVertexData.uv5s;\r\n        if (uv5s) {\r\n            vertexData.set(uv5s, VertexBuffer.UV5Kind);\r\n        }\r\n\r\n        // uv6s\r\n        const uv6s = parsedVertexData.uv6s;\r\n        if (uv6s) {\r\n            vertexData.set(uv6s, VertexBuffer.UV6Kind);\r\n        }\r\n\r\n        // colors\r\n        const colors = parsedVertexData.colors;\r\n        if (colors) {\r\n            vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);\r\n        }\r\n\r\n        // matricesIndices\r\n        const matricesIndices = parsedVertexData.matricesIndices;\r\n        if (matricesIndices) {\r\n            vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);\r\n        }\r\n\r\n        // matricesWeights\r\n        const matricesWeights = parsedVertexData.matricesWeights;\r\n        if (matricesWeights) {\r\n            vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);\r\n        }\r\n\r\n        // indices\r\n        const indices = parsedVertexData.indices;\r\n        if (indices) {\r\n            vertexData.indices = indices;\r\n        }\r\n\r\n        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}