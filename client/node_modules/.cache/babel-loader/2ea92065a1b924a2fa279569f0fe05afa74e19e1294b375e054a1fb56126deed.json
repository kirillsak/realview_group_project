{"ast":null,"code":"const growthFactor = 1.5;\n/**\n * A class acting as a dynamic float32array used in the performance viewer\n */\nexport class DynamicFloat32Array {\n  /**\n   * Creates a new DynamicFloat32Array with the desired item capacity.\n   * @param itemCapacity The initial item capacity you would like to set for the array.\n   */\n  constructor(itemCapacity) {\n    this._view = new Float32Array(itemCapacity);\n    this._itemLength = 0;\n  }\n  /**\n   * The number of items currently in the array.\n   */\n  get itemLength() {\n    return this._itemLength;\n  }\n  /**\n   * Gets value at index, NaN if no such index exists.\n   * @param index the index to get the value at.\n   * @returns the value at the index provided.\n   */\n  at(index) {\n    if (index < 0 || index >= this._itemLength) {\n      return NaN;\n    }\n    return this._view[index];\n  }\n  /**\n   * Gets a view of the original array from start to end (exclusive of end).\n   * @param start starting index.\n   * @param end ending index.\n   * @returns a subarray of the original array.\n   */\n  subarray(start, end) {\n    if (start >= end || start < 0) {\n      return new Float32Array(0);\n    }\n    if (end > this._itemLength) {\n      end = this._itemLength;\n    }\n    return this._view.subarray(start, end);\n  }\n  /**\n   * Pushes items to the end of the array.\n   * @param item The item to push into the array.\n   */\n  push(item) {\n    this._view[this._itemLength] = item;\n    this._itemLength++;\n    if (this._itemLength >= this._view.length) {\n      this._growArray();\n    }\n  }\n  /**\n   * Grows the array by the growth factor when necessary.\n   */\n  _growArray() {\n    const newCapacity = Math.floor(this._view.length * growthFactor);\n    const view = new Float32Array(newCapacity);\n    view.set(this._view);\n    this._view = view;\n  }\n}","map":{"version":3,"mappings":"AAAA,MAAMA,YAAY,GAAG,GAAG;AAExB;;;AAGA,OAAM,MAAOC,mBAAmB;EAI5B;;;;EAIAC,YAAYC,YAAoB;IAC5B,IAAI,CAACC,KAAK,GAAG,IAAIC,YAAY,CAACF,YAAY,CAAC;IAC3C,IAAI,CAACG,WAAW,GAAG,CAAC;EACxB;EAEA;;;EAGA,IAAWC,UAAU;IACjB,OAAO,IAAI,CAACD,WAAW;EAC3B;EAEA;;;;;EAKOE,EAAE,CAACC,KAAa;IACnB,IAAIA,KAAK,GAAG,CAAC,IAAIA,KAAK,IAAI,IAAI,CAACH,WAAW,EAAE;MACxC,OAAOI,GAAG;;IAGd,OAAO,IAAI,CAACN,KAAK,CAACK,KAAK,CAAC;EAC5B;EAEA;;;;;;EAMOE,QAAQ,CAACC,KAAa,EAAEC,GAAW;IACtC,IAAID,KAAK,IAAIC,GAAG,IAAID,KAAK,GAAG,CAAC,EAAE;MAC3B,OAAO,IAAIP,YAAY,CAAC,CAAC,CAAC;;IAG9B,IAAIQ,GAAG,GAAG,IAAI,CAACP,WAAW,EAAE;MACxBO,GAAG,GAAG,IAAI,CAACP,WAAW;;IAG1B,OAAO,IAAI,CAACF,KAAK,CAACO,QAAQ,CAACC,KAAK,EAAEC,GAAG,CAAC;EAC1C;EAEA;;;;EAIOC,IAAI,CAACC,IAAY;IACpB,IAAI,CAACX,KAAK,CAAC,IAAI,CAACE,WAAW,CAAC,GAAGS,IAAI;IACnC,IAAI,CAACT,WAAW,EAAE;IAClB,IAAI,IAAI,CAACA,WAAW,IAAI,IAAI,CAACF,KAAK,CAACY,MAAM,EAAE;MACvC,IAAI,CAACC,UAAU,EAAE;;EAEzB;EAEA;;;EAGQA,UAAU;IACd,MAAMC,WAAW,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAAChB,KAAK,CAACY,MAAM,GAAGhB,YAAY,CAAC;IAChE,MAAMqB,IAAI,GAAG,IAAIhB,YAAY,CAACa,WAAW,CAAC;IAC1CG,IAAI,CAACC,GAAG,CAAC,IAAI,CAAClB,KAAK,CAAC;IACpB,IAAI,CAACA,KAAK,GAAGiB,IAAI;EACrB","names":["growthFactor","DynamicFloat32Array","constructor","itemCapacity","_view","Float32Array","_itemLength","itemLength","at","index","NaN","subarray","start","end","push","item","length","_growArray","newCapacity","Math","floor","view","set"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/PerformanceViewer/dynamicFloat32Array.ts"],"sourcesContent":["const growthFactor = 1.5;\r\n\r\n/**\r\n * A class acting as a dynamic float32array used in the performance viewer\r\n */\r\nexport class DynamicFloat32Array {\r\n    private _view: Float32Array;\r\n    private _itemLength: number;\r\n\r\n    /**\r\n     * Creates a new DynamicFloat32Array with the desired item capacity.\r\n     * @param itemCapacity The initial item capacity you would like to set for the array.\r\n     */\r\n    constructor(itemCapacity: number) {\r\n        this._view = new Float32Array(itemCapacity);\r\n        this._itemLength = 0;\r\n    }\r\n\r\n    /**\r\n     * The number of items currently in the array.\r\n     */\r\n    public get itemLength(): number {\r\n        return this._itemLength;\r\n    }\r\n\r\n    /**\r\n     * Gets value at index, NaN if no such index exists.\r\n     * @param index the index to get the value at.\r\n     * @returns the value at the index provided.\r\n     */\r\n    public at(index: number): number {\r\n        if (index < 0 || index >= this._itemLength) {\r\n            return NaN;\r\n        }\r\n\r\n        return this._view[index];\r\n    }\r\n\r\n    /**\r\n     * Gets a view of the original array from start to end (exclusive of end).\r\n     * @param start starting index.\r\n     * @param end ending index.\r\n     * @returns a subarray of the original array.\r\n     */\r\n    public subarray(start: number, end: number): Float32Array {\r\n        if (start >= end || start < 0) {\r\n            return new Float32Array(0);\r\n        }\r\n\r\n        if (end > this._itemLength) {\r\n            end = this._itemLength;\r\n        }\r\n\r\n        return this._view.subarray(start, end);\r\n    }\r\n\r\n    /**\r\n     * Pushes items to the end of the array.\r\n     * @param item The item to push into the array.\r\n     */\r\n    public push(item: number) {\r\n        this._view[this._itemLength] = item;\r\n        this._itemLength++;\r\n        if (this._itemLength >= this._view.length) {\r\n            this._growArray();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Grows the array by the growth factor when necessary.\r\n     */\r\n    private _growArray() {\r\n        const newCapacity = Math.floor(this._view.length * growthFactor);\r\n        const view = new Float32Array(newCapacity);\r\n        view.set(this._view);\r\n        this._view = view;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}