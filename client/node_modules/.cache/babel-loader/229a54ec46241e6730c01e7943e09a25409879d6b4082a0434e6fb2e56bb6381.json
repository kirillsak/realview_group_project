{"ast":null,"code":"import \"core-js/modules/es.regexp.flags.js\";\nimport { Logger } from \"../Misc/logger.js\";\n//private static _TYPE_NO_DATA = 0;\nconst _TYPE_INDEXED = 1;\nconst _TYPE_RGB = 2;\nconst _TYPE_GREY = 3;\nconst _TYPE_RLE_INDEXED = 9;\nconst _TYPE_RLE_RGB = 10;\nconst _TYPE_RLE_GREY = 11;\nconst _ORIGIN_MASK = 0x30;\nconst _ORIGIN_SHIFT = 0x04;\nconst _ORIGIN_BL = 0x00;\nconst _ORIGIN_BR = 0x01;\nconst _ORIGIN_UL = 0x02;\nconst _ORIGIN_UR = 0x03;\n/**\n * Gets the header of a TGA file\n * @param data defines the TGA data\n * @returns the header\n */\nexport function GetTGAHeader(data) {\n  let offset = 0;\n  const header = {\n    id_length: data[offset++],\n    colormap_type: data[offset++],\n    image_type: data[offset++],\n    colormap_index: data[offset++] | data[offset++] << 8,\n    colormap_length: data[offset++] | data[offset++] << 8,\n    colormap_size: data[offset++],\n    origin: [data[offset++] | data[offset++] << 8, data[offset++] | data[offset++] << 8],\n    width: data[offset++] | data[offset++] << 8,\n    height: data[offset++] | data[offset++] << 8,\n    pixel_size: data[offset++],\n    flags: data[offset++]\n  };\n  return header;\n}\n/**\n * Uploads TGA content to a Babylon Texture\n * @internal\n */\nexport function UploadContent(texture, data) {\n  // Not enough data to contain header ?\n  if (data.length < 19) {\n    Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\n    return;\n  }\n  // Read Header\n  let offset = 18;\n  const header = GetTGAHeader(data);\n  // Assume it's a valid Targa file.\n  if (header.id_length + offset > data.length) {\n    Logger.Error(\"Unable to load TGA file - Not enough data\");\n    return;\n  }\n  // Skip not needed data\n  offset += header.id_length;\n  let use_rle = false;\n  let use_pal = false;\n  let use_grey = false;\n  // Get some informations.\n  switch (header.image_type) {\n    case _TYPE_RLE_INDEXED:\n      use_rle = true;\n    // eslint-disable-next-line no-fallthrough\n    case _TYPE_INDEXED:\n      use_pal = true;\n      break;\n    case _TYPE_RLE_RGB:\n      use_rle = true;\n    // eslint-disable-next-line no-fallthrough\n    case _TYPE_RGB:\n      // use_rgb = true;\n      break;\n    case _TYPE_RLE_GREY:\n      use_rle = true;\n    // eslint-disable-next-line no-fallthrough\n    case _TYPE_GREY:\n      use_grey = true;\n      break;\n  }\n  let pixel_data;\n  // var numAlphaBits = header.flags & 0xf;\n  const pixel_size = header.pixel_size >> 3;\n  const pixel_total = header.width * header.height * pixel_size;\n  // Read palettes\n  let palettes;\n  if (use_pal) {\n    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n  }\n  // Read LRE\n  if (use_rle) {\n    pixel_data = new Uint8Array(pixel_total);\n    let c, count, i;\n    let localOffset = 0;\n    const pixels = new Uint8Array(pixel_size);\n    while (offset < pixel_total && localOffset < pixel_total) {\n      c = data[offset++];\n      count = (c & 0x7f) + 1;\n      // RLE pixels\n      if (c & 0x80) {\n        // Bind pixel tmp array\n        for (i = 0; i < pixel_size; ++i) {\n          pixels[i] = data[offset++];\n        }\n        // Copy pixel array\n        for (i = 0; i < count; ++i) {\n          pixel_data.set(pixels, localOffset + i * pixel_size);\n        }\n        localOffset += pixel_size * count;\n      }\n      // Raw pixels\n      else {\n        count *= pixel_size;\n        for (i = 0; i < count; ++i) {\n          pixel_data[localOffset + i] = data[offset++];\n        }\n        localOffset += count;\n      }\n    }\n  }\n  // RAW Pixels\n  else {\n    pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n  }\n  // Load to texture\n  let x_start, y_start, x_step, y_step, y_end, x_end;\n  switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {\n    default:\n    case _ORIGIN_UL:\n      x_start = 0;\n      x_step = 1;\n      x_end = header.width;\n      y_start = 0;\n      y_step = 1;\n      y_end = header.height;\n      break;\n    case _ORIGIN_BL:\n      x_start = 0;\n      x_step = 1;\n      x_end = header.width;\n      y_start = header.height - 1;\n      y_step = -1;\n      y_end = -1;\n      break;\n    case _ORIGIN_UR:\n      x_start = header.width - 1;\n      x_step = -1;\n      x_end = -1;\n      y_start = 0;\n      y_step = 1;\n      y_end = header.height;\n      break;\n    case _ORIGIN_BR:\n      x_start = header.width - 1;\n      x_step = -1;\n      x_end = -1;\n      y_start = header.height - 1;\n      y_step = -1;\n      y_end = -1;\n      break;\n  }\n  // Load the specify method\n  const func = \"_getImageData\" + (use_grey ? \"Grey\" : \"\") + header.pixel_size + \"bits\";\n  const imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\n  const engine = texture.getEngine();\n  engine._uploadDataToTextureDirectly(texture, imageData);\n}\n/**\n * @internal\n */\nfunction _getImageData8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data,\n    colormap = palettes;\n  const width = header.width,\n    height = header.height;\n  let color,\n    i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i++) {\n      color = image[i];\n      imageData[(x + width * y) * 4 + 3] = 255;\n      imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n      imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n      imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let color,\n    i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 2) {\n      color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n      const r = ((color & 0x7c00) >> 10) * 255 / 0x1f | 0;\n      const g = ((color & 0x03e0) >> 5) * 255 / 0x1f | 0;\n      const b = (color & 0x001f) * 255 / 0x1f | 0;\n      imageData[(x + width * y) * 4 + 0] = r;\n      imageData[(x + width * y) * 4 + 1] = g;\n      imageData[(x + width * y) * 4 + 2] = b;\n      imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData24bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 3) {\n      imageData[(x + width * y) * 4 + 3] = 255;\n      imageData[(x + width * y) * 4 + 2] = image[i + 0];\n      imageData[(x + width * y) * 4 + 1] = image[i + 1];\n      imageData[(x + width * y) * 4 + 0] = image[i + 2];\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageData32bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 4) {\n      imageData[(x + width * y) * 4 + 2] = image[i + 0];\n      imageData[(x + width * y) * 4 + 1] = image[i + 1];\n      imageData[(x + width * y) * 4 + 0] = image[i + 2];\n      imageData[(x + width * y) * 4 + 3] = image[i + 3];\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageDataGrey8bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let color,\n    i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i++) {\n      color = image[i];\n      imageData[(x + width * y) * 4 + 0] = color;\n      imageData[(x + width * y) * 4 + 1] = color;\n      imageData[(x + width * y) * 4 + 2] = color;\n      imageData[(x + width * y) * 4 + 3] = 255;\n    }\n  }\n  return imageData;\n}\n/**\n * @internal\n */\nfunction _getImageDataGrey16bits(header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n  const image = pixel_data;\n  const width = header.width,\n    height = header.height;\n  let i = 0,\n    x,\n    y;\n  const imageData = new Uint8Array(width * height * 4);\n  for (y = y_start; y !== y_end; y += y_step) {\n    for (x = x_start; x !== x_end; x += x_step, i += 2) {\n      imageData[(x + width * y) * 4 + 0] = image[i + 0];\n      imageData[(x + width * y) * 4 + 1] = image[i + 0];\n      imageData[(x + width * y) * 4 + 2] = image[i + 0];\n      imageData[(x + width * y) * 4 + 3] = image[i + 1];\n    }\n  }\n  return imageData;\n}\n/**\n * Based on jsTGALoader - Javascript loader for TGA file\n * By Vincent Thibault\n * @see http://blog.robrowser.com/javascript-tga-loader.html\n */\nexport const TGATools = {\n  /**\n   * Gets the header of a TGA file\n   * @param data defines the TGA data\n   * @returns the header\n   */\n  GetTGAHeader,\n  /**\n   * Uploads TGA content to a Babylon Texture\n   * @internal\n   */\n  UploadContent,\n  /** @internal */\n  _getImageData8bits,\n  /** @internal */\n  _getImageData16bits,\n  /** @internal */\n  _getImageData24bits,\n  /** @internal */\n  _getImageData32bits,\n  /** @internal */\n  _getImageDataGrey8bits,\n  /** @internal */\n  _getImageDataGrey16bits\n};","map":{"version":3,"mappings":"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","names":["Logger","_TYPE_INDEXED","_TYPE_RGB","_TYPE_GREY","_TYPE_RLE_INDEXED","_TYPE_RLE_RGB","_TYPE_RLE_GREY","_ORIGIN_MASK","_ORIGIN_SHIFT","_ORIGIN_BL","_ORIGIN_BR","_ORIGIN_UL","_ORIGIN_UR","GetTGAHeader","data","offset","header","id_length","colormap_type","image_type","colormap_index","colormap_length","colormap_size","origin","width","height","pixel_size","flags","UploadContent","texture","length","Error","use_rle","use_pal","use_grey","pixel_data","pixel_total","palettes","subarray","Uint8Array","c","count","i","localOffset","pixels","set","x_start","y_start","x_step","y_step","y_end","x_end","func","imageData","TGATools","engine","getEngine","_uploadDataToTextureDirectly","_getImageData8bits","image","colormap","color","x","y","_getImageData16bits","r","g","b","_getImageData24bits","_getImageData32bits","_getImageDataGrey8bits","_getImageDataGrey16bits"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/tga.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n//private static _TYPE_NO_DATA = 0;\r\nconst _TYPE_INDEXED = 1;\r\nconst _TYPE_RGB = 2;\r\nconst _TYPE_GREY = 3;\r\nconst _TYPE_RLE_INDEXED = 9;\r\nconst _TYPE_RLE_RGB = 10;\r\nconst _TYPE_RLE_GREY = 11;\r\nconst _ORIGIN_MASK = 0x30;\r\nconst _ORIGIN_SHIFT = 0x04;\r\nconst _ORIGIN_BL = 0x00;\r\nconst _ORIGIN_BR = 0x01;\r\nconst _ORIGIN_UL = 0x02;\r\nconst _ORIGIN_UR = 0x03;\r\n\r\n/**\r\n * Gets the header of a TGA file\r\n * @param data defines the TGA data\r\n * @returns the header\r\n */\r\nexport function GetTGAHeader(data: Uint8Array): any {\r\n    let offset = 0;\r\n\r\n    const header = {\r\n        id_length: data[offset++],\r\n        colormap_type: data[offset++],\r\n        image_type: data[offset++],\r\n        colormap_index: data[offset++] | (data[offset++] << 8),\r\n        colormap_length: data[offset++] | (data[offset++] << 8),\r\n        colormap_size: data[offset++],\r\n        origin: [data[offset++] | (data[offset++] << 8), data[offset++] | (data[offset++] << 8)],\r\n        width: data[offset++] | (data[offset++] << 8),\r\n        height: data[offset++] | (data[offset++] << 8),\r\n        pixel_size: data[offset++],\r\n        flags: data[offset++],\r\n    };\r\n\r\n    return header;\r\n}\r\n\r\n/**\r\n * Uploads TGA content to a Babylon Texture\r\n * @internal\r\n */\r\nexport function UploadContent(texture: InternalTexture, data: Uint8Array): void {\r\n    // Not enough data to contain header ?\r\n    if (data.length < 19) {\r\n        Logger.Error(\"Unable to load TGA file - Not enough data to contain header\");\r\n        return;\r\n    }\r\n\r\n    // Read Header\r\n    let offset = 18;\r\n    const header = GetTGAHeader(data);\r\n\r\n    // Assume it's a valid Targa file.\r\n    if (header.id_length + offset > data.length) {\r\n        Logger.Error(\"Unable to load TGA file - Not enough data\");\r\n        return;\r\n    }\r\n\r\n    // Skip not needed data\r\n    offset += header.id_length;\r\n\r\n    let use_rle = false;\r\n    let use_pal = false;\r\n    let use_grey = false;\r\n\r\n    // Get some informations.\r\n    switch (header.image_type) {\r\n        case _TYPE_RLE_INDEXED:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_INDEXED:\r\n            use_pal = true;\r\n            break;\r\n\r\n        case _TYPE_RLE_RGB:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_RGB:\r\n            // use_rgb = true;\r\n            break;\r\n\r\n        case _TYPE_RLE_GREY:\r\n            use_rle = true;\r\n        // eslint-disable-next-line no-fallthrough\r\n        case _TYPE_GREY:\r\n            use_grey = true;\r\n            break;\r\n    }\r\n\r\n    let pixel_data;\r\n\r\n    // var numAlphaBits = header.flags & 0xf;\r\n    const pixel_size = header.pixel_size >> 3;\r\n    const pixel_total = header.width * header.height * pixel_size;\r\n\r\n    // Read palettes\r\n    let palettes;\r\n\r\n    if (use_pal) {\r\n        palettes = data.subarray(offset, (offset += header.colormap_length * (header.colormap_size >> 3)));\r\n    }\r\n\r\n    // Read LRE\r\n    if (use_rle) {\r\n        pixel_data = new Uint8Array(pixel_total);\r\n\r\n        let c, count, i;\r\n        let localOffset = 0;\r\n        const pixels = new Uint8Array(pixel_size);\r\n\r\n        while (offset < pixel_total && localOffset < pixel_total) {\r\n            c = data[offset++];\r\n            count = (c & 0x7f) + 1;\r\n\r\n            // RLE pixels\r\n            if (c & 0x80) {\r\n                // Bind pixel tmp array\r\n                for (i = 0; i < pixel_size; ++i) {\r\n                    pixels[i] = data[offset++];\r\n                }\r\n\r\n                // Copy pixel array\r\n                for (i = 0; i < count; ++i) {\r\n                    pixel_data.set(pixels, localOffset + i * pixel_size);\r\n                }\r\n\r\n                localOffset += pixel_size * count;\r\n            }\r\n            // Raw pixels\r\n            else {\r\n                count *= pixel_size;\r\n                for (i = 0; i < count; ++i) {\r\n                    pixel_data[localOffset + i] = data[offset++];\r\n                }\r\n                localOffset += count;\r\n            }\r\n        }\r\n    }\r\n    // RAW Pixels\r\n    else {\r\n        pixel_data = data.subarray(offset, (offset += use_pal ? header.width * header.height : pixel_total));\r\n    }\r\n\r\n    // Load to texture\r\n    let x_start, y_start, x_step, y_step, y_end, x_end;\r\n\r\n    switch ((header.flags & _ORIGIN_MASK) >> _ORIGIN_SHIFT) {\r\n        default:\r\n        case _ORIGIN_UL:\r\n            x_start = 0;\r\n            x_step = 1;\r\n            x_end = header.width;\r\n            y_start = 0;\r\n            y_step = 1;\r\n            y_end = header.height;\r\n            break;\r\n\r\n        case _ORIGIN_BL:\r\n            x_start = 0;\r\n            x_step = 1;\r\n            x_end = header.width;\r\n            y_start = header.height - 1;\r\n            y_step = -1;\r\n            y_end = -1;\r\n            break;\r\n\r\n        case _ORIGIN_UR:\r\n            x_start = header.width - 1;\r\n            x_step = -1;\r\n            x_end = -1;\r\n            y_start = 0;\r\n            y_step = 1;\r\n            y_end = header.height;\r\n            break;\r\n\r\n        case _ORIGIN_BR:\r\n            x_start = header.width - 1;\r\n            x_step = -1;\r\n            x_end = -1;\r\n            y_start = header.height - 1;\r\n            y_step = -1;\r\n            y_end = -1;\r\n            break;\r\n    }\r\n\r\n    // Load the specify method\r\n    const func = \"_getImageData\" + (use_grey ? \"Grey\" : \"\") + header.pixel_size + \"bits\";\r\n    const imageData = (<any>TGATools)[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\r\n\r\n    const engine = texture.getEngine();\r\n    engine._uploadDataToTextureDirectly(texture, imageData);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData8bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data,\r\n        colormap = palettes;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n            color = image[i];\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\r\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\r\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData16bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\r\n            const r = ((((color & 0x7c00) >> 10) * 255) / 0x1f) | 0;\r\n            const g = ((((color & 0x03e0) >> 5) * 255) / 0x1f) | 0;\r\n            const b = (((color & 0x001f) * 255) / 0x1f) | 0;\r\n\r\n            imageData[(x + width * y) * 4 + 0] = r;\r\n            imageData[(x + width * y) * 4 + 1] = g;\r\n            imageData[(x + width * y) * 4 + 2] = b;\r\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData24bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageData32bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageDataGrey8bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let color,\r\n        i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n            color = image[i];\r\n            imageData[(x + width * y) * 4 + 0] = color;\r\n            imageData[(x + width * y) * 4 + 1] = color;\r\n            imageData[(x + width * y) * 4 + 2] = color;\r\n            imageData[(x + width * y) * 4 + 3] = 255;\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nfunction _getImageDataGrey16bits(\r\n    header: any,\r\n    palettes: Uint8Array,\r\n    pixel_data: Uint8Array,\r\n    y_start: number,\r\n    y_step: number,\r\n    y_end: number,\r\n    x_start: number,\r\n    x_step: number,\r\n    x_end: number\r\n): Uint8Array {\r\n    const image = pixel_data;\r\n    const width = header.width,\r\n        height = header.height;\r\n    let i = 0,\r\n        x,\r\n        y;\r\n\r\n    const imageData = new Uint8Array(width * height * 4);\r\n\r\n    for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Based on jsTGALoader - Javascript loader for TGA file\r\n * By Vincent Thibault\r\n * @see http://blog.robrowser.com/javascript-tga-loader.html\r\n */\r\nexport const TGATools = {\r\n    /**\r\n     * Gets the header of a TGA file\r\n     * @param data defines the TGA data\r\n     * @returns the header\r\n     */\r\n    GetTGAHeader,\r\n\r\n    /**\r\n     * Uploads TGA content to a Babylon Texture\r\n     * @internal\r\n     */\r\n    UploadContent,\r\n\r\n    /** @internal */\r\n    _getImageData8bits,\r\n\r\n    /** @internal */\r\n    _getImageData16bits,\r\n    /** @internal */\r\n    _getImageData24bits,\r\n\r\n    /** @internal */\r\n    _getImageData32bits,\r\n\r\n    /** @internal */\r\n    _getImageDataGrey8bits,\r\n    /** @internal */\r\n    _getImageDataGrey16bits,\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}