{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\n// License for the mipmap generation code:\n//\n// Copyright 2020 Brandon Jones\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture.js\";\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture.js\";\n// TODO WEBGPU improve mipmap generation by using compute shaders\n// TODO WEBGPU use WGSL instead of GLSL\nconst mipmapVertexSource = `\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\n\n    layout(location = 0) out vec2 vTex;\n\n    void main() {\n        vTex = tex[gl_VertexIndex];\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n    }\n    `;\nconst mipmapFragmentSource = `\n    layout(set = 0, binding = 0) uniform sampler imgSampler;\n    layout(set = 0, binding = 1) uniform texture2D img;\n\n    layout(location = 0) in vec2 vTex;\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        outColor = texture(sampler2D(img, imgSampler), vTex);\n    }\n    `;\nconst invertYPreMultiplyAlphaVertexSource = `\n    #extension GL_EXT_samplerless_texture_functions : enable\n\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\n\n    layout(set = 0, binding = 0) uniform texture2D img;\n\n    #ifdef INVERTY\n        layout(location = 0) out flat ivec2 vTextureSize;\n    #endif\n\n    void main() {\n        #ifdef INVERTY\n            vTextureSize = textureSize(img, 0);\n        #endif\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n    }\n    `;\nconst invertYPreMultiplyAlphaFragmentSource = `\n    #extension GL_EXT_samplerless_texture_functions : enable\n\n    layout(set = 0, binding = 0) uniform texture2D img;\n\n    #ifdef INVERTY\n        layout(location = 0) in flat ivec2 vTextureSize;\n    #endif\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n    #ifdef INVERTY\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, vTextureSize.y - gl_FragCoord.y), 0);\n    #else\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\n    #endif\n    #ifdef PREMULTIPLYALPHA\n        color.rgb *= color.a;\n    #endif\n        outColor = color;\n    }\n    `;\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\n    #extension GL_EXT_samplerless_texture_functions : enable\n\n    layout(set = 0, binding = 0) uniform texture2D img;\n    layout(set = 0, binding = 1) uniform Params {\n        float ofstX;\n        float ofstY;\n        float width;\n        float height;\n    };\n\n    #ifdef INVERTY\n        layout(location = 0) in flat ivec2 vTextureSize;\n    #endif\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        if (gl_FragCoord.x < ofstX || gl_FragCoord.x >= ofstX + width) {\n            discard;\n        }\n        if (gl_FragCoord.y < ofstY || gl_FragCoord.y >= ofstY + height) {\n            discard;\n        }\n    #ifdef INVERTY\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, ofstY + height - (gl_FragCoord.y - ofstY)), 0);\n    #else\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\n    #endif\n    #ifdef PREMULTIPLYALPHA\n        color.rgb *= color.a;\n    #endif\n        outColor = color;\n    }\n    `;\nconst clearVertexSource = `\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\n\n    void main() {\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n    }\n    `;\nconst clearFragmentSource = `\n    layout(set = 0, binding = 0) uniform Uniforms {\n        uniform vec4 color;\n    };\n\n    layout(location = 0) out vec4 outColor;\n\n    void main() {\n        outColor = color;\n    }\n    `;\nconst copyVideoToTextureVertexSource = `\n    struct VertexOutput {\n        @builtin(position) Position : vec4<f32>,\n        @location(0) fragUV : vec2<f32>\n    }\n  \n    @vertex\n    fn main(\n        @builtin(vertex_index) VertexIndex : u32\n    ) -> VertexOutput {\n        var pos = array<vec2<f32>, 4>(\n            vec2(-1.0,  1.0),\n            vec2( 1.0,  1.0),\n            vec2(-1.0, -1.0),\n            vec2( 1.0, -1.0)\n        );\n        var tex = array<vec2<f32>, 4>(\n            vec2(0.0, 0.0),\n            vec2(1.0, 0.0),\n            vec2(0.0, 1.0),\n            vec2(1.0, 1.0)\n        );\n\n        var output: VertexOutput;\n\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n        output.fragUV = tex[VertexIndex];\n\n        return output;\n    }\n    `;\nconst copyVideoToTextureFragmentSource = `\n    @group(0) @binding(0) var videoSampler: sampler;\n    @group(0) @binding(1) var videoTexture: texture_external;\n\n    @fragment\n    fn main(\n        @location(0) fragUV: vec2<f32>\n    ) -> @location(0) vec4<f32> {\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\n    }\n    `;\nconst copyVideoToTextureInvertYFragmentSource = `\n    @group(0) @binding(0) var videoSampler: sampler;\n    @group(0) @binding(1) var videoTexture: texture_external;\n\n    @fragment\n    fn main(\n        @location(0) fragUV: vec2<f32>\n    ) -> @location(0) vec4<f32> {\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\n    }\n    `;\nvar PipelineType;\n(function (PipelineType) {\n  PipelineType[PipelineType[\"MipMap\"] = 0] = \"MipMap\";\n  PipelineType[PipelineType[\"InvertYPremultiplyAlpha\"] = 1] = \"InvertYPremultiplyAlpha\";\n  PipelineType[PipelineType[\"Clear\"] = 2] = \"Clear\";\n  PipelineType[PipelineType[\"InvertYPremultiplyAlphaWithOfst\"] = 3] = \"InvertYPremultiplyAlphaWithOfst\";\n})(PipelineType || (PipelineType = {}));\nvar VideoPipelineType;\n(function (VideoPipelineType) {\n  VideoPipelineType[VideoPipelineType[\"DontInvertY\"] = 0] = \"DontInvertY\";\n  VideoPipelineType[VideoPipelineType[\"InvertY\"] = 1] = \"InvertY\";\n})(VideoPipelineType || (VideoPipelineType = {}));\nconst shadersForPipelineType = [{\n  vertex: mipmapVertexSource,\n  fragment: mipmapFragmentSource\n}, {\n  vertex: invertYPreMultiplyAlphaVertexSource,\n  fragment: invertYPreMultiplyAlphaFragmentSource\n}, {\n  vertex: clearVertexSource,\n  fragment: clearFragmentSource\n}, {\n  vertex: invertYPreMultiplyAlphaWithOfstVertexSource,\n  fragment: invertYPreMultiplyAlphaWithOfstFragmentSource\n}];\n/**\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\n */\nexport const renderableTextureFormatToIndex = {\n  \"\": 0,\n  r8unorm: 1,\n  r8uint: 2,\n  r8sint: 3,\n  r16uint: 4,\n  r16sint: 5,\n  r16float: 6,\n  rg8unorm: 7,\n  rg8uint: 8,\n  rg8sint: 9,\n  r32uint: 10,\n  r32sint: 11,\n  r32float: 12,\n  rg16uint: 13,\n  rg16sint: 14,\n  rg16float: 15,\n  rgba8unorm: 16,\n  \"rgba8unorm-srgb\": 17,\n  rgba8uint: 18,\n  rgba8sint: 19,\n  bgra8unorm: 20,\n  \"bgra8unorm-srgb\": 21,\n  rgb10a2unorm: 22,\n  rg32uint: 23,\n  rg32sint: 24,\n  rg32float: 25,\n  rgba16uint: 26,\n  rgba16sint: 27,\n  rgba16float: 28,\n  rgba32uint: 29,\n  rgba32sint: 30,\n  rgba32float: 31,\n  stencil8: 32,\n  depth16unorm: 33,\n  depth24plus: 34,\n  \"depth24plus-stencil8\": 35,\n  depth32float: 36,\n  \"depth24unorm-stencil8\": 37,\n  \"depth32float-stencil8\": 38\n};\n/** @internal */\nexport class WebGPUTextureHelper {\n  //------------------------------------------------------------------------------\n  //                         Initialization / Helpers\n  //------------------------------------------------------------------------------\n  constructor(device, glslang, tintWASM, bufferManager) {\n    this._pipelines = {};\n    this._compiledShaders = [];\n    this._videoPipelines = {};\n    this._videoCompiledShaders = [];\n    this._deferredReleaseTextures = [];\n    this._device = device;\n    this._glslang = glslang;\n    this._tintWASM = tintWASM;\n    this._bufferManager = bufferManager;\n    this._mipmapSampler = device.createSampler({\n      minFilter: WebGPUConstants.FilterMode.Linear\n    });\n    this._videoSampler = device.createSampler({\n      minFilter: WebGPUConstants.FilterMode.Linear\n    });\n    this._ubCopyWithOfst = this._bufferManager.createBuffer(4 * 4, WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst).underlyingResource;\n    this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\n    this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\n  }\n  static ComputeNumMipmapLevels(width, height) {\n    return Scalar.ILog2(Math.max(width, height)) + 1;\n  }\n  _getPipeline(format, type = PipelineType.MipMap, params) {\n    const index = type === PipelineType.MipMap ? 1 << 0 : type === PipelineType.InvertYPremultiplyAlpha ? ((params.invertY ? 1 : 0) << 1) + ((params.premultiplyAlpha ? 1 : 0) << 2) : type === PipelineType.Clear ? 1 << 3 : type === PipelineType.InvertYPremultiplyAlphaWithOfst ? ((params.invertY ? 1 : 0) << 4) + ((params.premultiplyAlpha ? 1 : 0) << 5) : 0;\n    if (!this._pipelines[format]) {\n      this._pipelines[format] = [];\n    }\n    let pipelineAndBGL = this._pipelines[format][index];\n    if (!pipelineAndBGL) {\n      let defines = \"#version 450\\r\\n\";\n      if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\n        if (params.invertY) {\n          defines += \"#define INVERTY\\r\\n\";\n        }\n        if (params.premultiplyAlpha) {\n          defines += \"#define PREMULTIPLYALPHA\\r\\n\";\n        }\n      }\n      let modules = this._compiledShaders[index];\n      if (!modules) {\n        let vertexCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].vertex, \"vertex\");\n        let fragmentCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].fragment, \"fragment\");\n        if (this._tintWASM) {\n          vertexCode = this._tintWASM.convertSpirV2WGSL(vertexCode);\n          fragmentCode = this._tintWASM.convertSpirV2WGSL(fragmentCode);\n        }\n        const vertexModule = this._device.createShaderModule({\n          code: vertexCode\n        });\n        const fragmentModule = this._device.createShaderModule({\n          code: fragmentCode\n        });\n        modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\n      }\n      const pipeline = this._device.createRenderPipeline({\n        layout: WebGPUConstants.AutoLayoutMode.Auto,\n        vertex: {\n          module: modules[0],\n          entryPoint: \"main\"\n        },\n        fragment: {\n          module: modules[1],\n          entryPoint: \"main\",\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\n          stripIndexFormat: WebGPUConstants.IndexFormat.Uint16\n        }\n      });\n      pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\n    }\n    return pipelineAndBGL;\n  }\n  _getVideoPipeline(format, type = VideoPipelineType.DontInvertY) {\n    const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\n    if (!this._videoPipelines[format]) {\n      this._videoPipelines[format] = [];\n    }\n    let pipelineAndBGL = this._videoPipelines[format][index];\n    if (!pipelineAndBGL) {\n      let modules = this._videoCompiledShaders[index];\n      if (!modules) {\n        const vertexModule = this._device.createShaderModule({\n          code: copyVideoToTextureVertexSource\n        });\n        const fragmentModule = this._device.createShaderModule({\n          code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource\n        });\n        modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\n      }\n      const pipeline = this._device.createRenderPipeline({\n        label: `CopyVideoToTexture_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\n        layout: WebGPUConstants.AutoLayoutMode.Auto,\n        vertex: {\n          module: modules[0],\n          entryPoint: \"main\"\n        },\n        fragment: {\n          module: modules[1],\n          entryPoint: \"main\",\n          targets: [{\n            format\n          }]\n        },\n        primitive: {\n          topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\n          stripIndexFormat: WebGPUConstants.IndexFormat.Uint16\n        }\n      });\n      pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\n    }\n    return pipelineAndBGL;\n  }\n  static _GetTextureTypeFromFormat(format) {\n    switch (format) {\n      // One Component = 8 bits\n      case WebGPUConstants.TextureFormat.R8Unorm:\n      case WebGPUConstants.TextureFormat.R8Snorm:\n      case WebGPUConstants.TextureFormat.R8Uint:\n      case WebGPUConstants.TextureFormat.R8Sint:\n      case WebGPUConstants.TextureFormat.RG8Unorm:\n      case WebGPUConstants.TextureFormat.RG8Snorm:\n      case WebGPUConstants.TextureFormat.RG8Uint:\n      case WebGPUConstants.TextureFormat.RG8Sint:\n      case WebGPUConstants.TextureFormat.RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.RGBA8Snorm:\n      case WebGPUConstants.TextureFormat.RGBA8Uint:\n      case WebGPUConstants.TextureFormat.RGBA8Sint:\n      case WebGPUConstants.TextureFormat.BGRA8Unorm:\n      case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.Depth24UnormStencil8: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.Depth32FloatStencil8: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\n      case WebGPUConstants.TextureFormat.BC6HRGBFloat:\n      case WebGPUConstants.TextureFormat.BC5RGUnorm:\n      case WebGPUConstants.TextureFormat.BC5RGSnorm:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC4RUnorm:\n      case WebGPUConstants.TextureFormat.BC4RSnorm:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.EACR11Unorm:\n      case WebGPUConstants.TextureFormat.EACR11Snorm:\n      case WebGPUConstants.TextureFormat.EACRG11Unorm:\n      case WebGPUConstants.TextureFormat.EACRG11Snorm:\n      case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\n        return 0;\n      // One component = 16 bits\n      case WebGPUConstants.TextureFormat.R16Uint:\n      case WebGPUConstants.TextureFormat.R16Sint:\n      case WebGPUConstants.TextureFormat.RG16Uint:\n      case WebGPUConstants.TextureFormat.RG16Sint:\n      case WebGPUConstants.TextureFormat.RGBA16Uint:\n      case WebGPUConstants.TextureFormat.RGBA16Sint:\n      case WebGPUConstants.TextureFormat.Depth16Unorm:\n        return 5;\n      case WebGPUConstants.TextureFormat.R16Float:\n      case WebGPUConstants.TextureFormat.RG16Float:\n      case WebGPUConstants.TextureFormat.RGBA16Float:\n        return 2;\n      // One component = 32 bits\n      case WebGPUConstants.TextureFormat.R32Uint:\n      case WebGPUConstants.TextureFormat.R32Sint:\n      case WebGPUConstants.TextureFormat.RG32Uint:\n      case WebGPUConstants.TextureFormat.RG32Sint:\n      case WebGPUConstants.TextureFormat.RGBA32Uint:\n      case WebGPUConstants.TextureFormat.RGBA32Sint:\n        return 7;\n      case WebGPUConstants.TextureFormat.R32Float:\n      case WebGPUConstants.TextureFormat.RG32Float:\n      case WebGPUConstants.TextureFormat.RGBA32Float:\n      case WebGPUConstants.TextureFormat.Depth32Float:\n        return 1;\n      case WebGPUConstants.TextureFormat.Stencil8:\n        throw \"No fixed size for Stencil8 format!\";\n      case WebGPUConstants.TextureFormat.Depth24Plus:\n        throw \"No fixed size for Depth24Plus format!\";\n      case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\n        throw \"No fixed size for Depth24PlusStencil8 format!\";\n    }\n    return 0;\n  }\n  static _GetBlockInformationFromFormat(format) {\n    switch (format) {\n      // 8 bits formats\n      case WebGPUConstants.TextureFormat.R8Unorm:\n      case WebGPUConstants.TextureFormat.R8Snorm:\n      case WebGPUConstants.TextureFormat.R8Uint:\n      case WebGPUConstants.TextureFormat.R8Sint:\n        return {\n          width: 1,\n          height: 1,\n          length: 1\n        };\n      // 16 bits formats\n      case WebGPUConstants.TextureFormat.R16Uint:\n      case WebGPUConstants.TextureFormat.R16Sint:\n      case WebGPUConstants.TextureFormat.R16Float:\n      case WebGPUConstants.TextureFormat.RG8Unorm:\n      case WebGPUConstants.TextureFormat.RG8Snorm:\n      case WebGPUConstants.TextureFormat.RG8Uint:\n      case WebGPUConstants.TextureFormat.RG8Sint:\n        return {\n          width: 1,\n          height: 1,\n          length: 2\n        };\n      // 32 bits formats\n      case WebGPUConstants.TextureFormat.R32Uint:\n      case WebGPUConstants.TextureFormat.R32Sint:\n      case WebGPUConstants.TextureFormat.R32Float:\n      case WebGPUConstants.TextureFormat.RG16Uint:\n      case WebGPUConstants.TextureFormat.RG16Sint:\n      case WebGPUConstants.TextureFormat.RG16Float:\n      case WebGPUConstants.TextureFormat.RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.RGBA8Snorm:\n      case WebGPUConstants.TextureFormat.RGBA8Uint:\n      case WebGPUConstants.TextureFormat.RGBA8Sint:\n      case WebGPUConstants.TextureFormat.BGRA8Unorm:\n      case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.RGB9E5UFloat:\n      case WebGPUConstants.TextureFormat.RGB10A2Unorm:\n      case WebGPUConstants.TextureFormat.RG11B10UFloat:\n        return {\n          width: 1,\n          height: 1,\n          length: 4\n        };\n      // 64 bits formats\n      case WebGPUConstants.TextureFormat.RG32Uint:\n      case WebGPUConstants.TextureFormat.RG32Sint:\n      case WebGPUConstants.TextureFormat.RG32Float:\n      case WebGPUConstants.TextureFormat.RGBA16Uint:\n      case WebGPUConstants.TextureFormat.RGBA16Sint:\n      case WebGPUConstants.TextureFormat.RGBA16Float:\n        return {\n          width: 1,\n          height: 1,\n          length: 8\n        };\n      // 128 bits formats\n      case WebGPUConstants.TextureFormat.RGBA32Uint:\n      case WebGPUConstants.TextureFormat.RGBA32Sint:\n      case WebGPUConstants.TextureFormat.RGBA32Float:\n        return {\n          width: 1,\n          height: 1,\n          length: 16\n        };\n      // Depth and stencil formats\n      case WebGPUConstants.TextureFormat.Stencil8:\n        throw \"No fixed size for Stencil8 format!\";\n      case WebGPUConstants.TextureFormat.Depth16Unorm:\n        return {\n          width: 1,\n          height: 1,\n          length: 2\n        };\n      case WebGPUConstants.TextureFormat.Depth24Plus:\n        throw \"No fixed size for Depth24Plus format!\";\n      case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\n        throw \"No fixed size for Depth24PlusStencil8 format!\";\n      case WebGPUConstants.TextureFormat.Depth32Float:\n        return {\n          width: 1,\n          height: 1,\n          length: 4\n        };\n      case WebGPUConstants.TextureFormat.Depth24UnormStencil8:\n        return {\n          width: 1,\n          height: 1,\n          length: 4\n        };\n      case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\n        return {\n          width: 1,\n          height: 1,\n          length: 5\n        };\n      // BC compressed formats usable if \"texture-compression-bc\" is both\n      // supported by the device/user agent and enabled in requestDevice.\n      case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\n      case WebGPUConstants.TextureFormat.BC6HRGBFloat:\n      case WebGPUConstants.TextureFormat.BC5RGUnorm:\n      case WebGPUConstants.TextureFormat.BC5RGSnorm:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\n        return {\n          width: 4,\n          height: 4,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.BC4RUnorm:\n      case WebGPUConstants.TextureFormat.BC4RSnorm:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\n        return {\n          width: 4,\n          height: 4,\n          length: 8\n        };\n      // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\n      // supported by the device/user agent and enabled in requestDevice.\n      case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\n      case WebGPUConstants.TextureFormat.EACR11Unorm:\n      case WebGPUConstants.TextureFormat.EACR11Snorm:\n        return {\n          width: 4,\n          height: 4,\n          length: 8\n        };\n      case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.EACRG11Unorm:\n      case WebGPUConstants.TextureFormat.EACRG11Snorm:\n        return {\n          width: 4,\n          height: 4,\n          length: 16\n        };\n      // ASTC compressed formats usable if \"texture-compression-astc\" is both\n      // supported by the device/user agent and enabled in requestDevice.\n      case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\n        return {\n          width: 4,\n          height: 4,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\n        return {\n          width: 5,\n          height: 4,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\n        return {\n          width: 5,\n          height: 5,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\n        return {\n          width: 6,\n          height: 5,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\n        return {\n          width: 6,\n          height: 6,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\n        return {\n          width: 8,\n          height: 5,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\n        return {\n          width: 8,\n          height: 6,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\n        return {\n          width: 8,\n          height: 8,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\n        return {\n          width: 10,\n          height: 5,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\n        return {\n          width: 10,\n          height: 6,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\n        return {\n          width: 10,\n          height: 8,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\n        return {\n          width: 10,\n          height: 10,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\n        return {\n          width: 12,\n          height: 10,\n          length: 16\n        };\n      case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\n        return {\n          width: 12,\n          height: 12,\n          length: 16\n        };\n    }\n    return {\n      width: 1,\n      height: 1,\n      length: 4\n    };\n  }\n  static _IsHardwareTexture(texture) {\n    return !!texture.release;\n  }\n  static _IsInternalTexture(texture) {\n    return !!texture.dispose;\n  }\n  static IsImageBitmap(imageBitmap) {\n    return imageBitmap.close !== undefined;\n  }\n  static IsImageBitmapArray(imageBitmap) {\n    return Array.isArray(imageBitmap) && imageBitmap[0].close !== undefined;\n  }\n  setCommandEncoder(encoder) {\n    this._commandEncoderForCreation = encoder;\n  }\n  static IsCompressedFormat(format) {\n    switch (format) {\n      case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC6HRGBFloat:\n      case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\n      case WebGPUConstants.TextureFormat.BC5RGSnorm:\n      case WebGPUConstants.TextureFormat.BC5RGUnorm:\n      case WebGPUConstants.TextureFormat.BC4RSnorm:\n      case WebGPUConstants.TextureFormat.BC4RUnorm:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.EACR11Unorm:\n      case WebGPUConstants.TextureFormat.EACR11Snorm:\n      case WebGPUConstants.TextureFormat.EACRG11Unorm:\n      case WebGPUConstants.TextureFormat.EACRG11Snorm:\n      case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\n        return true;\n    }\n    return false;\n  }\n  static GetWebGPUTextureFormat(type, format, useSRGBBuffer = false) {\n    switch (format) {\n      case 15:\n        return WebGPUConstants.TextureFormat.Depth16Unorm;\n      case 16:\n        return WebGPUConstants.TextureFormat.Depth24Plus;\n      case 13:\n        return WebGPUConstants.TextureFormat.Depth24PlusStencil8;\n      case 14:\n        return WebGPUConstants.TextureFormat.Depth32Float;\n      case 17:\n        return WebGPUConstants.TextureFormat.Depth24UnormStencil8;\n      case 18:\n        return WebGPUConstants.TextureFormat.Depth32FloatStencil8;\n      case 36492:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC7RGBAUnorm;\n      case 36495:\n        return WebGPUConstants.TextureFormat.BC6HRGBUFloat;\n      case 36494:\n        return WebGPUConstants.TextureFormat.BC6HRGBFloat;\n      case 33779:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC3RGBAUnorm;\n      case 33778:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC2RGBAUnorm;\n      case 33777:\n      case 33776:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC1RGBAUnorm;\n      case 37808:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB : WebGPUConstants.TextureFormat.ASTC4x4Unorm;\n      case 36196:\n      case 37492:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGB8Unorm;\n      case 37496:\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGBA8Unorm;\n    }\n    switch (type) {\n      case 3:\n        switch (format) {\n          case 6:\n            return WebGPUConstants.TextureFormat.R8Snorm;\n          case 7:\n            return WebGPUConstants.TextureFormat.RG8Snorm;\n          case 4:\n            throw \"RGB format not supported in WebGPU\";\n          case 8:\n            return WebGPUConstants.TextureFormat.R8Sint;\n          case 9:\n            return WebGPUConstants.TextureFormat.RG8Sint;\n          case 10:\n            throw \"RGB_INTEGER format not supported in WebGPU\";\n          case 11:\n            return WebGPUConstants.TextureFormat.RGBA8Sint;\n          default:\n            return WebGPUConstants.TextureFormat.RGBA8Snorm;\n        }\n      case 0:\n        switch (format) {\n          case 6:\n            return WebGPUConstants.TextureFormat.R8Unorm;\n          case 7:\n            return WebGPUConstants.TextureFormat.RG8Unorm;\n          case 4:\n            throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\n          case 5:\n            return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\n          case 12:\n            return useSRGBBuffer ? WebGPUConstants.TextureFormat.BGRA8UnormSRGB : WebGPUConstants.TextureFormat.BGRA8Unorm;\n          case 8:\n            return WebGPUConstants.TextureFormat.R8Uint;\n          case 9:\n            return WebGPUConstants.TextureFormat.RG8Uint;\n          case 10:\n            throw \"RGB_INTEGER format not supported in WebGPU\";\n          case 11:\n            return WebGPUConstants.TextureFormat.RGBA8Uint;\n          case 0:\n            throw \"TEXTUREFORMAT_ALPHA format not supported in WebGPU\";\n          case 1:\n            throw \"TEXTUREFORMAT_LUMINANCE format not supported in WebGPU\";\n          case 2:\n            throw \"TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU\";\n          default:\n            return WebGPUConstants.TextureFormat.RGBA8Unorm;\n        }\n      case 4:\n        switch (format) {\n          case 8:\n            return WebGPUConstants.TextureFormat.R16Sint;\n          case 9:\n            return WebGPUConstants.TextureFormat.RG16Sint;\n          case 10:\n            throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\n          case 11:\n            return WebGPUConstants.TextureFormat.RGBA16Sint;\n          default:\n            return WebGPUConstants.TextureFormat.RGBA16Sint;\n        }\n      case 5:\n        switch (format) {\n          case 8:\n            return WebGPUConstants.TextureFormat.R16Uint;\n          case 9:\n            return WebGPUConstants.TextureFormat.RG16Uint;\n          case 10:\n            throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\n          case 11:\n            return WebGPUConstants.TextureFormat.RGBA16Uint;\n          default:\n            return WebGPUConstants.TextureFormat.RGBA16Uint;\n        }\n      case 6:\n        switch (format) {\n          case 8:\n            return WebGPUConstants.TextureFormat.R32Sint;\n          case 9:\n            return WebGPUConstants.TextureFormat.RG32Sint;\n          case 10:\n            throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\n          case 11:\n            return WebGPUConstants.TextureFormat.RGBA32Sint;\n          default:\n            return WebGPUConstants.TextureFormat.RGBA32Sint;\n        }\n      case 7:\n        // Refers to UNSIGNED_INT\n        switch (format) {\n          case 8:\n            return WebGPUConstants.TextureFormat.R32Uint;\n          case 9:\n            return WebGPUConstants.TextureFormat.RG32Uint;\n          case 10:\n            throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\n          case 11:\n            return WebGPUConstants.TextureFormat.RGBA32Uint;\n          default:\n            return WebGPUConstants.TextureFormat.RGBA32Uint;\n        }\n      case 1:\n        switch (format) {\n          case 6:\n            return WebGPUConstants.TextureFormat.R32Float;\n          // By default. Other possibility is R16Float.\n          case 7:\n            return WebGPUConstants.TextureFormat.RG32Float;\n          // By default. Other possibility is RG16Float.\n          case 4:\n            throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\n          case 5:\n            return WebGPUConstants.TextureFormat.RGBA32Float;\n          // By default. Other possibility is RGBA16Float.\n          default:\n            return WebGPUConstants.TextureFormat.RGBA32Float;\n        }\n      case 2:\n        switch (format) {\n          case 6:\n            return WebGPUConstants.TextureFormat.R16Float;\n          case 7:\n            return WebGPUConstants.TextureFormat.RG16Float;\n          case 4:\n            throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\n          case 5:\n            return WebGPUConstants.TextureFormat.RGBA16Float;\n          default:\n            return WebGPUConstants.TextureFormat.RGBA16Float;\n        }\n      case 10:\n        throw \"TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU\";\n      case 13:\n        throw \"TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV format not supported in WebGPU\";\n      case 14:\n        throw \"TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV format not supported in WebGPU\";\n      case 8:\n        throw \"TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU\";\n      case 9:\n        throw \"TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU\";\n      case 11:\n        switch (format) {\n          case 5:\n            return WebGPUConstants.TextureFormat.RGB10A2Unorm;\n          case 11:\n            throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV\";\n          default:\n            return WebGPUConstants.TextureFormat.RGB10A2Unorm;\n        }\n    }\n    return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\n  }\n  static GetNumChannelsFromWebGPUTextureFormat(format) {\n    switch (format) {\n      case WebGPUConstants.TextureFormat.R8Unorm:\n      case WebGPUConstants.TextureFormat.R8Snorm:\n      case WebGPUConstants.TextureFormat.R8Uint:\n      case WebGPUConstants.TextureFormat.R8Sint:\n      case WebGPUConstants.TextureFormat.BC4RUnorm:\n      case WebGPUConstants.TextureFormat.BC4RSnorm:\n      case WebGPUConstants.TextureFormat.R16Uint:\n      case WebGPUConstants.TextureFormat.R16Sint:\n      case WebGPUConstants.TextureFormat.Depth16Unorm:\n      case WebGPUConstants.TextureFormat.R16Float:\n      case WebGPUConstants.TextureFormat.R32Uint:\n      case WebGPUConstants.TextureFormat.R32Sint:\n      case WebGPUConstants.TextureFormat.R32Float:\n      case WebGPUConstants.TextureFormat.Depth32Float:\n      case WebGPUConstants.TextureFormat.Stencil8:\n      case WebGPUConstants.TextureFormat.Depth24Plus:\n      case WebGPUConstants.TextureFormat.EACR11Unorm:\n      case WebGPUConstants.TextureFormat.EACR11Snorm:\n        return 1;\n      case WebGPUConstants.TextureFormat.RG8Unorm:\n      case WebGPUConstants.TextureFormat.RG8Snorm:\n      case WebGPUConstants.TextureFormat.RG8Uint:\n      case WebGPUConstants.TextureFormat.RG8Sint:\n      case WebGPUConstants.TextureFormat.Depth24UnormStencil8: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.Depth32FloatStencil8: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.BC5RGUnorm:\n      case WebGPUConstants.TextureFormat.BC5RGSnorm:\n      case WebGPUConstants.TextureFormat.RG16Uint:\n      case WebGPUConstants.TextureFormat.RG16Sint:\n      case WebGPUConstants.TextureFormat.RG16Float:\n      case WebGPUConstants.TextureFormat.RG32Uint:\n      case WebGPUConstants.TextureFormat.RG32Sint:\n      case WebGPUConstants.TextureFormat.RG32Float:\n      case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\n      case WebGPUConstants.TextureFormat.EACRG11Unorm:\n      case WebGPUConstants.TextureFormat.EACRG11Snorm:\n        return 2;\n      case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\n      case WebGPUConstants.TextureFormat.BC6HRGBFloat:\n      case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\n        return 3;\n      case WebGPUConstants.TextureFormat.RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.RGBA8Snorm:\n      case WebGPUConstants.TextureFormat.RGBA8Uint:\n      case WebGPUConstants.TextureFormat.RGBA8Sint:\n      case WebGPUConstants.TextureFormat.BGRA8Unorm:\n      case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\n      case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\n      case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\n      case WebGPUConstants.TextureFormat.RGBA16Uint:\n      case WebGPUConstants.TextureFormat.RGBA16Sint:\n      case WebGPUConstants.TextureFormat.RGBA16Float:\n      case WebGPUConstants.TextureFormat.RGBA32Uint:\n      case WebGPUConstants.TextureFormat.RGBA32Sint:\n      case WebGPUConstants.TextureFormat.RGBA32Float:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\n      case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\n      case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\n      case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\n        return 4;\n    }\n    throw `Unknown format ${format}!`;\n  }\n  static HasStencilAspect(format) {\n    switch (format) {\n      case WebGPUConstants.TextureFormat.Stencil8:\n      case WebGPUConstants.TextureFormat.Depth24UnormStencil8:\n      case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\n      case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\n        return true;\n    }\n    return false;\n  }\n  static HasDepthAndStencilAspects(format) {\n    switch (format) {\n      case WebGPUConstants.TextureFormat.Depth24UnormStencil8:\n      case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\n      case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\n        return true;\n    }\n    return false;\n  }\n  copyVideoToTexture(video, texture, format, invertY = false, commandEncoder) {\n    var _a, _b, _c, _d;\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `copy video to texture - invertY=${invertY}`);\n    const webgpuHardwareTexture = texture._hardwareTexture;\n    const renderPassDescriptor = {\n      colorAttachments: [{\n        view: webgpuHardwareTexture.underlyingResource.createView({\n          format,\n          dimension: WebGPUConstants.TextureViewDimension.E2d,\n          mipLevelCount: 1,\n          baseArrayLayer: 0,\n          baseMipLevel: 0,\n          arrayLayerCount: 1,\n          aspect: WebGPUConstants.TextureAspect.All\n        }),\n        loadOp: WebGPUConstants.LoadOp.Load,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }]\n    };\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    const descriptor = {\n      layout: bindGroupLayout,\n      entries: [{\n        binding: 0,\n        resource: this._videoSampler\n      }, {\n        binding: 1,\n        resource: this._device.importExternalTexture({\n          source: video.underlyingResource\n        })\n      }]\n    };\n    const bindGroup = this._device.createBindGroup(descriptor);\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.draw(4, 1, 0, 0);\n    passEncoder.end();\n    (_d = (_c = commandEncoder).popDebugGroup) === null || _d === void 0 ? void 0 : _d.call(_c);\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY = false, premultiplyAlpha = false, faceIndex = 0, mipLevel = 0, layers = 1, ofstX = 0, ofstY = 0, rectWidth = 0, rectHeight = 0, commandEncoder,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  allowGPUOptimization) {\n    var _a, _b, _c, _d, _e, _f;\n    const useRect = rectWidth !== 0;\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\n      invertY,\n      premultiplyAlpha\n    });\n    faceIndex = Math.max(faceIndex, 0);\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\n    let gpuTexture;\n    if (WebGPUTextureHelper._IsHardwareTexture(gpuOrHdwTexture)) {\n      gpuTexture = gpuOrHdwTexture.underlyingResource;\n      if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\n        // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\n        gpuOrHdwTexture = undefined;\n      }\n    } else {\n      gpuTexture = gpuOrHdwTexture;\n      gpuOrHdwTexture = undefined;\n    }\n    if (!gpuTexture) {\n      return;\n    }\n    if (useRect) {\n      this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\n    }\n    const webgpuHardwareTexture = gpuOrHdwTexture;\n    const outputTexture = (_c = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYTempTexture) !== null && _c !== void 0 ? _c : this.createTexture({\n      width,\n      height,\n      layers: 1\n    }, false, false, false, false, false, format, 1, commandEncoder, WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding);\n    const renderPassDescriptor = (_d = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYRenderPassDescr) !== null && _d !== void 0 ? _d : {\n      colorAttachments: [{\n        view: outputTexture.createView({\n          format,\n          dimension: WebGPUConstants.TextureViewDimension.E2d,\n          baseMipLevel: 0,\n          mipLevelCount: 1,\n          arrayLayerCount: 1,\n          baseArrayLayer: 0\n        }),\n        loadOp: WebGPUConstants.LoadOp.Load,\n        storeOp: WebGPUConstants.StoreOp.Store\n      }]\n    };\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    let bindGroup = useRect ? webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYBindGroupWithOfst : webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._copyInvertYBindGroup;\n    if (!bindGroup) {\n      const descriptor = {\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: gpuTexture.createView({\n            format,\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\n            baseMipLevel: mipLevel,\n            mipLevelCount: 1,\n            arrayLayerCount: layers,\n            baseArrayLayer: faceIndex\n          })\n        }]\n      };\n      if (useRect) {\n        descriptor.entries.push({\n          binding: 1,\n          resource: {\n            buffer: this._ubCopyWithOfst\n          }\n        });\n      }\n      bindGroup = this._device.createBindGroup(descriptor);\n    }\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.draw(4, 1, 0, 0);\n    passEncoder.end();\n    commandEncoder.copyTextureToTexture({\n      texture: outputTexture\n    }, {\n      texture: gpuTexture,\n      mipLevel,\n      origin: {\n        x: 0,\n        y: 0,\n        z: faceIndex\n      }\n    }, {\n      width,\n      height,\n      depthOrArrayLayers: 1\n    });\n    if (webgpuHardwareTexture) {\n      webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\n      webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\n      if (useRect) {\n        webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\n      } else {\n        webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\n      }\n    } else {\n      this._deferredReleaseTextures.push([outputTexture, null]);\n    }\n    (_f = (_e = commandEncoder).popDebugGroup) === null || _f === void 0 ? void 0 : _f.call(_e);\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  copyWithInvertY(srcTextureView, format, renderPassDescriptor, commandEncoder) {\n    var _a, _b, _c, _d;\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.InvertYPremultiplyAlpha, {\n      invertY: true,\n      premultiplyAlpha: false\n    });\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `internal copy texture with invertY`);\n    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n    const bindGroup = this._device.createBindGroup({\n      layout: bindGroupLayout,\n      entries: [{\n        binding: 0,\n        resource: srcTextureView\n      }]\n    });\n    passEncoder.setPipeline(pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.draw(4, 1, 0, 0);\n    passEncoder.end();\n    (_d = (_c = commandEncoder).popDebugGroup) === null || _d === void 0 ? void 0 : _d.call(_c);\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                               Creation\n  //------------------------------------------------------------------------------\n  createTexture(imageBitmap, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, is3D = false, format = WebGPUConstants.TextureFormat.RGBA8Unorm, sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0) {\n    if (sampleCount > 1) {\n      // WebGPU only supports 1 or 4\n      sampleCount = 4;\n    }\n    const layerCount = imageBitmap.layers || 1;\n    const textureSize = {\n      width: imageBitmap.width,\n      height: imageBitmap.height,\n      depthOrArrayLayers: layerCount\n    };\n    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\n    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\n    const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\n    additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment : 0;\n    if (!isCompressedFormat && !is3D) {\n      // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\n      additionalUsages |= WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopyDst;\n    }\n    const gpuTexture = this._device.createTexture({\n      label: `Texture_${textureSize.width}x${textureSize.height}x${textureSize.depthOrArrayLayers}_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\n      size: textureSize,\n      dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\n      format,\n      usage: usages | additionalUsages,\n      sampleCount,\n      mipLevelCount\n    });\n    if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\n      this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\n      if (hasMipmaps && generateMipmaps) {\n        this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, commandEncoder);\n      }\n    }\n    return gpuTexture;\n  }\n  createCubeTexture(imageBitmaps, hasMipmaps = false, generateMipmaps = false, invertY = false, premultiplyAlpha = false, format = WebGPUConstants.TextureFormat.RGBA8Unorm, sampleCount = 1, commandEncoder, usage = -1, additionalUsages = 0) {\n    if (sampleCount > 1) {\n      // WebGPU only supports 1 or 4\n      sampleCount = 4;\n    }\n    const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\n    const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\n    const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\n    const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\n    const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\n    additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment : 0;\n    if (!isCompressedFormat) {\n      // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\n      additionalUsages |= WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopyDst;\n    }\n    const gpuTexture = this._device.createTexture({\n      label: `TextureCube_${width}x${height}x6_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\n      size: {\n        width,\n        height,\n        depthOrArrayLayers: 6\n      },\n      dimension: WebGPUConstants.TextureDimension.E2d,\n      format,\n      usage: usages | additionalUsages,\n      sampleCount,\n      mipLevelCount\n    });\n    if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\n      this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\n      if (hasMipmaps && generateMipmaps) {\n        this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\n      }\n    }\n    return gpuTexture;\n  }\n  generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder) {\n    var _a, _b, _c, _d;\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `create cube mipmaps - ${mipLevelCount} levels`);\n    for (let f = 0; f < 6; ++f) {\n      this.generateMipmaps(gpuTexture, format, mipLevelCount, f, commandEncoder);\n    }\n    (_d = (_c = commandEncoder).popDebugGroup) === null || _d === void 0 ? void 0 : _d.call(_c);\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  generateMipmaps(gpuOrHdwTexture, format, mipLevelCount, faceIndex = 0, commandEncoder) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const useOwnCommandEncoder = commandEncoder === undefined;\n    const [pipeline, bindGroupLayout] = this._getPipeline(format);\n    faceIndex = Math.max(faceIndex, 0);\n    if (useOwnCommandEncoder) {\n      commandEncoder = this._device.createCommandEncoder({});\n    }\n    (_b = (_a = commandEncoder).pushDebugGroup) === null || _b === void 0 ? void 0 : _b.call(_a, `create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\n    let gpuTexture;\n    if (WebGPUTextureHelper._IsHardwareTexture(gpuOrHdwTexture)) {\n      gpuTexture = gpuOrHdwTexture.underlyingResource;\n      gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\n      gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\n    } else {\n      gpuTexture = gpuOrHdwTexture;\n      gpuOrHdwTexture = undefined;\n    }\n    if (!gpuTexture) {\n      return;\n    }\n    const webgpuHardwareTexture = gpuOrHdwTexture;\n    for (let i = 1; i < mipLevelCount; ++i) {\n      const renderPassDescriptor = (_d = (_c = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex]) === null || _c === void 0 ? void 0 : _c[i - 1]) !== null && _d !== void 0 ? _d : {\n        colorAttachments: [{\n          view: gpuTexture.createView({\n            format,\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\n            baseMipLevel: i,\n            mipLevelCount: 1,\n            arrayLayerCount: 1,\n            baseArrayLayer: faceIndex\n          }),\n          loadOp: WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        }]\n      };\n      if (webgpuHardwareTexture) {\n        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\n        webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\n      }\n      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n      const bindGroup = (_f = (_e = webgpuHardwareTexture === null || webgpuHardwareTexture === void 0 ? void 0 : webgpuHardwareTexture._mipmapGenBindGroup[faceIndex]) === null || _e === void 0 ? void 0 : _e[i - 1]) !== null && _f !== void 0 ? _f : this._device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: [{\n          binding: 0,\n          resource: this._mipmapSampler\n        }, {\n          binding: 1,\n          resource: gpuTexture.createView({\n            format,\n            dimension: WebGPUConstants.TextureViewDimension.E2d,\n            baseMipLevel: i - 1,\n            mipLevelCount: 1,\n            arrayLayerCount: 1,\n            baseArrayLayer: faceIndex\n          })\n        }]\n      });\n      if (webgpuHardwareTexture) {\n        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\n        webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\n      }\n      passEncoder.setPipeline(pipeline);\n      passEncoder.setBindGroup(0, bindGroup);\n      passEncoder.draw(4, 1, 0, 0);\n      passEncoder.end();\n    }\n    (_h = (_g = commandEncoder).popDebugGroup) === null || _h === void 0 ? void 0 : _h.call(_g);\n    if (useOwnCommandEncoder) {\n      this._device.queue.submit([commandEncoder.finish()]);\n      commandEncoder = null;\n    }\n  }\n  createGPUTextureForInternalTexture(texture, width, height, depth, creationFlags) {\n    if (!texture._hardwareTexture) {\n      texture._hardwareTexture = new WebGPUHardwareTexture();\n    }\n    if (width === undefined) {\n      width = texture.width;\n    }\n    if (height === undefined) {\n      height = texture.height;\n    }\n    if (depth === undefined) {\n      depth = texture.depth;\n    }\n    const gpuTextureWrapper = texture._hardwareTexture;\n    const isStorageTexture = ((creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0) & 1) !== 0;\n    gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\n    gpuTextureWrapper.textureUsages = texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment : texture._source === InternalTextureSource.DepthStencil ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment : -1;\n    gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\n    const hasMipMaps = texture.generateMipMaps;\n    const layerCount = depth || 1;\n    let mipmapCount;\n    if (texture._maxLodLevel !== null) {\n      mipmapCount = texture._maxLodLevel;\n    } else {\n      mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\n    }\n    if (texture.isCube) {\n      const gpuTexture = this.createCubeTexture({\n        width,\n        height\n      }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);\n      gpuTextureWrapper.set(gpuTexture);\n      gpuTextureWrapper.createView({\n        format: gpuTextureWrapper.format,\n        dimension: WebGPUConstants.TextureViewDimension.Cube,\n        mipLevelCount: mipmapCount,\n        baseArrayLayer: 0,\n        baseMipLevel: 0,\n        arrayLayerCount: 6,\n        aspect: WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All\n      }, isStorageTexture);\n    } else {\n      const gpuTexture = this.createTexture({\n        width,\n        height,\n        layers: layerCount\n      }, texture.generateMipMaps, texture.generateMipMaps, texture.invertY, false, texture.is3D, gpuTextureWrapper.format, 1, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);\n      gpuTextureWrapper.set(gpuTexture);\n      gpuTextureWrapper.createView({\n        format: gpuTextureWrapper.format,\n        dimension: texture.is2DArray ? WebGPUConstants.TextureViewDimension.E2dArray : texture.is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureViewDimension.E2d,\n        mipLevelCount: mipmapCount,\n        baseArrayLayer: 0,\n        baseMipLevel: 0,\n        arrayLayerCount: texture.is3D ? 1 : layerCount,\n        aspect: WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All\n      }, isStorageTexture);\n    }\n    texture.width = texture.baseWidth = width;\n    texture.height = texture.baseHeight = height;\n    texture.depth = texture.baseDepth = depth;\n    this.createMSAATexture(texture, texture.samples);\n    return gpuTextureWrapper;\n  }\n  createMSAATexture(texture, samples) {\n    const gpuTextureWrapper = texture._hardwareTexture;\n    if (gpuTextureWrapper === null || gpuTextureWrapper === void 0 ? void 0 : gpuTextureWrapper.msaaTexture) {\n      this.releaseTexture(gpuTextureWrapper.msaaTexture);\n      gpuTextureWrapper.msaaTexture = null;\n    }\n    if (!gpuTextureWrapper || (samples !== null && samples !== void 0 ? samples : 1) <= 1) {\n      return;\n    }\n    const width = texture.width;\n    const height = texture.height;\n    const layerCount = texture.depth || 1;\n    if (texture.isCube) {\n      const gpuMSAATexture = this.createCubeTexture({\n        width,\n        height\n      }, false, false, texture.invertY, false, gpuTextureWrapper.format, samples, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);\n      gpuTextureWrapper.msaaTexture = gpuMSAATexture;\n    } else {\n      const gpuMSAATexture = this.createTexture({\n        width,\n        height,\n        layers: layerCount\n      }, false, false, texture.invertY, false, texture.is3D, gpuTextureWrapper.format, samples, this._commandEncoderForCreation, gpuTextureWrapper.textureUsages, gpuTextureWrapper.textureAdditionalUsages);\n      gpuTextureWrapper.msaaTexture = gpuMSAATexture;\n    }\n  }\n  //------------------------------------------------------------------------------\n  //                                  Update\n  //------------------------------------------------------------------------------\n  updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0) {\n    const faces = [0, 3, 1, 4, 2, 5];\n    for (let f = 0; f < faces.length; ++f) {\n      const imageBitmap = imageBitmaps[faces[f]];\n      this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\n    }\n  }\n  // TODO WEBGPU handle data source not being in the same format than the destination texture?\n  updateTexture(imageBitmap, texture, width, height, layers, format, faceIndex = 0, mipLevel = 0, invertY = false, premultiplyAlpha = false, offsetX = 0, offsetY = 0, allowGPUOptimization) {\n    const gpuTexture = WebGPUTextureHelper._IsInternalTexture(texture) ? texture._hardwareTexture.underlyingResource : texture;\n    const blockInformation = WebGPUTextureHelper._GetBlockInformationFromFormat(format);\n    const gpuOrHdwTexture = WebGPUTextureHelper._IsInternalTexture(texture) ? texture._hardwareTexture : texture;\n    const textureCopyView = {\n      texture: gpuTexture,\n      origin: {\n        x: offsetX,\n        y: offsetY,\n        z: Math.max(faceIndex, 0)\n      },\n      mipLevel: mipLevel,\n      premultipliedAlpha: premultiplyAlpha\n    };\n    const textureExtent = {\n      width: Math.ceil(width / blockInformation.width) * blockInformation.width,\n      height: Math.ceil(height / blockInformation.height) * blockInformation.height,\n      depthOrArrayLayers: layers || 1\n    };\n    if (imageBitmap.byteLength !== undefined) {\n      imageBitmap = imageBitmap;\n      const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\n      const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\n      if (aligned) {\n        const commandEncoder = this._device.createCommandEncoder({});\n        const buffer = this._bufferManager.createRawBuffer(imageBitmap.byteLength, WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc, true);\n        const arrayBuffer = buffer.getMappedRange();\n        new Uint8Array(arrayBuffer).set(imageBitmap);\n        buffer.unmap();\n        commandEncoder.copyBufferToTexture({\n          buffer: buffer,\n          offset: 0,\n          bytesPerRow,\n          rowsPerImage: height\n        }, textureCopyView, textureExtent);\n        this._device.queue.submit([commandEncoder.finish()]);\n        this._bufferManager.releaseBuffer(buffer);\n      } else {\n        this._device.queue.writeTexture(textureCopyView, imageBitmap, {\n          offset: 0,\n          bytesPerRow,\n          rowsPerImage: height\n        }, textureExtent);\n      }\n      if (invertY || premultiplyAlpha) {\n        if (WebGPUTextureHelper._IsInternalTexture(texture)) {\n          const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\n          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, texture.width, texture.height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, offsetX, offsetY, dontUseRect ? 0 : width, dontUseRect ? 0 : height, undefined, allowGPUOptimization);\n        } else {\n          // we should never take this code path\n          throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\n        }\n      }\n    } else {\n      imageBitmap = imageBitmap;\n      if (invertY) {\n        textureCopyView.premultipliedAlpha = false; // we are going to handle premultiplyAlpha ourselves\n        // we must preprocess the image\n        if (WebGPUTextureHelper._IsInternalTexture(texture) && offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height) {\n          // optimization when the source image is the same size than the destination texture and offsets X/Y == 0:\n          // we simply copy the source to the destination and we apply the preprocessing on the destination\n          this._device.queue.copyExternalImageToTexture({\n            source: imageBitmap\n          }, textureCopyView, textureExtent);\n          this.invertYPreMultiplyAlpha(gpuOrHdwTexture, width, height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, 0, 0, 0, 0, undefined, allowGPUOptimization);\n        } else {\n          // we must apply the preprocessing on the source image before copying it into the destination texture\n          const commandEncoder = this._device.createCommandEncoder({});\n          // create a temp texture and copy the image to it\n          const srcTexture = this.createTexture({\n            width,\n            height,\n            layers: 1\n          }, false, false, false, false, false, format, 1, commandEncoder, WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.TextureBinding);\n          this._deferredReleaseTextures.push([srcTexture, null]);\n          textureExtent.depthOrArrayLayers = 1;\n          this._device.queue.copyExternalImageToTexture({\n            source: imageBitmap\n          }, {\n            texture: srcTexture\n          }, textureExtent);\n          textureExtent.depthOrArrayLayers = layers || 1;\n          // apply the preprocessing to this temp texture\n          this.invertYPreMultiplyAlpha(srcTexture, width, height, format, invertY, premultiplyAlpha, faceIndex, mipLevel, layers || 1, 0, 0, 0, 0, commandEncoder, allowGPUOptimization);\n          // copy the temp texture to the destination texture\n          commandEncoder.copyTextureToTexture({\n            texture: srcTexture\n          }, textureCopyView, textureExtent);\n          this._device.queue.submit([commandEncoder.finish()]);\n        }\n      } else {\n        // no preprocessing: direct copy to destination texture\n        this._device.queue.copyExternalImageToTexture({\n          source: imageBitmap\n        }, textureCopyView, textureExtent);\n      }\n    }\n  }\n  readPixels(texture, x, y, width, height, format, faceIndex = 0, mipLevel = 0, buffer = null, noDataConversion = false) {\n    const blockInformation = WebGPUTextureHelper._GetBlockInformationFromFormat(format);\n    const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\n    const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\n    const size = bytesPerRowAligned * height;\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\n    const commandEncoder = this._device.createCommandEncoder({});\n    commandEncoder.copyTextureToBuffer({\n      texture,\n      mipLevel,\n      origin: {\n        x,\n        y,\n        z: Math.max(faceIndex, 0)\n      }\n    }, {\n      buffer: gpuBuffer,\n      offset: 0,\n      bytesPerRow: bytesPerRowAligned\n    }, {\n      width,\n      height,\n      depthOrArrayLayers: 1\n    });\n    this._device.queue.submit([commandEncoder.finish()]);\n    return this._bufferManager.readDataFromBuffer(gpuBuffer, size, width, height, bytesPerRow, bytesPerRowAligned, WebGPUTextureHelper._GetTextureTypeFromFormat(format), 0, buffer, true, noDataConversion);\n  }\n  //------------------------------------------------------------------------------\n  //                              Dispose\n  //------------------------------------------------------------------------------\n  releaseTexture(texture) {\n    if (WebGPUTextureHelper._IsInternalTexture(texture)) {\n      const hardwareTexture = texture._hardwareTexture;\n      const irradianceTexture = texture._irradianceTexture;\n      // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\n      this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\n    } else {\n      this._deferredReleaseTextures.push([texture, null]);\n    }\n  }\n  destroyDeferredTextures() {\n    for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\n      const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\n      if (hardwareTexture) {\n        if (WebGPUTextureHelper._IsHardwareTexture(hardwareTexture)) {\n          hardwareTexture.release();\n        } else {\n          hardwareTexture.destroy();\n        }\n      }\n      irradianceTexture === null || irradianceTexture === void 0 ? void 0 : irradianceTexture.dispose();\n    }\n    this._deferredReleaseTextures.length = 0;\n  }\n}","map":{"version":3,"mappings":"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","names":["WebGPUConstants","Scalar","InternalTextureSource","WebGPUHardwareTexture","mipmapVertexSource","mipmapFragmentSource","invertYPreMultiplyAlphaVertexSource","invertYPreMultiplyAlphaFragmentSource","invertYPreMultiplyAlphaWithOfstVertexSource","invertYPreMultiplyAlphaWithOfstFragmentSource","clearVertexSource","clearFragmentSource","copyVideoToTextureVertexSource","copyVideoToTextureFragmentSource","copyVideoToTextureInvertYFragmentSource","PipelineType","VideoPipelineType","shadersForPipelineType","vertex","fragment","renderableTextureFormatToIndex","r8unorm","r8uint","r8sint","r16uint","r16sint","r16float","rg8unorm","rg8uint","rg8sint","r32uint","r32sint","r32float","rg16uint","rg16sint","rg16float","rgba8unorm","rgba8uint","rgba8sint","bgra8unorm","rgb10a2unorm","rg32uint","rg32sint","rg32float","rgba16uint","rgba16sint","rgba16float","rgba32uint","rgba32sint","rgba32float","stencil8","depth16unorm","depth24plus","depth32float","WebGPUTextureHelper","constructor","device","glslang","tintWASM","bufferManager","_device","_glslang","_tintWASM","_bufferManager","_mipmapSampler","createSampler","minFilter","FilterMode","Linear","_videoSampler","_ubCopyWithOfst","createBuffer","BufferUsage","Uniform","CopyDst","underlyingResource","_getPipeline","TextureFormat","RGBA8Unorm","_getVideoPipeline","ComputeNumMipmapLevels","width","height","ILog2","Math","max","format","type","MipMap","params","index","InvertYPremultiplyAlpha","invertY","premultiplyAlpha","Clear","InvertYPremultiplyAlphaWithOfst","_pipelines","pipelineAndBGL","defines","modules","_compiledShaders","vertexCode","compileGLSL","fragmentCode","convertSpirV2WGSL","vertexModule","createShaderModule","code","fragmentModule","pipeline","createRenderPipeline","layout","AutoLayoutMode","Auto","module","entryPoint","targets","primitive","topology","PrimitiveTopology","TriangleStrip","stripIndexFormat","IndexFormat","Uint16","getBindGroupLayout","DontInvertY","InvertY","_videoPipelines","_videoCompiledShaders","label","_GetTextureTypeFromFormat","R8Unorm","R8Snorm","R8Uint","R8Sint","RG8Unorm","RG8Snorm","RG8Uint","RG8Sint","RGBA8UnormSRGB","RGBA8Snorm","RGBA8Uint","RGBA8Sint","BGRA8Unorm","BGRA8UnormSRGB","RGB10A2Unorm","RGB9E5UFloat","RG11B10UFloat","Depth24UnormStencil8","Depth32FloatStencil8","BC7RGBAUnorm","BC7RGBAUnormSRGB","BC6HRGBUFloat","BC6HRGBFloat","BC5RGUnorm","BC5RGSnorm","BC3RGBAUnorm","BC3RGBAUnormSRGB","BC2RGBAUnorm","BC2RGBAUnormSRGB","BC4RUnorm","BC4RSnorm","BC1RGBAUnorm","BC1RGBAUnormSRGB","ETC2RGB8Unorm","ETC2RGB8UnormSRGB","ETC2RGB8A1Unorm","ETC2RGB8A1UnormSRGB","ETC2RGBA8Unorm","ETC2RGBA8UnormSRGB","EACR11Unorm","EACR11Snorm","EACRG11Unorm","EACRG11Snorm","ASTC4x4Unorm","ASTC4x4UnormSRGB","ASTC5x4Unorm","ASTC5x4UnormSRGB","ASTC5x5Unorm","ASTC5x5UnormSRGB","ASTC6x5Unorm","ASTC6x5UnormSRGB","ASTC6x6Unorm","ASTC6x6UnormSRGB","ASTC8x5Unorm","ASTC8x5UnormSRGB","ASTC8x6Unorm","ASTC8x6UnormSRGB","ASTC8x8Unorm","ASTC8x8UnormSRGB","ASTC10x5Unorm","ASTC10x5UnormSRGB","ASTC10x6Unorm","ASTC10x6UnormSRGB","ASTC10x8Unorm","ASTC10x8UnormSRGB","ASTC10x10Unorm","ASTC10x10UnormSRGB","ASTC12x10Unorm","ASTC12x10UnormSRGB","ASTC12x12Unorm","ASTC12x12UnormSRGB","R16Uint","R16Sint","RG16Uint","RG16Sint","RGBA16Uint","RGBA16Sint","Depth16Unorm","R16Float","RG16Float","RGBA16Float","R32Uint","R32Sint","RG32Uint","RG32Sint","RGBA32Uint","RGBA32Sint","R32Float","RG32Float","RGBA32Float","Depth32Float","Stencil8","Depth24Plus","Depth24PlusStencil8","_GetBlockInformationFromFormat","length","_IsHardwareTexture","texture","release","_IsInternalTexture","dispose","IsImageBitmap","imageBitmap","close","undefined","IsImageBitmapArray","Array","isArray","setCommandEncoder","encoder","_commandEncoderForCreation","IsCompressedFormat","GetWebGPUTextureFormat","useSRGBBuffer","GetNumChannelsFromWebGPUTextureFormat","HasStencilAspect","HasDepthAndStencilAspects","copyVideoToTexture","video","commandEncoder","useOwnCommandEncoder","bindGroupLayout","createCommandEncoder","pushDebugGroup","webgpuHardwareTexture","_hardwareTexture","renderPassDescriptor","colorAttachments","view","createView","dimension","TextureViewDimension","E2d","mipLevelCount","baseArrayLayer","baseMipLevel","arrayLayerCount","aspect","TextureAspect","All","loadOp","LoadOp","Load","storeOp","StoreOp","Store","passEncoder","beginRenderPass","descriptor","entries","binding","resource","importExternalTexture","source","bindGroup","createBindGroup","setPipeline","setBindGroup","draw","end","popDebugGroup","queue","submit","finish","invertYPreMultiplyAlpha","gpuOrHdwTexture","faceIndex","mipLevel","layers","ofstX","ofstY","rectWidth","rectHeight","allowGPUOptimization","useRect","gpuTexture","setRawData","Float32Array","outputTexture","_copyInvertYTempTexture","createTexture","TextureUsage","CopySrc","RenderAttachment","TextureBinding","_copyInvertYRenderPassDescr","_copyInvertYBindGroupWithOfst","_copyInvertYBindGroup","push","buffer","copyTextureToTexture","origin","x","y","z","depthOrArrayLayers","_deferredReleaseTextures","copyWithInvertY","srcTextureView","hasMipmaps","generateMipmaps","is3D","sampleCount","usage","additionalUsages","layerCount","textureSize","isCompressedFormat","usages","size","TextureDimension","E3d","updateTexture","createCubeTexture","imageBitmaps","updateCubeTextures","generateCubeMipmaps","f","_mipmapGenRenderPassDescr","_mipmapGenBindGroup","i","createGPUTextureForInternalTexture","depth","creationFlags","gpuTextureWrapper","isStorageTexture","_useSRGBBuffer","textureUsages","_source","RenderTarget","MultiRenderTarget","DepthStencil","textureAdditionalUsages","StorageBinding","hasMipMaps","generateMipMaps","mipmapCount","_maxLodLevel","isCube","set","Cube","DepthOnly","is2DArray","E2dArray","baseWidth","baseHeight","baseDepth","createMSAATexture","samples","msaaTexture","releaseTexture","gpuMSAATexture","offsetX","offsetY","faces","blockInformation","textureCopyView","premultipliedAlpha","textureExtent","ceil","byteLength","bytesPerRow","aligned","createRawBuffer","MapWrite","arrayBuffer","getMappedRange","Uint8Array","unmap","copyBufferToTexture","offset","rowsPerImage","releaseBuffer","writeTexture","dontUseRect","copyExternalImageToTexture","srcTexture","readPixels","noDataConversion","bytesPerRowAligned","gpuBuffer","MapRead","copyTextureToBuffer","readDataFromBuffer","hardwareTexture","irradianceTexture","_irradianceTexture","destroyDeferredTextures","destroy"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuTextureHelper.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n// License for the mipmap generation code:\r\n//\r\n// Copyright 2020 Brandon Jones\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n// SOFTWARE.\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport { Constants } from \"../constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { HardwareTextureWrapper } from \"../../Materials/Textures/hardwareTextureWrapper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { WebGPUTintWASM } from \"./webgpuTintWASM\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\n\r\n// TODO WEBGPU improve mipmap generation by using compute shaders\r\n\r\n// TODO WEBGPU use WGSL instead of GLSL\r\nconst mipmapVertexSource = `\r\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\r\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\r\n\r\n    layout(location = 0) out vec2 vTex;\r\n\r\n    void main() {\r\n        vTex = tex[gl_VertexIndex];\r\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst mipmapFragmentSource = `\r\n    layout(set = 0, binding = 0) uniform sampler imgSampler;\r\n    layout(set = 0, binding = 1) uniform texture2D img;\r\n\r\n    layout(location = 0) in vec2 vTex;\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n        outColor = texture(sampler2D(img, imgSampler), vTex);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaVertexSource = `\r\n    #extension GL_EXT_samplerless_texture_functions : enable\r\n\r\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\r\n    const vec2 tex[4] = vec2[4](vec2(0.0f, 0.0f), vec2(1.0f, 0.0f), vec2(0.0f, 1.0f), vec2(1.0f, 1.0f));\r\n\r\n    layout(set = 0, binding = 0) uniform texture2D img;\r\n\r\n    #ifdef INVERTY\r\n        layout(location = 0) out flat ivec2 vTextureSize;\r\n    #endif\r\n\r\n    void main() {\r\n        #ifdef INVERTY\r\n            vTextureSize = textureSize(img, 0);\r\n        #endif\r\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaFragmentSource = `\r\n    #extension GL_EXT_samplerless_texture_functions : enable\r\n\r\n    layout(set = 0, binding = 0) uniform texture2D img;\r\n\r\n    #ifdef INVERTY\r\n        layout(location = 0) in flat ivec2 vTextureSize;\r\n    #endif\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n    #ifdef INVERTY\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, vTextureSize.y - gl_FragCoord.y), 0);\r\n    #else\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color.rgb *= color.a;\r\n    #endif\r\n        outColor = color;\r\n    }\r\n    `;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstVertexSource = invertYPreMultiplyAlphaVertexSource;\r\n\r\nconst invertYPreMultiplyAlphaWithOfstFragmentSource = `\r\n    #extension GL_EXT_samplerless_texture_functions : enable\r\n\r\n    layout(set = 0, binding = 0) uniform texture2D img;\r\n    layout(set = 0, binding = 1) uniform Params {\r\n        float ofstX;\r\n        float ofstY;\r\n        float width;\r\n        float height;\r\n    };\r\n\r\n    #ifdef INVERTY\r\n        layout(location = 0) in flat ivec2 vTextureSize;\r\n    #endif\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n        if (gl_FragCoord.x < ofstX || gl_FragCoord.x >= ofstX + width) {\r\n            discard;\r\n        }\r\n        if (gl_FragCoord.y < ofstY || gl_FragCoord.y >= ofstY + height) {\r\n            discard;\r\n        }\r\n    #ifdef INVERTY\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.x, ofstY + height - (gl_FragCoord.y - ofstY)), 0);\r\n    #else\r\n        vec4 color = texelFetch(img, ivec2(gl_FragCoord.xy), 0);\r\n    #endif\r\n    #ifdef PREMULTIPLYALPHA\r\n        color.rgb *= color.a;\r\n    #endif\r\n        outColor = color;\r\n    }\r\n    `;\r\n\r\nconst clearVertexSource = `\r\n    const vec2 pos[4] = vec2[4](vec2(-1.0f, 1.0f), vec2(1.0f, 1.0f), vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f));\r\n\r\n    void main() {\r\n        gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\r\n    }\r\n    `;\r\n\r\nconst clearFragmentSource = `\r\n    layout(set = 0, binding = 0) uniform Uniforms {\r\n        uniform vec4 color;\r\n    };\r\n\r\n    layout(location = 0) out vec4 outColor;\r\n\r\n    void main() {\r\n        outColor = color;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureVertexSource = `\r\n    struct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n        @location(0) fragUV : vec2<f32>\r\n    }\r\n  \r\n    @vertex\r\n    fn main(\r\n        @builtin(vertex_index) VertexIndex : u32\r\n    ) -> VertexOutput {\r\n        var pos = array<vec2<f32>, 4>(\r\n            vec2(-1.0,  1.0),\r\n            vec2( 1.0,  1.0),\r\n            vec2(-1.0, -1.0),\r\n            vec2( 1.0, -1.0)\r\n        );\r\n        var tex = array<vec2<f32>, 4>(\r\n            vec2(0.0, 0.0),\r\n            vec2(1.0, 0.0),\r\n            vec2(0.0, 1.0),\r\n            vec2(1.0, 1.0)\r\n        );\r\n\r\n        var output: VertexOutput;\r\n\r\n        output.Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\r\n        output.fragUV = tex[VertexIndex];\r\n\r\n        return output;\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, fragUV);\r\n    }\r\n    `;\r\n\r\nconst copyVideoToTextureInvertYFragmentSource = `\r\n    @group(0) @binding(0) var videoSampler: sampler;\r\n    @group(0) @binding(1) var videoTexture: texture_external;\r\n\r\n    @fragment\r\n    fn main(\r\n        @location(0) fragUV: vec2<f32>\r\n    ) -> @location(0) vec4<f32> {\r\n        return textureSampleBaseClampToEdge(videoTexture, videoSampler, vec2<f32>(fragUV.x, 1.0 - fragUV.y));\r\n    }\r\n    `;\r\n\r\nenum PipelineType {\r\n    MipMap = 0,\r\n    InvertYPremultiplyAlpha = 1,\r\n    Clear = 2,\r\n    InvertYPremultiplyAlphaWithOfst = 3,\r\n}\r\n\r\nenum VideoPipelineType {\r\n    DontInvertY = 0,\r\n    InvertY = 1,\r\n}\r\n\r\ninterface IPipelineParameters {\r\n    invertY?: boolean;\r\n    premultiplyAlpha?: boolean;\r\n}\r\n\r\nconst shadersForPipelineType = [\r\n    { vertex: mipmapVertexSource, fragment: mipmapFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaVertexSource, fragment: invertYPreMultiplyAlphaFragmentSource },\r\n    { vertex: clearVertexSource, fragment: clearFragmentSource },\r\n    { vertex: invertYPreMultiplyAlphaWithOfstVertexSource, fragment: invertYPreMultiplyAlphaWithOfstFragmentSource },\r\n];\r\n\r\n/**\r\n * Map a (renderable) texture format (GPUTextureFormat) to an index for fast lookup (in caches for eg)\r\n */\r\nexport const renderableTextureFormatToIndex: { [name: string]: number } = {\r\n    \"\": 0,\r\n    r8unorm: 1,\r\n    r8uint: 2,\r\n    r8sint: 3,\r\n\r\n    r16uint: 4,\r\n    r16sint: 5,\r\n    r16float: 6,\r\n    rg8unorm: 7,\r\n    rg8uint: 8,\r\n    rg8sint: 9,\r\n\r\n    r32uint: 10,\r\n    r32sint: 11,\r\n    r32float: 12,\r\n    rg16uint: 13,\r\n    rg16sint: 14,\r\n    rg16float: 15,\r\n    rgba8unorm: 16,\r\n    \"rgba8unorm-srgb\": 17,\r\n    rgba8uint: 18,\r\n    rgba8sint: 19,\r\n    bgra8unorm: 20,\r\n    \"bgra8unorm-srgb\": 21,\r\n\r\n    rgb10a2unorm: 22,\r\n\r\n    rg32uint: 23,\r\n    rg32sint: 24,\r\n    rg32float: 25,\r\n    rgba16uint: 26,\r\n    rgba16sint: 27,\r\n    rgba16float: 28,\r\n\r\n    rgba32uint: 29,\r\n    rgba32sint: 30,\r\n    rgba32float: 31,\r\n\r\n    stencil8: 32,\r\n    depth16unorm: 33,\r\n    depth24plus: 34,\r\n    \"depth24plus-stencil8\": 35,\r\n    depth32float: 36,\r\n\r\n    \"depth24unorm-stencil8\": 37,\r\n\r\n    \"depth32float-stencil8\": 38,\r\n};\r\n\r\n/** @internal */\r\nexport class WebGPUTextureHelper {\r\n    private _device: GPUDevice;\r\n    private _glslang: any;\r\n    private _tintWASM: Nullable<WebGPUTintWASM>;\r\n    private _bufferManager: WebGPUBufferManager;\r\n    private _mipmapSampler: GPUSampler;\r\n    private _videoSampler: GPUSampler;\r\n    private _ubCopyWithOfst: GPUBuffer;\r\n    private _pipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _compiledShaders: GPUShaderModule[][] = [];\r\n    private _videoPipelines: { [format: string]: Array<[GPURenderPipeline, GPUBindGroupLayout]> } = {};\r\n    private _videoCompiledShaders: GPUShaderModule[][] = [];\r\n    private _deferredReleaseTextures: Array<[Nullable<HardwareTextureWrapper | GPUTexture>, Nullable<BaseTexture>]> = [];\r\n    private _commandEncoderForCreation: GPUCommandEncoder;\r\n\r\n    public static ComputeNumMipmapLevels(width: number, height: number) {\r\n        return Scalar.ILog2(Math.max(width, height)) + 1;\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                         Initialization / Helpers\r\n    //------------------------------------------------------------------------------\r\n\r\n    constructor(device: GPUDevice, glslang: any, tintWASM: Nullable<WebGPUTintWASM>, bufferManager: WebGPUBufferManager) {\r\n        this._device = device;\r\n        this._glslang = glslang;\r\n        this._tintWASM = tintWASM;\r\n        this._bufferManager = bufferManager;\r\n\r\n        this._mipmapSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._videoSampler = device.createSampler({ minFilter: WebGPUConstants.FilterMode.Linear });\r\n        this._ubCopyWithOfst = this._bufferManager.createBuffer(4 * 4, WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst).underlyingResource;\r\n\r\n        this._getPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n        this._getVideoPipeline(WebGPUConstants.TextureFormat.RGBA8Unorm);\r\n    }\r\n\r\n    private _getPipeline(format: GPUTextureFormat, type: PipelineType = PipelineType.MipMap, params?: IPipelineParameters): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index =\r\n            type === PipelineType.MipMap\r\n                ? 1 << 0\r\n                : type === PipelineType.InvertYPremultiplyAlpha\r\n                ? ((params!.invertY ? 1 : 0) << 1) + ((params!.premultiplyAlpha ? 1 : 0) << 2)\r\n                : type === PipelineType.Clear\r\n                ? 1 << 3\r\n                : type === PipelineType.InvertYPremultiplyAlphaWithOfst\r\n                ? ((params!.invertY ? 1 : 0) << 4) + ((params!.premultiplyAlpha ? 1 : 0) << 5)\r\n                : 0;\r\n\r\n        if (!this._pipelines[format]) {\r\n            this._pipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._pipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let defines = \"#version 450\\r\\n\";\r\n            if (type === PipelineType.InvertYPremultiplyAlpha || type === PipelineType.InvertYPremultiplyAlphaWithOfst) {\r\n                if (params!.invertY) {\r\n                    defines += \"#define INVERTY\\r\\n\";\r\n                }\r\n                if (params!.premultiplyAlpha) {\r\n                    defines += \"#define PREMULTIPLYALPHA\\r\\n\";\r\n                }\r\n            }\r\n\r\n            let modules = this._compiledShaders[index];\r\n            if (!modules) {\r\n                let vertexCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].vertex, \"vertex\");\r\n                let fragmentCode = this._glslang.compileGLSL(defines + shadersForPipelineType[type].fragment, \"fragment\");\r\n\r\n                if (this._tintWASM) {\r\n                    vertexCode = this._tintWASM.convertSpirV2WGSL(vertexCode);\r\n                    fragmentCode = this._tintWASM.convertSpirV2WGSL(fragmentCode);\r\n                }\r\n\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: vertexCode,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: fragmentCode,\r\n                });\r\n                modules = this._compiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._pipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    private _getVideoPipeline(format: GPUTextureFormat, type: VideoPipelineType = VideoPipelineType.DontInvertY): [GPURenderPipeline, GPUBindGroupLayout] {\r\n        const index = type === VideoPipelineType.InvertY ? 1 << 0 : 0;\r\n\r\n        if (!this._videoPipelines[format]) {\r\n            this._videoPipelines[format] = [];\r\n        }\r\n\r\n        let pipelineAndBGL = this._videoPipelines[format][index];\r\n        if (!pipelineAndBGL) {\r\n            let modules = this._videoCompiledShaders[index];\r\n            if (!modules) {\r\n                const vertexModule = this._device.createShaderModule({\r\n                    code: copyVideoToTextureVertexSource,\r\n                });\r\n                const fragmentModule = this._device.createShaderModule({\r\n                    code: index === 0 ? copyVideoToTextureFragmentSource : copyVideoToTextureInvertYFragmentSource,\r\n                });\r\n                modules = this._videoCompiledShaders[index] = [vertexModule, fragmentModule];\r\n            }\r\n\r\n            const pipeline = this._device.createRenderPipeline({\r\n                label: `CopyVideoToTexture_${format}_${index === 0 ? \"DontInvertY\" : \"InvertY\"}`,\r\n                layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n                vertex: {\r\n                    module: modules[0],\r\n                    entryPoint: \"main\",\r\n                },\r\n                fragment: {\r\n                    module: modules[1],\r\n                    entryPoint: \"main\",\r\n                    targets: [\r\n                        {\r\n                            format,\r\n                        },\r\n                    ],\r\n                },\r\n                primitive: {\r\n                    topology: WebGPUConstants.PrimitiveTopology.TriangleStrip,\r\n                    stripIndexFormat: WebGPUConstants.IndexFormat.Uint16,\r\n                },\r\n            });\r\n\r\n            pipelineAndBGL = this._videoPipelines[format][index] = [pipeline, pipeline.getBindGroupLayout(0)];\r\n        }\r\n\r\n        return pipelineAndBGL;\r\n    }\r\n\r\n    private static _GetTextureTypeFromFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            // One Component = 8 bits\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.Depth24UnormStencil8: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n            // One component = 16 bits\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return Constants.TEXTURETYPE_UNSIGNED_SHORT;\r\n\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n                return Constants.TEXTURETYPE_HALF_FLOAT;\r\n\r\n            // One component = 32 bits\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n                return Constants.TEXTURETYPE_UNSIGNED_INTEGER;\r\n\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return Constants.TEXTURETYPE_FLOAT;\r\n\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                throw \"No fixed size for Stencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                throw \"No fixed size for Depth24Plus format!\";\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                throw \"No fixed size for Depth24PlusStencil8 format!\";\r\n        }\r\n\r\n        return Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    private static _GetBlockInformationFromFormat(format: GPUTextureFormat): { width: number; height: number; length: number } {\r\n        switch (format) {\r\n            // 8 bits formats\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n                return { width: 1, height: 1, length: 1 };\r\n\r\n            // 16 bits formats\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n                return { width: 1, height: 1, length: 2 };\r\n\r\n            // 32 bits formats\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm:\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat:\r\n                return { width: 1, height: 1, length: 4 };\r\n\r\n            // 64 bits formats\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n                return { width: 1, height: 1, length: 8 };\r\n\r\n            // 128 bits formats\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n                return { width: 1, height: 1, length: 16 };\r\n\r\n            // Depth and stencil formats\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n                throw \"No fixed size for Stencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n                return { width: 1, height: 1, length: 2 };\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n                throw \"No fixed size for Depth24Plus format!\";\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                throw \"No fixed size for Depth24PlusStencil8 format!\";\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n                return { width: 1, height: 1, length: 4 };\r\n            case WebGPUConstants.TextureFormat.Depth24UnormStencil8:\r\n                return { width: 1, height: 1, length: 4 };\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n                return { width: 1, height: 1, length: 5 };\r\n\r\n            // BC compressed formats usable if \"texture-compression-bc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            // ETC2 compressed formats usable if \"texture-compression-etc2\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return { width: 4, height: 4, length: 8 };\r\n\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return { width: 4, height: 4, length: 16 };\r\n\r\n            // ASTC compressed formats usable if \"texture-compression-astc\" is both\r\n            // supported by the device/user agent and enabled in requestDevice.\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n                return { width: 4, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n                return { width: 5, height: 4, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n                return { width: 5, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n                return { width: 6, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n                return { width: 6, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n                return { width: 8, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n                return { width: 8, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n                return { width: 8, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n                return { width: 10, height: 5, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n                return { width: 10, height: 6, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n                return { width: 10, height: 8, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n                return { width: 10, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n                return { width: 12, height: 10, length: 16 };\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return { width: 12, height: 12, length: 16 };\r\n        }\r\n\r\n        return { width: 1, height: 1, length: 4 };\r\n    }\r\n\r\n    private static _IsHardwareTexture(texture: HardwareTextureWrapper | GPUTexture): texture is HardwareTextureWrapper {\r\n        return !!(texture as HardwareTextureWrapper).release;\r\n    }\r\n\r\n    private static _IsInternalTexture(texture: InternalTexture | GPUTexture): texture is InternalTexture {\r\n        return !!(texture as InternalTexture).dispose;\r\n    }\r\n\r\n    public static IsImageBitmap(imageBitmap: ImageBitmap | { width: number; height: number }): imageBitmap is ImageBitmap {\r\n        return (imageBitmap as ImageBitmap).close !== undefined;\r\n    }\r\n\r\n    public static IsImageBitmapArray(imageBitmap: ImageBitmap[] | { width: number; height: number }): imageBitmap is ImageBitmap[] {\r\n        return Array.isArray(imageBitmap as ImageBitmap[]) && (imageBitmap as ImageBitmap[])[0].close !== undefined;\r\n    }\r\n\r\n    public setCommandEncoder(encoder: GPUCommandEncoder): void {\r\n        this._commandEncoderForCreation = encoder;\r\n    }\r\n\r\n    public static IsCompressedFormat(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static GetWebGPUTextureFormat(type: number, format: number, useSRGBBuffer = false): GPUTextureFormat {\r\n        switch (format) {\r\n            case Constants.TEXTUREFORMAT_DEPTH16:\r\n                return WebGPUConstants.TextureFormat.Depth16Unorm;\r\n            case Constants.TEXTUREFORMAT_DEPTH24:\r\n                return WebGPUConstants.TextureFormat.Depth24Plus;\r\n            case Constants.TEXTUREFORMAT_DEPTH24_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth24PlusStencil8;\r\n            case Constants.TEXTUREFORMAT_DEPTH32_FLOAT:\r\n                return WebGPUConstants.TextureFormat.Depth32Float;\r\n            case Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth24UnormStencil8;\r\n            case Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8:\r\n                return WebGPUConstants.TextureFormat.Depth32FloatStencil8;\r\n\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC7RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBUFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n                return WebGPUConstants.TextureFormat.BC6HRGBFloat;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC3RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC2RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB : WebGPUConstants.TextureFormat.BC1RGBAUnorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB : WebGPUConstants.TextureFormat.ASTC4x4Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGB8Unorm;\r\n            case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n                return useSRGBBuffer ? WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB : WebGPUConstants.TextureFormat.ETC2RGBA8Unorm;\r\n        }\r\n\r\n        switch (type) {\r\n            case Constants.TEXTURETYPE_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Snorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        throw \"RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Snorm;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_BGRA:\r\n                        return useSRGBBuffer ? WebGPUConstants.TextureFormat.BGRA8UnormSRGB : WebGPUConstants.TextureFormat.BGRA8Unorm;\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R8Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG8Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        throw \"RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Uint;\r\n                    case Constants.TEXTUREFORMAT_ALPHA:\r\n                        throw \"TEXTUREFORMAT_ALPHA format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE:\r\n                        throw \"TEXTUREFORMAT_LUMINANCE format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_LUMINANCE_ALPHA:\r\n                        throw \"TEXTUREFORMAT_LUMINANCE_ALPHA format not supported in WebGPU\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n                }\r\n            case Constants.TEXTURETYPE_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R16Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG16Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_INT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Sint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Sint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Sint;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_INTEGER: // Refers to UNSIGNED_INT\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.R32Uint;\r\n                    case Constants.TEXTUREFORMAT_RG_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RG32Uint;\r\n                    case Constants.TEXTUREFORMAT_RGB_INTEGER:\r\n                        throw \"TEXTUREFORMAT_RGB_INTEGER format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Uint;\r\n                }\r\n            case Constants.TEXTURETYPE_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R32Float; // By default. Other possibility is R16Float.\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG32Float; // By default. Other possibility is RG16Float.\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float; // By default. Other possibility is RGBA16Float.\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA32Float;\r\n                }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RED:\r\n                        return WebGPUConstants.TextureFormat.R16Float;\r\n                    case Constants.TEXTUREFORMAT_RG:\r\n                        return WebGPUConstants.TextureFormat.RG16Float;\r\n                    case Constants.TEXTUREFORMAT_RGB:\r\n                        throw \"TEXTUREFORMAT_RGB format not supported in WebGPU\";\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGBA16Float;\r\n                }\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_6_5 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n                throw \"TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n                throw \"TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n                throw \"TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 format not supported in WebGPU\";\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n                switch (format) {\r\n                    case Constants.TEXTUREFORMAT_RGBA:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                    case Constants.TEXTUREFORMAT_RGBA_INTEGER:\r\n                        throw \"TEXTUREFORMAT_RGBA_INTEGER format not supported in WebGPU when type is TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV\";\r\n                    default:\r\n                        return WebGPUConstants.TextureFormat.RGB10A2Unorm;\r\n                }\r\n        }\r\n\r\n        return useSRGBBuffer ? WebGPUConstants.TextureFormat.RGBA8UnormSRGB : WebGPUConstants.TextureFormat.RGBA8Unorm;\r\n    }\r\n\r\n    public static GetNumChannelsFromWebGPUTextureFormat(format: GPUTextureFormat): number {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.R8Unorm:\r\n            case WebGPUConstants.TextureFormat.R8Snorm:\r\n            case WebGPUConstants.TextureFormat.R8Uint:\r\n            case WebGPUConstants.TextureFormat.R8Sint:\r\n            case WebGPUConstants.TextureFormat.BC4RUnorm:\r\n            case WebGPUConstants.TextureFormat.BC4RSnorm:\r\n            case WebGPUConstants.TextureFormat.R16Uint:\r\n            case WebGPUConstants.TextureFormat.R16Sint:\r\n            case WebGPUConstants.TextureFormat.Depth16Unorm:\r\n            case WebGPUConstants.TextureFormat.R16Float:\r\n            case WebGPUConstants.TextureFormat.R32Uint:\r\n            case WebGPUConstants.TextureFormat.R32Sint:\r\n            case WebGPUConstants.TextureFormat.R32Float:\r\n            case WebGPUConstants.TextureFormat.Depth32Float:\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24Plus:\r\n            case WebGPUConstants.TextureFormat.EACR11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACR11Snorm:\r\n                return 1;\r\n\r\n            case WebGPUConstants.TextureFormat.RG8Unorm:\r\n            case WebGPUConstants.TextureFormat.RG8Snorm:\r\n            case WebGPUConstants.TextureFormat.RG8Uint:\r\n            case WebGPUConstants.TextureFormat.RG8Sint:\r\n            case WebGPUConstants.TextureFormat.Depth24UnormStencil8: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC5RGUnorm:\r\n            case WebGPUConstants.TextureFormat.BC5RGSnorm:\r\n            case WebGPUConstants.TextureFormat.RG16Uint:\r\n            case WebGPUConstants.TextureFormat.RG16Sint:\r\n            case WebGPUConstants.TextureFormat.RG16Float:\r\n            case WebGPUConstants.TextureFormat.RG32Uint:\r\n            case WebGPUConstants.TextureFormat.RG32Sint:\r\n            case WebGPUConstants.TextureFormat.RG32Float:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n            case WebGPUConstants.TextureFormat.EACRG11Unorm:\r\n            case WebGPUConstants.TextureFormat.EACRG11Snorm:\r\n                return 2;\r\n\r\n            case WebGPUConstants.TextureFormat.RGB9E5UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.RG11B10UFloat: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC6HRGBUFloat:\r\n            case WebGPUConstants.TextureFormat.BC6HRGBFloat:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8UnormSRGB:\r\n                return 3;\r\n\r\n            case WebGPUConstants.TextureFormat.RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA8Snorm:\r\n            case WebGPUConstants.TextureFormat.RGBA8Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA8Sint:\r\n            case WebGPUConstants.TextureFormat.BGRA8Unorm:\r\n            case WebGPUConstants.TextureFormat.BGRA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGB10A2Unorm: // composite format - let's say it's byte...\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC7RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC3RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC2RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnorm:\r\n            case WebGPUConstants.TextureFormat.BC1RGBAUnormSRGB:\r\n            case WebGPUConstants.TextureFormat.RGBA16Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA16Float:\r\n            case WebGPUConstants.TextureFormat.RGBA32Uint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Sint:\r\n            case WebGPUConstants.TextureFormat.RGBA32Float:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGB8A1UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8Unorm:\r\n            case WebGPUConstants.TextureFormat.ETC2RGBA8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC4x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x4UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC5x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC6x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC8x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x5UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x6UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x8UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC10x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x10UnormSRGB:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12Unorm:\r\n            case WebGPUConstants.TextureFormat.ASTC12x12UnormSRGB:\r\n                return 4;\r\n        }\r\n\r\n        throw `Unknown format ${format}!`;\r\n    }\r\n\r\n    public static HasStencilAspect(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Stencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24UnormStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static HasDepthAndStencilAspects(format: GPUTextureFormat): boolean {\r\n        switch (format) {\r\n            case WebGPUConstants.TextureFormat.Depth24UnormStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth32FloatStencil8:\r\n            case WebGPUConstants.TextureFormat.Depth24PlusStencil8:\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public copyVideoToTexture(video: ExternalTexture, texture: InternalTexture, format: GPUTextureFormat, invertY = false, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getVideoPipeline(format, invertY ? VideoPipelineType.InvertY : VideoPipelineType.DontInvertY);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`copy video to texture - invertY=${invertY}`);\r\n\r\n        const webgpuHardwareTexture = texture._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n        const renderPassDescriptor: GPURenderPassDescriptor = {\r\n            colorAttachments: [\r\n                {\r\n                    view: webgpuHardwareTexture.underlyingResource!.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        mipLevelCount: 1,\r\n                        baseArrayLayer: 0,\r\n                        baseMipLevel: 0,\r\n                        arrayLayerCount: 1,\r\n                        aspect: WebGPUConstants.TextureAspect.All,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const descriptor: GPUBindGroupDescriptor = {\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: this._videoSampler,\r\n                },\r\n                {\r\n                    binding: 1,\r\n                    resource: this._device.importExternalTexture({\r\n                        source: video.underlyingResource,\r\n                    }),\r\n                },\r\n            ],\r\n        };\r\n\r\n        const bindGroup = this._device.createBindGroup(descriptor);\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public invertYPreMultiplyAlpha(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        faceIndex = 0,\r\n        mipLevel = 0,\r\n        layers = 1,\r\n        ofstX = 0,\r\n        ofstY = 0,\r\n        rectWidth = 0,\r\n        rectHeight = 0,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const useRect = rectWidth !== 0;\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, useRect ? PipelineType.InvertYPremultiplyAlphaWithOfst : PipelineType.InvertYPremultiplyAlpha, {\r\n            invertY,\r\n            premultiplyAlpha,\r\n        });\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal process texture - invertY=${invertY} premultiplyAlpha=${premultiplyAlpha}`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper._IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            if (!(invertY && !premultiplyAlpha && layers === 1 && faceIndex === 0)) {\r\n                // we optimize only for the most likely case (invertY=true, premultiplyAlpha=false, layers=1, faceIndex=0) to avoid dealing with big caches\r\n                gpuOrHdwTexture = undefined as any;\r\n            }\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        if (useRect) {\r\n            this._bufferManager.setRawData(this._ubCopyWithOfst, 0, new Float32Array([ofstX, ofstY, rectWidth, rectHeight]), 0, 4 * 4);\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        const outputTexture =\r\n            webgpuHardwareTexture?._copyInvertYTempTexture ??\r\n            this.createTexture(\r\n                { width, height, layers: 1 },\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                false,\r\n                format,\r\n                1,\r\n                commandEncoder,\r\n                WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.TextureBinding\r\n            );\r\n\r\n        const renderPassDescriptor = webgpuHardwareTexture?._copyInvertYRenderPassDescr ?? {\r\n            colorAttachments: [\r\n                {\r\n                    view: outputTexture.createView({\r\n                        format,\r\n                        dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                        baseMipLevel: 0,\r\n                        mipLevelCount: 1,\r\n                        arrayLayerCount: 1,\r\n                        baseArrayLayer: 0,\r\n                    }),\r\n                    loadOp: WebGPUConstants.LoadOp.Load,\r\n                    storeOp: WebGPUConstants.StoreOp.Store,\r\n                },\r\n            ],\r\n        };\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        let bindGroup = useRect ? webgpuHardwareTexture?._copyInvertYBindGroupWithOfst : webgpuHardwareTexture?._copyInvertYBindGroup;\r\n        if (!bindGroup) {\r\n            const descriptor: GPUBindGroupDescriptor = {\r\n                layout: bindGroupLayout,\r\n                entries: [\r\n                    {\r\n                        binding: 0,\r\n                        resource: gpuTexture.createView({\r\n                            format,\r\n                            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: mipLevel,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: layers,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                    },\r\n                ],\r\n            };\r\n            if (useRect) {\r\n                descriptor.entries.push({\r\n                    binding: 1,\r\n                    resource: {\r\n                        buffer: this._ubCopyWithOfst,\r\n                    },\r\n                });\r\n            }\r\n            bindGroup = this._device.createBindGroup(descriptor);\r\n        }\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.copyTextureToTexture(\r\n            {\r\n                texture: outputTexture,\r\n            },\r\n            {\r\n                texture: gpuTexture,\r\n                mipLevel,\r\n                origin: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    z: faceIndex,\r\n                },\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        if (webgpuHardwareTexture) {\r\n            webgpuHardwareTexture._copyInvertYTempTexture = outputTexture;\r\n            webgpuHardwareTexture._copyInvertYRenderPassDescr = renderPassDescriptor;\r\n            if (useRect) {\r\n                webgpuHardwareTexture._copyInvertYBindGroupWithOfst = bindGroup;\r\n            } else {\r\n                webgpuHardwareTexture._copyInvertYBindGroup = bindGroup;\r\n            }\r\n        } else {\r\n            this._deferredReleaseTextures.push([outputTexture, null]);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public copyWithInvertY(srcTextureView: GPUTextureView, format: GPUTextureFormat, renderPassDescriptor: GPURenderPassDescriptor, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format, PipelineType.InvertYPremultiplyAlpha, { invertY: true, premultiplyAlpha: false });\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`internal copy texture with invertY`);\r\n\r\n        const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n        const bindGroup = this._device.createBindGroup({\r\n            layout: bindGroupLayout,\r\n            entries: [\r\n                {\r\n                    binding: 0,\r\n                    resource: srcTextureView,\r\n                },\r\n            ],\r\n        });\r\n\r\n        passEncoder.setPipeline(pipeline);\r\n        passEncoder.setBindGroup(0, bindGroup);\r\n        passEncoder.draw(4, 1, 0, 0);\r\n        passEncoder.end();\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                               Creation\r\n    //------------------------------------------------------------------------------\r\n\r\n    public createTexture(\r\n        imageBitmap: ImageBitmap | { width: number; height: number; layers: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        is3D = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0\r\n    ): GPUTexture {\r\n        if (sampleCount > 1) {\r\n            // WebGPU only supports 1 or 4\r\n            sampleCount = 4;\r\n        }\r\n\r\n        const layerCount = (imageBitmap as any).layers || 1;\r\n        const textureSize = {\r\n            width: imageBitmap.width,\r\n            height: imageBitmap.height,\r\n            depthOrArrayLayers: layerCount,\r\n        };\r\n\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(imageBitmap.width, imageBitmap.height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n\r\n        if (!isCompressedFormat && !is3D) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `Texture_${textureSize.width}x${textureSize.height}x${textureSize.depthOrArrayLayers}_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\r\n            size: textureSize,\r\n            dimension: is3D ? WebGPUConstants.TextureDimension.E3d : WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmap(imageBitmap)) {\r\n            this.updateTexture(imageBitmap, gpuTexture, imageBitmap.width, imageBitmap.height, layerCount, format, 0, 0, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateMipmaps(gpuTexture, format, mipLevelCount, 0, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public createCubeTexture(\r\n        imageBitmaps: ImageBitmap[] | { width: number; height: number },\r\n        hasMipmaps = false,\r\n        generateMipmaps = false,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        format: GPUTextureFormat = WebGPUConstants.TextureFormat.RGBA8Unorm,\r\n        sampleCount = 1,\r\n        commandEncoder?: GPUCommandEncoder,\r\n        usage = -1,\r\n        additionalUsages = 0\r\n    ): GPUTexture {\r\n        if (sampleCount > 1) {\r\n            // WebGPU only supports 1 or 4\r\n            sampleCount = 4;\r\n        }\r\n\r\n        const width = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].width : imageBitmaps.width;\r\n        const height = WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps) ? imageBitmaps[0].height : imageBitmaps.height;\r\n\r\n        const isCompressedFormat = WebGPUTextureHelper.IsCompressedFormat(format);\r\n        const mipLevelCount = hasMipmaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width, height) : 1;\r\n        const usages = usage >= 0 ? usage : WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.CopyDst | WebGPUConstants.TextureUsage.TextureBinding;\r\n        additionalUsages |= hasMipmaps && !isCompressedFormat ? WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment : 0;\r\n\r\n        if (!isCompressedFormat) {\r\n            // we don't know in advance if the texture will be updated with copyExternalImageToTexture (which requires to have those flags), so we need to force the flags all the times\r\n            additionalUsages |= WebGPUConstants.TextureUsage.RenderAttachment | WebGPUConstants.TextureUsage.CopyDst;\r\n        }\r\n\r\n        const gpuTexture = this._device.createTexture({\r\n            label: `TextureCube_${width}x${height}x6_${hasMipmaps ? \"wmips\" : \"womips\"}_${format}_samples${sampleCount}`,\r\n            size: {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 6,\r\n            },\r\n            dimension: WebGPUConstants.TextureDimension.E2d,\r\n            format,\r\n            usage: usages | additionalUsages,\r\n            sampleCount,\r\n            mipLevelCount,\r\n        });\r\n\r\n        if (WebGPUTextureHelper.IsImageBitmapArray(imageBitmaps)) {\r\n            this.updateCubeTextures(imageBitmaps, gpuTexture, width, height, format, invertY, premultiplyAlpha, 0, 0);\r\n\r\n            if (hasMipmaps && generateMipmaps) {\r\n                this.generateCubeMipmaps(gpuTexture, format, mipLevelCount, commandEncoder);\r\n            }\r\n        }\r\n\r\n        return gpuTexture;\r\n    }\r\n\r\n    public generateCubeMipmaps(gpuTexture: GPUTexture | WebGPUHardwareTexture, format: GPUTextureFormat, mipLevelCount: number, commandEncoder?: GPUCommandEncoder): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create cube mipmaps - ${mipLevelCount} levels`);\r\n\r\n        for (let f = 0; f < 6; ++f) {\r\n            this.generateMipmaps(gpuTexture, format, mipLevelCount, f, commandEncoder);\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public generateMipmaps(\r\n        gpuOrHdwTexture: GPUTexture | WebGPUHardwareTexture,\r\n        format: GPUTextureFormat,\r\n        mipLevelCount: number,\r\n        faceIndex = 0,\r\n        commandEncoder?: GPUCommandEncoder\r\n    ): void {\r\n        const useOwnCommandEncoder = commandEncoder === undefined;\r\n        const [pipeline, bindGroupLayout] = this._getPipeline(format);\r\n\r\n        faceIndex = Math.max(faceIndex, 0);\r\n\r\n        if (useOwnCommandEncoder) {\r\n            commandEncoder = this._device.createCommandEncoder({});\r\n        }\r\n\r\n        commandEncoder!.pushDebugGroup?.(`create mipmaps for face #${faceIndex} - ${mipLevelCount} levels`);\r\n\r\n        let gpuTexture: Nullable<GPUTexture>;\r\n        if (WebGPUTextureHelper._IsHardwareTexture(gpuOrHdwTexture)) {\r\n            gpuTexture = gpuOrHdwTexture.underlyingResource;\r\n            gpuOrHdwTexture._mipmapGenRenderPassDescr = gpuOrHdwTexture._mipmapGenRenderPassDescr || [];\r\n            gpuOrHdwTexture._mipmapGenBindGroup = gpuOrHdwTexture._mipmapGenBindGroup || [];\r\n        } else {\r\n            gpuTexture = gpuOrHdwTexture;\r\n            gpuOrHdwTexture = undefined as any;\r\n        }\r\n        if (!gpuTexture) {\r\n            return;\r\n        }\r\n\r\n        const webgpuHardwareTexture = gpuOrHdwTexture as Nullable<WebGPUHardwareTexture>;\r\n        for (let i = 1; i < mipLevelCount; ++i) {\r\n            const renderPassDescriptor = webgpuHardwareTexture?._mipmapGenRenderPassDescr[faceIndex]?.[i - 1] ?? {\r\n                colorAttachments: [\r\n                    {\r\n                        view: gpuTexture.createView({\r\n                            format,\r\n                            dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                            baseMipLevel: i,\r\n                            mipLevelCount: 1,\r\n                            arrayLayerCount: 1,\r\n                            baseArrayLayer: faceIndex,\r\n                        }),\r\n                        loadOp: WebGPUConstants.LoadOp.Load,\r\n                        storeOp: WebGPUConstants.StoreOp.Store,\r\n                    },\r\n                ],\r\n            };\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] = webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenRenderPassDescr[faceIndex][i - 1] = renderPassDescriptor;\r\n            }\r\n            const passEncoder = commandEncoder!.beginRenderPass(renderPassDescriptor);\r\n\r\n            const bindGroup =\r\n                webgpuHardwareTexture?._mipmapGenBindGroup[faceIndex]?.[i - 1] ??\r\n                this._device.createBindGroup({\r\n                    layout: bindGroupLayout,\r\n                    entries: [\r\n                        {\r\n                            binding: 0,\r\n                            resource: this._mipmapSampler,\r\n                        },\r\n                        {\r\n                            binding: 1,\r\n                            resource: gpuTexture.createView({\r\n                                format,\r\n                                dimension: WebGPUConstants.TextureViewDimension.E2d,\r\n                                baseMipLevel: i - 1,\r\n                                mipLevelCount: 1,\r\n                                arrayLayerCount: 1,\r\n                                baseArrayLayer: faceIndex,\r\n                            }),\r\n                        },\r\n                    ],\r\n                });\r\n            if (webgpuHardwareTexture) {\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] = webgpuHardwareTexture._mipmapGenBindGroup[faceIndex] || [];\r\n                webgpuHardwareTexture._mipmapGenBindGroup[faceIndex][i - 1] = bindGroup;\r\n            }\r\n\r\n            passEncoder.setPipeline(pipeline);\r\n            passEncoder.setBindGroup(0, bindGroup);\r\n            passEncoder.draw(4, 1, 0, 0);\r\n            passEncoder.end();\r\n        }\r\n\r\n        commandEncoder!.popDebugGroup?.();\r\n\r\n        if (useOwnCommandEncoder) {\r\n            this._device.queue.submit([commandEncoder!.finish()]);\r\n            commandEncoder = null as any;\r\n        }\r\n    }\r\n\r\n    public createGPUTextureForInternalTexture(texture: InternalTexture, width?: number, height?: number, depth?: number, creationFlags?: number): WebGPUHardwareTexture {\r\n        if (!texture._hardwareTexture) {\r\n            texture._hardwareTexture = new WebGPUHardwareTexture();\r\n        }\r\n\r\n        if (width === undefined) {\r\n            width = texture.width;\r\n        }\r\n        if (height === undefined) {\r\n            height = texture.height;\r\n        }\r\n        if (depth === undefined) {\r\n            depth = texture.depth;\r\n        }\r\n\r\n        const gpuTextureWrapper = texture._hardwareTexture as WebGPUHardwareTexture;\r\n        const isStorageTexture = ((creationFlags ?? 0) & Constants.TEXTURE_CREATIONFLAG_STORAGE) !== 0;\r\n\r\n        gpuTextureWrapper.format = WebGPUTextureHelper.GetWebGPUTextureFormat(texture.type, texture.format, texture._useSRGBBuffer);\r\n\r\n        gpuTextureWrapper.textureUsages =\r\n            texture._source === InternalTextureSource.RenderTarget || texture.source === InternalTextureSource.MultiRenderTarget\r\n                ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.RenderAttachment\r\n                : texture._source === InternalTextureSource.DepthStencil\r\n                ? WebGPUConstants.TextureUsage.TextureBinding | WebGPUConstants.TextureUsage.RenderAttachment\r\n                : -1;\r\n\r\n        gpuTextureWrapper.textureAdditionalUsages = isStorageTexture ? WebGPUConstants.TextureUsage.StorageBinding : 0;\r\n\r\n        const hasMipMaps = texture.generateMipMaps;\r\n        const layerCount = depth || 1;\r\n        let mipmapCount;\r\n        if (texture._maxLodLevel !== null) {\r\n            mipmapCount = texture._maxLodLevel;\r\n        } else {\r\n            mipmapCount = hasMipMaps ? WebGPUTextureHelper.ComputeNumMipmapLevels(width!, height!) : 1;\r\n        }\r\n\r\n        if (texture.isCube) {\r\n            const gpuTexture = this.createCubeTexture(\r\n                { width, height },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    format: gpuTextureWrapper.format,\r\n                    dimension: WebGPUConstants.TextureViewDimension.Cube,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount: 6,\r\n                    aspect: WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        } else {\r\n            const gpuTexture = this.createTexture(\r\n                { width, height, layers: layerCount },\r\n                texture.generateMipMaps,\r\n                texture.generateMipMaps,\r\n                texture.invertY,\r\n                false,\r\n                texture.is3D,\r\n                gpuTextureWrapper.format,\r\n                1,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages\r\n            );\r\n\r\n            gpuTextureWrapper.set(gpuTexture);\r\n            gpuTextureWrapper.createView(\r\n                {\r\n                    format: gpuTextureWrapper.format,\r\n                    dimension: texture.is2DArray\r\n                        ? WebGPUConstants.TextureViewDimension.E2dArray\r\n                        : texture.is3D\r\n                        ? WebGPUConstants.TextureDimension.E3d\r\n                        : WebGPUConstants.TextureViewDimension.E2d,\r\n                    mipLevelCount: mipmapCount,\r\n                    baseArrayLayer: 0,\r\n                    baseMipLevel: 0,\r\n                    arrayLayerCount: texture.is3D ? 1 : layerCount,\r\n                    aspect: WebGPUTextureHelper.HasDepthAndStencilAspects(gpuTextureWrapper.format) ? WebGPUConstants.TextureAspect.DepthOnly : WebGPUConstants.TextureAspect.All,\r\n                },\r\n                isStorageTexture\r\n            );\r\n        }\r\n\r\n        texture.width = texture.baseWidth = width;\r\n        texture.height = texture.baseHeight = height;\r\n        texture.depth = texture.baseDepth = depth;\r\n\r\n        this.createMSAATexture(texture, texture.samples);\r\n\r\n        return gpuTextureWrapper;\r\n    }\r\n\r\n    public createMSAATexture(texture: InternalTexture, samples: number): void {\r\n        const gpuTextureWrapper = texture._hardwareTexture as Nullable<WebGPUHardwareTexture>;\r\n\r\n        if (gpuTextureWrapper?.msaaTexture) {\r\n            this.releaseTexture(gpuTextureWrapper.msaaTexture);\r\n            gpuTextureWrapper.msaaTexture = null;\r\n        }\r\n\r\n        if (!gpuTextureWrapper || (samples ?? 1) <= 1) {\r\n            return;\r\n        }\r\n\r\n        const width = texture.width;\r\n        const height = texture.height;\r\n        const layerCount = texture.depth || 1;\r\n\r\n        if (texture.isCube) {\r\n            const gpuMSAATexture = this.createCubeTexture(\r\n                { width, height },\r\n                false,\r\n                false,\r\n                texture.invertY,\r\n                false,\r\n                gpuTextureWrapper.format,\r\n                samples,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages\r\n            );\r\n            gpuTextureWrapper.msaaTexture = gpuMSAATexture;\r\n        } else {\r\n            const gpuMSAATexture = this.createTexture(\r\n                { width, height, layers: layerCount },\r\n                false,\r\n                false,\r\n                texture.invertY,\r\n                false,\r\n                texture.is3D,\r\n                gpuTextureWrapper.format,\r\n                samples,\r\n                this._commandEncoderForCreation,\r\n                gpuTextureWrapper.textureUsages,\r\n                gpuTextureWrapper.textureAdditionalUsages\r\n            );\r\n            gpuTextureWrapper.msaaTexture = gpuMSAATexture;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                                  Update\r\n    //------------------------------------------------------------------------------\r\n\r\n    public updateCubeTextures(\r\n        imageBitmaps: ImageBitmap[] | Uint8Array[],\r\n        gpuTexture: GPUTexture,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0\r\n    ): void {\r\n        const faces = [0, 3, 1, 4, 2, 5];\r\n\r\n        for (let f = 0; f < faces.length; ++f) {\r\n            const imageBitmap = imageBitmaps[faces[f]];\r\n\r\n            this.updateTexture(imageBitmap, gpuTexture, width, height, 1, format, f, 0, invertY, premultiplyAlpha, offsetX, offsetY);\r\n        }\r\n    }\r\n\r\n    // TODO WEBGPU handle data source not being in the same format than the destination texture?\r\n    public updateTexture(\r\n        imageBitmap: ImageBitmap | Uint8Array | HTMLCanvasElement | OffscreenCanvas,\r\n        texture: GPUTexture | InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        layers: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        invertY = false,\r\n        premultiplyAlpha = false,\r\n        offsetX = 0,\r\n        offsetY = 0,\r\n        allowGPUOptimization?: boolean\r\n    ): void {\r\n        const gpuTexture = WebGPUTextureHelper._IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture).underlyingResource! : texture;\r\n        const blockInformation = WebGPUTextureHelper._GetBlockInformationFromFormat(format);\r\n        const gpuOrHdwTexture = WebGPUTextureHelper._IsInternalTexture(texture) ? (texture._hardwareTexture as WebGPUHardwareTexture) : texture;\r\n\r\n        const textureCopyView: GPUImageCopyTextureTagged = {\r\n            texture: gpuTexture,\r\n            origin: {\r\n                x: offsetX,\r\n                y: offsetY,\r\n                z: Math.max(faceIndex, 0),\r\n            },\r\n            mipLevel: mipLevel,\r\n            premultipliedAlpha: premultiplyAlpha,\r\n        };\r\n\r\n        const textureExtent = {\r\n            width: Math.ceil(width / blockInformation.width) * blockInformation.width,\r\n            height: Math.ceil(height / blockInformation.height) * blockInformation.height,\r\n            depthOrArrayLayers: layers || 1,\r\n        };\r\n\r\n        if ((imageBitmap as Uint8Array).byteLength !== undefined) {\r\n            imageBitmap = imageBitmap as Uint8Array;\r\n\r\n            const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n            const aligned = Math.ceil(bytesPerRow / 256) * 256 === bytesPerRow;\r\n\r\n            if (aligned) {\r\n                const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                const buffer = this._bufferManager.createRawBuffer(imageBitmap.byteLength, WebGPUConstants.BufferUsage.MapWrite | WebGPUConstants.BufferUsage.CopySrc, true);\r\n\r\n                const arrayBuffer = buffer.getMappedRange();\r\n\r\n                new Uint8Array(arrayBuffer).set(imageBitmap);\r\n\r\n                buffer.unmap();\r\n\r\n                commandEncoder!.copyBufferToTexture(\r\n                    {\r\n                        buffer: buffer,\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureCopyView,\r\n                    textureExtent\r\n                );\r\n\r\n                this._device.queue.submit([commandEncoder!.finish()]);\r\n\r\n                this._bufferManager.releaseBuffer(buffer);\r\n            } else {\r\n                this._device.queue.writeTexture(\r\n                    textureCopyView,\r\n                    imageBitmap,\r\n                    {\r\n                        offset: 0,\r\n                        bytesPerRow,\r\n                        rowsPerImage: height,\r\n                    },\r\n                    textureExtent\r\n                );\r\n            }\r\n\r\n            if (invertY || premultiplyAlpha) {\r\n                if (WebGPUTextureHelper._IsInternalTexture(texture)) {\r\n                    const dontUseRect = offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height;\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        texture.width,\r\n                        texture.height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        offsetX,\r\n                        offsetY,\r\n                        dontUseRect ? 0 : width,\r\n                        dontUseRect ? 0 : height,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we should never take this code path\r\n                    throw \"updateTexture: Can't process the texture data because a GPUTexture was provided instead of an InternalTexture!\";\r\n                }\r\n            }\r\n        } else {\r\n            imageBitmap = imageBitmap as ImageBitmap | HTMLCanvasElement | OffscreenCanvas;\r\n\r\n            if (invertY) {\r\n                textureCopyView.premultipliedAlpha = false; // we are going to handle premultiplyAlpha ourselves\r\n\r\n                // we must preprocess the image\r\n                if (WebGPUTextureHelper._IsInternalTexture(texture) && offsetX === 0 && offsetY === 0 && width === texture.width && height === texture.height) {\r\n                    // optimization when the source image is the same size than the destination texture and offsets X/Y == 0:\r\n                    // we simply copy the source to the destination and we apply the preprocessing on the destination\r\n                    this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);\r\n\r\n                    this.invertYPreMultiplyAlpha(\r\n                        gpuOrHdwTexture,\r\n                        width,\r\n                        height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        undefined,\r\n                        allowGPUOptimization\r\n                    );\r\n                } else {\r\n                    // we must apply the preprocessing on the source image before copying it into the destination texture\r\n                    const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n                    // create a temp texture and copy the image to it\r\n                    const srcTexture = this.createTexture(\r\n                        { width, height, layers: 1 },\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        false,\r\n                        format,\r\n                        1,\r\n                        commandEncoder,\r\n                        WebGPUConstants.TextureUsage.CopySrc | WebGPUConstants.TextureUsage.TextureBinding\r\n                    );\r\n\r\n                    this._deferredReleaseTextures.push([srcTexture, null]);\r\n\r\n                    textureExtent.depthOrArrayLayers = 1;\r\n                    this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture: srcTexture }, textureExtent);\r\n                    textureExtent.depthOrArrayLayers = layers || 1;\r\n\r\n                    // apply the preprocessing to this temp texture\r\n                    this.invertYPreMultiplyAlpha(\r\n                        srcTexture,\r\n                        width,\r\n                        height,\r\n                        format,\r\n                        invertY,\r\n                        premultiplyAlpha,\r\n                        faceIndex,\r\n                        mipLevel,\r\n                        layers || 1,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        0,\r\n                        commandEncoder,\r\n                        allowGPUOptimization\r\n                    );\r\n\r\n                    // copy the temp texture to the destination texture\r\n                    commandEncoder.copyTextureToTexture({ texture: srcTexture }, textureCopyView, textureExtent);\r\n\r\n                    this._device.queue.submit([commandEncoder!.finish()]);\r\n                }\r\n            } else {\r\n                // no preprocessing: direct copy to destination texture\r\n                this._device.queue.copyExternalImageToTexture({ source: imageBitmap }, textureCopyView, textureExtent);\r\n            }\r\n        }\r\n    }\r\n\r\n    public readPixels(\r\n        texture: GPUTexture,\r\n        x: number,\r\n        y: number,\r\n        width: number,\r\n        height: number,\r\n        format: GPUTextureFormat,\r\n        faceIndex: number = 0,\r\n        mipLevel: number = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        noDataConversion = false\r\n    ): Promise<ArrayBufferView> {\r\n        const blockInformation = WebGPUTextureHelper._GetBlockInformationFromFormat(format);\r\n\r\n        const bytesPerRow = Math.ceil(width / blockInformation.width) * blockInformation.length;\r\n\r\n        const bytesPerRowAligned = Math.ceil(bytesPerRow / 256) * 256;\r\n\r\n        const size = bytesPerRowAligned * height;\r\n\r\n        const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n        const commandEncoder = this._device.createCommandEncoder({});\r\n\r\n        commandEncoder.copyTextureToBuffer(\r\n            {\r\n                texture,\r\n                mipLevel,\r\n                origin: {\r\n                    x,\r\n                    y,\r\n                    z: Math.max(faceIndex, 0),\r\n                },\r\n            },\r\n            {\r\n                buffer: gpuBuffer,\r\n                offset: 0,\r\n                bytesPerRow: bytesPerRowAligned,\r\n            },\r\n            {\r\n                width,\r\n                height,\r\n                depthOrArrayLayers: 1,\r\n            }\r\n        );\r\n\r\n        this._device.queue.submit([commandEncoder!.finish()]);\r\n\r\n        return this._bufferManager.readDataFromBuffer(\r\n            gpuBuffer,\r\n            size,\r\n            width,\r\n            height,\r\n            bytesPerRow,\r\n            bytesPerRowAligned,\r\n            WebGPUTextureHelper._GetTextureTypeFromFormat(format),\r\n            0,\r\n            buffer,\r\n            true,\r\n            noDataConversion\r\n        );\r\n    }\r\n\r\n    //------------------------------------------------------------------------------\r\n    //                              Dispose\r\n    //------------------------------------------------------------------------------\r\n\r\n    public releaseTexture(texture: InternalTexture | GPUTexture): void {\r\n        if (WebGPUTextureHelper._IsInternalTexture(texture)) {\r\n            const hardwareTexture = texture._hardwareTexture;\r\n            const irradianceTexture = texture._irradianceTexture;\r\n\r\n            // We can't destroy the objects just now because they could be used in the current frame - we delay the destroying after the end of the frame\r\n            this._deferredReleaseTextures.push([hardwareTexture, irradianceTexture]);\r\n        } else {\r\n            this._deferredReleaseTextures.push([texture, null]);\r\n        }\r\n    }\r\n\r\n    public destroyDeferredTextures(): void {\r\n        for (let i = 0; i < this._deferredReleaseTextures.length; ++i) {\r\n            const [hardwareTexture, irradianceTexture] = this._deferredReleaseTextures[i];\r\n\r\n            if (hardwareTexture) {\r\n                if (WebGPUTextureHelper._IsHardwareTexture(hardwareTexture)) {\r\n                    hardwareTexture.release();\r\n                } else {\r\n                    hardwareTexture.destroy();\r\n                }\r\n            }\r\n            irradianceTexture?.dispose();\r\n        }\r\n\r\n        this._deferredReleaseTextures.length = 0;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}