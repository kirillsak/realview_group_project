{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Scene } from \"../scene.js\";\nimport { PhysicsEngine as PhysicsEngineV1 } from \"./v1/physicsEngine.js\";\nimport { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine.js\";\n/**\n * Gets the current physics engine\n * @returns a IPhysicsEngine or null if none attached\n */\nScene.prototype.getPhysicsEngine = function () {\n  return this._physicsEngine;\n};\n/**\n * Enables physics to the current scene\n * @param gravity defines the scene's gravity for the physics engine\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\n * @returns a boolean indicating if the physics engine was initialized\n */\nScene.prototype.enablePhysics = function (gravity = null, plugin) {\n  if (this._physicsEngine) {\n    return true;\n  }\n  // Register the component to the scene\n  let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE);\n  if (!component) {\n    component = new PhysicsEngineSceneComponent(this);\n    this._addComponent(component);\n  }\n  try {\n    if (!plugin || (plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 1) {\n      this._physicsEngine = new PhysicsEngineV1(gravity, plugin);\n    } else if ((plugin === null || plugin === void 0 ? void 0 : plugin.getPluginVersion()) === 2) {\n      this._physicsEngine = new PhysicsEngineV2(gravity, plugin);\n    } else {\n      throw new Error(\"Unsupported Physics plugin version.\");\n    }\n    this._physicsTimeAccumulator = 0;\n    return true;\n  } catch (e) {\n    Logger.Error(e.message);\n    return false;\n  }\n};\n/**\n * Disables and disposes the physics engine associated with the scene\n */\nScene.prototype.disablePhysicsEngine = function () {\n  if (!this._physicsEngine) {\n    return;\n  }\n  this._physicsEngine.dispose();\n  this._physicsEngine = null;\n};\n/**\n * Gets a boolean indicating if there is an active physics engine\n * @returns a boolean indicating if there is an active physics engine\n */\nScene.prototype.isPhysicsEnabled = function () {\n  return this._physicsEngine !== undefined;\n};\n/**\n * Deletes a physics compound impostor\n * @param compound defines the compound to delete\n */\nScene.prototype.deleteCompoundImpostor = function (compound) {\n  const mesh = compound.parts[0].mesh;\n  if (mesh.physicsImpostor) {\n    mesh.physicsImpostor.dispose( /*true*/);\n    mesh.physicsImpostor = null;\n  }\n};\n/**\n * @internal\n */\nScene.prototype._advancePhysicsEngineStep = function (step) {\n  if (this._physicsEngine) {\n    const subTime = this._physicsEngine.getSubTimeStep();\n    if (subTime > 0) {\n      this._physicsTimeAccumulator += step;\n      while (this._physicsTimeAccumulator > subTime) {\n        this.onBeforePhysicsObservable.notifyObservers(this);\n        this._physicsEngine._step(subTime / 1000);\n        this.onAfterPhysicsObservable.notifyObservers(this);\n        this._physicsTimeAccumulator -= subTime;\n      }\n    } else {\n      this.onBeforePhysicsObservable.notifyObservers(this);\n      this._physicsEngine._step(step / 1000);\n      this.onAfterPhysicsObservable.notifyObservers(this);\n    }\n  }\n};\n/**\n * Defines the physics engine scene component responsible to manage a physics engine\n */\nexport class PhysicsEngineSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PHYSICSENGINE;\n    this.scene = scene;\n    this.scene.onBeforePhysicsObservable = new Observable();\n    this.scene.onAfterPhysicsObservable = new Observable();\n    // Replace the function used to get the deterministic frame time\n    this.scene.getDeterministicFrameTime = () => {\n      if (this.scene._physicsEngine) {\n        return this.scene._physicsEngine.getTimeStep() * 1000;\n      }\n      return 1000.0 / 60.0;\n    };\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {}\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do for this component\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    this.scene.onBeforePhysicsObservable.clear();\n    this.scene.onAfterPhysicsObservable.clear();\n    if (this.scene._physicsEngine) {\n      this.scene.disablePhysicsEngine();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","Observable","SceneComponentConstants","Scene","PhysicsEngine","PhysicsEngineV1","PhysicsEngineV2","prototype","getPhysicsEngine","_physicsEngine","enablePhysics","gravity","plugin","component","_getComponent","NAME_PHYSICSENGINE","PhysicsEngineSceneComponent","_addComponent","getPluginVersion","Error","_physicsTimeAccumulator","e","message","disablePhysicsEngine","dispose","isPhysicsEnabled","undefined","deleteCompoundImpostor","compound","mesh","parts","physicsImpostor","_advancePhysicsEngineStep","step","subTime","getSubTimeStep","onBeforePhysicsObservable","notifyObservers","_step","onAfterPhysicsObservable","constructor","scene","getDeterministicFrameTime","getTimeStep","register","rebuild","clear"],"sourceRoot":"","sources":["../../../../lts/core/generated/Physics/joinedPhysicsEngineComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { IPhysicsEngine } from \"./IPhysicsEngine\";\r\nimport type { IPhysicsEnginePlugin as IPhysicsEnginePluginV1 } from \"./v1/IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnginePluginV2 } from \"./v2/IPhysicsEnginePlugin\";\r\nimport { PhysicsEngine as PhysicsEngineV1 } from \"./v1/physicsEngine\";\r\nimport { PhysicsEngine as PhysicsEngineV2 } from \"./v2/physicsEngine\";\r\n\r\ndeclare module \"../scene\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _physicsEngine: Nullable<IPhysicsEngine>;\r\n        /** @internal */\r\n        _physicsTimeAccumulator: number;\r\n\r\n        /**\r\n         * Gets the current physics engine\r\n         * @returns a IPhysicsEngine or null if none attached\r\n         */\r\n        getPhysicsEngine(): Nullable<IPhysicsEngine>;\r\n\r\n        /**\r\n         * Enables physics to the current scene\r\n         * @param gravity defines the scene's gravity for the physics engine. defaults to real earth gravity : (0, -9.81, 0)\r\n         * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n         * @returns a boolean indicating if the physics engine was initialized\r\n         */\r\n        enablePhysics(gravity?: Nullable<Vector3>, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean;\r\n\r\n        /**\r\n         * Disables and disposes the physics engine associated with the scene\r\n         */\r\n        disablePhysicsEngine(): void;\r\n\r\n        /**\r\n         * Gets a boolean indicating if there is an active physics engine\r\n         * @returns a boolean indicating if there is an active physics engine\r\n         */\r\n        isPhysicsEnabled(): boolean;\r\n\r\n        /**\r\n         * Deletes a physics compound impostor\r\n         * @param compound defines the compound to delete\r\n         */\r\n        deleteCompoundImpostor(compound: any): void;\r\n\r\n        /**\r\n         * An event triggered when physic simulation is about to be run\r\n         */\r\n        onBeforePhysicsObservable: Observable<Scene>;\r\n\r\n        /**\r\n         * An event triggered when physic simulation has been done\r\n         */\r\n        onAfterPhysicsObservable: Observable<Scene>;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the current physics engine\r\n * @returns a IPhysicsEngine or null if none attached\r\n */\r\nScene.prototype.getPhysicsEngine = function (): Nullable<IPhysicsEngine> {\r\n    return this._physicsEngine;\r\n};\r\n\r\n/**\r\n * Enables physics to the current scene\r\n * @param gravity defines the scene's gravity for the physics engine\r\n * @param plugin defines the physics engine to be used. defaults to CannonJS.\r\n * @returns a boolean indicating if the physics engine was initialized\r\n */\r\nScene.prototype.enablePhysics = function (gravity: Nullable<Vector3> = null, plugin?: IPhysicsEnginePluginV1 | IPhysicsEnginePluginV2): boolean {\r\n    if (this._physicsEngine) {\r\n        return true;\r\n    }\r\n\r\n    // Register the component to the scene\r\n    let component = this._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE) as PhysicsEngineSceneComponent;\r\n    if (!component) {\r\n        component = new PhysicsEngineSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    try {\r\n        if (!plugin || plugin?.getPluginVersion() === 1) {\r\n            this._physicsEngine = new PhysicsEngineV1(gravity, plugin as IPhysicsEnginePluginV1);\r\n        } else if (plugin?.getPluginVersion() === 2) {\r\n            this._physicsEngine = new PhysicsEngineV2(gravity, plugin as IPhysicsEnginePluginV2);\r\n        } else {\r\n            throw new Error(\"Unsupported Physics plugin version.\");\r\n        }\r\n        this._physicsTimeAccumulator = 0;\r\n        return true;\r\n    } catch (e) {\r\n        Logger.Error(e.message);\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Disables and disposes the physics engine associated with the scene\r\n */\r\nScene.prototype.disablePhysicsEngine = function (): void {\r\n    if (!this._physicsEngine) {\r\n        return;\r\n    }\r\n\r\n    this._physicsEngine.dispose();\r\n    this._physicsEngine = null;\r\n};\r\n\r\n/**\r\n * Gets a boolean indicating if there is an active physics engine\r\n * @returns a boolean indicating if there is an active physics engine\r\n */\r\nScene.prototype.isPhysicsEnabled = function (): boolean {\r\n    return this._physicsEngine !== undefined;\r\n};\r\n\r\n/**\r\n * Deletes a physics compound impostor\r\n * @param compound defines the compound to delete\r\n */\r\nScene.prototype.deleteCompoundImpostor = function (compound: any): void {\r\n    const mesh: AbstractMesh = compound.parts[0].mesh;\r\n\r\n    if (mesh.physicsImpostor) {\r\n        mesh.physicsImpostor.dispose(/*true*/);\r\n        mesh.physicsImpostor = null;\r\n    }\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\nScene.prototype._advancePhysicsEngineStep = function (step: number) {\r\n    if (this._physicsEngine) {\r\n        const subTime = this._physicsEngine.getSubTimeStep();\r\n        if (subTime > 0) {\r\n            this._physicsTimeAccumulator += step;\r\n            while (this._physicsTimeAccumulator > subTime) {\r\n                this.onBeforePhysicsObservable.notifyObservers(this);\r\n                this._physicsEngine._step(subTime / 1000);\r\n                this.onAfterPhysicsObservable.notifyObservers(this);\r\n                this._physicsTimeAccumulator -= subTime;\r\n            }\r\n        } else {\r\n            this.onBeforePhysicsObservable.notifyObservers(this);\r\n            this._physicsEngine._step(step / 1000);\r\n            this.onAfterPhysicsObservable.notifyObservers(this);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defines the physics engine scene component responsible to manage a physics engine\r\n */\r\nexport class PhysicsEngineSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PHYSICSENGINE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.scene.onBeforePhysicsObservable = new Observable<Scene>();\r\n        this.scene.onAfterPhysicsObservable = new Observable<Scene>();\r\n\r\n        // Replace the function used to get the deterministic frame time\r\n        this.scene.getDeterministicFrameTime = () => {\r\n            if (this.scene._physicsEngine) {\r\n                return this.scene._physicsEngine.getTimeStep() * 1000;\r\n            }\r\n\r\n            return 1000.0 / 60.0;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        this.scene.onBeforePhysicsObservable.clear();\r\n        this.scene.onAfterPhysicsObservable.clear();\r\n\r\n        if (this.scene._physicsEngine) {\r\n            this.scene.disablePhysicsEngine();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}