{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture.js\";\nimport \"../../Shaders/shadowMap.fragment.js\";\nimport \"../../Shaders/shadowMap.vertex.js\";\nimport \"../../Shaders/depthBoxBlur.fragment.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShadowGenerator } from \"./shadowGenerator.js\";\nimport { BoundingInfo } from \"../../Culling/boundingInfo.js\";\nimport { DepthReducer } from \"../../Misc/depthReducer.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst UpDir = Vector3.Up();\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst ZeroVec = Vector3.Zero();\nconst tmpv1 = new Vector3(),\n  tmpv2 = new Vector3(),\n  tmpMatrix = new Matrix();\n/**\n * A CSM implementation allowing casting shadows on large scenes.\n * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/\n */\nexport class CascadedShadowGenerator extends ShadowGenerator {\n  /**\n   * Creates a Cascaded Shadow Generator object.\n   * A ShadowGenerator is the required tool to use the shadows.\n   * Each directional light casting shadows needs to use its own ShadowGenerator.\n   * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\n   * @param mapSize The size of the texture what stores the shadows. Example : 1024.\n   * @param light The directional light object generating the shadows.\n   * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n   * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\n   */\n  constructor(mapSize, light, usefulFloatFirst, camera) {\n    if (!CascadedShadowGenerator.IsSupported) {\n      Logger.Error(\"CascadedShadowMap is not supported by the current engine.\");\n      return;\n    }\n    super(mapSize, light, usefulFloatFirst, camera);\n    this.usePercentageCloserFiltering = true;\n  }\n  _validateFilter(filter) {\n    if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {\n      return filter;\n    }\n    console.error('Unsupported filter \"' + filter + '\"!');\n    return ShadowGenerator.FILTER_NONE;\n  }\n  /**\n   * Gets or set the number of cascades used by the CSM.\n   */\n  get numCascades() {\n    return this._numCascades;\n  }\n  set numCascades(value) {\n    value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);\n    if (value === this._numCascades) {\n      return;\n    }\n    this._numCascades = value;\n    this.recreateShadowMap();\n    this._recreateSceneUBOs();\n  }\n  /**\n   * Enables or disables the shadow casters bounding info computation.\n   * If your shadow casters don't move, you can disable this feature.\n   * If it is enabled, the bounding box computation is done every frame.\n   */\n  get freezeShadowCastersBoundingInfo() {\n    return this._freezeShadowCastersBoundingInfo;\n  }\n  set freezeShadowCastersBoundingInfo(freeze) {\n    if (this._freezeShadowCastersBoundingInfoObservable && freeze) {\n      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n      this._freezeShadowCastersBoundingInfoObservable = null;\n    }\n    if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {\n      this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));\n    }\n    this._freezeShadowCastersBoundingInfo = freeze;\n    if (freeze) {\n      this._computeShadowCastersBoundingInfo();\n    }\n  }\n  _computeShadowCastersBoundingInfo() {\n    this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n    if (this._shadowMap && this._shadowMap.renderList) {\n      const renderList = this._shadowMap.renderList;\n      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n        const mesh = renderList[meshIndex];\n        if (!mesh) {\n          continue;\n        }\n        const boundingInfo = mesh.getBoundingInfo(),\n          boundingBox = boundingInfo.boundingBox;\n        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n      }\n      const meshes = this._scene.meshes;\n      for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\n        const mesh = meshes[meshIndex];\n        if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {\n          continue;\n        }\n        const boundingInfo = mesh.getBoundingInfo(),\n          boundingBox = boundingInfo.boundingBox;\n        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\n        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\n      }\n    }\n    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);\n  }\n  /**\n   * Gets or sets the shadow casters bounding info.\n   * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo\n   * so that the system won't overwrite the bounds you provide\n   */\n  get shadowCastersBoundingInfo() {\n    return this._shadowCastersBoundingInfo;\n  }\n  set shadowCastersBoundingInfo(boundingInfo) {\n    this._shadowCastersBoundingInfo = boundingInfo;\n  }\n  /**\n   * Sets the minimal and maximal distances to use when computing the cascade breaks.\n   *\n   * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.\n   * If you don't know these values, simply leave them to their defaults and don't call this function.\n   * @param min minimal distance for the breaks (default to 0.)\n   * @param max maximal distance for the breaks (default to 1.)\n   */\n  setMinMaxDistance(min, max) {\n    if (this._minDistance === min && this._maxDistance === max) {\n      return;\n    }\n    if (min > max) {\n      min = 0;\n      max = 1;\n    }\n    if (min < 0) {\n      min = 0;\n    }\n    if (max > 1) {\n      max = 1;\n    }\n    this._minDistance = min;\n    this._maxDistance = max;\n    this._breaksAreDirty = true;\n  }\n  /** Gets the minimal distance used in the cascade break computation */\n  get minDistance() {\n    return this._minDistance;\n  }\n  /** Gets the maximal distance used in the cascade break computation */\n  get maxDistance() {\n    return this._maxDistance;\n  }\n  /**\n   * Gets the class name of that object\n   * @returns \"CascadedShadowGenerator\"\n   */\n  getClassName() {\n    return CascadedShadowGenerator.CLASSNAME;\n  }\n  /**\n   * Gets a cascade minimum extents\n   * @param cascadeIndex index of the cascade\n   * @returns the minimum cascade extents\n   */\n  getCascadeMinExtents(cascadeIndex) {\n    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;\n  }\n  /**\n   * Gets a cascade maximum extents\n   * @param cascadeIndex index of the cascade\n   * @returns the maximum cascade extents\n   */\n  getCascadeMaxExtents(cascadeIndex) {\n    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;\n  }\n  /**\n   * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.\n   * It defaults to camera.maxZ\n   */\n  get shadowMaxZ() {\n    if (!this._getCamera()) {\n      return 0;\n    }\n    return this._shadowMaxZ;\n  }\n  /**\n   * Sets the shadow max z distance.\n   */\n  set shadowMaxZ(value) {\n    const camera = this._getCamera();\n    if (!camera) {\n      this._shadowMaxZ = value;\n      return;\n    }\n    if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ) {\n      return;\n    }\n    this._shadowMaxZ = value;\n    this._light._markMeshesAsLightDirty();\n    this._breaksAreDirty = true;\n  }\n  /**\n   * Gets or sets the debug flag.\n   * When enabled, the cascades are materialized by different colors on the screen.\n   */\n  get debug() {\n    return this._debug;\n  }\n  set debug(dbg) {\n    this._debug = dbg;\n    this._light._markMeshesAsLightDirty();\n  }\n  /**\n   * Gets or sets the depth clamping value.\n   *\n   * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted\n   * to account for the shadow casters far away.\n   *\n   * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.\n   */\n  get depthClamp() {\n    return this._depthClamp;\n  }\n  set depthClamp(value) {\n    this._depthClamp = value;\n  }\n  /**\n   * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).\n   * It defaults to 0.1 (10% blending).\n   */\n  get cascadeBlendPercentage() {\n    return this._cascadeBlendPercentage;\n  }\n  set cascadeBlendPercentage(value) {\n    this._cascadeBlendPercentage = value;\n    this._light._markMeshesAsLightDirty();\n  }\n  /**\n   * Gets or set the lambda parameter.\n   * This parameter is used to split the camera frustum and create the cascades.\n   * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.\n   * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.\n   */\n  get lambda() {\n    return this._lambda;\n  }\n  set lambda(value) {\n    const lambda = Math.min(Math.max(value, 0), 1);\n    if (this._lambda == lambda) {\n      return;\n    }\n    this._lambda = lambda;\n    this._breaksAreDirty = true;\n  }\n  /**\n   * Gets the view matrix corresponding to a given cascade\n   * @param cascadeNum cascade to retrieve the view matrix from\n   * @returns the cascade view matrix\n   */\n  getCascadeViewMatrix(cascadeNum) {\n    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;\n  }\n  /**\n   * Gets the projection matrix corresponding to a given cascade\n   * @param cascadeNum cascade to retrieve the projection matrix from\n   * @returns the cascade projection matrix\n   */\n  getCascadeProjectionMatrix(cascadeNum) {\n    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;\n  }\n  /**\n   * Gets the transformation matrix corresponding to a given cascade\n   * @param cascadeNum cascade to retrieve the transformation matrix from\n   * @returns the cascade transformation matrix\n   */\n  getCascadeTransformMatrix(cascadeNum) {\n    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;\n  }\n  /**\n   * Sets the depth renderer to use when autoCalcDepthBounds is enabled.\n   *\n   * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.\n   *\n   * You should call this function if you already have a depth renderer enabled in your scene, to avoid\n   * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!\n   * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created\n   */\n  setDepthRenderer(depthRenderer) {\n    this._depthRenderer = depthRenderer;\n    if (this._depthReducer) {\n      this._depthReducer.setDepthRenderer(this._depthRenderer);\n    }\n  }\n  /**\n   * Gets or sets the autoCalcDepthBounds property.\n   *\n   * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one\n   * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the\n   * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.\n   * It can greatly enhance the shadow quality, at the expense of more GPU works.\n   * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.\n   */\n  get autoCalcDepthBounds() {\n    return this._autoCalcDepthBounds;\n  }\n  set autoCalcDepthBounds(value) {\n    const camera = this._getCamera();\n    if (!camera) {\n      return;\n    }\n    this._autoCalcDepthBounds = value;\n    if (!value) {\n      if (this._depthReducer) {\n        this._depthReducer.deactivate();\n      }\n      this.setMinMaxDistance(0, 1);\n      return;\n    }\n    if (!this._depthReducer) {\n      this._depthReducer = new DepthReducer(camera);\n      this._depthReducer.onAfterReductionPerformed.add(minmax => {\n        let min = minmax.min,\n          max = minmax.max;\n        if (min >= max) {\n          min = 0;\n          max = 1;\n        }\n        if (min != this._minDistance || max != this._maxDistance) {\n          this.setMinMaxDistance(min, max);\n        }\n      });\n      this._depthReducer.setDepthRenderer(this._depthRenderer);\n    }\n    this._depthReducer.activate();\n  }\n  /**\n   * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\n   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\n   * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible\n   * for setting the refresh rate on the renderer yourself!\n   */\n  get autoCalcDepthBoundsRefreshRate() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) === null || _b === void 0 ? void 0 : _b.getDepthMap().refreshRate) !== null && _c !== void 0 ? _c : -1;\n  }\n  set autoCalcDepthBoundsRefreshRate(value) {\n    var _a;\n    if ((_a = this._depthReducer) === null || _a === void 0 ? void 0 : _a.depthRenderer) {\n      this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;\n    }\n  }\n  /**\n   * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.\n   * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if\n   * you change the camera near/far planes!\n   */\n  splitFrustum() {\n    this._breaksAreDirty = true;\n  }\n  _splitFrustum() {\n    const camera = this._getCamera();\n    if (!camera) {\n      return;\n    }\n    const near = camera.minZ,\n      far = camera.maxZ,\n      cameraRange = far - near,\n      minDistance = this._minDistance,\n      maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;\n    const minZ = near + minDistance * cameraRange,\n      maxZ = near + maxDistance * cameraRange;\n    const range = maxZ - minZ,\n      ratio = maxZ / minZ;\n    for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {\n      const p = (cascadeIndex + 1) / this._numCascades,\n        log = minZ * ratio ** p,\n        uniform = minZ + range * p;\n      const d = this._lambda * (log - uniform) + uniform;\n      this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;\n      this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;\n      this._viewSpaceFrustumsZ[cascadeIndex] = d;\n      this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;\n    }\n    this._breaksAreDirty = false;\n  }\n  _computeMatrices() {\n    const scene = this._scene;\n    const camera = this._getCamera();\n    if (!camera) {\n      return;\n    }\n    Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);\n    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\n      this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n    }\n\n    this._cachedDirection.copyFrom(this._lightDirection);\n    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\n    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n      this._computeFrustumInWorldSpace(cascadeIndex);\n      this._computeCascadeFrustum(cascadeIndex);\n      this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1); // tmpv1 = cascadeExtents\n      // Get position of the shadow camera\n      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);\n      // Come up with a new orthographic camera for the shadow caster\n      Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);\n      let minZ = 0,\n        maxZ = tmpv1.z;\n      // Try to tighten minZ and maxZ based on the bounding box of the shadow casters\n      const boundingInfo = this._shadowCastersBoundingInfo;\n      boundingInfo.update(this._viewMatrices[cascadeIndex]);\n      maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);\n      if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {\n        // If we don't use depth clamping, we must set minZ so that all shadow casters are in the light frustum\n        minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);\n      } else {\n        // If using depth clamping, we can adjust minZ to reduce the [minZ, maxZ] range (and get some additional precision in the shadow map)\n        minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);\n      }\n      Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);\n      this._cascadeMinExtents[cascadeIndex].z = minZ;\n      this._cascadeMaxExtents[cascadeIndex].z = maxZ;\n      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n      // Create the rounding matrix, by projecting the world-space origin and determining\n      // the fractional offset in texel space\n      Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1); // tmpv1 = shadowOrigin\n      tmpv1.scaleInPlace(this._mapSize / 2);\n      tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z)); // tmpv2 = roundedOrigin\n      tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize); // tmpv2 = roundOffset\n      Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0.0, tmpMatrix);\n      this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);\n      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\n      this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);\n    }\n  }\n  // Get the 8 points of the view frustum in world space\n  _computeFrustumInWorldSpace(cascadeIndex) {\n    const camera = this._getCamera();\n    if (!camera) {\n      return;\n    }\n    const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance,\n      splitDist = this._cascades[cascadeIndex].breakDistance;\n    const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;\n    camera.getViewMatrix(); // make sure the transformation matrix we get when calling 'getTransformationMatrix()' is calculated with an up to date view matrix\n    const invViewProj = Matrix.Invert(camera.getTransformationMatrix());\n    const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;\n    for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {\n      tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNDCSpace.length]);\n      if (isNDCHalfZRange && tmpv1.z === -1) {\n        tmpv1.z = 0;\n      }\n      Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n    }\n    // Get the corners of the current cascade slice of the view frustum\n    for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {\n      tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n      tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist); // near corner ray\n      tmpv1.scaleInPlace(splitDist); // far corner ray\n      tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);\n      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);\n    }\n  }\n  _computeCascadeFrustum(cascadeIndex) {\n    this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n    this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);\n    const camera = this._getCamera();\n    if (!camera) {\n      return;\n    }\n    // Calculate the centroid of the view frustum slice\n    for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n      this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\n    }\n    this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);\n    if (this.stabilizeCascades) {\n      // Calculate the radius of a bounding sphere surrounding the frustum corners\n      let sphereRadius = 0;\n      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n        const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();\n        sphereRadius = Math.max(sphereRadius, dist);\n      }\n      sphereRadius = Math.ceil(sphereRadius * 16) / 16;\n      this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);\n      this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);\n    } else {\n      // Create a temporary view matrix for the light\n      const lightCameraPos = this._frustumCenter[cascadeIndex];\n      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1); // tmpv1 = look at\n      Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix); // matrix = lightView\n      // Calculate an AABB around the frustum corners\n      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\n        Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);\n        this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);\n        this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);\n      }\n    }\n  }\n  _recreateSceneUBOs() {\n    this._disposeSceneUBOs();\n    if (this._sceneUBOs) {\n      for (let i = 0; i < this._numCascades; ++i) {\n        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light \"${this._light.name}\" cascade #${i})`));\n      }\n    }\n  }\n  /**\n   *  Support test.\n   */\n  static get IsSupported() {\n    const engine = EngineStore.LastCreatedEngine;\n    if (!engine) {\n      return false;\n    }\n    return engine._features.supportCSM;\n  }\n  _initializeGenerator() {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;\n    this.penumbraDarkness = (_a = this.penumbraDarkness) !== null && _a !== void 0 ? _a : 1.0;\n    this._numCascades = (_b = this._numCascades) !== null && _b !== void 0 ? _b : CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\n    this.stabilizeCascades = (_c = this.stabilizeCascades) !== null && _c !== void 0 ? _c : false;\n    this._freezeShadowCastersBoundingInfoObservable = (_d = this._freezeShadowCastersBoundingInfoObservable) !== null && _d !== void 0 ? _d : null;\n    this.freezeShadowCastersBoundingInfo = (_e = this.freezeShadowCastersBoundingInfo) !== null && _e !== void 0 ? _e : false;\n    this._scbiMin = (_f = this._scbiMin) !== null && _f !== void 0 ? _f : new Vector3(0, 0, 0);\n    this._scbiMax = (_g = this._scbiMax) !== null && _g !== void 0 ? _g : new Vector3(0, 0, 0);\n    this._shadowCastersBoundingInfo = (_h = this._shadowCastersBoundingInfo) !== null && _h !== void 0 ? _h : new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n    this._breaksAreDirty = (_j = this._breaksAreDirty) !== null && _j !== void 0 ? _j : true;\n    this._minDistance = (_k = this._minDistance) !== null && _k !== void 0 ? _k : 0;\n    this._maxDistance = (_l = this._maxDistance) !== null && _l !== void 0 ? _l : 1;\n    this._currentLayer = (_m = this._currentLayer) !== null && _m !== void 0 ? _m : 0;\n    this._shadowMaxZ = (_q = (_o = this._shadowMaxZ) !== null && _o !== void 0 ? _o : (_p = this._getCamera()) === null || _p === void 0 ? void 0 : _p.maxZ) !== null && _q !== void 0 ? _q : 10000;\n    this._debug = (_r = this._debug) !== null && _r !== void 0 ? _r : false;\n    this._depthClamp = (_s = this._depthClamp) !== null && _s !== void 0 ? _s : true;\n    this._cascadeBlendPercentage = (_t = this._cascadeBlendPercentage) !== null && _t !== void 0 ? _t : 0.1;\n    this._lambda = (_u = this._lambda) !== null && _u !== void 0 ? _u : 0.5;\n    this._autoCalcDepthBounds = (_v = this._autoCalcDepthBounds) !== null && _v !== void 0 ? _v : false;\n    this._recreateSceneUBOs();\n    super._initializeGenerator();\n  }\n  _createTargetRenderTexture() {\n    const engine = this._scene.getEngine();\n    const size = {\n      width: this._mapSize,\n      height: this._mapSize,\n      layers: this.numCascades\n    };\n    this._shadowMap = new RenderTargetTexture(this._light.name + \"_CSMShadowMap\", size, this._scene, false, true, this._textureType, false, undefined, false, false, undefined /*, 6*/);\n    this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true);\n  }\n  _initializeShadowMap() {\n    super._initializeShadowMap();\n    if (this._shadowMap === null) {\n      return;\n    }\n    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);\n    this._viewSpaceFrustumsZ = new Array(this._numCascades);\n    this._frustumLengths = new Array(this._numCascades);\n    this._lightSizeUVCorrection = new Array(this._numCascades * 2);\n    this._depthCorrection = new Array(this._numCascades);\n    this._cascades = [];\n    this._viewMatrices = [];\n    this._projectionMatrices = [];\n    this._transformMatrices = [];\n    this._cascadeMinExtents = [];\n    this._cascadeMaxExtents = [];\n    this._frustumCenter = [];\n    this._shadowCameraPos = [];\n    this._frustumCornersWorldSpace = [];\n    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n      this._cascades[cascadeIndex] = {\n        prevBreakDistance: 0,\n        breakDistance: 0\n      };\n      this._viewMatrices[cascadeIndex] = Matrix.Zero();\n      this._projectionMatrices[cascadeIndex] = Matrix.Zero();\n      this._transformMatrices[cascadeIndex] = Matrix.Zero();\n      this._cascadeMinExtents[cascadeIndex] = new Vector3();\n      this._cascadeMaxExtents[cascadeIndex] = new Vector3();\n      this._frustumCenter[cascadeIndex] = new Vector3();\n      this._shadowCameraPos[cascadeIndex] = new Vector3();\n      this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNDCSpace.length);\n      for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {\n        this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();\n      }\n    }\n    const engine = this._scene.getEngine();\n    this._shadowMap.onBeforeBindObservable.clear();\n    this._shadowMap.onBeforeRenderObservable.clear();\n    this._shadowMap.onBeforeRenderObservable.add(layer => {\n      if (this._sceneUBOs) {\n        this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);\n      }\n      this._currentLayer = layer;\n      if (this._filter === ShadowGenerator.FILTER_PCF) {\n        engine.setColorWrite(false);\n      }\n      this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));\n      if (this._useUBO) {\n        this._scene.getSceneUniformBuffer().unbindEffect();\n        this._scene.finalizeSceneUbo();\n      }\n    });\n    this._shadowMap.onBeforeBindObservable.add(() => {\n      var _a;\n      this._currentSceneUBO = this._scene.getSceneUniformBuffer();\n      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\n      if (this._breaksAreDirty) {\n        this._splitFrustum();\n      }\n      this._computeMatrices();\n    });\n    this._splitFrustum();\n  }\n  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {\n    effect.setMatrix(\"viewProjection\", this.getCascadeTransformMatrix(this._currentLayer));\n  }\n  _isReadyCustomDefines(defines) {\n    defines.push(\"#define SM_DEPTHCLAMP \" + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? \"1\" : \"0\"));\n  }\n  /**\n   * Prepare all the defines in a material relying on a shadow map at the specified light index.\n   * @param defines Defines of the material we want to update\n   * @param lightIndex Index of the light in the enabled light list of the material\n   */\n  prepareDefines(defines, lightIndex) {\n    super.prepareDefines(defines, lightIndex);\n    const scene = this._scene;\n    const light = this._light;\n    if (!scene.shadowsEnabled || !light.shadowEnabled) {\n      return;\n    }\n    defines[\"SHADOWCSM\" + lightIndex] = true;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = this.debug;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = this.numCascades;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = scene.useRightHandedSystem;\n    const camera = this._getCamera();\n    if (camera && this._shadowMaxZ < camera.maxZ) {\n      defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = true;\n    }\n    if (this.cascadeBlendPercentage === 0) {\n      defines[\"SHADOWCSMNOBLEND\" + lightIndex] = true;\n    }\n  }\n  /**\n   * Binds the shadow related information inside of an effect (information like near, far, darkness...\n   * defined in the generator but impacting the effect).\n   * @param lightIndex Index of the light in the enabled light list of the material owning the effect\n   * @param effect The effect we are binfing the information for\n   */\n  bindShadowLight(lightIndex, effect) {\n    const light = this._light;\n    const scene = this._scene;\n    if (!scene.shadowsEnabled || !light.shadowEnabled) {\n      return;\n    }\n    const camera = this._getCamera();\n    if (!camera) {\n      return;\n    }\n    const shadowMap = this.getShadowMap();\n    if (!shadowMap) {\n      return;\n    }\n    const width = shadowMap.getSize().width;\n    effect.setMatrices(\"lightMatrix\" + lightIndex, this._transformMatricesAsArray);\n    effect.setArray(\"viewFrustumZ\" + lightIndex, this._viewSpaceFrustumsZ);\n    effect.setFloat(\"cascadeBlendFactor\" + lightIndex, this.cascadeBlendPercentage === 0 ? 10000 : 1 / this.cascadeBlendPercentage);\n    effect.setArray(\"frustumLengths\" + lightIndex, this._frustumLengths);\n    // Only PCF uses depth stencil texture.\n    if (this._filter === ShadowGenerator.FILTER_PCF) {\n      effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\n      light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {\n      for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\n        this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x); // x correction\n        this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y); // y correction\n        this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);\n      }\n      effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\n      effect.setTexture(\"depthSampler\" + lightIndex, shadowMap);\n      effect.setArray2(\"lightSizeUVCorrection\" + lightIndex, this._lightSizeUVCorrection);\n      effect.setArray(\"depthCorrection\" + lightIndex, this._depthCorrection);\n      effect.setFloat(\"penumbraDarkness\" + lightIndex, this.penumbraDarkness);\n      light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);\n    } else {\n      effect.setTexture(\"shadowSampler\" + lightIndex, shadowMap);\n      light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\n    }\n    light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);\n  }\n  /**\n   * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.\n   * (eq to view projection * shadow projection matrices)\n   * @returns The transform matrix used to create the shadow map\n   */\n  getTransformMatrix() {\n    return this.getCascadeTransformMatrix(0);\n  }\n  /**\n   * Disposes the ShadowGenerator.\n   * Returns nothing.\n   */\n  dispose() {\n    super.dispose();\n    if (this._freezeShadowCastersBoundingInfoObservable) {\n      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\n      this._freezeShadowCastersBoundingInfoObservable = null;\n    }\n    if (this._depthReducer) {\n      this._depthReducer.dispose();\n      this._depthReducer = null;\n    }\n  }\n  /**\n   * Serializes the shadow generator setup to a json object.\n   * @returns The serialized JSON object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    const shadowMap = this.getShadowMap();\n    if (!shadowMap) {\n      return serializationObject;\n    }\n    serializationObject.numCascades = this._numCascades;\n    serializationObject.debug = this._debug;\n    serializationObject.stabilizeCascades = this.stabilizeCascades;\n    serializationObject.lambda = this._lambda;\n    serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;\n    serializationObject.depthClamp = this._depthClamp;\n    serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;\n    serializationObject.shadowMaxZ = this._shadowMaxZ;\n    serializationObject.penumbraDarkness = this.penumbraDarkness;\n    serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;\n    serializationObject.minDistance = this.minDistance;\n    serializationObject.maxDistance = this.maxDistance;\n    serializationObject.renderList = [];\n    if (shadowMap.renderList) {\n      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n        const mesh = shadowMap.renderList[meshIndex];\n        serializationObject.renderList.push(mesh.id);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n   * @param parsedShadowGenerator The JSON object to parse\n   * @param scene The scene to create the shadow map for\n   * @returns The parsed shadow generator\n   */\n  static Parse(parsedShadowGenerator, scene) {\n    const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new CascadedShadowGenerator(mapSize, light, undefined, camera));\n    if (parsedShadowGenerator.numCascades !== undefined) {\n      shadowGenerator.numCascades = parsedShadowGenerator.numCascades;\n    }\n    if (parsedShadowGenerator.debug !== undefined) {\n      shadowGenerator.debug = parsedShadowGenerator.debug;\n    }\n    if (parsedShadowGenerator.stabilizeCascades !== undefined) {\n      shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;\n    }\n    if (parsedShadowGenerator.lambda !== undefined) {\n      shadowGenerator.lambda = parsedShadowGenerator.lambda;\n    }\n    if (parsedShadowGenerator.cascadeBlendPercentage !== undefined) {\n      shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;\n    }\n    if (parsedShadowGenerator.depthClamp !== undefined) {\n      shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;\n    }\n    if (parsedShadowGenerator.autoCalcDepthBounds !== undefined) {\n      shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;\n    }\n    if (parsedShadowGenerator.shadowMaxZ !== undefined) {\n      shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;\n    }\n    if (parsedShadowGenerator.penumbraDarkness !== undefined) {\n      shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;\n    }\n    if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== undefined) {\n      shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;\n    }\n    if (parsedShadowGenerator.minDistance !== undefined && parsedShadowGenerator.maxDistance !== undefined) {\n      shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);\n    }\n    return shadowGenerator;\n  }\n}\nCascadedShadowGenerator._FrustumCornersNDCSpace = [new Vector3(-1.0, +1.0, -1.0), new Vector3(+1.0, +1.0, -1.0), new Vector3(+1.0, -1.0, -1.0), new Vector3(-1.0, -1.0, -1.0), new Vector3(-1.0, +1.0, +1.0), new Vector3(+1.0, +1.0, +1.0), new Vector3(+1.0, -1.0, +1.0), new Vector3(-1.0, -1.0, +1.0)];\n/**\n * Name of the CSM class\n */\nCascadedShadowGenerator.CLASSNAME = \"CascadedShadowGenerator\";\n/**\n * Defines the default number of cascades used by the CSM.\n */\nCascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;\n/**\n * Defines the minimum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MIN_CASCADES_COUNT = 2;\n/**\n * Defines the maximum number of cascades used by the CSM.\n */\nCascadedShadowGenerator.MAX_CASCADES_COUNT = 4;\n/**\n * @internal\n */\nCascadedShadowGenerator._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"ShadowGeneratorSceneComponent\");\n};","map":{"version":3,"mappings":"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","names":["Matrix","Vector3","RenderTargetTexture","_WarnImport","ShadowGenerator","BoundingInfo","DepthReducer","Logger","EngineStore","UpDir","Up","ZeroVec","Zero","tmpv1","tmpv2","tmpMatrix","CascadedShadowGenerator","constructor","mapSize","light","usefulFloatFirst","camera","IsSupported","Error","usePercentageCloserFiltering","_validateFilter","filter","FILTER_NONE","FILTER_PCF","FILTER_PCSS","console","error","numCascades","_numCascades","value","Math","min","max","MIN_CASCADES_COUNT","MAX_CASCADES_COUNT","recreateShadowMap","_recreateSceneUBOs","freezeShadowCastersBoundingInfo","_freezeShadowCastersBoundingInfo","freeze","_freezeShadowCastersBoundingInfoObservable","_scene","onBeforeRenderObservable","remove","add","_computeShadowCastersBoundingInfo","bind","_scbiMin","copyFromFloats","Number","MAX_VALUE","_scbiMax","MIN_VALUE","_shadowMap","renderList","meshIndex","length","mesh","boundingInfo","getBoundingInfo","boundingBox","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","meshes","isVisible","isEnabled","receiveShadows","_shadowCastersBoundingInfo","reConstruct","shadowCastersBoundingInfo","setMinMaxDistance","_minDistance","_maxDistance","_breaksAreDirty","minDistance","maxDistance","getClassName","CLASSNAME","getCascadeMinExtents","cascadeIndex","_cascadeMinExtents","getCascadeMaxExtents","_cascadeMaxExtents","shadowMaxZ","_getCamera","_shadowMaxZ","minZ","maxZ","_light","_markMeshesAsLightDirty","debug","_debug","dbg","depthClamp","_depthClamp","cascadeBlendPercentage","_cascadeBlendPercentage","lambda","_lambda","getCascadeViewMatrix","cascadeNum","_viewMatrices","getCascadeProjectionMatrix","_projectionMatrices","getCascadeTransformMatrix","_transformMatrices","setDepthRenderer","depthRenderer","_depthRenderer","_depthReducer","autoCalcDepthBounds","_autoCalcDepthBounds","deactivate","onAfterReductionPerformed","minmax","activate","autoCalcDepthBoundsRefreshRate","getDepthMap","refreshRate","splitFrustum","_splitFrustum","near","far","cameraRange","range","ratio","_cascades","p","log","uniform","d","prevBreakDistance","breakDistance","_viewSpaceFrustumsZ","_frustumLengths","_computeMatrices","scene","NormalizeToRef","getShadowDirection","_lightDirection","abs","Dot","z","_cachedDirection","copyFrom","useReverseDepthBuffer","getEngine","_computeFrustumInWorldSpace","_computeCascadeFrustum","subtractToRef","_frustumCenter","addToRef","scale","_shadowCameraPos","LookAtLHToRef","update","OrthoOffCenterLHToRef","x","y","isNDCHalfZRange","multiplyToRef","TransformCoordinatesToRef","scaleInPlace","_mapSize","round","subtractInPlace","TranslationToRef","copyToArray","_transformMatricesAsArray","prevSplitDist","splitDist","getViewMatrix","invViewProj","Invert","getTransformationMatrix","cornerIndexOffset","cornerIndex","_FrustumCornersNDCSpace","_frustumCornersWorldSpace","addInPlace","stabilizeCascades","sphereRadius","dist","ceil","lightCameraPos","_disposeSceneUBOs","_sceneUBOs","i","push","createSceneUniformBuffer","name","engine","LastCreatedEngine","_features","supportCSM","_initializeGenerator","penumbraDarkness","DEFAULT_CASCADES_COUNT","_currentLayer","_createTargetRenderTexture","size","width","height","layers","_textureType","undefined","createDepthStencilTexture","_initializeShadowMap","Float32Array","Array","_lightSizeUVCorrection","_depthCorrection","onBeforeBindObservable","clear","layer","setSceneUniformBuffer","_filter","setColorWrite","setTransformMatrix","_useUBO","getSceneUniformBuffer","unbindEffect","finalizeSceneUbo","_currentSceneUBO","_debugPushGroup","currentRenderPassId","_bindCustomEffectForRenderSubMeshForShadowMap","subMesh","effect","setMatrix","_isReadyCustomDefines","defines","prepareDefines","lightIndex","shadowsEnabled","shadowEnabled","useRightHandedSystem","bindShadowLight","shadowMap","getShadowMap","getSize","setMatrices","setArray","setFloat","setDepthStencilTexture","_uniformBuffer","updateFloat4","getDarkness","frustumEdgeFalloff","setTexture","setArray2","_contactHardeningLightSizeUVRatio","updateFloat2","getLight","getDepthMinZ","getDepthMaxZ","getTransformMatrix","dispose","serialize","serializationObject","id","Parse","parsedShadowGenerator","shadowGenerator","_"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Lights/Shadows/cascadedShadowGenerator.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\n\r\nimport type { IShadowLight } from \"../../Lights/shadowLight\";\r\nimport type { Effect } from \"../../Materials/effect\";\r\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\n\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport \"../../Shaders/shadowMap.fragment\";\r\nimport \"../../Shaders/shadowMap.vertex\";\r\nimport \"../../Shaders/depthBoxBlur.fragment\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShadowGenerator } from \"./shadowGenerator\";\r\nimport type { DirectionalLight } from \"../directionalLight\";\r\n\r\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { DepthRenderer } from \"../../Rendering/depthRenderer\";\r\nimport { DepthReducer } from \"../../Misc/depthReducer\";\r\n\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\n\r\ninterface ICascade {\r\n    prevBreakDistance: number;\r\n    breakDistance: number;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst UpDir = Vector3.Up();\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst ZeroVec = Vector3.Zero();\r\n\r\nconst tmpv1 = new Vector3(),\r\n    tmpv2 = new Vector3(),\r\n    tmpMatrix = new Matrix();\r\n\r\n/**\r\n * A CSM implementation allowing casting shadows on large scenes.\r\n * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\r\n * Based on: https://github.com/TheRealMJP/Shadows and https://johanmedestrom.wordpress.com/2016/03/18/opengl-cascaded-shadow-maps/\r\n */\r\nexport class CascadedShadowGenerator extends ShadowGenerator {\r\n    private static readonly _FrustumCornersNDCSpace = [\r\n        new Vector3(-1.0, +1.0, -1.0),\r\n        new Vector3(+1.0, +1.0, -1.0),\r\n        new Vector3(+1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, -1.0, -1.0),\r\n        new Vector3(-1.0, +1.0, +1.0),\r\n        new Vector3(+1.0, +1.0, +1.0),\r\n        new Vector3(+1.0, -1.0, +1.0),\r\n        new Vector3(-1.0, -1.0, +1.0),\r\n    ];\r\n\r\n    /**\r\n     * Name of the CSM class\r\n     */\r\n    public static CLASSNAME = \"CascadedShadowGenerator\";\r\n\r\n    /**\r\n     * Defines the default number of cascades used by the CSM.\r\n     */\r\n    public static readonly DEFAULT_CASCADES_COUNT = 4;\r\n    /**\r\n     * Defines the minimum number of cascades used by the CSM.\r\n     */\r\n    public static readonly MIN_CASCADES_COUNT = 2;\r\n    /**\r\n     * Defines the maximum number of cascades used by the CSM.\r\n     */\r\n    public static readonly MAX_CASCADES_COUNT = 4;\r\n\r\n    protected _validateFilter(filter: number): number {\r\n        if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {\r\n            return filter;\r\n        }\r\n\r\n        console.error('Unsupported filter \"' + filter + '\"!');\r\n\r\n        return ShadowGenerator.FILTER_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the actual darkness of the soft shadows while using PCSS filtering (value between 0. and 1.)\r\n     */\r\n    public penumbraDarkness: number;\r\n\r\n    private _numCascades: number;\r\n\r\n    /**\r\n     * Gets or set the number of cascades used by the CSM.\r\n     */\r\n    public get numCascades(): number {\r\n        return this._numCascades;\r\n    }\r\n\r\n    public set numCascades(value: number) {\r\n        value = Math.min(Math.max(value, CascadedShadowGenerator.MIN_CASCADES_COUNT), CascadedShadowGenerator.MAX_CASCADES_COUNT);\r\n        if (value === this._numCascades) {\r\n            return;\r\n        }\r\n\r\n        this._numCascades = value;\r\n        this.recreateShadowMap();\r\n        this._recreateSceneUBOs();\r\n    }\r\n\r\n    /**\r\n     * Sets this to true if you want that the edges of the shadows don't \"swimm\" / \"shimmer\" when rotating the camera.\r\n     * The trade off is that you lose some precision in the shadow rendering when enabling this setting.\r\n     */\r\n    public stabilizeCascades: boolean;\r\n\r\n    private _freezeShadowCastersBoundingInfo: boolean;\r\n    private _freezeShadowCastersBoundingInfoObservable: Nullable<Observer<Scene>>;\r\n\r\n    /**\r\n     * Enables or disables the shadow casters bounding info computation.\r\n     * If your shadow casters don't move, you can disable this feature.\r\n     * If it is enabled, the bounding box computation is done every frame.\r\n     */\r\n    public get freezeShadowCastersBoundingInfo(): boolean {\r\n        return this._freezeShadowCastersBoundingInfo;\r\n    }\r\n\r\n    public set freezeShadowCastersBoundingInfo(freeze: boolean) {\r\n        if (this._freezeShadowCastersBoundingInfoObservable && freeze) {\r\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\r\n            this._freezeShadowCastersBoundingInfoObservable = null;\r\n        }\r\n\r\n        if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {\r\n            this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this));\r\n        }\r\n\r\n        this._freezeShadowCastersBoundingInfo = freeze;\r\n\r\n        if (freeze) {\r\n            this._computeShadowCastersBoundingInfo();\r\n        }\r\n    }\r\n\r\n    private _scbiMin: Vector3;\r\n    private _scbiMax: Vector3;\r\n\r\n    protected _computeShadowCastersBoundingInfo(): void {\r\n        this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\r\n\r\n        if (this._shadowMap && this._shadowMap.renderList) {\r\n            const renderList = this._shadowMap.renderList;\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo(),\r\n                    boundingBox = boundingInfo.boundingBox;\r\n\r\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\r\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\r\n            }\r\n\r\n            const meshes = this._scene.meshes;\r\n            for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n                const mesh = meshes[meshIndex];\r\n\r\n                if (!mesh || !mesh.isVisible || !mesh.isEnabled || !mesh.receiveShadows) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo(),\r\n                    boundingBox = boundingInfo.boundingBox;\r\n\r\n                this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);\r\n                this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);\r\n            }\r\n        }\r\n\r\n        this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);\r\n    }\r\n\r\n    protected _shadowCastersBoundingInfo: BoundingInfo;\r\n\r\n    /**\r\n     * Gets or sets the shadow casters bounding info.\r\n     * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo\r\n     * so that the system won't overwrite the bounds you provide\r\n     */\r\n    public get shadowCastersBoundingInfo(): BoundingInfo {\r\n        return this._shadowCastersBoundingInfo;\r\n    }\r\n\r\n    public set shadowCastersBoundingInfo(boundingInfo: BoundingInfo) {\r\n        this._shadowCastersBoundingInfo = boundingInfo;\r\n    }\r\n\r\n    protected _breaksAreDirty: boolean;\r\n\r\n    protected _minDistance: number;\r\n    protected _maxDistance: number;\r\n\r\n    /**\r\n     * Sets the minimal and maximal distances to use when computing the cascade breaks.\r\n     *\r\n     * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.\r\n     * If you don't know these values, simply leave them to their defaults and don't call this function.\r\n     * @param min minimal distance for the breaks (default to 0.)\r\n     * @param max maximal distance for the breaks (default to 1.)\r\n     */\r\n    public setMinMaxDistance(min: number, max: number): void {\r\n        if (this._minDistance === min && this._maxDistance === max) {\r\n            return;\r\n        }\r\n\r\n        if (min > max) {\r\n            min = 0;\r\n            max = 1;\r\n        }\r\n\r\n        if (min < 0) {\r\n            min = 0;\r\n        }\r\n\r\n        if (max > 1) {\r\n            max = 1;\r\n        }\r\n\r\n        this._minDistance = min;\r\n        this._maxDistance = max;\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    /** Gets the minimal distance used in the cascade break computation */\r\n    public get minDistance(): number {\r\n        return this._minDistance;\r\n    }\r\n\r\n    /** Gets the maximal distance used in the cascade break computation */\r\n    public get maxDistance(): number {\r\n        return this._maxDistance;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of that object\r\n     * @returns \"CascadedShadowGenerator\"\r\n     */\r\n    public getClassName(): string {\r\n        return CascadedShadowGenerator.CLASSNAME;\r\n    }\r\n\r\n    private _cascadeMinExtents: Array<Vector3>;\r\n    private _cascadeMaxExtents: Array<Vector3>;\r\n\r\n    /**\r\n     * Gets a cascade minimum extents\r\n     * @param cascadeIndex index of the cascade\r\n     * @returns the minimum cascade extents\r\n     */\r\n    public getCascadeMinExtents(cascadeIndex: number): Nullable<Vector3> {\r\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets a cascade maximum extents\r\n     * @param cascadeIndex index of the cascade\r\n     * @returns the maximum cascade extents\r\n     */\r\n    public getCascadeMaxExtents(cascadeIndex: number): Nullable<Vector3> {\r\n        return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;\r\n    }\r\n\r\n    private _cascades: Array<ICascade>;\r\n    private _currentLayer: number;\r\n    private _viewSpaceFrustumsZ: Array<number>;\r\n    private _viewMatrices: Array<Matrix>;\r\n    private _projectionMatrices: Array<Matrix>;\r\n    private _transformMatrices: Array<Matrix>;\r\n    private _transformMatricesAsArray: Float32Array;\r\n    private _frustumLengths: Array<number>;\r\n    private _lightSizeUVCorrection: Array<number>;\r\n    private _depthCorrection: Array<number>;\r\n    private _frustumCornersWorldSpace: Array<Array<Vector3>>;\r\n    private _frustumCenter: Array<Vector3>;\r\n    private _shadowCameraPos: Array<Vector3>;\r\n\r\n    private _shadowMaxZ: number;\r\n    /**\r\n     * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.\r\n     * It defaults to camera.maxZ\r\n     */\r\n    public get shadowMaxZ(): number {\r\n        if (!this._getCamera()) {\r\n            return 0;\r\n        }\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Sets the shadow max z distance.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            this._shadowMaxZ = value;\r\n            return;\r\n        }\r\n        if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ) {\r\n            return;\r\n        }\r\n        this._shadowMaxZ = value;\r\n        this._light._markMeshesAsLightDirty();\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    protected _debug: boolean;\r\n\r\n    /**\r\n     * Gets or sets the debug flag.\r\n     * When enabled, the cascades are materialized by different colors on the screen.\r\n     */\r\n    public get debug(): boolean {\r\n        return this._debug;\r\n    }\r\n\r\n    public set debug(dbg: boolean) {\r\n        this._debug = dbg;\r\n        this._light._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _depthClamp: boolean;\r\n\r\n    /**\r\n     * Gets or sets the depth clamping value.\r\n     *\r\n     * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted\r\n     * to account for the shadow casters far away.\r\n     *\r\n     * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.\r\n     */\r\n    public get depthClamp(): boolean {\r\n        return this._depthClamp;\r\n    }\r\n\r\n    public set depthClamp(value: boolean) {\r\n        this._depthClamp = value;\r\n    }\r\n\r\n    private _cascadeBlendPercentage: number;\r\n\r\n    /**\r\n     * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).\r\n     * It defaults to 0.1 (10% blending).\r\n     */\r\n    public get cascadeBlendPercentage(): number {\r\n        return this._cascadeBlendPercentage;\r\n    }\r\n\r\n    public set cascadeBlendPercentage(value: number) {\r\n        this._cascadeBlendPercentage = value;\r\n        this._light._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _lambda: number;\r\n\r\n    /**\r\n     * Gets or set the lambda parameter.\r\n     * This parameter is used to split the camera frustum and create the cascades.\r\n     * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.\r\n     * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.\r\n     */\r\n    public get lambda(): number {\r\n        return this._lambda;\r\n    }\r\n\r\n    public set lambda(value: number) {\r\n        const lambda = Math.min(Math.max(value, 0), 1);\r\n        if (this._lambda == lambda) {\r\n            return;\r\n        }\r\n        this._lambda = lambda;\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix corresponding to a given cascade\r\n     * @param cascadeNum cascade to retrieve the view matrix from\r\n     * @returns the cascade view matrix\r\n     */\r\n    public getCascadeViewMatrix(cascadeNum: number): Nullable<Matrix> {\r\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the projection matrix corresponding to a given cascade\r\n     * @param cascadeNum cascade to retrieve the projection matrix from\r\n     * @returns the cascade projection matrix\r\n     */\r\n    public getCascadeProjectionMatrix(cascadeNum: number): Nullable<Matrix> {\r\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix corresponding to a given cascade\r\n     * @param cascadeNum cascade to retrieve the transformation matrix from\r\n     * @returns the cascade transformation matrix\r\n     */\r\n    public getCascadeTransformMatrix(cascadeNum: number): Nullable<Matrix> {\r\n        return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;\r\n    }\r\n\r\n    private _depthRenderer: Nullable<DepthRenderer>;\r\n    /**\r\n     * Sets the depth renderer to use when autoCalcDepthBounds is enabled.\r\n     *\r\n     * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.\r\n     *\r\n     * You should call this function if you already have a depth renderer enabled in your scene, to avoid\r\n     * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!\r\n     * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created\r\n     */\r\n    public setDepthRenderer(depthRenderer: Nullable<DepthRenderer>): void {\r\n        this._depthRenderer = depthRenderer;\r\n\r\n        if (this._depthReducer) {\r\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\r\n        }\r\n    }\r\n\r\n    private _depthReducer: Nullable<DepthReducer>;\r\n    private _autoCalcDepthBounds: boolean;\r\n\r\n    /**\r\n     * Gets or sets the autoCalcDepthBounds property.\r\n     *\r\n     * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one\r\n     * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the\r\n     * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.\r\n     * It can greatly enhance the shadow quality, at the expense of more GPU works.\r\n     * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.\r\n     */\r\n    public get autoCalcDepthBounds(): boolean {\r\n        return this._autoCalcDepthBounds;\r\n    }\r\n\r\n    public set autoCalcDepthBounds(value: boolean) {\r\n        const camera = this._getCamera();\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        this._autoCalcDepthBounds = value;\r\n\r\n        if (!value) {\r\n            if (this._depthReducer) {\r\n                this._depthReducer.deactivate();\r\n            }\r\n            this.setMinMaxDistance(0, 1);\r\n            return;\r\n        }\r\n\r\n        if (!this._depthReducer) {\r\n            this._depthReducer = new DepthReducer(camera);\r\n            this._depthReducer.onAfterReductionPerformed.add((minmax: { min: number; max: number }) => {\r\n                let min = minmax.min,\r\n                    max = minmax.max;\r\n                if (min >= max) {\r\n                    min = 0;\r\n                    max = 1;\r\n                }\r\n                if (min != this._minDistance || max != this._maxDistance) {\r\n                    this.setMinMaxDistance(min, max);\r\n                }\r\n            });\r\n            this._depthReducer.setDepthRenderer(this._depthRenderer);\r\n        }\r\n\r\n        this._depthReducer.activate();\r\n    }\r\n\r\n    /**\r\n     * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true\r\n     * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...\r\n     * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible\r\n     * for setting the refresh rate on the renderer yourself!\r\n     */\r\n    public get autoCalcDepthBoundsRefreshRate(): number {\r\n        return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1;\r\n    }\r\n\r\n    public set autoCalcDepthBoundsRefreshRate(value: number) {\r\n        if (this._depthReducer?.depthRenderer) {\r\n            this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.\r\n     * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if\r\n     * you change the camera near/far planes!\r\n     */\r\n    public splitFrustum(): void {\r\n        this._breaksAreDirty = true;\r\n    }\r\n\r\n    private _splitFrustum(): void {\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const near = camera.minZ,\r\n            far = camera.maxZ,\r\n            cameraRange = far - near,\r\n            minDistance = this._minDistance,\r\n            maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;\r\n\r\n        const minZ = near + minDistance * cameraRange,\r\n            maxZ = near + maxDistance * cameraRange;\r\n\r\n        const range = maxZ - minZ,\r\n            ratio = maxZ / minZ;\r\n\r\n        for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {\r\n            const p = (cascadeIndex + 1) / this._numCascades,\r\n                log = minZ * ratio ** p,\r\n                uniform = minZ + range * p;\r\n\r\n            const d = this._lambda * (log - uniform) + uniform;\r\n\r\n            this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;\r\n            this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;\r\n\r\n            this._viewSpaceFrustumsZ[cascadeIndex] = d;\r\n            this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;\r\n        }\r\n\r\n        this._breaksAreDirty = false;\r\n    }\r\n\r\n    private _computeMatrices(): void {\r\n        const scene = this._scene;\r\n\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);\r\n        if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1.0) {\r\n            this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        this._cachedDirection.copyFrom(this._lightDirection);\r\n\r\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\r\n\r\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\r\n            this._computeFrustumInWorldSpace(cascadeIndex);\r\n            this._computeCascadeFrustum(cascadeIndex);\r\n\r\n            this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], tmpv1); // tmpv1 = cascadeExtents\r\n\r\n            // Get position of the shadow camera\r\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);\r\n\r\n            // Come up with a new orthographic camera for the shadow caster\r\n            Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);\r\n\r\n            let minZ = 0,\r\n                maxZ = tmpv1.z;\r\n\r\n            // Try to tighten minZ and maxZ based on the bounding box of the shadow casters\r\n            const boundingInfo = this._shadowCastersBoundingInfo;\r\n\r\n            boundingInfo.update(this._viewMatrices[cascadeIndex]);\r\n\r\n            maxZ = Math.min(maxZ, boundingInfo.boundingBox.maximumWorld.z);\r\n\r\n            if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {\r\n                // If we don't use depth clamping, we must set minZ so that all shadow casters are in the light frustum\r\n                minZ = Math.min(minZ, boundingInfo.boundingBox.minimumWorld.z);\r\n            } else {\r\n                // If using depth clamping, we can adjust minZ to reduce the [minZ, maxZ] range (and get some additional precision in the shadow map)\r\n                minZ = Math.max(minZ, boundingInfo.boundingBox.minimumWorld.z);\r\n            }\r\n\r\n            Matrix.OrthoOffCenterLHToRef(\r\n                this._cascadeMinExtents[cascadeIndex].x,\r\n                this._cascadeMaxExtents[cascadeIndex].x,\r\n                this._cascadeMinExtents[cascadeIndex].y,\r\n                this._cascadeMaxExtents[cascadeIndex].y,\r\n                useReverseDepthBuffer ? maxZ : minZ,\r\n                useReverseDepthBuffer ? minZ : maxZ,\r\n                this._projectionMatrices[cascadeIndex],\r\n                scene.getEngine().isNDCHalfZRange\r\n            );\r\n\r\n            this._cascadeMinExtents[cascadeIndex].z = minZ;\r\n            this._cascadeMaxExtents[cascadeIndex].z = maxZ;\r\n\r\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\r\n\r\n            // Create the rounding matrix, by projecting the world-space origin and determining\r\n            // the fractional offset in texel space\r\n            Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], tmpv1); // tmpv1 = shadowOrigin\r\n            tmpv1.scaleInPlace(this._mapSize / 2);\r\n\r\n            tmpv2.copyFromFloats(Math.round(tmpv1.x), Math.round(tmpv1.y), Math.round(tmpv1.z)); // tmpv2 = roundedOrigin\r\n            tmpv2.subtractInPlace(tmpv1).scaleInPlace(2 / this._mapSize); // tmpv2 = roundOffset\r\n\r\n            Matrix.TranslationToRef(tmpv2.x, tmpv2.y, 0.0, tmpMatrix);\r\n\r\n            this._projectionMatrices[cascadeIndex].multiplyToRef(tmpMatrix, this._projectionMatrices[cascadeIndex]);\r\n            this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);\r\n\r\n            this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);\r\n        }\r\n    }\r\n\r\n    // Get the 8 points of the view frustum in world space\r\n    private _computeFrustumInWorldSpace(cascadeIndex: number): void {\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance,\r\n            splitDist = this._cascades[cascadeIndex].breakDistance;\r\n\r\n        const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;\r\n\r\n        camera.getViewMatrix(); // make sure the transformation matrix we get when calling 'getTransformationMatrix()' is calculated with an up to date view matrix\r\n\r\n        const invViewProj = Matrix.Invert(camera.getTransformationMatrix());\r\n        const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;\r\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++cornerIndex) {\r\n            tmpv1.copyFrom(CascadedShadowGenerator._FrustumCornersNDCSpace[(cornerIndex + cornerIndexOffset) % CascadedShadowGenerator._FrustumCornersNDCSpace.length]);\r\n            if (isNDCHalfZRange && tmpv1.z === -1) {\r\n                tmpv1.z = 0;\r\n            }\r\n            Vector3.TransformCoordinatesToRef(tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n        }\r\n\r\n        // Get the corners of the current cascade slice of the view frustum\r\n        for (let cornerIndex = 0; cornerIndex < CascadedShadowGenerator._FrustumCornersNDCSpace.length / 2; ++cornerIndex) {\r\n            tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n            tmpv2.copyFrom(tmpv1).scaleInPlace(prevSplitDist); // near corner ray\r\n            tmpv1.scaleInPlace(splitDist); // far corner ray\r\n\r\n            tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n\r\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(tmpv1);\r\n            this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(tmpv2);\r\n        }\r\n    }\r\n\r\n    private _computeCascadeFrustum(cascadeIndex: number): void {\r\n        this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cascadeMaxExtents[cascadeIndex].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\r\n        this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);\r\n\r\n        const camera = this._getCamera();\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        // Calculate the centroid of the view frustum slice\r\n        for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\r\n            this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);\r\n        }\r\n\r\n        this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);\r\n\r\n        if (this.stabilizeCascades) {\r\n            // Calculate the radius of a bounding sphere surrounding the frustum corners\r\n            let sphereRadius = 0;\r\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\r\n                const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], tmpv1).length();\r\n                sphereRadius = Math.max(sphereRadius, dist);\r\n            }\r\n\r\n            sphereRadius = Math.ceil(sphereRadius * 16) / 16;\r\n\r\n            this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);\r\n            this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);\r\n        } else {\r\n            // Create a temporary view matrix for the light\r\n            const lightCameraPos = this._frustumCenter[cascadeIndex];\r\n\r\n            this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, tmpv1); // tmpv1 = look at\r\n\r\n            Matrix.LookAtLHToRef(lightCameraPos, tmpv1, UpDir, tmpMatrix); // matrix = lightView\r\n\r\n            // Calculate an AABB around the frustum corners\r\n            for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {\r\n                Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], tmpMatrix, tmpv1);\r\n\r\n                this._cascadeMinExtents[cascadeIndex].minimizeInPlace(tmpv1);\r\n                this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(tmpv1);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _recreateSceneUBOs(): void {\r\n        this._disposeSceneUBOs();\r\n        if (this._sceneUBOs) {\r\n            for (let i = 0; i < this._numCascades; ++i) {\r\n                this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light \"${this._light.name}\" cascade #${i})`));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  Support test.\r\n     */\r\n    public static get IsSupported(): boolean {\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        if (!engine) {\r\n            return false;\r\n        }\r\n        return engine._features.supportCSM;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"ShadowGeneratorSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Creates a Cascaded Shadow Generator object.\r\n     * A ShadowGenerator is the required tool to use the shadows.\r\n     * Each directional light casting shadows needs to use its own ShadowGenerator.\r\n     * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows\r\n     * @param mapSize The size of the texture what stores the shadows. Example : 1024.\r\n     * @param light The directional light object generating the shadows.\r\n     * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\r\n     * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it\r\n     */\r\n    constructor(mapSize: number, light: DirectionalLight, usefulFloatFirst?: boolean, camera?: Nullable<Camera>) {\r\n        if (!CascadedShadowGenerator.IsSupported) {\r\n            Logger.Error(\"CascadedShadowMap is not supported by the current engine.\");\r\n            return;\r\n        }\r\n\r\n        super(mapSize, light, usefulFloatFirst, camera);\r\n\r\n        this.usePercentageCloserFiltering = true;\r\n    }\r\n\r\n    protected _initializeGenerator(): void {\r\n        this.penumbraDarkness = this.penumbraDarkness ?? 1.0;\r\n        this._numCascades = this._numCascades ?? CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;\r\n        this.stabilizeCascades = this.stabilizeCascades ?? false;\r\n        this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;\r\n        this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;\r\n        this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);\r\n        this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);\r\n        this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        this._breaksAreDirty = this._breaksAreDirty ?? true;\r\n        this._minDistance = this._minDistance ?? 0;\r\n        this._maxDistance = this._maxDistance ?? 1;\r\n        this._currentLayer = this._currentLayer ?? 0;\r\n        this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 10000;\r\n        this._debug = this._debug ?? false;\r\n        this._depthClamp = this._depthClamp ?? true;\r\n        this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;\r\n        this._lambda = this._lambda ?? 0.5;\r\n        this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;\r\n\r\n        this._recreateSceneUBOs();\r\n\r\n        super._initializeGenerator();\r\n    }\r\n\r\n    protected _createTargetRenderTexture(): void {\r\n        const engine = this._scene.getEngine();\r\n        const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };\r\n        this._shadowMap = new RenderTargetTexture(\r\n            this._light.name + \"_CSMShadowMap\",\r\n            size,\r\n            this._scene,\r\n            false,\r\n            true,\r\n            this._textureType,\r\n            false,\r\n            undefined,\r\n            false,\r\n            false,\r\n            undefined /*, Constants.TEXTUREFORMAT_RED*/\r\n        );\r\n        this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? Constants.GREATER : Constants.LESS, true);\r\n    }\r\n\r\n    protected _initializeShadowMap(): void {\r\n        super._initializeShadowMap();\r\n\r\n        if (this._shadowMap === null) {\r\n            return;\r\n        }\r\n\r\n        this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);\r\n        this._viewSpaceFrustumsZ = new Array(this._numCascades);\r\n        this._frustumLengths = new Array(this._numCascades);\r\n        this._lightSizeUVCorrection = new Array(this._numCascades * 2);\r\n        this._depthCorrection = new Array(this._numCascades);\r\n\r\n        this._cascades = [];\r\n        this._viewMatrices = [];\r\n        this._projectionMatrices = [];\r\n        this._transformMatrices = [];\r\n        this._cascadeMinExtents = [];\r\n        this._cascadeMaxExtents = [];\r\n        this._frustumCenter = [];\r\n        this._shadowCameraPos = [];\r\n        this._frustumCornersWorldSpace = [];\r\n\r\n        for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\r\n            this._cascades[cascadeIndex] = {\r\n                prevBreakDistance: 0,\r\n                breakDistance: 0,\r\n            };\r\n\r\n            this._viewMatrices[cascadeIndex] = Matrix.Zero();\r\n            this._projectionMatrices[cascadeIndex] = Matrix.Zero();\r\n            this._transformMatrices[cascadeIndex] = Matrix.Zero();\r\n            this._cascadeMinExtents[cascadeIndex] = new Vector3();\r\n            this._cascadeMaxExtents[cascadeIndex] = new Vector3();\r\n            this._frustumCenter[cascadeIndex] = new Vector3();\r\n            this._shadowCameraPos[cascadeIndex] = new Vector3();\r\n            this._frustumCornersWorldSpace[cascadeIndex] = new Array(CascadedShadowGenerator._FrustumCornersNDCSpace.length);\r\n\r\n            for (let i = 0; i < CascadedShadowGenerator._FrustumCornersNDCSpace.length; ++i) {\r\n                this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();\r\n            }\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._shadowMap.onBeforeBindObservable.clear();\r\n        this._shadowMap.onBeforeRenderObservable.clear();\r\n\r\n        this._shadowMap.onBeforeRenderObservable.add((layer: number) => {\r\n            if (this._sceneUBOs) {\r\n                this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);\r\n            }\r\n            this._currentLayer = layer;\r\n            if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n                engine.setColorWrite(false);\r\n            }\r\n            this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer)!, this.getCascadeProjectionMatrix(layer)!);\r\n            if (this._useUBO) {\r\n                this._scene.getSceneUniformBuffer().unbindEffect();\r\n                this._scene.finalizeSceneUbo();\r\n            }\r\n        });\r\n\r\n        this._shadowMap.onBeforeBindObservable.add(() => {\r\n            this._currentSceneUBO = this._scene.getSceneUniformBuffer();\r\n            engine._debugPushGroup?.(`cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);\r\n            if (this._breaksAreDirty) {\r\n                this._splitFrustum();\r\n            }\r\n            this._computeMatrices();\r\n        });\r\n\r\n        this._splitFrustum();\r\n    }\r\n\r\n    protected _bindCustomEffectForRenderSubMeshForShadowMap(subMesh: SubMesh, effect: Effect): void {\r\n        effect.setMatrix(\"viewProjection\", this.getCascadeTransformMatrix(this._currentLayer)!);\r\n    }\r\n\r\n    protected _isReadyCustomDefines(defines: any): void {\r\n        defines.push(\"#define SM_DEPTHCLAMP \" + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? \"1\" : \"0\"));\r\n    }\r\n\r\n    /**\r\n     * Prepare all the defines in a material relying on a shadow map at the specified light index.\r\n     * @param defines Defines of the material we want to update\r\n     * @param lightIndex Index of the light in the enabled light list of the material\r\n     */\r\n    public prepareDefines(defines: any, lightIndex: number): void {\r\n        super.prepareDefines(defines, lightIndex);\r\n\r\n        const scene = this._scene;\r\n        const light = this._light;\r\n\r\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\r\n            return;\r\n        }\r\n\r\n        defines[\"SHADOWCSM\" + lightIndex] = true;\r\n        defines[\"SHADOWCSMDEBUG\" + lightIndex] = this.debug;\r\n        defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = this.numCascades;\r\n        defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = scene.useRightHandedSystem;\r\n\r\n        const camera = this._getCamera();\r\n\r\n        if (camera && this._shadowMaxZ < camera.maxZ) {\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = true;\r\n        }\r\n\r\n        if (this.cascadeBlendPercentage === 0) {\r\n            defines[\"SHADOWCSMNOBLEND\" + lightIndex] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the shadow related information inside of an effect (information like near, far, darkness...\r\n     * defined in the generator but impacting the effect).\r\n     * @param lightIndex Index of the light in the enabled light list of the material owning the effect\r\n     * @param effect The effect we are binfing the information for\r\n     */\r\n    public bindShadowLight(lightIndex: string, effect: Effect): void {\r\n        const light = this._light;\r\n        const scene = this._scene;\r\n\r\n        if (!scene.shadowsEnabled || !light.shadowEnabled) {\r\n            return;\r\n        }\r\n\r\n        const camera = this._getCamera();\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        const shadowMap = this.getShadowMap();\r\n        if (!shadowMap) {\r\n            return;\r\n        }\r\n\r\n        const width = shadowMap.getSize().width;\r\n\r\n        effect.setMatrices(\"lightMatrix\" + lightIndex, this._transformMatricesAsArray);\r\n        effect.setArray(\"viewFrustumZ\" + lightIndex, this._viewSpaceFrustumsZ);\r\n        effect.setFloat(\"cascadeBlendFactor\" + lightIndex, this.cascadeBlendPercentage === 0 ? 10000 : 1 / this.cascadeBlendPercentage);\r\n        effect.setArray(\"frustumLengths\" + lightIndex, this._frustumLengths);\r\n\r\n        // Only PCF uses depth stencil texture.\r\n        if (this._filter === ShadowGenerator.FILTER_PCF) {\r\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\r\n        } else if (this._filter === ShadowGenerator.FILTER_PCSS) {\r\n            for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {\r\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 0] =\r\n                    cascadeIndex === 0\r\n                        ? 1\r\n                        : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x); // x correction\r\n                this._lightSizeUVCorrection[cascadeIndex * 2 + 1] =\r\n                    cascadeIndex === 0\r\n                        ? 1\r\n                        : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y); // y correction\r\n                this._depthCorrection[cascadeIndex] =\r\n                    cascadeIndex === 0\r\n                        ? 1\r\n                        : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);\r\n            }\r\n            effect.setDepthStencilTexture(\"shadowSampler\" + lightIndex, shadowMap);\r\n            effect.setTexture(\"depthSampler\" + lightIndex, shadowMap);\r\n            effect.setArray2(\"lightSizeUVCorrection\" + lightIndex, this._lightSizeUVCorrection);\r\n            effect.setArray(\"depthCorrection\" + lightIndex, this._depthCorrection);\r\n            effect.setFloat(\"penumbraDarkness\" + lightIndex, this.penumbraDarkness);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);\r\n        } else {\r\n            effect.setTexture(\"shadowSampler\" + lightIndex, shadowMap);\r\n            light._uniformBuffer.updateFloat4(\"shadowsInfo\", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);\r\n        }\r\n\r\n        light._uniformBuffer.updateFloat2(\r\n            \"depthValues\",\r\n            this.getLight().getDepthMinZ(camera),\r\n            this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera),\r\n            lightIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.\r\n     * (eq to view projection * shadow projection matrices)\r\n     * @returns The transform matrix used to create the shadow map\r\n     */\r\n    public getTransformMatrix(): Matrix {\r\n        return this.getCascadeTransformMatrix(0)!;\r\n    }\r\n\r\n    /**\r\n     * Disposes the ShadowGenerator.\r\n     * Returns nothing.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._freezeShadowCastersBoundingInfoObservable) {\r\n            this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);\r\n            this._freezeShadowCastersBoundingInfoObservable = null;\r\n        }\r\n\r\n        if (this._depthReducer) {\r\n            this._depthReducer.dispose();\r\n            this._depthReducer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the shadow generator setup to a json object.\r\n     * @returns The serialized JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = super.serialize();\r\n        const shadowMap = this.getShadowMap();\r\n\r\n        if (!shadowMap) {\r\n            return serializationObject;\r\n        }\r\n\r\n        serializationObject.numCascades = this._numCascades;\r\n        serializationObject.debug = this._debug;\r\n        serializationObject.stabilizeCascades = this.stabilizeCascades;\r\n        serializationObject.lambda = this._lambda;\r\n        serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;\r\n        serializationObject.depthClamp = this._depthClamp;\r\n        serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;\r\n        serializationObject.shadowMaxZ = this._shadowMaxZ;\r\n        serializationObject.penumbraDarkness = this.penumbraDarkness;\r\n\r\n        serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;\r\n        serializationObject.minDistance = this.minDistance;\r\n        serializationObject.maxDistance = this.maxDistance;\r\n\r\n        serializationObject.renderList = [];\r\n        if (shadowMap.renderList) {\r\n            for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\r\n                const mesh = shadowMap.renderList[meshIndex];\r\n\r\n                serializationObject.renderList.push(mesh.id);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\r\n     * @param parsedShadowGenerator The JSON object to parse\r\n     * @param scene The scene to create the shadow map for\r\n     * @returns The parsed shadow generator\r\n     */\r\n    public static Parse(parsedShadowGenerator: any, scene: Scene): ShadowGenerator {\r\n        const shadowGenerator = ShadowGenerator.Parse(\r\n            parsedShadowGenerator,\r\n            scene,\r\n            (mapSize: number, light: IShadowLight, camera: Nullable<Camera>) => new CascadedShadowGenerator(mapSize, <DirectionalLight>light, undefined, camera)\r\n        ) as CascadedShadowGenerator;\r\n\r\n        if (parsedShadowGenerator.numCascades !== undefined) {\r\n            shadowGenerator.numCascades = parsedShadowGenerator.numCascades;\r\n        }\r\n\r\n        if (parsedShadowGenerator.debug !== undefined) {\r\n            shadowGenerator.debug = parsedShadowGenerator.debug;\r\n        }\r\n\r\n        if (parsedShadowGenerator.stabilizeCascades !== undefined) {\r\n            shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;\r\n        }\r\n\r\n        if (parsedShadowGenerator.lambda !== undefined) {\r\n            shadowGenerator.lambda = parsedShadowGenerator.lambda;\r\n        }\r\n\r\n        if (parsedShadowGenerator.cascadeBlendPercentage !== undefined) {\r\n            shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;\r\n        }\r\n\r\n        if (parsedShadowGenerator.depthClamp !== undefined) {\r\n            shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;\r\n        }\r\n\r\n        if (parsedShadowGenerator.autoCalcDepthBounds !== undefined) {\r\n            shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;\r\n        }\r\n\r\n        if (parsedShadowGenerator.shadowMaxZ !== undefined) {\r\n            shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;\r\n        }\r\n\r\n        if (parsedShadowGenerator.penumbraDarkness !== undefined) {\r\n            shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;\r\n        }\r\n\r\n        if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== undefined) {\r\n            shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;\r\n        }\r\n\r\n        if (parsedShadowGenerator.minDistance !== undefined && parsedShadowGenerator.maxDistance !== undefined) {\r\n            shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);\r\n        }\r\n\r\n        return shadowGenerator;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}