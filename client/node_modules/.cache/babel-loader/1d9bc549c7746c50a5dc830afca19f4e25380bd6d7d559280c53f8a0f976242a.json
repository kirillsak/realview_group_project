{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\n */\nexport class CylinderParticleEmitter {\n  /**\n   * Creates a new instance CylinderParticleEmitter\n   * @param radius the radius of the emission cylinder (1 by default)\n   * @param height the height of the emission cylinder (1 by default)\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  constructor(\n  /**\n   * The radius of the emission cylinder.\n   */\n  radius = 1,\n  /**\n   * The height of the emission cylinder.\n   */\n  height = 1,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange = 1,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer = 0) {\n    this.radius = radius;\n    this.height = height;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n    this._tempVector = Vector3.Zero();\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {\n    particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\n    this._tempVector.normalize();\n    Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\n    const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\n    let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\n    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\n    this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\n    this._tempVector.x = Math.sin(angle);\n    this._tempVector.z = Math.cos(angle);\n    this._tempVector.normalize();\n    if (isLocal) {\n      directionToUpdate.copyFrom(this._tempVector);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\n    const angle = Scalar.RandomRange(0, 2 * Math.PI);\n    // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\n    const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\n    const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\n    const xPos = positionRadius * Math.cos(angle);\n    const zPos = positionRadius * Math.sin(angle);\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(xPos, yPos, zPos);\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"height\", this.height);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"height\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define CYLINDEREMITTER\";\n  }\n  /**\n   * Returns the string \"CylinderParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"CylinderParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.height = this.height;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.height = serializationObject.height;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  }\n}\n/**\n * Particle emitter emitting particles from the inside of a cylinder.\n * It emits the particles randomly between two vectors.\n */\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\n  /**\n   * Creates a new instance CylinderDirectedParticleEmitter\n   * @param radius the radius of the emission cylinder (1 by default)\n   * @param height the height of the emission cylinder (1 by default)\n   * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param direction1 the min limit of the emission direction (up vector by default)\n   * @param direction2 the max limit of the emission direction (up vector by default)\n   */\n  constructor(radius = 1, height = 1, radiusRange = 1,\n  /**\n   * The min limit of the emission direction.\n   */\n  direction1 = new Vector3(0, 1, 0),\n  /**\n   * The max limit of the emission direction.\n   */\n  direction2 = new Vector3(0, 1, 0)) {\n    super(radius, height, radiusRange);\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate) {\n    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"height\", this.height);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"height\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\n  }\n  /**\n   * Returns the string \"CylinderDirectedParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"CylinderDirectedParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    super.parse(serializationObject);\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  }\n}","map":{"version":3,"mappings":"AACA,SAASA,OAAO,QAAQ,4BAA0B;AAClD,SAASC,MAAM,QAAQ,4BAA0B;AAGjD,SAASC,UAAU,QAAQ,0BAAwB;AAGnD;;;;AAIA,OAAM,MAAOC,uBAAuB;EAGhC;;;;;;;EAOAC;EACI;;;EAGOC,SAAS,CAAC;EACjB;;;EAGOC,SAAS,CAAC;EACjB;;;EAGOC,cAAc,CAAC;EACtB;;;EAGOC,sBAAsB,CAAC;IAZvB,WAAM,GAANH,MAAM;IAIN,WAAM,GAANC,MAAM;IAIN,gBAAW,GAAXC,WAAW;IAIX,wBAAmB,GAAnBC,mBAAmB;IAzBtB,gBAAW,GAAGR,OAAO,CAACS,IAAI,EAAE;EA0BjC;EAEH;;;;;;;;EAQOC,sBAAsB,CAACC,WAAmB,EAAEC,iBAA0B,EAAEC,QAAkB,EAAEC,OAAgB,EAAEC,kBAA0B;IAC3IF,QAAQ,CAACG,QAAQ,CAACC,aAAa,CAACN,WAAW,CAACO,cAAc,EAAE,EAAE,IAAI,CAACC,WAAW,CAAC;IAE/E,IAAI,CAACA,WAAW,CAACC,SAAS,EAAE;IAE5BpB,OAAO,CAACqB,oBAAoB,CAAC,IAAI,CAACF,WAAW,EAAEJ,kBAAkB,EAAE,IAAI,CAACI,WAAW,CAAC;IAEpF,MAAMG,KAAK,GAAGrB,MAAM,CAACsB,WAAW,CAAC,CAAC,IAAI,CAACf,mBAAmB,GAAG,CAAC,EAAE,IAAI,CAACA,mBAAmB,GAAG,CAAC,CAAC;IAE7F,IAAIgB,KAAK,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACP,WAAW,CAACQ,CAAC,EAAE,IAAI,CAACR,WAAW,CAACS,CAAC,CAAC;IAC9DJ,KAAK,IAAIvB,MAAM,CAACsB,WAAW,CAAC,CAACE,IAAI,CAACI,EAAE,GAAG,CAAC,EAAEJ,IAAI,CAACI,EAAE,GAAG,CAAC,CAAC,GAAG,IAAI,CAACrB,mBAAmB;IAEjF,IAAI,CAACW,WAAW,CAACW,CAAC,GAAGR,KAAK,CAAC,CAAC;IAC5B,IAAI,CAACH,WAAW,CAACQ,CAAC,GAAGF,IAAI,CAACM,GAAG,CAACP,KAAK,CAAC;IACpC,IAAI,CAACL,WAAW,CAACS,CAAC,GAAGH,IAAI,CAACO,GAAG,CAACR,KAAK,CAAC;IACpC,IAAI,CAACL,WAAW,CAACC,SAAS,EAAE;IAE5B,IAAIN,OAAO,EAAE;MACTF,iBAAiB,CAACqB,QAAQ,CAAC,IAAI,CAACd,WAAW,CAAC;MAC5C;;IAGJnB,OAAO,CAACkC,8BAA8B,CAAC,IAAI,CAACf,WAAW,CAACQ,CAAC,EAAE,IAAI,CAACR,WAAW,CAACW,CAAC,EAAE,IAAI,CAACX,WAAW,CAACS,CAAC,EAAEjB,WAAW,EAAEC,iBAAiB,CAAC;EACtI;EAEA;;;;;;;EAOOuB,qBAAqB,CAACxB,WAAmB,EAAEyB,gBAAyB,EAAEvB,QAAkB,EAAEC,OAAgB;IAC7G,MAAMuB,IAAI,GAAGpC,MAAM,CAACsB,WAAW,CAAC,CAAC,IAAI,CAACjB,MAAM,GAAG,CAAC,EAAE,IAAI,CAACA,MAAM,GAAG,CAAC,CAAC;IAClE,MAAMkB,KAAK,GAAGvB,MAAM,CAACsB,WAAW,CAAC,CAAC,EAAE,CAAC,GAAGE,IAAI,CAACI,EAAE,CAAC;IAEhD;IACA,MAAMS,kBAAkB,GAAGrC,MAAM,CAACsB,WAAW,CAAC,CAAC,CAAC,GAAG,IAAI,CAAChB,WAAW,KAAK,CAAC,GAAG,IAAI,CAACA,WAAW,CAAC,EAAE,CAAC,CAAC;IACjG,MAAMgC,cAAc,GAAGd,IAAI,CAACe,IAAI,CAACF,kBAAkB,CAAC,GAAG,IAAI,CAACjC,MAAM;IAClE,MAAMoC,IAAI,GAAGF,cAAc,GAAGd,IAAI,CAACO,GAAG,CAACR,KAAK,CAAC;IAC7C,MAAMkB,IAAI,GAAGH,cAAc,GAAGd,IAAI,CAACM,GAAG,CAACP,KAAK,CAAC;IAE7C,IAAIV,OAAO,EAAE;MACTsB,gBAAgB,CAACO,cAAc,CAACF,IAAI,EAAEJ,IAAI,EAAEK,IAAI,CAAC;MACjD;;IAGJ1C,OAAO,CAAC4C,mCAAmC,CAACH,IAAI,EAAEJ,IAAI,EAAEK,IAAI,EAAE/B,WAAW,EAAEyB,gBAAgB,CAAC;EAChG;EAEA;;;;EAIOS,KAAK;IACR,MAAMC,MAAM,GAAG,IAAI3C,uBAAuB,CAAC,IAAI,CAACE,MAAM,EAAE,IAAI,CAACG,mBAAmB,CAAC;IAEjFN,UAAU,CAAC6C,QAAQ,CAAC,IAAI,EAAED,MAAM,CAAC;IAEjC,OAAOA,MAAM;EACjB;EAEA;;;;EAIOE,aAAa,CAACC,WAA8C;IAC/DA,WAAW,CAACC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC7C,MAAM,CAAC;IAC3C4C,WAAW,CAACC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC5C,MAAM,CAAC;IAC3C2C,WAAW,CAACC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC3C,WAAW,CAAC;IACrD0C,WAAW,CAACC,QAAQ,CAAC,qBAAqB,EAAE,IAAI,CAAC1C,mBAAmB,CAAC;EACzE;EAEA;;;;EAIO2C,kBAAkB,CAACC,GAAkB;IACxCA,GAAG,CAACC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC3BD,GAAG,CAACC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC3BD,GAAG,CAACC,UAAU,CAAC,aAAa,EAAE,CAAC,CAAC;IAChCD,GAAG,CAACC,UAAU,CAAC,qBAAqB,EAAE,CAAC,CAAC;EAC5C;EAEA;;;;EAIOC,gBAAgB;IACnB,OAAO,yBAAyB;EACpC;EAEA;;;;EAIOC,YAAY;IACf,OAAO,yBAAyB;EACpC;EAEA;;;;EAIOC,SAAS;IACZ,MAAMC,mBAAmB,GAAQ,EAAE;IACnCA,mBAAmB,CAACC,IAAI,GAAG,IAAI,CAACH,YAAY,EAAE;IAC9CE,mBAAmB,CAACpD,MAAM,GAAG,IAAI,CAACA,MAAM;IACxCoD,mBAAmB,CAACnD,MAAM,GAAG,IAAI,CAACA,MAAM;IACxCmD,mBAAmB,CAAClD,WAAW,GAAG,IAAI,CAACA,WAAW;IAClDkD,mBAAmB,CAACjD,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;IAElE,OAAOiD,mBAAmB;EAC9B;EAEA;;;;EAIOE,KAAK,CAACF,mBAAwB;IACjC,IAAI,CAACpD,MAAM,GAAGoD,mBAAmB,CAACpD,MAAM;IACxC,IAAI,CAACC,MAAM,GAAGmD,mBAAmB,CAACnD,MAAM;IACxC,IAAI,CAACC,WAAW,GAAGkD,mBAAmB,CAAClD,WAAW;IAClD,IAAI,CAACC,mBAAmB,GAAGiD,mBAAmB,CAACjD,mBAAmB;EACtE;;AAGJ;;;;AAIA,OAAM,MAAOoD,+BAAgC,SAAQzD,uBAAuB;EACxE;;;;;;;;EAQAC,YACIC,MAAM,GAAG,CAAC,EACVC,MAAM,GAAG,CAAC,EACVC,WAAW,GAAG,CAAC;EACf;;;EAGOsD,aAAa,IAAI7D,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACxC;;;EAGO8D,aAAa,IAAI9D,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAExC,KAAK,CAACK,MAAM,EAAEC,MAAM,EAAEC,WAAW,CAAC;IAN3B,eAAU,GAAVsD,UAAU;IAIV,eAAU,GAAVC,UAAU;EAGrB;EAEA;;;;;EAKOpD,sBAAsB,CAACC,WAAmB,EAAEC,iBAA0B;IACzE,MAAMmD,KAAK,GAAG9D,MAAM,CAACsB,WAAW,CAAC,IAAI,CAACsC,UAAU,CAAClC,CAAC,EAAE,IAAI,CAACmC,UAAU,CAACnC,CAAC,CAAC;IACtE,MAAML,KAAK,GAAGrB,MAAM,CAACsB,WAAW,CAAC,IAAI,CAACsC,UAAU,CAAC/B,CAAC,EAAE,IAAI,CAACgC,UAAU,CAAChC,CAAC,CAAC;IACtE,MAAMkC,KAAK,GAAG/D,MAAM,CAACsB,WAAW,CAAC,IAAI,CAACsC,UAAU,CAACjC,CAAC,EAAE,IAAI,CAACkC,UAAU,CAAClC,CAAC,CAAC;IACtE5B,OAAO,CAACkC,8BAA8B,CAAC6B,KAAK,EAAEzC,KAAK,EAAE0C,KAAK,EAAErD,WAAW,EAAEC,iBAAiB,CAAC;EAC/F;EAEA;;;;EAIOiC,KAAK;IACR,MAAMC,MAAM,GAAG,IAAIc,+BAA+B,CAAC,IAAI,CAACvD,MAAM,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACC,WAAW,EAAE,IAAI,CAACsD,UAAU,EAAE,IAAI,CAACC,UAAU,CAAC;IAEhI5D,UAAU,CAAC6C,QAAQ,CAAC,IAAI,EAAED,MAAM,CAAC;IAEjC,OAAOA,MAAM;EACjB;EAEA;;;;EAIOE,aAAa,CAACC,WAA8C;IAC/DA,WAAW,CAACC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC7C,MAAM,CAAC;IAC3C4C,WAAW,CAACC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC5C,MAAM,CAAC;IAC3C2C,WAAW,CAACC,QAAQ,CAAC,aAAa,EAAE,IAAI,CAAC3C,WAAW,CAAC;IACrD0C,WAAW,CAACgB,UAAU,CAAC,YAAY,EAAE,IAAI,CAACJ,UAAU,CAAC;IACrDZ,WAAW,CAACgB,UAAU,CAAC,YAAY,EAAE,IAAI,CAACH,UAAU,CAAC;EACzD;EAEA;;;;EAIOX,kBAAkB,CAACC,GAAkB;IACxCA,GAAG,CAACC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC3BD,GAAG,CAACC,UAAU,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC3BD,GAAG,CAACC,UAAU,CAAC,aAAa,EAAE,CAAC,CAAC;IAChCD,GAAG,CAACC,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC;IAC/BD,GAAG,CAACC,UAAU,CAAC,YAAY,EAAE,CAAC,CAAC;EACnC;EAEA;;;;EAIOC,gBAAgB;IACnB,OAAO,0DAA0D;EACrE;EAEA;;;;EAIOC,YAAY;IACf,OAAO,iCAAiC;EAC5C;EAEA;;;;EAIOC,SAAS;IACZ,MAAMC,mBAAmB,GAAG,KAAK,CAACD,SAAS,EAAE;IAE7CC,mBAAmB,CAACI,UAAU,GAAG,IAAI,CAACA,UAAU,CAACK,OAAO,EAAE;IAC1DT,mBAAmB,CAACK,UAAU,GAAG,IAAI,CAACA,UAAU,CAACI,OAAO,EAAE;IAE1D,OAAOT,mBAAmB;EAC9B;EAEA;;;;EAIOE,KAAK,CAACF,mBAAwB;IACjC,KAAK,CAACE,KAAK,CAACF,mBAAmB,CAAC;IAChC,IAAI,CAACI,UAAU,CAAC5B,QAAQ,CAACwB,mBAAmB,CAACI,UAAU,CAAC;IACxD,IAAI,CAACC,UAAU,CAAC7B,QAAQ,CAACwB,mBAAmB,CAACK,UAAU,CAAC;EAC5D","names":["Vector3","Scalar","DeepCopier","CylinderParticleEmitter","constructor","radius","height","radiusRange","directionRandomizer","Zero","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","inverseWorldMatrix","position","subtractToRef","getTranslation","_tempVector","normalize","TransformNormalToRef","randY","RandomRange","angle","Math","atan2","x","z","PI","y","sin","cos","copyFrom","TransformNormalFromFloatsToRef","startPositionFunction","positionToUpdate","yPos","radiusDistribution","positionRadius","sqrt","xPos","zPos","copyFromFloats","TransformCoordinatesFromFloatsToRef","clone","newOne","DeepCopy","applyToShader","uboOrEffect","setFloat","buildUniformLayout","ubo","addUniform","getEffectDefines","getClassName","serialize","serializationObject","type","parse","CylinderDirectedParticleEmitter","direction1","direction2","randX","randZ","setVector3","asArray"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/EmitterTypes/cylinderParticleEmitter.ts"],"sourcesContent":["import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles alongside the cylinder radius. The emission direction might be randomized.\r\n */\r\nexport class CylinderParticleEmitter implements IParticleEmitterType {\r\n    private _tempVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a new instance CylinderParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission cylinder.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The height of the emission cylinder.\r\n         */\r\n        public height = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     * @param inverseWorldMatrix defines the inverted world matrix to use if isLocal is false\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean, inverseWorldMatrix: Matrix): void {\r\n        particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);\r\n\r\n        this._tempVector.normalize();\r\n\r\n        Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);\r\n\r\n        const randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);\r\n\r\n        let angle = Math.atan2(this._tempVector.x, this._tempVector.z);\r\n        angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;\r\n\r\n        this._tempVector.y = randY; // set direction y to rand y to mirror normal of cylinder surface\r\n        this._tempVector.x = Math.sin(angle);\r\n        this._tempVector.z = Math.cos(angle);\r\n        this._tempVector.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(this._tempVector);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);\r\n        const angle = Scalar.RandomRange(0, 2 * Math.PI);\r\n\r\n        // Pick a properly distributed point within the circle https://programming.guide/random-point-within-circle.html\r\n        const radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);\r\n        const positionRadius = Math.sqrt(radiusDistribution) * this.radius;\r\n        const xPos = positionRadius * Math.cos(angle);\r\n        const zPos = positionRadius * Math.sin(angle);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(xPos, yPos, zPos);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderParticleEmitter {\r\n        const newOne = new CylinderParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.height = this.height;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.height = serializationObject.height;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a cylinder.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class CylinderDirectedParticleEmitter extends CylinderParticleEmitter {\r\n    /**\r\n     * Creates a new instance CylinderDirectedParticleEmitter\r\n     * @param radius the radius of the emission cylinder (1 by default)\r\n     * @param height the height of the emission cylinder (1 by default)\r\n     * @param radiusRange the range of the emission cylinder [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        height = 1,\r\n        radiusRange = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius, height, radiusRange);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): CylinderDirectedParticleEmitter {\r\n        const newOne = new CylinderDirectedParticleEmitter(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"height\", this.height);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"height\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define CYLINDEREMITTER\\n#define DIRECTEDCYLINDEREMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"CylinderDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"CylinderDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}