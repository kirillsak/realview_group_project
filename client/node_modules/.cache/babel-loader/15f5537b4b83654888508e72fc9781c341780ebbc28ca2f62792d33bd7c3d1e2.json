{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector.js\";\nimport { Sprite } from \"./sprite.js\";\nimport { SpriteSceneComponent } from \"./spriteSceneComponent.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { WebRequest } from \"../Misc/webRequest.js\";\nimport { SpriteRenderer } from \"./spriteRenderer.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n\n/**\n * Class used to manage multiple sprites on the same spritesheet\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class SpriteManager {\n  /**\n   * Creates a new sprite manager\n   * @param name defines the manager's name\n   * @param imgUrl defines the sprite sheet url\n   * @param capacity defines the maximum allowed number of sprites\n   * @param cellSize defines the size of a sprite cell\n   * @param scene defines the hosting scene\n   * @param epsilon defines the epsilon value to align texture (0.01 by default)\n   * @param samplingMode defines the sampling mode to use with spritesheet\n   * @param fromPacked set to false; do not alter\n   * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\n   */\n  constructor( /** defines the manager's name */\n  name, imgUrl, capacity, cellSize, scene, epsilon = 0.01, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, fromPacked = false, spriteJSON = null) {\n    this.name = name;\n    /** Gets the list of sprites */\n    this.sprites = new Array();\n    /** Gets or sets the rendering group id (0 by default) */\n    this.renderingGroupId = 0;\n    /** Gets or sets camera layer mask */\n    this.layerMask = 0x0fffffff;\n    /** Gets or sets a boolean indicating if the sprites are pickable */\n    this.isPickable = false;\n    /**\n     * Gets or sets an object used to store user defined information for the sprite manager\n     */\n    this.metadata = null;\n    /** @internal */\n    this._wasDispatched = false;\n    /**\n     * An event triggered when the manager is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    this._disableDepthWrite = false;\n    /** True when packed cell data from JSON file is ready*/\n    this._packedAndReady = false;\n    this._customUpdate = (sprite, baseSize) => {\n      if (!sprite.cellRef) {\n        sprite.cellIndex = 0;\n      }\n      const num = sprite.cellIndex;\n      if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\n        sprite.cellRef = this._spriteMap[sprite.cellIndex];\n      }\n      sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\n      sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\n      sprite._xSize = this._cellData[sprite.cellRef].frame.w;\n      sprite._ySize = this._cellData[sprite.cellRef].frame.h;\n    };\n    if (!scene) {\n      scene = EngineStore.LastCreatedScene;\n    }\n    if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\n      scene._addComponent(new SpriteSceneComponent(scene));\n    }\n    this._fromPacked = fromPacked;\n    this._scene = scene;\n    const engine = this._scene.getEngine();\n    this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\n    if (cellSize.width && cellSize.height) {\n      this.cellWidth = cellSize.width;\n      this.cellHeight = cellSize.height;\n    } else if (cellSize !== undefined) {\n      this.cellWidth = cellSize;\n      this.cellHeight = cellSize;\n    } else {\n      this._spriteRenderer = null;\n      return;\n    }\n    this._scene.spriteManagers.push(this);\n    this.uniqueId = this.scene.getUniqueId();\n    if (imgUrl) {\n      this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\n    }\n    if (this._fromPacked) {\n      this._makePacked(imgUrl, spriteJSON);\n    }\n  }\n  /**\n   * Callback called when the manager is disposed\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Gets the array of sprites\n   */\n  get children() {\n    return this.sprites;\n  }\n  /**\n   * Gets the hosting scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Gets the capacity of the manager\n   */\n  get capacity() {\n    return this._spriteRenderer.capacity;\n  }\n  /**\n   * Gets or sets the spritesheet texture\n   */\n  get texture() {\n    return this._spriteRenderer.texture;\n  }\n  set texture(value) {\n    value.wrapU = Texture.CLAMP_ADDRESSMODE;\n    value.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._spriteRenderer.texture = value;\n    this._textureContent = null;\n  }\n  /** Defines the default width of a cell in the spritesheet */\n  get cellWidth() {\n    return this._spriteRenderer.cellWidth;\n  }\n  set cellWidth(value) {\n    this._spriteRenderer.cellWidth = value;\n  }\n  /** Defines the default height of a cell in the spritesheet */\n  get cellHeight() {\n    return this._spriteRenderer.cellHeight;\n  }\n  set cellHeight(value) {\n    this._spriteRenderer.cellHeight = value;\n  }\n  /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\n  get fogEnabled() {\n    return this._spriteRenderer.fogEnabled;\n  }\n  set fogEnabled(value) {\n    this._spriteRenderer.fogEnabled = value;\n  }\n  /**\n   * Blend mode use to render the particle, it can be any of\n   * the static undefined properties provided in this class.\n   * Default value is 2\n   */\n  get blendMode() {\n    return this._spriteRenderer.blendMode;\n  }\n  set blendMode(blendMode) {\n    this._spriteRenderer.blendMode = blendMode;\n  }\n  /** Disables writing to the depth buffer when rendering the sprites.\n   *  It can be handy to disable depth writing when using textures without alpha channel\n   *  and setting some specific blend modes.\n   */\n  get disableDepthWrite() {\n    return this._disableDepthWrite;\n  }\n  set disableDepthWrite(value) {\n    this._disableDepthWrite = value;\n    this._spriteRenderer.disableDepthWrite = value;\n  }\n  /**\n   * Returns the string \"SpriteManager\"\n   * @returns \"SpriteManager\"\n   */\n  getClassName() {\n    return \"SpriteManager\";\n  }\n  _makePacked(imgUrl, spriteJSON) {\n    if (spriteJSON !== null) {\n      try {\n        //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\n        let celldata;\n        if (typeof spriteJSON === \"string\") {\n          celldata = JSON.parse(spriteJSON);\n        } else {\n          celldata = spriteJSON;\n        }\n        if (celldata.frames.length) {\n          const frametemp = {};\n          for (let i = 0; i < celldata.frames.length; i++) {\n            const _f = celldata.frames[i];\n            if (typeof Object.keys(_f)[0] !== \"string\") {\n              throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\n            }\n            const name = _f[Object.keys(_f)[0]];\n            frametemp[name] = _f;\n          }\n          celldata.frames = frametemp;\n        }\n        const spritemap = Reflect.ownKeys(celldata.frames);\n        this._spriteMap = spritemap;\n        this._packedAndReady = true;\n        this._cellData = celldata.frames;\n      } catch (e) {\n        this._fromPacked = false;\n        this._packedAndReady = false;\n        throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\n      }\n    } else {\n      const re = /\\./g;\n      let li;\n      do {\n        li = re.lastIndex;\n        re.test(imgUrl);\n      } while (re.lastIndex > 0);\n      const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\n      const onerror = () => {\n        Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\n        this._fromPacked = false;\n        this._packedAndReady = false;\n      };\n      const onload = data => {\n        try {\n          const celldata = JSON.parse(data);\n          const spritemap = Reflect.ownKeys(celldata.frames);\n          this._spriteMap = spritemap;\n          this._packedAndReady = true;\n          this._cellData = celldata.frames;\n        } catch (e) {\n          this._fromPacked = false;\n          this._packedAndReady = false;\n          throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\n        }\n      };\n      Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\n    }\n  }\n  _checkTextureAlpha(sprite, ray, distance, min, max) {\n    if (!sprite.useAlphaForPicking || !this.texture) {\n      return true;\n    }\n    const textureSize = this.texture.getSize();\n    if (!this._textureContent) {\n      this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\n      this.texture.readPixels(0, 0, this._textureContent);\n    }\n    const contactPoint = TmpVectors.Vector3[0];\n    contactPoint.copyFrom(ray.direction);\n    contactPoint.normalize();\n    contactPoint.scaleInPlace(distance);\n    contactPoint.addInPlace(ray.origin);\n    const contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\n    const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;\n    // Rotate\n    const angle = sprite.angle;\n    const rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\n    const rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\n    const u = sprite._xOffset * textureSize.width + rotatedU * sprite._xSize | 0;\n    const v = sprite._yOffset * textureSize.height + rotatedV * sprite._ySize | 0;\n    const alpha = this._textureContent[(u + v * textureSize.width) * 4 + 3];\n    return alpha > 0.5;\n  }\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\n   * @returns null if no hit or a PickingInfo\n   */\n  intersects(ray, camera, predicate, fastCheck) {\n    const count = Math.min(this.capacity, this.sprites.length);\n    const min = Vector3.Zero();\n    const max = Vector3.Zero();\n    let distance = Number.MAX_VALUE;\n    let currentSprite = null;\n    const pickedPoint = TmpVectors.Vector3[0];\n    const cameraSpacePosition = TmpVectors.Vector3[1];\n    const cameraView = camera.getViewMatrix();\n    let activeRay = ray;\n    let pickedRay = ray;\n    for (let index = 0; index < count; index++) {\n      const sprite = this.sprites[index];\n      if (!sprite) {\n        continue;\n      }\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      if (sprite.angle) {\n        // Create a rotation matrix to rotate the ray to the sprite's rotation\n        Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\n        Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\n        Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]);\n        // inv translation x rotation x translation\n        TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\n        TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\n        activeRay = ray.clone();\n        Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\n        Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\n      } else {\n        activeRay = ray;\n      }\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n      if (activeRay.intersectsBoxMinMax(min, max)) {\n        const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\n        if (distance > currentDistance) {\n          if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\n            continue;\n          }\n          pickedRay = activeRay;\n          distance = currentDistance;\n          currentSprite = sprite;\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n    if (currentSprite) {\n      const result = new PickingInfo();\n      cameraView.invertToRef(TmpVectors.Matrix[0]);\n      result.hit = true;\n      result.pickedSprite = currentSprite;\n      result.distance = distance;\n      // Get picked point\n      const direction = TmpVectors.Vector3[2];\n      direction.copyFrom(pickedRay.direction);\n      direction.normalize();\n      direction.scaleInPlace(distance);\n      pickedRay.origin.addToRef(direction, pickedPoint);\n      result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      return result;\n    }\n    return null;\n  }\n  /**\n   * Intersects the sprites with a ray\n   * @param ray defines the ray to intersect with\n   * @param camera defines the current active camera\n   * @param predicate defines a predicate used to select candidate sprites\n   * @returns null if no hit or a PickingInfo array\n   */\n  multiIntersects(ray, camera, predicate) {\n    const count = Math.min(this.capacity, this.sprites.length);\n    const min = Vector3.Zero();\n    const max = Vector3.Zero();\n    let distance;\n    const results = [];\n    const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\n    const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\n    const cameraView = camera.getViewMatrix();\n    for (let index = 0; index < count; index++) {\n      const sprite = this.sprites[index];\n      if (!sprite) {\n        continue;\n      }\n      if (predicate) {\n        if (!predicate(sprite)) {\n          continue;\n        }\n      } else if (!sprite.isPickable) {\n        continue;\n      }\n      Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n      min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n      max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n      if (ray.intersectsBoxMinMax(min, max)) {\n        distance = Vector3.Distance(cameraSpacePosition, ray.origin);\n        if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\n          continue;\n        }\n        const result = new PickingInfo();\n        results.push(result);\n        cameraView.invertToRef(TmpVectors.Matrix[0]);\n        result.hit = true;\n        result.pickedSprite = sprite;\n        result.distance = distance;\n        // Get picked point\n        const direction = TmpVectors.Vector3[2];\n        direction.copyFrom(ray.direction);\n        direction.normalize();\n        direction.scaleInPlace(distance);\n        ray.origin.addToRef(direction, pickedPoint);\n        result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\n      }\n    }\n    return results;\n  }\n  /**\n   * Render all child sprites\n   */\n  render() {\n    // Check\n    if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    const deltaTime = engine.getDeltaTime();\n    if (this._packedAndReady) {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\n    } else {\n      this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\n    }\n  }\n  /**\n   * Rebuilds the manager (after a context lost, for eg)\n   */\n  rebuild() {\n    var _a;\n    (_a = this._spriteRenderer) === null || _a === void 0 ? void 0 : _a.rebuild();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    if (this._spriteRenderer) {\n      this._spriteRenderer.dispose();\n      this._spriteRenderer = null;\n    }\n    this._textureContent = null;\n    // Remove from scene\n    const index = this._scene.spriteManagers.indexOf(this);\n    this._scene.spriteManagers.splice(index, 1);\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.metadata = null;\n  }\n  /**\n   * Serializes the sprite manager to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.capacity = this.capacity;\n    serializationObject.cellWidth = this.cellWidth;\n    serializationObject.cellHeight = this.cellHeight;\n    if (this.texture) {\n      if (serializeTexture) {\n        serializationObject.texture = this.texture.serialize();\n      } else {\n        serializationObject.textureUrl = this.texture.name;\n        serializationObject.invertY = this.texture._invertY;\n      }\n    }\n    serializationObject.sprites = [];\n    for (const sprite of this.sprites) {\n      serializationObject.sprites.push(sprite.serialize());\n    }\n    serializationObject.metadata = this.metadata;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a new sprite manager.\n   * @param parsedManager The JSON object to parse\n   * @param scene The scene to create the sprite manager\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @returns the new sprite manager\n   */\n  static Parse(parsedManager, scene, rootUrl) {\n    const manager = new SpriteManager(parsedManager.name, \"\", parsedManager.capacity, {\n      width: parsedManager.cellWidth,\n      height: parsedManager.cellHeight\n    }, scene);\n    if (parsedManager.metadata !== undefined) {\n      manager.metadata = parsedManager.metadata;\n    }\n    if (parsedManager.texture) {\n      manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl);\n    } else if (parsedManager.textureName) {\n      manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\n    }\n    for (const parsedSprite of parsedManager.sprites) {\n      Sprite.Parse(parsedSprite, manager);\n    }\n    return manager;\n  }\n  /**\n   * Creates a sprite manager from a snippet saved in a remote file\n   * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n  static ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const serializationObject = JSON.parse(request.responseText);\n            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            if (name) {\n              output.name = name;\n            }\n            resolve(output);\n          } else {\n            reject(\"Unable to load the sprite manager\");\n          }\n        }\n      });\n      request.open(\"GET\", url);\n      request.send();\n    });\n  }\n  /**\n   * Creates a sprite manager from a snippet saved by the sprite editor\n   * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a promise that will resolve to the new sprite manager\n   */\n  static ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.spriteManager);\n            const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n            output.snippetId = snippetId;\n            resolve(output);\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n}\n/** Define the Url to load snippets */\nSpriteManager.SnippetUrl = `https://snippet.babylonjs.com`;\n/**\n * Creates a sprite manager from a snippet saved by the sprite editor\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new sprite manager\n */\nSpriteManager.CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;","map":{"version":3,"mappings":"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","names":["Observable","Vector3","TmpVectors","Matrix","Sprite","SpriteSceneComponent","PickingInfo","Texture","SceneComponentConstants","Logger","Tools","WebRequest","SpriteRenderer","EngineStore","SpriteManager","constructor","name","imgUrl","capacity","cellSize","scene","epsilon","samplingMode","TRILINEAR_SAMPLINGMODE","fromPacked","spriteJSON","Array","sprite","baseSize","cellRef","cellIndex","num","isFinite","Math","floor","_spriteMap","_xOffset","_cellData","frame","x","width","_yOffset","y","height","_xSize","w","_ySize","h","LastCreatedScene","_getComponent","NAME_SPRITE","_addComponent","_fromPacked","_scene","engine","getEngine","_spriteRenderer","cellWidth","cellHeight","undefined","spriteManagers","push","uniqueId","getUniqueId","texture","_makePacked","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","children","sprites","value","wrapU","CLAMP_ADDRESSMODE","wrapV","_textureContent","fogEnabled","blendMode","disableDepthWrite","_disableDepthWrite","getClassName","celldata","JSON","parse","frames","length","frametemp","i","_f","Object","keys","Error","spritemap","Reflect","ownKeys","_packedAndReady","e","re","li","lastIndex","test","jsonUrl","substring","onerror","onload","data","LoadFile","_checkTextureAlpha","ray","distance","min","max","useAlphaForPicking","textureSize","getSize","Uint8Array","readPixels","contactPoint","copyFrom","direction","normalize","scaleInPlace","addInPlace","origin","contactPointU","contactPointV","angle","rotatedU","cos","sin","rotatedV","u","v","alpha","intersects","camera","predicate","fastCheck","count","Zero","Number","MAX_VALUE","currentSprite","pickedPoint","cameraSpacePosition","cameraView","getViewMatrix","activeRay","pickedRay","index","isPickable","TransformCoordinatesToRef","position","TranslationToRef","RotationZToRef","multiplyToRef","clone","TransformNormalToRef","copyFromFloats","z","intersectsBoxMinMax","currentDistance","Distance","result","invertToRef","hit","pickedSprite","addToRef","TransformCoordinates","multiIntersects","results","render","deltaTime","getDeltaTime","getProjectionMatrix","_customUpdate","rebuild","dispose","indexOf","splice","notifyObservers","clear","metadata","serialize","serializeTexture","serializationObject","textureUrl","invertY","_invertY","Parse","parsedManager","rootUrl","manager","textureName","parsedSprite","ParseFromFileAsync","url","Promise","resolve","reject","request","addEventListener","readyState","status","responseText","output","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","spriteManager","SnippetUrl","replace"],"sourceRoot":"","sources":["../../../../lts/core/generated/Sprites/spriteManager.ts"],"sourcesContent":["import type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Sprite } from \"./sprite\";\r\nimport { SpriteSceneComponent } from \"./spriteSceneComponent\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport { SpriteRenderer } from \"./spriteRenderer\";\r\nimport type { ThinSprite } from \"./thinSprite\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\ndeclare type Ray = import(\"../Culling/ray\").Ray;\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\r\ndeclare const Reflect: any;\r\n\r\n/**\r\n * Defines the minimum interface to fulfill in order to be a sprite manager.\r\n */\r\nexport interface ISpriteManager extends IDisposable {\r\n    /**\r\n     * Gets manager's name\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Restricts the camera to viewing objects with the same layerMask.\r\n     * A camera with a layerMask of 1 will render spriteManager.layerMask & camera.layerMask!== 0\r\n     */\r\n    layerMask: number;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true\r\n     */\r\n    isPickable: boolean;\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * Specifies the rendering group id for this mesh (0 by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering#rendering-groups\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Defines the list of sprites managed by the manager.\r\n     */\r\n    sprites: Array<Sprite>;\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    texture: Texture;\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    cellWidth: number;\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    cellHeight: number;\r\n\r\n    /** @internal */\r\n    _wasDispatched: boolean;\r\n\r\n    /**\r\n     * Tests the intersection of a sprite with a specific ray.\r\n     * @param ray The ray we are sending to test the collision\r\n     * @param camera The camera space we are sending rays in\r\n     * @param predicate A predicate allowing excluding sprites from the list of object to test\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @returns picking info or null.\r\n     */\r\n    intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo>;\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]>;\r\n\r\n    /**\r\n     * Renders the list of sprites on screen.\r\n     */\r\n    render(): void;\r\n\r\n    /**\r\n     * Rebuilds the manager (after a context lost, for eg)\r\n     */\r\n    rebuild(): void;\r\n}\r\n\r\n/**\r\n * Class used to manage multiple sprites on the same spritesheet\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n */\r\nexport class SpriteManager implements ISpriteManager {\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the manager was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Gets the list of sprites */\r\n    public sprites = new Array<Sprite>();\r\n    /** Gets or sets the rendering group id (0 by default) */\r\n    public renderingGroupId = 0;\r\n    /** Gets or sets camera layer mask */\r\n    public layerMask: number = 0x0fffffff;\r\n    /** Gets or sets a boolean indicating if the sprites are pickable */\r\n    public isPickable = false;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sprite manager\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _wasDispatched = false;\r\n\r\n    /**\r\n     * An event triggered when the manager is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<SpriteManager>();\r\n\r\n    /**\r\n     * Callback called when the manager is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the sprite\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets the array of sprites\r\n     */\r\n    public get children() {\r\n        return this.sprites;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the capacity of the manager\r\n     */\r\n    public get capacity() {\r\n        return this._spriteRenderer.capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the spritesheet texture\r\n     */\r\n    public get texture(): Texture {\r\n        return this._spriteRenderer.texture as Texture;\r\n    }\r\n    public set texture(value: Texture) {\r\n        value.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        value.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._spriteRenderer.texture = value;\r\n        this._textureContent = null;\r\n    }\r\n\r\n    /** Defines the default width of a cell in the spritesheet */\r\n    public get cellWidth(): number {\r\n        return this._spriteRenderer.cellWidth;\r\n    }\r\n    public set cellWidth(value: number) {\r\n        this._spriteRenderer.cellWidth = value;\r\n    }\r\n\r\n    /** Defines the default height of a cell in the spritesheet */\r\n    public get cellHeight(): number {\r\n        return this._spriteRenderer.cellHeight;\r\n    }\r\n    public set cellHeight(value: number) {\r\n        this._spriteRenderer.cellHeight = value;\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the manager must consider scene fog when rendering */\r\n    public get fogEnabled(): boolean {\r\n        return this._spriteRenderer.fogEnabled;\r\n    }\r\n    public set fogEnabled(value: boolean) {\r\n        this._spriteRenderer.fogEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Blend mode use to render the particle, it can be any of\r\n     * the static Constants.ALPHA_x properties provided in this class.\r\n     * Default value is Constants.ALPHA_COMBINE\r\n     */\r\n    public get blendMode() {\r\n        return this._spriteRenderer.blendMode;\r\n    }\r\n    public set blendMode(blendMode: number) {\r\n        this._spriteRenderer.blendMode = blendMode;\r\n    }\r\n\r\n    private _disableDepthWrite: boolean = false;\r\n    /** Disables writing to the depth buffer when rendering the sprites.\r\n     *  It can be handy to disable depth writing when using textures without alpha channel\r\n     *  and setting some specific blend modes.\r\n     */\r\n    public get disableDepthWrite() {\r\n        return this._disableDepthWrite;\r\n    }\r\n\r\n    public set disableDepthWrite(value: boolean) {\r\n        this._disableDepthWrite = value;\r\n        this._spriteRenderer.disableDepthWrite = value;\r\n    }\r\n\r\n    private _spriteRenderer: SpriteRenderer;\r\n    /** Associative array from JSON sprite data file */\r\n    private _cellData: any;\r\n    /** Array of sprite names from JSON sprite data file */\r\n    private _spriteMap: Array<string>;\r\n    /** True when packed cell data from JSON file is ready*/\r\n    private _packedAndReady: boolean = false;\r\n    private _textureContent: Nullable<Uint8Array>;\r\n    private _onDisposeObserver: Nullable<Observer<SpriteManager>>;\r\n    private _fromPacked: boolean;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new sprite manager\r\n     * @param name defines the manager's name\r\n     * @param imgUrl defines the sprite sheet url\r\n     * @param capacity defines the maximum allowed number of sprites\r\n     * @param cellSize defines the size of a sprite cell\r\n     * @param scene defines the hosting scene\r\n     * @param epsilon defines the epsilon value to align texture (0.01 by default)\r\n     * @param samplingMode defines the sampling mode to use with spritesheet\r\n     * @param fromPacked set to false; do not alter\r\n     * @param spriteJSON null otherwise a JSON object defining sprite sheet data; do not alter\r\n     */\r\n    constructor(\r\n        /** defines the manager's name */\r\n        public name: string,\r\n        imgUrl: string,\r\n        capacity: number,\r\n        cellSize: any,\r\n        scene: Scene,\r\n        epsilon: number = 0.01,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        fromPacked: boolean = false,\r\n        spriteJSON: any | null = null\r\n    ) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene!;\r\n        }\r\n\r\n        if (!scene._getComponent(SceneComponentConstants.NAME_SPRITE)) {\r\n            scene._addComponent(new SpriteSceneComponent(scene));\r\n        }\r\n        this._fromPacked = fromPacked;\r\n\r\n        this._scene = scene;\r\n        const engine = this._scene.getEngine();\r\n        this._spriteRenderer = new SpriteRenderer(engine, capacity, epsilon, scene);\r\n\r\n        if (cellSize.width && cellSize.height) {\r\n            this.cellWidth = cellSize.width;\r\n            this.cellHeight = cellSize.height;\r\n        } else if (cellSize !== undefined) {\r\n            this.cellWidth = cellSize;\r\n            this.cellHeight = cellSize;\r\n        } else {\r\n            this._spriteRenderer = <any>null;\r\n            return;\r\n        }\r\n\r\n        this._scene.spriteManagers.push(this);\r\n        this.uniqueId = this.scene.getUniqueId();\r\n\r\n        if (imgUrl) {\r\n            this.texture = new Texture(imgUrl, scene, true, false, samplingMode);\r\n        }\r\n\r\n        if (this._fromPacked) {\r\n            this._makePacked(imgUrl, spriteJSON);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpriteManager\"\r\n     * @returns \"SpriteManager\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"SpriteManager\";\r\n    }\r\n\r\n    private _makePacked(imgUrl: string, spriteJSON: any) {\r\n        if (spriteJSON !== null) {\r\n            try {\r\n                //Get the JSON and Check its structure.  If its an array parse it if its a JSON string etc...\r\n                let celldata: any;\r\n                if (typeof spriteJSON === \"string\") {\r\n                    celldata = JSON.parse(spriteJSON);\r\n                } else {\r\n                    celldata = spriteJSON;\r\n                }\r\n\r\n                if (celldata.frames.length) {\r\n                    const frametemp: any = {};\r\n                    for (let i = 0; i < celldata.frames.length; i++) {\r\n                        const _f = celldata.frames[i];\r\n                        if (typeof Object.keys(_f)[0] !== \"string\") {\r\n                            throw new Error(\"Invalid JSON Format.  Check the frame values and make sure the name is the first parameter.\");\r\n                        }\r\n\r\n                        const name: string = _f[Object.keys(_f)[0]];\r\n                        frametemp[name] = _f;\r\n                    }\r\n                    celldata.frames = frametemp;\r\n                }\r\n\r\n                const spritemap = <string[]>Reflect.ownKeys(celldata.frames);\r\n\r\n                this._spriteMap = spritemap;\r\n                this._packedAndReady = true;\r\n                this._cellData = celldata.frames;\r\n            } catch (e) {\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n                throw new Error(\"Invalid JSON from string. Spritesheet managed with constant cell size.\");\r\n            }\r\n        } else {\r\n            const re = /\\./g;\r\n            let li: number;\r\n            do {\r\n                li = re.lastIndex;\r\n                re.test(imgUrl);\r\n            } while (re.lastIndex > 0);\r\n            const jsonUrl = imgUrl.substring(0, li - 1) + \".json\";\r\n            const onerror = () => {\r\n                Logger.Error(\"JSON ERROR: Unable to load JSON file.\");\r\n                this._fromPacked = false;\r\n                this._packedAndReady = false;\r\n            };\r\n            const onload = (data: string | ArrayBuffer) => {\r\n                try {\r\n                    const celldata = JSON.parse(data as string);\r\n                    const spritemap = <string[]>Reflect.ownKeys(celldata.frames);\r\n                    this._spriteMap = spritemap;\r\n                    this._packedAndReady = true;\r\n                    this._cellData = celldata.frames;\r\n                } catch (e) {\r\n                    this._fromPacked = false;\r\n                    this._packedAndReady = false;\r\n                    throw new Error(\"Invalid JSON format. Please check documentation for format specifications.\");\r\n                }\r\n            };\r\n            Tools.LoadFile(jsonUrl, onload, undefined, undefined, false, onerror);\r\n        }\r\n    }\r\n\r\n    private _checkTextureAlpha(sprite: Sprite, ray: Ray, distance: number, min: Vector3, max: Vector3) {\r\n        if (!sprite.useAlphaForPicking || !this.texture) {\r\n            return true;\r\n        }\r\n\r\n        const textureSize = this.texture.getSize();\r\n        if (!this._textureContent) {\r\n            this._textureContent = new Uint8Array(textureSize.width * textureSize.height * 4);\r\n            this.texture.readPixels(0, 0, this._textureContent);\r\n        }\r\n\r\n        const contactPoint = TmpVectors.Vector3[0];\r\n\r\n        contactPoint.copyFrom(ray.direction);\r\n\r\n        contactPoint.normalize();\r\n        contactPoint.scaleInPlace(distance);\r\n        contactPoint.addInPlace(ray.origin);\r\n\r\n        const contactPointU = (contactPoint.x - min.x) / (max.x - min.x) - 0.5;\r\n        const contactPointV = 1.0 - (contactPoint.y - min.y) / (max.y - min.y) - 0.5;\r\n\r\n        // Rotate\r\n        const angle = sprite.angle;\r\n        const rotatedU = 0.5 + (contactPointU * Math.cos(angle) - contactPointV * Math.sin(angle));\r\n        const rotatedV = 0.5 + (contactPointU * Math.sin(angle) + contactPointV * Math.cos(angle));\r\n\r\n        const u = (sprite._xOffset * textureSize.width + rotatedU * sprite._xSize) | 0;\r\n        const v = (sprite._yOffset * textureSize.height + rotatedV * sprite._ySize) | 0;\r\n\r\n        const alpha = this._textureContent![(u + v * textureSize.width) * 4 + 3];\r\n\r\n        return alpha > 0.5;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @param fastCheck defines if a fast check only must be done (the first potential sprite is will be used and not the closer)\r\n     * @returns null if no hit or a PickingInfo\r\n     */\r\n    public intersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean, fastCheck?: boolean): Nullable<PickingInfo> {\r\n        const count = Math.min(this.capacity, this.sprites.length);\r\n        const min = Vector3.Zero();\r\n        const max = Vector3.Zero();\r\n        let distance = Number.MAX_VALUE;\r\n        let currentSprite: Nullable<Sprite> = null;\r\n        const pickedPoint = TmpVectors.Vector3[0];\r\n        const cameraSpacePosition = TmpVectors.Vector3[1];\r\n        const cameraView = camera.getViewMatrix();\r\n        let activeRay: Ray = ray;\r\n        let pickedRay: Ray = ray;\r\n\r\n        for (let index = 0; index < count; index++) {\r\n            const sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            if (sprite.angle) {\r\n                // Create a rotation matrix to rotate the ray to the sprite's rotation\r\n                Matrix.TranslationToRef(-cameraSpacePosition.x, -cameraSpacePosition.y, 0, TmpVectors.Matrix[1]);\r\n                Matrix.TranslationToRef(cameraSpacePosition.x, cameraSpacePosition.y, 0, TmpVectors.Matrix[2]);\r\n                Matrix.RotationZToRef(sprite.angle, TmpVectors.Matrix[3]);\r\n\r\n                // inv translation x rotation x translation\r\n                TmpVectors.Matrix[1].multiplyToRef(TmpVectors.Matrix[3], TmpVectors.Matrix[4]);\r\n                TmpVectors.Matrix[4].multiplyToRef(TmpVectors.Matrix[2], TmpVectors.Matrix[0]);\r\n\r\n                activeRay = ray.clone();\r\n                Vector3.TransformCoordinatesToRef(ray.origin, TmpVectors.Matrix[0], activeRay.origin);\r\n                Vector3.TransformNormalToRef(ray.direction, TmpVectors.Matrix[0], activeRay.direction);\r\n            } else {\r\n                activeRay = ray;\r\n            }\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (activeRay.intersectsBoxMinMax(min, max)) {\r\n                const currentDistance = Vector3.Distance(cameraSpacePosition, activeRay.origin);\r\n\r\n                if (distance > currentDistance) {\r\n                    if (!this._checkTextureAlpha(sprite, activeRay, currentDistance, min, max)) {\r\n                        continue;\r\n                    }\r\n\r\n                    pickedRay = activeRay;\r\n                    distance = currentDistance;\r\n                    currentSprite = sprite;\r\n\r\n                    if (fastCheck) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentSprite) {\r\n            const result = new PickingInfo();\r\n\r\n            cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n            result.hit = true;\r\n            result.pickedSprite = currentSprite;\r\n            result.distance = distance;\r\n\r\n            // Get picked point\r\n            const direction = TmpVectors.Vector3[2];\r\n            direction.copyFrom(pickedRay.direction);\r\n            direction.normalize();\r\n            direction.scaleInPlace(distance);\r\n\r\n            pickedRay.origin.addToRef(direction, pickedPoint);\r\n            result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n\r\n            return result;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Intersects the sprites with a ray\r\n     * @param ray defines the ray to intersect with\r\n     * @param camera defines the current active camera\r\n     * @param predicate defines a predicate used to select candidate sprites\r\n     * @returns null if no hit or a PickingInfo array\r\n     */\r\n    public multiIntersects(ray: Ray, camera: Camera, predicate?: (sprite: Sprite) => boolean): Nullable<PickingInfo[]> {\r\n        const count = Math.min(this.capacity, this.sprites.length);\r\n        const min = Vector3.Zero();\r\n        const max = Vector3.Zero();\r\n        let distance: number;\r\n        const results: Nullable<PickingInfo[]> = [];\r\n        const pickedPoint = TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);\r\n        const cameraSpacePosition = TmpVectors.Vector3[1].copyFromFloats(0, 0, 0);\r\n        const cameraView = camera.getViewMatrix();\r\n\r\n        for (let index = 0; index < count; index++) {\r\n            const sprite = this.sprites[index];\r\n            if (!sprite) {\r\n                continue;\r\n            }\r\n\r\n            if (predicate) {\r\n                if (!predicate(sprite)) {\r\n                    continue;\r\n                }\r\n            } else if (!sprite.isPickable) {\r\n                continue;\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\r\n\r\n            min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\r\n            max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\r\n\r\n            if (ray.intersectsBoxMinMax(min, max)) {\r\n                distance = Vector3.Distance(cameraSpacePosition, ray.origin);\r\n\r\n                if (!this._checkTextureAlpha(sprite, ray, distance, min, max)) {\r\n                    continue;\r\n                }\r\n\r\n                const result = new PickingInfo();\r\n                results.push(result);\r\n\r\n                cameraView.invertToRef(TmpVectors.Matrix[0]);\r\n                result.hit = true;\r\n                result.pickedSprite = sprite;\r\n                result.distance = distance;\r\n\r\n                // Get picked point\r\n                const direction = TmpVectors.Vector3[2];\r\n                direction.copyFrom(ray.direction);\r\n                direction.normalize();\r\n                direction.scaleInPlace(distance);\r\n\r\n                ray.origin.addToRef(direction, pickedPoint);\r\n                result.pickedPoint = Vector3.TransformCoordinates(pickedPoint, TmpVectors.Matrix[0]);\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Render all child sprites\r\n     */\r\n    public render(): void {\r\n        // Check\r\n        if (this._fromPacked && (!this._packedAndReady || !this._spriteMap || !this._cellData)) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n        const deltaTime = engine.getDeltaTime();\r\n        if (this._packedAndReady) {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix(), this._customUpdate);\r\n        } else {\r\n            this._spriteRenderer.render(this.sprites, deltaTime, this._scene.getViewMatrix(), this._scene.getProjectionMatrix());\r\n        }\r\n    }\r\n\r\n    private _customUpdate = (sprite: ThinSprite, baseSize: ISize): void => {\r\n        if (!sprite.cellRef) {\r\n            sprite.cellIndex = 0;\r\n        }\r\n        const num = sprite.cellIndex;\r\n        if (typeof num === \"number\" && isFinite(num) && Math.floor(num) === num) {\r\n            sprite.cellRef = this._spriteMap[sprite.cellIndex];\r\n        }\r\n        sprite._xOffset = this._cellData[sprite.cellRef].frame.x / baseSize.width;\r\n        sprite._yOffset = this._cellData[sprite.cellRef].frame.y / baseSize.height;\r\n        sprite._xSize = this._cellData[sprite.cellRef].frame.w;\r\n        sprite._ySize = this._cellData[sprite.cellRef].frame.h;\r\n    };\r\n\r\n    /**\r\n     * Rebuilds the manager (after a context lost, for eg)\r\n     */\r\n    public rebuild(): void {\r\n        this._spriteRenderer?.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._spriteRenderer) {\r\n            this._spriteRenderer.dispose();\r\n            (<any>this._spriteRenderer) = null;\r\n        }\r\n\r\n        this._textureContent = null;\r\n\r\n        // Remove from scene\r\n        const index = this._scene.spriteManagers.indexOf(this);\r\n        this._scene.spriteManagers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n    }\r\n\r\n    /**\r\n     * Serializes the sprite manager to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.capacity = this.capacity;\r\n        serializationObject.cellWidth = this.cellWidth;\r\n        serializationObject.cellHeight = this.cellHeight;\r\n\r\n        if (this.texture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = this.texture.serialize();\r\n            } else {\r\n                serializationObject.textureUrl = this.texture.name;\r\n                serializationObject.invertY = this.texture._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.sprites = [];\r\n\r\n        for (const sprite of this.sprites) {\r\n            serializationObject.sprites.push(sprite.serialize());\r\n        }\r\n\r\n        serializationObject.metadata = this.metadata;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a new sprite manager.\r\n     * @param parsedManager The JSON object to parse\r\n     * @param scene The scene to create the sprite manager\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @returns the new sprite manager\r\n     */\r\n    public static Parse(parsedManager: any, scene: Scene, rootUrl: string): SpriteManager {\r\n        const manager = new SpriteManager(\r\n            parsedManager.name,\r\n            \"\",\r\n            parsedManager.capacity,\r\n            {\r\n                width: parsedManager.cellWidth,\r\n                height: parsedManager.cellHeight,\r\n            },\r\n            scene\r\n        );\r\n\r\n        if (parsedManager.metadata !== undefined) {\r\n            manager.metadata = parsedManager.metadata;\r\n        }\r\n\r\n        if (parsedManager.texture) {\r\n            manager.texture = Texture.Parse(parsedManager.texture, scene, rootUrl) as Texture;\r\n        } else if (parsedManager.textureName) {\r\n            manager.texture = new Texture(rootUrl + parsedManager.textureUrl, scene, false, parsedManager.invertY !== undefined ? parsedManager.invertY : true);\r\n        }\r\n\r\n        for (const parsedSprite of parsedManager.sprites) {\r\n            Sprite.Parse(parsedSprite, manager);\r\n        }\r\n\r\n        return manager;\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved in a remote file\r\n     * @param name defines the name of the sprite manager to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the sprite manager\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved by the sprite editor\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl: string = \"\"): Promise<SpriteManager> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(new SpriteManager(\"Default sprite manager\", \"//playground.babylonjs.com/textures/player.png\", 500, 64, scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.spriteManager);\r\n                        const output = SpriteManager.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a sprite manager from a snippet saved by the sprite editor\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load (can be set to _BLANK to create a default one)\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new sprite manager\r\n     */\r\n    public static CreateFromSnippetAsync = SpriteManager.ParseFromSnippetAsync;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}