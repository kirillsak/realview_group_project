{"ast":null,"code":"import { Color4 } from \"../Maths/math.color.js\";\n/** Class used to store color4 gradient */\nexport class ColorGradient {\n  /**\n   * Creates a new color4 gradient\n   * @param gradient gets or sets the gradient value (between 0 and 1)\n   * @param color1 gets or sets first associated color\n   * @param color2 gets or sets first second color\n   */\n  constructor(\n  /**\n   * Gets or sets the gradient value (between 0 and 1)\n   */\n  gradient,\n  /**\n   * Gets or sets first associated color\n   */\n  color1,\n  /**\n   * Gets or sets second associated color\n   */\n  color2) {\n    this.gradient = gradient;\n    this.color1 = color1;\n    this.color2 = color2;\n  }\n  /**\n   * Will get a color picked randomly between color1 and color2.\n   * If color2 is undefined then color1 will be used\n   * @param result defines the target Color4 to store the result in\n   */\n  getColorToRef(result) {\n    if (!this.color2) {\n      result.copyFrom(this.color1);\n      return;\n    }\n    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\n  }\n}\n/** Class used to store color 3 gradient */\nexport class Color3Gradient {\n  /**\n   * Creates a new color3 gradient\n   * @param gradient gets or sets the gradient value (between 0 and 1)\n   * @param color gets or sets associated color\n   */\n  constructor(\n  /**\n   * Gets or sets the gradient value (between 0 and 1)\n   */\n  gradient,\n  /**\n   * Gets or sets the associated color\n   */\n  color) {\n    this.gradient = gradient;\n    this.color = color;\n  }\n}\n/** Class used to store factor gradient */\nexport class FactorGradient {\n  /**\n   * Creates a new factor gradient\n   * @param gradient gets or sets the gradient value (between 0 and 1)\n   * @param factor1 gets or sets first associated factor\n   * @param factor2 gets or sets second associated factor\n   */\n  constructor(\n  /**\n   * Gets or sets the gradient value (between 0 and 1)\n   */\n  gradient,\n  /**\n   * Gets or sets first associated factor\n   */\n  factor1,\n  /**\n   * Gets or sets second associated factor\n   */\n  factor2) {\n    this.gradient = gradient;\n    this.factor1 = factor1;\n    this.factor2 = factor2;\n  }\n  /**\n   * Will get a number picked randomly between factor1 and factor2.\n   * If factor2 is undefined then factor1 will be used\n   * @returns the picked number\n   */\n  getFactor() {\n    if (this.factor2 === undefined || this.factor2 === this.factor1) {\n      return this.factor1;\n    }\n    return this.factor1 + (this.factor2 - this.factor1) * Math.random();\n  }\n}\n/**\n * Helper used to simplify some generic gradient tasks\n */\nexport class GradientHelper {\n  /**\n   * Gets the current gradient from an array of IValueGradient\n   * @param ratio defines the current ratio to get\n   * @param gradients defines the array of IValueGradient\n   * @param updateFunc defines the callback function used to get the final value from the selected gradients\n   */\n  static GetCurrentGradient(ratio, gradients, updateFunc) {\n    // Use last index if over\n    if (gradients[0].gradient > ratio) {\n      updateFunc(gradients[0], gradients[0], 1.0);\n      return;\n    }\n    for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\n      const currentGradient = gradients[gradientIndex];\n      const nextGradient = gradients[gradientIndex + 1];\n      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\n        const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\n        updateFunc(currentGradient, nextGradient, scale);\n        return;\n      }\n    }\n    // Use last index if over\n    const lastIndex = gradients.length - 1;\n    updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\n  }\n}","map":{"version":3,"mappings":"AACA,SAASA,MAAM,QAAQ,wBAAsB;AAU7C;AACA,OAAM,MAAOC,aAAa;EACtB;;;;;;EAMAC;EACI;;;EAGOC,QAAgB;EACvB;;;EAGOC,MAAc;EACrB;;;EAGOC,MAAe;IARf,aAAQ,GAARF,QAAQ;IAIR,WAAM,GAANC,MAAM;IAIN,WAAM,GAANC,MAAM;EACd;EAEH;;;;;EAKOC,aAAa,CAACC,MAAc;IAC/B,IAAI,CAAC,IAAI,CAACF,MAAM,EAAE;MACdE,MAAM,CAACC,QAAQ,CAAC,IAAI,CAACJ,MAAM,CAAC;MAC5B;;IAGJJ,MAAM,CAACS,SAAS,CAAC,IAAI,CAACL,MAAM,EAAE,IAAI,CAACC,MAAM,EAAEK,IAAI,CAACC,MAAM,EAAE,EAAEJ,MAAM,CAAC;EACrE;;AAGJ;AACA,OAAM,MAAOK,cAAc;EACvB;;;;;EAKAV;EACI;;;EAGOC,QAAgB;EACvB;;;EAGOU,KAAa;IAJb,aAAQ,GAARV,QAAQ;IAIR,UAAK,GAALU,KAAK;EACb;;AAGP;AACA,OAAM,MAAOC,cAAc;EACvB;;;;;;EAMAZ;EACI;;;EAGOC,QAAgB;EACvB;;;EAGOY,OAAe;EACtB;;;EAGOC,OAAgB;IARhB,aAAQ,GAARb,QAAQ;IAIR,YAAO,GAAPY,OAAO;IAIP,YAAO,GAAPC,OAAO;EACf;EAEH;;;;;EAKOC,SAAS;IACZ,IAAI,IAAI,CAACD,OAAO,KAAKE,SAAS,IAAI,IAAI,CAACF,OAAO,KAAK,IAAI,CAACD,OAAO,EAAE;MAC7D,OAAO,IAAI,CAACA,OAAO;;IAGvB,OAAO,IAAI,CAACA,OAAO,GAAG,CAAC,IAAI,CAACC,OAAO,GAAG,IAAI,CAACD,OAAO,IAAIL,IAAI,CAACC,MAAM,EAAE;EACvE;;AAGJ;;;AAGA,OAAM,MAAOQ,cAAc;EACvB;;;;;;EAMO,OAAOC,kBAAkB,CAACC,KAAa,EAAEC,SAA2B,EAAEC,UAAkF;IAC3J;IACA,IAAID,SAAS,CAAC,CAAC,CAAC,CAACnB,QAAQ,GAAGkB,KAAK,EAAE;MAC/BE,UAAU,CAACD,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;MAC3C;;IAGJ,KAAK,IAAIE,aAAa,GAAG,CAAC,EAAEA,aAAa,GAAGF,SAAS,CAACG,MAAM,GAAG,CAAC,EAAED,aAAa,EAAE,EAAE;MAC/E,MAAME,eAAe,GAAGJ,SAAS,CAACE,aAAa,CAAC;MAChD,MAAMG,YAAY,GAAGL,SAAS,CAACE,aAAa,GAAG,CAAC,CAAC;MAEjD,IAAIH,KAAK,IAAIK,eAAe,CAACvB,QAAQ,IAAIkB,KAAK,IAAIM,YAAY,CAACxB,QAAQ,EAAE;QACrE,MAAMyB,KAAK,GAAG,CAACP,KAAK,GAAGK,eAAe,CAACvB,QAAQ,KAAKwB,YAAY,CAACxB,QAAQ,GAAGuB,eAAe,CAACvB,QAAQ,CAAC;QACrGoB,UAAU,CAACG,eAAe,EAAEC,YAAY,EAAEC,KAAK,CAAC;QAChD;;;IAIR;IACA,MAAMC,SAAS,GAAGP,SAAS,CAACG,MAAM,GAAG,CAAC;IACtCF,UAAU,CAACD,SAAS,CAACO,SAAS,CAAC,EAAEP,SAAS,CAACO,SAAS,CAAC,EAAE,GAAG,CAAC;EAC/D","names":["Color4","ColorGradient","constructor","gradient","color1","color2","getColorToRef","result","copyFrom","LerpToRef","Math","random","Color3Gradient","color","FactorGradient","factor1","factor2","getFactor","undefined","GradientHelper","GetCurrentGradient","ratio","gradients","updateFunc","gradientIndex","length","currentGradient","nextGradient","scale","lastIndex"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/gradients.ts"],"sourcesContent":["import type { Color3 } from \"../Maths/math.color\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\n\r\n/** Interface used by value gradients (color, factor, ...) */\r\nexport interface IValueGradient {\r\n    /**\r\n     * Gets or sets the gradient value (between 0 and 1)\r\n     */\r\n    gradient: number;\r\n}\r\n\r\n/** Class used to store color4 gradient */\r\nexport class ColorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color4 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color1 gets or sets first associated color\r\n     * @param color2 gets or sets first second color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated color\r\n         */\r\n        public color1: Color4,\r\n        /**\r\n         * Gets or sets second associated color\r\n         */\r\n        public color2?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Will get a color picked randomly between color1 and color2.\r\n     * If color2 is undefined then color1 will be used\r\n     * @param result defines the target Color4 to store the result in\r\n     */\r\n    public getColorToRef(result: Color4) {\r\n        if (!this.color2) {\r\n            result.copyFrom(this.color1);\r\n            return;\r\n        }\r\n\r\n        Color4.LerpToRef(this.color1, this.color2, Math.random(), result);\r\n    }\r\n}\r\n\r\n/** Class used to store color 3 gradient */\r\nexport class Color3Gradient implements IValueGradient {\r\n    /**\r\n     * Creates a new color3 gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param color gets or sets associated color\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets the associated color\r\n         */\r\n        public color: Color3\r\n    ) {}\r\n}\r\n\r\n/** Class used to store factor gradient */\r\nexport class FactorGradient implements IValueGradient {\r\n    /**\r\n     * Creates a new factor gradient\r\n     * @param gradient gets or sets the gradient value (between 0 and 1)\r\n     * @param factor1 gets or sets first associated factor\r\n     * @param factor2 gets or sets second associated factor\r\n     */\r\n    public constructor(\r\n        /**\r\n         * Gets or sets the gradient value (between 0 and 1)\r\n         */\r\n        public gradient: number,\r\n        /**\r\n         * Gets or sets first associated factor\r\n         */\r\n        public factor1: number,\r\n        /**\r\n         * Gets or sets second associated factor\r\n         */\r\n        public factor2?: number\r\n    ) {}\r\n\r\n    /**\r\n     * Will get a number picked randomly between factor1 and factor2.\r\n     * If factor2 is undefined then factor1 will be used\r\n     * @returns the picked number\r\n     */\r\n    public getFactor(): number {\r\n        if (this.factor2 === undefined || this.factor2 === this.factor1) {\r\n            return this.factor1;\r\n        }\r\n\r\n        return this.factor1 + (this.factor2 - this.factor1) * Math.random();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to simplify some generic gradient tasks\r\n */\r\nexport class GradientHelper {\r\n    /**\r\n     * Gets the current gradient from an array of IValueGradient\r\n     * @param ratio defines the current ratio to get\r\n     * @param gradients defines the array of IValueGradient\r\n     * @param updateFunc defines the callback function used to get the final value from the selected gradients\r\n     */\r\n    public static GetCurrentGradient(ratio: number, gradients: IValueGradient[], updateFunc: (current: IValueGradient, next: IValueGradient, scale: number) => void) {\r\n        // Use last index if over\r\n        if (gradients[0].gradient > ratio) {\r\n            updateFunc(gradients[0], gradients[0], 1.0);\r\n            return;\r\n        }\r\n\r\n        for (let gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {\r\n            const currentGradient = gradients[gradientIndex];\r\n            const nextGradient = gradients[gradientIndex + 1];\r\n\r\n            if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {\r\n                const scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);\r\n                updateFunc(currentGradient, nextGradient, scale);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Use last index if over\r\n        const lastIndex = gradients.length - 1;\r\n        updateFunc(gradients[lastIndex], gradients[lastIndex], 1.0);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}