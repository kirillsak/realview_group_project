{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n/**\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\n */\nexport class MeshExploder {\n  /**\n   * Explodes meshes from a center mesh.\n   * @param meshes The meshes to explode.\n   * @param centerMesh The mesh to be center of explosion.\n   */\n  constructor(meshes, centerMesh) {\n    this._meshesOrigins = [];\n    this._toCenterVectors = [];\n    this._scaledDirection = new Vector3(1, 1, 1);\n    this._newPosition = Vector3.Zero();\n    this._centerPosition = Vector3.Zero();\n    this._meshes = meshes.slice();\n    if (centerMesh) {\n      this._centerMesh = centerMesh;\n    } else {\n      this._setCenterMesh();\n    }\n    this._centerMesh.computeWorldMatrix(true);\n    const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\n    if (centerMeshIndex >= 0) {\n      this._meshes.splice(centerMeshIndex, 1);\n    }\n    this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        const mesh = this._meshes[index];\n        this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\n        this._toCenterVectors[index] = Vector3.Zero();\n        if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\n          mesh.computeWorldMatrix(true);\n          mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\n        }\n      }\n    }\n  }\n  _setCenterMesh() {\n    let averageCenter = Vector3.Zero();\n    const totalCenters = Vector3.Zero();\n    let shortestToCenter = Number.MAX_VALUE;\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        const mesh = this._meshes[index];\n        const boundingInfo = mesh.getBoundingInfo();\n        if (boundingInfo) {\n          totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\n        }\n      }\n    }\n    averageCenter = totalCenters.scale(1 / this._meshes.length);\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index]) {\n        const mesh = this._meshes[index];\n        const boundingInfo = mesh.getBoundingInfo();\n        if (boundingInfo) {\n          const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\n          if (distanceToCenter < shortestToCenter) {\n            this._centerMesh = mesh;\n            shortestToCenter = distanceToCenter;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Get class name\n   * @returns \"MeshExploder\"\n   */\n  getClassName() {\n    return \"MeshExploder\";\n  }\n  /**\n   * \"Exploded meshes\"\n   * @returns Array of meshes with the centerMesh at index 0.\n   */\n  getMeshes() {\n    const meshArray = this._meshes.slice();\n    meshArray.unshift(this._centerMesh);\n    return meshArray;\n  }\n  /**\n   * Explodes meshes giving a specific direction\n   * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\n   */\n  explode(direction = 1.0) {\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\n        this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\n        this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\n        this._meshes[index].setAbsolutePosition(this._newPosition);\n      }\n    }\n    this._centerMesh.setAbsolutePosition(this._centerPosition);\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","MeshExploder","constructor","meshes","centerMesh","Zero","_meshes","slice","_centerMesh","_setCenterMesh","computeWorldMatrix","centerMeshIndex","indexOf","splice","_centerPosition","getAbsolutePosition","clone","index","length","mesh","_meshesOrigins","_toCenterVectors","hasBoundingInfo","getBoundingInfo","boundingBox","centerWorld","subtractToRef","averageCenter","totalCenters","shortestToCenter","Number","MAX_VALUE","boundingInfo","addInPlace","scale","distanceToCenter","subtract","lengthSquared","getClassName","getMeshes","meshArray","unshift","explode","direction","scaleToRef","_scaledDirection","addToRef","_newPosition","setAbsolutePosition"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/meshExploder.ts"],"sourcesContent":["import type { Mesh } from \"../Meshes/mesh\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\n\r\n/**\r\n * Class used to explode meshes (ie. to have a center and move them away from that center to better see the overall organization)\r\n */\r\nexport class MeshExploder {\r\n    private _centerMesh: Mesh;\r\n    private _meshes: Array<Mesh>;\r\n    private _meshesOrigins: Array<Vector3> = [];\r\n    private _toCenterVectors: Array<Vector3> = [];\r\n    private _scaledDirection = new Vector3(1, 1, 1);\r\n    private _newPosition = Vector3.Zero();\r\n    private _centerPosition = Vector3.Zero();\r\n\r\n    /**\r\n     * Explodes meshes from a center mesh.\r\n     * @param meshes The meshes to explode.\r\n     * @param centerMesh The mesh to be center of explosion.\r\n     */\r\n    constructor(meshes: Array<Mesh>, centerMesh?: Mesh) {\r\n        this._meshes = meshes.slice();\r\n\r\n        if (centerMesh) {\r\n            this._centerMesh = centerMesh;\r\n        } else {\r\n            this._setCenterMesh();\r\n        }\r\n        this._centerMesh.computeWorldMatrix(true);\r\n\r\n        const centerMeshIndex = this._meshes.indexOf(this._centerMesh);\r\n        if (centerMeshIndex >= 0) {\r\n            this._meshes.splice(centerMeshIndex, 1);\r\n        }\r\n        this._centerPosition = this._centerMesh.getAbsolutePosition().clone();\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                this._meshesOrigins[index] = mesh.getAbsolutePosition().clone();\r\n                this._toCenterVectors[index] = Vector3.Zero();\r\n                if (mesh.hasBoundingInfo && this._centerMesh.hasBoundingInfo) {\r\n                    mesh.computeWorldMatrix(true);\r\n                    mesh.getBoundingInfo().boundingBox.centerWorld.subtractToRef(this._centerMesh.getBoundingInfo().boundingBox.centerWorld, this._toCenterVectors[index]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setCenterMesh(): void {\r\n        let averageCenter = Vector3.Zero();\r\n        const totalCenters = Vector3.Zero();\r\n        let shortestToCenter = Number.MAX_VALUE;\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    totalCenters.addInPlace(boundingInfo.boundingBox.centerWorld);\r\n                }\r\n            }\r\n        }\r\n        averageCenter = totalCenters.scale(1 / this._meshes.length);\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index]) {\r\n                const mesh = this._meshes[index];\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    const distanceToCenter = boundingInfo.boundingBox.centerWorld.subtract(averageCenter).lengthSquared();\r\n                    if (distanceToCenter < shortestToCenter) {\r\n                        this._centerMesh = mesh;\r\n                        shortestToCenter = distanceToCenter;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get class name\r\n     * @returns \"MeshExploder\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshExploder\";\r\n    }\r\n\r\n    /**\r\n     * \"Exploded meshes\"\r\n     * @returns Array of meshes with the centerMesh at index 0.\r\n     */\r\n    public getMeshes(): Array<Mesh> {\r\n        const meshArray = this._meshes.slice();\r\n        meshArray.unshift(this._centerMesh);\r\n        return meshArray;\r\n    }\r\n\r\n    /**\r\n     * Explodes meshes giving a specific direction\r\n     * @param direction Number to multiply distance of each mesh's origin from center. Use a negative number to implode, or zero to reset.\r\n     */\r\n    public explode(direction: number = 1.0): void {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (this._meshes[index] && this._meshesOrigins[index] && this._toCenterVectors[index]) {\r\n                this._toCenterVectors[index].scaleToRef(direction, this._scaledDirection);\r\n                this._meshesOrigins[index].addToRef(this._scaledDirection, this._newPosition);\r\n                this._meshes[index].setAbsolutePosition(this._newPosition);\r\n            }\r\n        }\r\n        this._centerMesh.setAbsolutePosition(this._centerPosition);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}