{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * Particle emitter emitting particles from the inside of a box.\n * It emits the particles randomly between 2 given directions.\n */\nexport class MeshParticleEmitter {\n  /**\n   * Creates a new instance MeshParticleEmitter\n   * @param mesh defines the mesh to use as source\n   */\n  constructor(mesh = null) {\n    this._indices = null;\n    this._positions = null;\n    this._normals = null;\n    this._storedNormal = Vector3.Zero();\n    this._mesh = null;\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n    this.direction1 = new Vector3(0, 1.0, 0);\n    /**\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\n     */\n    this.direction2 = new Vector3(0, 1.0, 0);\n    /**\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\n     */\n    this.useMeshNormalsForDirection = true;\n    this.mesh = mesh;\n  }\n  /** Defines the mesh to use as source */\n  get mesh() {\n    return this._mesh;\n  }\n  set mesh(value) {\n    if (this._mesh === value) {\n      return;\n    }\n    this._mesh = value;\n    if (value) {\n      this._indices = value.getIndices();\n      this._positions = value.getVerticesData(VertexBuffer.PositionKind);\n      this._normals = value.getVerticesData(VertexBuffer.NormalKind);\n    } else {\n      this._indices = null;\n      this._positions = null;\n      this._normals = null;\n    }\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    if (this.useMeshNormalsForDirection && this._normals) {\n      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\n      return;\n    }\n    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    if (isLocal) {\n      directionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    if (!this._indices || !this._positions) {\n      return;\n    }\n    const randomFaceIndex = 3 * Math.random() * (this._indices.length / 3) | 0;\n    const bu = Math.random();\n    const bv = Math.random() * (1.0 - bu);\n    const bw = 1.0 - bu - bv;\n    const faceIndexA = this._indices[randomFaceIndex];\n    const faceIndexB = this._indices[randomFaceIndex + 1];\n    const faceIndexC = this._indices[randomFaceIndex + 2];\n    const vertexA = TmpVectors.Vector3[0];\n    const vertexB = TmpVectors.Vector3[1];\n    const vertexC = TmpVectors.Vector3[2];\n    const randomVertex = TmpVectors.Vector3[3];\n    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\n    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\n    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\n    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\n    } else {\n      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\n    }\n    if (this.useMeshNormalsForDirection && this._normals) {\n      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\n      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\n      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\n      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\n      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\n      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\n    }\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new MeshParticleEmitter(this.mesh);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"\";\n  }\n  /**\n   * Returns the string \"BoxParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"MeshParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    var _a;\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    serializationObject.meshId = (_a = this.mesh) === null || _a === void 0 ? void 0 : _a.id;\n    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   * @param scene defines the hosting scene\n   */\n  parse(serializationObject, scene) {\n    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\n    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\n    if (serializationObject.meshId && scene) {\n      this.mesh = scene.getLastMeshById(serializationObject.meshId);\n    }\n    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\n  }\n}","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","TmpVectors","Scalar","VertexBuffer","MeshParticleEmitter","constructor","mesh","Zero","_mesh","value","_indices","getIndices","_positions","getVerticesData","PositionKind","_normals","NormalKind","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","useMeshNormalsForDirection","TransformNormalToRef","_storedNormal","randX","RandomRange","direction1","x","direction2","randY","y","randZ","z","copyFromFloats","TransformNormalFromFloatsToRef","startPositionFunction","positionToUpdate","randomFaceIndex","Math","random","length","bu","bv","bw","faceIndexA","faceIndexB","faceIndexC","vertexA","vertexB","vertexC","randomVertex","FromArrayToRef","TransformCoordinatesFromFloatsToRef","clone","newOne","DeepCopy","applyToShader","uboOrEffect","setVector3","buildUniformLayout","ubo","addUniform","getEffectDefines","getClassName","serialize","serializationObject","type","asArray","meshId","id","parse","scene","getLastMeshById"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/EmitterTypes/meshParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { IndicesArray, Nullable, FloatArray } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a box.\r\n * It emits the particles randomly between 2 given directions.\r\n */\r\nexport class MeshParticleEmitter implements IParticleEmitterType {\r\n    private _indices: Nullable<IndicesArray> = null;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _storedNormal = Vector3.Zero();\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction1 = new Vector3(0, 1.0, 0);\r\n    /**\r\n     * Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.\r\n     */\r\n    public direction2 = new Vector3(0, 1.0, 0);\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that particle directions must be built from mesh face normals\r\n     */\r\n    public useMeshNormalsForDirection = true;\r\n\r\n    /** Defines the mesh to use as source */\r\n    public get mesh(): Nullable<AbstractMesh> {\r\n        return this._mesh;\r\n    }\r\n\r\n    public set mesh(value: Nullable<AbstractMesh>) {\r\n        if (this._mesh === value) {\r\n            return;\r\n        }\r\n\r\n        this._mesh = value;\r\n\r\n        if (value) {\r\n            this._indices = value.getIndices();\r\n            this._positions = value.getVerticesData(VertexBuffer.PositionKind);\r\n            this._normals = value.getVerticesData(VertexBuffer.NormalKind);\r\n        } else {\r\n            this._indices = null;\r\n            this._positions = null;\r\n            this._normals = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MeshParticleEmitter\r\n     * @param mesh defines the mesh to use as source\r\n     */\r\n    constructor(mesh: Nullable<AbstractMesh> = null) {\r\n        this.mesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);\r\n            return;\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (!this._indices || !this._positions) {\r\n            return;\r\n        }\r\n\r\n        const randomFaceIndex = (3 * Math.random() * (this._indices.length / 3)) | 0;\r\n        const bu = Math.random();\r\n        const bv = Math.random() * (1.0 - bu);\r\n        const bw = 1.0 - bu - bv;\r\n\r\n        const faceIndexA = this._indices[randomFaceIndex];\r\n        const faceIndexB = this._indices[randomFaceIndex + 1];\r\n        const faceIndexC = this._indices[randomFaceIndex + 2];\r\n        const vertexA = TmpVectors.Vector3[0];\r\n        const vertexB = TmpVectors.Vector3[1];\r\n        const vertexC = TmpVectors.Vector3[2];\r\n        const randomVertex = TmpVectors.Vector3[3];\r\n\r\n        Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);\r\n        Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);\r\n\r\n        randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n        randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n        randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);\r\n        } else {\r\n            Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);\r\n        }\r\n\r\n        if (this.useMeshNormalsForDirection && this._normals) {\r\n            Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);\r\n            Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);\r\n\r\n            this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;\r\n            this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;\r\n            this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): MeshParticleEmitter {\r\n        const newOne = new MeshParticleEmitter(this.mesh);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"BoxParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MeshParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n        serializationObject.meshId = this.mesh?.id;\r\n        serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public parse(serializationObject: any, scene: Nullable<Scene>): void {\r\n        Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);\r\n        Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);\r\n\r\n        if (serializationObject.meshId && scene) {\r\n            this.mesh = scene.getLastMeshById(serializationObject.meshId);\r\n        }\r\n\r\n        this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}