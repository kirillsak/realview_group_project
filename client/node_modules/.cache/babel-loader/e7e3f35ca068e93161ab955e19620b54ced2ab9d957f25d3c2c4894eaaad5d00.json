{"ast":null,"code":"import { Logger } from \"../../../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color4, Color3 } from \"../../../Maths/math.color.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { WebRequest } from \"../../../Misc/webRequest.js\";\n/**\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n * Custom Procedural textures are the easiest way to create your own procedural in your application.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\n */\nexport class CustomProceduralTexture extends ProceduralTexture {\n  /**\n   * Instantiates a new Custom Procedural Texture.\n   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\n   * Custom Procedural textures are the easiest way to create your own procedural in your application.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\n   * @param name Define the name of the texture\n   * @param texturePath Define the folder path containing all the custom texture related files (config, shaders...)\n   * @param size Define the size of the texture to create\n   * @param scene Define the scene the texture belongs to\n   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\n   * @param generateMipMaps Define if the texture should creates mip maps or not\n   * @param skipJson Define a boolena indicating that there is no json config file to load\n   */\n  constructor(name, texturePath, size, scene, fallbackTexture, generateMipMaps, skipJson) {\n    super(name, size, null, scene, fallbackTexture, generateMipMaps);\n    this._animate = true;\n    this._time = 0;\n    this._texturePath = texturePath;\n    if (!skipJson) {\n      //Try to load json\n      this._loadJson(texturePath);\n    } else {\n      this.setFragment(this._texturePath);\n    }\n    this.refreshRate = 1;\n  }\n  _loadJson(jsonUrl) {\n    const noConfigFile = () => {\n      try {\n        this.setFragment(this._texturePath);\n      } catch (ex) {\n        Logger.Log(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\n      }\n    };\n    const configFileUrl = jsonUrl + \"/config.json\";\n    const xhr = new WebRequest();\n    xhr.open(\"GET\", configFileUrl);\n    xhr.addEventListener(\"load\", () => {\n      if (xhr.status === 200 || xhr.responseText && xhr.responseText.length > 0) {\n        try {\n          this._config = JSON.parse(xhr.response);\n          this.updateShaderUniforms();\n          this.updateTextures();\n          this.setFragment(this._texturePath + \"/custom\");\n          this._animate = this._config.animate;\n          this.refreshRate = this._config.refreshrate;\n        } catch (ex) {\n          noConfigFile();\n        }\n      } else {\n        noConfigFile();\n      }\n    }, false);\n    xhr.addEventListener(\"error\", () => {\n      noConfigFile();\n    }, false);\n    try {\n      xhr.send();\n    } catch (ex) {\n      Logger.Error(\"CustomProceduralTexture: Error on XHR send request.\");\n    }\n  }\n  /**\n   * Is the texture ready to be used ? (rendered at least once)\n   * @returns true if ready, otherwise, false.\n   */\n  isReady() {\n    if (!super.isReady()) {\n      return false;\n    }\n    for (const name in this._textures) {\n      const texture = this._textures[name];\n      if (!texture.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Render the texture to its associated render target.\n   * @param useCameraPostProcess Define if camera post process should be applied to the texture\n   */\n  render(useCameraPostProcess) {\n    const scene = this.getScene();\n    if (this._animate && scene) {\n      this._time += scene.getAnimationRatio() * 0.03;\n      this.updateShaderUniforms();\n    }\n    super.render(useCameraPostProcess);\n  }\n  /**\n   * Update the list of dependant textures samplers in the shader.\n   */\n  updateTextures() {\n    for (let i = 0; i < this._config.sampler2Ds.length; i++) {\n      this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + \"/\" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));\n    }\n  }\n  /**\n   * Update the uniform values of the procedural texture in the shader.\n   */\n  updateShaderUniforms() {\n    if (this._config) {\n      for (let j = 0; j < this._config.uniforms.length; j++) {\n        const uniform = this._config.uniforms[j];\n        switch (uniform.type) {\n          case \"float\":\n            this.setFloat(uniform.name, uniform.value);\n            break;\n          case \"color3\":\n            this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));\n            break;\n          case \"color4\":\n            this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));\n            break;\n          case \"vector2\":\n            this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));\n            break;\n          case \"vector3\":\n            this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));\n            break;\n        }\n      }\n    }\n    this.setFloat(\"time\", this._time);\n  }\n  /**\n   * Define if the texture animates or not.\n   */\n  get animate() {\n    return this._animate;\n  }\n  set animate(value) {\n    this._animate = value;\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","Vector3","Vector2","Color4","Color3","Texture","ProceduralTexture","WebRequest","CustomProceduralTexture","constructor","name","texturePath","size","scene","fallbackTexture","generateMipMaps","skipJson","_texturePath","_loadJson","setFragment","refreshRate","jsonUrl","noConfigFile","ex","Log","configFileUrl","xhr","open","addEventListener","status","responseText","length","_config","JSON","parse","response","updateShaderUniforms","updateTextures","_animate","animate","refreshrate","send","Error","isReady","_textures","texture","render","useCameraPostProcess","getScene","_time","getAnimationRatio","i","sampler2Ds","setTexture","sample2Dname","textureRelativeUrl","j","uniforms","uniform","type","setFloat","value","setColor3","r","g","b","setColor4","a","setVector2","x","y","setVector3","z"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/Procedurals/customProceduralTexture.ts"],"sourcesContent":["import { Logger } from \"../../../Misc/logger\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"./proceduralTexture\";\r\nimport { WebRequest } from \"../../../Misc/webRequest\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n * Custom Procedural textures are the easiest way to create your own procedural in your application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\r\n */\r\nexport class CustomProceduralTexture extends ProceduralTexture {\r\n    private _animate: boolean = true;\r\n    private _time: number = 0;\r\n    private _config: any;\r\n    private _texturePath: string;\r\n\r\n    /**\r\n     * Instantiates a new Custom Procedural Texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * Custom Procedural textures are the easiest way to create your own procedural in your application.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures#creating-custom-procedural-textures\r\n     * @param name Define the name of the texture\r\n     * @param texturePath Define the folder path containing all the custom texture related files (config, shaders...)\r\n     * @param size Define the size of the texture to create\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param skipJson Define a boolena indicating that there is no json config file to load\r\n     */\r\n    constructor(name: string, texturePath: string, size: TextureSize, scene: Scene, fallbackTexture?: Texture, generateMipMaps?: boolean, skipJson?: boolean) {\r\n        super(name, size, null, scene, fallbackTexture, generateMipMaps);\r\n        this._texturePath = texturePath;\r\n\r\n        if (!skipJson) {\r\n            //Try to load json\r\n            this._loadJson(texturePath);\r\n        } else {\r\n            this.setFragment(this._texturePath);\r\n        }\r\n        this.refreshRate = 1;\r\n    }\r\n\r\n    private _loadJson(jsonUrl: string): void {\r\n        const noConfigFile = () => {\r\n            try {\r\n                this.setFragment(this._texturePath);\r\n            } catch (ex) {\r\n                Logger.Log(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\r\n            }\r\n        };\r\n\r\n        const configFileUrl = jsonUrl + \"/config.json\";\r\n        const xhr = new WebRequest();\r\n\r\n        xhr.open(\"GET\", configFileUrl);\r\n        xhr.addEventListener(\r\n            \"load\",\r\n            () => {\r\n                if (xhr.status === 200 || (xhr.responseText && xhr.responseText.length > 0)) {\r\n                    try {\r\n                        this._config = JSON.parse(xhr.response);\r\n\r\n                        this.updateShaderUniforms();\r\n                        this.updateTextures();\r\n                        this.setFragment(this._texturePath + \"/custom\");\r\n\r\n                        this._animate = this._config.animate;\r\n                        this.refreshRate = this._config.refreshrate;\r\n                    } catch (ex) {\r\n                        noConfigFile();\r\n                    }\r\n                } else {\r\n                    noConfigFile();\r\n                }\r\n            },\r\n            false\r\n        );\r\n\r\n        xhr.addEventListener(\r\n            \"error\",\r\n            () => {\r\n                noConfigFile();\r\n            },\r\n            false\r\n        );\r\n\r\n        try {\r\n            xhr.send();\r\n        } catch (ex) {\r\n            Logger.Error(\"CustomProceduralTexture: Error on XHR send request.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public isReady(): boolean {\r\n        if (!super.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            const texture = this._textures[name];\r\n\r\n            if (!texture.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n        if (this._animate && scene) {\r\n            this._time += scene.getAnimationRatio() * 0.03;\r\n            this.updateShaderUniforms();\r\n        }\r\n\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    /**\r\n     * Update the list of dependant textures samplers in the shader.\r\n     */\r\n    public updateTextures(): void {\r\n        for (let i = 0; i < this._config.sampler2Ds.length; i++) {\r\n            this.setTexture(this._config.sampler2Ds[i].sample2Dname, new Texture(this._texturePath + \"/\" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the uniform values of the procedural texture in the shader.\r\n     */\r\n    public updateShaderUniforms(): void {\r\n        if (this._config) {\r\n            for (let j = 0; j < this._config.uniforms.length; j++) {\r\n                const uniform = this._config.uniforms[j];\r\n\r\n                switch (uniform.type) {\r\n                    case \"float\":\r\n                        this.setFloat(uniform.name, uniform.value);\r\n                        break;\r\n                    case \"color3\":\r\n                        this.setColor3(uniform.name, new Color3(uniform.r, uniform.g, uniform.b));\r\n                        break;\r\n                    case \"color4\":\r\n                        this.setColor4(uniform.name, new Color4(uniform.r, uniform.g, uniform.b, uniform.a));\r\n                        break;\r\n                    case \"vector2\":\r\n                        this.setVector2(uniform.name, new Vector2(uniform.x, uniform.y));\r\n                        break;\r\n                    case \"vector3\":\r\n                        this.setVector3(uniform.name, new Vector3(uniform.x, uniform.y, uniform.z));\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setFloat(\"time\", this._time);\r\n    }\r\n\r\n    /**\r\n     * Define if the texture animates or not.\r\n     */\r\n    public get animate(): boolean {\r\n        return this._animate;\r\n    }\r\n\r\n    public set animate(value: boolean) {\r\n        this._animate = value;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}