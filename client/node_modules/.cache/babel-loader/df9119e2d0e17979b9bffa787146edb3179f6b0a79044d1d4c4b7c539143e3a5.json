{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Vector4 } from \"../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../Maths/math.color.js\";\nimport { Condition, ValueCondition } from \"./condition.js\";\nimport { Action } from \"./action.js\";\nimport { DoNothingAction } from \"./directActions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { AbstractActionManager } from \"./abstractActionManager.js\";\n\n/**\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\n */\nexport class ActionManager extends AbstractActionManager {\n  /**\n   * Creates a new action manager\n   * @param scene defines the hosting scene\n   */\n  constructor(scene) {\n    super();\n    scene = scene || EngineStore.LastCreatedScene;\n    if (!scene) {\n      return;\n    }\n    this._scene = scene;\n    scene.actionManagers.push(this);\n  }\n  // Methods\n  /**\n   * Releases all associated resources\n   */\n  dispose() {\n    const index = this._scene.actionManagers.indexOf(this);\n    for (let i = 0; i < this.actions.length; i++) {\n      const action = this.actions[i];\n      ActionManager.Triggers[action.trigger]--;\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n    }\n    if (index > -1) {\n      this._scene.actionManagers.splice(index, 1);\n    }\n  }\n  /**\n   * Gets hosting scene\n   * @returns the hosting scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Does this action manager handles actions of any of the given triggers\n   * @param triggers defines the triggers to be tested\n   * @returns a boolean indicating whether one (or more) of the triggers is handled\n   */\n  hasSpecificTriggers(triggers) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (triggers.indexOf(action.trigger) > -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\n   * speed.\n   * @param triggerA defines the trigger to be tested\n   * @param triggerB defines the trigger to be tested\n   * @returns a boolean indicating whether one (or more) of the triggers is handled\n   */\n  hasSpecificTriggers2(triggerA, triggerB) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (triggerA == action.trigger || triggerB == action.trigger) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager handles actions of a given trigger\n   * @param trigger defines the trigger to be tested\n   * @param parameterPredicate defines an optional predicate to filter triggers by parameter\n   * @returns whether the trigger is handled\n   */\n  hasSpecificTrigger(trigger, parameterPredicate) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger === trigger) {\n        if (parameterPredicate) {\n          if (parameterPredicate(action.getTriggerParameter())) {\n            return true;\n          }\n        } else {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager has pointer triggers\n   */\n  get hasPointerTriggers() {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Does this action manager has pick triggers\n   */\n  get hasPickTriggers() {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Registers an action to this action manager\n   * @param action defines the action to be registered\n   * @returns the action amended (prepared) after registration\n   */\n  registerAction(action) {\n    if (action.trigger === ActionManager.OnEveryFrameTrigger) {\n      if (this.getScene().actionManager !== this) {\n        Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\n        return null;\n      }\n    }\n    this.actions.push(action);\n    this.getScene()._registeredActions++;\n    if (ActionManager.Triggers[action.trigger]) {\n      ActionManager.Triggers[action.trigger]++;\n    } else {\n      ActionManager.Triggers[action.trigger] = 1;\n    }\n    action._actionManager = this;\n    action._prepare();\n    return action;\n  }\n  /**\n   * Unregisters an action to this action manager\n   * @param action defines the action to be unregistered\n   * @returns a boolean indicating whether the action has been unregistered\n   */\n  unregisterAction(action) {\n    const index = this.actions.indexOf(action);\n    if (index !== -1) {\n      this.actions.splice(index, 1);\n      ActionManager.Triggers[action.trigger] -= 1;\n      if (ActionManager.Triggers[action.trigger] === 0) {\n        delete ActionManager.Triggers[action.trigger];\n      }\n      action._actionManager = null;\n      this.getScene()._registeredActions--;\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Process a specific trigger\n   * @param trigger defines the trigger to process\n   * @param evt defines the event details to be processed\n   */\n  processTrigger(trigger, evt) {\n    for (let index = 0; index < this.actions.length; index++) {\n      const action = this.actions[index];\n      if (action.trigger === trigger) {\n        if (evt) {\n          if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\n            const parameter = action.getTriggerParameter();\n            if (parameter && parameter !== evt.sourceEvent.keyCode) {\n              if (!parameter.toLowerCase) {\n                continue;\n              }\n              const lowerCase = parameter.toLowerCase();\n              if (lowerCase !== evt.sourceEvent.key) {\n                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\n                const actualkey = String.fromCharCode(unicode).toLowerCase();\n                if (actualkey !== lowerCase) {\n                  continue;\n                }\n              }\n            }\n          }\n        }\n        action._executeCurrent(evt);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _getEffectiveTarget(target, propertyPath) {\n    const properties = propertyPath.split(\".\");\n    for (let index = 0; index < properties.length - 1; index++) {\n      target = target[properties[index]];\n    }\n    return target;\n  }\n  /**\n   * @internal\n   */\n  _getProperty(propertyPath) {\n    const properties = propertyPath.split(\".\");\n    return properties[properties.length - 1];\n  }\n  /**\n   * Serialize this manager to a JSON object\n   * @param name defines the property name to store this manager\n   * @returns a JSON representation of this manager\n   */\n  serialize(name) {\n    const root = {\n      children: new Array(),\n      name: name,\n      type: 3,\n      properties: new Array() // Empty for root but required\n    };\n\n    for (let i = 0; i < this.actions.length; i++) {\n      const triggerObject = {\n        type: 0,\n        children: new Array(),\n        name: ActionManager.GetTriggerName(this.actions[i].trigger),\n        properties: new Array()\n      };\n      const triggerOptions = this.actions[i].triggerOptions;\n      if (triggerOptions && typeof triggerOptions !== \"number\") {\n        if (triggerOptions.parameter instanceof Node) {\n          triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\n        } else if (typeof triggerOptions.parameter === \"object\") {\n          const parameter = {};\n          DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\n          if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\n            parameter._meshId = triggerOptions.parameter.mesh.id;\n          }\n          triggerObject.properties.push({\n            name: \"parameter\",\n            targetType: null,\n            value: parameter\n          });\n        } else {\n          triggerObject.properties.push({\n            name: \"parameter\",\n            targetType: null,\n            value: triggerOptions.parameter\n          });\n        }\n      }\n      // Serialize child action, recursively\n      this.actions[i].serialize(triggerObject);\n      // Add serialized trigger\n      root.children.push(triggerObject);\n    }\n    return root;\n  }\n  /**\n   * Creates a new ActionManager from a JSON data\n   * @param parsedActions defines the JSON data to read from\n   * @param object defines the hosting mesh\n   * @param scene defines the hosting scene\n   */\n  static Parse(parsedActions, object, scene) {\n    const actionManager = new ActionManager(scene);\n    if (object === null) {\n      scene.actionManager = actionManager;\n    } else {\n      object.actionManager = actionManager;\n    }\n    // instantiate a new object\n    const instantiate = (name, params) => {\n      const internalClassType = GetClass(\"BABYLON.\" + name);\n      return internalClassType && new internalClassType(...params);\n    };\n    const parseParameter = (name, value, target, propertyPath) => {\n      if (propertyPath === null) {\n        // String, boolean or float\n        const floatValue = parseFloat(value);\n        if (value === \"true\" || value === \"false\") {\n          return value === \"true\";\n        } else {\n          return isNaN(floatValue) ? value : floatValue;\n        }\n      }\n      const effectiveTarget = propertyPath.split(\".\");\n      const values = value.split(\",\");\n      // Get effective Target\n      for (let i = 0; i < effectiveTarget.length; i++) {\n        target = target[effectiveTarget[i]];\n      }\n      // Return appropriate value with its type\n      if (typeof target === \"boolean\") {\n        return values[0] === \"true\";\n      }\n      if (typeof target === \"string\") {\n        return values[0];\n      }\n      // Parameters with multiple values such as Vector3 etc.\n      const split = new Array();\n      for (let i = 0; i < values.length; i++) {\n        split.push(parseFloat(values[i]));\n      }\n      if (target instanceof Vector3) {\n        return Vector3.FromArray(split);\n      }\n      if (target instanceof Vector4) {\n        return Vector4.FromArray(split);\n      }\n      if (target instanceof Color3) {\n        return Color3.FromArray(split);\n      }\n      if (target instanceof Color4) {\n        return Color4.FromArray(split);\n      }\n      return parseFloat(values[0]);\n    };\n    // traverse graph per trigger\n    const traverse = (parsedAction, trigger, condition, action, combineArray = null) => {\n      if (parsedAction.detached) {\n        return;\n      }\n      const parameters = new Array();\n      let target = null;\n      let propertyPath = null;\n      const combine = parsedAction.combine && parsedAction.combine.length > 0;\n      // Parameters\n      if (parsedAction.type === 2) {\n        parameters.push(actionManager);\n      } else {\n        parameters.push(trigger);\n      }\n      if (combine) {\n        const actions = new Array();\n        for (let j = 0; j < parsedAction.combine.length; j++) {\n          traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\n        }\n        parameters.push(actions);\n      } else {\n        for (let i = 0; i < parsedAction.properties.length; i++) {\n          let value = parsedAction.properties[i].value;\n          const name = parsedAction.properties[i].name;\n          const targetType = parsedAction.properties[i].targetType;\n          if (name === \"target\") {\n            if (targetType === \"SceneProperties\") {\n              value = target = scene;\n            } else if (targetType === \"MaterialProperties\") {\n              value = target = scene.getMaterialByName(value);\n            } else {\n              value = target = scene.getNodeByName(value);\n            }\n          } else if (name === \"parent\") {\n            value = scene.getNodeByName(value);\n          } else if (name === \"sound\") {\n            // Can not externalize to component, so only checks for the presence off the API.\n            if (scene.getSoundByName) {\n              value = scene.getSoundByName(value);\n            }\n          } else if (name !== \"propertyPath\") {\n            if (parsedAction.type === 2 && name === \"operator\") {\n              value = ValueCondition[value];\n            } else {\n              value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\n            }\n          } else {\n            propertyPath = value;\n          }\n          parameters.push(value);\n        }\n      }\n      if (combineArray === null) {\n        parameters.push(condition);\n      } else {\n        parameters.push(null);\n      }\n      // If interpolate value action\n      if (parsedAction.name === \"InterpolateValueAction\") {\n        const param = parameters[parameters.length - 2];\n        parameters[parameters.length - 1] = param;\n        parameters[parameters.length - 2] = condition;\n      }\n      // Action or condition(s) and not CombineAction\n      let newAction = instantiate(parsedAction.name, parameters);\n      if (newAction instanceof Condition && condition !== null) {\n        const nothing = new DoNothingAction(trigger, condition);\n        if (action) {\n          action.then(nothing);\n        } else {\n          actionManager.registerAction(nothing);\n        }\n        action = nothing;\n      }\n      if (combineArray === null) {\n        if (newAction instanceof Condition) {\n          condition = newAction;\n          newAction = action;\n        } else {\n          condition = null;\n          if (action) {\n            action.then(newAction);\n          } else {\n            actionManager.registerAction(newAction);\n          }\n        }\n      } else {\n        combineArray.push(newAction);\n      }\n      for (let i = 0; i < parsedAction.children.length; i++) {\n        traverse(parsedAction.children[i], trigger, condition, newAction, null);\n      }\n    };\n    // triggers\n    for (let i = 0; i < parsedActions.children.length; i++) {\n      let triggerParams;\n      const trigger = parsedActions.children[i];\n      if (trigger.properties.length > 0) {\n        const param = trigger.properties[0].value;\n        const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\n        if (value._meshId) {\n          value.mesh = scene.getMeshById(value._meshId);\n        }\n        triggerParams = {\n          trigger: ActionManager[trigger.name],\n          parameter: value\n        };\n      } else {\n        triggerParams = ActionManager[trigger.name];\n      }\n      for (let j = 0; j < trigger.children.length; j++) {\n        if (!trigger.detached) {\n          traverse(trigger.children[j], triggerParams, null, null);\n        }\n      }\n    }\n  }\n  /**\n   * Get a trigger name by index\n   * @param trigger defines the trigger index\n   * @returns a trigger name\n   */\n  static GetTriggerName(trigger) {\n    switch (trigger) {\n      case 0:\n        return \"NothingTrigger\";\n      case 1:\n        return \"OnPickTrigger\";\n      case 2:\n        return \"OnLeftPickTrigger\";\n      case 3:\n        return \"OnRightPickTrigger\";\n      case 4:\n        return \"OnCenterPickTrigger\";\n      case 5:\n        return \"OnPickDownTrigger\";\n      case 6:\n        return \"OnDoublePickTrigger\";\n      // start;\n      case 7:\n        return \"OnPickUpTrigger\";\n      case 8:\n        return \"OnLongPressTrigger\";\n      case 9:\n        return \"OnPointerOverTrigger\";\n      case 10:\n        return \"OnPointerOutTrigger\";\n      case 11:\n        return \"OnEveryFrameTrigger\";\n      case 12:\n        return \"OnIntersectionEnterTrigger\";\n      case 13:\n        return \"OnIntersectionExitTrigger\";\n      case 14:\n        return \"OnKeyDownTrigger\";\n      case 15:\n        return \"OnKeyUpTrigger\";\n      case 16:\n        return \"OnPickOutTrigger\";\n      default:\n        return \"\";\n    }\n  }\n}\n/**\n * Nothing\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.NothingTrigger = 0;\n/**\n * On pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickTrigger = 1;\n/**\n * On left pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnLeftPickTrigger = 2;\n/**\n * On right pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnRightPickTrigger = 3;\n/**\n * On center pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnCenterPickTrigger = 4;\n/**\n * On pick down\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickDownTrigger = 5;\n/**\n * On double pick\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnDoublePickTrigger = 6;\n/**\n * On pick up\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickUpTrigger = 7;\n/**\n * On pick out.\n * This trigger will only be raised if you also declared a OnPickDown\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPickOutTrigger = 16;\n/**\n * On long press\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnLongPressTrigger = 8;\n/**\n * On pointer over\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPointerOverTrigger = 9;\n/**\n * On pointer out\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnPointerOutTrigger = 10;\n/**\n * On every frame\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnEveryFrameTrigger = 11;\n/**\n * On intersection enter\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnIntersectionEnterTrigger = 12;\n/**\n * On intersection exit\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnIntersectionExitTrigger = 13;\n/**\n * On key down\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnKeyDownTrigger = 14;\n/**\n * On key up\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\n */\nActionManager.OnKeyUpTrigger = 15;","map":{"version":3,"mappings":"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","names":["Vector3","Vector4","Color3","Color4","Condition","ValueCondition","Action","DoNothingAction","EngineStore","Logger","DeepCopier","GetClass","AbstractActionManager","ActionManager","constructor","scene","LastCreatedScene","_scene","actionManagers","push","dispose","index","indexOf","i","actions","length","action","Triggers","trigger","splice","getScene","hasSpecificTriggers","triggers","hasSpecificTriggers2","triggerA","triggerB","hasSpecificTrigger","parameterPredicate","getTriggerParameter","hasPointerTriggers","OnPickTrigger","OnPointerOutTrigger","hasPickTriggers","OnPickUpTrigger","registerAction","OnEveryFrameTrigger","actionManager","Warn","_registeredActions","_actionManager","_prepare","unregisterAction","processTrigger","evt","OnKeyUpTrigger","OnKeyDownTrigger","parameter","sourceEvent","keyCode","toLowerCase","lowerCase","key","unicode","charCode","actualkey","String","fromCharCode","_executeCurrent","_getEffectiveTarget","target","propertyPath","properties","split","_getProperty","serialize","name","root","children","Array","type","triggerObject","GetTriggerName","triggerOptions","Node","_GetTargetProperty","DeepCopy","mesh","_meshId","id","targetType","value","Parse","parsedActions","object","instantiate","params","internalClassType","parseParameter","floatValue","parseFloat","isNaN","effectiveTarget","values","FromArray","traverse","parsedAction","condition","combineArray","detached","parameters","combine","j","NothingTrigger","getMaterialByName","getNodeByName","getSoundByName","param","newAction","nothing","then","triggerParams","getMeshByName","getMeshById"],"sourceRoot":"","sources":["../../../../lts/core/generated/Actions/actionManager.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Condition, ValueCondition } from \"./condition\";\r\nimport type { IAction } from \"./action\";\r\nimport { Action } from \"./action\";\r\nimport { DoNothingAction } from \"./directActions\";\r\n\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IActionEvent } from \"../Actions/actionEvent\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport { AbstractActionManager } from \"./abstractActionManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Action Manager manages all events to be triggered on a given mesh or the global scene.\r\n * A single scene can have many Action Managers to handle predefined actions on specific meshes.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\r\n */\r\nexport class ActionManager extends AbstractActionManager {\r\n    /**\r\n     * Nothing\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly NothingTrigger = Constants.ACTION_NothingTrigger;\r\n\r\n    /**\r\n     * On pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickTrigger = Constants.ACTION_OnPickTrigger;\r\n\r\n    /**\r\n     * On left pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnLeftPickTrigger = Constants.ACTION_OnLeftPickTrigger;\r\n\r\n    /**\r\n     * On right pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnRightPickTrigger = Constants.ACTION_OnRightPickTrigger;\r\n\r\n    /**\r\n     * On center pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnCenterPickTrigger = Constants.ACTION_OnCenterPickTrigger;\r\n\r\n    /**\r\n     * On pick down\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickDownTrigger = Constants.ACTION_OnPickDownTrigger;\r\n\r\n    /**\r\n     * On double pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnDoublePickTrigger = Constants.ACTION_OnDoublePickTrigger;\r\n\r\n    /**\r\n     * On pick up\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickUpTrigger = Constants.ACTION_OnPickUpTrigger;\r\n    /**\r\n     * On pick out.\r\n     * This trigger will only be raised if you also declared a OnPickDown\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPickOutTrigger = Constants.ACTION_OnPickOutTrigger;\r\n\r\n    /**\r\n     * On long press\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnLongPressTrigger = Constants.ACTION_OnLongPressTrigger;\r\n\r\n    /**\r\n     * On pointer over\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPointerOverTrigger = Constants.ACTION_OnPointerOverTrigger;\r\n\r\n    /**\r\n     * On pointer out\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnPointerOutTrigger = Constants.ACTION_OnPointerOutTrigger;\r\n\r\n    /**\r\n     * On every frame\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnEveryFrameTrigger = Constants.ACTION_OnEveryFrameTrigger;\r\n    /**\r\n     * On intersection enter\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnIntersectionEnterTrigger = Constants.ACTION_OnIntersectionEnterTrigger;\r\n\r\n    /**\r\n     * On intersection exit\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnIntersectionExitTrigger = Constants.ACTION_OnIntersectionExitTrigger;\r\n\r\n    /**\r\n     * On key down\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnKeyDownTrigger = Constants.ACTION_OnKeyDownTrigger;\r\n\r\n    /**\r\n     * On key up\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly OnKeyUpTrigger = Constants.ACTION_OnKeyUpTrigger;\r\n\r\n    // Members\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Creates a new action manager\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        super();\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n\r\n        scene.actionManagers.push(this);\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Releases all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const index = this._scene.actionManagers.indexOf(this);\r\n\r\n        for (let i = 0; i < this.actions.length; i++) {\r\n            const action = this.actions[i];\r\n            ActionManager.Triggers[action.trigger]--;\r\n            if (ActionManager.Triggers[action.trigger] === 0) {\r\n                delete ActionManager.Triggers[action.trigger];\r\n            }\r\n        }\r\n\r\n        if (index > -1) {\r\n            this._scene.actionManagers.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets hosting scene\r\n     * @returns the hosting scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of any of the given triggers\r\n     * @param triggers defines the triggers to be tested\r\n     * @returns a boolean indicating whether one (or more) of the triggers is handled\r\n     */\r\n    public hasSpecificTriggers(triggers: number[]): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (triggers.indexOf(action.trigger) > -1) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of any of the given triggers. This function takes two arguments for\r\n     * speed.\r\n     * @param triggerA defines the trigger to be tested\r\n     * @param triggerB defines the trigger to be tested\r\n     * @returns a boolean indicating whether one (or more) of the triggers is handled\r\n     */\r\n    public hasSpecificTriggers2(triggerA: number, triggerB: number): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (triggerA == action.trigger || triggerB == action.trigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager handles actions of a given trigger\r\n     * @param trigger defines the trigger to be tested\r\n     * @param parameterPredicate defines an optional predicate to filter triggers by parameter\r\n     * @returns whether the trigger is handled\r\n     */\r\n    public hasSpecificTrigger(trigger: number, parameterPredicate?: (parameter: any) => boolean): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger === trigger) {\r\n                if (parameterPredicate) {\r\n                    if (parameterPredicate(action.getTriggerParameter())) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager has pointer triggers\r\n     */\r\n    public get hasPointerTriggers(): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPointerOutTrigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Does this action manager has pick triggers\r\n     */\r\n    public get hasPickTriggers(): boolean {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger >= ActionManager.OnPickTrigger && action.trigger <= ActionManager.OnPickUpTrigger) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Registers an action to this action manager\r\n     * @param action defines the action to be registered\r\n     * @returns the action amended (prepared) after registration\r\n     */\r\n    public registerAction(action: IAction): Nullable<IAction> {\r\n        if (action.trigger === ActionManager.OnEveryFrameTrigger) {\r\n            if (this.getScene().actionManager !== this) {\r\n                Logger.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\r\n                return null;\r\n            }\r\n        }\r\n\r\n        this.actions.push(action);\r\n        this.getScene()._registeredActions++;\r\n\r\n        if (ActionManager.Triggers[action.trigger]) {\r\n            ActionManager.Triggers[action.trigger]++;\r\n        } else {\r\n            ActionManager.Triggers[action.trigger] = 1;\r\n        }\r\n\r\n        action._actionManager = this;\r\n        action._prepare();\r\n\r\n        return action;\r\n    }\r\n\r\n    /**\r\n     * Unregisters an action to this action manager\r\n     * @param action defines the action to be unregistered\r\n     * @returns a boolean indicating whether the action has been unregistered\r\n     */\r\n    public unregisterAction(action: IAction): Boolean {\r\n        const index = this.actions.indexOf(action);\r\n        if (index !== -1) {\r\n            this.actions.splice(index, 1);\r\n            ActionManager.Triggers[action.trigger] -= 1;\r\n            if (ActionManager.Triggers[action.trigger] === 0) {\r\n                delete ActionManager.Triggers[action.trigger];\r\n            }\r\n            action._actionManager = null;\r\n            this.getScene()._registeredActions--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Process a specific trigger\r\n     * @param trigger defines the trigger to process\r\n     * @param evt defines the event details to be processed\r\n     */\r\n    public processTrigger(trigger: number, evt?: IActionEvent): void {\r\n        for (let index = 0; index < this.actions.length; index++) {\r\n            const action = this.actions[index];\r\n\r\n            if (action.trigger === trigger) {\r\n                if (evt) {\r\n                    if (trigger === ActionManager.OnKeyUpTrigger || trigger === ActionManager.OnKeyDownTrigger) {\r\n                        const parameter = action.getTriggerParameter();\r\n\r\n                        if (parameter && parameter !== evt.sourceEvent.keyCode) {\r\n                            if (!parameter.toLowerCase) {\r\n                                continue;\r\n                            }\r\n                            const lowerCase = parameter.toLowerCase();\r\n\r\n                            if (lowerCase !== evt.sourceEvent.key) {\r\n                                const unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\r\n                                const actualkey = String.fromCharCode(unicode).toLowerCase();\r\n                                if (actualkey !== lowerCase) {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                action._executeCurrent(evt);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getEffectiveTarget(target: any, propertyPath: string): any {\r\n        const properties = propertyPath.split(\".\");\r\n\r\n        for (let index = 0; index < properties.length - 1; index++) {\r\n            target = target[properties[index]];\r\n        }\r\n\r\n        return target;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getProperty(propertyPath: string): string {\r\n        const properties = propertyPath.split(\".\");\r\n\r\n        return properties[properties.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Serialize this manager to a JSON object\r\n     * @param name defines the property name to store this manager\r\n     * @returns a JSON representation of this manager\r\n     */\r\n    public serialize(name: string): any {\r\n        const root = {\r\n            children: new Array(),\r\n            name: name,\r\n            type: 3, // Root node\r\n            properties: new Array(), // Empty for root but required\r\n        };\r\n\r\n        for (let i = 0; i < this.actions.length; i++) {\r\n            const triggerObject = {\r\n                type: 0, // Trigger\r\n                children: new Array(),\r\n                name: ActionManager.GetTriggerName(this.actions[i].trigger),\r\n                properties: new Array(),\r\n            };\r\n\r\n            const triggerOptions = this.actions[i].triggerOptions;\r\n\r\n            if (triggerOptions && typeof triggerOptions !== \"number\") {\r\n                if (triggerOptions.parameter instanceof Node) {\r\n                    triggerObject.properties.push(Action._GetTargetProperty(triggerOptions.parameter));\r\n                } else if (typeof triggerOptions.parameter === \"object\") {\r\n                    const parameter = <any>{};\r\n                    DeepCopier.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\r\n\r\n                    if (triggerOptions.parameter && triggerOptions.parameter.mesh) {\r\n                        parameter._meshId = triggerOptions.parameter.mesh.id;\r\n                    }\r\n\r\n                    triggerObject.properties.push({ name: \"parameter\", targetType: null, value: parameter });\r\n                } else {\r\n                    triggerObject.properties.push({ name: \"parameter\", targetType: null, value: triggerOptions.parameter });\r\n                }\r\n            }\r\n\r\n            // Serialize child action, recursively\r\n            this.actions[i].serialize(triggerObject);\r\n\r\n            // Add serialized trigger\r\n            root.children.push(triggerObject);\r\n        }\r\n\r\n        return root;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ActionManager from a JSON data\r\n     * @param parsedActions defines the JSON data to read from\r\n     * @param object defines the hosting mesh\r\n     * @param scene defines the hosting scene\r\n     */\r\n    public static Parse(parsedActions: any, object: Nullable<AbstractMesh>, scene: Scene): void {\r\n        const actionManager = new ActionManager(scene);\r\n        if (object === null) {\r\n            scene.actionManager = actionManager;\r\n        } else {\r\n            object.actionManager = actionManager;\r\n        }\r\n\r\n        // instantiate a new object\r\n        const instantiate = (name: string, params: Array<any>): any => {\r\n            const internalClassType = GetClass(\"BABYLON.\" + name);\r\n            return internalClassType && new internalClassType(...params);\r\n        };\r\n\r\n        const parseParameter = (name: string, value: string, target: any, propertyPath: Nullable<string>): any => {\r\n            if (propertyPath === null) {\r\n                // String, boolean or float\r\n                const floatValue = parseFloat(value);\r\n\r\n                if (value === \"true\" || value === \"false\") {\r\n                    return value === \"true\";\r\n                } else {\r\n                    return isNaN(floatValue) ? value : floatValue;\r\n                }\r\n            }\r\n\r\n            const effectiveTarget = propertyPath.split(\".\");\r\n            const values = value.split(\",\");\r\n\r\n            // Get effective Target\r\n            for (let i = 0; i < effectiveTarget.length; i++) {\r\n                target = target[effectiveTarget[i]];\r\n            }\r\n\r\n            // Return appropriate value with its type\r\n            if (typeof target === \"boolean\") {\r\n                return values[0] === \"true\";\r\n            }\r\n\r\n            if (typeof target === \"string\") {\r\n                return values[0];\r\n            }\r\n\r\n            // Parameters with multiple values such as Vector3 etc.\r\n            const split = new Array<number>();\r\n            for (let i = 0; i < values.length; i++) {\r\n                split.push(parseFloat(values[i]));\r\n            }\r\n\r\n            if (target instanceof Vector3) {\r\n                return Vector3.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Vector4) {\r\n                return Vector4.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Color3) {\r\n                return Color3.FromArray(split);\r\n            }\r\n\r\n            if (target instanceof Color4) {\r\n                return Color4.FromArray(split);\r\n            }\r\n\r\n            return parseFloat(values[0]);\r\n        };\r\n\r\n        // traverse graph per trigger\r\n        const traverse = (parsedAction: any, trigger: any, condition: Nullable<Condition>, action: Nullable<Action>, combineArray: Nullable<Array<Action>> = null) => {\r\n            if (parsedAction.detached) {\r\n                return;\r\n            }\r\n\r\n            const parameters = new Array<any>();\r\n            let target: any = null;\r\n            let propertyPath: Nullable<string> = null;\r\n            const combine = parsedAction.combine && parsedAction.combine.length > 0;\r\n\r\n            // Parameters\r\n            if (parsedAction.type === 2) {\r\n                parameters.push(actionManager);\r\n            } else {\r\n                parameters.push(trigger);\r\n            }\r\n\r\n            if (combine) {\r\n                const actions = new Array<Action>();\r\n                for (let j = 0; j < parsedAction.combine.length; j++) {\r\n                    traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\r\n                }\r\n                parameters.push(actions);\r\n            } else {\r\n                for (let i = 0; i < parsedAction.properties.length; i++) {\r\n                    let value = parsedAction.properties[i].value;\r\n                    const name = parsedAction.properties[i].name;\r\n                    const targetType = parsedAction.properties[i].targetType;\r\n\r\n                    if (name === \"target\") {\r\n                        if (targetType === \"SceneProperties\") {\r\n                            value = target = scene;\r\n                        } else if (targetType === \"MaterialProperties\") {\r\n                            value = target = scene.getMaterialByName(value);\r\n                        } else {\r\n                            value = target = scene.getNodeByName(value);\r\n                        }\r\n                    } else if (name === \"parent\") {\r\n                        value = scene.getNodeByName(value);\r\n                    } else if (name === \"sound\") {\r\n                        // Can not externalize to component, so only checks for the presence off the API.\r\n                        if (scene.getSoundByName) {\r\n                            value = scene.getSoundByName(value);\r\n                        }\r\n                    } else if (name !== \"propertyPath\") {\r\n                        if (parsedAction.type === 2 && name === \"operator\") {\r\n                            value = (<any>ValueCondition)[value];\r\n                        } else {\r\n                            value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\r\n                        }\r\n                    } else {\r\n                        propertyPath = value;\r\n                    }\r\n\r\n                    parameters.push(value);\r\n                }\r\n            }\r\n\r\n            if (combineArray === null) {\r\n                parameters.push(condition);\r\n            } else {\r\n                parameters.push(null);\r\n            }\r\n\r\n            // If interpolate value action\r\n            if (parsedAction.name === \"InterpolateValueAction\") {\r\n                const param = parameters[parameters.length - 2];\r\n                parameters[parameters.length - 1] = param;\r\n                parameters[parameters.length - 2] = condition;\r\n            }\r\n\r\n            // Action or condition(s) and not CombineAction\r\n            let newAction = instantiate(parsedAction.name, parameters);\r\n\r\n            if (newAction instanceof Condition && condition !== null) {\r\n                const nothing = new DoNothingAction(trigger, condition);\r\n\r\n                if (action) {\r\n                    action.then(nothing);\r\n                } else {\r\n                    actionManager.registerAction(nothing);\r\n                }\r\n\r\n                action = nothing;\r\n            }\r\n\r\n            if (combineArray === null) {\r\n                if (newAction instanceof Condition) {\r\n                    condition = newAction;\r\n                    newAction = action;\r\n                } else {\r\n                    condition = null;\r\n                    if (action) {\r\n                        action.then(newAction);\r\n                    } else {\r\n                        actionManager.registerAction(newAction);\r\n                    }\r\n                }\r\n            } else {\r\n                combineArray.push(newAction);\r\n            }\r\n\r\n            for (let i = 0; i < parsedAction.children.length; i++) {\r\n                traverse(parsedAction.children[i], trigger, condition, newAction, null);\r\n            }\r\n        };\r\n\r\n        // triggers\r\n        for (let i = 0; i < parsedActions.children.length; i++) {\r\n            let triggerParams: any;\r\n            const trigger = parsedActions.children[i];\r\n\r\n            if (trigger.properties.length > 0) {\r\n                const param = trigger.properties[0].value;\r\n                const value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\r\n\r\n                if (value._meshId) {\r\n                    value.mesh = scene.getMeshById(value._meshId);\r\n                }\r\n\r\n                triggerParams = { trigger: (<any>ActionManager)[trigger.name], parameter: value };\r\n            } else {\r\n                triggerParams = (<any>ActionManager)[trigger.name];\r\n            }\r\n\r\n            for (let j = 0; j < trigger.children.length; j++) {\r\n                if (!trigger.detached) {\r\n                    traverse(trigger.children[j], triggerParams, null, null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a trigger name by index\r\n     * @param trigger defines the trigger index\r\n     * @returns a trigger name\r\n     */\r\n    public static GetTriggerName(trigger: number): string {\r\n        switch (trigger) {\r\n            case Constants.ACTION_NothingTrigger:\r\n                return \"NothingTrigger\";\r\n            case Constants.ACTION_OnPickTrigger:\r\n                return \"OnPickTrigger\";\r\n            case Constants.ACTION_OnLeftPickTrigger:\r\n                return \"OnLeftPickTrigger\";\r\n            case Constants.ACTION_OnRightPickTrigger:\r\n                return \"OnRightPickTrigger\";\r\n            case Constants.ACTION_OnCenterPickTrigger:\r\n                return \"OnCenterPickTrigger\";\r\n            case Constants.ACTION_OnPickDownTrigger:\r\n                return \"OnPickDownTrigger\";\r\n            case Constants.ACTION_OnDoublePickTrigger:\r\n                return \"OnDoublePickTrigger\"; // start;\r\n            case Constants.ACTION_OnPickUpTrigger:\r\n                return \"OnPickUpTrigger\";\r\n            case Constants.ACTION_OnLongPressTrigger:\r\n                return \"OnLongPressTrigger\";\r\n            case Constants.ACTION_OnPointerOverTrigger:\r\n                return \"OnPointerOverTrigger\";\r\n            case Constants.ACTION_OnPointerOutTrigger:\r\n                return \"OnPointerOutTrigger\";\r\n            case Constants.ACTION_OnEveryFrameTrigger:\r\n                return \"OnEveryFrameTrigger\";\r\n            case Constants.ACTION_OnIntersectionEnterTrigger:\r\n                return \"OnIntersectionEnterTrigger\";\r\n            case Constants.ACTION_OnIntersectionExitTrigger:\r\n                return \"OnIntersectionExitTrigger\";\r\n            case Constants.ACTION_OnKeyDownTrigger:\r\n                return \"OnKeyDownTrigger\";\r\n            case Constants.ACTION_OnKeyUpTrigger:\r\n                return \"OnKeyUpTrigger\";\r\n            case Constants.ACTION_OnPickOutTrigger:\r\n                return \"OnPickOutTrigger\";\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}