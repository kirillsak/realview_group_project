{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { BoxParticleEmitter, HemisphericParticleEmitter, SphereParticleEmitter, SphereDirectedParticleEmitter, CylinderParticleEmitter, ConeParticleEmitter, PointParticleEmitter, MeshParticleEmitter, CylinderDirectedParticleEmitter } from \"../Particles/EmitterTypes/index.js\";\nimport { BaseParticleSystem } from \"./baseParticleSystem.js\";\nimport { Particle } from \"./particle.js\";\nimport { SubEmitter, SubEmitterType } from \"./subEmitter.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/particles.fragment.js\";\nimport \"../Shaders/particles.vertex.js\";\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport \"../Engines/Extensions/engine.alpha.js\";\nimport { addClipPlaneUniforms, prepareDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a particle system in Babylon.\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n */\nexport class ParticleSystem extends BaseParticleSystem {\n  /**\n   * Instantiates a particle system.\n   * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\n   * @param name The name of the particle system\n   * @param capacity The max number of particles alive at the same time\n   * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\n   * @param customEffect a custom effect used to change the way particles are rendered by default\n   * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\n   * @param epsilon Offset used to render the particles\n   */\n  constructor(name, capacity, sceneOrEngine, customEffect = null, isAnimationSheetEnabled = false, epsilon = 0.01) {\n    super(name);\n    this._emitterInverseWorldMatrix = Matrix.Identity();\n    /**\n     * @internal\n     */\n    this._inheritedVelocityOffset = new Vector3();\n    /**\n     * An event triggered when the system is disposed\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered when the system is stopped\n     */\n    this.onStoppedObservable = new Observable();\n    this._particles = new Array();\n    this._stockParticles = new Array();\n    this._newPartsExcess = 0;\n    this._vertexBuffers = {};\n    this._scaledColorStep = new Color4(0, 0, 0, 0);\n    this._colorDiff = new Color4(0, 0, 0, 0);\n    this._scaledDirection = Vector3.Zero();\n    this._scaledGravity = Vector3.Zero();\n    this._currentRenderId = -1;\n    this._useInstancing = false;\n    this._started = false;\n    this._stopped = false;\n    this._actualFrame = 0;\n    /** @internal */\n    this._currentEmitRate1 = 0;\n    /** @internal */\n    this._currentEmitRate2 = 0;\n    /** @internal */\n    this._currentStartSize1 = 0;\n    /** @internal */\n    this._currentStartSize2 = 0;\n    /** Indicates that the update of particles is done in the animate function */\n    this.updateInAnimate = true;\n    this._rawTextureWidth = 256;\n    this._useRampGradients = false;\n    /**\n     * @internal\n     * If the particle systems emitter should be disposed when the particle system is disposed\n     */\n    this._disposeEmitterOnDispose = false;\n    /**\n     * Specifies if the particles are updated in emitter local space or world space\n     */\n    this.isLocal = false;\n    /** Indicates that the particle system is CPU based */\n    this.isGPU = false;\n    /** @internal */\n    this._onBeforeDrawParticlesObservable = null;\n    // start of sub system methods\n    /**\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\n     * Its lifetime will start back at 0.\n     * @param particle\n     */\n    this.recycleParticle = particle => {\n      // move particle from activeParticle list to stock particles\n      const lastParticle = this._particles.pop();\n      if (lastParticle !== particle) {\n        lastParticle.copyTo(particle);\n      }\n      this._stockParticles.push(lastParticle);\n    };\n    this._createParticle = () => {\n      let particle;\n      if (this._stockParticles.length !== 0) {\n        particle = this._stockParticles.pop();\n        particle._reset();\n      } else {\n        particle = new Particle(this);\n      }\n      // Attach emitters\n      if (this._subEmitters && this._subEmitters.length > 0) {\n        const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\n        particle._attachedSubEmitters = [];\n        subEmitters.forEach(subEmitter => {\n          if (subEmitter.type === SubEmitterType.ATTACHED) {\n            const newEmitter = subEmitter.clone();\n            particle._attachedSubEmitters.push(newEmitter);\n            newEmitter.particleSystem.start();\n          }\n        });\n      }\n      return particle;\n    };\n    this._emitFromParticle = particle => {\n      if (!this._subEmitters || this._subEmitters.length === 0) {\n        return;\n      }\n      const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\n      this._subEmitters[templateIndex].forEach(subEmitter => {\n        if (subEmitter.type === SubEmitterType.END) {\n          const subSystem = subEmitter.clone();\n          particle._inheritParticleInfoToSubEmitter(subSystem);\n          subSystem.particleSystem._rootParticleSystem = this;\n          this.activeSubSystems.push(subSystem.particleSystem);\n          subSystem.particleSystem.start();\n        }\n      });\n    };\n    this._capacity = capacity;\n    this._epsilon = epsilon;\n    this._isAnimationSheetEnabled = isAnimationSheetEnabled;\n    if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\n      this._scene = sceneOrEngine || EngineStore.LastCreatedScene;\n      this._engine = this._scene.getEngine();\n      this.uniqueId = this._scene.getUniqueId();\n      this._scene.particleSystems.push(this);\n    } else {\n      this._engine = sceneOrEngine;\n      this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\n    }\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this._customWrappers = {\n      0: new DrawWrapper(this._engine)\n    };\n    this._customWrappers[0].effect = customEffect;\n    this._drawWrappers = [];\n    this._useInstancing = this._engine.getCaps().instancedArrays;\n    this._createIndexBuffer();\n    this._createVertexBuffers();\n    // Default emitter type\n    this.particleEmitterType = new BoxParticleEmitter();\n    let noiseTextureData = null;\n    // Update\n    this.updateFunction = particles => {\n      var _a;\n      let noiseTextureSize = null;\n      if (this.noiseTexture) {\n        // We need to get texture data back to CPU\n        noiseTextureSize = this.noiseTexture.getSize();\n        (_a = this.noiseTexture.getContent()) === null || _a === void 0 ? void 0 : _a.then(data => {\n          noiseTextureData = data;\n        });\n      }\n      for (let index = 0; index < particles.length; index++) {\n        const particle = particles[index];\n        let scaledUpdateSpeed = this._scaledUpdateSpeed;\n        const previousAge = particle.age;\n        particle.age += scaledUpdateSpeed;\n        // Evaluate step to death\n        if (particle.age > particle.lifeTime) {\n          const diff = particle.age - previousAge;\n          const oldDiff = particle.lifeTime - previousAge;\n          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;\n          particle.age = particle.lifeTime;\n        }\n        const ratio = particle.age / particle.lifeTime;\n        // Color\n        if (this._colorGradients && this._colorGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentColorGradient) {\n              particle._currentColor1.copyFrom(particle._currentColor2);\n              nextGradient.getColorToRef(particle._currentColor2);\n              particle._currentColorGradient = currentGradient;\n            }\n            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\n          });\n        } else {\n          particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\n          particle.color.addInPlace(this._scaledColorStep);\n          if (particle.color.a < 0) {\n            particle.color.a = 0;\n          }\n        }\n        // Angular speed\n        if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentAngularSpeedGradient) {\n              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\n              particle._currentAngularSpeed2 = nextGradient.getFactor();\n              particle._currentAngularSpeedGradient = currentGradient;\n            }\n            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\n          });\n        }\n        particle.angle += particle.angularSpeed * scaledUpdateSpeed;\n        // Direction\n        let directionScale = scaledUpdateSpeed;\n        /// Velocity\n        if (this._velocityGradients && this._velocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentVelocityGradient) {\n              particle._currentVelocity1 = particle._currentVelocity2;\n              particle._currentVelocity2 = nextGradient.getFactor();\n              particle._currentVelocityGradient = currentGradient;\n            }\n            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\n          });\n        }\n        particle.direction.scaleToRef(directionScale, this._scaledDirection);\n        /// Limit velocity\n        if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentLimitVelocityGradient) {\n              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\n              particle._currentLimitVelocity2 = nextGradient.getFactor();\n              particle._currentLimitVelocityGradient = currentGradient;\n            }\n            const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\n            const currentVelocity = particle.direction.length();\n            if (currentVelocity > limitVelocity) {\n              particle.direction.scaleInPlace(this.limitVelocityDamping);\n            }\n          });\n        }\n        /// Drag\n        if (this._dragGradients && this._dragGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentDragGradient) {\n              particle._currentDrag1 = particle._currentDrag2;\n              particle._currentDrag2 = nextGradient.getFactor();\n              particle._currentDragGradient = currentGradient;\n            }\n            const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\n            this._scaledDirection.scaleInPlace(1.0 - drag);\n          });\n        }\n        if (this.isLocal && particle._localPosition) {\n          particle._localPosition.addInPlace(this._scaledDirection);\n          Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n        } else {\n          particle.position.addInPlace(this._scaledDirection);\n        }\n        // Noise\n        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\n          const fetchedColorR = this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const fetchedColorG = this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const fetchedColorB = this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);\n          const force = TmpVectors.Vector3[0];\n          const scaledForce = TmpVectors.Vector3[1];\n          force.copyFromFloats((2 * fetchedColorR - 1) * this.noiseStrength.x, (2 * fetchedColorG - 1) * this.noiseStrength.y, (2 * fetchedColorB - 1) * this.noiseStrength.z);\n          force.scaleToRef(scaledUpdateSpeed, scaledForce);\n          particle.direction.addInPlace(scaledForce);\n        }\n        // Gravity\n        this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\n        particle.direction.addInPlace(this._scaledGravity);\n        // Size\n        if (this._sizeGradients && this._sizeGradients.length > 0) {\n          GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\n            if (currentGradient !== particle._currentSizeGradient) {\n              particle._currentSize1 = particle._currentSize2;\n              particle._currentSize2 = nextGradient.getFactor();\n              particle._currentSizeGradient = currentGradient;\n            }\n            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\n          });\n        }\n        // Remap data\n        if (this._useRampGradients) {\n          if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\n              const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.x = min;\n              particle.remapData.y = max - min;\n            });\n          }\n          if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\n            GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\n              const min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);\n              const max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);\n              particle.remapData.z = min;\n              particle.remapData.w = max - min;\n            });\n          }\n        }\n        if (this._isAnimationSheetEnabled) {\n          particle.updateCellIndex();\n        }\n        // Update the position of the attached sub-emitters to match their attached particle\n        particle._inheritParticleInfoToSubEmitters();\n        if (particle.age >= particle.lifeTime) {\n          // Recycle by swapping with last particle\n          this._emitFromParticle(particle);\n          if (particle._attachedSubEmitters) {\n            particle._attachedSubEmitters.forEach(subEmitter => {\n              subEmitter.particleSystem.disposeOnStop = true;\n              subEmitter.particleSystem.stop();\n            });\n            particle._attachedSubEmitters = null;\n          }\n          this.recycleParticle(particle);\n          index--;\n          continue;\n        }\n      }\n    };\n  }\n  /**\n   * Sets a callback that will be triggered when the system is disposed\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /** Gets or sets a boolean indicating that ramp gradients must be used\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\n   */\n  get useRampGradients() {\n    return this._useRampGradients;\n  }\n  set useRampGradients(value) {\n    if (this._useRampGradients === value) {\n      return;\n    }\n    this._useRampGradients = value;\n    this._resetEffect();\n  }\n  //end of Sub-emitter\n  /**\n   * Gets the current list of active particles\n   */\n  get particles() {\n    return this._particles;\n  }\n  /**\n   * Gets the number of particles active at the same time.\n   * @returns The number of active particles.\n   */\n  getActiveCount() {\n    return this._particles.length;\n  }\n  /**\n   * Returns the string \"ParticleSystem\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"ParticleSystem\";\n  }\n  /**\n   * Gets a boolean indicating that the system is stopping\n   * @returns true if the system is currently stopping\n   */\n  isStopping() {\n    return this._stopped && this.isAlive();\n  }\n  /**\n   * Gets the custom effect used to render the particles\n   * @param blendMode Blend mode for which the effect should be retrieved\n   * @returns The effect\n   */\n  getCustomEffect(blendMode = 0) {\n    var _a, _b;\n    return (_b = (_a = this._customWrappers[blendMode]) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : this._customWrappers[0].effect;\n  }\n  _getCustomDrawWrapper(blendMode = 0) {\n    var _a;\n    return (_a = this._customWrappers[blendMode]) !== null && _a !== void 0 ? _a : this._customWrappers[0];\n  }\n  /**\n   * Sets the custom effect used to render the particles\n   * @param effect The effect to set\n   * @param blendMode Blend mode for which the effect should be set\n   */\n  setCustomEffect(effect, blendMode = 0) {\n    this._customWrappers[blendMode] = new DrawWrapper(this._engine);\n    this._customWrappers[blendMode].effect = effect;\n    if (this._customWrappers[blendMode].drawContext) {\n      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;\n    }\n  }\n  /**\n   * Observable that will be called just before the particles are drawn\n   */\n  get onBeforeDrawParticlesObservable() {\n    if (!this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable = new Observable();\n    }\n    return this._onBeforeDrawParticlesObservable;\n  }\n  /**\n   * Gets the name of the particle vertex shader\n   */\n  get vertexShaderName() {\n    return \"particles\";\n  }\n  /**\n   * Gets the vertex buffers used by the particle system\n   */\n  get vertexBuffers() {\n    return this._vertexBuffers;\n  }\n  /**\n   * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\n   */\n  get indexBuffer() {\n    return this._indexBuffer;\n  }\n  _addFactorGradient(factorGradients, gradient, factor, factor2) {\n    const newGradient = new FactorGradient(gradient, factor, factor2);\n    factorGradients.push(newGradient);\n    factorGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  _removeFactorGradient(factorGradients, gradient) {\n    if (!factorGradients) {\n      return;\n    }\n    let index = 0;\n    for (const factorGradient of factorGradients) {\n      if (factorGradient.gradient === gradient) {\n        factorGradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n  }\n  /**\n   * Adds a new life time gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the life time factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addLifeTimeGradient(gradient, factor, factor2) {\n    if (!this._lifeTimeGradients) {\n      this._lifeTimeGradients = [];\n    }\n    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific life time gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLifeTimeGradient(gradient) {\n    this._removeFactorGradient(this._lifeTimeGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new size gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the size factor to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addSizeGradient(gradient, factor, factor2) {\n    if (!this._sizeGradients) {\n      this._sizeGradients = [];\n    }\n    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeSizeGradient(gradient) {\n    this._removeFactorGradient(this._sizeGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new color remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the color remap minimal range\n   * @param max defines the color remap maximal range\n   * @returns the current particle system\n   */\n  addColorRemapGradient(gradient, min, max) {\n    if (!this._colorRemapGradients) {\n      this._colorRemapGradients = [];\n    }\n    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\n    return this;\n  }\n  /**\n   * Remove a specific color remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeColorRemapGradient(gradient) {\n    this._removeFactorGradient(this._colorRemapGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new alpha remap gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param min defines the alpha remap minimal range\n   * @param max defines the alpha remap maximal range\n   * @returns the current particle system\n   */\n  addAlphaRemapGradient(gradient, min, max) {\n    if (!this._alphaRemapGradients) {\n      this._alphaRemapGradients = [];\n    }\n    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\n    return this;\n  }\n  /**\n   * Remove a specific alpha remap gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAlphaRemapGradient(gradient) {\n    this._removeFactorGradient(this._alphaRemapGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new angular speed gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the angular speed  to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addAngularSpeedGradient(gradient, factor, factor2) {\n    if (!this._angularSpeedGradients) {\n      this._angularSpeedGradients = [];\n    }\n    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific angular speed gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeAngularSpeedGradient(gradient) {\n    this._removeFactorGradient(this._angularSpeedGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the velocity to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addVelocityGradient(gradient, factor, factor2) {\n    if (!this._velocityGradients) {\n      this._velocityGradients = [];\n    }\n    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeVelocityGradient(gradient) {\n    this._removeFactorGradient(this._velocityGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new limit velocity gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the limit velocity value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addLimitVelocityGradient(gradient, factor, factor2) {\n    if (!this._limitVelocityGradients) {\n      this._limitVelocityGradients = [];\n    }\n    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific limit velocity gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeLimitVelocityGradient(gradient) {\n    this._removeFactorGradient(this._limitVelocityGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new drag gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the drag value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addDragGradient(gradient, factor, factor2) {\n    if (!this._dragGradients) {\n      this._dragGradients = [];\n    }\n    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific drag gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeDragGradient(gradient) {\n    this._removeFactorGradient(this._dragGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the emit rate value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addEmitRateGradient(gradient, factor, factor2) {\n    if (!this._emitRateGradients) {\n      this._emitRateGradients = [];\n    }\n    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific emit rate gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeEmitRateGradient(gradient) {\n    this._removeFactorGradient(this._emitRateGradients, gradient);\n    return this;\n  }\n  /**\n   * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param factor defines the start size value to affect to the specified gradient\n   * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\n   * @returns the current particle system\n   */\n  addStartSizeGradient(gradient, factor, factor2) {\n    if (!this._startSizeGradients) {\n      this._startSizeGradients = [];\n    }\n    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\n    return this;\n  }\n  /**\n   * Remove a specific start size gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeStartSizeGradient(gradient) {\n    this._removeFactorGradient(this._startSizeGradients, gradient);\n    return this;\n  }\n  _createRampGradientTexture() {\n    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\n      return;\n    }\n    const data = new Uint8Array(this._rawTextureWidth * 4);\n    const tmpColor = TmpColors.Color3[0];\n    for (let x = 0; x < this._rawTextureWidth; x++) {\n      const ratio = x / this._rawTextureWidth;\n      GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\n        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);\n        data[x * 4] = tmpColor.r * 255;\n        data[x * 4 + 1] = tmpColor.g * 255;\n        data[x * 4 + 2] = tmpColor.b * 255;\n        data[x * 4 + 3] = 255;\n      });\n    }\n    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);\n  }\n  /**\n   * Gets the current list of ramp gradients.\n   * You must use addRampGradient and removeRampGradient to update this list\n   * @returns the list of ramp gradients\n   */\n  getRampGradients() {\n    return this._rampGradients;\n  }\n  /** Force the system to rebuild all gradients that need to be resync */\n  forceRefreshGradients() {\n    this._syncRampGradientTexture();\n  }\n  _syncRampGradientTexture() {\n    if (!this._rampGradients) {\n      return;\n    }\n    this._rampGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n      this._rampGradientsTexture = null;\n    }\n    this._createRampGradientTexture();\n  }\n  /**\n   * Adds a new ramp gradient used to remap particle colors\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color defines the color to affect to the specified gradient\n   * @returns the current particle system\n   */\n  addRampGradient(gradient, color) {\n    if (!this._rampGradients) {\n      this._rampGradients = [];\n    }\n    const rampGradient = new Color3Gradient(gradient, color);\n    this._rampGradients.push(rampGradient);\n    this._syncRampGradientTexture();\n    return this;\n  }\n  /**\n   * Remove a specific ramp gradient\n   * @param gradient defines the gradient to remove\n   * @returns the current particle system\n   */\n  removeRampGradient(gradient) {\n    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\n    this._rampGradientsTexture = null;\n    if (this._rampGradients && this._rampGradients.length > 0) {\n      this._createRampGradientTexture();\n    }\n    return this;\n  }\n  /**\n   * Adds a new color gradient\n   * @param gradient defines the gradient to use (between 0 and 1)\n   * @param color1 defines the color to affect to the specified gradient\n   * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\n   * @returns this particle system\n   */\n  addColorGradient(gradient, color1, color2) {\n    if (!this._colorGradients) {\n      this._colorGradients = [];\n    }\n    const colorGradient = new ColorGradient(gradient, color1, color2);\n    this._colorGradients.push(colorGradient);\n    this._colorGradients.sort((a, b) => {\n      if (a.gradient < b.gradient) {\n        return -1;\n      } else if (a.gradient > b.gradient) {\n        return 1;\n      }\n      return 0;\n    });\n    return this;\n  }\n  /**\n   * Remove a specific color gradient\n   * @param gradient defines the gradient to remove\n   * @returns this particle system\n   */\n  removeColorGradient(gradient) {\n    if (!this._colorGradients) {\n      return this;\n    }\n    let index = 0;\n    for (const colorGradient of this._colorGradients) {\n      if (colorGradient.gradient === gradient) {\n        this._colorGradients.splice(index, 1);\n        break;\n      }\n      index++;\n    }\n    return this;\n  }\n  /**\n   * Resets the draw wrappers cache\n   */\n  resetDrawCache() {\n    for (const drawWrappers of this._drawWrappers) {\n      if (drawWrappers) {\n        for (const drawWrapper of drawWrappers) {\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n    this._drawWrappers = [];\n  }\n  _fetchR(u, v, width, height, pixels) {\n    u = Math.abs(u) * 0.5 + 0.5;\n    v = Math.abs(v) * 0.5 + 0.5;\n    const wrappedU = u * width % width | 0;\n    const wrappedV = v * height % height | 0;\n    const position = (wrappedU + wrappedV * width) * 4;\n    return pixels[position] / 255;\n  }\n  _reset() {\n    this._resetEffect();\n  }\n  _resetEffect() {\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n      this._vertexBuffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    this._createVertexBuffers();\n  }\n  _createVertexBuffers() {\n    this._vertexBufferSize = this._useInstancing ? 10 : 12;\n    if (this._isAnimationSheetEnabled) {\n      this._vertexBufferSize += 1;\n    }\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n      this._vertexBufferSize += 3;\n    }\n    if (this._useRampGradients) {\n      this._vertexBufferSize += 4;\n    }\n    const engine = this._engine;\n    const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\n    this._vertexData = new Float32Array(this._capacity * vertexSize);\n    this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\n    let dataOffset = 0;\n    const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.PositionKind] = positions;\n    dataOffset += 3;\n    const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[VertexBuffer.ColorKind] = colors;\n    dataOffset += 4;\n    const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[\"angle\"] = options;\n    dataOffset += 1;\n    const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n    this._vertexBuffers[\"size\"] = size;\n    dataOffset += 2;\n    if (this._isAnimationSheetEnabled) {\n      const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\n      dataOffset += 1;\n    }\n    if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n      const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"direction\"] = directionBuffer;\n      dataOffset += 3;\n    }\n    if (this._useRampGradients) {\n      const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\n      this._vertexBuffers[\"remapData\"] = rampDataBuffer;\n      dataOffset += 4;\n    }\n    let offsets;\n    if (this._useInstancing) {\n      const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n      this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\n      offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\n    } else {\n      offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\n      dataOffset += 2;\n    }\n    this._vertexBuffers[\"offset\"] = offsets;\n    this.resetDrawCache();\n  }\n  _createIndexBuffer() {\n    if (this._useInstancing) {\n      return;\n    }\n    const indices = [];\n    let index = 0;\n    for (let count = 0; count < this._capacity; count++) {\n      indices.push(index);\n      indices.push(index + 1);\n      indices.push(index + 2);\n      indices.push(index);\n      indices.push(index + 2);\n      indices.push(index + 3);\n      index += 4;\n    }\n    this._indexBuffer = this._engine.createIndexBuffer(indices);\n  }\n  /**\n   * Gets the maximum number of particles active at the same time.\n   * @returns The max number of active particles.\n   */\n  getCapacity() {\n    return this._capacity;\n  }\n  /**\n   * Gets whether there are still active particles in the system.\n   * @returns True if it is alive, otherwise false.\n   */\n  isAlive() {\n    return this._alive;\n  }\n  /**\n   * Gets if the system has been started. (Note: this will still be true after stop is called)\n   * @returns True if it has been started, otherwise false.\n   */\n  isStarted() {\n    return this._started;\n  }\n  _prepareSubEmitterInternalArray() {\n    this._subEmitters = new Array();\n    if (this.subEmitters) {\n      this.subEmitters.forEach(subEmitter => {\n        if (subEmitter instanceof ParticleSystem) {\n          this._subEmitters.push([new SubEmitter(subEmitter)]);\n        } else if (subEmitter instanceof SubEmitter) {\n          this._subEmitters.push([subEmitter]);\n        } else if (subEmitter instanceof Array) {\n          this._subEmitters.push(subEmitter);\n        }\n      });\n    }\n  }\n  /**\n   * Starts the particle system and begins to emit\n   * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\n   */\n  start(delay = this.startDelay) {\n    var _a;\n    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\n      throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\n    }\n    if (delay) {\n      setTimeout(() => {\n        this.start(0);\n      }, delay);\n      return;\n    }\n    // Convert the subEmitters field to the constant type field _subEmitters\n    this._prepareSubEmitterInternalArray();\n    this._started = true;\n    this._stopped = false;\n    this._actualFrame = 0;\n    if (this._subEmitters && this._subEmitters.length != 0) {\n      this.activeSubSystems = new Array();\n    }\n    // Reset emit gradient so it acts the same on every start\n    if (this._emitRateGradients) {\n      if (this._emitRateGradients.length > 0) {\n        this._currentEmitRateGradient = this._emitRateGradients[0];\n        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\n        this._currentEmitRate2 = this._currentEmitRate1;\n      }\n      if (this._emitRateGradients.length > 1) {\n        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\n      }\n    }\n    // Reset start size gradient so it acts the same on every start\n    if (this._startSizeGradients) {\n      if (this._startSizeGradients.length > 0) {\n        this._currentStartSizeGradient = this._startSizeGradients[0];\n        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\n        this._currentStartSize2 = this._currentStartSize1;\n      }\n      if (this._startSizeGradients.length > 1) {\n        this._currentStartSize2 = this._startSizeGradients[1].getFactor();\n      }\n    }\n    if (this.preWarmCycles) {\n      if (((_a = this.emitter) === null || _a === void 0 ? void 0 : _a.getClassName().indexOf(\"Mesh\")) !== -1) {\n        this.emitter.computeWorldMatrix(true);\n      }\n      const noiseTextureAsProcedural = this.noiseTexture;\n      if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\n        noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\n          setTimeout(() => {\n            for (let index = 0; index < this.preWarmCycles; index++) {\n              this.animate(true);\n              noiseTextureAsProcedural.render();\n            }\n          });\n        });\n      } else {\n        for (let index = 0; index < this.preWarmCycles; index++) {\n          this.animate(true);\n        }\n      }\n    }\n    // Animations\n    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\n      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\n    }\n  }\n  /**\n   * Stops the particle system.\n   * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\n   */\n  stop(stopSubEmitters = true) {\n    if (this._stopped) {\n      return;\n    }\n    this.onStoppedObservable.notifyObservers(this);\n    this._stopped = true;\n    if (stopSubEmitters) {\n      this._stopSubEmitters();\n    }\n  }\n  // animation sheet\n  /**\n   * Remove all active particles\n   */\n  reset() {\n    this._stockParticles.length = 0;\n    this._particles.length = 0;\n  }\n  /**\n   * @internal (for internal use only)\n   */\n  _appendParticleVertex(index, particle, offsetX, offsetY) {\n    let offset = index * this._vertexBufferSize;\n    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\n    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\n    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\n    this._vertexData[offset++] = particle.color.r;\n    this._vertexData[offset++] = particle.color.g;\n    this._vertexData[offset++] = particle.color.b;\n    this._vertexData[offset++] = particle.color.a;\n    this._vertexData[offset++] = particle.angle;\n    this._vertexData[offset++] = particle.scale.x * particle.size;\n    this._vertexData[offset++] = particle.scale.y * particle.size;\n    if (this._isAnimationSheetEnabled) {\n      this._vertexData[offset++] = particle.cellIndex;\n    }\n    if (!this._isBillboardBased) {\n      if (particle._initialDirection) {\n        let initialDirection = particle._initialDirection;\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          initialDirection = TmpVectors.Vector3[0];\n        }\n        if (initialDirection.x === 0 && initialDirection.z === 0) {\n          initialDirection.x = 0.001;\n        }\n        this._vertexData[offset++] = initialDirection.x;\n        this._vertexData[offset++] = initialDirection.y;\n        this._vertexData[offset++] = initialDirection.z;\n      } else {\n        let direction = particle.direction;\n        if (this.isLocal) {\n          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\n          direction = TmpVectors.Vector3[0];\n        }\n        if (direction.x === 0 && direction.z === 0) {\n          direction.x = 0.001;\n        }\n        this._vertexData[offset++] = direction.x;\n        this._vertexData[offset++] = direction.y;\n        this._vertexData[offset++] = direction.z;\n      }\n    } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n      this._vertexData[offset++] = particle.direction.x;\n      this._vertexData[offset++] = particle.direction.y;\n      this._vertexData[offset++] = particle.direction.z;\n    }\n    if (this._useRampGradients && particle.remapData) {\n      this._vertexData[offset++] = particle.remapData.x;\n      this._vertexData[offset++] = particle.remapData.y;\n      this._vertexData[offset++] = particle.remapData.z;\n      this._vertexData[offset++] = particle.remapData.w;\n    }\n    if (!this._useInstancing) {\n      if (this._isAnimationSheetEnabled) {\n        if (offsetX === 0) {\n          offsetX = this._epsilon;\n        } else if (offsetX === 1) {\n          offsetX = 1 - this._epsilon;\n        }\n        if (offsetY === 0) {\n          offsetY = this._epsilon;\n        } else if (offsetY === 1) {\n          offsetY = 1 - this._epsilon;\n        }\n      }\n      this._vertexData[offset++] = offsetX;\n      this._vertexData[offset++] = offsetY;\n    }\n  }\n  _stopSubEmitters() {\n    if (!this.activeSubSystems) {\n      return;\n    }\n    this.activeSubSystems.forEach(subSystem => {\n      subSystem.stop(true);\n    });\n    this.activeSubSystems = new Array();\n  }\n  _removeFromRoot() {\n    if (!this._rootParticleSystem) {\n      return;\n    }\n    const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\n    if (index !== -1) {\n      this._rootParticleSystem.activeSubSystems.splice(index, 1);\n    }\n    this._rootParticleSystem = null;\n  }\n  // End of sub system methods\n  _update(newParticles) {\n    // Update current\n    this._alive = this._particles.length > 0;\n    if (this.emitter.position) {\n      const emitterMesh = this.emitter;\n      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\n    } else {\n      const emitterPosition = this.emitter;\n      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\n    }\n    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\n    this.updateFunction(this._particles);\n    // Add new ones\n    let particle;\n    for (let index = 0; index < newParticles; index++) {\n      if (this._particles.length === this._capacity) {\n        break;\n      }\n      particle = this._createParticle();\n      this._particles.push(particle);\n      // Life time\n      if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\n        const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\n        GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\n          const factorGradient1 = currentGradient;\n          const factorGradient2 = nextGradient;\n          const lifeTime1 = factorGradient1.getFactor();\n          const lifeTime2 = factorGradient2.getFactor();\n          const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\n          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\n        });\n      } else {\n        particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\n      }\n      // Emitter\n      const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\n      if (this.startPositionFunction) {\n        this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n      } else {\n        this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\n      }\n      if (this.isLocal) {\n        if (!particle._localPosition) {\n          particle._localPosition = particle.position.clone();\n        } else {\n          particle._localPosition.copyFrom(particle.position);\n        }\n        Vector3.TransformCoordinatesToRef(particle._localPosition, this._emitterWorldMatrix, particle.position);\n      }\n      if (this.startDirectionFunction) {\n        this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\n      } else {\n        this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\n      }\n      if (emitPower === 0) {\n        if (!particle._initialDirection) {\n          particle._initialDirection = particle.direction.clone();\n        } else {\n          particle._initialDirection.copyFrom(particle.direction);\n        }\n      } else {\n        particle._initialDirection = null;\n      }\n      particle.direction.scaleInPlace(emitPower);\n      // Size\n      if (!this._sizeGradients || this._sizeGradients.length === 0) {\n        particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\n      } else {\n        particle._currentSizeGradient = this._sizeGradients[0];\n        particle._currentSize1 = particle._currentSizeGradient.getFactor();\n        particle.size = particle._currentSize1;\n        if (this._sizeGradients.length > 1) {\n          particle._currentSize2 = this._sizeGradients[1].getFactor();\n        } else {\n          particle._currentSize2 = particle._currentSize1;\n        }\n      }\n      // Size and scale\n      particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\n      // Adjust scale by start size\n      if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\n        const ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\n          if (currentGradient !== this._currentStartSizeGradient) {\n            this._currentStartSize1 = this._currentStartSize2;\n            this._currentStartSize2 = nextGradient.getFactor();\n            this._currentStartSizeGradient = currentGradient;\n          }\n          const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\n          particle.scale.scaleInPlace(value);\n        });\n      }\n      // Angle\n      if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\n        particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\n      } else {\n        particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\n        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\n        particle._currentAngularSpeed1 = particle.angularSpeed;\n        if (this._angularSpeedGradients.length > 1) {\n          particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\n        } else {\n          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\n        }\n      }\n      particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\n      // Velocity\n      if (this._velocityGradients && this._velocityGradients.length > 0) {\n        particle._currentVelocityGradient = this._velocityGradients[0];\n        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\n        if (this._velocityGradients.length > 1) {\n          particle._currentVelocity2 = this._velocityGradients[1].getFactor();\n        } else {\n          particle._currentVelocity2 = particle._currentVelocity1;\n        }\n      }\n      // Limit velocity\n      if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\n        particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\n        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\n        if (this._limitVelocityGradients.length > 1) {\n          particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\n        } else {\n          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\n        }\n      }\n      // Drag\n      if (this._dragGradients && this._dragGradients.length > 0) {\n        particle._currentDragGradient = this._dragGradients[0];\n        particle._currentDrag1 = particle._currentDragGradient.getFactor();\n        if (this._dragGradients.length > 1) {\n          particle._currentDrag2 = this._dragGradients[1].getFactor();\n        } else {\n          particle._currentDrag2 = particle._currentDrag1;\n        }\n      }\n      // Color\n      if (!this._colorGradients || this._colorGradients.length === 0) {\n        const step = Scalar.RandomRange(0, 1.0);\n        Color4.LerpToRef(this.color1, this.color2, step, particle.color);\n        this.colorDead.subtractToRef(particle.color, this._colorDiff);\n        this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n      } else {\n        particle._currentColorGradient = this._colorGradients[0];\n        particle._currentColorGradient.getColorToRef(particle.color);\n        particle._currentColor1.copyFrom(particle.color);\n        if (this._colorGradients.length > 1) {\n          this._colorGradients[1].getColorToRef(particle._currentColor2);\n        } else {\n          particle._currentColor2.copyFrom(particle.color);\n        }\n      }\n      // Sheet\n      if (this._isAnimationSheetEnabled) {\n        particle._initialStartSpriteCellID = this.startSpriteCellID;\n        particle._initialEndSpriteCellID = this.endSpriteCellID;\n        particle._initialSpriteCellLoop = this.spriteCellLoop;\n      }\n      // Inherited Velocity\n      particle.direction.addInPlace(this._inheritedVelocityOffset);\n      // Ramp\n      if (this._useRampGradients) {\n        particle.remapData = new Vector4(0, 1, 0, 1);\n      }\n      // Noise texture coordinates\n      if (this.noiseTexture) {\n        if (particle._randomNoiseCoordinates1) {\n          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\n        } else {\n          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\n          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\n        }\n      }\n      // Update the position of the attached sub-emitters to match their attached particle\n      particle._inheritParticleInfoToSubEmitters();\n    }\n  }\n  /**\n   * @internal\n   */\n  static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false) {\n    const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\n    if (isAnimationSheetEnabled) {\n      attributeNamesOrOptions.push(\"cellIndex\");\n    }\n    if (!isBillboardBased) {\n      attributeNamesOrOptions.push(\"direction\");\n    }\n    if (useRampGradients) {\n      attributeNamesOrOptions.push(\"remapData\");\n    }\n    return attributeNamesOrOptions;\n  }\n  /**\n   * @internal\n   */\n  static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false) {\n    const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\n    addClipPlaneUniforms(effectCreationOption);\n    if (isAnimationSheetEnabled) {\n      effectCreationOption.push(\"particlesInfos\");\n    }\n    if (useLogarithmicDepth) {\n      effectCreationOption.push(\"logarithmicDepthConstant\");\n    }\n    return effectCreationOption;\n  }\n  /**\n   * Fill the defines array according to the current settings of the particle system\n   * @param defines Array to be updated\n   * @param blendMode blend mode to take into account when updating the array\n   */\n  fillDefines(defines, blendMode) {\n    if (this._scene) {\n      prepareDefinesForClipPlanes(this, this._scene, defines);\n    }\n    if (this._isAnimationSheetEnabled) {\n      defines.push(\"#define ANIMATESHEET\");\n    }\n    if (this.useLogarithmicDepth) {\n      defines.push(\"#define LOGARITHMICDEPTH\");\n    }\n    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\n      defines.push(\"#define BLENDMULTIPLYMODE\");\n    }\n    if (this._useRampGradients) {\n      defines.push(\"#define RAMPGRADIENT\");\n    }\n    if (this._isBillboardBased) {\n      defines.push(\"#define BILLBOARD\");\n      switch (this.billboardMode) {\n        case ParticleSystem.BILLBOARDMODE_Y:\n          defines.push(\"#define BILLBOARDY\");\n          break;\n        case ParticleSystem.BILLBOARDMODE_STRETCHED:\n        case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:\n          defines.push(\"#define BILLBOARDSTRETCHED\");\n          if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\n            defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\n          }\n          break;\n        case ParticleSystem.BILLBOARDMODE_ALL:\n          defines.push(\"#define BILLBOARDMODE_ALL\");\n          break;\n        default:\n          break;\n      }\n    }\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\n      defines.push(this._imageProcessingConfigurationDefines.toString());\n    }\n  }\n  /**\n   * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\n   * @param uniforms Uniforms array to fill\n   * @param attributes Attributes array to fill\n   * @param samplers Samplers array to fill\n   */\n  fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers) {\n    attributes.push(...ParticleSystem._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL, this._useRampGradients));\n    uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\n    samplers.push(\"diffuseSampler\", \"rampSampler\");\n    if (this._imageProcessingConfiguration) {\n      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\n      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\n    }\n  }\n  /**\n   * @internal\n   */\n  _getWrapper(blendMode) {\n    const customWrapper = this._getCustomDrawWrapper(blendMode);\n    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {\n      return customWrapper;\n    }\n    const defines = [];\n    this.fillDefines(defines, blendMode);\n    // Effect\n    const currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;\n    let drawWrappers = this._drawWrappers[currentRenderPassId];\n    if (!drawWrappers) {\n      drawWrappers = this._drawWrappers[currentRenderPassId] = [];\n    }\n    let drawWrapper = drawWrappers[blendMode];\n    if (!drawWrapper) {\n      drawWrapper = new DrawWrapper(this._engine);\n      if (drawWrapper.drawContext) {\n        drawWrapper.drawContext.useInstancing = this._useInstancing;\n      }\n      drawWrappers[blendMode] = drawWrapper;\n    }\n    const join = defines.join(\"\\n\");\n    if (drawWrapper.defines !== join) {\n      const attributesNamesOrOptions = [];\n      const effectCreationOption = [];\n      const samplers = [];\n      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\n      drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\n    }\n    return drawWrapper;\n  }\n  /**\n   * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\n   * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\n   */\n  animate(preWarmOnly = false) {\n    var _a;\n    if (!this._started) {\n      return;\n    }\n    if (!preWarmOnly && this._scene) {\n      // Check\n      if (!this.isReady()) {\n        return;\n      }\n      if (this._currentRenderId === this._scene.getFrameId()) {\n        return;\n      }\n      this._currentRenderId = this._scene.getFrameId();\n    }\n    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getAnimationRatio()) || 1);\n    // Determine the number of particles we need to create\n    let newParticles;\n    if (this.manualEmitCount > -1) {\n      newParticles = this.manualEmitCount;\n      this._newPartsExcess = 0;\n      this.manualEmitCount = 0;\n    } else {\n      let rate = this.emitRate;\n      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\n        const ratio = this._actualFrame / this.targetStopDuration;\n        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\n          if (currentGradient !== this._currentEmitRateGradient) {\n            this._currentEmitRate1 = this._currentEmitRate2;\n            this._currentEmitRate2 = nextGradient.getFactor();\n            this._currentEmitRateGradient = currentGradient;\n          }\n          rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\n        });\n      }\n      newParticles = rate * this._scaledUpdateSpeed >> 0;\n      this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\n    }\n    if (this._newPartsExcess > 1.0) {\n      newParticles += this._newPartsExcess >> 0;\n      this._newPartsExcess -= this._newPartsExcess >> 0;\n    }\n    this._alive = false;\n    if (!this._stopped) {\n      this._actualFrame += this._scaledUpdateSpeed;\n      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\n        this.stop();\n      }\n    } else {\n      newParticles = 0;\n    }\n    this._update(newParticles);\n    // Stopped?\n    if (this._stopped) {\n      if (!this._alive) {\n        this._started = false;\n        if (this.onAnimationEnd) {\n          this.onAnimationEnd();\n        }\n        if (this.disposeOnStop && this._scene) {\n          this._scene._toBeDisposed.push(this);\n        }\n      }\n    }\n    if (!preWarmOnly) {\n      // Update VBO\n      let offset = 0;\n      for (let index = 0; index < this._particles.length; index++) {\n        const particle = this._particles[index];\n        this._appendParticleVertices(offset, particle);\n        offset += this._useInstancing ? 1 : 4;\n      }\n      if (this._vertexBuffer) {\n        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\n      }\n    }\n    if (this.manualEmitCount === 0 && this.disposeOnStop) {\n      this.stop();\n    }\n  }\n  _appendParticleVertices(offset, particle) {\n    this._appendParticleVertex(offset++, particle, 0, 0);\n    if (!this._useInstancing) {\n      this._appendParticleVertex(offset++, particle, 1, 0);\n      this._appendParticleVertex(offset++, particle, 1, 1);\n      this._appendParticleVertex(offset++, particle, 0, 1);\n    }\n  }\n  /**\n   * Rebuilds the particle system.\n   */\n  rebuild() {\n    var _a, _b;\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObject = null;\n    }\n    this._createIndexBuffer();\n    (_a = this._spriteBuffer) === null || _a === void 0 ? void 0 : _a._rebuild();\n    (_b = this._vertexBuffer) === null || _b === void 0 ? void 0 : _b._rebuild();\n    for (const key in this._vertexBuffers) {\n      this._vertexBuffers[key]._rebuild();\n    }\n    this.resetDrawCache();\n  }\n  /**\n   * Is this system ready to be used/rendered\n   * @returns true if the system is ready\n   */\n  isReady() {\n    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {\n      return false;\n    }\n    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      if (!this._getWrapper(this.blendMode).effect.isReady()) {\n        return false;\n      }\n    } else {\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {\n        return false;\n      }\n      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _render(blendMode) {\n    var _a, _b;\n    const drawWrapper = this._getWrapper(blendMode);\n    const effect = drawWrapper.effect;\n    const engine = this._engine;\n    // Render\n    engine.enableEffect(drawWrapper);\n    const viewMatrix = (_a = this.defaultViewMatrix) !== null && _a !== void 0 ? _a : this._scene.getViewMatrix();\n    effect.setTexture(\"diffuseSampler\", this.particleTexture);\n    effect.setMatrix(\"view\", viewMatrix);\n    effect.setMatrix(\"projection\", (_b = this.defaultProjectionMatrix) !== null && _b !== void 0 ? _b : this._scene.getProjectionMatrix());\n    if (this._isAnimationSheetEnabled && this.particleTexture) {\n      const baseSize = this.particleTexture.getBaseSize();\n      effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\n    }\n    effect.setVector2(\"translationPivot\", this.translationPivot);\n    effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n    if (this._isBillboardBased && this._scene) {\n      const camera = this._scene.activeCamera;\n      effect.setVector3(\"eyePosition\", camera.globalPosition);\n    }\n    if (this._rampGradientsTexture) {\n      if (!this._rampGradients || !this._rampGradients.length) {\n        this._rampGradientsTexture.dispose();\n        this._rampGradientsTexture = null;\n      }\n      effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\n    }\n    const defines = effect.defines;\n    if (this._scene) {\n      bindClipPlane(effect, this, this._scene);\n    }\n    if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\n      viewMatrix.invertToRef(TmpVectors.Matrix[0]);\n      effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\n    }\n    if (this._vertexArrayObject !== undefined) {\n      if (!this._vertexArrayObject) {\n        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\n      }\n      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\n    } else {\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n    }\n    // Log. depth\n    if (this.useLogarithmicDepth && this._scene) {\n      MaterialHelper.BindLogDepth(defines, effect, this._scene);\n    }\n    // image processing\n    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\n      this._imageProcessingConfiguration.bind(effect);\n    }\n    // Draw order\n    switch (blendMode) {\n      case ParticleSystem.BLENDMODE_ADD:\n        engine.setAlphaMode(1);\n        break;\n      case ParticleSystem.BLENDMODE_ONEONE:\n        engine.setAlphaMode(6);\n        break;\n      case ParticleSystem.BLENDMODE_STANDARD:\n        engine.setAlphaMode(2);\n        break;\n      case ParticleSystem.BLENDMODE_MULTIPLY:\n        engine.setAlphaMode(4);\n        break;\n    }\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.notifyObservers(effect);\n    }\n    if (this._useInstancing) {\n      engine.drawArraysType(7, 0, 4, this._particles.length);\n    } else {\n      engine.drawElementsType(0, 0, this._particles.length * 6);\n    }\n    return this._particles.length;\n  }\n  /**\n   * Renders the particle system in its current state.\n   * @returns the current number of particles\n   */\n  render() {\n    // Check\n    if (!this.isReady() || !this._particles.length) {\n      return 0;\n    }\n    const engine = this._engine;\n    if (engine.setState) {\n      engine.setState(false);\n      if (this.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      }\n    }\n    let outparticles = 0;\n    if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\n      outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\n    } else {\n      outparticles = this._render(this.blendMode);\n    }\n    this._engine.unbindInstanceAttributes();\n    this._engine.setAlphaMode(0);\n    return outparticles;\n  }\n  /**\n   * Disposes the particle system and free the associated resources\n   * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\n   */\n  dispose(disposeTexture = true) {\n    this.resetDrawCache();\n    if (this._vertexBuffer) {\n      this._vertexBuffer.dispose();\n      this._vertexBuffer = null;\n    }\n    if (this._spriteBuffer) {\n      this._spriteBuffer.dispose();\n      this._spriteBuffer = null;\n    }\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this._vertexArrayObject) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObject);\n      this._vertexArrayObject = null;\n    }\n    if (disposeTexture && this.particleTexture) {\n      this.particleTexture.dispose();\n      this.particleTexture = null;\n    }\n    if (disposeTexture && this.noiseTexture) {\n      this.noiseTexture.dispose();\n      this.noiseTexture = null;\n    }\n    if (this._rampGradientsTexture) {\n      this._rampGradientsTexture.dispose();\n      this._rampGradientsTexture = null;\n    }\n    this._removeFromRoot();\n    if (this.subEmitters && !this._subEmitters) {\n      this._prepareSubEmitterInternalArray();\n    }\n    if (this._subEmitters && this._subEmitters.length) {\n      for (let index = 0; index < this._subEmitters.length; index++) {\n        for (const subEmitter of this._subEmitters[index]) {\n          subEmitter.dispose();\n        }\n      }\n      this._subEmitters = [];\n      this.subEmitters = [];\n    }\n    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {\n      this.emitter.dispose(true);\n    }\n    if (this._onBeforeDrawParticlesObservable) {\n      this._onBeforeDrawParticlesObservable.clear();\n    }\n    // Remove from scene\n    if (this._scene) {\n      const index = this._scene.particleSystems.indexOf(this);\n      if (index > -1) {\n        this._scene.particleSystems.splice(index, 1);\n      }\n      this._scene._activeParticleSystems.dispose();\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onStoppedObservable.clear();\n    this.reset();\n  }\n  // Clone\n  /**\n   * Clones the particle system.\n   * @param name The name of the cloned object\n   * @param newEmitter The new emitter to use\n   * @param cloneTexture Also clone the textures if true\n   * @returns the cloned particle system\n   */\n  clone(name, newEmitter, cloneTexture = false) {\n    const custom = {\n      ...this._customWrappers\n    };\n    let program = null;\n    const engine = this._engine;\n    if (engine.createEffectForParticles) {\n      if (this.customShader != null) {\n        program = this.customShader;\n        const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n        const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n        if (!custom[0]) {\n          this.setCustomEffect(effect, 0);\n        } else {\n          custom[0].effect = effect;\n        }\n      }\n    }\n    const serialization = this.serialize(cloneTexture);\n    const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\n    result.name = name;\n    result.customShader = program;\n    result._customWrappers = custom;\n    if (newEmitter === undefined) {\n      newEmitter = this.emitter;\n    }\n    if (this.noiseTexture) {\n      result.noiseTexture = this.noiseTexture.clone();\n    }\n    result.emitter = newEmitter;\n    if (!this.preventAutoStart) {\n      result.start();\n    }\n    return result;\n  }\n  /**\n   * Serializes the particle system to a JSON object\n   * @param serializeTexture defines if the texture must be serialized as well\n   * @returns the JSON object\n   */\n  serialize(serializeTexture = false) {\n    const serializationObject = {};\n    ParticleSystem._Serialize(serializationObject, this, serializeTexture);\n    serializationObject.textureMask = this.textureMask.asArray();\n    serializationObject.customShader = this.customShader;\n    serializationObject.preventAutoStart = this.preventAutoStart;\n    // SubEmitters\n    if (this.subEmitters) {\n      serializationObject.subEmitters = [];\n      if (!this._subEmitters) {\n        this._prepareSubEmitterInternalArray();\n      }\n      for (const subs of this._subEmitters) {\n        const cell = [];\n        for (const sub of subs) {\n          cell.push(sub.serialize(serializeTexture));\n        }\n        serializationObject.subEmitters.push(cell);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * @internal\n   */\n  static _Serialize(serializationObject, particleSystem, serializeTexture) {\n    serializationObject.name = particleSystem.name;\n    serializationObject.id = particleSystem.id;\n    serializationObject.capacity = particleSystem.getCapacity();\n    serializationObject.disposeOnStop = particleSystem.disposeOnStop;\n    serializationObject.manualEmitCount = particleSystem.manualEmitCount;\n    // Emitter\n    if (particleSystem.emitter.position) {\n      const emitterMesh = particleSystem.emitter;\n      serializationObject.emitterId = emitterMesh.id;\n    } else {\n      const emitterPosition = particleSystem.emitter;\n      serializationObject.emitter = emitterPosition.asArray();\n    }\n    // Emitter\n    if (particleSystem.particleEmitterType) {\n      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\n    }\n    if (particleSystem.particleTexture) {\n      if (serializeTexture) {\n        serializationObject.texture = particleSystem.particleTexture.serialize();\n      } else {\n        serializationObject.textureName = particleSystem.particleTexture.name;\n        serializationObject.invertY = !!particleSystem.particleTexture._invertY;\n      }\n    }\n    serializationObject.isLocal = particleSystem.isLocal;\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\n    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\n    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\n    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\n    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\n    // Particle system\n    serializationObject.startDelay = particleSystem.startDelay;\n    serializationObject.renderingGroupId = particleSystem.renderingGroupId;\n    serializationObject.isBillboardBased = particleSystem.isBillboardBased;\n    serializationObject.billboardMode = particleSystem.billboardMode;\n    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\n    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\n    serializationObject.minSize = particleSystem.minSize;\n    serializationObject.maxSize = particleSystem.maxSize;\n    serializationObject.minScaleX = particleSystem.minScaleX;\n    serializationObject.maxScaleX = particleSystem.maxScaleX;\n    serializationObject.minScaleY = particleSystem.minScaleY;\n    serializationObject.maxScaleY = particleSystem.maxScaleY;\n    serializationObject.minEmitPower = particleSystem.minEmitPower;\n    serializationObject.maxEmitPower = particleSystem.maxEmitPower;\n    serializationObject.minLifeTime = particleSystem.minLifeTime;\n    serializationObject.maxLifeTime = particleSystem.maxLifeTime;\n    serializationObject.emitRate = particleSystem.emitRate;\n    serializationObject.gravity = particleSystem.gravity.asArray();\n    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\n    serializationObject.color1 = particleSystem.color1.asArray();\n    serializationObject.color2 = particleSystem.color2.asArray();\n    serializationObject.colorDead = particleSystem.colorDead.asArray();\n    serializationObject.updateSpeed = particleSystem.updateSpeed;\n    serializationObject.targetStopDuration = particleSystem.targetStopDuration;\n    serializationObject.blendMode = particleSystem.blendMode;\n    serializationObject.preWarmCycles = particleSystem.preWarmCycles;\n    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\n    serializationObject.minInitialRotation = particleSystem.minInitialRotation;\n    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\n    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\n    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\n    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\n    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\n    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\n    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\n    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\n    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\n    serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\n    const colorGradients = particleSystem.getColorGradients();\n    if (colorGradients) {\n      serializationObject.colorGradients = [];\n      for (const colorGradient of colorGradients) {\n        const serializedGradient = {\n          gradient: colorGradient.gradient,\n          color1: colorGradient.color1.asArray()\n        };\n        if (colorGradient.color2) {\n          serializedGradient.color2 = colorGradient.color2.asArray();\n        } else {\n          serializedGradient.color2 = colorGradient.color1.asArray();\n        }\n        serializationObject.colorGradients.push(serializedGradient);\n      }\n    }\n    const rampGradients = particleSystem.getRampGradients();\n    if (rampGradients) {\n      serializationObject.rampGradients = [];\n      for (const rampGradient of rampGradients) {\n        const serializedGradient = {\n          gradient: rampGradient.gradient,\n          color: rampGradient.color.asArray()\n        };\n        serializationObject.rampGradients.push(serializedGradient);\n      }\n      serializationObject.useRampGradients = particleSystem.useRampGradients;\n    }\n    const colorRemapGradients = particleSystem.getColorRemapGradients();\n    if (colorRemapGradients) {\n      serializationObject.colorRemapGradients = [];\n      for (const colorRemapGradient of colorRemapGradients) {\n        const serializedGradient = {\n          gradient: colorRemapGradient.gradient,\n          factor1: colorRemapGradient.factor1\n        };\n        if (colorRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = colorRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = colorRemapGradient.factor1;\n        }\n        serializationObject.colorRemapGradients.push(serializedGradient);\n      }\n    }\n    const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\n    if (alphaRemapGradients) {\n      serializationObject.alphaRemapGradients = [];\n      for (const alphaRemapGradient of alphaRemapGradients) {\n        const serializedGradient = {\n          gradient: alphaRemapGradient.gradient,\n          factor1: alphaRemapGradient.factor1\n        };\n        if (alphaRemapGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = alphaRemapGradient.factor2;\n        } else {\n          serializedGradient.factor2 = alphaRemapGradient.factor1;\n        }\n        serializationObject.alphaRemapGradients.push(serializedGradient);\n      }\n    }\n    const sizeGradients = particleSystem.getSizeGradients();\n    if (sizeGradients) {\n      serializationObject.sizeGradients = [];\n      for (const sizeGradient of sizeGradients) {\n        const serializedGradient = {\n          gradient: sizeGradient.gradient,\n          factor1: sizeGradient.factor1\n        };\n        if (sizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = sizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = sizeGradient.factor1;\n        }\n        serializationObject.sizeGradients.push(serializedGradient);\n      }\n    }\n    const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\n    if (angularSpeedGradients) {\n      serializationObject.angularSpeedGradients = [];\n      for (const angularSpeedGradient of angularSpeedGradients) {\n        const serializedGradient = {\n          gradient: angularSpeedGradient.gradient,\n          factor1: angularSpeedGradient.factor1\n        };\n        if (angularSpeedGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = angularSpeedGradient.factor2;\n        } else {\n          serializedGradient.factor2 = angularSpeedGradient.factor1;\n        }\n        serializationObject.angularSpeedGradients.push(serializedGradient);\n      }\n    }\n    const velocityGradients = particleSystem.getVelocityGradients();\n    if (velocityGradients) {\n      serializationObject.velocityGradients = [];\n      for (const velocityGradient of velocityGradients) {\n        const serializedGradient = {\n          gradient: velocityGradient.gradient,\n          factor1: velocityGradient.factor1\n        };\n        if (velocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = velocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = velocityGradient.factor1;\n        }\n        serializationObject.velocityGradients.push(serializedGradient);\n      }\n    }\n    const dragGradients = particleSystem.getDragGradients();\n    if (dragGradients) {\n      serializationObject.dragGradients = [];\n      for (const dragGradient of dragGradients) {\n        const serializedGradient = {\n          gradient: dragGradient.gradient,\n          factor1: dragGradient.factor1\n        };\n        if (dragGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = dragGradient.factor2;\n        } else {\n          serializedGradient.factor2 = dragGradient.factor1;\n        }\n        serializationObject.dragGradients.push(serializedGradient);\n      }\n    }\n    const emitRateGradients = particleSystem.getEmitRateGradients();\n    if (emitRateGradients) {\n      serializationObject.emitRateGradients = [];\n      for (const emitRateGradient of emitRateGradients) {\n        const serializedGradient = {\n          gradient: emitRateGradient.gradient,\n          factor1: emitRateGradient.factor1\n        };\n        if (emitRateGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = emitRateGradient.factor2;\n        } else {\n          serializedGradient.factor2 = emitRateGradient.factor1;\n        }\n        serializationObject.emitRateGradients.push(serializedGradient);\n      }\n    }\n    const startSizeGradients = particleSystem.getStartSizeGradients();\n    if (startSizeGradients) {\n      serializationObject.startSizeGradients = [];\n      for (const startSizeGradient of startSizeGradients) {\n        const serializedGradient = {\n          gradient: startSizeGradient.gradient,\n          factor1: startSizeGradient.factor1\n        };\n        if (startSizeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = startSizeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = startSizeGradient.factor1;\n        }\n        serializationObject.startSizeGradients.push(serializedGradient);\n      }\n    }\n    const lifeTimeGradients = particleSystem.getLifeTimeGradients();\n    if (lifeTimeGradients) {\n      serializationObject.lifeTimeGradients = [];\n      for (const lifeTimeGradient of lifeTimeGradients) {\n        const serializedGradient = {\n          gradient: lifeTimeGradient.gradient,\n          factor1: lifeTimeGradient.factor1\n        };\n        if (lifeTimeGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = lifeTimeGradient.factor2;\n        } else {\n          serializedGradient.factor2 = lifeTimeGradient.factor1;\n        }\n        serializationObject.lifeTimeGradients.push(serializedGradient);\n      }\n    }\n    const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\n    if (limitVelocityGradients) {\n      serializationObject.limitVelocityGradients = [];\n      for (const limitVelocityGradient of limitVelocityGradients) {\n        const serializedGradient = {\n          gradient: limitVelocityGradient.gradient,\n          factor1: limitVelocityGradient.factor1\n        };\n        if (limitVelocityGradient.factor2 !== undefined) {\n          serializedGradient.factor2 = limitVelocityGradient.factor2;\n        } else {\n          serializedGradient.factor2 = limitVelocityGradient.factor1;\n        }\n        serializationObject.limitVelocityGradients.push(serializedGradient);\n      }\n      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\n    }\n    if (particleSystem.noiseTexture) {\n      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\n    }\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {\n    var _a, _b, _c;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      scene = null;\n    } else {\n      scene = sceneOrEngine;\n    }\n    const internalClass = GetClass(\"BABYLON.Texture\");\n    if (internalClass && scene) {\n      // Texture\n      if (parsedParticleSystem.texture) {\n        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);\n      } else if (parsedParticleSystem.textureName) {\n        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true);\n        particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n      }\n    }\n    // Emitter\n    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\n      particleSystem.emitter = Vector3.Zero();\n    } else if (parsedParticleSystem.emitterId && scene) {\n      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\n    } else {\n      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\n    }\n    particleSystem.isLocal = !!parsedParticleSystem.isLocal;\n    // Misc.\n    if (parsedParticleSystem.renderingGroupId !== undefined) {\n      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\n    }\n    if (parsedParticleSystem.isBillboardBased !== undefined) {\n      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\n    }\n    if (parsedParticleSystem.billboardMode !== undefined) {\n      particleSystem.billboardMode = parsedParticleSystem.billboardMode;\n    }\n    if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\n      particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\n    }\n    // Animations\n    if (parsedParticleSystem.animations) {\n      for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n        const parsedAnimation = parsedParticleSystem.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          particleSystem.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\n      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\n      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\n      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\n    }\n    if (parsedParticleSystem.autoAnimate && scene) {\n      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n    }\n    // Particle system\n    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\n    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n    particleSystem.minSize = parsedParticleSystem.minSize;\n    particleSystem.maxSize = parsedParticleSystem.maxSize;\n    if (parsedParticleSystem.minScaleX) {\n      particleSystem.minScaleX = parsedParticleSystem.minScaleX;\n      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\n      particleSystem.minScaleY = parsedParticleSystem.minScaleY;\n      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\n    }\n    if (parsedParticleSystem.preWarmCycles !== undefined) {\n      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\n      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\n    }\n    if (parsedParticleSystem.minInitialRotation !== undefined) {\n      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\n      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\n    }\n    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n    particleSystem.emitRate = parsedParticleSystem.emitRate;\n    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\n    if (parsedParticleSystem.noiseStrength) {\n      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\n    }\n    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\n    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\n    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\n    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n    particleSystem.blendMode = parsedParticleSystem.blendMode;\n    if (parsedParticleSystem.colorGradients) {\n      for (const colorGradient of parsedParticleSystem.colorGradients) {\n        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined);\n      }\n    }\n    if (parsedParticleSystem.rampGradients) {\n      for (const rampGradient of parsedParticleSystem.rampGradients) {\n        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\n      }\n      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\n    }\n    if (parsedParticleSystem.colorRemapGradients) {\n      for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\n        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.alphaRemapGradients) {\n      for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\n        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.sizeGradients) {\n      for (const sizeGradient of parsedParticleSystem.sizeGradients) {\n        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.angularSpeedGradients) {\n      for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\n        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.velocityGradients) {\n      for (const velocityGradient of parsedParticleSystem.velocityGradients) {\n        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.dragGradients) {\n      for (const dragGradient of parsedParticleSystem.dragGradients) {\n        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.emitRateGradients) {\n      for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\n        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.startSizeGradients) {\n      for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\n        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.lifeTimeGradients) {\n      for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\n        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);\n      }\n    }\n    if (parsedParticleSystem.limitVelocityGradients) {\n      for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\n        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);\n      }\n      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\n    }\n    if (parsedParticleSystem.noiseTexture && scene) {\n      const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\n      particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\n    }\n    // Emitter\n    let emitterType;\n    if (parsedParticleSystem.particleEmitterType) {\n      switch (parsedParticleSystem.particleEmitterType.type) {\n        case \"SphereParticleEmitter\":\n          emitterType = new SphereParticleEmitter();\n          break;\n        case \"SphereDirectedParticleEmitter\":\n          emitterType = new SphereDirectedParticleEmitter();\n          break;\n        case \"ConeEmitter\":\n        case \"ConeParticleEmitter\":\n          emitterType = new ConeParticleEmitter();\n          break;\n        case \"CylinderParticleEmitter\":\n          emitterType = new CylinderParticleEmitter();\n          break;\n        case \"CylinderDirectedParticleEmitter\":\n          emitterType = new CylinderDirectedParticleEmitter();\n          break;\n        case \"HemisphericParticleEmitter\":\n          emitterType = new HemisphericParticleEmitter();\n          break;\n        case \"PointParticleEmitter\":\n          emitterType = new PointParticleEmitter();\n          break;\n        case \"MeshParticleEmitter\":\n          emitterType = new MeshParticleEmitter();\n          break;\n        case \"BoxEmitter\":\n        case \"BoxParticleEmitter\":\n        default:\n          emitterType = new BoxParticleEmitter();\n          break;\n      }\n      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\n    } else {\n      emitterType = new BoxParticleEmitter();\n      emitterType.parse(parsedParticleSystem, scene);\n    }\n    particleSystem.particleEmitterType = emitterType;\n    // Animation sheet\n    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\n    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\n    particleSystem.spriteCellLoop = (_a = parsedParticleSystem.spriteCellLoop) !== null && _a !== void 0 ? _a : true;\n    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\n    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\n    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\n    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\n    particleSystem.disposeOnStop = (_b = parsedParticleSystem.disposeOnStop) !== null && _b !== void 0 ? _b : false;\n    particleSystem.manualEmitCount = (_c = parsedParticleSystem.manualEmitCount) !== null && _c !== void 0 ? _c : -1;\n  }\n  /**\n   * Parses a JSON object to create a particle system.\n   * @param parsedParticleSystem The JSON object to parse\n   * @param sceneOrEngine The scene or the engine to create the particle system in\n   * @param rootUrl The root url to use to load external dependencies like texture\n   * @param doNotStart Ignore the preventAutoStart attribute and does not start\n   * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\n   * @returns the Parsed particle system\n   */\n  static Parse(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart = false, capacity) {\n    const name = parsedParticleSystem.name;\n    let custom = null;\n    let program = null;\n    let engine;\n    let scene;\n    if (sceneOrEngine instanceof ThinEngine) {\n      engine = sceneOrEngine;\n    } else {\n      scene = sceneOrEngine;\n      engine = scene.getEngine();\n    }\n    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {\n      program = parsedParticleSystem.customShader;\n      const defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n    }\n    const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\n    particleSystem.customShader = program;\n    particleSystem._rootUrl = rootUrl;\n    if (parsedParticleSystem.id) {\n      particleSystem.id = parsedParticleSystem.id;\n    }\n    // SubEmitters\n    if (parsedParticleSystem.subEmitters) {\n      particleSystem.subEmitters = [];\n      for (const cell of parsedParticleSystem.subEmitters) {\n        const cellArray = [];\n        for (const sub of cell) {\n          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\n        }\n        particleSystem.subEmitters.push(cellArray);\n      }\n    }\n    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\n    if (parsedParticleSystem.textureMask) {\n      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\n    }\n    // Auto start\n    if (parsedParticleSystem.preventAutoStart) {\n      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n    }\n    if (!doNotStart && !particleSystem.preventAutoStart) {\n      particleSystem.start();\n    }\n    return particleSystem;\n  }\n}\n/**\n * Billboard mode will only apply to Y axis\n */\nParticleSystem.BILLBOARDMODE_Y = 2;\n/**\n * Billboard mode will apply to all axes\n */\nParticleSystem.BILLBOARDMODE_ALL = 7;\n/**\n * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\n */\nParticleSystem.BILLBOARDMODE_STRETCHED = 8;\n/**\n * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\n */\nParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL = 9;\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;","map":{"version":3,"mappings":"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","names":["FactorGradient","ColorGradient","Color3Gradient","GradientHelper","Observable","Vector3","Matrix","TmpVectors","Vector4","Scalar","VertexBuffer","Buffer","ImageProcessingConfiguration","RawTexture","EngineStore","BoxParticleEmitter","HemisphericParticleEmitter","SphereParticleEmitter","SphereDirectedParticleEmitter","CylinderParticleEmitter","ConeParticleEmitter","PointParticleEmitter","MeshParticleEmitter","CylinderDirectedParticleEmitter","BaseParticleSystem","Particle","SubEmitter","SubEmitterType","SerializationHelper","GetClass","DrawWrapper","Color4","Color3","TmpColors","ThinEngine","MaterialHelper","addClipPlaneUniforms","prepareDefinesForClipPlanes","bindClipPlane","ParticleSystem","constructor","name","capacity","sceneOrEngine","customEffect","isAnimationSheetEnabled","epsilon","Identity","Array","Zero","particle","lastParticle","_particles","pop","copyTo","_stockParticles","push","length","_reset","_subEmitters","subEmitters","Math","floor","random","_attachedSubEmitters","forEach","subEmitter","type","ATTACHED","newEmitter","clone","particleSystem","start","templateIndex","END","subSystem","_inheritParticleInfoToSubEmitter","_rootParticleSystem","activeSubSystems","_capacity","_epsilon","_isAnimationSheetEnabled","getClassName","_scene","LastCreatedScene","_engine","getEngine","uniqueId","getUniqueId","particleSystems","defaultProjectionMatrix","PerspectiveFovLH","isNDCHalfZRange","getCaps","vertexArrayObject","_vertexArrayObject","_attachImageProcessingConfiguration","_customWrappers","effect","_drawWrappers","_useInstancing","instancedArrays","_createIndexBuffer","_createVertexBuffers","particleEmitterType","noiseTextureData","updateFunction","particles","noiseTextureSize","noiseTexture","getSize","getContent","then","data","index","scaledUpdateSpeed","_scaledUpdateSpeed","previousAge","age","lifeTime","diff","oldDiff","ratio","_colorGradients","GetCurrentGradient","currentGradient","nextGradient","scale","_currentColorGradient","_currentColor1","copyFrom","_currentColor2","getColorToRef","LerpToRef","color","colorStep","scaleToRef","_scaledColorStep","addInPlace","a","_angularSpeedGradients","_currentAngularSpeedGradient","_currentAngularSpeed1","_currentAngularSpeed2","getFactor","angularSpeed","Lerp","angle","directionScale","_velocityGradients","_currentVelocityGradient","_currentVelocity1","_currentVelocity2","direction","_scaledDirection","_limitVelocityGradients","_currentLimitVelocityGradient","_currentLimitVelocity1","_currentLimitVelocity2","limitVelocity","currentVelocity","scaleInPlace","limitVelocityDamping","_dragGradients","_currentDragGradient","_currentDrag1","_currentDrag2","drag","isLocal","_localPosition","TransformCoordinatesToRef","_emitterWorldMatrix","position","_randomNoiseCoordinates1","fetchedColorR","_fetchR","x","y","width","height","fetchedColorG","z","_randomNoiseCoordinates2","fetchedColorB","force","scaledForce","copyFromFloats","noiseStrength","gravity","_scaledGravity","_sizeGradients","_currentSizeGradient","_currentSize1","_currentSize2","size","_useRampGradients","_colorRemapGradients","min","factor1","max","factor2","remapData","_alphaRemapGradients","w","updateCellIndex","_inheritParticleInfoToSubEmitters","_emitFromParticle","disposeOnStop","stop","recycleParticle","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","useRampGradients","value","_resetEffect","getActiveCount","isStopping","_stopped","isAlive","getCustomEffect","blendMode","_getCustomDrawWrapper","setCustomEffect","drawContext","useInstancing","onBeforeDrawParticlesObservable","_onBeforeDrawParticlesObservable","vertexShaderName","vertexBuffers","_vertexBuffers","indexBuffer","_indexBuffer","_addFactorGradient","factorGradients","gradient","factor","newGradient","sort","b","_removeFactorGradient","factorGradient","splice","addLifeTimeGradient","_lifeTimeGradients","removeLifeTimeGradient","addSizeGradient","removeSizeGradient","addColorRemapGradient","removeColorRemapGradient","addAlphaRemapGradient","removeAlphaRemapGradient","addAngularSpeedGradient","removeAngularSpeedGradient","addVelocityGradient","removeVelocityGradient","addLimitVelocityGradient","removeLimitVelocityGradient","addDragGradient","removeDragGradient","addEmitRateGradient","_emitRateGradients","removeEmitRateGradient","addStartSizeGradient","_startSizeGradients","removeStartSizeGradient","_createRampGradientTexture","_rampGradients","_rampGradientsTexture","Uint8Array","_rawTextureWidth","tmpColor","r","g","CreateRGBATexture","getRampGradients","forceRefreshGradients","_syncRampGradientTexture","dispose","addRampGradient","rampGradient","removeRampGradient","_removeGradientAndTexture","addColorGradient","color1","color2","colorGradient","removeColorGradient","resetDrawCache","drawWrappers","drawWrapper","u","v","pixels","abs","wrappedU","wrappedV","_vertexBuffer","_spriteBuffer","releaseVertexArrayObject","_vertexBufferSize","_isBillboardBased","billboardMode","BILLBOARDMODE_STRETCHED","BILLBOARDMODE_STRETCHED_LOCAL","engine","vertexSize","_vertexData","Float32Array","dataOffset","positions","createVertexBuffer","PositionKind","colors","ColorKind","options","cellIndexBuffer","directionBuffer","rampDataBuffer","offsets","spriteData","indices","count","createIndexBuffer","getCapacity","_alive","isStarted","_started","_prepareSubEmitterInternalArray","delay","startDelay","targetStopDuration","_hasTargetStopDurationDependantGradient","setTimeout","_actualFrame","_currentEmitRateGradient","_currentEmitRate1","_currentEmitRate2","_currentStartSizeGradient","_currentStartSize1","_currentStartSize2","preWarmCycles","emitter","indexOf","computeWorldMatrix","noiseTextureAsProcedural","onGeneratedObservable","addOnce","animate","render","beginAnimationOnStart","animations","beginAnimation","beginAnimationFrom","beginAnimationTo","beginAnimationLoop","stopSubEmitters","onStoppedObservable","notifyObservers","_stopSubEmitters","reset","_appendParticleVertex","offsetX","offsetY","offset","worldOffset","cellIndex","_initialDirection","initialDirection","TransformNormalToRef","_removeFromRoot","_update","newParticles","emitterMesh","getWorldMatrix","emitterPosition","Translation","invertToRef","_emitterInverseWorldMatrix","_createParticle","Clamp","factorGradient1","factorGradient2","lifeTime1","lifeTime2","RandomRange","minLifeTime","maxLifeTime","emitPower","minEmitPower","maxEmitPower","startPositionFunction","startDirectionFunction","minSize","maxSize","minScaleX","maxScaleX","minScaleY","maxScaleY","minAngularSpeed","maxAngularSpeed","minInitialRotation","maxInitialRotation","step","colorDead","subtractToRef","_colorDiff","_initialStartSpriteCellID","startSpriteCellID","_initialEndSpriteCellID","endSpriteCellID","_initialSpriteCellLoop","spriteCellLoop","_inheritedVelocityOffset","_GetAttributeNamesOrOptions","isBillboardBased","attributeNamesOrOptions","_GetEffectCreationOptions","useLogarithmicDepth","effectCreationOption","fillDefines","defines","BLENDMODE_MULTIPLY","BILLBOARDMODE_Y","BILLBOARDMODE_ALL","_imageProcessingConfiguration","prepareDefines","_imageProcessingConfigurationDefines","toString","fillUniformsAttributesAndSamplerNames","uniforms","attributes","samplers","PrepareUniforms","PrepareSamplers","_getWrapper","customWrapper","currentRenderPassId","_features","supportRenderPasses","join","attributesNamesOrOptions","setEffect","createEffect","preWarmOnly","isReady","_currentRenderId","getFrameId","updateSpeed","preWarmStepOffset","getAnimationRatio","manualEmitCount","_newPartsExcess","rate","emitRate","onAnimationEnd","_toBeDisposed","_appendParticleVertices","updateDirectly","rebuild","_rebuild","key","particleTexture","BLENDMODE_MULTIPLYADD","BLENDMODE_ADD","_render","enableEffect","viewMatrix","defaultViewMatrix","getViewMatrix","setTexture","setMatrix","getProjectionMatrix","baseSize","getBaseSize","setFloat3","spriteCellWidth","spriteCellHeight","setVector2","translationPivot","setFloat4","textureMask","camera","activeCamera","setVector3","globalPosition","undefined","recordVertexArrayObject","bindVertexArrayObject","bindBuffers","BindLogDepth","applyByPostProcess","bind","setAlphaMode","BLENDMODE_ONEONE","BLENDMODE_STANDARD","drawArraysType","drawElementsType","setState","forceDepthWrite","setDepthWrite","outparticles","unbindInstanceAttributes","disposeTexture","_releaseBuffer","_disposeEmitterOnDispose","clear","_activeParticleSystems","cloneTexture","custom","program","createEffectForParticles","customShader","shaderOptions","shaderPath","fragmentElement","serialization","serialize","result","Parse","_rootUrl","preventAutoStart","serializeTexture","serializationObject","_Serialize","asArray","subs","cell","sub","id","emitterId","texture","textureName","invertY","_invertY","AppendSerializedAnimations","renderingGroupId","spriteCellChangeSpeed","spriteRandomStartCell","colorGradients","getColorGradients","serializedGradient","rampGradients","colorRemapGradients","getColorRemapGradients","colorRemapGradient","alphaRemapGradients","getAlphaRemapGradients","alphaRemapGradient","sizeGradients","getSizeGradients","sizeGradient","angularSpeedGradients","getAngularSpeedGradients","angularSpeedGradient","velocityGradients","getVelocityGradients","velocityGradient","dragGradients","getDragGradients","dragGradient","emitRateGradients","getEmitRateGradients","emitRateGradient","startSizeGradients","getStartSizeGradients","startSizeGradient","lifeTimeGradients","getLifeTimeGradients","lifeTimeGradient","limitVelocityGradients","getLimitVelocityGradients","limitVelocityGradient","_Parse","parsedParticleSystem","rootUrl","scene","internalClass","getLastMeshById","FromArray","animationIndex","parsedAnimation","autoAnimate","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","emitterType","parse","doNotStart","cellArray","_ParseParticleSystem"],"sourceRoot":"","sources":["../../../../lts/core/generated/Particles/particleSystem.ts"],"sourcesContent":["/* eslint-disable import/no-internal-modules */\r\nimport type { Immutable, Nullable } from \"../types\";\r\nimport { FactorGradient, ColorGradient, Color3Gradient, GradientHelper } from \"../Misc/gradients\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\n\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IDisposable } from \"../scene\";\r\nimport type { IParticleEmitterType } from \"../Particles/EmitterTypes/index\";\r\nimport {\r\n    BoxParticleEmitter,\r\n    HemisphericParticleEmitter,\r\n    SphereParticleEmitter,\r\n    SphereDirectedParticleEmitter,\r\n    CylinderParticleEmitter,\r\n    ConeParticleEmitter,\r\n    PointParticleEmitter,\r\n    MeshParticleEmitter,\r\n    CylinderDirectedParticleEmitter,\r\n} from \"../Particles/EmitterTypes/index\";\r\nimport type { IParticleSystem } from \"./IParticleSystem\";\r\nimport { BaseParticleSystem } from \"./baseParticleSystem\";\r\nimport { Particle } from \"./particle\";\r\nimport { SubEmitter, SubEmitterType } from \"./subEmitter\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/particles.fragment\";\r\nimport \"../Shaders/particles.vertex\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color4, Color3, TmpColors } from \"../Maths/math.color\";\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\n\r\nimport \"../Engines/Extensions/engine.alpha\";\r\nimport { addClipPlaneUniforms, prepareDefinesForClipPlanes, bindClipPlane } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\ndeclare type ProceduralTexture = import(\"../Materials/Textures/Procedurals/proceduralTexture\").ProceduralTexture;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n * This represents a particle system in Babylon.\r\n * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n * Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n */\r\nexport class ParticleSystem extends BaseParticleSystem implements IDisposable, IAnimatable, IParticleSystem {\r\n    /**\r\n     * Billboard mode will only apply to Y axis\r\n     */\r\n    public static readonly BILLBOARDMODE_Y = Constants.PARTICLES_BILLBOARDMODE_Y;\r\n    /**\r\n     * Billboard mode will apply to all axes\r\n     */\r\n    public static readonly BILLBOARDMODE_ALL = Constants.PARTICLES_BILLBOARDMODE_ALL;\r\n    /**\r\n     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED = Constants.PARTICLES_BILLBOARDMODE_STRETCHED;\r\n    /**\r\n     * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\r\n     */\r\n    public static readonly BILLBOARDMODE_STRETCHED_LOCAL = Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL;\r\n\r\n    /**\r\n     * This function can be defined to provide custom update for active particles.\r\n     * This function will be called instead of regular update (age, position, color, etc.).\r\n     * Do not forget that this function will be called on every frame so try to keep it simple and fast :)\r\n     */\r\n    public updateFunction: (particles: Particle[]) => void;\r\n\r\n    private _emitterWorldMatrix: Matrix;\r\n    private _emitterInverseWorldMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * This function can be defined to specify initial direction for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startDirectionFunction: (worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n    /**\r\n     * This function can be defined to specify initial position for every new particle.\r\n     * It by default use the emitterType defined function\r\n     */\r\n    public startPositionFunction: (worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean) => void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _inheritedVelocityOffset = new Vector3();\r\n    /**\r\n     * An event triggered when the system is disposed\r\n     */\r\n    public onDisposeObservable = new Observable<IParticleSystem>();\r\n    /**\r\n     * An event triggered when the system is stopped\r\n     */\r\n    public onStoppedObservable = new Observable<IParticleSystem>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<IParticleSystem>>;\r\n    /**\r\n     * Sets a callback that will be triggered when the system is disposed\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    private _particles = new Array<Particle>();\r\n    private _epsilon: number;\r\n    private _capacity: number;\r\n    private _stockParticles = new Array<Particle>();\r\n    private _newPartsExcess = 0;\r\n    private _vertexData: Float32Array;\r\n    private _vertexBuffer: Nullable<Buffer>;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrappers: DrawWrapper[][]; // first index is render pass id, second index is blend mode\r\n    private _customWrappers: { [blendMode: number]: Nullable<DrawWrapper> };\r\n    private _scaledColorStep = new Color4(0, 0, 0, 0);\r\n    private _colorDiff = new Color4(0, 0, 0, 0);\r\n    private _scaledDirection = Vector3.Zero();\r\n    private _scaledGravity = Vector3.Zero();\r\n    private _currentRenderId = -1;\r\n    private _alive: boolean;\r\n    private _useInstancing = false;\r\n    private _vertexArrayObject: Nullable<WebGLVertexArrayObject>;\r\n\r\n    private _started = false;\r\n    private _stopped = false;\r\n    private _actualFrame = 0;\r\n    private _scaledUpdateSpeed: number;\r\n    private _vertexBufferSize: number;\r\n\r\n    /** @internal */\r\n    public _currentEmitRateGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentEmitRate1 = 0;\r\n    /** @internal */\r\n    public _currentEmitRate2 = 0;\r\n\r\n    /** @internal */\r\n    public _currentStartSizeGradient: Nullable<FactorGradient>;\r\n    /** @internal */\r\n    public _currentStartSize1 = 0;\r\n    /** @internal */\r\n    public _currentStartSize2 = 0;\r\n\r\n    /** Indicates that the update of particles is done in the animate function */\r\n    public readonly updateInAnimate = true;\r\n\r\n    private readonly _rawTextureWidth = 256;\r\n    private _rampGradientsTexture: Nullable<RawTexture>;\r\n    private _useRampGradients = false;\r\n\r\n    /** Gets or sets a matrix to use to compute projection */\r\n    public defaultProjectionMatrix: Matrix;\r\n\r\n    /** Gets or sets a matrix to use to compute view */\r\n    public defaultViewMatrix: Matrix;\r\n\r\n    /** Gets or sets a boolean indicating that ramp gradients must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro#ramp-gradients\r\n     */\r\n    public get useRampGradients(): boolean {\r\n        return this._useRampGradients;\r\n    }\r\n\r\n    public set useRampGradients(value: boolean) {\r\n        if (this._useRampGradients === value) {\r\n            return;\r\n        }\r\n\r\n        this._useRampGradients = value;\r\n\r\n        this._resetEffect();\r\n    }\r\n\r\n    // Sub-emitters\r\n    /**\r\n     * The Sub-emitters templates that will be used to generate the sub particle system to be associated with the system, this property is used by the root particle system only.\r\n     * When a particle is spawned, an array will be chosen at random and all the emitters in that array will be attached to the particle.  (Default: [])\r\n     */\r\n    public subEmitters: Array<ParticleSystem | SubEmitter | Array<SubEmitter>>;\r\n    // the subEmitters field above converted to a constant type\r\n    private _subEmitters: Array<Array<SubEmitter>>;\r\n    /**\r\n     * @internal\r\n     * If the particle systems emitter should be disposed when the particle system is disposed\r\n     */\r\n    public _disposeEmitterOnDispose = false;\r\n    /**\r\n     * The current active Sub-systems, this property is used by the root particle system only.\r\n     */\r\n    public activeSubSystems: Array<ParticleSystem>;\r\n\r\n    /**\r\n     * Specifies if the particles are updated in emitter local space or world space\r\n     */\r\n    public isLocal = false;\r\n\r\n    /** Indicates that the particle system is CPU based */\r\n    public readonly isGPU = false;\r\n\r\n    private _rootParticleSystem: Nullable<ParticleSystem>;\r\n    //end of Sub-emitter\r\n\r\n    /**\r\n     * Gets the current list of active particles\r\n     */\r\n    public get particles(): Particle[] {\r\n        return this._particles;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of particles active at the same time.\r\n     * @returns The number of active particles.\r\n     */\r\n    public getActiveCount() {\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ParticleSystem\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ParticleSystem\";\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the system is stopping\r\n     * @returns true if the system is currently stopping\r\n     */\r\n    public isStopping() {\r\n        return this._stopped && this.isAlive();\r\n    }\r\n\r\n    /**\r\n     * Gets the custom effect used to render the particles\r\n     * @param blendMode Blend mode for which the effect should be retrieved\r\n     * @returns The effect\r\n     */\r\n    public getCustomEffect(blendMode: number = 0): Nullable<Effect> {\r\n        return this._customWrappers[blendMode]?.effect ?? this._customWrappers[0]!.effect;\r\n    }\r\n\r\n    private _getCustomDrawWrapper(blendMode: number = 0): Nullable<DrawWrapper> {\r\n        return this._customWrappers[blendMode] ?? this._customWrappers[0];\r\n    }\r\n\r\n    /**\r\n     * Sets the custom effect used to render the particles\r\n     * @param effect The effect to set\r\n     * @param blendMode Blend mode for which the effect should be set\r\n     */\r\n    public setCustomEffect(effect: Nullable<Effect>, blendMode: number = 0) {\r\n        this._customWrappers[blendMode] = new DrawWrapper(this._engine);\r\n        this._customWrappers[blendMode]!.effect = effect;\r\n        if (this._customWrappers[blendMode]!.drawContext) {\r\n            this._customWrappers[blendMode]!.drawContext!.useInstancing = this._useInstancing;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    private _onBeforeDrawParticlesObservable: Nullable<Observable<Nullable<Effect>>> = null;\r\n\r\n    /**\r\n     * Observable that will be called just before the particles are drawn\r\n     */\r\n    public get onBeforeDrawParticlesObservable(): Observable<Nullable<Effect>> {\r\n        if (!this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable = new Observable<Nullable<Effect>>();\r\n        }\r\n\r\n        return this._onBeforeDrawParticlesObservable;\r\n    }\r\n\r\n    /**\r\n     * Gets the name of the particle vertex shader\r\n     */\r\n    public get vertexShaderName(): string {\r\n        return \"particles\";\r\n    }\r\n\r\n    /**\r\n     * Gets the vertex buffers used by the particle system\r\n     */\r\n    public get vertexBuffers(): Immutable<{ [key: string]: VertexBuffer }> {\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer used by the particle system (or null if no index buffer is used (if _useInstancing=true))\r\n     */\r\n    public get indexBuffer(): Nullable<DataBuffer> {\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a particle system.\r\n     * Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.\r\n     * @param name The name of the particle system\r\n     * @param capacity The max number of particles alive at the same time\r\n     * @param sceneOrEngine The scene the particle system belongs to or the engine to use if no scene\r\n     * @param customEffect a custom effect used to change the way particles are rendered by default\r\n     * @param isAnimationSheetEnabled Must be true if using a spritesheet to animate the particles texture\r\n     * @param epsilon Offset used to render the particles\r\n     */\r\n    constructor(\r\n        name: string,\r\n        capacity: number,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        customEffect: Nullable<Effect> = null,\r\n        isAnimationSheetEnabled: boolean = false,\r\n        epsilon: number = 0.01\r\n    ) {\r\n        super(name);\r\n\r\n        this._capacity = capacity;\r\n\r\n        this._epsilon = epsilon;\r\n        this._isAnimationSheetEnabled = isAnimationSheetEnabled;\r\n\r\n        if (!sceneOrEngine || sceneOrEngine.getClassName() === \"Scene\") {\r\n            this._scene = (sceneOrEngine as Scene) || EngineStore.LastCreatedScene;\r\n            this._engine = this._scene.getEngine();\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.particleSystems.push(this);\r\n        } else {\r\n            this._engine = sceneOrEngine as ThinEngine;\r\n            this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, this._engine.isNDCHalfZRange);\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        this._customWrappers = { 0: new DrawWrapper(this._engine) };\r\n        this._customWrappers[0]!.effect = customEffect;\r\n\r\n        this._drawWrappers = [];\r\n        this._useInstancing = this._engine.getCaps().instancedArrays;\r\n\r\n        this._createIndexBuffer();\r\n        this._createVertexBuffers();\r\n\r\n        // Default emitter type\r\n        this.particleEmitterType = new BoxParticleEmitter();\r\n        let noiseTextureData: Nullable<Uint8Array> = null;\r\n\r\n        // Update\r\n        this.updateFunction = (particles: Particle[]): void => {\r\n            let noiseTextureSize: Nullable<ISize> = null;\r\n\r\n            if (this.noiseTexture) {\r\n                // We need to get texture data back to CPU\r\n                noiseTextureSize = this.noiseTexture.getSize();\r\n                this.noiseTexture.getContent()?.then((data) => {\r\n                    noiseTextureData = data as Uint8Array;\r\n                });\r\n            }\r\n\r\n            for (let index = 0; index < particles.length; index++) {\r\n                const particle = particles[index];\r\n\r\n                let scaledUpdateSpeed = this._scaledUpdateSpeed;\r\n                const previousAge = particle.age;\r\n                particle.age += scaledUpdateSpeed;\r\n\r\n                // Evaluate step to death\r\n                if (particle.age > particle.lifeTime) {\r\n                    const diff = particle.age - previousAge;\r\n                    const oldDiff = particle.lifeTime - previousAge;\r\n\r\n                    scaledUpdateSpeed = (oldDiff * scaledUpdateSpeed) / diff;\r\n\r\n                    particle.age = particle.lifeTime;\r\n                }\r\n\r\n                const ratio = particle.age / particle.lifeTime;\r\n\r\n                // Color\r\n                if (this._colorGradients && this._colorGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._colorGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentColorGradient) {\r\n                            particle._currentColor1.copyFrom(particle._currentColor2);\r\n                            (<ColorGradient>nextGradient).getColorToRef(particle._currentColor2);\r\n                            particle._currentColorGradient = <ColorGradient>currentGradient;\r\n                        }\r\n                        Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);\r\n                    });\r\n                } else {\r\n                    particle.colorStep.scaleToRef(scaledUpdateSpeed, this._scaledColorStep);\r\n                    particle.color.addInPlace(this._scaledColorStep);\r\n\r\n                    if (particle.color.a < 0) {\r\n                        particle.color.a = 0;\r\n                    }\r\n                }\r\n\r\n                // Angular speed\r\n                if (this._angularSpeedGradients && this._angularSpeedGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._angularSpeedGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentAngularSpeedGradient) {\r\n                            particle._currentAngularSpeed1 = particle._currentAngularSpeed2;\r\n                            particle._currentAngularSpeed2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentAngularSpeedGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);\r\n                    });\r\n                }\r\n                particle.angle += particle.angularSpeed * scaledUpdateSpeed;\r\n\r\n                // Direction\r\n                let directionScale = scaledUpdateSpeed;\r\n\r\n                /// Velocity\r\n                if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._velocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentVelocityGradient) {\r\n                            particle._currentVelocity1 = particle._currentVelocity2;\r\n                            particle._currentVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);\r\n                    });\r\n                }\r\n\r\n                particle.direction.scaleToRef(directionScale, this._scaledDirection);\r\n\r\n                /// Limit velocity\r\n                if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._limitVelocityGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentLimitVelocityGradient) {\r\n                            particle._currentLimitVelocity1 = particle._currentLimitVelocity2;\r\n                            particle._currentLimitVelocity2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentLimitVelocityGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);\r\n                        const currentVelocity = particle.direction.length();\r\n\r\n                        if (currentVelocity > limitVelocity) {\r\n                            particle.direction.scaleInPlace(this.limitVelocityDamping);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /// Drag\r\n                if (this._dragGradients && this._dragGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._dragGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentDragGradient) {\r\n                            particle._currentDrag1 = particle._currentDrag2;\r\n                            particle._currentDrag2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentDragGradient = <FactorGradient>currentGradient;\r\n                        }\r\n\r\n                        const drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);\r\n\r\n                        this._scaledDirection.scaleInPlace(1.0 - drag);\r\n                    });\r\n                }\r\n\r\n                if (this.isLocal && particle._localPosition) {\r\n                    particle._localPosition!.addInPlace(this._scaledDirection);\r\n                    Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n                } else {\r\n                    particle.position.addInPlace(this._scaledDirection);\r\n                }\r\n\r\n                // Noise\r\n                if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {\r\n                    const fetchedColorR = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.x,\r\n                        particle._randomNoiseCoordinates1.y,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorG = this._fetchR(\r\n                        particle._randomNoiseCoordinates1.z,\r\n                        particle._randomNoiseCoordinates2.x,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n                    const fetchedColorB = this._fetchR(\r\n                        particle._randomNoiseCoordinates2.y,\r\n                        particle._randomNoiseCoordinates2.z,\r\n                        noiseTextureSize.width,\r\n                        noiseTextureSize.height,\r\n                        noiseTextureData\r\n                    );\r\n\r\n                    const force = TmpVectors.Vector3[0];\r\n                    const scaledForce = TmpVectors.Vector3[1];\r\n\r\n                    force.copyFromFloats(\r\n                        (2 * fetchedColorR - 1) * this.noiseStrength.x,\r\n                        (2 * fetchedColorG - 1) * this.noiseStrength.y,\r\n                        (2 * fetchedColorB - 1) * this.noiseStrength.z\r\n                    );\r\n\r\n                    force.scaleToRef(scaledUpdateSpeed, scaledForce);\r\n                    particle.direction.addInPlace(scaledForce);\r\n                }\r\n\r\n                // Gravity\r\n                this.gravity.scaleToRef(scaledUpdateSpeed, this._scaledGravity);\r\n                particle.direction.addInPlace(this._scaledGravity);\r\n\r\n                // Size\r\n                if (this._sizeGradients && this._sizeGradients.length > 0) {\r\n                    GradientHelper.GetCurrentGradient(ratio, this._sizeGradients, (currentGradient, nextGradient, scale) => {\r\n                        if (currentGradient !== particle._currentSizeGradient) {\r\n                            particle._currentSize1 = particle._currentSize2;\r\n                            particle._currentSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                            particle._currentSizeGradient = <FactorGradient>currentGradient;\r\n                        }\r\n                        particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);\r\n                    });\r\n                }\r\n\r\n                // Remap data\r\n                if (this._useRampGradients) {\r\n                    if (this._colorRemapGradients && this._colorRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._colorRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.x = min;\r\n                            particle.remapData.y = max - min;\r\n                        });\r\n                    }\r\n\r\n                    if (this._alphaRemapGradients && this._alphaRemapGradients.length > 0) {\r\n                        GradientHelper.GetCurrentGradient(ratio, this._alphaRemapGradients, (currentGradient, nextGradient, scale) => {\r\n                            const min = Scalar.Lerp((<FactorGradient>currentGradient).factor1, (<FactorGradient>nextGradient).factor1, scale);\r\n                            const max = Scalar.Lerp((<FactorGradient>currentGradient).factor2!, (<FactorGradient>nextGradient).factor2!, scale);\r\n\r\n                            particle.remapData.z = min;\r\n                            particle.remapData.w = max - min;\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this._isAnimationSheetEnabled) {\r\n                    particle.updateCellIndex();\r\n                }\r\n\r\n                // Update the position of the attached sub-emitters to match their attached particle\r\n                particle._inheritParticleInfoToSubEmitters();\r\n\r\n                if (particle.age >= particle.lifeTime) {\r\n                    // Recycle by swapping with last particle\r\n                    this._emitFromParticle(particle);\r\n                    if (particle._attachedSubEmitters) {\r\n                        particle._attachedSubEmitters.forEach((subEmitter) => {\r\n                            subEmitter.particleSystem.disposeOnStop = true;\r\n                            subEmitter.particleSystem.stop();\r\n                        });\r\n                        particle._attachedSubEmitters = null;\r\n                    }\r\n                    this.recycleParticle(particle);\r\n                    index--;\r\n                    continue;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private _addFactorGradient(factorGradients: FactorGradient[], gradient: number, factor: number, factor2?: number) {\r\n        const newGradient = new FactorGradient(gradient, factor, factor2);\r\n        factorGradients.push(newGradient);\r\n\r\n        factorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n    }\r\n\r\n    private _removeFactorGradient(factorGradients: Nullable<FactorGradient[]>, gradient: number) {\r\n        if (!factorGradients) {\r\n            return;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const factorGradient of factorGradients) {\r\n            if (factorGradient.gradient === gradient) {\r\n                factorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a new life time gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the life time factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLifeTimeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._lifeTimeGradients) {\r\n            this._lifeTimeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific life time gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLifeTimeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._lifeTimeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new size gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the size factor to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._sizeGradients) {\r\n            this._sizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._sizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the color remap minimal range\r\n     * @param max defines the color remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addColorRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._colorRemapGradients) {\r\n            this._colorRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._colorRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeColorRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._colorRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new alpha remap gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param min defines the alpha remap minimal range\r\n     * @param max defines the alpha remap maximal range\r\n     * @returns the current particle system\r\n     */\r\n    public addAlphaRemapGradient(gradient: number, min: number, max: number): IParticleSystem {\r\n        if (!this._alphaRemapGradients) {\r\n            this._alphaRemapGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific alpha remap gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAlphaRemapGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._alphaRemapGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new angular speed gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the angular speed  to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addAngularSpeedGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._angularSpeedGradients) {\r\n            this._angularSpeedGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific angular speed gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeAngularSpeedGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._angularSpeedGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the velocity to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._velocityGradients) {\r\n            this._velocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._velocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new limit velocity gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the limit velocity value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addLimitVelocityGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._limitVelocityGradients) {\r\n            this._limitVelocityGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific limit velocity gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeLimitVelocityGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._limitVelocityGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new drag gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the drag value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addDragGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._dragGradients) {\r\n            this._dragGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._dragGradients, gradient, factor, factor2);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific drag gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeDragGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._dragGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new emit rate gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the emit rate value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addEmitRateGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._emitRateGradients) {\r\n            this._emitRateGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific emit rate gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeEmitRateGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._emitRateGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new start size gradient (please note that this will only work if you set the targetStopDuration property)\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param factor defines the start size value to affect to the specified gradient\r\n     * @param factor2 defines an additional factor used to define a range ([factor, factor2]) with main value to pick the final value from\r\n     * @returns the current particle system\r\n     */\r\n    public addStartSizeGradient(gradient: number, factor: number, factor2?: number): IParticleSystem {\r\n        if (!this._startSizeGradients) {\r\n            this._startSizeGradients = [];\r\n        }\r\n\r\n        this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific start size gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeStartSizeGradient(gradient: number): IParticleSystem {\r\n        this._removeFactorGradient(this._startSizeGradients, gradient);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _createRampGradientTexture() {\r\n        if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {\r\n            return;\r\n        }\r\n\r\n        const data = new Uint8Array(this._rawTextureWidth * 4);\r\n        const tmpColor = TmpColors.Color3[0];\r\n\r\n        for (let x = 0; x < this._rawTextureWidth; x++) {\r\n            const ratio = x / this._rawTextureWidth;\r\n\r\n            GradientHelper.GetCurrentGradient(ratio, this._rampGradients, (currentGradient, nextGradient, scale) => {\r\n                Color3.LerpToRef((<Color3Gradient>currentGradient).color, (<Color3Gradient>nextGradient).color, scale, tmpColor);\r\n                data[x * 4] = tmpColor.r * 255;\r\n                data[x * 4 + 1] = tmpColor.g * 255;\r\n                data[x * 4 + 2] = tmpColor.b * 255;\r\n                data[x * 4 + 3] = 255;\r\n            });\r\n        }\r\n\r\n        this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\r\n    }\r\n\r\n    /**\r\n     * Gets the current list of ramp gradients.\r\n     * You must use addRampGradient and removeRampGradient to update this list\r\n     * @returns the list of ramp gradients\r\n     */\r\n    public getRampGradients(): Nullable<Array<Color3Gradient>> {\r\n        return this._rampGradients;\r\n    }\r\n\r\n    /** Force the system to rebuild all gradients that need to be resync */\r\n    public forceRefreshGradients() {\r\n        this._syncRampGradientTexture();\r\n    }\r\n\r\n    private _syncRampGradientTexture() {\r\n        if (!this._rampGradients) {\r\n            return;\r\n        }\r\n\r\n        this._rampGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._createRampGradientTexture();\r\n    }\r\n\r\n    /**\r\n     * Adds a new ramp gradient used to remap particle colors\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color defines the color to affect to the specified gradient\r\n     * @returns the current particle system\r\n     */\r\n    public addRampGradient(gradient: number, color: Color3): ParticleSystem {\r\n        if (!this._rampGradients) {\r\n            this._rampGradients = [];\r\n        }\r\n\r\n        const rampGradient = new Color3Gradient(gradient, color);\r\n        this._rampGradients.push(rampGradient);\r\n\r\n        this._syncRampGradientTexture();\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific ramp gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns the current particle system\r\n     */\r\n    public removeRampGradient(gradient: number): ParticleSystem {\r\n        this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);\r\n        this._rampGradientsTexture = null;\r\n\r\n        if (this._rampGradients && this._rampGradients.length > 0) {\r\n            this._createRampGradientTexture();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds a new color gradient\r\n     * @param gradient defines the gradient to use (between 0 and 1)\r\n     * @param color1 defines the color to affect to the specified gradient\r\n     * @param color2 defines an additional color used to define a range ([color, color2]) with main color to pick the final color from\r\n     * @returns this particle system\r\n     */\r\n    public addColorGradient(gradient: number, color1: Color4, color2?: Color4): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            this._colorGradients = [];\r\n        }\r\n\r\n        const colorGradient = new ColorGradient(gradient, color1, color2);\r\n        this._colorGradients.push(colorGradient);\r\n\r\n        this._colorGradients.sort((a, b) => {\r\n            if (a.gradient < b.gradient) {\r\n                return -1;\r\n            } else if (a.gradient > b.gradient) {\r\n                return 1;\r\n            }\r\n\r\n            return 0;\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a specific color gradient\r\n     * @param gradient defines the gradient to remove\r\n     * @returns this particle system\r\n     */\r\n    public removeColorGradient(gradient: number): IParticleSystem {\r\n        if (!this._colorGradients) {\r\n            return this;\r\n        }\r\n\r\n        let index = 0;\r\n        for (const colorGradient of this._colorGradients) {\r\n            if (colorGradient.gradient === gradient) {\r\n                this._colorGradients.splice(index, 1);\r\n                break;\r\n            }\r\n            index++;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Resets the draw wrappers cache\r\n     */\r\n    public resetDrawCache(): void {\r\n        for (const drawWrappers of this._drawWrappers) {\r\n            if (drawWrappers) {\r\n                for (const drawWrapper of drawWrappers) {\r\n                    drawWrapper?.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._drawWrappers = [];\r\n    }\r\n\r\n    private _fetchR(u: number, v: number, width: number, height: number, pixels: Uint8Array): number {\r\n        u = Math.abs(u) * 0.5 + 0.5;\r\n        v = Math.abs(v) * 0.5 + 0.5;\r\n\r\n        const wrappedU = (u * width) % width | 0;\r\n        const wrappedV = (v * height) % height | 0;\r\n\r\n        const position = (wrappedU + wrappedV * width) * 4;\r\n        return pixels[position] / 255;\r\n    }\r\n\r\n    protected _reset() {\r\n        this._resetEffect();\r\n    }\r\n\r\n    private _resetEffect() {\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createVertexBuffers();\r\n    }\r\n\r\n    private _createVertexBuffers() {\r\n        this._vertexBufferSize = this._useInstancing ? 10 : 12;\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexBufferSize += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            this._vertexBufferSize += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            this._vertexBufferSize += 4;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        const vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);\r\n        this._vertexData = new Float32Array(this._capacity * vertexSize);\r\n        this._vertexBuffer = new Buffer(engine, this._vertexData, true, vertexSize);\r\n\r\n        let dataOffset = 0;\r\n        const positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = positions;\r\n        dataOffset += 3;\r\n\r\n        const colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[VertexBuffer.ColorKind] = colors;\r\n        dataOffset += 4;\r\n\r\n        const options = this._vertexBuffer.createVertexBuffer(\"angle\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"angle\"] = options;\r\n        dataOffset += 1;\r\n\r\n        const size = this._vertexBuffer.createVertexBuffer(\"size\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n        this._vertexBuffers[\"size\"] = size;\r\n        dataOffset += 2;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            const cellIndexBuffer = this._vertexBuffer.createVertexBuffer(\"cellIndex\", dataOffset, 1, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"cellIndex\"] = cellIndexBuffer;\r\n            dataOffset += 1;\r\n        }\r\n\r\n        if (!this._isBillboardBased || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            const directionBuffer = this._vertexBuffer.createVertexBuffer(\"direction\", dataOffset, 3, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"direction\"] = directionBuffer;\r\n            dataOffset += 3;\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            const rampDataBuffer = this._vertexBuffer.createVertexBuffer(\"remapData\", dataOffset, 4, this._vertexBufferSize, this._useInstancing);\r\n            this._vertexBuffers[\"remapData\"] = rampDataBuffer;\r\n            dataOffset += 4;\r\n        }\r\n\r\n        let offsets: VertexBuffer;\r\n        if (this._useInstancing) {\r\n            const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n            this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n            offsets = this._spriteBuffer.createVertexBuffer(\"offset\", 0, 2);\r\n        } else {\r\n            offsets = this._vertexBuffer.createVertexBuffer(\"offset\", dataOffset, 2, this._vertexBufferSize, this._useInstancing);\r\n            dataOffset += 2;\r\n        }\r\n        this._vertexBuffers[\"offset\"] = offsets;\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    private _createIndexBuffer() {\r\n        if (this._useInstancing) {\r\n            return;\r\n        }\r\n        const indices = [];\r\n        let index = 0;\r\n        for (let count = 0; count < this._capacity; count++) {\r\n            indices.push(index);\r\n            indices.push(index + 1);\r\n            indices.push(index + 2);\r\n            indices.push(index);\r\n            indices.push(index + 2);\r\n            indices.push(index + 3);\r\n            index += 4;\r\n        }\r\n\r\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of particles active at the same time.\r\n     * @returns The max number of active particles.\r\n     */\r\n    public getCapacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets whether there are still active particles in the system.\r\n     * @returns True if it is alive, otherwise false.\r\n     */\r\n    public isAlive(): boolean {\r\n        return this._alive;\r\n    }\r\n\r\n    /**\r\n     * Gets if the system has been started. (Note: this will still be true after stop is called)\r\n     * @returns True if it has been started, otherwise false.\r\n     */\r\n    public isStarted(): boolean {\r\n        return this._started;\r\n    }\r\n\r\n    private _prepareSubEmitterInternalArray() {\r\n        this._subEmitters = new Array<Array<SubEmitter>>();\r\n        if (this.subEmitters) {\r\n            this.subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter instanceof ParticleSystem) {\r\n                    this._subEmitters.push([new SubEmitter(subEmitter)]);\r\n                } else if (subEmitter instanceof SubEmitter) {\r\n                    this._subEmitters.push([subEmitter]);\r\n                } else if (subEmitter instanceof Array) {\r\n                    this._subEmitters.push(subEmitter);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the particle system and begins to emit\r\n     * @param delay defines the delay in milliseconds before starting the system (this.startDelay by default)\r\n     */\r\n    public start(delay = this.startDelay): void {\r\n        if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {\r\n            throw \"Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set\";\r\n        }\r\n        if (delay) {\r\n            setTimeout(() => {\r\n                this.start(0);\r\n            }, delay);\r\n            return;\r\n        }\r\n        // Convert the subEmitters field to the constant type field _subEmitters\r\n        this._prepareSubEmitterInternalArray();\r\n\r\n        this._started = true;\r\n        this._stopped = false;\r\n        this._actualFrame = 0;\r\n        if (this._subEmitters && this._subEmitters.length != 0) {\r\n            this.activeSubSystems = new Array<ParticleSystem>();\r\n        }\r\n\r\n        // Reset emit gradient so it acts the same on every start\r\n        if (this._emitRateGradients) {\r\n            if (this._emitRateGradients.length > 0) {\r\n                this._currentEmitRateGradient = this._emitRateGradients[0];\r\n                this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();\r\n                this._currentEmitRate2 = this._currentEmitRate1;\r\n            }\r\n            if (this._emitRateGradients.length > 1) {\r\n                this._currentEmitRate2 = this._emitRateGradients[1].getFactor();\r\n            }\r\n        }\r\n        // Reset start size gradient so it acts the same on every start\r\n        if (this._startSizeGradients) {\r\n            if (this._startSizeGradients.length > 0) {\r\n                this._currentStartSizeGradient = this._startSizeGradients[0];\r\n                this._currentStartSize1 = this._currentStartSizeGradient.getFactor();\r\n                this._currentStartSize2 = this._currentStartSize1;\r\n            }\r\n            if (this._startSizeGradients.length > 1) {\r\n                this._currentStartSize2 = this._startSizeGradients[1].getFactor();\r\n            }\r\n        }\r\n\r\n        if (this.preWarmCycles) {\r\n            if (this.emitter?.getClassName().indexOf(\"Mesh\") !== -1) {\r\n                (this.emitter as any).computeWorldMatrix(true);\r\n            }\r\n\r\n            const noiseTextureAsProcedural = this.noiseTexture as ProceduralTexture;\r\n\r\n            if (noiseTextureAsProcedural && noiseTextureAsProcedural.onGeneratedObservable) {\r\n                noiseTextureAsProcedural.onGeneratedObservable.addOnce(() => {\r\n                    setTimeout(() => {\r\n                        for (let index = 0; index < this.preWarmCycles; index++) {\r\n                            this.animate(true);\r\n                            noiseTextureAsProcedural.render();\r\n                        }\r\n                    });\r\n                });\r\n            } else {\r\n                for (let index = 0; index < this.preWarmCycles; index++) {\r\n                    this.animate(true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Animations\r\n        if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {\r\n            this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the particle system.\r\n     * @param stopSubEmitters if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.\r\n     */\r\n    public stop(stopSubEmitters = true): void {\r\n        if (this._stopped) {\r\n            return;\r\n        }\r\n\r\n        this.onStoppedObservable.notifyObservers(this);\r\n\r\n        this._stopped = true;\r\n\r\n        if (stopSubEmitters) {\r\n            this._stopSubEmitters();\r\n        }\r\n    }\r\n\r\n    // animation sheet\r\n\r\n    /**\r\n     * Remove all active particles\r\n     */\r\n    public reset(): void {\r\n        this._stockParticles.length = 0;\r\n        this._particles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal (for internal use only)\r\n     */\r\n    public _appendParticleVertex(index: number, particle: Particle, offsetX: number, offsetY: number): void {\r\n        let offset = index * this._vertexBufferSize;\r\n\r\n        this._vertexData[offset++] = particle.position.x + this.worldOffset.x;\r\n        this._vertexData[offset++] = particle.position.y + this.worldOffset.y;\r\n        this._vertexData[offset++] = particle.position.z + this.worldOffset.z;\r\n        this._vertexData[offset++] = particle.color.r;\r\n        this._vertexData[offset++] = particle.color.g;\r\n        this._vertexData[offset++] = particle.color.b;\r\n        this._vertexData[offset++] = particle.color.a;\r\n        this._vertexData[offset++] = particle.angle;\r\n\r\n        this._vertexData[offset++] = particle.scale.x * particle.size;\r\n        this._vertexData[offset++] = particle.scale.y * particle.size;\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            this._vertexData[offset++] = particle.cellIndex;\r\n        }\r\n\r\n        if (!this._isBillboardBased) {\r\n            if (particle._initialDirection) {\r\n                let initialDirection = particle._initialDirection;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    initialDirection = TmpVectors.Vector3[0];\r\n                }\r\n                if (initialDirection.x === 0 && initialDirection.z === 0) {\r\n                    initialDirection.x = 0.001;\r\n                }\r\n\r\n                this._vertexData[offset++] = initialDirection.x;\r\n                this._vertexData[offset++] = initialDirection.y;\r\n                this._vertexData[offset++] = initialDirection.z;\r\n            } else {\r\n                let direction = particle.direction;\r\n                if (this.isLocal) {\r\n                    Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);\r\n                    direction = TmpVectors.Vector3[0];\r\n                }\r\n\r\n                if (direction.x === 0 && direction.z === 0) {\r\n                    direction.x = 0.001;\r\n                }\r\n                this._vertexData[offset++] = direction.x;\r\n                this._vertexData[offset++] = direction.y;\r\n                this._vertexData[offset++] = direction.z;\r\n            }\r\n        } else if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED || this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n            this._vertexData[offset++] = particle.direction.x;\r\n            this._vertexData[offset++] = particle.direction.y;\r\n            this._vertexData[offset++] = particle.direction.z;\r\n        }\r\n\r\n        if (this._useRampGradients && particle.remapData) {\r\n            this._vertexData[offset++] = particle.remapData.x;\r\n            this._vertexData[offset++] = particle.remapData.y;\r\n            this._vertexData[offset++] = particle.remapData.z;\r\n            this._vertexData[offset++] = particle.remapData.w;\r\n        }\r\n\r\n        if (!this._useInstancing) {\r\n            if (this._isAnimationSheetEnabled) {\r\n                if (offsetX === 0) {\r\n                    offsetX = this._epsilon;\r\n                } else if (offsetX === 1) {\r\n                    offsetX = 1 - this._epsilon;\r\n                }\r\n\r\n                if (offsetY === 0) {\r\n                    offsetY = this._epsilon;\r\n                } else if (offsetY === 1) {\r\n                    offsetY = 1 - this._epsilon;\r\n                }\r\n            }\r\n\r\n            this._vertexData[offset++] = offsetX;\r\n            this._vertexData[offset++] = offsetY;\r\n        }\r\n    }\r\n\r\n    // start of sub system methods\r\n\r\n    /**\r\n     * \"Recycles\" one of the particle by copying it back to the \"stock\" of particles and removing it from the active list.\r\n     * Its lifetime will start back at 0.\r\n     * @param particle\r\n     */\r\n    public recycleParticle: (particle: Particle) => void = (particle) => {\r\n        // move particle from activeParticle list to stock particles\r\n        const lastParticle = <Particle>this._particles.pop();\r\n        if (lastParticle !== particle) {\r\n            lastParticle.copyTo(particle);\r\n        }\r\n        this._stockParticles.push(lastParticle);\r\n    };\r\n\r\n    private _stopSubEmitters(): void {\r\n        if (!this.activeSubSystems) {\r\n            return;\r\n        }\r\n        this.activeSubSystems.forEach((subSystem) => {\r\n            subSystem.stop(true);\r\n        });\r\n        this.activeSubSystems = new Array<ParticleSystem>();\r\n    }\r\n\r\n    private _createParticle: () => Particle = () => {\r\n        let particle: Particle;\r\n        if (this._stockParticles.length !== 0) {\r\n            particle = <Particle>this._stockParticles.pop();\r\n            particle._reset();\r\n        } else {\r\n            particle = new Particle(this);\r\n        }\r\n\r\n        // Attach emitters\r\n        if (this._subEmitters && this._subEmitters.length > 0) {\r\n            const subEmitters = this._subEmitters[Math.floor(Math.random() * this._subEmitters.length)];\r\n            particle._attachedSubEmitters = [];\r\n            subEmitters.forEach((subEmitter) => {\r\n                if (subEmitter.type === SubEmitterType.ATTACHED) {\r\n                    const newEmitter = subEmitter.clone();\r\n                    (<Array<SubEmitter>>particle._attachedSubEmitters).push(newEmitter);\r\n                    newEmitter.particleSystem.start();\r\n                }\r\n            });\r\n        }\r\n        return particle;\r\n    };\r\n\r\n    private _removeFromRoot(): void {\r\n        if (!this._rootParticleSystem) {\r\n            return;\r\n        }\r\n\r\n        const index = this._rootParticleSystem.activeSubSystems.indexOf(this);\r\n        if (index !== -1) {\r\n            this._rootParticleSystem.activeSubSystems.splice(index, 1);\r\n        }\r\n\r\n        this._rootParticleSystem = null;\r\n    }\r\n\r\n    private _emitFromParticle: (particle: Particle) => void = (particle) => {\r\n        if (!this._subEmitters || this._subEmitters.length === 0) {\r\n            return;\r\n        }\r\n        const templateIndex = Math.floor(Math.random() * this._subEmitters.length);\r\n\r\n        this._subEmitters[templateIndex].forEach((subEmitter) => {\r\n            if (subEmitter.type === SubEmitterType.END) {\r\n                const subSystem = subEmitter.clone();\r\n                particle._inheritParticleInfoToSubEmitter(subSystem);\r\n                subSystem.particleSystem._rootParticleSystem = this;\r\n                this.activeSubSystems.push(subSystem.particleSystem);\r\n                subSystem.particleSystem.start();\r\n            }\r\n        });\r\n    };\r\n\r\n    // End of sub system methods\r\n\r\n    private _update(newParticles: number): void {\r\n        // Update current\r\n        this._alive = this._particles.length > 0;\r\n\r\n        if ((<AbstractMesh>this.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>this.emitter;\r\n            this._emitterWorldMatrix = emitterMesh.getWorldMatrix();\r\n        } else {\r\n            const emitterPosition = <Vector3>this.emitter;\r\n            this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);\r\n        }\r\n\r\n        this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);\r\n        this.updateFunction(this._particles);\r\n\r\n        // Add new ones\r\n        let particle: Particle;\r\n        for (let index = 0; index < newParticles; index++) {\r\n            if (this._particles.length === this._capacity) {\r\n                break;\r\n            }\r\n\r\n            particle = this._createParticle();\r\n\r\n            this._particles.push(particle);\r\n\r\n            // Life time\r\n            if (this.targetStopDuration && this._lifeTimeGradients && this._lifeTimeGradients.length > 0) {\r\n                const ratio = Scalar.Clamp(this._actualFrame / this.targetStopDuration);\r\n                GradientHelper.GetCurrentGradient(ratio, this._lifeTimeGradients, (currentGradient, nextGradient) => {\r\n                    const factorGradient1 = <FactorGradient>currentGradient;\r\n                    const factorGradient2 = <FactorGradient>nextGradient;\r\n                    const lifeTime1 = factorGradient1.getFactor();\r\n                    const lifeTime2 = factorGradient2.getFactor();\r\n                    const gradient = (ratio - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);\r\n                    particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);\r\n                });\r\n            } else {\r\n                particle.lifeTime = Scalar.RandomRange(this.minLifeTime, this.maxLifeTime);\r\n            }\r\n\r\n            // Emitter\r\n            const emitPower = Scalar.RandomRange(this.minEmitPower, this.maxEmitPower);\r\n\r\n            if (this.startPositionFunction) {\r\n                this.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startPositionFunction(this._emitterWorldMatrix, particle.position, particle, this.isLocal);\r\n            }\r\n\r\n            if (this.isLocal) {\r\n                if (!particle._localPosition) {\r\n                    particle._localPosition = particle.position.clone();\r\n                } else {\r\n                    particle._localPosition.copyFrom(particle.position);\r\n                }\r\n                Vector3.TransformCoordinatesToRef(particle._localPosition!, this._emitterWorldMatrix, particle.position);\r\n            }\r\n\r\n            if (this.startDirectionFunction) {\r\n                this.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal);\r\n            } else {\r\n                this.particleEmitterType.startDirectionFunction(this._emitterWorldMatrix, particle.direction, particle, this.isLocal, this._emitterInverseWorldMatrix);\r\n            }\r\n\r\n            if (emitPower === 0) {\r\n                if (!particle._initialDirection) {\r\n                    particle._initialDirection = particle.direction.clone();\r\n                } else {\r\n                    particle._initialDirection.copyFrom(particle.direction);\r\n                }\r\n            } else {\r\n                particle._initialDirection = null;\r\n            }\r\n\r\n            particle.direction.scaleInPlace(emitPower);\r\n\r\n            // Size\r\n            if (!this._sizeGradients || this._sizeGradients.length === 0) {\r\n                particle.size = Scalar.RandomRange(this.minSize, this.maxSize);\r\n            } else {\r\n                particle._currentSizeGradient = this._sizeGradients[0];\r\n                particle._currentSize1 = particle._currentSizeGradient.getFactor();\r\n                particle.size = particle._currentSize1;\r\n\r\n                if (this._sizeGradients.length > 1) {\r\n                    particle._currentSize2 = this._sizeGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentSize2 = particle._currentSize1;\r\n                }\r\n            }\r\n            // Size and scale\r\n            particle.scale.copyFromFloats(Scalar.RandomRange(this.minScaleX, this.maxScaleX), Scalar.RandomRange(this.minScaleY, this.maxScaleY));\r\n\r\n            // Adjust scale by start size\r\n            if (this._startSizeGradients && this._startSizeGradients[0] && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._startSizeGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentStartSizeGradient) {\r\n                        this._currentStartSize1 = this._currentStartSize2;\r\n                        this._currentStartSize2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentStartSizeGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    const value = Scalar.Lerp(this._currentStartSize1, this._currentStartSize2, scale);\r\n                    particle.scale.scaleInPlace(value);\r\n                });\r\n            }\r\n\r\n            // Angle\r\n            if (!this._angularSpeedGradients || this._angularSpeedGradients.length === 0) {\r\n                particle.angularSpeed = Scalar.RandomRange(this.minAngularSpeed, this.maxAngularSpeed);\r\n            } else {\r\n                particle._currentAngularSpeedGradient = this._angularSpeedGradients[0];\r\n                particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();\r\n                particle._currentAngularSpeed1 = particle.angularSpeed;\r\n\r\n                if (this._angularSpeedGradients.length > 1) {\r\n                    particle._currentAngularSpeed2 = this._angularSpeedGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentAngularSpeed2 = particle._currentAngularSpeed1;\r\n                }\r\n            }\r\n            particle.angle = Scalar.RandomRange(this.minInitialRotation, this.maxInitialRotation);\r\n\r\n            // Velocity\r\n            if (this._velocityGradients && this._velocityGradients.length > 0) {\r\n                particle._currentVelocityGradient = this._velocityGradients[0];\r\n                particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();\r\n\r\n                if (this._velocityGradients.length > 1) {\r\n                    particle._currentVelocity2 = this._velocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentVelocity2 = particle._currentVelocity1;\r\n                }\r\n            }\r\n\r\n            // Limit velocity\r\n            if (this._limitVelocityGradients && this._limitVelocityGradients.length > 0) {\r\n                particle._currentLimitVelocityGradient = this._limitVelocityGradients[0];\r\n                particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();\r\n\r\n                if (this._limitVelocityGradients.length > 1) {\r\n                    particle._currentLimitVelocity2 = this._limitVelocityGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentLimitVelocity2 = particle._currentLimitVelocity1;\r\n                }\r\n            }\r\n\r\n            // Drag\r\n            if (this._dragGradients && this._dragGradients.length > 0) {\r\n                particle._currentDragGradient = this._dragGradients[0];\r\n                particle._currentDrag1 = particle._currentDragGradient.getFactor();\r\n\r\n                if (this._dragGradients.length > 1) {\r\n                    particle._currentDrag2 = this._dragGradients[1].getFactor();\r\n                } else {\r\n                    particle._currentDrag2 = particle._currentDrag1;\r\n                }\r\n            }\r\n\r\n            // Color\r\n            if (!this._colorGradients || this._colorGradients.length === 0) {\r\n                const step = Scalar.RandomRange(0, 1.0);\r\n\r\n                Color4.LerpToRef(this.color1, this.color2, step, particle.color);\r\n\r\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\r\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\r\n            } else {\r\n                particle._currentColorGradient = this._colorGradients[0];\r\n                particle._currentColorGradient.getColorToRef(particle.color);\r\n                particle._currentColor1.copyFrom(particle.color);\r\n\r\n                if (this._colorGradients.length > 1) {\r\n                    this._colorGradients[1].getColorToRef(particle._currentColor2);\r\n                } else {\r\n                    particle._currentColor2.copyFrom(particle.color);\r\n                }\r\n            }\r\n\r\n            // Sheet\r\n            if (this._isAnimationSheetEnabled) {\r\n                particle._initialStartSpriteCellID = this.startSpriteCellID;\r\n                particle._initialEndSpriteCellID = this.endSpriteCellID;\r\n                particle._initialSpriteCellLoop = this.spriteCellLoop;\r\n            }\r\n\r\n            // Inherited Velocity\r\n            particle.direction.addInPlace(this._inheritedVelocityOffset);\r\n\r\n            // Ramp\r\n            if (this._useRampGradients) {\r\n                particle.remapData = new Vector4(0, 1, 0, 1);\r\n            }\r\n\r\n            // Noise texture coordinates\r\n            if (this.noiseTexture) {\r\n                if (particle._randomNoiseCoordinates1) {\r\n                    particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());\r\n                } else {\r\n                    particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                    particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());\r\n                }\r\n            }\r\n\r\n            // Update the position of the attached sub-emitters to match their attached particle\r\n            particle._inheritParticleInfoToSubEmitters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetAttributeNamesOrOptions(isAnimationSheetEnabled = false, isBillboardBased = false, useRampGradients = false): string[] {\r\n        const attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, \"angle\", \"offset\", \"size\"];\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            attributeNamesOrOptions.push(\"cellIndex\");\r\n        }\r\n\r\n        if (!isBillboardBased) {\r\n            attributeNamesOrOptions.push(\"direction\");\r\n        }\r\n\r\n        if (useRampGradients) {\r\n            attributeNamesOrOptions.push(\"remapData\");\r\n        }\r\n\r\n        return attributeNamesOrOptions;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetEffectCreationOptions(isAnimationSheetEnabled = false, useLogarithmicDepth = false): string[] {\r\n        const effectCreationOption = [\"invView\", \"view\", \"projection\", \"textureMask\", \"translationPivot\", \"eyePosition\"];\r\n\r\n        addClipPlaneUniforms(effectCreationOption);\r\n\r\n        if (isAnimationSheetEnabled) {\r\n            effectCreationOption.push(\"particlesInfos\");\r\n        }\r\n        if (useLogarithmicDepth) {\r\n            effectCreationOption.push(\"logarithmicDepthConstant\");\r\n        }\r\n\r\n        return effectCreationOption;\r\n    }\r\n\r\n    /**\r\n     * Fill the defines array according to the current settings of the particle system\r\n     * @param defines Array to be updated\r\n     * @param blendMode blend mode to take into account when updating the array\r\n     */\r\n    public fillDefines(defines: Array<string>, blendMode: number) {\r\n        if (this._scene) {\r\n            prepareDefinesForClipPlanes(this, this._scene, defines);\r\n        }\r\n\r\n        if (this._isAnimationSheetEnabled) {\r\n            defines.push(\"#define ANIMATESHEET\");\r\n        }\r\n\r\n        if (this.useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n        }\r\n\r\n        if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {\r\n            defines.push(\"#define BLENDMULTIPLYMODE\");\r\n        }\r\n\r\n        if (this._useRampGradients) {\r\n            defines.push(\"#define RAMPGRADIENT\");\r\n        }\r\n\r\n        if (this._isBillboardBased) {\r\n            defines.push(\"#define BILLBOARD\");\r\n\r\n            switch (this.billboardMode) {\r\n                case ParticleSystem.BILLBOARDMODE_Y:\r\n                    defines.push(\"#define BILLBOARDY\");\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED:\r\n                case ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL:\r\n                    defines.push(\"#define BILLBOARDSTRETCHED\");\r\n                    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL) {\r\n                        defines.push(\"#define BILLBOARDSTRETCHED_LOCAL\");\r\n                    }\r\n                    break;\r\n                case ParticleSystem.BILLBOARDMODE_ALL:\r\n                    defines.push(\"#define BILLBOARDMODE_ALL\");\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);\r\n            defines.push(this._imageProcessingConfigurationDefines.toString());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fill the uniforms, attributes and samplers arrays according to the current settings of the particle system\r\n     * @param uniforms Uniforms array to fill\r\n     * @param attributes Attributes array to fill\r\n     * @param samplers Samplers array to fill\r\n     */\r\n    public fillUniformsAttributesAndSamplerNames(uniforms: Array<string>, attributes: Array<string>, samplers: Array<string>) {\r\n        attributes.push(\r\n            ...ParticleSystem._GetAttributeNamesOrOptions(\r\n                this._isAnimationSheetEnabled,\r\n                this._isBillboardBased && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED && this.billboardMode !== ParticleSystem.BILLBOARDMODE_STRETCHED_LOCAL,\r\n                this._useRampGradients\r\n            )\r\n        );\r\n\r\n        uniforms.push(...ParticleSystem._GetEffectCreationOptions(this._isAnimationSheetEnabled, this.useLogarithmicDepth));\r\n\r\n        samplers.push(\"diffuseSampler\", \"rampSampler\");\r\n\r\n        if (this._imageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _getWrapper(blendMode: number): DrawWrapper {\r\n        const customWrapper = this._getCustomDrawWrapper(blendMode);\r\n\r\n        if (customWrapper?.effect) {\r\n            return customWrapper;\r\n        }\r\n\r\n        const defines: Array<string> = [];\r\n\r\n        this.fillDefines(defines, blendMode);\r\n\r\n        // Effect\r\n        const currentRenderPassId = this._engine._features.supportRenderPasses ? (this._engine as Engine).currentRenderPassId : Constants.RENDERPASS_MAIN;\r\n        let drawWrappers = this._drawWrappers[currentRenderPassId];\r\n        if (!drawWrappers) {\r\n            drawWrappers = this._drawWrappers[currentRenderPassId] = [];\r\n        }\r\n        let drawWrapper = drawWrappers[blendMode];\r\n        if (!drawWrapper) {\r\n            drawWrapper = new DrawWrapper(this._engine);\r\n            if (drawWrapper.drawContext) {\r\n                drawWrapper.drawContext.useInstancing = this._useInstancing;\r\n            }\r\n            drawWrappers[blendMode] = drawWrapper;\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n        if (drawWrapper.defines !== join) {\r\n            const attributesNamesOrOptions: Array<string> = [];\r\n            const effectCreationOption: Array<string> = [];\r\n            const samplers: Array<string> = [];\r\n\r\n            this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);\r\n\r\n            drawWrapper.setEffect(this._engine.createEffect(\"particles\", attributesNamesOrOptions, effectCreationOption, samplers, join), join);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Animates the particle system for the current frame by emitting new particles and or animating the living ones.\r\n     * @param preWarmOnly will prevent the system from updating the vertex buffer (default is false)\r\n     */\r\n    public animate(preWarmOnly = false): void {\r\n        if (!this._started) {\r\n            return;\r\n        }\r\n\r\n        if (!preWarmOnly && this._scene) {\r\n            // Check\r\n            if (!this.isReady()) {\r\n                return;\r\n            }\r\n\r\n            if (this._currentRenderId === this._scene.getFrameId()) {\r\n                return;\r\n            }\r\n            this._currentRenderId = this._scene.getFrameId();\r\n        }\r\n\r\n        this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : this._scene?.getAnimationRatio() || 1);\r\n\r\n        // Determine the number of particles we need to create\r\n        let newParticles;\r\n\r\n        if (this.manualEmitCount > -1) {\r\n            newParticles = this.manualEmitCount;\r\n            this._newPartsExcess = 0;\r\n            this.manualEmitCount = 0;\r\n        } else {\r\n            let rate = this.emitRate;\r\n\r\n            if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {\r\n                const ratio = this._actualFrame / this.targetStopDuration;\r\n                GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, (currentGradient, nextGradient, scale) => {\r\n                    if (currentGradient !== this._currentEmitRateGradient) {\r\n                        this._currentEmitRate1 = this._currentEmitRate2;\r\n                        this._currentEmitRate2 = (<FactorGradient>nextGradient).getFactor();\r\n                        this._currentEmitRateGradient = <FactorGradient>currentGradient;\r\n                    }\r\n\r\n                    rate = Scalar.Lerp(this._currentEmitRate1, this._currentEmitRate2, scale);\r\n                });\r\n            }\r\n\r\n            newParticles = (rate * this._scaledUpdateSpeed) >> 0;\r\n            this._newPartsExcess += rate * this._scaledUpdateSpeed - newParticles;\r\n        }\r\n\r\n        if (this._newPartsExcess > 1.0) {\r\n            newParticles += this._newPartsExcess >> 0;\r\n            this._newPartsExcess -= this._newPartsExcess >> 0;\r\n        }\r\n\r\n        this._alive = false;\r\n\r\n        if (!this._stopped) {\r\n            this._actualFrame += this._scaledUpdateSpeed;\r\n\r\n            if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {\r\n                this.stop();\r\n            }\r\n        } else {\r\n            newParticles = 0;\r\n        }\r\n        this._update(newParticles);\r\n\r\n        // Stopped?\r\n        if (this._stopped) {\r\n            if (!this._alive) {\r\n                this._started = false;\r\n                if (this.onAnimationEnd) {\r\n                    this.onAnimationEnd();\r\n                }\r\n                if (this.disposeOnStop && this._scene) {\r\n                    this._scene._toBeDisposed.push(this);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!preWarmOnly) {\r\n            // Update VBO\r\n            let offset = 0;\r\n            for (let index = 0; index < this._particles.length; index++) {\r\n                const particle = this._particles[index];\r\n                this._appendParticleVertices(offset, particle);\r\n                offset += this._useInstancing ? 1 : 4;\r\n            }\r\n\r\n            if (this._vertexBuffer) {\r\n                this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);\r\n            }\r\n        }\r\n\r\n        if (this.manualEmitCount === 0 && this.disposeOnStop) {\r\n            this.stop();\r\n        }\r\n    }\r\n\r\n    private _appendParticleVertices(offset: number, particle: Particle) {\r\n        this._appendParticleVertex(offset++, particle, 0, 0);\r\n        if (!this._useInstancing) {\r\n            this._appendParticleVertex(offset++, particle, 1, 0);\r\n            this._appendParticleVertex(offset++, particle, 1, 1);\r\n            this._appendParticleVertex(offset++, particle, 0, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the particle system.\r\n     */\r\n    public rebuild(): void {\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        this._spriteBuffer?._rebuild();\r\n\r\n        this._vertexBuffer?._rebuild();\r\n\r\n        for (const key in this._vertexBuffers) {\r\n            this._vertexBuffers[key]._rebuild();\r\n        }\r\n\r\n        this.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * Is this system ready to be used/rendered\r\n     * @returns true if the system is ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (!this.emitter || (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady()) || !this.particleTexture || !this.particleTexture.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            if (!this._getWrapper(this.blendMode).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect!.isReady()) {\r\n                return false;\r\n            }\r\n            if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect!.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _render(blendMode: number) {\r\n        const drawWrapper = this._getWrapper(blendMode);\r\n        const effect = drawWrapper.effect!;\r\n\r\n        const engine = this._engine;\r\n\r\n        // Render\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        const viewMatrix = this.defaultViewMatrix ?? this._scene!.getViewMatrix();\r\n        effect.setTexture(\"diffuseSampler\", this.particleTexture);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", this.defaultProjectionMatrix ?? this._scene!.getProjectionMatrix());\r\n\r\n        if (this._isAnimationSheetEnabled && this.particleTexture) {\r\n            const baseSize = this.particleTexture.getBaseSize();\r\n            effect.setFloat3(\"particlesInfos\", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);\r\n        }\r\n\r\n        effect.setVector2(\"translationPivot\", this.translationPivot);\r\n        effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\r\n\r\n        if (this._isBillboardBased && this._scene) {\r\n            const camera = this._scene.activeCamera!;\r\n            effect.setVector3(\"eyePosition\", camera.globalPosition);\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            if (!this._rampGradients || !this._rampGradients.length) {\r\n                this._rampGradientsTexture.dispose();\r\n                this._rampGradientsTexture = null;\r\n            }\r\n            effect.setTexture(\"rampSampler\", this._rampGradientsTexture);\r\n        }\r\n\r\n        const defines = effect.defines;\r\n\r\n        if (this._scene) {\r\n            bindClipPlane(effect, this, this._scene);\r\n        }\r\n\r\n        if (defines.indexOf(\"#define BILLBOARDMODE_ALL\") >= 0) {\r\n            viewMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            effect.setMatrix(\"invView\", TmpVectors.Matrix[0]);\r\n        }\r\n\r\n        if (this._vertexArrayObject !== undefined) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);\r\n            }\r\n\r\n            this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);\r\n        } else {\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n        }\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth && this._scene) {\r\n            MaterialHelper.BindLogDepth(defines, effect, this._scene);\r\n        }\r\n\r\n        // image processing\r\n        if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n            this._imageProcessingConfiguration.bind(effect);\r\n        }\r\n\r\n        // Draw order\r\n        switch (blendMode) {\r\n            case ParticleSystem.BLENDMODE_ADD:\r\n                engine.setAlphaMode(Constants.ALPHA_ADD);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_ONEONE:\r\n                engine.setAlphaMode(Constants.ALPHA_ONEONE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_STANDARD:\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                break;\r\n            case ParticleSystem.BLENDMODE_MULTIPLY:\r\n                engine.setAlphaMode(Constants.ALPHA_MULTIPLY);\r\n                break;\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.notifyObservers(effect);\r\n        }\r\n\r\n        if (this._useInstancing) {\r\n            engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, this._particles.length);\r\n        } else {\r\n            engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, this._particles.length * 6);\r\n        }\r\n\r\n        return this._particles.length;\r\n    }\r\n\r\n    /**\r\n     * Renders the particle system in its current state.\r\n     * @returns the current number of particles\r\n     */\r\n    public render(): number {\r\n        // Check\r\n        if (!this.isReady() || !this._particles.length) {\r\n            return 0;\r\n        }\r\n\r\n        const engine = this._engine as any;\r\n        if (engine.setState) {\r\n            engine.setState(false);\r\n\r\n            if (this.forceDepthWrite) {\r\n                engine.setDepthWrite(true);\r\n            }\r\n        }\r\n\r\n        let outparticles = 0;\r\n\r\n        if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {\r\n            outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY) + this._render(ParticleSystem.BLENDMODE_ADD);\r\n        } else {\r\n            outparticles = this._render(this.blendMode);\r\n        }\r\n\r\n        this._engine.unbindInstanceAttributes();\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return outparticles;\r\n    }\r\n\r\n    /**\r\n     * Disposes the particle system and free the associated resources\r\n     * @param disposeTexture defines if the particle texture must be disposed as well (true by default)\r\n     */\r\n    public dispose(disposeTexture = true): void {\r\n        this.resetDrawCache();\r\n\r\n        if (this._vertexBuffer) {\r\n            this._vertexBuffer.dispose();\r\n            this._vertexBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObject);\r\n            this._vertexArrayObject = null;\r\n        }\r\n\r\n        if (disposeTexture && this.particleTexture) {\r\n            this.particleTexture.dispose();\r\n            this.particleTexture = null;\r\n        }\r\n\r\n        if (disposeTexture && this.noiseTexture) {\r\n            this.noiseTexture.dispose();\r\n            this.noiseTexture = null;\r\n        }\r\n\r\n        if (this._rampGradientsTexture) {\r\n            this._rampGradientsTexture.dispose();\r\n            this._rampGradientsTexture = null;\r\n        }\r\n\r\n        this._removeFromRoot();\r\n\r\n        if (this.subEmitters && !this._subEmitters) {\r\n            this._prepareSubEmitterInternalArray();\r\n        }\r\n\r\n        if (this._subEmitters && this._subEmitters.length) {\r\n            for (let index = 0; index < this._subEmitters.length; index++) {\r\n                for (const subEmitter of this._subEmitters[index]) {\r\n                    subEmitter.dispose();\r\n                }\r\n            }\r\n\r\n            this._subEmitters = [];\r\n            this.subEmitters = [];\r\n        }\r\n\r\n        if (this._disposeEmitterOnDispose && this.emitter && (this.emitter as AbstractMesh).dispose) {\r\n            (<AbstractMesh>this.emitter).dispose(true);\r\n        }\r\n\r\n        if (this._onBeforeDrawParticlesObservable) {\r\n            this._onBeforeDrawParticlesObservable.clear();\r\n        }\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            const index = this._scene.particleSystems.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene.particleSystems.splice(index, 1);\r\n            }\r\n\r\n            this._scene._activeParticleSystems.dispose();\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n        this.onStoppedObservable.clear();\r\n\r\n        this.reset();\r\n    }\r\n\r\n    // Clone\r\n    /**\r\n     * Clones the particle system.\r\n     * @param name The name of the cloned object\r\n     * @param newEmitter The new emitter to use\r\n     * @param cloneTexture Also clone the textures if true\r\n     * @returns the cloned particle system\r\n     */\r\n    public clone(name: string, newEmitter: any, cloneTexture = false): ParticleSystem {\r\n        const custom = { ...this._customWrappers };\r\n        let program: any = null;\r\n        const engine = this._engine as Engine;\r\n        if (engine.createEffectForParticles) {\r\n            if (this.customShader != null) {\r\n                program = this.customShader;\r\n                const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n                const effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n                if (!custom[0]) {\r\n                    this.setCustomEffect(effect, 0);\r\n                } else {\r\n                    custom[0].effect = effect;\r\n                }\r\n            }\r\n        }\r\n\r\n        const serialization = this.serialize(cloneTexture);\r\n        const result = ParticleSystem.Parse(serialization, this._scene || this._engine, this._rootUrl);\r\n        result.name = name;\r\n        result.customShader = program;\r\n        result._customWrappers = custom;\r\n\r\n        if (newEmitter === undefined) {\r\n            newEmitter = this.emitter;\r\n        }\r\n\r\n        if (this.noiseTexture) {\r\n            result.noiseTexture = this.noiseTexture.clone();\r\n        }\r\n\r\n        result.emitter = newEmitter;\r\n        if (!this.preventAutoStart) {\r\n            result.start();\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object\r\n     * @param serializeTexture defines if the texture must be serialized as well\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(serializeTexture = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        ParticleSystem._Serialize(serializationObject, this, serializeTexture);\r\n\r\n        serializationObject.textureMask = this.textureMask.asArray();\r\n        serializationObject.customShader = this.customShader;\r\n        serializationObject.preventAutoStart = this.preventAutoStart;\r\n\r\n        // SubEmitters\r\n        if (this.subEmitters) {\r\n            serializationObject.subEmitters = [];\r\n\r\n            if (!this._subEmitters) {\r\n                this._prepareSubEmitterInternalArray();\r\n            }\r\n\r\n            for (const subs of this._subEmitters) {\r\n                const cell = [];\r\n                for (const sub of subs) {\r\n                    cell.push(sub.serialize(serializeTexture));\r\n                }\r\n\r\n                serializationObject.subEmitters.push(cell);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Serialize(serializationObject: any, particleSystem: IParticleSystem, serializeTexture: boolean) {\r\n        serializationObject.name = particleSystem.name;\r\n        serializationObject.id = particleSystem.id;\r\n\r\n        serializationObject.capacity = particleSystem.getCapacity();\r\n\r\n        serializationObject.disposeOnStop = particleSystem.disposeOnStop;\r\n        serializationObject.manualEmitCount = particleSystem.manualEmitCount;\r\n\r\n        // Emitter\r\n        if ((<AbstractMesh>particleSystem.emitter).position) {\r\n            const emitterMesh = <AbstractMesh>particleSystem.emitter;\r\n            serializationObject.emitterId = emitterMesh.id;\r\n        } else {\r\n            const emitterPosition = <Vector3>particleSystem.emitter;\r\n            serializationObject.emitter = emitterPosition.asArray();\r\n        }\r\n\r\n        // Emitter\r\n        if (particleSystem.particleEmitterType) {\r\n            serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();\r\n        }\r\n\r\n        if (particleSystem.particleTexture) {\r\n            if (serializeTexture) {\r\n                serializationObject.texture = particleSystem.particleTexture.serialize();\r\n            } else {\r\n                serializationObject.textureName = particleSystem.particleTexture.name;\r\n                serializationObject.invertY = !!(particleSystem.particleTexture as any)._invertY;\r\n            }\r\n        }\r\n\r\n        serializationObject.isLocal = particleSystem.isLocal;\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);\r\n        serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;\r\n        serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;\r\n        serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;\r\n        serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;\r\n\r\n        // Particle system\r\n        serializationObject.startDelay = particleSystem.startDelay;\r\n        serializationObject.renderingGroupId = particleSystem.renderingGroupId;\r\n        serializationObject.isBillboardBased = particleSystem.isBillboardBased;\r\n        serializationObject.billboardMode = particleSystem.billboardMode;\r\n        serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;\r\n        serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;\r\n        serializationObject.minSize = particleSystem.minSize;\r\n        serializationObject.maxSize = particleSystem.maxSize;\r\n        serializationObject.minScaleX = particleSystem.minScaleX;\r\n        serializationObject.maxScaleX = particleSystem.maxScaleX;\r\n        serializationObject.minScaleY = particleSystem.minScaleY;\r\n        serializationObject.maxScaleY = particleSystem.maxScaleY;\r\n        serializationObject.minEmitPower = particleSystem.minEmitPower;\r\n        serializationObject.maxEmitPower = particleSystem.maxEmitPower;\r\n        serializationObject.minLifeTime = particleSystem.minLifeTime;\r\n        serializationObject.maxLifeTime = particleSystem.maxLifeTime;\r\n        serializationObject.emitRate = particleSystem.emitRate;\r\n        serializationObject.gravity = particleSystem.gravity.asArray();\r\n        serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();\r\n        serializationObject.color1 = particleSystem.color1.asArray();\r\n        serializationObject.color2 = particleSystem.color2.asArray();\r\n        serializationObject.colorDead = particleSystem.colorDead.asArray();\r\n        serializationObject.updateSpeed = particleSystem.updateSpeed;\r\n        serializationObject.targetStopDuration = particleSystem.targetStopDuration;\r\n        serializationObject.blendMode = particleSystem.blendMode;\r\n        serializationObject.preWarmCycles = particleSystem.preWarmCycles;\r\n        serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;\r\n        serializationObject.minInitialRotation = particleSystem.minInitialRotation;\r\n        serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;\r\n        serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;\r\n        serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;\r\n        serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;\r\n        serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;\r\n        serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;\r\n        serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;\r\n        serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;\r\n        serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;\r\n        serializationObject.useLogarithmicDepth = particleSystem.useLogarithmicDepth;\r\n\r\n        const colorGradients = particleSystem.getColorGradients();\r\n        if (colorGradients) {\r\n            serializationObject.colorGradients = [];\r\n            for (const colorGradient of colorGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorGradient.gradient,\r\n                    color1: colorGradient.color1.asArray(),\r\n                };\r\n\r\n                if (colorGradient.color2) {\r\n                    serializedGradient.color2 = colorGradient.color2.asArray();\r\n                } else {\r\n                    serializedGradient.color2 = colorGradient.color1.asArray();\r\n                }\r\n\r\n                serializationObject.colorGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const rampGradients = particleSystem.getRampGradients();\r\n        if (rampGradients) {\r\n            serializationObject.rampGradients = [];\r\n            for (const rampGradient of rampGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: rampGradient.gradient,\r\n                    color: rampGradient.color.asArray(),\r\n                };\r\n\r\n                serializationObject.rampGradients.push(serializedGradient);\r\n            }\r\n            serializationObject.useRampGradients = particleSystem.useRampGradients;\r\n        }\r\n\r\n        const colorRemapGradients = particleSystem.getColorRemapGradients();\r\n        if (colorRemapGradients) {\r\n            serializationObject.colorRemapGradients = [];\r\n            for (const colorRemapGradient of colorRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: colorRemapGradient.gradient,\r\n                    factor1: colorRemapGradient.factor1,\r\n                };\r\n\r\n                if (colorRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = colorRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.colorRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const alphaRemapGradients = particleSystem.getAlphaRemapGradients();\r\n        if (alphaRemapGradients) {\r\n            serializationObject.alphaRemapGradients = [];\r\n            for (const alphaRemapGradient of alphaRemapGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: alphaRemapGradient.gradient,\r\n                    factor1: alphaRemapGradient.factor1,\r\n                };\r\n\r\n                if (alphaRemapGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = alphaRemapGradient.factor1;\r\n                }\r\n\r\n                serializationObject.alphaRemapGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const sizeGradients = particleSystem.getSizeGradients();\r\n        if (sizeGradients) {\r\n            serializationObject.sizeGradients = [];\r\n            for (const sizeGradient of sizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: sizeGradient.gradient,\r\n                    factor1: sizeGradient.factor1,\r\n                };\r\n\r\n                if (sizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = sizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = sizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.sizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const angularSpeedGradients = particleSystem.getAngularSpeedGradients();\r\n        if (angularSpeedGradients) {\r\n            serializationObject.angularSpeedGradients = [];\r\n            for (const angularSpeedGradient of angularSpeedGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: angularSpeedGradient.gradient,\r\n                    factor1: angularSpeedGradient.factor1,\r\n                };\r\n\r\n                if (angularSpeedGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = angularSpeedGradient.factor1;\r\n                }\r\n\r\n                serializationObject.angularSpeedGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const velocityGradients = particleSystem.getVelocityGradients();\r\n        if (velocityGradients) {\r\n            serializationObject.velocityGradients = [];\r\n            for (const velocityGradient of velocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: velocityGradient.gradient,\r\n                    factor1: velocityGradient.factor1,\r\n                };\r\n\r\n                if (velocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = velocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = velocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.velocityGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const dragGradients = particleSystem.getDragGradients();\r\n        if (dragGradients) {\r\n            serializationObject.dragGradients = [];\r\n            for (const dragGradient of dragGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: dragGradient.gradient,\r\n                    factor1: dragGradient.factor1,\r\n                };\r\n\r\n                if (dragGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = dragGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = dragGradient.factor1;\r\n                }\r\n\r\n                serializationObject.dragGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const emitRateGradients = particleSystem.getEmitRateGradients();\r\n        if (emitRateGradients) {\r\n            serializationObject.emitRateGradients = [];\r\n            for (const emitRateGradient of emitRateGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: emitRateGradient.gradient,\r\n                    factor1: emitRateGradient.factor1,\r\n                };\r\n\r\n                if (emitRateGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = emitRateGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = emitRateGradient.factor1;\r\n                }\r\n\r\n                serializationObject.emitRateGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const startSizeGradients = particleSystem.getStartSizeGradients();\r\n        if (startSizeGradients) {\r\n            serializationObject.startSizeGradients = [];\r\n            for (const startSizeGradient of startSizeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: startSizeGradient.gradient,\r\n                    factor1: startSizeGradient.factor1,\r\n                };\r\n\r\n                if (startSizeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = startSizeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = startSizeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.startSizeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const lifeTimeGradients = particleSystem.getLifeTimeGradients();\r\n        if (lifeTimeGradients) {\r\n            serializationObject.lifeTimeGradients = [];\r\n            for (const lifeTimeGradient of lifeTimeGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: lifeTimeGradient.gradient,\r\n                    factor1: lifeTimeGradient.factor1,\r\n                };\r\n\r\n                if (lifeTimeGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = lifeTimeGradient.factor1;\r\n                }\r\n\r\n                serializationObject.lifeTimeGradients.push(serializedGradient);\r\n            }\r\n        }\r\n\r\n        const limitVelocityGradients = particleSystem.getLimitVelocityGradients();\r\n        if (limitVelocityGradients) {\r\n            serializationObject.limitVelocityGradients = [];\r\n            for (const limitVelocityGradient of limitVelocityGradients) {\r\n                const serializedGradient: any = {\r\n                    gradient: limitVelocityGradient.gradient,\r\n                    factor1: limitVelocityGradient.factor1,\r\n                };\r\n\r\n                if (limitVelocityGradient.factor2 !== undefined) {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor2;\r\n                } else {\r\n                    serializedGradient.factor2 = limitVelocityGradient.factor1;\r\n                }\r\n\r\n                serializationObject.limitVelocityGradients.push(serializedGradient);\r\n            }\r\n\r\n            serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (particleSystem.noiseTexture) {\r\n            serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedParticleSystem: any, particleSystem: IParticleSystem, sceneOrEngine: Scene | ThinEngine, rootUrl: string) {\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            scene = null;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n        }\r\n\r\n        const internalClass = GetClass(\"BABYLON.Texture\");\r\n        if (internalClass && scene) {\r\n            // Texture\r\n            if (parsedParticleSystem.texture) {\r\n                particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl) as BaseTexture;\r\n            } else if (parsedParticleSystem.textureName) {\r\n                particleSystem.particleTexture = new internalClass(\r\n                    rootUrl + parsedParticleSystem.textureName,\r\n                    scene,\r\n                    false,\r\n                    parsedParticleSystem.invertY !== undefined ? parsedParticleSystem.invertY : true\r\n                );\r\n                particleSystem.particleTexture!.name = parsedParticleSystem.textureName;\r\n            }\r\n        }\r\n\r\n        // Emitter\r\n        if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === undefined) {\r\n            particleSystem.emitter = Vector3.Zero();\r\n        } else if (parsedParticleSystem.emitterId && scene) {\r\n            particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);\r\n        } else {\r\n            particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);\r\n        }\r\n\r\n        particleSystem.isLocal = !!parsedParticleSystem.isLocal;\r\n\r\n        // Misc.\r\n        if (parsedParticleSystem.renderingGroupId !== undefined) {\r\n            particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;\r\n        }\r\n\r\n        if (parsedParticleSystem.isBillboardBased !== undefined) {\r\n            particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;\r\n        }\r\n\r\n        if (parsedParticleSystem.billboardMode !== undefined) {\r\n            particleSystem.billboardMode = parsedParticleSystem.billboardMode;\r\n        }\r\n\r\n        if (parsedParticleSystem.useLogarithmicDepth !== undefined) {\r\n            particleSystem.useLogarithmicDepth = parsedParticleSystem.useLogarithmicDepth;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedParticleSystem.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedParticleSystem.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    particleSystem.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;\r\n            particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;\r\n            particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;\r\n            particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;\r\n        }\r\n\r\n        if (parsedParticleSystem.autoAnimate && scene) {\r\n            scene.beginAnimation(\r\n                particleSystem,\r\n                parsedParticleSystem.autoAnimateFrom,\r\n                parsedParticleSystem.autoAnimateTo,\r\n                parsedParticleSystem.autoAnimateLoop,\r\n                parsedParticleSystem.autoAnimateSpeed || 1.0\r\n            );\r\n        }\r\n\r\n        // Particle system\r\n        particleSystem.startDelay = parsedParticleSystem.startDelay | 0;\r\n        particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\r\n        particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\r\n        particleSystem.minSize = parsedParticleSystem.minSize;\r\n        particleSystem.maxSize = parsedParticleSystem.maxSize;\r\n\r\n        if (parsedParticleSystem.minScaleX) {\r\n            particleSystem.minScaleX = parsedParticleSystem.minScaleX;\r\n            particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;\r\n            particleSystem.minScaleY = parsedParticleSystem.minScaleY;\r\n            particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;\r\n        }\r\n\r\n        if (parsedParticleSystem.preWarmCycles !== undefined) {\r\n            particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;\r\n            particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;\r\n        }\r\n\r\n        if (parsedParticleSystem.minInitialRotation !== undefined) {\r\n            particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;\r\n            particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;\r\n        }\r\n\r\n        particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\r\n        particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\r\n        particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\r\n        particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\r\n        particleSystem.emitRate = parsedParticleSystem.emitRate;\r\n        particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);\r\n        if (parsedParticleSystem.noiseStrength) {\r\n            particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);\r\n        }\r\n        particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);\r\n        particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);\r\n        particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);\r\n        particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\r\n        particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\r\n        particleSystem.blendMode = parsedParticleSystem.blendMode;\r\n\r\n        if (parsedParticleSystem.colorGradients) {\r\n            for (const colorGradient of parsedParticleSystem.colorGradients) {\r\n                particleSystem.addColorGradient(\r\n                    colorGradient.gradient,\r\n                    Color4.FromArray(colorGradient.color1),\r\n                    colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : undefined\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.rampGradients) {\r\n            for (const rampGradient of parsedParticleSystem.rampGradients) {\r\n                particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));\r\n            }\r\n            particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;\r\n        }\r\n\r\n        if (parsedParticleSystem.colorRemapGradients) {\r\n            for (const colorRemapGradient of parsedParticleSystem.colorRemapGradients) {\r\n                particleSystem.addColorRemapGradient(\r\n                    colorRemapGradient.gradient,\r\n                    colorRemapGradient.factor1 !== undefined ? colorRemapGradient.factor1 : colorRemapGradient.factor,\r\n                    colorRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.alphaRemapGradients) {\r\n            for (const alphaRemapGradient of parsedParticleSystem.alphaRemapGradients) {\r\n                particleSystem.addAlphaRemapGradient(\r\n                    alphaRemapGradient.gradient,\r\n                    alphaRemapGradient.factor1 !== undefined ? alphaRemapGradient.factor1 : alphaRemapGradient.factor,\r\n                    alphaRemapGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.sizeGradients) {\r\n            for (const sizeGradient of parsedParticleSystem.sizeGradients) {\r\n                particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== undefined ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.angularSpeedGradients) {\r\n            for (const angularSpeedGradient of parsedParticleSystem.angularSpeedGradients) {\r\n                particleSystem.addAngularSpeedGradient(\r\n                    angularSpeedGradient.gradient,\r\n                    angularSpeedGradient.factor1 !== undefined ? angularSpeedGradient.factor1 : angularSpeedGradient.factor,\r\n                    angularSpeedGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.velocityGradients) {\r\n            for (const velocityGradient of parsedParticleSystem.velocityGradients) {\r\n                particleSystem.addVelocityGradient(\r\n                    velocityGradient.gradient,\r\n                    velocityGradient.factor1 !== undefined ? velocityGradient.factor1 : velocityGradient.factor,\r\n                    velocityGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.dragGradients) {\r\n            for (const dragGradient of parsedParticleSystem.dragGradients) {\r\n                particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== undefined ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.emitRateGradients) {\r\n            for (const emitRateGradient of parsedParticleSystem.emitRateGradients) {\r\n                particleSystem.addEmitRateGradient(\r\n                    emitRateGradient.gradient,\r\n                    emitRateGradient.factor1 !== undefined ? emitRateGradient.factor1 : emitRateGradient.factor,\r\n                    emitRateGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.startSizeGradients) {\r\n            for (const startSizeGradient of parsedParticleSystem.startSizeGradients) {\r\n                particleSystem.addStartSizeGradient(\r\n                    startSizeGradient.gradient,\r\n                    startSizeGradient.factor1 !== undefined ? startSizeGradient.factor1 : startSizeGradient.factor,\r\n                    startSizeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.lifeTimeGradients) {\r\n            for (const lifeTimeGradient of parsedParticleSystem.lifeTimeGradients) {\r\n                particleSystem.addLifeTimeGradient(\r\n                    lifeTimeGradient.gradient,\r\n                    lifeTimeGradient.factor1 !== undefined ? lifeTimeGradient.factor1 : lifeTimeGradient.factor,\r\n                    lifeTimeGradient.factor2\r\n                );\r\n            }\r\n        }\r\n\r\n        if (parsedParticleSystem.limitVelocityGradients) {\r\n            for (const limitVelocityGradient of parsedParticleSystem.limitVelocityGradients) {\r\n                particleSystem.addLimitVelocityGradient(\r\n                    limitVelocityGradient.gradient,\r\n                    limitVelocityGradient.factor1 !== undefined ? limitVelocityGradient.factor1 : limitVelocityGradient.factor,\r\n                    limitVelocityGradient.factor2\r\n                );\r\n            }\r\n            particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;\r\n        }\r\n\r\n        if (parsedParticleSystem.noiseTexture && scene) {\r\n            const internalClass = GetClass(\"BABYLON.ProceduralTexture\");\r\n            particleSystem.noiseTexture = internalClass.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);\r\n        }\r\n\r\n        // Emitter\r\n        let emitterType: IParticleEmitterType;\r\n        if (parsedParticleSystem.particleEmitterType) {\r\n            switch (parsedParticleSystem.particleEmitterType.type) {\r\n                case \"SphereParticleEmitter\":\r\n                    emitterType = new SphereParticleEmitter();\r\n                    break;\r\n                case \"SphereDirectedParticleEmitter\":\r\n                    emitterType = new SphereDirectedParticleEmitter();\r\n                    break;\r\n                case \"ConeEmitter\":\r\n                case \"ConeParticleEmitter\":\r\n                    emitterType = new ConeParticleEmitter();\r\n                    break;\r\n                case \"CylinderParticleEmitter\":\r\n                    emitterType = new CylinderParticleEmitter();\r\n                    break;\r\n                case \"CylinderDirectedParticleEmitter\":\r\n                    emitterType = new CylinderDirectedParticleEmitter();\r\n                    break;\r\n                case \"HemisphericParticleEmitter\":\r\n                    emitterType = new HemisphericParticleEmitter();\r\n                    break;\r\n                case \"PointParticleEmitter\":\r\n                    emitterType = new PointParticleEmitter();\r\n                    break;\r\n                case \"MeshParticleEmitter\":\r\n                    emitterType = new MeshParticleEmitter();\r\n                    break;\r\n                case \"BoxEmitter\":\r\n                case \"BoxParticleEmitter\":\r\n                default:\r\n                    emitterType = new BoxParticleEmitter();\r\n                    break;\r\n            }\r\n\r\n            emitterType.parse(parsedParticleSystem.particleEmitterType, scene);\r\n        } else {\r\n            emitterType = new BoxParticleEmitter();\r\n            emitterType.parse(parsedParticleSystem, scene);\r\n        }\r\n        particleSystem.particleEmitterType = emitterType;\r\n\r\n        // Animation sheet\r\n        particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;\r\n        particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;\r\n        particleSystem.spriteCellLoop = parsedParticleSystem.spriteCellLoop ?? true;\r\n        particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;\r\n        particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;\r\n        particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;\r\n        particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;\r\n\r\n        particleSystem.disposeOnStop = parsedParticleSystem.disposeOnStop ?? false;\r\n        particleSystem.manualEmitCount = parsedParticleSystem.manualEmitCount ?? -1;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a particle system.\r\n     * @param parsedParticleSystem The JSON object to parse\r\n     * @param sceneOrEngine The scene or the engine to create the particle system in\r\n     * @param rootUrl The root url to use to load external dependencies like texture\r\n     * @param doNotStart Ignore the preventAutoStart attribute and does not start\r\n     * @param capacity defines the system capacity (if null or undefined the sotred capacity will be used)\r\n     * @returns the Parsed particle system\r\n     */\r\n    public static Parse(parsedParticleSystem: any, sceneOrEngine: Scene | ThinEngine, rootUrl: string, doNotStart = false, capacity?: number): ParticleSystem {\r\n        const name = parsedParticleSystem.name;\r\n        let custom: Nullable<Effect> = null;\r\n        let program: any = null;\r\n        let engine: ThinEngine;\r\n        let scene: Nullable<Scene>;\r\n\r\n        if (sceneOrEngine instanceof ThinEngine) {\r\n            engine = sceneOrEngine;\r\n        } else {\r\n            scene = sceneOrEngine as Scene;\r\n            engine = scene.getEngine();\r\n        }\r\n\r\n        if (parsedParticleSystem.customShader && (engine as any).createEffectForParticles) {\r\n            program = parsedParticleSystem.customShader;\r\n            const defines: string = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join(\"\\n\") : \"\";\r\n            custom = (engine as any).createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\r\n        }\r\n        const particleSystem = new ParticleSystem(name, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);\r\n        particleSystem.customShader = program;\r\n        particleSystem._rootUrl = rootUrl;\r\n\r\n        if (parsedParticleSystem.id) {\r\n            particleSystem.id = parsedParticleSystem.id;\r\n        }\r\n\r\n        // SubEmitters\r\n        if (parsedParticleSystem.subEmitters) {\r\n            particleSystem.subEmitters = [];\r\n            for (const cell of parsedParticleSystem.subEmitters) {\r\n                const cellArray = [];\r\n                for (const sub of cell) {\r\n                    cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));\r\n                }\r\n\r\n                particleSystem.subEmitters.push(cellArray);\r\n            }\r\n        }\r\n\r\n        ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);\r\n\r\n        if (parsedParticleSystem.textureMask) {\r\n            particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);\r\n        }\r\n\r\n        // Auto start\r\n        if (parsedParticleSystem.preventAutoStart) {\r\n            particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\r\n        }\r\n\r\n        if (!doNotStart && !particleSystem.preventAutoStart) {\r\n            particleSystem.start();\r\n        }\r\n\r\n        return particleSystem;\r\n    }\r\n}\r\n\r\nSubEmitter._ParseParticleSystem = ParticleSystem.Parse;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}