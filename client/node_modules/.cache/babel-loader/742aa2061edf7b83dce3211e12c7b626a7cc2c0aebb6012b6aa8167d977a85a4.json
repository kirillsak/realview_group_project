{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { Path2 } from \"../Maths/math.path.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/**\n * Vector2 wth index property\n */\nclass IndexedVector2 extends Vector2 {\n  constructor(original, /** Index of the vector2 */\n  index) {\n    super(original.x, original.y);\n    this.index = index;\n  }\n}\n/**\n * Defines points to create a polygon\n */\nclass PolygonPoints {\n  constructor() {\n    this.elements = new Array();\n  }\n  add(originalPoints) {\n    const result = new Array();\n    originalPoints.forEach(point => {\n      const newPoint = new IndexedVector2(point, this.elements.length);\n      result.push(newPoint);\n      this.elements.push(newPoint);\n    });\n    return result;\n  }\n  computeBounds() {\n    const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\n    const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\n    this.elements.forEach(point => {\n      // x\n      if (point.x < lmin.x) {\n        lmin.x = point.x;\n      } else if (point.x > lmax.x) {\n        lmax.x = point.x;\n      }\n      // y\n      if (point.y < lmin.y) {\n        lmin.y = point.y;\n      } else if (point.y > lmax.y) {\n        lmax.y = point.y;\n      }\n    });\n    return {\n      min: lmin,\n      max: lmax,\n      width: lmax.x - lmin.x,\n      height: lmax.y - lmin.y\n    };\n  }\n}\n/**\n * Polygon\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\n */\nexport class Polygon {\n  /**\n   * Creates a rectangle\n   * @param xmin bottom X coord\n   * @param ymin bottom Y coord\n   * @param xmax top X coord\n   * @param ymax top Y coord\n   * @returns points that make the resulting rectangle\n   */\n  static Rectangle(xmin, ymin, xmax, ymax) {\n    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\n  }\n  /**\n   * Creates a circle\n   * @param radius radius of circle\n   * @param cx scale in x\n   * @param cy scale in y\n   * @param numberOfSides number of sides that make up the circle\n   * @returns points that make the resulting circle\n   */\n  static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {\n    const result = new Array();\n    let angle = 0;\n    const increment = Math.PI * 2 / numberOfSides;\n    for (let i = 0; i < numberOfSides; i++) {\n      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n      angle -= increment;\n    }\n    return result;\n  }\n  /**\n   * Creates a polygon from input string\n   * @param input Input polygon data\n   * @returns the parsed points\n   */\n  static Parse(input) {\n    const floats = input.split(/[^-+eE.\\d]+/).map(parseFloat).filter(val => !isNaN(val));\n    let i;\n    const result = [];\n    for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\n      result.push(new Vector2(floats[i], floats[i + 1]));\n    }\n    return result;\n  }\n  /**\n   * Starts building a polygon from x and y coordinates\n   * @param x x coordinate\n   * @param y y coordinate\n   * @returns the started path2\n   */\n  static StartingAt(x, y) {\n    return Path2.StartingAt(x, y);\n  }\n}\n/**\n * Builds a polygon\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\n */\nexport class PolygonMeshBuilder {\n  /**\n   * Creates a PolygonMeshBuilder\n   * @param name name of the builder\n   * @param contours Path of the polygon\n   * @param scene scene to add to when creating the mesh\n   * @param earcutInjection can be used to inject your own earcut reference\n   */\n  constructor(name, contours, scene, earcutInjection = earcut) {\n    this._points = new PolygonPoints();\n    this._outlinepoints = new PolygonPoints();\n    this._holes = new Array();\n    this._epoints = new Array();\n    this._eholes = new Array();\n    this.bjsEarcut = earcutInjection;\n    this._name = name;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    let points;\n    if (contours instanceof Path2) {\n      points = contours.getPoints();\n    } else {\n      points = contours;\n    }\n    this._addToepoint(points);\n    this._points.add(points);\n    this._outlinepoints.add(points);\n    if (typeof this.bjsEarcut === \"undefined\") {\n      Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\n    }\n  }\n  _addToepoint(points) {\n    for (const p of points) {\n      this._epoints.push(p.x, p.y);\n    }\n  }\n  /**\n   * Adds a hole within the polygon\n   * @param hole Array of points defining the hole\n   * @returns this\n   */\n  addHole(hole) {\n    this._points.add(hole);\n    const holepoints = new PolygonPoints();\n    holepoints.add(hole);\n    this._holes.push(holepoints);\n    this._eholes.push(this._epoints.length / 2);\n    this._addToepoint(hole);\n    return this;\n  }\n  /**\n   * Creates the polygon\n   * @param updatable If the mesh should be updatable\n   * @param depth The depth of the mesh created\n   * @param smoothingThreshold Dot product threshold for smoothed normals\n   * @returns the created mesh\n   */\n  build(updatable = false, depth = 0, smoothingThreshold = 2) {\n    const result = new Mesh(this._name, this._scene);\n    const vertexData = this.buildVertexData(depth, smoothingThreshold);\n    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);\n    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);\n    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);\n    result.setIndices(vertexData.indices);\n    return result;\n  }\n  /**\n   * Creates the polygon\n   * @param depth The depth of the mesh created\n   * @param smoothingThreshold Dot product threshold for smoothed normals\n   * @returns the created VertexData\n   */\n  buildVertexData(depth = 0, smoothingThreshold = 2) {\n    const result = new VertexData();\n    const normals = new Array();\n    const positions = new Array();\n    const uvs = new Array();\n    const bounds = this._points.computeBounds();\n    this._points.elements.forEach(p => {\n      normals.push(0, 1.0, 0);\n      positions.push(p.x, 0, p.y);\n      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n    });\n    const indices = new Array();\n    const res = this.bjsEarcut(this._epoints, this._eholes, 2);\n    for (let i = 0; i < res.length; i++) {\n      indices.push(res[i]);\n    }\n    if (depth > 0) {\n      const positionscount = positions.length / 3; //get the current pointcount\n      this._points.elements.forEach(p => {\n        //add the elements at the depth\n        normals.push(0, -1.0, 0);\n        positions.push(p.x, -depth, p.y);\n        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n      });\n      const totalCount = indices.length;\n      for (let i = 0; i < totalCount; i += 3) {\n        const i0 = indices[i + 0];\n        const i1 = indices[i + 1];\n        const i2 = indices[i + 2];\n        indices.push(i2 + positionscount);\n        indices.push(i1 + positionscount);\n        indices.push(i0 + positionscount);\n      }\n      //Add the sides\n      this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\n      this._holes.forEach(hole => {\n        this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\n      });\n    }\n    result.indices = indices;\n    result.positions = positions;\n    result.normals = normals;\n    result.uvs = uvs;\n    return result;\n  }\n  /**\n   * Adds a side to the polygon\n   * @param positions points that make the polygon\n   * @param normals normals of the polygon\n   * @param uvs uvs of the polygon\n   * @param indices indices of the polygon\n   * @param bounds bounds of the polygon\n   * @param points points of the polygon\n   * @param depth depth of the polygon\n   * @param flip flip of the polygon\n   * @param smoothingThreshold\n   */\n  _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {\n    let startIndex = positions.length / 3;\n    let ulength = 0;\n    for (let i = 0; i < points.elements.length; i++) {\n      const p = points.elements[i];\n      const p1 = points.elements[(i + 1) % points.elements.length];\n      positions.push(p.x, 0, p.y);\n      positions.push(p.x, -depth, p.y);\n      positions.push(p1.x, 0, p1.y);\n      positions.push(p1.x, -depth, p1.y);\n      const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];\n      const p2 = points.elements[(i + 2) % points.elements.length];\n      let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\n      let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\n      let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\n      if (!flip) {\n        vc = vc.scale(-1);\n        vp = vp.scale(-1);\n        vn = vn.scale(-1);\n      }\n      const vc_norm = vc.normalizeToNew();\n      let vp_norm = vp.normalizeToNew();\n      let vn_norm = vn.normalizeToNew();\n      const dotp = Vector3.Dot(vp_norm, vc_norm);\n      if (dotp > smoothingThreshold) {\n        if (dotp < Epsilon - 1) {\n          vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\n        } else {\n          // cheap average weighed by side length\n          vp_norm = vp.add(vc).normalize();\n        }\n      } else {\n        vp_norm = vc_norm;\n      }\n      const dotn = Vector3.Dot(vn, vc);\n      if (dotn > smoothingThreshold) {\n        if (dotn < Epsilon - 1) {\n          // back to back\n          vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\n        } else {\n          // cheap average weighed by side length\n          vn_norm = vn.add(vc).normalize();\n        }\n      } else {\n        vn_norm = vc_norm;\n      }\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      ulength += vc.length();\n      uvs.push(ulength / bounds.width, 0);\n      uvs.push(ulength / bounds.width, 1);\n      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n      normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\n      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n      normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\n      if (!flip) {\n        indices.push(startIndex);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 3);\n        indices.push(startIndex + 2);\n      } else {\n        indices.push(startIndex);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 1);\n        indices.push(startIndex + 2);\n        indices.push(startIndex + 3);\n      }\n      startIndex += 4;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","Vector3","Vector2","VertexBuffer","Mesh","VertexData","Path2","Epsilon","EngineStore","IndexedVector2","constructor","original","index","x","y","PolygonPoints","Array","add","originalPoints","result","forEach","point","newPoint","elements","length","push","computeBounds","lmin","lmax","min","max","width","height","Polygon","Rectangle","xmin","ymin","xmax","ymax","Circle","radius","cx","cy","numberOfSides","angle","increment","Math","PI","i","cos","sin","Parse","input","floats","split","map","parseFloat","filter","val","isNaN","StartingAt","PolygonMeshBuilder","name","contours","scene","earcutInjection","earcut","bjsEarcut","_name","_scene","LastCreatedScene","points","getPoints","_addToepoint","_points","_outlinepoints","Warn","p","_epoints","addHole","hole","holepoints","_holes","_eholes","build","updatable","depth","smoothingThreshold","vertexData","buildVertexData","setVerticesData","PositionKind","positions","NormalKind","normals","UVKind","uvs","setIndices","indices","bounds","res","positionscount","totalCount","i0","i1","i2","_addSide","flip","startIndex","ulength","p1","p0","p2","vc","vp","vn","scale","vc_norm","normalizeToNew","vp_norm","vn_norm","dotp","Dot","subtract","normalize","dotn","z"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/polygonMesh.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Path2 } from \"../Maths/math.path\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare let earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number\r\n    ) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = new Array<IndexedVector2>();\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n        const result = new Array<IndexedVector2>();\r\n        originalPoints.forEach((point) => {\r\n            const newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        this.elements.forEach((point) => {\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            } else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            } else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n        });\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectangle\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        const result = new Array<Vector2>();\r\n\r\n        let angle = 0;\r\n        const increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (let i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        const floats = input\r\n            .split(/[^-+eE.\\d]+/)\r\n            .map(parseFloat)\r\n            .filter((val) => !isNaN(val));\r\n        let i: number;\r\n        const result = [];\r\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (const p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        let points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = (<Path2>contours).getPoints();\r\n        } else {\r\n            points = <Vector2[]>contours;\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === \"undefined\") {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a hole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        const holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0, smoothingThreshold: number = 2): Mesh {\r\n        const result = new Mesh(this._name, this._scene);\r\n\r\n        const vertexData = this.buildVertexData(depth, smoothingThreshold);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0, smoothingThreshold: number = 2): VertexData {\r\n        const result = new VertexData();\r\n\r\n        const normals = new Array<number>();\r\n        const positions = new Array<number>();\r\n        const uvs = new Array<number>();\r\n\r\n        const bounds = this._points.computeBounds();\r\n        this._points.elements.forEach((p) => {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        });\r\n\r\n        const indices = new Array<number>();\r\n\r\n        const res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            const positionscount = positions.length / 3; //get the current pointcount\r\n\r\n            this._points.elements.forEach((p) => {\r\n                //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            });\r\n\r\n            const totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                const i0 = indices[i + 0];\r\n                const i1 = indices[i + 1];\r\n                const i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\r\n\r\n            this._holes.forEach((hole) => {\r\n                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\r\n            });\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     * @param smoothingThreshold\r\n     */\r\n    private _addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean, smoothingThreshold: number) {\r\n        let startIndex: number = positions.length / 3;\r\n        let ulength: number = 0;\r\n        for (let i: number = 0; i < points.elements.length; i++) {\r\n            const p: IndexedVector2 = points.elements[i];\r\n            const p1: IndexedVector2 = points.elements[(i + 1) % points.elements.length];\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            const p0: IndexedVector2 = points.elements[(i + points.elements.length - 1) % points.elements.length];\r\n            const p2: IndexedVector2 = points.elements[(i + 2) % points.elements.length];\r\n\r\n            let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\r\n            let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\r\n            let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\r\n\r\n            if (!flip) {\r\n                vc = vc.scale(-1);\r\n                vp = vp.scale(-1);\r\n                vn = vn.scale(-1);\r\n            }\r\n\r\n            const vc_norm = vc.normalizeToNew();\r\n            let vp_norm = vp.normalizeToNew();\r\n            let vn_norm = vn.normalizeToNew();\r\n\r\n            const dotp = Vector3.Dot(vp_norm, vc_norm);\r\n            if (dotp > smoothingThreshold) {\r\n                if (dotp < Epsilon - 1) {\r\n                    vp_norm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vp_norm = vp.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vp_norm = vc_norm;\r\n            }\r\n\r\n            const dotn = Vector3.Dot(vn, vc);\r\n            if (dotn > smoothingThreshold) {\r\n                if (dotn < Epsilon - 1) {\r\n                    // back to back\r\n                    vn_norm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vn_norm = vn.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vn_norm = vc_norm;\r\n            }\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += vc.length();\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vp_norm.x, vp_norm.y, vp_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n            normals.push(vn_norm.x, vn_norm.y, vn_norm.z);\r\n\r\n            if (!flip) {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 3);\r\n                indices.push(startIndex + 2);\r\n            } else {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 1);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 3);\r\n            }\r\n            startIndex += 4;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}