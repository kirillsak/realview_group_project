{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Matrix, TmpVectors, Vector2 } from \"../Maths/math.vector.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration.js\";\nimport \"../Animations/animatable.js\";\nimport \"../Rendering/geometryBufferRendererSceneComponent.js\";\nimport \"../Shaders/motionBlur.fragment.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\n * As an example, all you have to do is to create the post-process:\n *  var mb = new BABYLON.MotionBlurPostProcess(\n *      'mb', // The name of the effect.\n *      scene, // The scene containing the objects to blur according to their velocity.\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\n *      camera // The camera to apply the render pass to.\n * );\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\n */\nexport class MotionBlurPostProcess extends PostProcess {\n  /**\n   * Creates a new instance MotionBlurPostProcess\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to blur according to their velocity.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n  constructor(name, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {\n    super(name, \"motionBlur\", [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\", \"projection\"], [\"velocitySampler\", \"depthSampler\"], options, camera, samplingMode, engine, reusable, \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\", textureType, undefined, null, blockCompilation);\n    /**\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\n     */\n    this.motionStrength = 1;\n    this._motionBlurSamples = 32;\n    this._isObjectBased = true;\n    this._forceGeometryBuffer = false;\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    // Set up assets\n    if (this._forceGeometryBuffer) {\n      scene.enableGeometryBufferRenderer();\n      if (this._geometryBufferRenderer) {\n        this._geometryBufferRenderer.enableVelocity = true;\n      }\n    } else {\n      scene.enablePrePassRenderer();\n      if (this._prePassRenderer) {\n        this._prePassRenderer.markAsDirty();\n        this._prePassEffectConfiguration = new MotionBlurConfiguration();\n      }\n    }\n    this._applyMode();\n  }\n  /**\n   * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\n   */\n  get motionBlurSamples() {\n    return this._motionBlurSamples;\n  }\n  /**\n   * Sets the number of iterations to be used for motion blur quality\n   */\n  set motionBlurSamples(samples) {\n    this._motionBlurSamples = samples;\n    this._updateEffect();\n  }\n  /**\n   * Gets whether or not the motion blur post-process is in object based mode.\n   */\n  get isObjectBased() {\n    return this._isObjectBased;\n  }\n  /**\n   * Sets whether or not the motion blur post-process is in object based mode.\n   */\n  set isObjectBased(value) {\n    if (this._isObjectBased === value) {\n      return;\n    }\n    this._isObjectBased = value;\n    this._applyMode();\n  }\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"MotionBlurPostProcess\" string\n   */\n  getClassName() {\n    return \"MotionBlurPostProcess\";\n  }\n  /**\n   * Excludes the given skinned mesh from computing bones velocities.\n   * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\n   * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\n   */\n  excludeSkinnedMesh(skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      let list;\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n      list.push(skinnedMesh);\n    }\n  }\n  /**\n   * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\n   * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\n   * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\n   */\n  removeExcludedSkinnedMesh(skinnedMesh) {\n    if (skinnedMesh.skeleton) {\n      let list;\n      if (this._geometryBufferRenderer) {\n        list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\n      } else if (this._prePassRenderer) {\n        list = this._prePassRenderer.excludedSkinnedMesh;\n      } else {\n        return;\n      }\n      const index = list.indexOf(skinnedMesh);\n      if (index !== -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Disposes the post process.\n   * @param camera The camera to dispose the post process on.\n   */\n  dispose(camera) {\n    if (this._geometryBufferRenderer) {\n      // Clear previous transformation matrices dictionary used to compute objects velocities\n      this._geometryBufferRenderer._previousTransformationMatrices = {};\n      this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\n      this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\n    }\n    super.dispose(camera);\n  }\n  /**\n   * Called on the mode changed (object based or screen based).\n   */\n  _applyMode() {\n    if (!this._geometryBufferRenderer && !this._prePassRenderer) {\n      // We can't get a velocity or depth texture. So, work as a passthrough.\n      Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\n      return this.updateEffect();\n    }\n    this._updateEffect();\n    this._invViewProjection = null;\n    this._previousViewProjection = null;\n    if (this.isObjectBased) {\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 2;\n      }\n      this.onApply = effect => this._onApplyObjectBased(effect);\n    } else {\n      this._invViewProjection = Matrix.Identity();\n      this._previousViewProjection = this._scene.getTransformMatrix().clone();\n      if (this._prePassRenderer && this._prePassEffectConfiguration) {\n        this._prePassEffectConfiguration.texturesRequired[0] = 5;\n      }\n      this.onApply = effect => this._onApplyScreenBased(effect);\n    }\n  }\n  /**\n   * Called on the effect is applied when the motion blur post-process is in object based mode.\n   * @param effect\n   */\n  _onApplyObjectBased(effect) {\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n    if (this._geometryBufferRenderer) {\n      const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\n      effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n    } else if (this._prePassRenderer) {\n      const velocityIndex = this._prePassRenderer.getIndex(2);\n      effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\n    }\n  }\n  /**\n   * Called on the effect is applied when the motion blur post-process is in screen based mode.\n   * @param effect\n   */\n  _onApplyScreenBased(effect) {\n    const viewProjection = TmpVectors.Matrix[0];\n    viewProjection.copyFrom(this._scene.getTransformMatrix());\n    viewProjection.invertToRef(this._invViewProjection);\n    effect.setMatrix(\"inverseViewProjection\", this._invViewProjection);\n    effect.setMatrix(\"prevViewProjection\", this._previousViewProjection);\n    this._previousViewProjection.copyFrom(viewProjection);\n    effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n    effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\n    effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\n    effect.setFloat(\"motionStrength\", this.motionStrength);\n    if (this._geometryBufferRenderer) {\n      const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\n      effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n    } else if (this._prePassRenderer) {\n      const depthIndex = this._prePassRenderer.getIndex(5);\n      effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\n    }\n  }\n  /**\n   * Called on the effect must be updated (changed mode, samples count, etc.).\n   */\n  _updateEffect() {\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      const defines = [\"#define GEOMETRY_SUPPORTED\", \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1), this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\"];\n      this.updateEffect(defines.join(\"\\n\"));\n    }\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new MotionBlurPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, false);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"motionStrength\", void 0);\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"motionBlurSamples\", null);\n__decorate([serialize()], MotionBlurPostProcess.prototype, \"isObjectBased\", null);\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);","map":{"version":3,"mappings":"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","names":["Logger","Matrix","TmpVectors","Vector2","PostProcess","GeometryBufferRenderer","MotionBlurConfiguration","serialize","SerializationHelper","RegisterClass","MotionBlurPostProcess","constructor","name","scene","options","camera","samplingMode","engine","reusable","textureType","undefined","blockCompilation","_forceGeometryBuffer","forceGeometryBuffer","enableGeometryBufferRenderer","_geometryBufferRenderer","enableVelocity","enablePrePassRenderer","_prePassRenderer","markAsDirty","_prePassEffectConfiguration","_applyMode","motionBlurSamples","_motionBlurSamples","samples","_updateEffect","isObjectBased","_isObjectBased","value","_scene","geometryBufferRenderer","prePassRenderer","getClassName","excludeSkinnedMesh","skinnedMesh","skeleton","list","excludedSkinnedMeshesFromVelocity","excludedSkinnedMesh","push","removeExcludedSkinnedMesh","index","indexOf","splice","dispose","_previousTransformationMatrices","_previousBonesTransformationMatrices","Warn","updateEffect","_invViewProjection","_previousViewProjection","texturesRequired","onApply","effect","_onApplyObjectBased","Identity","getTransformMatrix","clone","_onApplyScreenBased","setVector2","width","height","setFloat","getAnimationRatio","motionStrength","velocityIndex","getTextureIndex","VELOCITY_TEXTURE_TYPE","setTexture","getGBuffer","textures","getIndex","getRenderTarget","viewProjection","copyFrom","invertToRef","setMatrix","getProjectionMatrix","depthIndex","DEPTH_TEXTURE_TYPE","defines","toFixed","join","_Parse","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode","getEngine","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/motionBlurPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Matrix, TmpVectors, Vector2 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { MotionBlurConfiguration } from \"../Rendering/motionBlurConfiguration\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\n\r\nimport \"../Animations/animatable\";\r\nimport \"../Rendering/geometryBufferRendererSceneComponent\";\r\nimport \"../Shaders/motionBlur.fragment\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The Motion Blur Post Process which blurs an image based on the objects velocity in scene.\r\n * Velocity can be affected by each object's rotation, position and scale depending on the transformation speed.\r\n * As an example, all you have to do is to create the post-process:\r\n *  var mb = new BABYLON.MotionBlurPostProcess(\r\n *      'mb', // The name of the effect.\r\n *      scene, // The scene containing the objects to blur according to their velocity.\r\n *      1.0, // The required width/height ratio to downsize to before computing the render pass.\r\n *      camera // The camera to apply the render pass to.\r\n * );\r\n * Then, all objects moving, rotating and/or scaling will be blurred depending on the transformation speed.\r\n */\r\nexport class MotionBlurPostProcess extends PostProcess {\r\n    /**\r\n     * Defines how much the image is blurred by the movement. Default value is equal to 1\r\n     */\r\n    @serialize()\r\n    public motionStrength: number = 1;\r\n\r\n    /**\r\n     * Gets the number of iterations are used for motion blur quality. Default value is equal to 32\r\n     */\r\n    @serialize()\r\n    public get motionBlurSamples(): number {\r\n        return this._motionBlurSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of iterations to be used for motion blur quality\r\n     */\r\n    public set motionBlurSamples(samples: number) {\r\n        this._motionBlurSamples = samples;\r\n        this._updateEffect();\r\n    }\r\n\r\n    private _motionBlurSamples: number = 32;\r\n\r\n    /**\r\n     * Gets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    @serialize()\r\n    public get isObjectBased(): boolean {\r\n        return this._isObjectBased;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the motion blur post-process is in object based mode.\r\n     */\r\n    public set isObjectBased(value: boolean) {\r\n        if (this._isObjectBased === value) {\r\n            return;\r\n        }\r\n\r\n        this._isObjectBased = value;\r\n        this._applyMode();\r\n    }\r\n\r\n    private _isObjectBased: boolean = true;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _invViewProjection: Nullable<Matrix> = null;\r\n    private _previousViewProjection: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"MotionBlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"MotionBlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance MotionBlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to blur according to their velocity.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"motionBlur\",\r\n            [\"motionStrength\", \"motionScale\", \"screenSize\", \"inverseViewProjection\", \"prevViewProjection\", \"projection\"],\r\n            [\"velocitySampler\", \"depthSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define GEOMETRY_SUPPORTED\\n#define SAMPLES 64.0\\n#define OBJECT_BASED\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        // Set up assets\r\n        if (this._forceGeometryBuffer) {\r\n            scene.enableGeometryBufferRenderer();\r\n\r\n            if (this._geometryBufferRenderer) {\r\n                this._geometryBufferRenderer.enableVelocity = true;\r\n            }\r\n        } else {\r\n            scene.enablePrePassRenderer();\r\n\r\n            if (this._prePassRenderer) {\r\n                this._prePassRenderer.markAsDirty();\r\n                this._prePassEffectConfiguration = new MotionBlurConfiguration();\r\n            }\r\n        }\r\n\r\n        this._applyMode();\r\n    }\r\n\r\n    /**\r\n     * Excludes the given skinned mesh from computing bones velocities.\r\n     * Computing bones velocities can have a cost and that cost. The cost can be saved by calling this function and by passing the skinned mesh reference to ignore.\r\n     * @param skinnedMesh The mesh containing the skeleton to ignore when computing the velocity map.\r\n     */\r\n    public excludeSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n            list.push(skinnedMesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the given skinned mesh from the excluded meshes to integrate bones velocities while rendering the velocity map.\r\n     * @param skinnedMesh The mesh containing the skeleton that has been ignored previously.\r\n     * @see excludeSkinnedMesh to exclude a skinned mesh from bones velocity computation.\r\n     */\r\n    public removeExcludedSkinnedMesh(skinnedMesh: AbstractMesh): void {\r\n        if (skinnedMesh.skeleton) {\r\n            let list;\r\n            if (this._geometryBufferRenderer) {\r\n                list = this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity;\r\n            } else if (this._prePassRenderer) {\r\n                list = this._prePassRenderer.excludedSkinnedMesh;\r\n            } else {\r\n                return;\r\n            }\r\n\r\n            const index = list.indexOf(skinnedMesh);\r\n            if (index !== -1) {\r\n                list.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the post process.\r\n     * @param camera The camera to dispose the post process on.\r\n     */\r\n    public dispose(camera?: Camera): void {\r\n        if (this._geometryBufferRenderer) {\r\n            // Clear previous transformation matrices dictionary used to compute objects velocities\r\n            this._geometryBufferRenderer._previousTransformationMatrices = {};\r\n            this._geometryBufferRenderer._previousBonesTransformationMatrices = {};\r\n            this._geometryBufferRenderer.excludedSkinnedMeshesFromVelocity = [];\r\n        }\r\n\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Called on the mode changed (object based or screen based).\r\n     */\r\n    private _applyMode(): void {\r\n        if (!this._geometryBufferRenderer && !this._prePassRenderer) {\r\n            // We can't get a velocity or depth texture. So, work as a passthrough.\r\n            Logger.Warn(\"Multiple Render Target support needed to compute object based motion blur\");\r\n            return this.updateEffect();\r\n        }\r\n\r\n        this._updateEffect();\r\n\r\n        this._invViewProjection = null;\r\n        this._previousViewProjection = null;\r\n\r\n        if (this.isObjectBased) {\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_VELOCITY_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyObjectBased(effect);\r\n        } else {\r\n            this._invViewProjection = Matrix.Identity();\r\n            this._previousViewProjection = this._scene.getTransformMatrix().clone();\r\n\r\n            if (this._prePassRenderer && this._prePassEffectConfiguration) {\r\n                this._prePassEffectConfiguration.texturesRequired[0] = Constants.PREPASS_DEPTH_TEXTURE_TYPE;\r\n            }\r\n\r\n            this.onApply = (effect: Effect) => this._onApplyScreenBased(effect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in object based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyObjectBased(effect: Effect): void {\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const velocityIndex = this._prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE);\r\n            effect.setTexture(\"velocitySampler\", this._prePassRenderer.getRenderTarget().textures[velocityIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect is applied when the motion blur post-process is in screen based mode.\r\n     * @param effect\r\n     */\r\n    private _onApplyScreenBased(effect: Effect): void {\r\n        const viewProjection = TmpVectors.Matrix[0];\r\n        viewProjection.copyFrom(this._scene.getTransformMatrix());\r\n\r\n        viewProjection.invertToRef(this._invViewProjection!);\r\n        effect.setMatrix(\"inverseViewProjection\", this._invViewProjection!);\r\n\r\n        effect.setMatrix(\"prevViewProjection\", this._previousViewProjection!);\r\n        this._previousViewProjection!.copyFrom(viewProjection);\r\n\r\n        effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\r\n\r\n        effect.setVector2(\"screenSize\", new Vector2(this.width, this.height));\r\n\r\n        effect.setFloat(\"motionScale\", this._scene.getAnimationRatio());\r\n        effect.setFloat(\"motionStrength\", this.motionStrength);\r\n\r\n        if (this._geometryBufferRenderer) {\r\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\r\n        } else if (this._prePassRenderer) {\r\n            const depthIndex = this._prePassRenderer.getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE);\r\n            effect.setTexture(\"depthSampler\", this._prePassRenderer.getRenderTarget().textures[depthIndex]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on the effect must be updated (changed mode, samples count, etc.).\r\n     */\r\n    private _updateEffect(): void {\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            const defines: string[] = [\r\n                \"#define GEOMETRY_SUPPORTED\",\r\n                \"#define SAMPLES \" + this._motionBlurSamples.toFixed(1),\r\n                this._isObjectBased ? \"#define OBJECT_BASED\" : \"#define SCREEN_BASED\",\r\n            ];\r\n\r\n            this.updateEffect(defines.join(\"\\n\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<MotionBlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new MotionBlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MotionBlurPostProcess\", MotionBlurPostProcess);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}