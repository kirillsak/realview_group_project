{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { SceneLoader } from \"../../Loading/sceneLoader.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial.js\";\nimport { Material } from \"../../Materials/material.js\";\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder.js\";\nimport { TransformNode } from \"../../Meshes/transformNode.js\";\nimport { Axis } from \"../../Maths/math.axis.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\n\n/**\n * Parts of the hands divided to writs and finger names\n */\nexport var HandPart;\n(function (HandPart) {\n  /**\n   * HandPart - Wrist\n   */\n  HandPart[\"WRIST\"] = \"wrist\";\n  /**\n   * HandPart - The thumb\n   */\n  HandPart[\"THUMB\"] = \"thumb\";\n  /**\n   * HandPart - Index finger\n   */\n  HandPart[\"INDEX\"] = \"index\";\n  /**\n   * HandPart - Middle finger\n   */\n  HandPart[\"MIDDLE\"] = \"middle\";\n  /**\n   * HandPart - Ring finger\n   */\n  HandPart[\"RING\"] = \"ring\";\n  /**\n   * HandPart - Little finger\n   */\n  HandPart[\"LITTLE\"] = \"little\";\n})(HandPart || (HandPart = {}));\n/**\n * Joints of the hand as defined by the WebXR specification.\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\n */\nexport var WebXRHandJoint;\n(function (WebXRHandJoint) {\n  /** Wrist */\n  WebXRHandJoint[\"WRIST\"] = \"wrist\";\n  /** Thumb near wrist */\n  WebXRHandJoint[\"THUMB_METACARPAL\"] = \"thumb-metacarpal\";\n  /** Thumb first knuckle */\n  WebXRHandJoint[\"THUMB_PHALANX_PROXIMAL\"] = \"thumb-phalanx-proximal\";\n  /** Thumb second knuckle */\n  WebXRHandJoint[\"THUMB_PHALANX_DISTAL\"] = \"thumb-phalanx-distal\";\n  /** Thumb tip */\n  WebXRHandJoint[\"THUMB_TIP\"] = \"thumb-tip\";\n  /** Index finger near wrist */\n  WebXRHandJoint[\"INDEX_FINGER_METACARPAL\"] = \"index-finger-metacarpal\";\n  /** Index finger first knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_PROXIMAL\"] = \"index-finger-phalanx-proximal\";\n  /** Index finger second knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_INTERMEDIATE\"] = \"index-finger-phalanx-intermediate\";\n  /** Index finger third knuckle */\n  WebXRHandJoint[\"INDEX_FINGER_PHALANX_DISTAL\"] = \"index-finger-phalanx-distal\";\n  /** Index finger tip */\n  WebXRHandJoint[\"INDEX_FINGER_TIP\"] = \"index-finger-tip\";\n  /** Middle finger near wrist */\n  WebXRHandJoint[\"MIDDLE_FINGER_METACARPAL\"] = \"middle-finger-metacarpal\";\n  /** Middle finger first knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_PROXIMAL\"] = \"middle-finger-phalanx-proximal\";\n  /** Middle finger second knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_INTERMEDIATE\"] = \"middle-finger-phalanx-intermediate\";\n  /** Middle finger third knuckle */\n  WebXRHandJoint[\"MIDDLE_FINGER_PHALANX_DISTAL\"] = \"middle-finger-phalanx-distal\";\n  /** Middle finger tip */\n  WebXRHandJoint[\"MIDDLE_FINGER_TIP\"] = \"middle-finger-tip\";\n  /** Ring finger near wrist */\n  WebXRHandJoint[\"RING_FINGER_METACARPAL\"] = \"ring-finger-metacarpal\";\n  /** Ring finger first knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_PROXIMAL\"] = \"ring-finger-phalanx-proximal\";\n  /** Ring finger second knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_INTERMEDIATE\"] = \"ring-finger-phalanx-intermediate\";\n  /** Ring finger third knuckle */\n  WebXRHandJoint[\"RING_FINGER_PHALANX_DISTAL\"] = \"ring-finger-phalanx-distal\";\n  /** Ring finger tip */\n  WebXRHandJoint[\"RING_FINGER_TIP\"] = \"ring-finger-tip\";\n  /** Pinky finger near wrist */\n  WebXRHandJoint[\"PINKY_FINGER_METACARPAL\"] = \"pinky-finger-metacarpal\";\n  /** Pinky finger first knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_PROXIMAL\"] = \"pinky-finger-phalanx-proximal\";\n  /** Pinky finger second knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_INTERMEDIATE\"] = \"pinky-finger-phalanx-intermediate\";\n  /** Pinky finger third knuckle */\n  WebXRHandJoint[\"PINKY_FINGER_PHALANX_DISTAL\"] = \"pinky-finger-phalanx-distal\";\n  /** Pinky finger tip */\n  WebXRHandJoint[\"PINKY_FINGER_TIP\"] = \"pinky-finger-tip\";\n})(WebXRHandJoint || (WebXRHandJoint = {}));\nconst handJointReferenceArray = [WebXRHandJoint.WRIST, WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP, WebXRHandJoint.INDEX_FINGER_METACARPAL, WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL, WebXRHandJoint.INDEX_FINGER_TIP, WebXRHandJoint.MIDDLE_FINGER_METACARPAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL, WebXRHandJoint.MIDDLE_FINGER_TIP, WebXRHandJoint.RING_FINGER_METACARPAL, WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.RING_FINGER_PHALANX_DISTAL, WebXRHandJoint.RING_FINGER_TIP, WebXRHandJoint.PINKY_FINGER_METACARPAL, WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL, WebXRHandJoint.PINKY_FINGER_TIP];\nconst handPartsDefinition = {\n  [HandPart.WRIST]: [WebXRHandJoint.WRIST],\n  [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\n  [HandPart.INDEX]: [WebXRHandJoint.INDEX_FINGER_METACARPAL, WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL, WebXRHandJoint.INDEX_FINGER_TIP],\n  [HandPart.MIDDLE]: [WebXRHandJoint.MIDDLE_FINGER_METACARPAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL, WebXRHandJoint.MIDDLE_FINGER_TIP],\n  [HandPart.RING]: [WebXRHandJoint.RING_FINGER_METACARPAL, WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.RING_FINGER_PHALANX_DISTAL, WebXRHandJoint.RING_FINGER_TIP],\n  [HandPart.LITTLE]: [WebXRHandJoint.PINKY_FINGER_METACARPAL, WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL, WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE, WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL, WebXRHandJoint.PINKY_FINGER_TIP]\n};\n/**\n * Representing a single hand (with its corresponding native XRHand object)\n */\nexport class WebXRHand {\n  /**\n   * Construct a new hand object\n   * @param xrController The controller to which the hand correlates.\n   * @param _jointMeshes The meshes to be used to track the hand joints.\n   * @param _handMesh An optional hand mesh.\n   * @param rigMapping An optional rig mapping for the hand mesh.\n   *                   If not provided (but a hand mesh is provided),\n   *                   it will be assumed that the hand mesh's bones are named\n   *                   directly after the WebXR bone names.\n   * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\n   * @param _jointsInvisible Are the tracked joint meshes visible\n   * @param _jointScaleFactor Scale factor for all joint meshes\n   */\n  constructor( /** The controller to which the hand correlates. */\n  xrController, _jointMeshes, _handMesh,\n  /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\n   * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\n  rigMapping, _leftHandedMeshes = false, _jointsInvisible = false, _jointScaleFactor = 1) {\n    this.xrController = xrController;\n    this._jointMeshes = _jointMeshes;\n    this._handMesh = _handMesh;\n    this.rigMapping = rigMapping;\n    this._leftHandedMeshes = _leftHandedMeshes;\n    this._jointsInvisible = _jointsInvisible;\n    this._jointScaleFactor = _jointScaleFactor;\n    /**\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\n     */\n    this._jointTransforms = new Array(handJointReferenceArray.length);\n    /**\n     * The float array that will directly receive the transform matrix data from WebXR.\n     */\n    this._jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\n    this._tempJointMatrix = new Matrix();\n    /**\n     * The float array that will directly receive the joint radii from WebXR.\n     */\n    this._jointRadii = new Float32Array(handJointReferenceArray.length);\n    this._scene = _jointMeshes[0].getScene();\n    // Initialize the joint transform quaternions and link the transforms to the bones.\n    for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\n      const jointTransform = this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene);\n      jointTransform.rotationQuaternion = new Quaternion();\n      // Set the rotation quaternion so we can use it later for tracking.\n      _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\n    }\n    if (_handMesh) {\n      // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\n      this.setHandMesh(_handMesh, rigMapping);\n    }\n    // hide the motion controller, if available/loaded\n    if (this.xrController.motionController) {\n      if (this.xrController.motionController.rootMesh) {\n        this.xrController.motionController.rootMesh.setEnabled(false);\n      } else {\n        this.xrController.motionController.onModelLoadedObservable.add(controller => {\n          if (controller.rootMesh) {\n            controller.rootMesh.setEnabled(false);\n          }\n        });\n      }\n    }\n    this.xrController.onMotionControllerInitObservable.add(motionController => {\n      motionController.onModelLoadedObservable.add(controller => {\n        if (controller.rootMesh) {\n          controller.rootMesh.setEnabled(false);\n        }\n      });\n      if (motionController.rootMesh) {\n        motionController.rootMesh.setEnabled(false);\n      }\n    });\n  }\n  /**\n   * Get the hand mesh.\n   */\n  get handMesh() {\n    return this._handMesh;\n  }\n  /**\n   * Get meshes of part of the hand.\n   * @param part The part of hand to get.\n   * @returns An array of meshes that correlate to the hand part requested.\n   */\n  getHandPartMeshes(part) {\n    return handPartsDefinition[part].map(name => this._jointMeshes[handJointReferenceArray.indexOf(name)]);\n  }\n  /**\n   * Retrieves a mesh linked to a named joint in the hand.\n   * @param jointName The name of the joint.\n   * @returns An AbstractMesh whose position corresponds with the joint position.\n   */\n  getJointMesh(jointName) {\n    return this._jointMeshes[handJointReferenceArray.indexOf(jointName)];\n  }\n  /**\n   * Sets the current hand mesh to render for the WebXRHand.\n   * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\n   * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\n   */\n  setHandMesh(handMesh, rigMapping) {\n    this._handMesh = handMesh;\n    // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\n    handMesh.alwaysSelectAsActiveMesh = true;\n    handMesh.getChildMeshes().forEach(mesh => mesh.alwaysSelectAsActiveMesh = true);\n    // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\n    if (this._handMesh.skeleton) {\n      const handMeshSkeleton = this._handMesh.skeleton;\n      handJointReferenceArray.forEach((jointName, jointIdx) => {\n        const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\n        if (jointBoneIdx !== -1) {\n          handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\n        }\n      });\n    }\n  }\n  /**\n   * Update this hand from the latest xr frame.\n   * @param xrFrame The latest frame received from WebXR.\n   * @param referenceSpace The current viewer reference space.\n   */\n  updateFromXRFrame(xrFrame, referenceSpace) {\n    const hand = this.xrController.inputSource.hand;\n    if (!hand) {\n      return;\n    }\n    // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\n    const anyHand = hand;\n    const jointSpaces = handJointReferenceArray.map(jointName => anyHand[jointName] || hand.get(jointName));\n    let trackingSuccessful = false;\n    if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\n      trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\n    } else if (xrFrame.getJointPose) {\n      trackingSuccessful = true;\n      // Warning: This codepath is slow by comparison, only here for compat.\n      for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\n        const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\n        if (jointPose) {\n          this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\n          this._jointRadii[jointIdx] = jointPose.radius || 0.008;\n        } else {\n          trackingSuccessful = false;\n          break;\n        }\n      }\n    }\n    if (!trackingSuccessful) {\n      return;\n    }\n    handJointReferenceArray.forEach((_jointName, jointIdx) => {\n      const jointTransform = this._jointTransforms[jointIdx];\n      Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\n      this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion, jointTransform.position);\n      // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\n      const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\n      const jointMesh = this._jointMeshes[jointIdx];\n      jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\n      jointMesh.position.copyFrom(jointTransform.position);\n      jointMesh.rotationQuaternion.copyFrom(jointTransform.rotationQuaternion);\n      jointMesh.scaling.setAll(scaledJointRadius);\n      // The WebXR data comes as right-handed, so we might need to do some conversions.\n      if (!this._scene.useRightHandedSystem) {\n        jointMesh.position.z *= -1;\n        jointMesh.rotationQuaternion.z *= -1;\n        jointMesh.rotationQuaternion.w *= -1;\n        if (this._leftHandedMeshes && this._handMesh) {\n          jointTransform.position.z *= -1;\n          jointTransform.rotationQuaternion.z *= -1;\n          jointTransform.rotationQuaternion.w *= -1;\n        }\n      }\n    });\n    if (this._handMesh) {\n      this._handMesh.isVisible = true;\n    }\n  }\n  /**\n   * Dispose this Hand object\n   */\n  dispose() {\n    if (this._handMesh) {\n      this._handMesh.isVisible = false;\n    }\n  }\n}\n/**\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\n */\nexport class WebXRHandTracking extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the XR hand tracking feature.\n   * @param _xrSessionManager An instance of WebXRSessionManager.\n   * @param options Options to use when constructing this feature.\n   */\n  constructor(_xrSessionManager, /** Options to use when constructing this feature. */\n  options) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._attachedHands = {};\n    this._trackingHands = {\n      left: null,\n      right: null\n    };\n    this._handResources = {\n      jointMeshes: null,\n      handMeshes: null,\n      rigMappings: null\n    };\n    /**\n     * This observable will notify registered observers when a new hand object was added and initialized\n     */\n    this.onHandAddedObservable = new Observable();\n    /**\n     * This observable will notify its observers right before the hand object is disposed\n     */\n    this.onHandRemovedObservable = new Observable();\n    this._attachHand = xrController => {\n      var _a, _b, _c;\n      if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\n        return;\n      }\n      const handedness = xrController.inputSource.handedness;\n      const webxrHand = new WebXRHand(xrController, this._handResources.jointMeshes[handedness], this._handResources.handMeshes && this._handResources.handMeshes[handedness], this._handResources.rigMappings && this._handResources.rigMappings[handedness], (_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.meshesUseLeftHandedCoordinates, (_b = this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.invisible, (_c = this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.scaleFactor);\n      this._attachedHands[xrController.uniqueId] = webxrHand;\n      this._trackingHands[handedness] = webxrHand;\n      this.onHandAddedObservable.notifyObservers(webxrHand);\n    };\n    this._detachHand = xrController => {\n      this._detachHandById(xrController.uniqueId);\n    };\n    this.xrNativeFeatureName = \"hand-tracking\";\n    // Support legacy versions of the options object by copying over joint mesh properties\n    const anyOptions = options;\n    const anyJointMeshOptions = anyOptions.jointMeshes;\n    if (anyJointMeshOptions) {\n      if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\n      }\n      if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\n      }\n      if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\n      }\n      if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\n        options.handMeshes = options.handMeshes || {};\n        const leftRigMapping = {};\n        const rightRigMapping = {};\n        [[anyJointMeshOptions.rigMapping.left, leftRigMapping], [anyJointMeshOptions.rigMapping.right, rightRigMapping]].forEach(rigMappingTuple => {\n          const legacyRigMapping = rigMappingTuple[0];\n          const rigMapping = rigMappingTuple[1];\n          legacyRigMapping.forEach((modelJointName, index) => {\n            rigMapping[handJointReferenceArray[index]] = modelJointName;\n          });\n        });\n        options.handMeshes.customRigMappings = {\n          left: leftRigMapping,\n          right: rightRigMapping\n        };\n      }\n    }\n  }\n  static _GenerateTrackedJointMeshes(featureOptions) {\n    const meshes = {};\n    [\"left\", \"right\"].map(handedness => {\n      var _a, _b, _c, _d, _e;\n      const trackedMeshes = [];\n      const originalMesh = ((_a = featureOptions.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\n      originalMesh.isVisible = !!((_b = featureOptions.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);\n      for (let i = 0; i < handJointReferenceArray.length; ++i) {\n        let newInstance = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\n        if ((_c = featureOptions.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {\n          const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance, i, handedness);\n          if (returnedMesh) {\n            if (returnedMesh !== newInstance) {\n              newInstance.dispose();\n              newInstance = returnedMesh;\n            }\n          }\n        }\n        newInstance.isPickable = false;\n        if ((_d = featureOptions.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {\n          const props = ((_e = featureOptions.jointMeshes) === null || _e === void 0 ? void 0 : _e.physicsProps) || {};\n          // downscale the instances so that physics will be initialized correctly\n          newInstance.scaling.setAll(0.02);\n          const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\n          newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, {\n            mass: 0,\n            ...props\n          });\n        }\n        newInstance.rotationQuaternion = new Quaternion();\n        newInstance.isVisible = false;\n        trackedMeshes.push(newInstance);\n      }\n      meshes[handedness] = trackedMeshes;\n    });\n    return {\n      left: meshes.left,\n      right: meshes.right\n    };\n  }\n  static _GenerateDefaultHandMeshesAsync(scene, options) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async resolve => {\n      var _a, _b, _c, _d, _e;\n      const riggedMeshes = {};\n      // check the cache, defensive\n      if ((_b = (_a = WebXRHandTracking._RightHandGLB) === null || _a === void 0 ? void 0 : _a.meshes[1]) === null || _b === void 0 ? void 0 : _b.isDisposed()) {\n        WebXRHandTracking._RightHandGLB = null;\n      }\n      if ((_d = (_c = WebXRHandTracking._LeftHandGLB) === null || _c === void 0 ? void 0 : _c.meshes[1]) === null || _d === void 0 ? void 0 : _d.isDisposed()) {\n        WebXRHandTracking._LeftHandGLB = null;\n      }\n      const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\n      // load them in parallel\n      const handGLBs = await Promise.all([WebXRHandTracking._RightHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene), WebXRHandTracking._LeftHandGLB || SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene)]);\n      WebXRHandTracking._RightHandGLB = handGLBs[0];\n      WebXRHandTracking._LeftHandGLB = handGLBs[1];\n      const handShader = new NodeMaterial(\"handShader\", scene, {\n        emitComments: false\n      });\n      await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\n      // depth prepass and alpha mode\n      handShader.needDepthPrePass = true;\n      handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\n      handShader.alphaMode = 2;\n      // build node materials\n      handShader.build(false);\n      // shader\n      const handColors = {\n        base: Color3.FromInts(116, 63, 203),\n        fresnel: Color3.FromInts(149, 102, 229),\n        fingerColor: Color3.FromInts(177, 130, 255),\n        tipFresnel: Color3.FromInts(220, 200, 255),\n        ...((_e = options === null || options === void 0 ? void 0 : options.handMeshes) === null || _e === void 0 ? void 0 : _e.customColors)\n      };\n      const handNodes = {\n        base: handShader.getBlockByName(\"baseColor\"),\n        fresnel: handShader.getBlockByName(\"fresnelColor\"),\n        fingerColor: handShader.getBlockByName(\"fingerColor\"),\n        tipFresnel: handShader.getBlockByName(\"tipFresnelColor\")\n      };\n      handNodes.base.value = handColors.base;\n      handNodes.fresnel.value = handColors.fresnel;\n      handNodes.fingerColor.value = handColors.fingerColor;\n      handNodes.tipFresnel.value = handColors.tipFresnel;\n      [\"left\", \"right\"].forEach(handedness => {\n        const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\n        if (!handGLB) {\n          // this should never happen!\n          throw new Error(\"Could not load hand model\");\n        }\n        const handMesh = handGLB.meshes[1];\n        handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\n        handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\n        handMesh.isVisible = false;\n        riggedMeshes[handedness] = handMesh;\n        // single change for left handed systems\n        if (!handsDefined && !scene.useRightHandedSystem) {\n          handGLB.meshes[1].rotate(Axis.Y, Math.PI);\n        }\n      });\n      handShader.dispose();\n      resolve({\n        left: riggedMeshes.left,\n        right: riggedMeshes.right\n      });\n    });\n  }\n  /**\n   * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\n   * @param handedness The handedness being mapped for.\n   */\n  static _GenerateDefaultHandMeshRigMapping(handedness) {\n    const H = handedness == \"right\" ? \"R\" : \"L\";\n    return {\n      [WebXRHandJoint.WRIST]: `wrist_${H}`,\n      [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\n      [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\n      [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\n      [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\n      [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\n      [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\n      [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\n      [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\n      [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`\n    };\n  }\n  /**\n   * Check if the needed objects are defined.\n   * This does not mean that the feature is enabled, but that the objects needed are well defined.\n   */\n  isCompatible() {\n    return typeof XRHand !== \"undefined\";\n  }\n  /**\n   * Get the hand object according to the controller id\n   * @param controllerId the controller id to which we want to get the hand\n   * @returns null if not found or the WebXRHand object if found\n   */\n  getHandByControllerId(controllerId) {\n    return this._attachedHands[controllerId];\n  }\n  /**\n   * Get a hand object according to the requested handedness\n   * @param handedness the handedness to request\n   * @returns null if not found or the WebXRHand object if found\n   */\n  getHandByHandedness(handedness) {\n    if (handedness == \"none\") {\n      return null;\n    }\n    return this._trackingHands[handedness];\n  }\n  /**\n   * Attach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    var _a, _b, _c, _d;\n    if (!super.attach()) {\n      return false;\n    }\n    this._handResources = {\n      jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\n      handMeshes: ((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes) || null,\n      rigMappings: ((_b = this.options.handMeshes) === null || _b === void 0 ? void 0 : _b.customRigMappings) || null\n    };\n    // If they didn't supply custom meshes and are not disabling the default meshes...\n    if (!((_c = this.options.handMeshes) === null || _c === void 0 ? void 0 : _c.customMeshes) && !((_d = this.options.handMeshes) === null || _d === void 0 ? void 0 : _d.disableDefaultMeshes)) {\n      WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene, this.options).then(defaultHandMeshes => {\n        var _a, _b;\n        this._handResources.handMeshes = defaultHandMeshes;\n        this._handResources.rigMappings = {\n          left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\n          right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\")\n        };\n        // Apply meshes to existing hands if already tracking.\n        (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\n        (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\n      });\n    }\n    this.options.xrInput.controllers.forEach(this._attachHand);\n    this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\n    this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\n    return true;\n  }\n  _onXRFrame(_xrFrame) {\n    var _a, _b;\n    (_a = this._trackingHands.left) === null || _a === void 0 ? void 0 : _a.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n    (_b = this._trackingHands.right) === null || _b === void 0 ? void 0 : _b.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\n  }\n  _detachHandById(controllerId) {\n    var _a;\n    const hand = this.getHandByControllerId(controllerId);\n    if (hand) {\n      const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\n      if (((_a = this._trackingHands[handedness]) === null || _a === void 0 ? void 0 : _a.xrController.uniqueId) === controllerId) {\n        this._trackingHands[handedness] = null;\n      }\n      this.onHandRemovedObservable.notifyObservers(hand);\n      hand.dispose();\n      delete this._attachedHands[controllerId];\n    }\n  }\n  /**\n   * Detach this feature.\n   * Will usually be called by the features manager.\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._attachedHands).forEach(uniqueId => this._detachHandById(uniqueId));\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached.\n   */\n  dispose() {\n    var _a;\n    super.dispose();\n    this.onHandAddedObservable.clear();\n    this.onHandRemovedObservable.clear();\n    if (this._handResources.handMeshes && !((_a = this.options.handMeshes) === null || _a === void 0 ? void 0 : _a.customMeshes)) {\n      // this will dispose the cached meshes\n      this._handResources.handMeshes.left.dispose();\n      this._handResources.handMeshes.right.dispose();\n      // remove the cached meshes\n      WebXRHandTracking._RightHandGLB = null;\n      WebXRHandTracking._LeftHandGLB = null;\n    }\n    if (this._handResources.jointMeshes) {\n      this._handResources.jointMeshes.left.forEach(trackedMesh => trackedMesh.dispose());\n      this._handResources.jointMeshes.right.forEach(trackedMesh => trackedMesh.dispose());\n    }\n  }\n}\n/**\n * The module's name\n */\nWebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHandTracking.Version = 1;\n/** The base URL for the default hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\n/** The filename to use for the default right hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\n/** The filename to use for the default left hand model. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\n/** The URL pointing to the default hand model NodeMaterial shader. */\nWebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\n// We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\nWebXRHandTracking._ICOSPHERE_PARAMS = {\n  radius: 0.5,\n  flat: false,\n  subdivisions: 2\n};\nWebXRHandTracking._RightHandGLB = null;\nWebXRHandTracking._LeftHandGLB = null;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, (xrSessionManager, options) => {\n  return () => new WebXRHandTracking(xrSessionManager, options);\n}, WebXRHandTracking.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRAbstractFeature","WebXRFeatureName","WebXRFeaturesManager","Matrix","Quaternion","PhysicsImpostor","Observable","SceneLoader","Color3","NodeMaterial","Material","CreateIcoSphere","TransformNode","Axis","EngineStore","HandPart","WebXRHandJoint","handJointReferenceArray","WRIST","THUMB_METACARPAL","THUMB_PHALANX_PROXIMAL","THUMB_PHALANX_DISTAL","THUMB_TIP","INDEX_FINGER_METACARPAL","INDEX_FINGER_PHALANX_PROXIMAL","INDEX_FINGER_PHALANX_INTERMEDIATE","INDEX_FINGER_PHALANX_DISTAL","INDEX_FINGER_TIP","MIDDLE_FINGER_METACARPAL","MIDDLE_FINGER_PHALANX_PROXIMAL","MIDDLE_FINGER_PHALANX_INTERMEDIATE","MIDDLE_FINGER_PHALANX_DISTAL","MIDDLE_FINGER_TIP","RING_FINGER_METACARPAL","RING_FINGER_PHALANX_PROXIMAL","RING_FINGER_PHALANX_INTERMEDIATE","RING_FINGER_PHALANX_DISTAL","RING_FINGER_TIP","PINKY_FINGER_METACARPAL","PINKY_FINGER_PHALANX_PROXIMAL","PINKY_FINGER_PHALANX_INTERMEDIATE","PINKY_FINGER_PHALANX_DISTAL","PINKY_FINGER_TIP","handPartsDefinition","THUMB","INDEX","MIDDLE","RING","LITTLE","WebXRHand","constructor","xrController","_jointMeshes","_handMesh","rigMapping","_leftHandedMeshes","_jointsInvisible","_jointScaleFactor","Array","length","Float32Array","_scene","getScene","jointIdx","_jointTransforms","jointTransform","rotationQuaternion","setHandMesh","motionController","rootMesh","setEnabled","onModelLoadedObservable","add","controller","onMotionControllerInitObservable","handMesh","getHandPartMeshes","part","map","name","indexOf","getJointMesh","jointName","alwaysSelectAsActiveMesh","getChildMeshes","forEach","mesh","skeleton","handMeshSkeleton","jointBoneIdx","getBoneIndexByName","bones","linkTransformNode","updateFromXRFrame","xrFrame","referenceSpace","hand","inputSource","anyHand","jointSpaces","get","trackingSuccessful","fillPoses","fillJointRadii","_jointTransformMatrices","_jointRadii","getJointPose","jointPose","set","transform","matrix","radius","_jointName","FromArrayToRef","_tempJointMatrix","decompose","undefined","position","scaledJointRadius","jointMesh","isVisible","copyFrom","scaling","setAll","useRightHandedSystem","z","w","dispose","WebXRHandTracking","_xrSessionManager","options","left","right","jointMeshes","handMeshes","rigMappings","handedness","_handResources","webxrHand","meshesUseLeftHandedCoordinates","invisible","scaleFactor","_attachedHands","uniqueId","_trackingHands","onHandAddedObservable","notifyObservers","_detachHandById","xrNativeFeatureName","anyOptions","anyJointMeshOptions","disableDefaultHandMesh","disableDefaultMeshes","customMeshes","leftHandedSystemMeshes","leftRigMapping","rightRigMapping","rigMappingTuple","legacyRigMapping","modelJointName","index","customRigMappings","_GenerateTrackedJointMeshes","featureOptions","meshes","trackedMeshes","originalMesh","sourceMesh","_ICOSPHERE_PARAMS","keepOriginalVisible","i","newInstance","createInstance","onHandJointMeshGenerated","returnedMesh","isPickable","enablePhysics","props","physicsProps","type","impostorType","SphereImpostor","physicsImpostor","mass","push","_GenerateDefaultHandMeshesAsync","scene","Promise","resolve","riggedMeshes","_RightHandGLB","isDisposed","_LeftHandGLB","handsDefined","handGLBs","all","ImportMeshAsync","DEFAULT_HAND_MODEL_BASE_URL","DEFAULT_HAND_MODEL_RIGHT_FILENAME","DEFAULT_HAND_MODEL_LEFT_FILENAME","handShader","emitComments","loadAsync","DEFAULT_HAND_MODEL_SHADER_URL","needDepthPrePass","transparencyMode","MATERIAL_ALPHABLEND","alphaMode","build","handColors","base","FromInts","fresnel","fingerColor","tipFresnel","customColors","handNodes","getBlockByName","value","handGLB","Error","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","material","clone","rotate","Y","Math","PI","_GenerateDefaultHandMeshRigMapping","H","isCompatible","XRHand","getHandByControllerId","controllerId","getHandByHandedness","attach","LastCreatedScene","then","defaultHandMeshes","xrInput","controllers","_attachHand","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","_detachHand","_onXRFrame","_xrFrame","onHandRemovedObservable","detach","Object","keys","clear","trackedMesh","HAND_TRACKING","flat","subdivisions","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRHandTracking.ts"],"sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor\";\r\n\r\nimport type { IDisposable, Scene } from \"../../scene\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { InstancedMesh } from \"../../Meshes/instancedMesh\";\r\nimport type { ISceneLoaderAsyncResult } from \"../../Loading/sceneLoader\";\r\nimport { SceneLoader } from \"../../Loading/sceneLoader\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { NodeMaterial } from \"../../Materials/Node/nodeMaterial\";\r\nimport type { InputBlock } from \"../../Materials/Node/Blocks/Input/inputBlock\";\r\nimport { Material } from \"../../Materials/material\";\r\nimport { CreateIcoSphere } from \"../../Meshes/Builders/icoSphereBuilder\";\r\nimport { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Axis } from \"../../Maths/math.axis\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\ndeclare const XRHand: XRHand;\r\n\r\n/**\r\n * Configuration interface for the hand tracking feature\r\n */\r\nexport interface IWebXRHandTrackingOptions {\r\n    /**\r\n     * The xrInput that will be used as source for new hands\r\n     */\r\n    xrInput: WebXRInput;\r\n\r\n    /**\r\n     * Configuration object for the joint meshes.\r\n     */\r\n    jointMeshes?: {\r\n        /**\r\n         * Should the meshes created be invisible (defaults to false).\r\n         */\r\n        invisible?: boolean;\r\n        /**\r\n         * A source mesh to be used to create instances. Defaults to an icosphere with two subdivisions and smooth lighting.\r\n         * This mesh will be the source for all other (25) meshes.\r\n         * It should have the general size of a single unit, as the instances will be scaled according to the provided radius.\r\n         */\r\n        sourceMesh?: Mesh;\r\n        /**\r\n         * This function will be called after a mesh was created for a specific joint.\r\n         * Using this function you can either manipulate the instance or return a new mesh.\r\n         * When returning a new mesh the instance created before will be disposed.\r\n         * @param meshInstance An instance of the original joint mesh being used for the joint.\r\n         * @param jointId The joint's index, see https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section for more info.\r\n         * @param hand Which hand (\"left\", \"right\") the joint will be on.\r\n         */\r\n        onHandJointMeshGenerated?: (meshInstance: InstancedMesh, jointId: number, hand: XRHandedness) => AbstractMesh | undefined;\r\n        /**\r\n         * Should the source mesh stay visible (defaults to false).\r\n         */\r\n        keepOriginalVisible?: boolean;\r\n        /**\r\n         * Should each instance have its own physics impostor\r\n         */\r\n        enablePhysics?: boolean;\r\n        /**\r\n         * If enabled, override default physics properties\r\n         */\r\n        physicsProps?: { friction?: number; restitution?: number; impostorType?: number };\r\n        /**\r\n         * Scale factor for all joint meshes (defaults to 1)\r\n         */\r\n        scaleFactor?: number;\r\n    };\r\n\r\n    /**\r\n     * Configuration object for the hand meshes.\r\n     */\r\n    handMeshes?: {\r\n        /**\r\n         * Should the default hand mesh be disabled. In this case, the spheres will be visible (unless set invisible).\r\n         */\r\n        disableDefaultMeshes?: boolean;\r\n        /**\r\n         * Rigged hand meshes that will be tracked to the user's hands. This will override the default hand mesh.\r\n         */\r\n        customMeshes?: {\r\n            right: AbstractMesh;\r\n            left: AbstractMesh;\r\n        };\r\n        /**\r\n         * Are the meshes prepared for a left-handed system. Default hand meshes are right-handed.\r\n         */\r\n        meshesUseLeftHandedCoordinates?: boolean;\r\n        /**\r\n         * If a hand mesh was provided, this array will define what axis will update which node. This will override the default hand mesh\r\n         */\r\n        customRigMappings?: {\r\n            right: XRHandMeshRigMapping;\r\n            left: XRHandMeshRigMapping;\r\n        };\r\n\r\n        /**\r\n         * Override the colors of the hand meshes.\r\n         */\r\n        customColors?: {\r\n            base?: Color3;\r\n            fresnel?: Color3;\r\n            fingerColor?: Color3;\r\n            tipFresnel?: Color3;\r\n        };\r\n    };\r\n}\r\n\r\n/**\r\n * Parts of the hands divided to writs and finger names\r\n */\r\nexport enum HandPart {\r\n    /**\r\n     * HandPart - Wrist\r\n     */\r\n    WRIST = \"wrist\",\r\n    /**\r\n     * HandPart - The thumb\r\n     */\r\n    THUMB = \"thumb\",\r\n    /**\r\n     * HandPart - Index finger\r\n     */\r\n    INDEX = \"index\",\r\n    /**\r\n     * HandPart - Middle finger\r\n     */\r\n    MIDDLE = \"middle\",\r\n    /**\r\n     * HandPart - Ring finger\r\n     */\r\n    RING = \"ring\",\r\n    /**\r\n     * HandPart - Little finger\r\n     */\r\n    LITTLE = \"little\",\r\n}\r\n\r\n/**\r\n * Joints of the hand as defined by the WebXR specification.\r\n * https://immersive-web.github.io/webxr-hand-input/#skeleton-joints-section\r\n */\r\nexport enum WebXRHandJoint {\r\n    /** Wrist */\r\n    WRIST = \"wrist\",\r\n\r\n    /** Thumb near wrist */\r\n    THUMB_METACARPAL = \"thumb-metacarpal\",\r\n    /** Thumb first knuckle */\r\n    THUMB_PHALANX_PROXIMAL = \"thumb-phalanx-proximal\",\r\n    /** Thumb second knuckle */\r\n    THUMB_PHALANX_DISTAL = \"thumb-phalanx-distal\",\r\n    /** Thumb tip */\r\n    THUMB_TIP = \"thumb-tip\",\r\n\r\n    /** Index finger near wrist */\r\n    INDEX_FINGER_METACARPAL = \"index-finger-metacarpal\",\r\n    /** Index finger first knuckle */\r\n    INDEX_FINGER_PHALANX_PROXIMAL = \"index-finger-phalanx-proximal\",\r\n    /** Index finger second knuckle */\r\n    INDEX_FINGER_PHALANX_INTERMEDIATE = \"index-finger-phalanx-intermediate\",\r\n    /** Index finger third knuckle */\r\n    INDEX_FINGER_PHALANX_DISTAL = \"index-finger-phalanx-distal\",\r\n    /** Index finger tip */\r\n    INDEX_FINGER_TIP = \"index-finger-tip\",\r\n\r\n    /** Middle finger near wrist */\r\n    MIDDLE_FINGER_METACARPAL = \"middle-finger-metacarpal\",\r\n    /** Middle finger first knuckle */\r\n    MIDDLE_FINGER_PHALANX_PROXIMAL = \"middle-finger-phalanx-proximal\",\r\n    /** Middle finger second knuckle */\r\n    MIDDLE_FINGER_PHALANX_INTERMEDIATE = \"middle-finger-phalanx-intermediate\",\r\n    /** Middle finger third knuckle */\r\n    MIDDLE_FINGER_PHALANX_DISTAL = \"middle-finger-phalanx-distal\",\r\n    /** Middle finger tip */\r\n    MIDDLE_FINGER_TIP = \"middle-finger-tip\",\r\n\r\n    /** Ring finger near wrist */\r\n    RING_FINGER_METACARPAL = \"ring-finger-metacarpal\",\r\n    /** Ring finger first knuckle */\r\n    RING_FINGER_PHALANX_PROXIMAL = \"ring-finger-phalanx-proximal\",\r\n    /** Ring finger second knuckle */\r\n    RING_FINGER_PHALANX_INTERMEDIATE = \"ring-finger-phalanx-intermediate\",\r\n    /** Ring finger third knuckle */\r\n    RING_FINGER_PHALANX_DISTAL = \"ring-finger-phalanx-distal\",\r\n    /** Ring finger tip */\r\n    RING_FINGER_TIP = \"ring-finger-tip\",\r\n\r\n    /** Pinky finger near wrist */\r\n    PINKY_FINGER_METACARPAL = \"pinky-finger-metacarpal\",\r\n    /** Pinky finger first knuckle */\r\n    PINKY_FINGER_PHALANX_PROXIMAL = \"pinky-finger-phalanx-proximal\",\r\n    /** Pinky finger second knuckle */\r\n    PINKY_FINGER_PHALANX_INTERMEDIATE = \"pinky-finger-phalanx-intermediate\",\r\n    /** Pinky finger third knuckle */\r\n    PINKY_FINGER_PHALANX_DISTAL = \"pinky-finger-phalanx-distal\",\r\n    /** Pinky finger tip */\r\n    PINKY_FINGER_TIP = \"pinky-finger-tip\",\r\n}\r\n\r\n/** A type encapsulating a dictionary mapping WebXR joints to bone names in a rigged hand mesh.  */\r\nexport type XRHandMeshRigMapping = { [webXRJointName in WebXRHandJoint]: string };\r\n\r\nconst handJointReferenceArray: WebXRHandJoint[] = [\r\n    WebXRHandJoint.WRIST,\r\n    WebXRHandJoint.THUMB_METACARPAL,\r\n    WebXRHandJoint.THUMB_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.THUMB_PHALANX_DISTAL,\r\n    WebXRHandJoint.THUMB_TIP,\r\n    WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.INDEX_FINGER_TIP,\r\n    WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    WebXRHandJoint.RING_FINGER_METACARPAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.RING_FINGER_TIP,\r\n    WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n    WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n    WebXRHandJoint.PINKY_FINGER_TIP,\r\n];\r\n\r\nconst handPartsDefinition: { [key in HandPart]: WebXRHandJoint[] } = {\r\n    [HandPart.WRIST]: [WebXRHandJoint.WRIST],\r\n    [HandPart.THUMB]: [WebXRHandJoint.THUMB_METACARPAL, WebXRHandJoint.THUMB_PHALANX_PROXIMAL, WebXRHandJoint.THUMB_PHALANX_DISTAL, WebXRHandJoint.THUMB_TIP],\r\n    [HandPart.INDEX]: [\r\n        WebXRHandJoint.INDEX_FINGER_METACARPAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.INDEX_FINGER_TIP,\r\n    ],\r\n    [HandPart.MIDDLE]: [\r\n        WebXRHandJoint.MIDDLE_FINGER_METACARPAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.MIDDLE_FINGER_TIP,\r\n    ],\r\n    [HandPart.RING]: [\r\n        WebXRHandJoint.RING_FINGER_METACARPAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.RING_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.RING_FINGER_TIP,\r\n    ],\r\n    [HandPart.LITTLE]: [\r\n        WebXRHandJoint.PINKY_FINGER_METACARPAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE,\r\n        WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL,\r\n        WebXRHandJoint.PINKY_FINGER_TIP,\r\n    ],\r\n};\r\n\r\n/**\r\n * Representing a single hand (with its corresponding native XRHand object)\r\n */\r\nexport class WebXRHand implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Transform nodes that will directly receive the transforms from the WebXR matrix data.\r\n     */\r\n    private _jointTransforms = new Array<TransformNode>(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * The float array that will directly receive the transform matrix data from WebXR.\r\n     */\r\n    private _jointTransformMatrices = new Float32Array(handJointReferenceArray.length * 16);\r\n\r\n    private _tempJointMatrix = new Matrix();\r\n\r\n    /**\r\n     * The float array that will directly receive the joint radii from WebXR.\r\n     */\r\n    private _jointRadii = new Float32Array(handJointReferenceArray.length);\r\n\r\n    /**\r\n     * Get the hand mesh.\r\n     */\r\n    public get handMesh(): Nullable<AbstractMesh> {\r\n        return this._handMesh;\r\n    }\r\n\r\n    /**\r\n     * Get meshes of part of the hand.\r\n     * @param part The part of hand to get.\r\n     * @returns An array of meshes that correlate to the hand part requested.\r\n     */\r\n    public getHandPartMeshes(part: HandPart): AbstractMesh[] {\r\n        return handPartsDefinition[part].map((name) => this._jointMeshes[handJointReferenceArray.indexOf(name)]!);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a mesh linked to a named joint in the hand.\r\n     * @param jointName The name of the joint.\r\n     * @returns An AbstractMesh whose position corresponds with the joint position.\r\n     */\r\n    public getJointMesh(jointName: WebXRHandJoint): AbstractMesh {\r\n        return this._jointMeshes[handJointReferenceArray.indexOf(jointName)!];\r\n    }\r\n\r\n    /**\r\n     * Construct a new hand object\r\n     * @param xrController The controller to which the hand correlates.\r\n     * @param _jointMeshes The meshes to be used to track the hand joints.\r\n     * @param _handMesh An optional hand mesh.\r\n     * @param rigMapping An optional rig mapping for the hand mesh.\r\n     *                   If not provided (but a hand mesh is provided),\r\n     *                   it will be assumed that the hand mesh's bones are named\r\n     *                   directly after the WebXR bone names.\r\n     * @param _leftHandedMeshes Are the hand meshes left-handed-system meshes\r\n     * @param _jointsInvisible Are the tracked joint meshes visible\r\n     * @param _jointScaleFactor Scale factor for all joint meshes\r\n     */\r\n    constructor(\r\n        /** The controller to which the hand correlates. */\r\n        public readonly xrController: WebXRInputSource,\r\n        private readonly _jointMeshes: AbstractMesh[],\r\n        private _handMesh: Nullable<AbstractMesh>,\r\n        /** An optional rig mapping for the hand mesh. If not provided (but a hand mesh is provided),\r\n         * it will be assumed that the hand mesh's bones are named directly after the WebXR bone names. */\r\n        readonly rigMapping: Nullable<XRHandMeshRigMapping>,\r\n        private readonly _leftHandedMeshes: boolean = false,\r\n        private readonly _jointsInvisible: boolean = false,\r\n        private readonly _jointScaleFactor: number = 1\r\n    ) {\r\n        this._scene = _jointMeshes[0].getScene();\r\n\r\n        // Initialize the joint transform quaternions and link the transforms to the bones.\r\n        for (let jointIdx = 0; jointIdx < this._jointTransforms.length; jointIdx++) {\r\n            const jointTransform = (this._jointTransforms[jointIdx] = new TransformNode(handJointReferenceArray[jointIdx], this._scene));\r\n            jointTransform.rotationQuaternion = new Quaternion();\r\n\r\n            // Set the rotation quaternion so we can use it later for tracking.\r\n            _jointMeshes[jointIdx].rotationQuaternion = new Quaternion();\r\n        }\r\n\r\n        if (_handMesh) {\r\n            // Note that this logic needs to happen after we initialize the joint tracking transform nodes.\r\n            this.setHandMesh(_handMesh, rigMapping);\r\n        }\r\n\r\n        // hide the motion controller, if available/loaded\r\n        if (this.xrController.motionController) {\r\n            if (this.xrController.motionController.rootMesh) {\r\n                this.xrController.motionController.rootMesh.setEnabled(false);\r\n            } else {\r\n                this.xrController.motionController.onModelLoadedObservable.add((controller) => {\r\n                    if (controller.rootMesh) {\r\n                        controller.rootMesh.setEnabled(false);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        this.xrController.onMotionControllerInitObservable.add((motionController) => {\r\n            motionController.onModelLoadedObservable.add((controller) => {\r\n                if (controller.rootMesh) {\r\n                    controller.rootMesh.setEnabled(false);\r\n                }\r\n            });\r\n            if (motionController.rootMesh) {\r\n                motionController.rootMesh.setEnabled(false);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets the current hand mesh to render for the WebXRHand.\r\n     * @param handMesh The rigged hand mesh that will be tracked to the user's hand.\r\n     * @param rigMapping The mapping from XRHandJoint to bone names to use with the mesh.\r\n     */\r\n    public setHandMesh(handMesh: AbstractMesh, rigMapping: Nullable<XRHandMeshRigMapping>) {\r\n        this._handMesh = handMesh;\r\n\r\n        // Avoid any strange frustum culling. We will manually control visibility via attach and detach.\r\n        handMesh.alwaysSelectAsActiveMesh = true;\r\n        handMesh.getChildMeshes().forEach((mesh) => (mesh.alwaysSelectAsActiveMesh = true));\r\n\r\n        // Link the bones in the hand mesh to the transform nodes that will be bound to the WebXR tracked joints.\r\n        if (this._handMesh.skeleton) {\r\n            const handMeshSkeleton = this._handMesh.skeleton;\r\n            handJointReferenceArray.forEach((jointName, jointIdx) => {\r\n                const jointBoneIdx = handMeshSkeleton.getBoneIndexByName(rigMapping ? rigMapping[jointName] : jointName);\r\n                if (jointBoneIdx !== -1) {\r\n                    handMeshSkeleton.bones[jointBoneIdx].linkTransformNode(this._jointTransforms[jointIdx]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update this hand from the latest xr frame.\r\n     * @param xrFrame The latest frame received from WebXR.\r\n     * @param referenceSpace The current viewer reference space.\r\n     */\r\n    public updateFromXRFrame(xrFrame: XRFrame, referenceSpace: XRReferenceSpace) {\r\n        const hand = this.xrController.inputSource.hand;\r\n        if (!hand) {\r\n            return;\r\n        }\r\n\r\n        // TODO: Modify webxr.d.ts to better match WebXR IDL so we don't need this any cast.\r\n        const anyHand: any = hand;\r\n        const jointSpaces: XRJointSpace[] = handJointReferenceArray.map((jointName) => anyHand[jointName] || hand.get(jointName));\r\n        let trackingSuccessful = false;\r\n\r\n        if (xrFrame.fillPoses && xrFrame.fillJointRadii) {\r\n            trackingSuccessful = xrFrame.fillPoses(jointSpaces, referenceSpace, this._jointTransformMatrices) && xrFrame.fillJointRadii(jointSpaces, this._jointRadii);\r\n        } else if (xrFrame.getJointPose) {\r\n            trackingSuccessful = true;\r\n            // Warning: This codepath is slow by comparison, only here for compat.\r\n            for (let jointIdx = 0; jointIdx < jointSpaces.length; jointIdx++) {\r\n                const jointPose = xrFrame.getJointPose(jointSpaces[jointIdx], referenceSpace);\r\n                if (jointPose) {\r\n                    this._jointTransformMatrices.set(jointPose.transform.matrix, jointIdx * 16);\r\n                    this._jointRadii[jointIdx] = jointPose.radius || 0.008;\r\n                } else {\r\n                    trackingSuccessful = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!trackingSuccessful) {\r\n            return;\r\n        }\r\n\r\n        handJointReferenceArray.forEach((_jointName, jointIdx) => {\r\n            const jointTransform = this._jointTransforms[jointIdx];\r\n            Matrix.FromArrayToRef(this._jointTransformMatrices, jointIdx * 16, this._tempJointMatrix);\r\n            this._tempJointMatrix.decompose(undefined, jointTransform.rotationQuaternion!, jointTransform.position);\r\n\r\n            // The radius we need to make the joint in order for it to roughly cover the joints of the user's real hand.\r\n            const scaledJointRadius = this._jointRadii[jointIdx] * this._jointScaleFactor;\r\n\r\n            const jointMesh = this._jointMeshes[jointIdx];\r\n            jointMesh.isVisible = !this._handMesh && !this._jointsInvisible;\r\n            jointMesh.position.copyFrom(jointTransform.position);\r\n            jointMesh.rotationQuaternion!.copyFrom(jointTransform.rotationQuaternion!);\r\n            jointMesh.scaling.setAll(scaledJointRadius);\r\n\r\n            // The WebXR data comes as right-handed, so we might need to do some conversions.\r\n            if (!this._scene.useRightHandedSystem) {\r\n                jointMesh.position.z *= -1;\r\n                jointMesh.rotationQuaternion!.z *= -1;\r\n                jointMesh.rotationQuaternion!.w *= -1;\r\n\r\n                if (this._leftHandedMeshes && this._handMesh) {\r\n                    jointTransform.position.z *= -1;\r\n                    jointTransform.rotationQuaternion!.z *= -1;\r\n                    jointTransform.rotationQuaternion!.w *= -1;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose this Hand object\r\n     */\r\n    public dispose() {\r\n        if (this._handMesh) {\r\n            this._handMesh.isVisible = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * WebXR Hand Joint tracking feature, available for selected browsers and devices\r\n */\r\nexport class WebXRHandTracking extends WebXRAbstractFeature {\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HAND_TRACKING;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /** The base URL for the default hand model. */\r\n    public static DEFAULT_HAND_MODEL_BASE_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/\";\r\n    /** The filename to use for the default right hand model. */\r\n    public static DEFAULT_HAND_MODEL_RIGHT_FILENAME = \"r_hand_rhs.glb\";\r\n    /** The filename to use for the default left hand model. */\r\n    public static DEFAULT_HAND_MODEL_LEFT_FILENAME = \"l_hand_rhs.glb\";\r\n    /** The URL pointing to the default hand model NodeMaterial shader. */\r\n    public static DEFAULT_HAND_MODEL_SHADER_URL = \"https://assets.babylonjs.com/meshes/HandMeshes/handsShader.json\";\r\n\r\n    // We want to use lightweight models, diameter will initially be 1 but scaled to the values returned from WebXR.\r\n    private static readonly _ICOSPHERE_PARAMS = { radius: 0.5, flat: false, subdivisions: 2 };\r\n\r\n    private static _RightHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n    private static _LeftHandGLB: Nullable<ISceneLoaderAsyncResult> = null;\r\n\r\n    private static _GenerateTrackedJointMeshes(featureOptions: IWebXRHandTrackingOptions): { left: AbstractMesh[]; right: AbstractMesh[] } {\r\n        const meshes: { [handedness: string]: AbstractMesh[] } = {};\r\n        [\"left\" as XRHandedness, \"right\" as XRHandedness].map((handedness) => {\r\n            const trackedMeshes = [];\r\n            const originalMesh = featureOptions.jointMeshes?.sourceMesh || CreateIcoSphere(\"jointParent\", WebXRHandTracking._ICOSPHERE_PARAMS);\r\n            originalMesh.isVisible = !!featureOptions.jointMeshes?.keepOriginalVisible;\r\n            for (let i = 0; i < handJointReferenceArray.length; ++i) {\r\n                let newInstance: AbstractMesh = originalMesh.createInstance(`${handedness}-handJoint-${i}`);\r\n                if (featureOptions.jointMeshes?.onHandJointMeshGenerated) {\r\n                    const returnedMesh = featureOptions.jointMeshes.onHandJointMeshGenerated(newInstance as InstancedMesh, i, handedness);\r\n                    if (returnedMesh) {\r\n                        if (returnedMesh !== newInstance) {\r\n                            newInstance.dispose();\r\n                            newInstance = returnedMesh;\r\n                        }\r\n                    }\r\n                }\r\n                newInstance.isPickable = false;\r\n                if (featureOptions.jointMeshes?.enablePhysics) {\r\n                    const props = featureOptions.jointMeshes?.physicsProps || {};\r\n                    // downscale the instances so that physics will be initialized correctly\r\n                    newInstance.scaling.setAll(0.02);\r\n                    const type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;\r\n                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, { mass: 0, ...props });\r\n                }\r\n                newInstance.rotationQuaternion = new Quaternion();\r\n                newInstance.isVisible = false;\r\n                trackedMeshes.push(newInstance);\r\n            }\r\n\r\n            meshes[handedness] = trackedMeshes;\r\n        });\r\n        return { left: meshes.left, right: meshes.right };\r\n    }\r\n\r\n    private static _GenerateDefaultHandMeshesAsync(scene: Scene, options?: IWebXRHandTrackingOptions): Promise<{ left: AbstractMesh; right: AbstractMesh }> {\r\n        // eslint-disable-next-line no-async-promise-executor\r\n        return new Promise(async (resolve) => {\r\n            const riggedMeshes: { [handedness: string]: AbstractMesh } = {};\r\n            // check the cache, defensive\r\n            if (WebXRHandTracking._RightHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._RightHandGLB = null;\r\n            }\r\n            if (WebXRHandTracking._LeftHandGLB?.meshes[1]?.isDisposed()) {\r\n                WebXRHandTracking._LeftHandGLB = null;\r\n            }\r\n\r\n            const handsDefined = !!(WebXRHandTracking._RightHandGLB && WebXRHandTracking._LeftHandGLB);\r\n            // load them in parallel\r\n            const handGLBs = await Promise.all([\r\n                WebXRHandTracking._RightHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_RIGHT_FILENAME, scene),\r\n                WebXRHandTracking._LeftHandGLB ||\r\n                    SceneLoader.ImportMeshAsync(\"\", WebXRHandTracking.DEFAULT_HAND_MODEL_BASE_URL, WebXRHandTracking.DEFAULT_HAND_MODEL_LEFT_FILENAME, scene),\r\n            ]);\r\n            WebXRHandTracking._RightHandGLB = handGLBs[0];\r\n            WebXRHandTracking._LeftHandGLB = handGLBs[1];\r\n\r\n            const handShader = new NodeMaterial(\"handShader\", scene, { emitComments: false });\r\n            await handShader.loadAsync(WebXRHandTracking.DEFAULT_HAND_MODEL_SHADER_URL);\r\n\r\n            // depth prepass and alpha mode\r\n            handShader.needDepthPrePass = true;\r\n            handShader.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n            handShader.alphaMode = Constants.ALPHA_COMBINE;\r\n\r\n            // build node materials\r\n            handShader.build(false);\r\n\r\n            // shader\r\n            const handColors = {\r\n                base: Color3.FromInts(116, 63, 203),\r\n                fresnel: Color3.FromInts(149, 102, 229),\r\n                fingerColor: Color3.FromInts(177, 130, 255),\r\n                tipFresnel: Color3.FromInts(220, 200, 255),\r\n                ...options?.handMeshes?.customColors,\r\n            };\r\n\r\n            const handNodes = {\r\n                base: handShader.getBlockByName(\"baseColor\") as InputBlock,\r\n                fresnel: handShader.getBlockByName(\"fresnelColor\") as InputBlock,\r\n                fingerColor: handShader.getBlockByName(\"fingerColor\") as InputBlock,\r\n                tipFresnel: handShader.getBlockByName(\"tipFresnelColor\") as InputBlock,\r\n            };\r\n\r\n            handNodes.base.value = handColors.base;\r\n            handNodes.fresnel.value = handColors.fresnel;\r\n            handNodes.fingerColor.value = handColors.fingerColor;\r\n            handNodes.tipFresnel.value = handColors.tipFresnel;\r\n\r\n            [\"left\", \"right\"].forEach((handedness) => {\r\n                const handGLB = handedness == \"left\" ? WebXRHandTracking._LeftHandGLB : WebXRHandTracking._RightHandGLB;\r\n                if (!handGLB) {\r\n                    // this should never happen!\r\n                    throw new Error(\"Could not load hand model\");\r\n                }\r\n                const handMesh = handGLB.meshes[1];\r\n                handMesh._internalAbstractMeshDataInfo._computeBonesUsingShaders = true;\r\n                handMesh.material = handShader.clone(`${handedness}HandShaderClone`, true);\r\n                handMesh.isVisible = false;\r\n\r\n                riggedMeshes[handedness] = handMesh;\r\n\r\n                // single change for left handed systems\r\n                if (!handsDefined && !scene.useRightHandedSystem) {\r\n                    handGLB.meshes[1].rotate(Axis.Y, Math.PI);\r\n                }\r\n            });\r\n\r\n            handShader.dispose();\r\n            resolve({ left: riggedMeshes.left, right: riggedMeshes.right });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates a mapping from XRHandJoint to bone name for the default hand mesh.\r\n     * @param handedness The handedness being mapped for.\r\n     */\r\n    private static _GenerateDefaultHandMeshRigMapping(handedness: XRHandedness): XRHandMeshRigMapping {\r\n        const H = handedness == \"right\" ? \"R\" : \"L\";\r\n        return {\r\n            [WebXRHandJoint.WRIST]: `wrist_${H}`,\r\n            [WebXRHandJoint.THUMB_METACARPAL]: `thumb_metacarpal_${H}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_PROXIMAL]: `thumb_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.THUMB_PHALANX_DISTAL]: `thumb_distPhalanx_${H}`,\r\n            [WebXRHandJoint.THUMB_TIP]: `thumb_tip_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_METACARPAL]: `index_metacarpal_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_PROXIMAL]: `index_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_INTERMEDIATE]: `index_intPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_PHALANX_DISTAL]: `index_distPhalanx_${H}`,\r\n            [WebXRHandJoint.INDEX_FINGER_TIP]: `index_tip_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_METACARPAL]: `middle_metacarpal_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_PROXIMAL]: `middle_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_INTERMEDIATE]: `middle_intPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_PHALANX_DISTAL]: `middle_distPhalanx_${H}`,\r\n            [WebXRHandJoint.MIDDLE_FINGER_TIP]: `middle_tip_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_METACARPAL]: `ring_metacarpal_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_PROXIMAL]: `ring_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_INTERMEDIATE]: `ring_intPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_PHALANX_DISTAL]: `ring_distPhalanx_${H}`,\r\n            [WebXRHandJoint.RING_FINGER_TIP]: `ring_tip_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_METACARPAL]: `little_metacarpal_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_PROXIMAL]: `little_proxPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_INTERMEDIATE]: `little_intPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_PHALANX_DISTAL]: `little_distPhalanx_${H}`,\r\n            [WebXRHandJoint.PINKY_FINGER_TIP]: `little_tip_${H}`,\r\n        };\r\n    }\r\n\r\n    private _attachedHands: {\r\n        [uniqueId: string]: WebXRHand;\r\n    } = {};\r\n\r\n    private _trackingHands: {\r\n        left: Nullable<WebXRHand>;\r\n        right: Nullable<WebXRHand>;\r\n    } = { left: null, right: null };\r\n\r\n    private _handResources: {\r\n        jointMeshes: Nullable<{ left: AbstractMesh[]; right: AbstractMesh[] }>;\r\n        handMeshes: Nullable<{ left: AbstractMesh; right: AbstractMesh }>;\r\n        rigMappings: Nullable<{ left: XRHandMeshRigMapping; right: XRHandMeshRigMapping }>;\r\n    } = { jointMeshes: null, handMeshes: null, rigMappings: null };\r\n\r\n    /**\r\n     * This observable will notify registered observers when a new hand object was added and initialized\r\n     */\r\n    public onHandAddedObservable: Observable<WebXRHand> = new Observable();\r\n    /**\r\n     * This observable will notify its observers right before the hand object is disposed\r\n     */\r\n    public onHandRemovedObservable: Observable<WebXRHand> = new Observable();\r\n\r\n    /**\r\n     * Check if the needed objects are defined.\r\n     * This does not mean that the feature is enabled, but that the objects needed are well defined.\r\n     */\r\n    public isCompatible(): boolean {\r\n        return typeof XRHand !== \"undefined\";\r\n    }\r\n\r\n    /**\r\n     * Get the hand object according to the controller id\r\n     * @param controllerId the controller id to which we want to get the hand\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByControllerId(controllerId: string): Nullable<WebXRHand> {\r\n        return this._attachedHands[controllerId];\r\n    }\r\n\r\n    /**\r\n     * Get a hand object according to the requested handedness\r\n     * @param handedness the handedness to request\r\n     * @returns null if not found or the WebXRHand object if found\r\n     */\r\n    public getHandByHandedness(handedness: XRHandedness): Nullable<WebXRHand> {\r\n        if (handedness == \"none\") {\r\n            return null;\r\n        }\r\n        return this._trackingHands[handedness];\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the XR hand tracking feature.\r\n     * @param _xrSessionManager An instance of WebXRSessionManager.\r\n     * @param options Options to use when constructing this feature.\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /** Options to use when constructing this feature. */\r\n        public readonly options: IWebXRHandTrackingOptions\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hand-tracking\";\r\n\r\n        // Support legacy versions of the options object by copying over joint mesh properties\r\n        const anyOptions = options as any;\r\n        const anyJointMeshOptions = anyOptions.jointMeshes;\r\n        if (anyJointMeshOptions) {\r\n            if (typeof anyJointMeshOptions.disableDefaultHandMesh !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.disableDefaultMeshes = anyJointMeshOptions.disableDefaultHandMesh;\r\n            }\r\n            if (typeof anyJointMeshOptions.handMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.customMeshes = anyJointMeshOptions.handMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.leftHandedSystemMeshes !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                options.handMeshes.meshesUseLeftHandedCoordinates = anyJointMeshOptions.leftHandedSystemMeshes;\r\n            }\r\n            if (typeof anyJointMeshOptions.rigMapping !== \"undefined\") {\r\n                options.handMeshes = options.handMeshes || {};\r\n                const leftRigMapping = {};\r\n                const rightRigMapping = {};\r\n                [\r\n                    [anyJointMeshOptions.rigMapping.left, leftRigMapping],\r\n                    [anyJointMeshOptions.rigMapping.right, rightRigMapping],\r\n                ].forEach((rigMappingTuple) => {\r\n                    const legacyRigMapping = rigMappingTuple[0] as string[];\r\n                    const rigMapping = rigMappingTuple[1] as XRHandMeshRigMapping;\r\n                    legacyRigMapping.forEach((modelJointName, index) => {\r\n                        rigMapping[handJointReferenceArray[index]] = modelJointName;\r\n                    });\r\n                });\r\n                options.handMeshes.customRigMappings = {\r\n                    left: leftRigMapping as XRHandMeshRigMapping,\r\n                    right: rightRigMapping as XRHandMeshRigMapping,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        this._handResources = {\r\n            jointMeshes: WebXRHandTracking._GenerateTrackedJointMeshes(this.options),\r\n            handMeshes: this.options.handMeshes?.customMeshes || null,\r\n            rigMappings: this.options.handMeshes?.customRigMappings || null,\r\n        };\r\n\r\n        // If they didn't supply custom meshes and are not disabling the default meshes...\r\n        if (!this.options.handMeshes?.customMeshes && !this.options.handMeshes?.disableDefaultMeshes) {\r\n            WebXRHandTracking._GenerateDefaultHandMeshesAsync(EngineStore.LastCreatedScene!, this.options).then((defaultHandMeshes) => {\r\n                this._handResources.handMeshes = defaultHandMeshes;\r\n                this._handResources.rigMappings = {\r\n                    left: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"left\"),\r\n                    right: WebXRHandTracking._GenerateDefaultHandMeshRigMapping(\"right\"),\r\n                };\r\n\r\n                // Apply meshes to existing hands if already tracking.\r\n                this._trackingHands.left?.setHandMesh(this._handResources.handMeshes.left, this._handResources.rigMappings.left);\r\n                this._trackingHands.right?.setHandMesh(this._handResources.handMeshes.right, this._handResources.rigMappings.right);\r\n            });\r\n        }\r\n\r\n        this.options.xrInput.controllers.forEach(this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);\r\n        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, this._detachHand);\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: XRFrame): void {\r\n        this._trackingHands.left?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n        this._trackingHands.right?.updateFromXRFrame(_xrFrame, this._xrSessionManager.referenceSpace);\r\n    }\r\n\r\n    private _attachHand = (xrController: WebXRInputSource) => {\r\n        if (!xrController.inputSource.hand || xrController.inputSource.handedness == \"none\" || !this._handResources.jointMeshes) {\r\n            return;\r\n        }\r\n\r\n        const handedness = xrController.inputSource.handedness;\r\n        const webxrHand = new WebXRHand(\r\n            xrController,\r\n            this._handResources.jointMeshes[handedness],\r\n            this._handResources.handMeshes && this._handResources.handMeshes[handedness],\r\n            this._handResources.rigMappings && this._handResources.rigMappings[handedness],\r\n            this.options.handMeshes?.meshesUseLeftHandedCoordinates,\r\n            this.options.jointMeshes?.invisible,\r\n            this.options.jointMeshes?.scaleFactor\r\n        );\r\n\r\n        this._attachedHands[xrController.uniqueId] = webxrHand;\r\n        this._trackingHands[handedness] = webxrHand;\r\n\r\n        this.onHandAddedObservable.notifyObservers(webxrHand);\r\n    };\r\n\r\n    private _detachHandById(controllerId: string) {\r\n        const hand = this.getHandByControllerId(controllerId);\r\n        if (hand) {\r\n            const handedness = hand.xrController.inputSource.handedness == \"left\" ? \"left\" : \"right\";\r\n            if (this._trackingHands[handedness]?.xrController.uniqueId === controllerId) {\r\n                this._trackingHands[handedness] = null;\r\n            }\r\n            this.onHandRemovedObservable.notifyObservers(hand);\r\n            hand.dispose();\r\n            delete this._attachedHands[controllerId];\r\n        }\r\n    }\r\n\r\n    private _detachHand = (xrController: WebXRInputSource) => {\r\n        this._detachHandById(xrController.uniqueId);\r\n    };\r\n\r\n    /**\r\n     * Detach this feature.\r\n     * Will usually be called by the features manager.\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._attachedHands).forEach((uniqueId) => this._detachHandById(uniqueId));\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHandAddedObservable.clear();\r\n        this.onHandRemovedObservable.clear();\r\n\r\n        if (this._handResources.handMeshes && !this.options.handMeshes?.customMeshes) {\r\n            // this will dispose the cached meshes\r\n            this._handResources.handMeshes.left.dispose();\r\n            this._handResources.handMeshes.right.dispose();\r\n            // remove the cached meshes\r\n            WebXRHandTracking._RightHandGLB = null;\r\n            WebXRHandTracking._LeftHandGLB = null;\r\n        }\r\n\r\n        if (this._handResources.jointMeshes) {\r\n            this._handResources.jointMeshes.left.forEach((trackedMesh) => trackedMesh.dispose());\r\n            this._handResources.jointMeshes.right.forEach((trackedMesh) => trackedMesh.dispose());\r\n        }\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHandTracking.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHandTracking(xrSessionManager, options);\r\n    },\r\n    WebXRHandTracking.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}