{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Vector3, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Animation } from \"../../Animations/animation.js\";\n/**\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\n */\nexport class FramingBehavior {\n  constructor() {\n    /**\n     * An event triggered when the animation to zoom on target mesh has ended\n     */\n    this.onTargetFramingAnimationEndObservable = new Observable();\n    this._mode = FramingBehavior.FitFrustumSidesMode;\n    this._radiusScale = 1.0;\n    this._positionScale = 0.5;\n    this._defaultElevation = 0.3;\n    this._elevationReturnTime = 1500;\n    this._elevationReturnWaitTime = 1000;\n    this._zoomStopsAnimation = false;\n    this._framingTime = 1500;\n    /**\n     * Define if the behavior should automatically change the configured\n     * camera limits and sensibilities.\n     */\n    this.autoCorrectCameraLimitsAndSensibility = true;\n    this._isPointerDown = false;\n    this._lastInteractionTime = -Infinity;\n    // Framing control\n    this._animatables = new Array();\n    this._betaIsAnimating = false;\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"Framing\";\n  }\n  /**\n   * Sets the current mode used by the behavior\n   */\n  set mode(mode) {\n    this._mode = mode;\n  }\n  /**\n   * Gets current mode used by the behavior.\n   */\n  get mode() {\n    return this._mode;\n  }\n  /**\n   * Sets the scale applied to the radius (1 by default)\n   */\n  set radiusScale(radius) {\n    this._radiusScale = radius;\n  }\n  /**\n   * Gets the scale applied to the radius\n   */\n  get radiusScale() {\n    return this._radiusScale;\n  }\n  /**\n   * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n   */\n  set positionScale(scale) {\n    this._positionScale = scale;\n  }\n  /**\n   * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\n   */\n  get positionScale() {\n    return this._positionScale;\n  }\n  /**\n   * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\n   * behaviour is triggered, in radians.\n   */\n  set defaultElevation(elevation) {\n    this._defaultElevation = elevation;\n  }\n  /**\n   * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\n   * behaviour is triggered, in radians.\n   */\n  get defaultElevation() {\n    return this._defaultElevation;\n  }\n  /**\n   * Sets the time (in milliseconds) taken to return to the default beta position.\n   * Negative value indicates camera should not return to default.\n   */\n  set elevationReturnTime(speed) {\n    this._elevationReturnTime = speed;\n  }\n  /**\n   * Gets the time (in milliseconds) taken to return to the default beta position.\n   * Negative value indicates camera should not return to default.\n   */\n  get elevationReturnTime() {\n    return this._elevationReturnTime;\n  }\n  /**\n   * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\n   */\n  set elevationReturnWaitTime(time) {\n    this._elevationReturnWaitTime = time;\n  }\n  /**\n   * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\n   */\n  get elevationReturnWaitTime() {\n    return this._elevationReturnWaitTime;\n  }\n  /**\n   * Sets the flag that indicates if user zooming should stop animation.\n   */\n  set zoomStopsAnimation(flag) {\n    this._zoomStopsAnimation = flag;\n  }\n  /**\n   * Gets the flag that indicates if user zooming should stop animation.\n   */\n  get zoomStopsAnimation() {\n    return this._zoomStopsAnimation;\n  }\n  /**\n   * Sets the transition time when framing the mesh, in milliseconds\n   */\n  set framingTime(time) {\n    this._framingTime = time;\n  }\n  /**\n   * Gets the transition time when framing the mesh, in milliseconds\n   */\n  get framingTime() {\n    return this._framingTime;\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    const scene = this._attachedCamera.getScene();\n    FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(pointerInfoPre => {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        this._isPointerDown = true;\n        return;\n      }\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        this._isPointerDown = false;\n      }\n    });\n    this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add(mesh => {\n      if (mesh) {\n        this.zoomOnMesh(mesh, undefined, () => {\n          this.onTargetFramingAnimationEndObservable.notifyObservers();\n        });\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      this._applyUserInteraction();\n      // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\n      // back to the default position after a given timeout\n      this._maintainCameraAboveGround();\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    const scene = this._attachedCamera.getScene();\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n    if (this._onAfterCheckInputsObserver) {\n      this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    }\n    if (this._onMeshTargetChangedObserver) {\n      this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\n    }\n    this._attachedCamera = null;\n  }\n  /**\n   * Targets the given mesh and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMesh(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {\n    mesh.computeWorldMatrix(true);\n    const boundingBox = mesh.getBoundingInfo().boundingBox;\n    this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the given mesh with its children and updates zoom level accordingly.\n   * @param mesh  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMeshHierarchy(mesh, focusOnOriginXZ = false, onAnimationEnd = null) {\n    mesh.computeWorldMatrix(true);\n    const boundingBox = mesh.getHierarchyBoundingVectors(true);\n    this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the given meshes with their children and updates zoom level accordingly.\n   * @param meshes  The mesh to target.\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnMeshesHierarchy(meshes, focusOnOriginXZ = false, onAnimationEnd = null) {\n    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    for (let i = 0; i < meshes.length; i++) {\n      const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\n      Vector3.CheckExtends(boundingInfo.min, min, max);\n      Vector3.CheckExtends(boundingInfo.max, min, max);\n    }\n    this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\n  }\n  /**\n   * Targets the bounding box info defined by its extends and updates zoom level accordingly.\n   * @param minimumWorld Determines the smaller position of the bounding box extend\n   * @param maximumWorld Determines the bigger position of the bounding box extend\n   * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\n   * @param onAnimationEnd Callback triggered at the end of the framing animation\n   */\n  zoomOnBoundingInfo(minimumWorld, maximumWorld, focusOnOriginXZ = false, onAnimationEnd = null) {\n    let zoomTarget;\n    if (!this._attachedCamera) {\n      return;\n    }\n    // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\n    const bottom = minimumWorld.y;\n    const top = maximumWorld.y;\n    const zoomTargetY = bottom + (top - bottom) * this._positionScale;\n    const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\n    if (focusOnOriginXZ) {\n      zoomTarget = new Vector3(0, zoomTargetY, 0);\n    } else {\n      const centerWorld = minimumWorld.add(radiusWorld);\n      zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\n    }\n    if (!this._vectorTransition) {\n      this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\n    }\n    this._betaIsAnimating = true;\n    let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n    // sets the radius and lower radius bounds\n    // Small delta ensures camera is not always at lower zoom limit.\n    let radius = 0;\n    if (this._mode === FramingBehavior.FitFrustumSidesMode) {\n      const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n      if (this.autoCorrectCameraLimitsAndSensibility) {\n        this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\n      }\n      radius = position;\n    } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\n      if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\n        this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\n      }\n    }\n    // Set sensibilities\n    if (this.autoCorrectCameraLimitsAndSensibility) {\n      const extend = maximumWorld.subtract(minimumWorld).length();\n      this._attachedCamera.panningSensibility = 5000 / extend;\n      this._attachedCamera.wheelPrecision = 100 / radius;\n    }\n    // transition to new radius\n    if (!this._radiusTransition) {\n      this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n    }\n    animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\n      this.stopAllAnimations();\n      if (onAnimationEnd) {\n        onAnimationEnd();\n      }\n      if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\n        this._attachedCamera.storeState();\n      }\n    });\n    if (animatable) {\n      this._animatables.push(animatable);\n    }\n  }\n  /**\n   * Calculates the lowest radius for the camera based on the bounding box of the mesh.\n   * @param minimumWorld\n   * @param maximumWorld\n   * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\n   *\t\t to fully enclose the mesh in the viewing frustum.\n   */\n  _calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld) {\n    const size = maximumWorld.subtract(minimumWorld);\n    const boxVectorGlobalDiagonal = size.length();\n    const frustumSlope = this._getFrustumSlope();\n    // Formula for setting distance\n    // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\n    const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\n    // Horizon distance\n    const radius = radiusWithoutFraming * this._radiusScale;\n    const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\n    const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\n    let distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return 0;\n    }\n    if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\n      // Don't exceed the requested limit\n      distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\n    }\n    // Don't exceed the upper radius limit\n    if (camera.upperRadiusLimit) {\n      distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\n    }\n    return distance;\n  }\n  /**\n   * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\n   * is automatically returned to its default position (expected to be above ground plane).\n   */\n  _maintainCameraAboveGround() {\n    if (this._elevationReturnTime < 0) {\n      return;\n    }\n    const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\n    const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\n    const limitBeta = Math.PI * 0.5;\n    // Bring the camera back up if below the ground plane\n    if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\n      this._betaIsAnimating = true;\n      //Transition to new position\n      this.stopAllAnimations();\n      if (!this._betaTransition) {\n        this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\n      }\n      const animatabe = Animation.TransitionTo(\"beta\", defaultBeta, this._attachedCamera, this._attachedCamera.getScene(), 60, this._betaTransition, this._elevationReturnTime, () => {\n        this._clearAnimationLocks();\n        this.stopAllAnimations();\n      });\n      if (animatabe) {\n        this._animatables.push(animatabe);\n      }\n    }\n  }\n  /**\n   * Returns the frustum slope based on the canvas ratio and camera FOV\n   * @returns The frustum slope represented as a Vector2 with X and Y slopes\n   */\n  _getFrustumSlope() {\n    // Calculate the viewport ratio\n    // Aspect Ratio is Height/Width.\n    const camera = this._attachedCamera;\n    if (!camera) {\n      return Vector2.Zero();\n    }\n    const engine = camera.getScene().getEngine();\n    const aspectRatio = engine.getAspectRatio(camera);\n    // Camera FOV is the vertical field of view (top-bottom) in radians.\n    // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\n    const frustumSlopeY = Math.tan(camera.fov / 2);\n    // Slope of the frustum left/right planes in view space, relative to the forward vector.\n    // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\n    // along the forward vector.\n    const frustumSlopeX = frustumSlopeY * aspectRatio;\n    return new Vector2(frustumSlopeX, frustumSlopeY);\n  }\n  /**\n   * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\n   */\n  _clearAnimationLocks() {\n    this._betaIsAnimating = false;\n  }\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n  _applyUserInteraction() {\n    if (this.isUserIsMoving) {\n      this._lastInteractionTime = PrecisionDate.Now;\n      this.stopAllAnimations();\n      this._clearAnimationLocks();\n    }\n  }\n  /**\n   * Stops and removes all animations that have been applied to the camera\n   */\n  stopAllAnimations() {\n    if (this._attachedCamera) {\n      this._attachedCamera.animations = [];\n    }\n    while (this._animatables.length) {\n      if (this._animatables[0]) {\n        this._animatables[0].onAnimationEnd = null;\n        this._animatables[0].stop();\n      }\n      this._animatables.shift();\n    }\n  }\n  /**\n   * Gets a value indicating if the user is moving the camera\n   */\n  get isUserIsMoving() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  }\n}\n/**\n * The easing function used by animations\n */\nFramingBehavior.EasingFunction = new ExponentialEase();\n/**\n * The easing mode used by animations\n */\nFramingBehavior.EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\n// Statics\n/**\n * The camera can move all the way towards the mesh.\n */\nFramingBehavior.IgnoreBoundsSizeMode = 0;\n/**\n * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\n */\nFramingBehavior.FitFrustumSidesMode = 1;","map":{"version":3,"mappings":"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","names":["ExponentialEase","EasingFunction","Observable","PointerEventTypes","PrecisionDate","Vector3","Vector2","Animation","FramingBehavior","constructor","FitFrustumSidesMode","Infinity","Array","name","mode","_mode","radiusScale","radius","_radiusScale","positionScale","scale","_positionScale","defaultElevation","elevation","_defaultElevation","elevationReturnTime","speed","_elevationReturnTime","elevationReturnWaitTime","time","_elevationReturnWaitTime","zoomStopsAnimation","flag","_zoomStopsAnimation","framingTime","_framingTime","init","attach","camera","_attachedCamera","scene","getScene","setEasingMode","EasingMode","_onPrePointerObservableObserver","onPrePointerObservable","add","pointerInfoPre","type","POINTERDOWN","_isPointerDown","POINTERUP","_onMeshTargetChangedObserver","onMeshTargetChangedObservable","mesh","zoomOnMesh","undefined","onTargetFramingAnimationEndObservable","notifyObservers","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_applyUserInteraction","_maintainCameraAboveGround","detach","remove","focusOnOriginXZ","onAnimationEnd","computeWorldMatrix","boundingBox","getBoundingInfo","zoomOnBoundingInfo","minimumWorld","maximumWorld","zoomOnMeshHierarchy","getHierarchyBoundingVectors","min","max","zoomOnMeshesHierarchy","meshes","Number","MAX_VALUE","i","length","boundingInfo","CheckExtends","zoomTarget","bottom","y","top","zoomTargetY","radiusWorld","subtract","centerWorld","x","z","_vectorTransition","CreateAnimation","ANIMATIONTYPE_VECTOR3","_betaIsAnimating","animatable","TransitionTo","_animatables","push","position","_calculateLowerRadiusFromModelBoundingSphere","autoCorrectCameraLimitsAndSensibility","lowerRadiusLimit","minZ","IgnoreBoundsSizeMode","extend","panningSensibility","wheelPrecision","_radiusTransition","ANIMATIONTYPE_FLOAT","stopAllAnimations","useInputToRestoreState","storeState","size","boxVectorGlobalDiagonal","frustumSlope","_getFrustumSlope","radiusWithoutFraming","distanceForHorizontalFrustum","Math","sqrt","distanceForVerticalFrustum","distance","upperRadiusLimit","timeSinceInteraction","Now","_lastInteractionTime","defaultBeta","PI","limitBeta","beta","_betaTransition","animatabe","_clearAnimationLocks","Zero","engine","getEngine","aspectRatio","getAspectRatio","frustumSlopeY","tan","fov","frustumSlopeX","isUserIsMoving","animations","stop","shift","inertialAlphaOffset","inertialBetaOffset","inertialRadiusOffset","inertialPanningX","inertialPanningY","EASINGMODE_EASEINOUT"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Cameras/framingBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { ExponentialEase, EasingFunction } from \"../../Animations/easing\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\n\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Vector3, Vector2 } from \"../../Maths/math.vector\";\r\nimport type { Animatable } from \"../../Animations/animatable\";\r\nimport { Animation } from \"../../Animations/animation\";\r\n\r\n/**\r\n * The framing behavior (FramingBehavior) is designed to automatically position an ArcRotateCamera when its target is set to a mesh. It is also useful if you want to prevent the camera to go under a virtual horizontal plane.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#framing-behavior\r\n */\r\nexport class FramingBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"Framing\";\r\n    }\r\n\r\n    /**\r\n     * An event triggered when the animation to zoom on target mesh has ended\r\n     */\r\n    public onTargetFramingAnimationEndObservable = new Observable<void>();\r\n\r\n    private _mode = FramingBehavior.FitFrustumSidesMode;\r\n    private _radiusScale = 1.0;\r\n    private _positionScale = 0.5;\r\n    private _defaultElevation = 0.3;\r\n    private _elevationReturnTime = 1500;\r\n    private _elevationReturnWaitTime = 1000;\r\n    private _zoomStopsAnimation = false;\r\n    private _framingTime = 1500;\r\n\r\n    /**\r\n     * The easing function used by animations\r\n     */\r\n    public static EasingFunction = new ExponentialEase();\r\n\r\n    /**\r\n     * The easing mode used by animations\r\n     */\r\n    public static EasingMode = EasingFunction.EASINGMODE_EASEINOUT;\r\n\r\n    /**\r\n     * Sets the current mode used by the behavior\r\n     */\r\n    public set mode(mode: number) {\r\n        this._mode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets current mode used by the behavior.\r\n     */\r\n    public get mode(): number {\r\n        return this._mode;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale applied to the radius (1 by default)\r\n     */\r\n    public set radiusScale(radius: number) {\r\n        this._radiusScale = radius;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale applied to the radius\r\n     */\r\n    public get radiusScale(): number {\r\n        return this._radiusScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public set positionScale(scale: number) {\r\n        this._positionScale = scale;\r\n    }\r\n\r\n    /**\r\n     * Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.\r\n     */\r\n    public get positionScale(): number {\r\n        return this._positionScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public set defaultElevation(elevation: number) {\r\n        this._defaultElevation = elevation;\r\n    }\r\n\r\n    /**\r\n     * Gets the angle above/below the horizontal plane to return to when the return to default elevation idle\r\n     * behaviour is triggered, in radians.\r\n     */\r\n    public get defaultElevation() {\r\n        return this._defaultElevation;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public set elevationReturnTime(speed: number) {\r\n        this._elevationReturnTime = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (in milliseconds) taken to return to the default beta position.\r\n     * Negative value indicates camera should not return to default.\r\n     */\r\n    public get elevationReturnTime(): number {\r\n        return this._elevationReturnTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public set elevationReturnWaitTime(time: number) {\r\n        this._elevationReturnWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the delay (in milliseconds) taken before the camera returns to the default beta position.\r\n     */\r\n    public get elevationReturnWaitTime(): number {\r\n        return this._elevationReturnWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public set framingTime(time: number) {\r\n        this._framingTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the transition time when framing the mesh, in milliseconds\r\n     */\r\n    public get framingTime() {\r\n        return this._framingTime;\r\n    }\r\n\r\n    /**\r\n     * Define if the behavior should automatically change the configured\r\n     * camera limits and sensibilities.\r\n     */\r\n    public autoCorrectCameraLimitsAndSensibility = true;\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _onMeshTargetChangedObserver: Nullable<Observer<Nullable<AbstractMesh>>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastInteractionTime = -Infinity;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        FramingBehavior.EasingFunction.setEasingMode(FramingBehavior.EasingMode);\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onMeshTargetChangedObserver = camera.onMeshTargetChangedObservable.add((mesh) => {\r\n            if (mesh) {\r\n                this.zoomOnMesh(mesh, undefined, () => {\r\n                    this.onTargetFramingAnimationEndObservable.notifyObservers();\r\n                });\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            // Maintain the camera above the ground. If the user pulls the camera beneath the ground plane, lift it\r\n            // back to the default position after a given timeout\r\n            this._maintainCameraAboveGround();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        if (this._onAfterCheckInputsObserver) {\r\n            this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        }\r\n\r\n        if (this._onMeshTargetChangedObserver) {\r\n            this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver);\r\n        }\r\n\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    // Framing control\r\n    private _animatables = new Array<Animatable>();\r\n    private _betaIsAnimating = false;\r\n    private _betaTransition: Animation;\r\n    private _radiusTransition: Animation;\r\n    private _vectorTransition: Animation;\r\n\r\n    /**\r\n     * Targets the given mesh and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMesh(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        this.zoomOnBoundingInfo(boundingBox.minimumWorld, boundingBox.maximumWorld, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given mesh with its children and updates zoom level accordingly.\r\n     * @param mesh  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshHierarchy(mesh: AbstractMesh, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        const boundingBox = mesh.getHierarchyBoundingVectors(true);\r\n        this.zoomOnBoundingInfo(boundingBox.min, boundingBox.max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the given meshes with their children and updates zoom level accordingly.\r\n     * @param meshes  The mesh to target.\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnMeshesHierarchy(meshes: AbstractMesh[], focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const boundingInfo = meshes[i].getHierarchyBoundingVectors(true);\r\n            Vector3.CheckExtends(boundingInfo.min, min, max);\r\n            Vector3.CheckExtends(boundingInfo.max, min, max);\r\n        }\r\n\r\n        this.zoomOnBoundingInfo(min, max, focusOnOriginXZ, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Targets the bounding box info defined by its extends and updates zoom level accordingly.\r\n     * @param minimumWorld Determines the smaller position of the bounding box extend\r\n     * @param maximumWorld Determines the bigger position of the bounding box extend\r\n     * @param focusOnOriginXZ Determines if the camera should focus on 0 in the X and Z axis instead of the mesh\r\n     * @param onAnimationEnd Callback triggered at the end of the framing animation\r\n     */\r\n    public zoomOnBoundingInfo(minimumWorld: Vector3, maximumWorld: Vector3, focusOnOriginXZ: boolean = false, onAnimationEnd: Nullable<() => void> = null): void {\r\n        let zoomTarget: Vector3;\r\n\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n\r\n        // Find target by interpolating from bottom of bounding box in world-space to top via framingPositionY\r\n        const bottom = minimumWorld.y;\r\n        const top = maximumWorld.y;\r\n        const zoomTargetY = bottom + (top - bottom) * this._positionScale;\r\n        const radiusWorld = maximumWorld.subtract(minimumWorld).scale(0.5);\r\n\r\n        if (focusOnOriginXZ) {\r\n            zoomTarget = new Vector3(0, zoomTargetY, 0);\r\n        } else {\r\n            const centerWorld = minimumWorld.add(radiusWorld);\r\n            zoomTarget = new Vector3(centerWorld.x, zoomTargetY, centerWorld.z);\r\n        }\r\n\r\n        if (!this._vectorTransition) {\r\n            this._vectorTransition = Animation.CreateAnimation(\"target\", Animation.ANIMATIONTYPE_VECTOR3, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        this._betaIsAnimating = true;\r\n        let animatable = Animation.TransitionTo(\"target\", zoomTarget, this._attachedCamera, this._attachedCamera.getScene(), 60, this._vectorTransition, this._framingTime);\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        // sets the radius and lower radius bounds\r\n        // Small delta ensures camera is not always at lower zoom limit.\r\n        let radius = 0;\r\n        if (this._mode === FramingBehavior.FitFrustumSidesMode) {\r\n            const position = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility) {\r\n                this._attachedCamera.lowerRadiusLimit = radiusWorld.length() + this._attachedCamera.minZ;\r\n            }\r\n            radius = position;\r\n        } else if (this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            radius = this._calculateLowerRadiusFromModelBoundingSphere(minimumWorld, maximumWorld);\r\n            if (this.autoCorrectCameraLimitsAndSensibility && this._attachedCamera.lowerRadiusLimit === null) {\r\n                this._attachedCamera.lowerRadiusLimit = this._attachedCamera.minZ;\r\n            }\r\n        }\r\n\r\n        // Set sensibilities\r\n        if (this.autoCorrectCameraLimitsAndSensibility) {\r\n            const extend = maximumWorld.subtract(minimumWorld).length();\r\n            this._attachedCamera.panningSensibility = 5000 / extend;\r\n            this._attachedCamera.wheelPrecision = 100 / radius;\r\n        }\r\n\r\n        // transition to new radius\r\n        if (!this._radiusTransition) {\r\n            this._radiusTransition = Animation.CreateAnimation(\"radius\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n        }\r\n\r\n        animatable = Animation.TransitionTo(\"radius\", radius, this._attachedCamera, this._attachedCamera.getScene(), 60, this._radiusTransition, this._framingTime, () => {\r\n            this.stopAllAnimations();\r\n            if (onAnimationEnd) {\r\n                onAnimationEnd();\r\n            }\r\n\r\n            if (this._attachedCamera && this._attachedCamera.useInputToRestoreState) {\r\n                this._attachedCamera.storeState();\r\n            }\r\n        });\r\n\r\n        if (animatable) {\r\n            this._animatables.push(animatable);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the lowest radius for the camera based on the bounding box of the mesh.\r\n     * @param minimumWorld\r\n     * @param maximumWorld\r\n     * @returns The minimum distance from the primary mesh's center point at which the camera must be kept in order\r\n     *\t\t to fully enclose the mesh in the viewing frustum.\r\n     */\r\n    protected _calculateLowerRadiusFromModelBoundingSphere(minimumWorld: Vector3, maximumWorld: Vector3): number {\r\n        const size = maximumWorld.subtract(minimumWorld);\r\n        const boxVectorGlobalDiagonal = size.length();\r\n        const frustumSlope: Vector2 = this._getFrustumSlope();\r\n\r\n        // Formula for setting distance\r\n        // (Good explanation: http://stackoverflow.com/questions/2866350/move-camera-to-fit-3d-scene)\r\n        const radiusWithoutFraming = boxVectorGlobalDiagonal * 0.5;\r\n\r\n        // Horizon distance\r\n        const radius = radiusWithoutFraming * this._radiusScale;\r\n        const distanceForHorizontalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.x * frustumSlope.x));\r\n        const distanceForVerticalFrustum = radius * Math.sqrt(1.0 + 1.0 / (frustumSlope.y * frustumSlope.y));\r\n        let distance = Math.max(distanceForHorizontalFrustum, distanceForVerticalFrustum);\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return 0;\r\n        }\r\n\r\n        if (camera.lowerRadiusLimit && this._mode === FramingBehavior.IgnoreBoundsSizeMode) {\r\n            // Don't exceed the requested limit\r\n            distance = distance < camera.lowerRadiusLimit ? camera.lowerRadiusLimit : distance;\r\n        }\r\n\r\n        // Don't exceed the upper radius limit\r\n        if (camera.upperRadiusLimit) {\r\n            distance = distance > camera.upperRadiusLimit ? camera.upperRadiusLimit : distance;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n\r\n    /**\r\n     * Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera\r\n     * is automatically returned to its default position (expected to be above ground plane).\r\n     */\r\n    private _maintainCameraAboveGround(): void {\r\n        if (this._elevationReturnTime < 0) {\r\n            return;\r\n        }\r\n\r\n        const timeSinceInteraction = PrecisionDate.Now - this._lastInteractionTime;\r\n        const defaultBeta = Math.PI * 0.5 - this._defaultElevation;\r\n        const limitBeta = Math.PI * 0.5;\r\n\r\n        // Bring the camera back up if below the ground plane\r\n        if (this._attachedCamera && !this._betaIsAnimating && this._attachedCamera.beta > limitBeta && timeSinceInteraction >= this._elevationReturnWaitTime) {\r\n            this._betaIsAnimating = true;\r\n\r\n            //Transition to new position\r\n            this.stopAllAnimations();\r\n\r\n            if (!this._betaTransition) {\r\n                this._betaTransition = Animation.CreateAnimation(\"beta\", Animation.ANIMATIONTYPE_FLOAT, 60, FramingBehavior.EasingFunction);\r\n            }\r\n\r\n            const animatabe = Animation.TransitionTo(\r\n                \"beta\",\r\n                defaultBeta,\r\n                this._attachedCamera,\r\n                this._attachedCamera.getScene(),\r\n                60,\r\n                this._betaTransition,\r\n                this._elevationReturnTime,\r\n                () => {\r\n                    this._clearAnimationLocks();\r\n                    this.stopAllAnimations();\r\n                }\r\n            );\r\n\r\n            if (animatabe) {\r\n                this._animatables.push(animatabe);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the frustum slope based on the canvas ratio and camera FOV\r\n     * @returns The frustum slope represented as a Vector2 with X and Y slopes\r\n     */\r\n    private _getFrustumSlope(): Vector2 {\r\n        // Calculate the viewport ratio\r\n        // Aspect Ratio is Height/Width.\r\n        const camera = this._attachedCamera;\r\n\r\n        if (!camera) {\r\n            return Vector2.Zero();\r\n        }\r\n\r\n        const engine = camera.getScene().getEngine();\r\n        const aspectRatio = engine.getAspectRatio(camera);\r\n\r\n        // Camera FOV is the vertical field of view (top-bottom) in radians.\r\n        // Slope of the frustum top/bottom planes in view space, relative to the forward vector.\r\n        const frustumSlopeY = Math.tan(camera.fov / 2);\r\n\r\n        // Slope of the frustum left/right planes in view space, relative to the forward vector.\r\n        // Provides the amount that one side (e.g. left) of the frustum gets wider for every unit\r\n        // along the forward vector.\r\n        const frustumSlopeX = frustumSlopeY * aspectRatio;\r\n\r\n        return new Vector2(frustumSlopeX, frustumSlopeY);\r\n    }\r\n\r\n    /**\r\n     * Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.\r\n     */\r\n    private _clearAnimationLocks(): void {\r\n        this._betaIsAnimating = false;\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this.isUserIsMoving) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n            this.stopAllAnimations();\r\n            this._clearAnimationLocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops and removes all animations that have been applied to the camera\r\n     */\r\n    public stopAllAnimations(): void {\r\n        if (this._attachedCamera) {\r\n            this._attachedCamera.animations = [];\r\n        }\r\n\r\n        while (this._animatables.length) {\r\n            if (this._animatables[0]) {\r\n                this._animatables[0].onAnimationEnd = null;\r\n                this._animatables[0].stop();\r\n            }\r\n            this._animatables.shift();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the user is moving the camera\r\n     */\r\n    public get isUserIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * The camera can move all the way towards the mesh.\r\n     */\r\n    public static IgnoreBoundsSizeMode = 0;\r\n\r\n    /**\r\n     * The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides\r\n     */\r\n    public static FitFrustumSidesMode = 1;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}