{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector.js\";\nimport { Space, Axis } from \"../Maths/math.axis.js\";\n/**\n * Class used to make a bone look toward a point in space\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#bonelookcontroller\n */\nexport class BoneLookController {\n  /**\n   * Create a BoneLookController\n   * @param mesh the TransformNode that the bone belongs to\n   * @param bone the bone that will be looking to the target\n   * @param target the target Vector3 to look at\n   * @param options optional settings:\n   * * maxYaw: the maximum angle the bone will yaw to\n   * * minYaw: the minimum angle the bone will yaw to\n   * * maxPitch: the maximum angle the bone will pitch to\n   * * minPitch: the minimum angle the bone will yaw to\n   * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\n   * * upAxis: the up axis of the coordinate system\n   * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\n   * * yawAxis: set yawAxis if the bone does not yaw on the y axis\n   * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\n   * * adjustYaw: used to make an adjustment to the yaw of the bone\n   * * adjustPitch: used to make an adjustment to the pitch of the bone\n   * * adjustRoll: used to make an adjustment to the roll of the bone\n   * @param options.maxYaw\n   * @param options.minYaw\n   * @param options.maxPitch\n   * @param options.minPitch\n   * @param options.slerpAmount\n   * @param options.upAxis\n   * @param options.upAxisSpace\n   * @param options.yawAxis\n   * @param options.pitchAxis\n   * @param options.adjustYaw\n   * @param options.adjustPitch\n   * @param options.adjustRoll\n   **/\n  constructor(mesh, bone, target, options) {\n    /**\n     * The up axis of the coordinate system that is used when the bone is rotated\n     */\n    this.upAxis = Vector3.Up();\n    /**\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\n     */\n    this.upAxisSpace = Space.LOCAL;\n    /**\n     * Used to make an adjustment to the yaw of the bone\n     */\n    this.adjustYaw = 0;\n    /**\n     * Used to make an adjustment to the pitch of the bone\n     */\n    this.adjustPitch = 0;\n    /**\n     * Used to make an adjustment to the roll of the bone\n     */\n    this.adjustRoll = 0;\n    /**\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\n     */\n    this.slerpAmount = 1;\n    this._boneQuat = Quaternion.Identity();\n    this._slerping = false;\n    this._firstFrameSkipped = false;\n    this._fowardAxis = Vector3.Forward();\n    this.mesh = mesh;\n    this.bone = bone;\n    this.target = target;\n    if (options) {\n      if (options.adjustYaw) {\n        this.adjustYaw = options.adjustYaw;\n      }\n      if (options.adjustPitch) {\n        this.adjustPitch = options.adjustPitch;\n      }\n      if (options.adjustRoll) {\n        this.adjustRoll = options.adjustRoll;\n      }\n      if (options.maxYaw != null) {\n        this.maxYaw = options.maxYaw;\n      } else {\n        this.maxYaw = Math.PI;\n      }\n      if (options.minYaw != null) {\n        this.minYaw = options.minYaw;\n      } else {\n        this.minYaw = -Math.PI;\n      }\n      if (options.maxPitch != null) {\n        this.maxPitch = options.maxPitch;\n      } else {\n        this.maxPitch = Math.PI;\n      }\n      if (options.minPitch != null) {\n        this.minPitch = options.minPitch;\n      } else {\n        this.minPitch = -Math.PI;\n      }\n      if (options.slerpAmount != null) {\n        this.slerpAmount = options.slerpAmount;\n      }\n      if (options.upAxis != null) {\n        this.upAxis = options.upAxis;\n      }\n      if (options.upAxisSpace != null) {\n        this.upAxisSpace = options.upAxisSpace;\n      }\n      if (options.yawAxis != null || options.pitchAxis != null) {\n        let newYawAxis = Axis.Y;\n        let newPitchAxis = Axis.X;\n        if (options.yawAxis != null) {\n          newYawAxis = options.yawAxis.clone();\n          newYawAxis.normalize();\n        }\n        if (options.pitchAxis != null) {\n          newPitchAxis = options.pitchAxis.clone();\n          newPitchAxis.normalize();\n        }\n        const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\n        this._transformYawPitch = Matrix.Identity();\n        Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n        this._transformYawPitchInv = this._transformYawPitch.clone();\n        this._transformYawPitch.invert();\n      }\n    }\n    if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\n      this.upAxisSpace = Space.LOCAL;\n    }\n  }\n  /**\n   * Gets or sets the minimum yaw angle that the bone can look to\n   */\n  get minYaw() {\n    return this._minYaw;\n  }\n  set minYaw(value) {\n    this._minYaw = value;\n    this._minYawSin = Math.sin(value);\n    this._minYawCos = Math.cos(value);\n    if (this._maxYaw != null) {\n      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n      this._yawRange = this._maxYaw - this._minYaw;\n    }\n  }\n  /**\n   * Gets or sets the maximum yaw angle that the bone can look to\n   */\n  get maxYaw() {\n    return this._maxYaw;\n  }\n  set maxYaw(value) {\n    this._maxYaw = value;\n    this._maxYawSin = Math.sin(value);\n    this._maxYawCos = Math.cos(value);\n    if (this._minYaw != null) {\n      this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\n      this._yawRange = this._maxYaw - this._minYaw;\n    }\n  }\n  /**\n   * Gets or sets the minimum pitch angle that the bone can look to\n   */\n  get minPitch() {\n    return this._minPitch;\n  }\n  set minPitch(value) {\n    this._minPitch = value;\n    this._minPitchTan = Math.tan(value);\n  }\n  /**\n   * Gets or sets the maximum pitch angle that the bone can look to\n   */\n  get maxPitch() {\n    return this._maxPitch;\n  }\n  set maxPitch(value) {\n    this._maxPitch = value;\n    this._maxPitchTan = Math.tan(value);\n  }\n  /**\n   * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\n   */\n  update() {\n    //skip the first frame when slerping so that the TransformNode rotation is correct\n    if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n      this._firstFrameSkipped = true;\n      return;\n    }\n    const bone = this.bone;\n    const bonePos = BoneLookController._TmpVecs[0];\n    bone.getAbsolutePositionToRef(this.mesh, bonePos);\n    let target = this.target;\n    const _tmpMat1 = BoneLookController._TmpMats[0];\n    const _tmpMat2 = BoneLookController._TmpMats[1];\n    const mesh = this.mesh;\n    const parentBone = bone.getParent();\n    const upAxis = BoneLookController._TmpVecs[1];\n    upAxis.copyFrom(this.upAxis);\n    if (this.upAxisSpace == Space.BONE && parentBone) {\n      if (this._transformYawPitch) {\n        Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n      }\n      parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n    } else if (this.upAxisSpace == Space.LOCAL) {\n      mesh.getDirectionToRef(upAxis, upAxis);\n      if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n        upAxis.normalize();\n      }\n    }\n    let checkYaw = false;\n    let checkPitch = false;\n    if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n      checkYaw = true;\n    }\n    if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n      checkPitch = true;\n    }\n    if (checkYaw || checkPitch) {\n      const spaceMat = BoneLookController._TmpMats[2];\n      const spaceMatInv = BoneLookController._TmpMats[3];\n      if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\n        parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\n      } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\n        spaceMat.copyFrom(mesh.getWorldMatrix());\n      } else {\n        let forwardAxis = BoneLookController._TmpVecs[2];\n        forwardAxis.copyFrom(this._fowardAxis);\n        if (this._transformYawPitch) {\n          Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n        }\n        if (parentBone) {\n          parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n        } else {\n          mesh.getDirectionToRef(forwardAxis, forwardAxis);\n        }\n        const rightAxis = Vector3.Cross(upAxis, forwardAxis);\n        rightAxis.normalize();\n        forwardAxis = Vector3.Cross(rightAxis, upAxis);\n        Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n      }\n      spaceMat.invertToRef(spaceMatInv);\n      let xzlen = null;\n      if (checkPitch) {\n        const localTarget = BoneLookController._TmpVecs[3];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n        const pitch = Math.atan2(localTarget.y, xzlen);\n        let newPitch = pitch;\n        if (pitch > this._maxPitch) {\n          localTarget.y = this._maxPitchTan * xzlen;\n          newPitch = this._maxPitch;\n        } else if (pitch < this._minPitch) {\n          localTarget.y = this._minPitchTan * xzlen;\n          newPitch = this._minPitch;\n        }\n        if (pitch != newPitch) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n      if (checkYaw) {\n        const localTarget = BoneLookController._TmpVecs[4];\n        target.subtractToRef(bonePos, localTarget);\n        Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n        const yaw = Math.atan2(localTarget.x, localTarget.z);\n        let newYaw = yaw;\n        if (yaw > this._maxYaw || yaw < this._minYaw) {\n          if (xzlen == null) {\n            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n          }\n          if (this._yawRange > Math.PI) {\n            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          } else {\n            if (yaw > this._maxYaw) {\n              localTarget.z = this._maxYawCos * xzlen;\n              localTarget.x = this._maxYawSin * xzlen;\n              newYaw = this._maxYaw;\n            } else if (yaw < this._minYaw) {\n              localTarget.z = this._minYawCos * xzlen;\n              localTarget.x = this._minYawSin * xzlen;\n              newYaw = this._minYaw;\n            }\n          }\n        }\n        if (this._slerping && this._yawRange > Math.PI) {\n          //are we going to be crossing into the min/max region?\n          const boneFwd = BoneLookController._TmpVecs[8];\n          boneFwd.copyFrom(Axis.Z);\n          if (this._transformYawPitch) {\n            Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n          }\n          const boneRotMat = BoneLookController._TmpMats[4];\n          this._boneQuat.toRotationMatrix(boneRotMat);\n          this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n          Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n          Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n          const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n          const angBtwTar = this._getAngleBetween(boneYaw, yaw);\n          const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n          if (angBtwTar > angBtwMidYaw) {\n            if (xzlen == null) {\n              xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n            }\n            const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n            const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n            if (angBtwMin < angBtwMax) {\n              newYaw = boneYaw + Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            } else {\n              newYaw = boneYaw - Math.PI * 0.75;\n              localTarget.z = Math.cos(newYaw) * xzlen;\n              localTarget.x = Math.sin(newYaw) * xzlen;\n            }\n          }\n        }\n        if (yaw != newYaw) {\n          Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n          localTarget.addInPlace(bonePos);\n          target = localTarget;\n        }\n      }\n    }\n    const zaxis = BoneLookController._TmpVecs[5];\n    const xaxis = BoneLookController._TmpVecs[6];\n    const yaxis = BoneLookController._TmpVecs[7];\n    const tmpQuat = BoneLookController._TmpQuat;\n    target.subtractToRef(bonePos, zaxis);\n    zaxis.normalize();\n    Vector3.CrossToRef(upAxis, zaxis, xaxis);\n    xaxis.normalize();\n    Vector3.CrossToRef(zaxis, xaxis, yaxis);\n    yaxis.normalize();\n    Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n    if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n      return;\n    }\n    if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n      return;\n    }\n    if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n      return;\n    }\n    if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n      Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n      _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n    }\n    if (this.slerpAmount < 1) {\n      if (!this._slerping) {\n        this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\n      }\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n      Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\n      Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\n      this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\n      this._slerping = true;\n    } else {\n      if (this._transformYawPitch) {\n        this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n      }\n      this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\n      this._slerping = false;\n    }\n    this._updateLinkedTransformRotation();\n  }\n  _getAngleDiff(ang1, ang2) {\n    let angDiff = ang2 - ang1;\n    angDiff %= Math.PI * 2;\n    if (angDiff > Math.PI) {\n      angDiff -= Math.PI * 2;\n    } else if (angDiff < -Math.PI) {\n      angDiff += Math.PI * 2;\n    }\n    return angDiff;\n  }\n  _getAngleBetween(ang1, ang2) {\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    let ab = 0;\n    if (ang1 < ang2) {\n      ab = ang2 - ang1;\n    } else {\n      ab = ang1 - ang2;\n    }\n    if (ab > Math.PI) {\n      ab = Math.PI * 2 - ab;\n    }\n    return ab;\n  }\n  _isAngleBetween(ang, ang1, ang2) {\n    ang %= 2 * Math.PI;\n    ang = ang < 0 ? ang + 2 * Math.PI : ang;\n    ang1 %= 2 * Math.PI;\n    ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\n    ang2 %= 2 * Math.PI;\n    ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\n    if (ang1 < ang2) {\n      if (ang > ang1 && ang < ang2) {\n        return true;\n      }\n    } else {\n      if (ang > ang2 && ang < ang1) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _updateLinkedTransformRotation() {\n    const bone = this.bone;\n    if (bone._linkedTransformNode) {\n      if (!bone._linkedTransformNode.rotationQuaternion) {\n        bone._linkedTransformNode.rotationQuaternion = new Quaternion();\n      }\n      bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\n    }\n  }\n}\nBoneLookController._TmpVecs = ArrayTools.BuildArray(10, Vector3.Zero);\nBoneLookController._TmpQuat = Quaternion.Identity();\nBoneLookController._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);","map":{"version":3,"mappings":"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","names":["ArrayTools","Vector3","Quaternion","Matrix","Space","Axis","BoneLookController","constructor","mesh","bone","target","options","Up","LOCAL","Identity","Forward","adjustYaw","adjustPitch","adjustRoll","maxYaw","Math","PI","minYaw","maxPitch","minPitch","slerpAmount","upAxis","upAxisSpace","yawAxis","pitchAxis","newYawAxis","Y","newPitchAxis","X","clone","normalize","newRollAxis","Cross","_transformYawPitch","FromXYZAxesToRef","_transformYawPitchInv","invert","getParent","BONE","_minYaw","value","_minYawSin","sin","_minYawCos","cos","_maxYaw","_midYawConstraint","_getAngleDiff","_yawRange","_maxYawSin","_maxYawCos","_minPitch","_minPitchTan","tan","_maxPitch","_maxPitchTan","update","_firstFrameSkipped","bonePos","_TmpVecs","getAbsolutePositionToRef","_tmpMat1","_TmpMats","_tmpMat2","parentBone","copyFrom","TransformCoordinatesToRef","getDirectionToRef","scaling","x","y","z","checkYaw","checkPitch","spaceMat","spaceMatInv","getRotationMatrixToRef","WORLD","getWorldMatrix","forwardAxis","_fowardAxis","rightAxis","invertToRef","xzlen","localTarget","subtractToRef","sqrt","pitch","atan2","newPitch","addInPlace","yaw","newYaw","_isAngleBetween","_slerping","boneFwd","Z","boneRotMat","_boneQuat","toRotationMatrix","multiplyToRef","boneYaw","angBtwTar","_getAngleBetween","angBtwMidYaw","angBtwMax","angBtwMin","zaxis","xaxis","yaxis","tmpQuat","_TmpQuat","CrossToRef","RotationYawPitchRollToRef","getRotationQuaternionToRef","FromRotationMatrixToRef","SlerpToRef","setRotationQuaternion","setRotationMatrix","_updateLinkedTransformRotation","ang1","ang2","angDiff","ab","ang","_linkedTransformNode","rotationQuaternion","BuildArray","Zero"],"sourceRoot":"","sources":["../../../../lts/core/generated/Bones/boneLookController.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Vector3, Quaternion, Matrix } from \"../Maths/math.vector\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Bone } from \"./bone\";\r\nimport { Space, Axis } from \"../Maths/math.axis\";\r\n\r\n/**\r\n * Class used to make a bone look toward a point in space\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons#bonelookcontroller\r\n */\r\nexport class BoneLookController {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(10, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * The target Vector3 that the bone will look at\r\n     */\r\n    public target: Vector3;\r\n\r\n    /**\r\n     * The TransformNode that the bone is attached to\r\n     * Name kept as mesh for back compatibility\r\n     */\r\n    public mesh: TransformNode;\r\n\r\n    /**\r\n     * The bone that will be looking to the target\r\n     */\r\n    public bone: Bone;\r\n\r\n    /**\r\n     * The up axis of the coordinate system that is used when the bone is rotated\r\n     */\r\n    public upAxis: Vector3 = Vector3.Up();\r\n\r\n    /**\r\n     * The space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD\r\n     */\r\n    public upAxisSpace: Space = Space.LOCAL;\r\n\r\n    /**\r\n     * Used to make an adjustment to the yaw of the bone\r\n     */\r\n    public adjustYaw = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the pitch of the bone\r\n     */\r\n    public adjustPitch = 0;\r\n\r\n    /**\r\n     * Used to make an adjustment to the roll of the bone\r\n     */\r\n    public adjustRoll = 0;\r\n\r\n    /**\r\n     * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)\r\n     */\r\n    public slerpAmount = 1;\r\n\r\n    private _minYaw: number;\r\n    private _maxYaw: number;\r\n    private _minPitch: number;\r\n    private _maxPitch: number;\r\n    private _minYawSin: number;\r\n    private _minYawCos: number;\r\n    private _maxYawSin: number;\r\n    private _maxYawCos: number;\r\n    private _midYawConstraint: number;\r\n    private _minPitchTan: number;\r\n    private _maxPitchTan: number;\r\n\r\n    private _boneQuat: Quaternion = Quaternion.Identity();\r\n    private _slerping = false;\r\n    private _transformYawPitch: Matrix;\r\n    private _transformYawPitchInv: Matrix;\r\n    private _firstFrameSkipped = false;\r\n    private _yawRange: number;\r\n    private _fowardAxis: Vector3 = Vector3.Forward();\r\n\r\n    /**\r\n     * Gets or sets the minimum yaw angle that the bone can look to\r\n     */\r\n    get minYaw(): number {\r\n        return this._minYaw;\r\n    }\r\n\r\n    set minYaw(value: number) {\r\n        this._minYaw = value;\r\n        this._minYawSin = Math.sin(value);\r\n        this._minYawCos = Math.cos(value);\r\n        if (this._maxYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum yaw angle that the bone can look to\r\n     */\r\n    get maxYaw(): number {\r\n        return this._maxYaw;\r\n    }\r\n\r\n    set maxYaw(value: number) {\r\n        this._maxYaw = value;\r\n        this._maxYawSin = Math.sin(value);\r\n        this._maxYawCos = Math.cos(value);\r\n        if (this._minYaw != null) {\r\n            this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * 0.5 + this._minYaw;\r\n            this._yawRange = this._maxYaw - this._minYaw;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the minimum pitch angle that the bone can look to\r\n     */\r\n    get minPitch(): number {\r\n        return this._minPitch;\r\n    }\r\n\r\n    set minPitch(value: number) {\r\n        this._minPitch = value;\r\n        this._minPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the maximum pitch angle that the bone can look to\r\n     */\r\n    get maxPitch(): number {\r\n        return this._maxPitch;\r\n    }\r\n\r\n    set maxPitch(value: number) {\r\n        this._maxPitch = value;\r\n        this._maxPitchTan = Math.tan(value);\r\n    }\r\n\r\n    /**\r\n     * Create a BoneLookController\r\n     * @param mesh the TransformNode that the bone belongs to\r\n     * @param bone the bone that will be looking to the target\r\n     * @param target the target Vector3 to look at\r\n     * @param options optional settings:\r\n     * * maxYaw: the maximum angle the bone will yaw to\r\n     * * minYaw: the minimum angle the bone will yaw to\r\n     * * maxPitch: the maximum angle the bone will pitch to\r\n     * * minPitch: the minimum angle the bone will yaw to\r\n     * * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\r\n     * * upAxis: the up axis of the coordinate system\r\n     * * upAxisSpace: the space that the up axis is in - Space.BONE, Space.LOCAL (default), or Space.WORLD.\r\n     * * yawAxis: set yawAxis if the bone does not yaw on the y axis\r\n     * * pitchAxis: set pitchAxis if the bone does not pitch on the x axis\r\n     * * adjustYaw: used to make an adjustment to the yaw of the bone\r\n     * * adjustPitch: used to make an adjustment to the pitch of the bone\r\n     * * adjustRoll: used to make an adjustment to the roll of the bone\r\n     * @param options.maxYaw\r\n     * @param options.minYaw\r\n     * @param options.maxPitch\r\n     * @param options.minPitch\r\n     * @param options.slerpAmount\r\n     * @param options.upAxis\r\n     * @param options.upAxisSpace\r\n     * @param options.yawAxis\r\n     * @param options.pitchAxis\r\n     * @param options.adjustYaw\r\n     * @param options.adjustPitch\r\n     * @param options.adjustRoll\r\n     **/\r\n    constructor(\r\n        mesh: TransformNode,\r\n        bone: Bone,\r\n        target: Vector3,\r\n        options?: {\r\n            maxYaw?: number;\r\n            minYaw?: number;\r\n            maxPitch?: number;\r\n            minPitch?: number;\r\n            slerpAmount?: number;\r\n            upAxis?: Vector3;\r\n            upAxisSpace?: Space;\r\n            yawAxis?: Vector3;\r\n            pitchAxis?: Vector3;\r\n            adjustYaw?: number;\r\n            adjustPitch?: number;\r\n            adjustRoll?: number;\r\n        }\r\n    ) {\r\n        this.mesh = mesh;\r\n        this.bone = bone;\r\n        this.target = target;\r\n\r\n        if (options) {\r\n            if (options.adjustYaw) {\r\n                this.adjustYaw = options.adjustYaw;\r\n            }\r\n\r\n            if (options.adjustPitch) {\r\n                this.adjustPitch = options.adjustPitch;\r\n            }\r\n\r\n            if (options.adjustRoll) {\r\n                this.adjustRoll = options.adjustRoll;\r\n            }\r\n\r\n            if (options.maxYaw != null) {\r\n                this.maxYaw = options.maxYaw;\r\n            } else {\r\n                this.maxYaw = Math.PI;\r\n            }\r\n\r\n            if (options.minYaw != null) {\r\n                this.minYaw = options.minYaw;\r\n            } else {\r\n                this.minYaw = -Math.PI;\r\n            }\r\n\r\n            if (options.maxPitch != null) {\r\n                this.maxPitch = options.maxPitch;\r\n            } else {\r\n                this.maxPitch = Math.PI;\r\n            }\r\n\r\n            if (options.minPitch != null) {\r\n                this.minPitch = options.minPitch;\r\n            } else {\r\n                this.minPitch = -Math.PI;\r\n            }\r\n\r\n            if (options.slerpAmount != null) {\r\n                this.slerpAmount = options.slerpAmount;\r\n            }\r\n\r\n            if (options.upAxis != null) {\r\n                this.upAxis = options.upAxis;\r\n            }\r\n\r\n            if (options.upAxisSpace != null) {\r\n                this.upAxisSpace = options.upAxisSpace;\r\n            }\r\n\r\n            if (options.yawAxis != null || options.pitchAxis != null) {\r\n                let newYawAxis = Axis.Y;\r\n                let newPitchAxis = Axis.X;\r\n\r\n                if (options.yawAxis != null) {\r\n                    newYawAxis = options.yawAxis.clone();\r\n                    newYawAxis.normalize();\r\n                }\r\n\r\n                if (options.pitchAxis != null) {\r\n                    newPitchAxis = options.pitchAxis.clone();\r\n                    newPitchAxis.normalize();\r\n                }\r\n\r\n                const newRollAxis = Vector3.Cross(newPitchAxis, newYawAxis);\r\n\r\n                this._transformYawPitch = Matrix.Identity();\r\n                Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\r\n\r\n                this._transformYawPitchInv = this._transformYawPitch.clone();\r\n                this._transformYawPitch.invert();\r\n            }\r\n        }\r\n\r\n        if (!bone.getParent() && this.upAxisSpace == Space.BONE) {\r\n            this.upAxisSpace = Space.LOCAL;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())\r\n     */\r\n    public update(): void {\r\n        //skip the first frame when slerping so that the TransformNode rotation is correct\r\n        if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\r\n            this._firstFrameSkipped = true;\r\n            return;\r\n        }\r\n\r\n        const bone = this.bone;\r\n        const bonePos = BoneLookController._TmpVecs[0];\r\n        bone.getAbsolutePositionToRef(this.mesh, bonePos);\r\n\r\n        let target = this.target;\r\n        const _tmpMat1 = BoneLookController._TmpMats[0];\r\n        const _tmpMat2 = BoneLookController._TmpMats[1];\r\n\r\n        const mesh = this.mesh;\r\n        const parentBone = bone.getParent();\r\n\r\n        const upAxis = BoneLookController._TmpVecs[1];\r\n        upAxis.copyFrom(this.upAxis);\r\n\r\n        if (this.upAxisSpace == Space.BONE && parentBone) {\r\n            if (this._transformYawPitch) {\r\n                Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\r\n            }\r\n            parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\r\n        } else if (this.upAxisSpace == Space.LOCAL) {\r\n            mesh.getDirectionToRef(upAxis, upAxis);\r\n            if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\r\n                upAxis.normalize();\r\n            }\r\n        }\r\n\r\n        let checkYaw = false;\r\n        let checkPitch = false;\r\n\r\n        if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\r\n            checkYaw = true;\r\n        }\r\n        if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\r\n            checkPitch = true;\r\n        }\r\n\r\n        if (checkYaw || checkPitch) {\r\n            const spaceMat = BoneLookController._TmpMats[2];\r\n            const spaceMatInv = BoneLookController._TmpMats[3];\r\n\r\n            if (this.upAxisSpace == Space.BONE && upAxis.y == 1 && parentBone) {\r\n                parentBone.getRotationMatrixToRef(Space.WORLD, this.mesh, spaceMat);\r\n            } else if (this.upAxisSpace == Space.LOCAL && upAxis.y == 1 && !parentBone) {\r\n                spaceMat.copyFrom(mesh.getWorldMatrix());\r\n            } else {\r\n                let forwardAxis = BoneLookController._TmpVecs[2];\r\n                forwardAxis.copyFrom(this._fowardAxis);\r\n\r\n                if (this._transformYawPitch) {\r\n                    Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\r\n                }\r\n\r\n                if (parentBone) {\r\n                    parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\r\n                } else {\r\n                    mesh.getDirectionToRef(forwardAxis, forwardAxis);\r\n                }\r\n\r\n                const rightAxis = Vector3.Cross(upAxis, forwardAxis);\r\n                rightAxis.normalize();\r\n                forwardAxis = Vector3.Cross(rightAxis, upAxis);\r\n\r\n                Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\r\n            }\r\n\r\n            spaceMat.invertToRef(spaceMatInv);\r\n\r\n            let xzlen: Nullable<number> = null;\r\n\r\n            if (checkPitch) {\r\n                const localTarget = BoneLookController._TmpVecs[3];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                const pitch = Math.atan2(localTarget.y, xzlen);\r\n                let newPitch = pitch;\r\n\r\n                if (pitch > this._maxPitch) {\r\n                    localTarget.y = this._maxPitchTan * xzlen;\r\n                    newPitch = this._maxPitch;\r\n                } else if (pitch < this._minPitch) {\r\n                    localTarget.y = this._minPitchTan * xzlen;\r\n                    newPitch = this._minPitch;\r\n                }\r\n\r\n                if (pitch != newPitch) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n\r\n            if (checkYaw) {\r\n                const localTarget = BoneLookController._TmpVecs[4];\r\n                target.subtractToRef(bonePos, localTarget);\r\n                Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\r\n\r\n                const yaw = Math.atan2(localTarget.x, localTarget.z);\r\n                let newYaw = yaw;\r\n\r\n                if (yaw > this._maxYaw || yaw < this._minYaw) {\r\n                    if (xzlen == null) {\r\n                        xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                    }\r\n\r\n                    if (this._yawRange > Math.PI) {\r\n                        if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    } else {\r\n                        if (yaw > this._maxYaw) {\r\n                            localTarget.z = this._maxYawCos * xzlen;\r\n                            localTarget.x = this._maxYawSin * xzlen;\r\n                            newYaw = this._maxYaw;\r\n                        } else if (yaw < this._minYaw) {\r\n                            localTarget.z = this._minYawCos * xzlen;\r\n                            localTarget.x = this._minYawSin * xzlen;\r\n                            newYaw = this._minYaw;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._slerping && this._yawRange > Math.PI) {\r\n                    //are we going to be crossing into the min/max region?\r\n                    const boneFwd = BoneLookController._TmpVecs[8];\r\n                    boneFwd.copyFrom(Axis.Z);\r\n                    if (this._transformYawPitch) {\r\n                        Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\r\n                    }\r\n\r\n                    const boneRotMat = BoneLookController._TmpMats[4];\r\n                    this._boneQuat.toRotationMatrix(boneRotMat);\r\n                    this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\r\n                    Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\r\n\r\n                    const boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\r\n                    const angBtwTar = this._getAngleBetween(boneYaw, yaw);\r\n                    const angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\r\n\r\n                    if (angBtwTar > angBtwMidYaw) {\r\n                        if (xzlen == null) {\r\n                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\r\n                        }\r\n\r\n                        const angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\r\n                        const angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\r\n\r\n                        if (angBtwMin < angBtwMax) {\r\n                            newYaw = boneYaw + Math.PI * 0.75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        } else {\r\n                            newYaw = boneYaw - Math.PI * 0.75;\r\n                            localTarget.z = Math.cos(newYaw) * xzlen;\r\n                            localTarget.x = Math.sin(newYaw) * xzlen;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (yaw != newYaw) {\r\n                    Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\r\n                    localTarget.addInPlace(bonePos);\r\n                    target = localTarget;\r\n                }\r\n            }\r\n        }\r\n\r\n        const zaxis = BoneLookController._TmpVecs[5];\r\n        const xaxis = BoneLookController._TmpVecs[6];\r\n        const yaxis = BoneLookController._TmpVecs[7];\r\n        const tmpQuat = BoneLookController._TmpQuat;\r\n\r\n        target.subtractToRef(bonePos, zaxis);\r\n        zaxis.normalize();\r\n        Vector3.CrossToRef(upAxis, zaxis, xaxis);\r\n        xaxis.normalize();\r\n        Vector3.CrossToRef(zaxis, xaxis, yaxis);\r\n        yaxis.normalize();\r\n        Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\r\n\r\n        if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\r\n            return;\r\n        }\r\n\r\n        if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\r\n            Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\r\n            _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\r\n        }\r\n\r\n        if (this.slerpAmount < 1) {\r\n            if (!this._slerping) {\r\n                this.bone.getRotationQuaternionToRef(Space.WORLD, this.mesh, this._boneQuat);\r\n            }\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            Quaternion.FromRotationMatrixToRef(_tmpMat1, tmpQuat);\r\n            Quaternion.SlerpToRef(this._boneQuat, tmpQuat, this.slerpAmount, this._boneQuat);\r\n\r\n            this.bone.setRotationQuaternion(this._boneQuat, Space.WORLD, this.mesh);\r\n            this._slerping = true;\r\n        } else {\r\n            if (this._transformYawPitch) {\r\n                this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\r\n            }\r\n            this.bone.setRotationMatrix(_tmpMat1, Space.WORLD, this.mesh);\r\n            this._slerping = false;\r\n        }\r\n\r\n        this._updateLinkedTransformRotation();\r\n    }\r\n\r\n    private _getAngleDiff(ang1: number, ang2: number): number {\r\n        let angDiff = ang2 - ang1;\r\n        angDiff %= Math.PI * 2;\r\n\r\n        if (angDiff > Math.PI) {\r\n            angDiff -= Math.PI * 2;\r\n        } else if (angDiff < -Math.PI) {\r\n            angDiff += Math.PI * 2;\r\n        }\r\n\r\n        return angDiff;\r\n    }\r\n\r\n    private _getAngleBetween(ang1: number, ang2: number): number {\r\n        ang1 %= 2 * Math.PI;\r\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\r\n\r\n        ang2 %= 2 * Math.PI;\r\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\r\n\r\n        let ab = 0;\r\n\r\n        if (ang1 < ang2) {\r\n            ab = ang2 - ang1;\r\n        } else {\r\n            ab = ang1 - ang2;\r\n        }\r\n\r\n        if (ab > Math.PI) {\r\n            ab = Math.PI * 2 - ab;\r\n        }\r\n\r\n        return ab;\r\n    }\r\n\r\n    private _isAngleBetween(ang: number, ang1: number, ang2: number): boolean {\r\n        ang %= 2 * Math.PI;\r\n        ang = ang < 0 ? ang + 2 * Math.PI : ang;\r\n        ang1 %= 2 * Math.PI;\r\n        ang1 = ang1 < 0 ? ang1 + 2 * Math.PI : ang1;\r\n        ang2 %= 2 * Math.PI;\r\n        ang2 = ang2 < 0 ? ang2 + 2 * Math.PI : ang2;\r\n\r\n        if (ang1 < ang2) {\r\n            if (ang > ang1 && ang < ang2) {\r\n                return true;\r\n            }\r\n        } else {\r\n            if (ang > ang2 && ang < ang1) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _updateLinkedTransformRotation(): void {\r\n        const bone = this.bone;\r\n        if (bone._linkedTransformNode) {\r\n            if (!bone._linkedTransformNode.rotationQuaternion) {\r\n                bone._linkedTransformNode.rotationQuaternion = new Quaternion();\r\n            }\r\n            bone.getRotationQuaternionToRef(Space.LOCAL, null, bone._linkedTransformNode.rotationQuaternion);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}