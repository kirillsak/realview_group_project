{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Node } from \"../node.js\";\nimport { Space } from \"../Maths/math.axis.js\";\n/**\n * Class used to store bone information\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Bone extends Node {\n  /**\n   * Create a new bone\n   * @param name defines the bone name\n   * @param skeleton defines the parent skeleton\n   * @param parentBone defines the parent (can be null if the bone is the root)\n   * @param localMatrix defines the local matrix\n   * @param restPose defines the rest pose matrix\n   * @param baseMatrix defines the base matrix\n   * @param index defines index of the bone in the hierarchy\n   */\n  constructor(\n  /**\n   * defines the bone name\n   */\n  name, skeleton, parentBone = null, localMatrix = null, restPose = null, baseMatrix = null, index = null) {\n    super(name, skeleton.getScene());\n    this.name = name;\n    /**\n     * Gets the list of child bones\n     */\n    this.children = new Array();\n    /** Gets the animations associated with this bone */\n    this.animations = new Array();\n    /**\n     * @internal Internal only\n     * Set this value to map this bone to a different index in the transform matrices\n     * Set this value to -1 to exclude the bone from the transform matrices\n     */\n    this._index = null;\n    this._absoluteTransform = new Matrix();\n    this._invertedAbsoluteTransform = new Matrix();\n    this._scalingDeterminant = 1;\n    this._worldTransform = new Matrix();\n    this._needToDecompose = true;\n    this._needToCompose = false;\n    /** @internal */\n    this._linkedTransformNode = null;\n    /** @internal */\n    this._waitingTransformNodeId = null;\n    this._skeleton = skeleton;\n    this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\n    this._restPose = restPose ? restPose : this._localMatrix.clone();\n    this._baseMatrix = baseMatrix ? baseMatrix : this._localMatrix.clone();\n    this._index = index;\n    skeleton.bones.push(this);\n    this.setParent(parentBone, false);\n    if (baseMatrix || localMatrix) {\n      this._updateDifferenceMatrix();\n    }\n  }\n  /** @internal */\n  get _matrix() {\n    this._compose();\n    return this._localMatrix;\n  }\n  /** @internal */\n  set _matrix(value) {\n    this._needToCompose = false; // in case there was a pending compose\n    // skip if the matrices are the same\n    if (value.updateFlag === this._localMatrix.updateFlag) {\n      return;\n    }\n    this._localMatrix.copyFrom(value);\n    this._markAsDirtyAndDecompose();\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Bone\";\n  }\n  // Members\n  /**\n   * Gets the parent skeleton\n   * @returns a skeleton\n   */\n  getSkeleton() {\n    return this._skeleton;\n  }\n  get parent() {\n    return this._parentNode;\n  }\n  /**\n   * Gets parent bone\n   * @returns a bone or null if the bone is the root of the bone hierarchy\n   */\n  getParent() {\n    return this.parent;\n  }\n  /**\n   * Returns an array containing the root bones\n   * @returns an array containing the root bones\n   */\n  getChildren() {\n    return this.children;\n  }\n  /**\n   * Gets the node index in matrix array generated for rendering\n   * @returns the node index\n   */\n  getIndex() {\n    return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\n  }\n  set parent(newParent) {\n    this.setParent(newParent);\n  }\n  /**\n   * Sets the parent bone\n   * @param parent defines the parent (can be null if the bone is the root)\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\n   */\n  setParent(parent, updateDifferenceMatrix = true) {\n    if (this.parent === parent) {\n      return;\n    }\n    if (this.parent) {\n      const index = this.parent.children.indexOf(this);\n      if (index !== -1) {\n        this.parent.children.splice(index, 1);\n      }\n    }\n    this._parentNode = parent;\n    if (this.parent) {\n      this.parent.children.push(this);\n    }\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n    this.markAsDirty();\n  }\n  /**\n   * Gets the local matrix\n   * @returns a matrix\n   */\n  getLocalMatrix() {\n    this._compose();\n    return this._localMatrix;\n  }\n  /**\n   * Gets the base matrix (initial matrix which remains unchanged)\n   * @returns the base matrix (as known as bind pose matrix)\n   */\n  getBaseMatrix() {\n    return this._baseMatrix;\n  }\n  /**\n   * Gets the rest pose matrix\n   * @returns a matrix\n   */\n  getRestPose() {\n    return this._restPose;\n  }\n  /**\n   * Sets the rest pose matrix\n   * @param matrix the local-space rest pose to set for this bone\n   */\n  setRestPose(matrix) {\n    this._restPose.copyFrom(matrix);\n  }\n  /**\n   * Gets the bind pose matrix\n   * @returns the bind pose matrix\n   * @deprecated Please use getBaseMatrix instead\n   */\n  getBindPose() {\n    return this._baseMatrix;\n  }\n  /**\n   * Sets the bind pose matrix\n   * @param matrix the local-space bind pose to set for this bone\n   * @deprecated Please use updateMatrix instead\n   */\n  setBindPose(matrix) {\n    this.updateMatrix(matrix);\n  }\n  /**\n   * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\n   */\n  getWorldMatrix() {\n    return this._worldTransform;\n  }\n  /**\n   * Sets the local matrix to rest pose matrix\n   */\n  returnToRest() {\n    var _a;\n    if (this._linkedTransformNode) {\n      const localScaling = TmpVectors.Vector3[0];\n      const localRotation = TmpVectors.Quaternion[0];\n      const localPosition = TmpVectors.Vector3[1];\n      this.getRestPose().decompose(localScaling, localRotation, localPosition);\n      this._linkedTransformNode.position.copyFrom(localPosition);\n      this._linkedTransformNode.rotationQuaternion = (_a = this._linkedTransformNode.rotationQuaternion) !== null && _a !== void 0 ? _a : Quaternion.Identity();\n      this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\n      this._linkedTransformNode.scaling.copyFrom(localScaling);\n    } else {\n      this._matrix = this._restPose;\n    }\n  }\n  /**\n   * Gets the inverse of the absolute transform matrix.\n   * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\n   * @returns a matrix\n   */\n  getInvertedAbsoluteTransform() {\n    return this._invertedAbsoluteTransform;\n  }\n  /**\n   * Gets the absolute transform matrix (ie base matrix * parent world matrix)\n   * @returns a matrix\n   */\n  getAbsoluteTransform() {\n    return this._absoluteTransform;\n  }\n  /**\n   * Links with the given transform node.\n   * The local matrix of this bone is copied from the transform node every frame.\n   * @param transformNode defines the transform node to link to\n   */\n  linkTransformNode(transformNode) {\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode--;\n    }\n    this._linkedTransformNode = transformNode;\n    if (this._linkedTransformNode) {\n      this._skeleton._numBonesWithLinkedTransformNode++;\n    }\n  }\n  // Properties (matches TransformNode properties)\n  /**\n   * Gets the node used to drive the bone's transformation\n   * @returns a transform node or null\n   */\n  getTransformNode() {\n    return this._linkedTransformNode;\n  }\n  /** Gets or sets current position (in local space) */\n  get position() {\n    this._decompose();\n    return this._localPosition;\n  }\n  set position(newPosition) {\n    this._decompose();\n    this._localPosition.copyFrom(newPosition);\n    this._markAsDirtyAndCompose();\n  }\n  /** Gets or sets current rotation (in local space) */\n  get rotation() {\n    return this.getRotation();\n  }\n  set rotation(newRotation) {\n    this.setRotation(newRotation);\n  }\n  /** Gets or sets current rotation quaternion (in local space) */\n  get rotationQuaternion() {\n    this._decompose();\n    return this._localRotation;\n  }\n  set rotationQuaternion(newRotation) {\n    this.setRotationQuaternion(newRotation);\n  }\n  /** Gets or sets current scaling (in local space) */\n  get scaling() {\n    return this.getScale();\n  }\n  set scaling(newScaling) {\n    this.setScale(newScaling);\n  }\n  /**\n   * Gets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    return this._skeleton.animationPropertiesOverride;\n  }\n  // Methods\n  _decompose() {\n    if (!this._needToDecompose) {\n      return;\n    }\n    this._needToDecompose = false;\n    if (!this._localScaling) {\n      this._localScaling = Vector3.Zero();\n      this._localRotation = Quaternion.Zero();\n      this._localPosition = Vector3.Zero();\n    }\n    this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\n  }\n  _compose() {\n    if (!this._needToCompose) {\n      return;\n    }\n    if (!this._localScaling) {\n      this._needToCompose = false;\n      return;\n    }\n    this._needToCompose = false;\n    Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\n  }\n  /**\n   * Update the base and local matrices\n   * @param matrix defines the new base or local matrix\n   * @param updateDifferenceMatrix defines if the difference matrix must be updated\n   * @param updateLocalMatrix defines if the local matrix should be updated\n   */\n  updateMatrix(matrix, updateDifferenceMatrix = true, updateLocalMatrix = true) {\n    this._baseMatrix.copyFrom(matrix);\n    if (updateDifferenceMatrix) {\n      this._updateDifferenceMatrix();\n    }\n    if (updateLocalMatrix) {\n      this._matrix = matrix;\n    } else {\n      this.markAsDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  _updateDifferenceMatrix(rootMatrix, updateChildren = true) {\n    if (!rootMatrix) {\n      rootMatrix = this._baseMatrix;\n    }\n    if (this.parent) {\n      rootMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(rootMatrix);\n    }\n    this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\n    if (updateChildren) {\n      for (let index = 0; index < this.children.length; index++) {\n        this.children[index]._updateDifferenceMatrix();\n      }\n    }\n    this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\n  }\n  /**\n   * Flag the bone as dirty (Forcing it to update everything)\n   * @returns this bone\n   */\n  markAsDirty() {\n    this._currentRenderId++;\n    this._childUpdateId++;\n    this._skeleton._markAsDirty();\n    return this;\n  }\n  /** @internal */\n  _markAsDirtyAndCompose() {\n    this.markAsDirty();\n    this._needToCompose = true;\n  }\n  _markAsDirtyAndDecompose() {\n    this.markAsDirty();\n    this._needToDecompose = true;\n  }\n  /**\n   * Translate the bone in local or world space\n   * @param vec The amount to translate the bone\n   * @param space The space that the translation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n  translate(vec, space = Space.LOCAL, tNode) {\n    const lm = this.getLocalMatrix();\n    if (space == Space.LOCAL) {\n      lm.addAtIndex(12, vec.x);\n      lm.addAtIndex(13, vec.y);\n      lm.addAtIndex(14, vec.z);\n    } else {\n      let wm = null;\n      //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n      if (tNode) {\n        wm = tNode.getWorldMatrix();\n      }\n      this._skeleton.computeAbsoluteTransforms();\n      const tmat = Bone._TmpMats[0];\n      const tvec = Bone._TmpVecs[0];\n      if (this.parent) {\n        if (tNode && wm) {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n        }\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n      tmat.setTranslationFromFloats(0, 0, 0);\n      tmat.invert();\n      Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\n      lm.addAtIndex(12, tvec.x);\n      lm.addAtIndex(13, tvec.y);\n      lm.addAtIndex(14, tvec.z);\n    }\n    this._markAsDirtyAndDecompose();\n  }\n  /**\n   * Set the position of the bone in local or world space\n   * @param position The position to set the bone\n   * @param space The space that the position is in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   */\n  setPosition(position, space = Space.LOCAL, tNode) {\n    const lm = this.getLocalMatrix();\n    if (space == Space.LOCAL) {\n      lm.setTranslationFromFloats(position.x, position.y, position.z);\n    } else {\n      let wm = null;\n      //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n      if (tNode) {\n        wm = tNode.getWorldMatrix();\n      }\n      this._skeleton.computeAbsoluteTransforms();\n      const tmat = Bone._TmpMats[0];\n      const vec = Bone._TmpVecs[0];\n      if (this.parent) {\n        if (tNode && wm) {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n          tmat.multiplyToRef(wm, tmat);\n        } else {\n          tmat.copyFrom(this.parent.getAbsoluteTransform());\n        }\n        tmat.invert();\n      } else {\n        Matrix.IdentityToRef(tmat);\n      }\n      Vector3.TransformCoordinatesToRef(position, tmat, vec);\n      lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\n    }\n    this._markAsDirtyAndDecompose();\n  }\n  /**\n   * Set the absolute position of the bone (world space)\n   * @param position The position to set the bone\n   * @param tNode The TransformNode that this bone is attached to\n   */\n  setAbsolutePosition(position, tNode) {\n    this.setPosition(position, Space.WORLD, tNode);\n  }\n  /**\n   * Scale the bone on the x, y and z axes (in local space)\n   * @param x The amount to scale the bone on the x axis\n   * @param y The amount to scale the bone on the y axis\n   * @param z The amount to scale the bone on the z axis\n   * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\n   */\n  scale(x, y, z, scaleChildren = false) {\n    const locMat = this.getLocalMatrix();\n    // Apply new scaling on top of current local matrix\n    const scaleMat = Bone._TmpMats[0];\n    Matrix.ScalingToRef(x, y, z, scaleMat);\n    scaleMat.multiplyToRef(locMat, locMat);\n    // Invert scaling matrix and apply the inverse to all children\n    scaleMat.invert();\n    for (const child of this.children) {\n      const cm = child.getLocalMatrix();\n      cm.multiplyToRef(scaleMat, cm);\n      cm.multiplyAtIndex(12, x);\n      cm.multiplyAtIndex(13, y);\n      cm.multiplyAtIndex(14, z);\n      child._markAsDirtyAndDecompose();\n    }\n    this._markAsDirtyAndDecompose();\n    if (scaleChildren) {\n      for (const child of this.children) {\n        child.scale(x, y, z, scaleChildren);\n      }\n    }\n  }\n  /**\n   * Set the bone scaling in local space\n   * @param scale defines the scaling vector\n   */\n  setScale(scale) {\n    this._decompose();\n    this._localScaling.copyFrom(scale);\n    this._markAsDirtyAndCompose();\n  }\n  /**\n   * Gets the current scaling in local space\n   * @returns the current scaling vector\n   */\n  getScale() {\n    this._decompose();\n    return this._localScaling;\n  }\n  /**\n   * Gets the current scaling in local space and stores it in a target vector\n   * @param result defines the target vector\n   */\n  getScaleToRef(result) {\n    this._decompose();\n    result.copyFrom(this._localScaling);\n  }\n  /**\n   * Set the yaw, pitch, and roll of the bone in local or world space\n   * @param yaw The rotation of the bone on the y axis\n   * @param pitch The rotation of the bone on the x axis\n   * @param roll The rotation of the bone on the z axis\n   * @param space The space that the axes of rotation are in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   */\n  setYawPitchRoll(yaw, pitch, roll, space = Space.LOCAL, tNode) {\n    if (space === Space.LOCAL) {\n      const quat = Bone._TmpQuat;\n      Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\n      this.setRotationQuaternion(quat, space, tNode);\n      return;\n    }\n    const rotMatInv = Bone._TmpMats[0];\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n    const rotMat = Bone._TmpMats[1];\n    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n    this._rotateWithMatrix(rotMat, space, tNode);\n  }\n  /**\n   * Add a rotation to the bone on an axis in local or world space\n   * @param axis The axis to rotate the bone on\n   * @param amount The amount to rotate the bone\n   * @param space The space that the axis is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n  rotate(axis, amount, space = Space.LOCAL, tNode) {\n    const rmat = Bone._TmpMats[0];\n    rmat.setTranslationFromFloats(0, 0, 0);\n    Matrix.RotationAxisToRef(axis, amount, rmat);\n    this._rotateWithMatrix(rmat, space, tNode);\n  }\n  /**\n   * Set the rotation of the bone to a particular axis angle in local or world space\n   * @param axis The axis to rotate the bone on\n   * @param angle The angle that the bone should be rotated to\n   * @param space The space that the axis is in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   */\n  setAxisAngle(axis, angle, space = Space.LOCAL, tNode) {\n    if (space === Space.LOCAL) {\n      const quat = Bone._TmpQuat;\n      Quaternion.RotationAxisToRef(axis, angle, quat);\n      this.setRotationQuaternion(quat, space, tNode);\n      return;\n    }\n    const rotMatInv = Bone._TmpMats[0];\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n    const rotMat = Bone._TmpMats[1];\n    Matrix.RotationAxisToRef(axis, angle, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n    this._rotateWithMatrix(rotMat, space, tNode);\n  }\n  /**\n   * Set the euler rotation of the bone in local or world space\n   * @param rotation The euler rotation that the bone should be set to\n   * @param space The space that the rotation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n  setRotation(rotation, space = Space.LOCAL, tNode) {\n    this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\n  }\n  /**\n   * Set the quaternion rotation of the bone in local or world space\n   * @param quat The quaternion rotation that the bone should be set to\n   * @param space The space that the rotation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n  setRotationQuaternion(quat, space = Space.LOCAL, tNode) {\n    if (space === Space.LOCAL) {\n      this._decompose();\n      this._localRotation.copyFrom(quat);\n      this._markAsDirtyAndCompose();\n      return;\n    }\n    const rotMatInv = Bone._TmpMats[0];\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n    const rotMat = Bone._TmpMats[1];\n    Matrix.FromQuaternionToRef(quat, rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat);\n    this._rotateWithMatrix(rotMat, space, tNode);\n  }\n  /**\n   * Set the rotation matrix of the bone in local or world space\n   * @param rotMat The rotation matrix that the bone should be set to\n   * @param space The space that the rotation is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   */\n  setRotationMatrix(rotMat, space = Space.LOCAL, tNode) {\n    if (space === Space.LOCAL) {\n      const quat = Bone._TmpQuat;\n      Quaternion.FromRotationMatrixToRef(rotMat, quat);\n      this.setRotationQuaternion(quat, space, tNode);\n      return;\n    }\n    const rotMatInv = Bone._TmpMats[0];\n    if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\n      return;\n    }\n    const rotMat2 = Bone._TmpMats[1];\n    rotMat2.copyFrom(rotMat);\n    rotMatInv.multiplyToRef(rotMat, rotMat2);\n    this._rotateWithMatrix(rotMat2, space, tNode);\n  }\n  _rotateWithMatrix(rmat, space = Space.LOCAL, tNode) {\n    const lmat = this.getLocalMatrix();\n    const lx = lmat.m[12];\n    const ly = lmat.m[13];\n    const lz = lmat.m[14];\n    const parent = this.getParent();\n    const parentScale = Bone._TmpMats[3];\n    const parentScaleInv = Bone._TmpMats[4];\n    if (parent && space == Space.WORLD) {\n      if (tNode) {\n        parentScale.copyFrom(tNode.getWorldMatrix());\n        parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\n      } else {\n        parentScale.copyFrom(parent.getAbsoluteTransform());\n      }\n      parentScaleInv.copyFrom(parentScale);\n      parentScaleInv.invert();\n      lmat.multiplyToRef(parentScale, lmat);\n      lmat.multiplyToRef(rmat, lmat);\n      lmat.multiplyToRef(parentScaleInv, lmat);\n    } else {\n      if (space == Space.WORLD && tNode) {\n        parentScale.copyFrom(tNode.getWorldMatrix());\n        parentScaleInv.copyFrom(parentScale);\n        parentScaleInv.invert();\n        lmat.multiplyToRef(parentScale, lmat);\n        lmat.multiplyToRef(rmat, lmat);\n        lmat.multiplyToRef(parentScaleInv, lmat);\n      } else {\n        lmat.multiplyToRef(rmat, lmat);\n      }\n    }\n    lmat.setTranslationFromFloats(lx, ly, lz);\n    this.computeAbsoluteTransforms();\n    this._markAsDirtyAndDecompose();\n  }\n  _getNegativeRotationToRef(rotMatInv, tNode) {\n    const scaleMatrix = Bone._TmpMats[2];\n    rotMatInv.copyFrom(this.getAbsoluteTransform());\n    if (tNode) {\n      rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\n      Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\n    } else {\n      Matrix.IdentityToRef(scaleMatrix);\n    }\n    rotMatInv.invert();\n    if (isNaN(rotMatInv.m[0])) {\n      // Matrix failed to invert.\n      // This can happen if scale is zero for example.\n      return false;\n    }\n    scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\n    rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n    return true;\n  }\n  /**\n   * Get the position of the bone in local or world space\n   * @param space The space that the returned position is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   * @returns The position of the bone\n   */\n  getPosition(space = Space.LOCAL, tNode = null) {\n    const pos = Vector3.Zero();\n    this.getPositionToRef(space, tNode, pos);\n    return pos;\n  }\n  /**\n   * Copy the position of the bone to a vector3 in local or world space\n   * @param space The space that the returned position is in\n   * @param tNode The TransformNode that this bone is attached to. This is only used in world space\n   * @param result The vector3 to copy the position to\n   */\n  getPositionToRef(space = Space.LOCAL, tNode, result) {\n    if (space == Space.LOCAL) {\n      const lm = this.getLocalMatrix();\n      result.x = lm.m[12];\n      result.y = lm.m[13];\n      result.z = lm.m[14];\n    } else {\n      let wm = null;\n      //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n      if (tNode) {\n        wm = tNode.getWorldMatrix();\n      }\n      this._skeleton.computeAbsoluteTransforms();\n      let tmat = Bone._TmpMats[0];\n      if (tNode && wm) {\n        tmat.copyFrom(this.getAbsoluteTransform());\n        tmat.multiplyToRef(wm, tmat);\n      } else {\n        tmat = this.getAbsoluteTransform();\n      }\n      result.x = tmat.m[12];\n      result.y = tmat.m[13];\n      result.z = tmat.m[14];\n    }\n  }\n  /**\n   * Get the absolute position of the bone (world space)\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The absolute position of the bone\n   */\n  getAbsolutePosition(tNode = null) {\n    const pos = Vector3.Zero();\n    this.getPositionToRef(Space.WORLD, tNode, pos);\n    return pos;\n  }\n  /**\n   * Copy the absolute position of the bone (world space) to the result param\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 to copy the absolute position to\n   */\n  getAbsolutePositionToRef(tNode, result) {\n    this.getPositionToRef(Space.WORLD, tNode, result);\n  }\n  /**\n   * Compute the absolute transforms of this bone and its children\n   */\n  computeAbsoluteTransforms() {\n    this._compose();\n    if (this.parent) {\n      this._localMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\n    } else {\n      this._absoluteTransform.copyFrom(this._localMatrix);\n      const poseMatrix = this._skeleton.getPoseMatrix();\n      if (poseMatrix) {\n        this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\n      }\n    }\n    const children = this.children;\n    const len = children.length;\n    for (let i = 0; i < len; i++) {\n      children[i].computeAbsoluteTransforms();\n    }\n  }\n  /**\n   * Get the world direction from an axis that is in the local space of the bone\n   * @param localAxis The local direction that is used to compute the world direction\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The world direction\n   */\n  getDirection(localAxis, tNode = null) {\n    const result = Vector3.Zero();\n    this.getDirectionToRef(localAxis, tNode, result);\n    return result;\n  }\n  /**\n   * Copy the world direction to a vector3 from an axis that is in the local space of the bone\n   * @param localAxis The local direction that is used to compute the world direction\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 that the world direction will be copied to\n   */\n  getDirectionToRef(localAxis, tNode = null, result) {\n    let wm = null;\n    //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n    if (tNode) {\n      wm = tNode.getWorldMatrix();\n    }\n    this._skeleton.computeAbsoluteTransforms();\n    const mat = Bone._TmpMats[0];\n    mat.copyFrom(this.getAbsoluteTransform());\n    if (tNode && wm) {\n      mat.multiplyToRef(wm, mat);\n    }\n    Vector3.TransformNormalToRef(localAxis, mat, result);\n    result.normalize();\n  }\n  /**\n   * Get the euler rotation of the bone in local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @returns The euler rotation\n   */\n  getRotation(space = Space.LOCAL, tNode = null) {\n    const result = Vector3.Zero();\n    this.getRotationToRef(space, tNode, result);\n    return result;\n  }\n  /**\n   * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @param result The vector3 that the rotation should be copied to\n   */\n  getRotationToRef(space = Space.LOCAL, tNode = null, result) {\n    const quat = Bone._TmpQuat;\n    this.getRotationQuaternionToRef(space, tNode, quat);\n    quat.toEulerAnglesToRef(result);\n  }\n  /**\n   * Get the quaternion rotation of the bone in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @returns The quaternion rotation\n   */\n  getRotationQuaternion(space = Space.LOCAL, tNode = null) {\n    const result = Quaternion.Identity();\n    this.getRotationQuaternionToRef(space, tNode, result);\n    return result;\n  }\n  /**\n   * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @param result The quaternion that the rotation should be copied to\n   */\n  getRotationQuaternionToRef(space = Space.LOCAL, tNode = null, result) {\n    if (space == Space.LOCAL) {\n      this._decompose();\n      result.copyFrom(this._localRotation);\n    } else {\n      const mat = Bone._TmpMats[0];\n      const amat = this.getAbsoluteTransform();\n      if (tNode) {\n        amat.multiplyToRef(tNode.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.decompose(undefined, result, undefined);\n    }\n  }\n  /**\n   * Get the rotation matrix of the bone in local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @returns The rotation matrix\n   */\n  getRotationMatrix(space = Space.LOCAL, tNode) {\n    const result = Matrix.Identity();\n    this.getRotationMatrixToRef(space, tNode, result);\n    return result;\n  }\n  /**\n   * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\n   * @param space The space that the rotation should be in\n   * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\n   * @param result The quaternion that the rotation should be copied to\n   */\n  getRotationMatrixToRef(space = Space.LOCAL, tNode, result) {\n    if (space == Space.LOCAL) {\n      this.getLocalMatrix().getRotationMatrixToRef(result);\n    } else {\n      const mat = Bone._TmpMats[0];\n      const amat = this.getAbsoluteTransform();\n      if (tNode) {\n        amat.multiplyToRef(tNode.getWorldMatrix(), mat);\n      } else {\n        mat.copyFrom(amat);\n      }\n      mat.multiplyAtIndex(0, this._scalingDeterminant);\n      mat.multiplyAtIndex(1, this._scalingDeterminant);\n      mat.multiplyAtIndex(2, this._scalingDeterminant);\n      mat.getRotationMatrixToRef(result);\n    }\n  }\n  /**\n   * Get the world position of a point that is in the local space of the bone\n   * @param position The local position\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The world position\n   */\n  getAbsolutePositionFromLocal(position, tNode = null) {\n    const result = Vector3.Zero();\n    this.getAbsolutePositionFromLocalToRef(position, tNode, result);\n    return result;\n  }\n  /**\n   * Get the world position of a point that is in the local space of the bone and copy it to the result param\n   * @param position The local position\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 that the world position should be copied to\n   */\n  getAbsolutePositionFromLocalToRef(position, tNode = null, result) {\n    let wm = null;\n    //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n    if (tNode) {\n      wm = tNode.getWorldMatrix();\n    }\n    this._skeleton.computeAbsoluteTransforms();\n    let tmat = Bone._TmpMats[0];\n    if (tNode && wm) {\n      tmat.copyFrom(this.getAbsoluteTransform());\n      tmat.multiplyToRef(wm, tmat);\n    } else {\n      tmat = this.getAbsoluteTransform();\n    }\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  }\n  /**\n   * Get the local position of a point that is in world space\n   * @param position The world position\n   * @param tNode The TransformNode that this bone is attached to\n   * @returns The local position\n   */\n  getLocalPositionFromAbsolute(position, tNode = null) {\n    const result = Vector3.Zero();\n    this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\n    return result;\n  }\n  /**\n   * Get the local position of a point that is in world space and copy it to the result param\n   * @param position The world position\n   * @param tNode The TransformNode that this bone is attached to\n   * @param result The vector3 that the local position should be copied to\n   */\n  getLocalPositionFromAbsoluteToRef(position, tNode = null, result) {\n    let wm = null;\n    //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n    if (tNode) {\n      wm = tNode.getWorldMatrix();\n    }\n    this._skeleton.computeAbsoluteTransforms();\n    const tmat = Bone._TmpMats[0];\n    tmat.copyFrom(this.getAbsoluteTransform());\n    if (tNode && wm) {\n      tmat.multiplyToRef(wm, tmat);\n    }\n    tmat.invert();\n    Vector3.TransformCoordinatesToRef(position, tmat, result);\n  }\n  /**\n   * Set the current local matrix as the restPose for this bone.\n   */\n  setCurrentPoseAsRest() {\n    this.setRestPose(this.getLocalMatrix());\n  }\n}\nBone._TmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);\nBone._TmpQuat = Quaternion.Identity();\nBone._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","TmpVectors","ArrayTools","Node","Space","Bone","constructor","name","skeleton","parentBone","localMatrix","restPose","baseMatrix","index","getScene","Array","_skeleton","_localMatrix","clone","Identity","_restPose","_baseMatrix","_index","bones","push","setParent","_updateDifferenceMatrix","_matrix","_compose","value","_needToCompose","updateFlag","copyFrom","_markAsDirtyAndDecompose","getClassName","getSkeleton","parent","_parentNode","getParent","getChildren","children","getIndex","indexOf","newParent","updateDifferenceMatrix","splice","markAsDirty","getLocalMatrix","getBaseMatrix","getRestPose","setRestPose","matrix","getBindPose","setBindPose","updateMatrix","getWorldMatrix","_worldTransform","returnToRest","_linkedTransformNode","localScaling","localRotation","localPosition","decompose","position","rotationQuaternion","scaling","getInvertedAbsoluteTransform","_invertedAbsoluteTransform","getAbsoluteTransform","_absoluteTransform","linkTransformNode","transformNode","_numBonesWithLinkedTransformNode","getTransformNode","_decompose","_localPosition","newPosition","_markAsDirtyAndCompose","rotation","getRotation","newRotation","setRotation","_localRotation","setRotationQuaternion","getScale","newScaling","setScale","animationPropertiesOverride","_needToDecompose","_localScaling","Zero","ComposeToRef","updateLocalMatrix","rootMatrix","updateChildren","multiplyToRef","invertToRef","length","_scalingDeterminant","determinant","_currentRenderId","_childUpdateId","_markAsDirty","translate","vec","space","LOCAL","tNode","lm","addAtIndex","x","y","z","wm","computeAbsoluteTransforms","tmat","_TmpMats","tvec","_TmpVecs","IdentityToRef","setTranslationFromFloats","invert","TransformCoordinatesToRef","setPosition","setAbsolutePosition","WORLD","scale","scaleChildren","locMat","scaleMat","ScalingToRef","child","cm","multiplyAtIndex","getScaleToRef","result","setYawPitchRoll","yaw","pitch","roll","quat","_TmpQuat","RotationYawPitchRollToRef","rotMatInv","_getNegativeRotationToRef","rotMat","_rotateWithMatrix","rotate","axis","amount","rmat","RotationAxisToRef","setAxisAngle","angle","FromQuaternionToRef","setRotationMatrix","FromRotationMatrixToRef","rotMat2","lmat","lx","m","ly","lz","parentScale","parentScaleInv","scaleMatrix","isNaN","getPosition","pos","getPositionToRef","getAbsolutePosition","getAbsolutePositionToRef","poseMatrix","getPoseMatrix","len","i","getDirection","localAxis","getDirectionToRef","mat","TransformNormalToRef","normalize","getRotationToRef","getRotationQuaternionToRef","toEulerAnglesToRef","getRotationQuaternion","amat","undefined","getRotationMatrix","getRotationMatrixToRef","getAbsolutePositionFromLocal","getAbsolutePositionFromLocalToRef","getLocalPositionFromAbsolute","getLocalPositionFromAbsoluteToRef","setCurrentPoseAsRest","BuildArray"],"sourceRoot":"","sources":["../../../../lts/core/generated/Bones/bone.ts"],"sourcesContent":["import type { Skeleton } from \"./skeleton\";\r\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Node } from \"../node\";\r\nimport { Space } from \"../Maths/math.axis\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\ndeclare type AnimationPropertiesOverride = import(\"../Animations/animationPropertiesOverride\").AnimationPropertiesOverride;\r\n\r\n/**\r\n * Class used to store bone information\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Bone extends Node {\r\n    private static _TmpVecs: Vector3[] = ArrayTools.BuildArray(2, Vector3.Zero);\r\n    private static _TmpQuat = Quaternion.Identity();\r\n    private static _TmpMats: Matrix[] = ArrayTools.BuildArray(5, Matrix.Identity);\r\n\r\n    /**\r\n     * Gets the list of child bones\r\n     */\r\n    public children = new Array<Bone>();\r\n\r\n    /** Gets the animations associated with this bone */\r\n    public animations = new Array<Animation>();\r\n\r\n    /**\r\n     * Gets or sets bone length\r\n     */\r\n    public length: number;\r\n\r\n    /**\r\n     * @internal Internal only\r\n     * Set this value to map this bone to a different index in the transform matrices\r\n     * Set this value to -1 to exclude the bone from the transform matrices\r\n     */\r\n    public _index: Nullable<number> = null;\r\n\r\n    private _skeleton: Skeleton;\r\n    private _localMatrix: Matrix;\r\n    private _restPose: Matrix;\r\n    private _baseMatrix: Matrix;\r\n    private _absoluteTransform = new Matrix();\r\n    private _invertedAbsoluteTransform = new Matrix();\r\n    private _scalingDeterminant = 1;\r\n    private _worldTransform = new Matrix();\r\n\r\n    private _localScaling: Vector3;\r\n    private _localRotation: Quaternion;\r\n    private _localPosition: Vector3;\r\n    private _needToDecompose = true;\r\n    private _needToCompose = false;\r\n\r\n    /** @internal */\r\n    public _linkedTransformNode: Nullable<TransformNode> = null;\r\n\r\n    /** @internal */\r\n    public _waitingTransformNodeId: Nullable<string> = null;\r\n\r\n    /** @internal */\r\n    get _matrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    set _matrix(value: Matrix) {\r\n        this._needToCompose = false; // in case there was a pending compose\r\n\r\n        // skip if the matrices are the same\r\n        if (value.updateFlag === this._localMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        this._localMatrix.copyFrom(value);\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Create a new bone\r\n     * @param name defines the bone name\r\n     * @param skeleton defines the parent skeleton\r\n     * @param parentBone defines the parent (can be null if the bone is the root)\r\n     * @param localMatrix defines the local matrix\r\n     * @param restPose defines the rest pose matrix\r\n     * @param baseMatrix defines the base matrix\r\n     * @param index defines index of the bone in the hierarchy\r\n     */\r\n    constructor(\r\n        /**\r\n         * defines the bone name\r\n         */\r\n        public name: string,\r\n        skeleton: Skeleton,\r\n        parentBone: Nullable<Bone> = null,\r\n        localMatrix: Nullable<Matrix> = null,\r\n        restPose: Nullable<Matrix> = null,\r\n        baseMatrix: Nullable<Matrix> = null,\r\n        index: Nullable<number> = null\r\n    ) {\r\n        super(name, skeleton.getScene());\r\n        this._skeleton = skeleton;\r\n        this._localMatrix = localMatrix ? localMatrix.clone() : Matrix.Identity();\r\n        this._restPose = restPose ? restPose : this._localMatrix.clone();\r\n        this._baseMatrix = baseMatrix ? baseMatrix : this._localMatrix.clone();\r\n        this._index = index;\r\n\r\n        skeleton.bones.push(this);\r\n\r\n        this.setParent(parentBone, false);\r\n\r\n        if (baseMatrix || localMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Bone\";\r\n    }\r\n\r\n    // Members\r\n\r\n    /**\r\n     * Gets the parent skeleton\r\n     * @returns a skeleton\r\n     */\r\n    public getSkeleton(): Skeleton {\r\n        return this._skeleton;\r\n    }\r\n\r\n    public get parent(): Bone {\r\n        return this._parentNode as Bone;\r\n    }\r\n\r\n    /**\r\n     * Gets parent bone\r\n     * @returns a bone or null if the bone is the root of the bone hierarchy\r\n     */\r\n    public getParent(): Nullable<Bone> {\r\n        return this.parent;\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.children;\r\n    }\r\n\r\n    /**\r\n     * Gets the node index in matrix array generated for rendering\r\n     * @returns the node index\r\n     */\r\n    public getIndex(): number {\r\n        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;\r\n    }\r\n\r\n    public set parent(newParent: Nullable<Bone>) {\r\n        this.setParent(newParent);\r\n    }\r\n\r\n    /**\r\n     * Sets the parent bone\r\n     * @param parent defines the parent (can be null if the bone is the root)\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     */\r\n    public setParent(parent: Nullable<Bone>, updateDifferenceMatrix: boolean = true): void {\r\n        if (this.parent === parent) {\r\n            return;\r\n        }\r\n\r\n        if (this.parent) {\r\n            const index = this.parent.children.indexOf(this);\r\n            if (index !== -1) {\r\n                this.parent.children.splice(index, 1);\r\n            }\r\n        }\r\n\r\n        this._parentNode = parent;\r\n\r\n        if (this.parent) {\r\n            this.parent.children.push(this);\r\n        }\r\n\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the local matrix\r\n     * @returns a matrix\r\n     */\r\n    public getLocalMatrix(): Matrix {\r\n        this._compose();\r\n        return this._localMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the base matrix (initial matrix which remains unchanged)\r\n     * @returns the base matrix (as known as bind pose matrix)\r\n     */\r\n    public getBaseMatrix(): Matrix {\r\n        return this._baseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the rest pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getRestPose(): Matrix {\r\n        return this._restPose;\r\n    }\r\n\r\n    /**\r\n     * Sets the rest pose matrix\r\n     * @param matrix the local-space rest pose to set for this bone\r\n     */\r\n    public setRestPose(matrix: Matrix): void {\r\n        this._restPose.copyFrom(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets the bind pose matrix\r\n     * @returns the bind pose matrix\r\n     * @deprecated Please use getBaseMatrix instead\r\n     */\r\n    public getBindPose(): Matrix {\r\n        return this._baseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the bind pose matrix\r\n     * @param matrix the local-space bind pose to set for this bone\r\n     * @deprecated Please use updateMatrix instead\r\n     */\r\n    public setBindPose(matrix: Matrix): void {\r\n        this.updateMatrix(matrix);\r\n    }\r\n\r\n    /**\r\n     * Gets a matrix used to store world matrix (ie. the matrix sent to shaders)\r\n     */\r\n    public getWorldMatrix(): Matrix {\r\n        return this._worldTransform;\r\n    }\r\n\r\n    /**\r\n     * Sets the local matrix to rest pose matrix\r\n     */\r\n    public returnToRest(): void {\r\n        if (this._linkedTransformNode) {\r\n            const localScaling = TmpVectors.Vector3[0];\r\n            const localRotation = TmpVectors.Quaternion[0];\r\n            const localPosition = TmpVectors.Vector3[1];\r\n\r\n            this.getRestPose().decompose(localScaling, localRotation, localPosition);\r\n\r\n            this._linkedTransformNode.position.copyFrom(localPosition);\r\n            this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();\r\n            this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);\r\n            this._linkedTransformNode.scaling.copyFrom(localScaling);\r\n        } else {\r\n            this._matrix = this._restPose;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the inverse of the absolute transform matrix.\r\n     * This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)\r\n     * @returns a matrix\r\n     */\r\n    public getInvertedAbsoluteTransform(): Matrix {\r\n        return this._invertedAbsoluteTransform;\r\n    }\r\n\r\n    /**\r\n     * Gets the absolute transform matrix (ie base matrix * parent world matrix)\r\n     * @returns a matrix\r\n     */\r\n    public getAbsoluteTransform(): Matrix {\r\n        return this._absoluteTransform;\r\n    }\r\n\r\n    /**\r\n     * Links with the given transform node.\r\n     * The local matrix of this bone is copied from the transform node every frame.\r\n     * @param transformNode defines the transform node to link to\r\n     */\r\n    public linkTransformNode(transformNode: Nullable<TransformNode>): void {\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode--;\r\n        }\r\n\r\n        this._linkedTransformNode = transformNode;\r\n\r\n        if (this._linkedTransformNode) {\r\n            this._skeleton._numBonesWithLinkedTransformNode++;\r\n        }\r\n    }\r\n\r\n    // Properties (matches TransformNode properties)\r\n\r\n    /**\r\n     * Gets the node used to drive the bone's transformation\r\n     * @returns a transform node or null\r\n     */\r\n    public getTransformNode() {\r\n        return this._linkedTransformNode;\r\n    }\r\n\r\n    /** Gets or sets current position (in local space) */\r\n    public get position(): Vector3 {\r\n        this._decompose();\r\n        return this._localPosition;\r\n    }\r\n\r\n    public set position(newPosition: Vector3) {\r\n        this._decompose();\r\n        this._localPosition.copyFrom(newPosition);\r\n\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /** Gets or sets current rotation (in local space) */\r\n    public get rotation(): Vector3 {\r\n        return this.getRotation();\r\n    }\r\n\r\n    public set rotation(newRotation: Vector3) {\r\n        this.setRotation(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current rotation quaternion (in local space) */\r\n    public get rotationQuaternion() {\r\n        this._decompose();\r\n        return this._localRotation;\r\n    }\r\n\r\n    public set rotationQuaternion(newRotation: Quaternion) {\r\n        this.setRotationQuaternion(newRotation);\r\n    }\r\n\r\n    /** Gets or sets current scaling (in local space) */\r\n    public get scaling(): Vector3 {\r\n        return this.getScale();\r\n    }\r\n\r\n    public set scaling(newScaling: Vector3) {\r\n        this.setScale(newScaling);\r\n    }\r\n\r\n    /**\r\n     * Gets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        return this._skeleton.animationPropertiesOverride;\r\n    }\r\n\r\n    // Methods\r\n    private _decompose() {\r\n        if (!this._needToDecompose) {\r\n            return;\r\n        }\r\n\r\n        this._needToDecompose = false;\r\n\r\n        if (!this._localScaling) {\r\n            this._localScaling = Vector3.Zero();\r\n            this._localRotation = Quaternion.Zero();\r\n            this._localPosition = Vector3.Zero();\r\n        }\r\n        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);\r\n    }\r\n\r\n    private _compose() {\r\n        if (!this._needToCompose) {\r\n            return;\r\n        }\r\n\r\n        if (!this._localScaling) {\r\n            this._needToCompose = false;\r\n            return;\r\n        }\r\n\r\n        this._needToCompose = false;\r\n        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);\r\n    }\r\n\r\n    /**\r\n     * Update the base and local matrices\r\n     * @param matrix defines the new base or local matrix\r\n     * @param updateDifferenceMatrix defines if the difference matrix must be updated\r\n     * @param updateLocalMatrix defines if the local matrix should be updated\r\n     */\r\n    public updateMatrix(matrix: Matrix, updateDifferenceMatrix = true, updateLocalMatrix = true): void {\r\n        this._baseMatrix.copyFrom(matrix);\r\n\r\n        if (updateDifferenceMatrix) {\r\n            this._updateDifferenceMatrix();\r\n        }\r\n\r\n        if (updateLocalMatrix) {\r\n            this._matrix = matrix;\r\n        } else {\r\n            this.markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateDifferenceMatrix(rootMatrix?: Matrix, updateChildren = true): void {\r\n        if (!rootMatrix) {\r\n            rootMatrix = this._baseMatrix;\r\n        }\r\n\r\n        if (this.parent) {\r\n            rootMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\r\n        } else {\r\n            this._absoluteTransform.copyFrom(rootMatrix);\r\n        }\r\n\r\n        this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\r\n\r\n        if (updateChildren) {\r\n            for (let index = 0; index < this.children.length; index++) {\r\n                this.children[index]._updateDifferenceMatrix();\r\n            }\r\n        }\r\n\r\n        this._scalingDeterminant = this._absoluteTransform.determinant() < 0 ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     * Flag the bone as dirty (Forcing it to update everything)\r\n     * @returns this bone\r\n     */\r\n    public markAsDirty(): Bone {\r\n        this._currentRenderId++;\r\n        this._childUpdateId++;\r\n        this._skeleton._markAsDirty();\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirtyAndCompose() {\r\n        this.markAsDirty();\r\n        this._needToCompose = true;\r\n    }\r\n\r\n    private _markAsDirtyAndDecompose() {\r\n        this.markAsDirty();\r\n        this._needToDecompose = true;\r\n    }\r\n\r\n    /**\r\n     * Translate the bone in local or world space\r\n     * @param vec The amount to translate the bone\r\n     * @param space The space that the translation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public translate(vec: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            lm.addAtIndex(12, vec.x);\r\n            lm.addAtIndex(13, vec.y);\r\n            lm.addAtIndex(14, vec.z);\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n            const tmat = Bone._TmpMats[0];\r\n            const tvec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                }\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            tmat.setTranslationFromFloats(0, 0, 0);\r\n            tmat.invert();\r\n            Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\r\n\r\n            lm.addAtIndex(12, tvec.x);\r\n            lm.addAtIndex(13, tvec.y);\r\n            lm.addAtIndex(14, tvec.z);\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Set the position of the bone in local or world space\r\n     * @param position The position to set the bone\r\n     * @param space The space that the position is in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setPosition(position: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lm = this.getLocalMatrix();\r\n\r\n        if (space == Space.LOCAL) {\r\n            lm.setTranslationFromFloats(position.x, position.y, position.z);\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n\r\n            const tmat = Bone._TmpMats[0];\r\n            const vec = Bone._TmpVecs[0];\r\n\r\n            if (this.parent) {\r\n                if (tNode && wm) {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                    tmat.multiplyToRef(wm, tmat);\r\n                } else {\r\n                    tmat.copyFrom(this.parent.getAbsoluteTransform());\r\n                }\r\n                tmat.invert();\r\n            } else {\r\n                Matrix.IdentityToRef(tmat);\r\n            }\r\n\r\n            Vector3.TransformCoordinatesToRef(position, tmat, vec);\r\n            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    /**\r\n     * Set the absolute position of the bone (world space)\r\n     * @param position The position to set the bone\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     */\r\n    public setAbsolutePosition(position: Vector3, tNode?: TransformNode) {\r\n        this.setPosition(position, Space.WORLD, tNode);\r\n    }\r\n\r\n    /**\r\n     * Scale the bone on the x, y and z axes (in local space)\r\n     * @param x The amount to scale the bone on the x axis\r\n     * @param y The amount to scale the bone on the y axis\r\n     * @param z The amount to scale the bone on the z axis\r\n     * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)\r\n     */\r\n    public scale(x: number, y: number, z: number, scaleChildren = false): void {\r\n        const locMat = this.getLocalMatrix();\r\n\r\n        // Apply new scaling on top of current local matrix\r\n        const scaleMat = Bone._TmpMats[0];\r\n        Matrix.ScalingToRef(x, y, z, scaleMat);\r\n        scaleMat.multiplyToRef(locMat, locMat);\r\n\r\n        // Invert scaling matrix and apply the inverse to all children\r\n        scaleMat.invert();\r\n\r\n        for (const child of this.children) {\r\n            const cm = child.getLocalMatrix();\r\n            cm.multiplyToRef(scaleMat, cm);\r\n            cm.multiplyAtIndex(12, x);\r\n            cm.multiplyAtIndex(13, y);\r\n            cm.multiplyAtIndex(14, z);\r\n\r\n            child._markAsDirtyAndDecompose();\r\n        }\r\n\r\n        this._markAsDirtyAndDecompose();\r\n\r\n        if (scaleChildren) {\r\n            for (const child of this.children) {\r\n                child.scale(x, y, z, scaleChildren);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the bone scaling in local space\r\n     * @param scale defines the scaling vector\r\n     */\r\n    public setScale(scale: Vector3): void {\r\n        this._decompose();\r\n        this._localScaling.copyFrom(scale);\r\n        this._markAsDirtyAndCompose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space\r\n     * @returns the current scaling vector\r\n     */\r\n    public getScale(): Vector3 {\r\n        this._decompose();\r\n        return this._localScaling;\r\n    }\r\n\r\n    /**\r\n     * Gets the current scaling in local space and stores it in a target vector\r\n     * @param result defines the target vector\r\n     */\r\n    public getScaleToRef(result: Vector3) {\r\n        this._decompose();\r\n        result.copyFrom(this._localScaling);\r\n    }\r\n\r\n    /**\r\n     * Set the yaw, pitch, and roll of the bone in local or world space\r\n     * @param yaw The rotation of the bone on the y axis\r\n     * @param pitch The rotation of the bone on the x axis\r\n     * @param roll The rotation of the bone on the z axis\r\n     * @param space The space that the axes of rotation are in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setYawPitchRoll(yaw: number, pitch: number, roll: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Add a rotation to the bone on an axis in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param amount The amount to rotate the bone\r\n     * @param space The space that the axis is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public rotate(axis: Vector3, amount: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const rmat = Bone._TmpMats[0];\r\n        rmat.setTranslationFromFloats(0, 0, 0);\r\n        Matrix.RotationAxisToRef(axis, amount, rmat);\r\n        this._rotateWithMatrix(rmat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation of the bone to a particular axis angle in local or world space\r\n     * @param axis The axis to rotate the bone on\r\n     * @param angle The angle that the bone should be rotated to\r\n     * @param space The space that the axis is in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     */\r\n    public setAxisAngle(axis: Vector3, angle: number, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.RotationAxisToRef(axis, angle, quat);\r\n\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.RotationAxisToRef(axis, angle, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the euler rotation of the bone in local or world space\r\n     * @param rotation The euler rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotation(rotation: Vector3, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the quaternion rotation of the bone in local or world space\r\n     * @param quat The quaternion rotation that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotationQuaternion(quat: Quaternion, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            this._decompose();\r\n            this._localRotation.copyFrom(quat);\r\n\r\n            this._markAsDirtyAndCompose();\r\n\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat = Bone._TmpMats[1];\r\n        Matrix.FromQuaternionToRef(quat, rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat);\r\n\r\n        this._rotateWithMatrix(rotMat, space, tNode);\r\n    }\r\n\r\n    /**\r\n     * Set the rotation matrix of the bone in local or world space\r\n     * @param rotMat The rotation matrix that the bone should be set to\r\n     * @param space The space that the rotation is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     */\r\n    public setRotationMatrix(rotMat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        if (space === Space.LOCAL) {\r\n            const quat = Bone._TmpQuat;\r\n            Quaternion.FromRotationMatrixToRef(rotMat, quat);\r\n            this.setRotationQuaternion(quat, space, tNode);\r\n            return;\r\n        }\r\n\r\n        const rotMatInv = Bone._TmpMats[0];\r\n        if (!this._getNegativeRotationToRef(rotMatInv, tNode)) {\r\n            return;\r\n        }\r\n\r\n        const rotMat2 = Bone._TmpMats[1];\r\n        rotMat2.copyFrom(rotMat);\r\n\r\n        rotMatInv.multiplyToRef(rotMat, rotMat2);\r\n\r\n        this._rotateWithMatrix(rotMat2, space, tNode);\r\n    }\r\n\r\n    private _rotateWithMatrix(rmat: Matrix, space = Space.LOCAL, tNode?: TransformNode): void {\r\n        const lmat = this.getLocalMatrix();\r\n        const lx = lmat.m[12];\r\n        const ly = lmat.m[13];\r\n        const lz = lmat.m[14];\r\n        const parent = this.getParent();\r\n        const parentScale = Bone._TmpMats[3];\r\n        const parentScaleInv = Bone._TmpMats[4];\r\n\r\n        if (parent && space == Space.WORLD) {\r\n            if (tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\r\n            } else {\r\n                parentScale.copyFrom(parent.getAbsoluteTransform());\r\n            }\r\n            parentScaleInv.copyFrom(parentScale);\r\n            parentScaleInv.invert();\r\n            lmat.multiplyToRef(parentScale, lmat);\r\n            lmat.multiplyToRef(rmat, lmat);\r\n            lmat.multiplyToRef(parentScaleInv, lmat);\r\n        } else {\r\n            if (space == Space.WORLD && tNode) {\r\n                parentScale.copyFrom(tNode.getWorldMatrix());\r\n                parentScaleInv.copyFrom(parentScale);\r\n                parentScaleInv.invert();\r\n                lmat.multiplyToRef(parentScale, lmat);\r\n                lmat.multiplyToRef(rmat, lmat);\r\n                lmat.multiplyToRef(parentScaleInv, lmat);\r\n            } else {\r\n                lmat.multiplyToRef(rmat, lmat);\r\n            }\r\n        }\r\n\r\n        lmat.setTranslationFromFloats(lx, ly, lz);\r\n\r\n        this.computeAbsoluteTransforms();\r\n        this._markAsDirtyAndDecompose();\r\n    }\r\n\r\n    private _getNegativeRotationToRef(rotMatInv: Matrix, tNode?: TransformNode): boolean {\r\n        const scaleMatrix = Bone._TmpMats[2];\r\n        rotMatInv.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (tNode) {\r\n            rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);\r\n            Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);\r\n        } else {\r\n            Matrix.IdentityToRef(scaleMatrix);\r\n        }\r\n\r\n        rotMatInv.invert();\r\n        if (isNaN(rotMatInv.m[0])) {\r\n            // Matrix failed to invert.\r\n            // This can happen if scale is zero for example.\r\n            return false;\r\n        }\r\n\r\n        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);\r\n        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the position of the bone in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     * @returns The position of the bone\r\n     */\r\n    public getPosition(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(space, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the position of the bone to a vector3 in local or world space\r\n     * @param space The space that the returned position is in\r\n     * @param tNode The TransformNode that this bone is attached to. This is only used in world space\r\n     * @param result The vector3 to copy the position to\r\n     */\r\n    public getPositionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode>, result: Vector3): void {\r\n        if (space == Space.LOCAL) {\r\n            const lm = this.getLocalMatrix();\r\n\r\n            result.x = lm.m[12];\r\n            result.y = lm.m[13];\r\n            result.z = lm.m[14];\r\n        } else {\r\n            let wm: Nullable<Matrix> = null;\r\n\r\n            //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n            if (tNode) {\r\n                wm = tNode.getWorldMatrix();\r\n            }\r\n\r\n            this._skeleton.computeAbsoluteTransforms();\r\n\r\n            let tmat = Bone._TmpMats[0];\r\n\r\n            if (tNode && wm) {\r\n                tmat.copyFrom(this.getAbsoluteTransform());\r\n                tmat.multiplyToRef(wm, tmat);\r\n            } else {\r\n                tmat = this.getAbsoluteTransform();\r\n            }\r\n\r\n            result.x = tmat.m[12];\r\n            result.y = tmat.m[13];\r\n            result.z = tmat.m[14];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the absolute position of the bone (world space)\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The absolute position of the bone\r\n     */\r\n    public getAbsolutePosition(tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const pos = Vector3.Zero();\r\n\r\n        this.getPositionToRef(Space.WORLD, tNode, pos);\r\n\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * Copy the absolute position of the bone (world space) to the result param\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 to copy the absolute position to\r\n     */\r\n    public getAbsolutePositionToRef(tNode: TransformNode, result: Vector3) {\r\n        this.getPositionToRef(Space.WORLD, tNode, result);\r\n    }\r\n\r\n    /**\r\n     * Compute the absolute transforms of this bone and its children\r\n     */\r\n    public computeAbsoluteTransforms(): void {\r\n        this._compose();\r\n\r\n        if (this.parent) {\r\n            this._localMatrix.multiplyToRef(this.parent._absoluteTransform, this._absoluteTransform);\r\n        } else {\r\n            this._absoluteTransform.copyFrom(this._localMatrix);\r\n\r\n            const poseMatrix = this._skeleton.getPoseMatrix();\r\n\r\n            if (poseMatrix) {\r\n                this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\r\n            }\r\n        }\r\n\r\n        const children = this.children;\r\n        const len = children.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            children[i].computeAbsoluteTransforms();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world direction from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The world direction\r\n     */\r\n    public getDirection(localAxis: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getDirectionToRef(localAxis, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the world direction to a vector3 from an axis that is in the local space of the bone\r\n     * @param localAxis The local direction that is used to compute the world direction\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 that the world direction will be copied to\r\n     */\r\n    public getDirectionToRef(localAxis: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        const mat = Bone._TmpMats[0];\r\n\r\n        mat.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (tNode && wm) {\r\n            mat.multiplyToRef(wm, mat);\r\n        }\r\n\r\n        Vector3.TransformNormalToRef(localAxis, mat, result);\r\n\r\n        result.normalize();\r\n    }\r\n\r\n    /**\r\n     * Get the euler rotation of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @returns The euler rotation\r\n     */\r\n    public getRotation(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getRotationToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @param result The vector3 that the rotation should be copied to\r\n     */\r\n    public getRotationToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        const quat = Bone._TmpQuat;\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, quat);\r\n\r\n        quat.toEulerAnglesToRef(result);\r\n    }\r\n\r\n    /**\r\n     * Get the quaternion rotation of the bone in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @returns The quaternion rotation\r\n     */\r\n    public getRotationQuaternion(space = Space.LOCAL, tNode: Nullable<TransformNode> = null): Quaternion {\r\n        const result = Quaternion.Identity();\r\n\r\n        this.getRotationQuaternionToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationQuaternionToRef(space = Space.LOCAL, tNode: Nullable<TransformNode> = null, result: Quaternion): void {\r\n        if (space == Space.LOCAL) {\r\n            this._decompose();\r\n            result.copyFrom(this._localRotation);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteTransform();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.decompose(undefined, result, undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the rotation matrix of the bone in local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @returns The rotation matrix\r\n     */\r\n    public getRotationMatrix(space = Space.LOCAL, tNode: TransformNode): Matrix {\r\n        const result = Matrix.Identity();\r\n\r\n        this.getRotationMatrixToRef(space, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space\r\n     * @param space The space that the rotation should be in\r\n     * @param tNode The TransformNode that this bone is attached to.  This is only used in world space\r\n     * @param result The quaternion that the rotation should be copied to\r\n     */\r\n    public getRotationMatrixToRef(space = Space.LOCAL, tNode: TransformNode, result: Matrix): void {\r\n        if (space == Space.LOCAL) {\r\n            this.getLocalMatrix().getRotationMatrixToRef(result);\r\n        } else {\r\n            const mat = Bone._TmpMats[0];\r\n            const amat = this.getAbsoluteTransform();\r\n\r\n            if (tNode) {\r\n                amat.multiplyToRef(tNode.getWorldMatrix(), mat);\r\n            } else {\r\n                mat.copyFrom(amat);\r\n            }\r\n\r\n            mat.multiplyAtIndex(0, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(1, this._scalingDeterminant);\r\n            mat.multiplyAtIndex(2, this._scalingDeterminant);\r\n\r\n            mat.getRotationMatrixToRef(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone\r\n     * @param position The local position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The world position\r\n     */\r\n    public getAbsolutePositionFromLocal(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getAbsolutePositionFromLocalToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the world position of a point that is in the local space of the bone and copy it to the result param\r\n     * @param position The local position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 that the world position should be copied to\r\n     */\r\n    public getAbsolutePositionFromLocalToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        let tmat = Bone._TmpMats[0];\r\n\r\n        if (tNode && wm) {\r\n            tmat.copyFrom(this.getAbsoluteTransform());\r\n            tmat.multiplyToRef(wm, tmat);\r\n        } else {\r\n            tmat = this.getAbsoluteTransform();\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space\r\n     * @param position The world position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @returns The local position\r\n     */\r\n    public getLocalPositionFromAbsolute(position: Vector3, tNode: Nullable<TransformNode> = null): Vector3 {\r\n        const result = Vector3.Zero();\r\n\r\n        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the local position of a point that is in world space and copy it to the result param\r\n     * @param position The world position\r\n     * @param tNode The TransformNode that this bone is attached to\r\n     * @param result The vector3 that the local position should be copied to\r\n     */\r\n    public getLocalPositionFromAbsoluteToRef(position: Vector3, tNode: Nullable<TransformNode> = null, result: Vector3): void {\r\n        let wm: Nullable<Matrix> = null;\r\n\r\n        //tNode.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\r\n        if (tNode) {\r\n            wm = tNode.getWorldMatrix();\r\n        }\r\n\r\n        this._skeleton.computeAbsoluteTransforms();\r\n\r\n        const tmat = Bone._TmpMats[0];\r\n\r\n        tmat.copyFrom(this.getAbsoluteTransform());\r\n\r\n        if (tNode && wm) {\r\n            tmat.multiplyToRef(wm, tmat);\r\n        }\r\n\r\n        tmat.invert();\r\n\r\n        Vector3.TransformCoordinatesToRef(position, tmat, result);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for this bone.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.setRestPose(this.getLocalMatrix());\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}