{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * The currently-working hit-test module.\n * Hit test (or Ray-casting) is used to interact with the real world.\n * For further information read here - https://github.com/immersive-web/hit-test\n *\n * Tested on chrome (mobile) 80.\n */\nexport class WebXRHitTest extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the hit test feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n  constructor(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options = {}) {\n    super(_xrSessionManager);\n    this.options = options;\n    this._tmpMat = new Matrix();\n    this._tmpPos = new Vector3();\n    this._tmpQuat = new Quaternion();\n    this._initHitTestSource = referenceSpace => {\n      if (!referenceSpace) {\n        return;\n      }\n      const offsetRay = new XRRay(this.options.offsetRay || {});\n      const hitTestOptions = {\n        space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\n        offsetRay: offsetRay\n      };\n      if (this.options.entityTypes) {\n        hitTestOptions.entityTypes = this.options.entityTypes;\n      }\n      if (!hitTestOptions.space) {\n        Tools.Warn(\"waiting for viewer reference space to initialize\");\n        return;\n      }\n      this._xrSessionManager.session.requestHitTestSource(hitTestOptions).then(hitTestSource => {\n        if (this._xrHitTestSource) {\n          this._xrHitTestSource.cancel();\n        }\n        this._xrHitTestSource = hitTestSource;\n      });\n    };\n    /**\n     * When set to true, each hit test will have its own position/rotation objects\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\n     * the developers will clone them or copy them as they see fit.\n     */\n    this.autoCloneTransformation = false;\n    /**\n     * Triggered when new babylon (transformed) hit test results are available\n     * Note - this will be called when results come back from the device. It can be an empty array!!\n     */\n    this.onHitTestResultObservable = new Observable();\n    /**\n     * Use this to temporarily pause hit test checks.\n     */\n    this.paused = false;\n    this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"Hit test is an experimental and unstable feature.\");\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    // Feature enabled, but not available\n    if (!this._xrSessionManager.session.requestHitTestSource) {\n      return false;\n    }\n    if (!this.options.disablePermanentHitTest) {\n      if (this._xrSessionManager.referenceSpace) {\n        this._initHitTestSource(this._xrSessionManager.referenceSpace);\n      }\n      this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\n    }\n    if (this.options.enableTransientHitTest) {\n      const offsetRay = new XRRay(this.options.transientOffsetRay || {});\n      this._xrSessionManager.session.requestHitTestSourceForTransientInput({\n        profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\n        offsetRay,\n        entityTypes: this.options.entityTypes\n      }).then(hitSource => {\n        this._transientXrHitTestSource = hitSource;\n      });\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    if (this._xrHitTestSource) {\n      this._xrHitTestSource.cancel();\n      this._xrHitTestSource = null;\n    }\n    this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\n    if (this._transientXrHitTestSource) {\n      this._transientXrHitTestSource.cancel();\n      this._transientXrHitTestSource = null;\n    }\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onHitTestResultObservable.clear();\n  }\n  _onXRFrame(frame) {\n    // make sure we do nothing if (async) not attached\n    if (!this.attached || this.paused) {\n      return;\n    }\n    if (this._xrHitTestSource) {\n      const results = frame.getHitTestResults(this._xrHitTestSource);\n      this._processWebXRHitTestResult(results);\n    }\n    if (this._transientXrHitTestSource) {\n      const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\n      hitTestResultsPerInputSource.forEach(resultsPerInputSource => {\n        this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\n      });\n    }\n  }\n  _processWebXRHitTestResult(hitTestResults, inputSource) {\n    const results = [];\n    hitTestResults.forEach(hitTestResult => {\n      const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\n      if (!pose) {\n        return;\n      }\n      const pos = pose.transform.position;\n      const quat = pose.transform.orientation;\n      this._tmpPos.set(pos.x, pos.y, pos.z);\n      this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\n      Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\n      if (!this._xrSessionManager.scene.useRightHandedSystem) {\n        this._tmpPos.z *= -1;\n        this._tmpQuat.z *= -1;\n        this._tmpQuat.w *= -1;\n        this._tmpMat.toggleModelMatrixHandInPlace();\n      }\n      const result = {\n        position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\n        rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\n        transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\n        inputSource: inputSource,\n        isTransient: !!inputSource,\n        xrHitResult: hitTestResult\n      };\n      results.push(result);\n    });\n    this.onHitTestResultObservable.notifyObservers(results);\n  }\n}\n/**\n * The module's name\n */\nWebXRHitTest.Name = WebXRFeatureName.HIT_TEST;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHitTest.Version = 2;\n//register the plugin versions\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTest.Name, (xrSessionManager, options) => {\n  return () => new WebXRHitTest(xrSessionManager, options);\n}, WebXRHitTest.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","Vector3","Matrix","Quaternion","WebXRAbstractFeature","Tools","WebXRHitTest","constructor","_xrSessionManager","options","referenceSpace","offsetRay","XRRay","hitTestOptions","space","useReferenceSpace","viewerReferenceSpace","entityTypes","Warn","session","requestHitTestSource","then","hitTestSource","_xrHitTestSource","cancel","xrNativeFeatureName","attach","disablePermanentHitTest","_initHitTestSource","onXRReferenceSpaceChanged","add","enableTransientHitTest","transientOffsetRay","requestHitTestSourceForTransientInput","profile","transientHitTestProfile","hitSource","_transientXrHitTestSource","detach","removeCallback","dispose","onHitTestResultObservable","clear","_onXRFrame","frame","attached","paused","results","getHitTestResults","_processWebXRHitTestResult","hitTestResultsPerInputSource","getHitTestResultsForTransientInput","forEach","resultsPerInputSource","inputSource","hitTestResults","hitTestResult","pose","getPose","pos","transform","position","quat","orientation","_tmpPos","set","x","y","z","_tmpQuat","w","FromFloat32ArrayToRefScaled","matrix","_tmpMat","scene","useRightHandedSystem","toggleModelMatrixHandInPlace","result","autoCloneTransformation","clone","rotationQuaternion","transformationMatrix","isTransient","xrHitResult","push","notifyObservers","HIT_TEST","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRHitTest.ts"],"sourcesContent":["import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport type { IWebXRLegacyHitTestOptions, IWebXRLegacyHitResult, IWebXRHitTestFeature } from \"./WebXRHitTestLegacy\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options used for hit testing (version 2)\r\n */\r\nexport interface IWebXRHitTestOptions extends IWebXRLegacyHitTestOptions {\r\n    /**\r\n     * Do not create a permanent hit test. Will usually be used when only\r\n     * transient inputs are needed.\r\n     */\r\n    disablePermanentHitTest?: boolean;\r\n    /**\r\n     * Enable transient (for example touch-based) hit test inspections\r\n     */\r\n    enableTransientHitTest?: boolean;\r\n    /**\r\n     * Override the default transient hit test profile (generic-touchscreen).\r\n     */\r\n    transientHitTestProfile?: string;\r\n    /**\r\n     * Offset ray for the permanent hit test\r\n     */\r\n    offsetRay?: Vector3;\r\n    /**\r\n     * Offset ray for the transient hit test\r\n     */\r\n    transientOffsetRay?: Vector3;\r\n    /**\r\n     * Instead of using viewer space for hit tests, use the reference space defined in the session manager\r\n     */\r\n    useReferenceSpace?: boolean;\r\n\r\n    /**\r\n     * Override the default entity type(s) of the hit-test result\r\n     */\r\n    entityTypes?: XRHitTestTrackableType[];\r\n}\r\n\r\n/**\r\n * Interface defining the babylon result of hit-test\r\n */\r\nexport interface IWebXRHitResult extends IWebXRLegacyHitResult {\r\n    /**\r\n     * The input source that generated this hit test (if transient)\r\n     */\r\n    inputSource?: XRInputSource;\r\n    /**\r\n     * Is this a transient hit test\r\n     */\r\n    isTransient?: boolean;\r\n    /**\r\n     * Position of the hit test result\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * Rotation of the hit test result\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * The native hit test result\r\n     */\r\n    xrHitResult: XRHitTestResult;\r\n}\r\n\r\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n *\r\n * Tested on chrome (mobile) 80.\r\n */\r\nexport class WebXRHitTest extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRHitResult> {\r\n    private _tmpMat: Matrix = new Matrix();\r\n    private _tmpPos: Vector3 = new Vector3();\r\n    private _tmpQuat: Quaternion = new Quaternion();\r\n    private _transientXrHitTestSource: Nullable<XRTransientInputHitTestSource>;\r\n    // in XR space z-forward is negative\r\n    private _xrHitTestSource: Nullable<XRHitTestSource>;\r\n    private _initHitTestSource = (referenceSpace: XRReferenceSpace) => {\r\n        if (!referenceSpace) {\r\n            return;\r\n        }\r\n        const offsetRay = new XRRay(this.options.offsetRay || {});\r\n        const hitTestOptions: XRHitTestOptionsInit = {\r\n            space: this.options.useReferenceSpace ? referenceSpace : this._xrSessionManager.viewerReferenceSpace,\r\n            offsetRay: offsetRay,\r\n        };\r\n        if (this.options.entityTypes) {\r\n            hitTestOptions.entityTypes = this.options.entityTypes;\r\n        }\r\n        if (!hitTestOptions.space) {\r\n            Tools.Warn(\"waiting for viewer reference space to initialize\");\r\n            return;\r\n        }\r\n        this._xrSessionManager.session.requestHitTestSource!(hitTestOptions).then((hitTestSource) => {\r\n            if (this._xrHitTestSource) {\r\n                this._xrHitTestSource.cancel();\r\n            }\r\n            this._xrHitTestSource = hitTestSource;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HIT_TEST;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 2;\r\n\r\n    /**\r\n     * When set to true, each hit test will have its own position/rotation objects\r\n     * When set to false, position and rotation objects will be reused for each hit test. It is expected that\r\n     * the developers will clone them or copy them as they see fit.\r\n     */\r\n    public autoCloneTransformation: boolean = false;\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     * Note - this will be called when results come back from the device. It can be an empty array!!\r\n     */\r\n    public onHitTestResultObservable: Observable<IWebXRHitResult[]> = new Observable();\r\n    /**\r\n     * Use this to temporarily pause hit test checks.\r\n     */\r\n    public paused: boolean = false;\r\n\r\n    /**\r\n     * Creates a new instance of the hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRHitTestOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hit-test\";\r\n        Tools.Warn(\"Hit test is an experimental and unstable feature.\");\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        // Feature enabled, but not available\r\n        if (!this._xrSessionManager.session.requestHitTestSource) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.options.disablePermanentHitTest) {\r\n            if (this._xrSessionManager.referenceSpace) {\r\n                this._initHitTestSource(this._xrSessionManager.referenceSpace);\r\n            }\r\n            this._xrSessionManager.onXRReferenceSpaceChanged.add(this._initHitTestSource);\r\n        }\r\n        if (this.options.enableTransientHitTest) {\r\n            const offsetRay = new XRRay(this.options.transientOffsetRay || {});\r\n            this._xrSessionManager.session.requestHitTestSourceForTransientInput!({\r\n                profile: this.options.transientHitTestProfile || \"generic-touchscreen\",\r\n                offsetRay,\r\n                entityTypes: this.options.entityTypes,\r\n            }).then((hitSource) => {\r\n                this._transientXrHitTestSource = hitSource;\r\n            });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        if (this._xrHitTestSource) {\r\n            this._xrHitTestSource.cancel();\r\n            this._xrHitTestSource = null;\r\n        }\r\n        this._xrSessionManager.onXRReferenceSpaceChanged.removeCallback(this._initHitTestSource);\r\n        if (this._transientXrHitTestSource) {\r\n            this._transientXrHitTestSource.cancel();\r\n            this._transientXrHitTestSource = null;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHitTestResultObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // make sure we do nothing if (async) not attached\r\n        if (!this.attached || this.paused) {\r\n            return;\r\n        }\r\n\r\n        if (this._xrHitTestSource) {\r\n            const results = frame.getHitTestResults(this._xrHitTestSource);\r\n            this._processWebXRHitTestResult(results);\r\n        }\r\n        if (this._transientXrHitTestSource) {\r\n            const hitTestResultsPerInputSource = frame.getHitTestResultsForTransientInput(this._transientXrHitTestSource);\r\n\r\n            hitTestResultsPerInputSource.forEach((resultsPerInputSource) => {\r\n                this._processWebXRHitTestResult(resultsPerInputSource.results, resultsPerInputSource.inputSource);\r\n            });\r\n        }\r\n    }\r\n\r\n    private _processWebXRHitTestResult(hitTestResults: readonly XRHitTestResult[], inputSource?: XRInputSource) {\r\n        const results: IWebXRHitResult[] = [];\r\n        hitTestResults.forEach((hitTestResult) => {\r\n            const pose = hitTestResult.getPose(this._xrSessionManager.referenceSpace);\r\n            if (!pose) {\r\n                return;\r\n            }\r\n            const pos = pose.transform.position;\r\n            const quat = pose.transform.orientation;\r\n            this._tmpPos.set(pos.x, pos.y, pos.z);\r\n            this._tmpQuat.set(quat.x, quat.y, quat.z, quat.w);\r\n            Matrix.FromFloat32ArrayToRefScaled(pose.transform.matrix, 0, 1, this._tmpMat);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                this._tmpPos.z *= -1;\r\n                this._tmpQuat.z *= -1;\r\n                this._tmpQuat.w *= -1;\r\n                this._tmpMat.toggleModelMatrixHandInPlace();\r\n            }\r\n\r\n            const result: IWebXRHitResult = {\r\n                position: this.autoCloneTransformation ? this._tmpPos.clone() : this._tmpPos,\r\n                rotationQuaternion: this.autoCloneTransformation ? this._tmpQuat.clone() : this._tmpQuat,\r\n                transformationMatrix: this.autoCloneTransformation ? this._tmpMat.clone() : this._tmpMat,\r\n                inputSource: inputSource,\r\n                isTransient: !!inputSource,\r\n                xrHitResult: hitTestResult,\r\n            };\r\n            results.push(result);\r\n        });\r\n\r\n        this.onHitTestResultObservable.notifyObservers(results);\r\n    }\r\n}\r\n\r\n//register the plugin versions\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHitTest.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHitTest(xrSessionManager, options);\r\n    },\r\n    WebXRHitTest.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}