{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"harmonicsFunctions\";\nconst shader = `#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {\nreturn vSphericalL00\n+ vSphericalL1_1*(normal.y)\n+ vSphericalL10*(normal.z)\n+ vSphericalL11*(normal.x)\n+ vSphericalL2_2*(normal.y*normal.x)\n+ vSphericalL2_1*(normal.y*normal.z)\n+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\n+ vSphericalL21*(normal.z*normal.x)\n+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));\n}\n#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {\nfloat Nx=normal.x;\nfloat Ny=normal.y;\nfloat Nz=normal.z;\nvec3 C1=vSphericalZZ.rgb;\nvec3 Cx=vSphericalX.rgb;\nvec3 Cy=vSphericalY.rgb;\nvec3 Cz=vSphericalZ.rgb;\nvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\nvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\nvec3 Cxy=vSphericalXY.rgb;\nvec3 Cyz=vSphericalYZ.rgb;\nvec3 Czx=vSphericalZX.rgb;\nvec3 a1=Cyy_zz*Ny+Cy;\nvec3 a2=Cyz*Nz+a1;\nvec3 b1=Czx*Nz+Cx;\nvec3 b2=Cxy*Ny+b1;\nvec3 b3=Cxx_zz*Nx+b2;\nvec3 t1=Cz *Nz+C1;\nvec3 t2=a2 *Ny+t1;\nvec3 t3=b3 *Nx+t2;\nreturn t3;\n}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const harmonicsFunctions = {\n  name,\n  shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,8BAA4B;AAExD,MAAMC,IAAI,GAAG,oBAAoB;AACjC,MAAMC,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAuCd;AACD;AACAF,WAAW,CAACG,oBAAoB,CAACF,IAAI,CAAC,GAAGC,MAAM;AAC/C;AACA,OAAO,MAAME,kBAAkB,GAAG;EAAEH,IAAI;EAAEC;AAAM,CAAE","names":["ShaderStore","name","shader","IncludesShadersStore","harmonicsFunctions"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Shaders/ShadersInclude/harmonicsFunctions.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"harmonicsFunctions\";\nconst shader = `#ifdef USESPHERICALFROMREFLECTIONMAP\n#ifdef SPHERICAL_HARMONICS\nvec3 computeEnvironmentIrradiance(vec3 normal) {\rreturn vSphericalL00\r+ vSphericalL1_1*(normal.y)\r+ vSphericalL10*(normal.z)\r+ vSphericalL11*(normal.x)\r+ vSphericalL2_2*(normal.y*normal.x)\r+ vSphericalL2_1*(normal.y*normal.z)\r+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)\r+ vSphericalL21*(normal.z*normal.x)\r+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));\r}\r#else\nvec3 computeEnvironmentIrradiance(vec3 normal) {\rfloat Nx=normal.x;\rfloat Ny=normal.y;\rfloat Nz=normal.z;\rvec3 C1=vSphericalZZ.rgb;\rvec3 Cx=vSphericalX.rgb;\rvec3 Cy=vSphericalY.rgb;\rvec3 Cz=vSphericalZ.rgb;\rvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\rvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\rvec3 Cxy=vSphericalXY.rgb;\rvec3 Cyz=vSphericalYZ.rgb;\rvec3 Czx=vSphericalZX.rgb;\rvec3 a1=Cyy_zz*Ny+Cy;\rvec3 a2=Cyz*Nz+a1;\rvec3 b1=Czx*Nz+Cx;\rvec3 b2=Cxy*Ny+b1;\rvec3 b3=Cxx_zz*Nx+b2;\rvec3 t1=Cz *Nz+C1;\rvec3 t2=a2 *Ny+t1;\rvec3 t3=b3 *Nx+t2;\rreturn t3;\r}\r#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const harmonicsFunctions = { name, shader };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}