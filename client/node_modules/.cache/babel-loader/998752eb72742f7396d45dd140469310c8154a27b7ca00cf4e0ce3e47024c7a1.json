{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { ThinSprite } from \"./thinSprite.js\";\n/**\n * Class used to represent a sprite\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\n */\nexport class Sprite extends ThinSprite {\n  /**\n   * Creates a new Sprite\n   * @param name defines the name\n   * @param manager defines the manager\n   */\n  constructor( /** defines the name */\n  name, manager) {\n    super();\n    this.name = name;\n    /** Gets the list of attached animations */\n    this.animations = new Array();\n    /** Gets or sets a boolean indicating if the sprite can be picked */\n    this.isPickable = false;\n    /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\n    this.useAlphaForPicking = false;\n    /**\n     * An event triggered when the control has been disposed\n     */\n    this.onDisposeObservable = new Observable();\n    this._onAnimationEnd = null;\n    this._endAnimation = () => {\n      if (this._onAnimationEnd) {\n        this._onAnimationEnd();\n      }\n      if (this.disposeWhenFinishedAnimating) {\n        this.dispose();\n      }\n    };\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.position = Vector3.Zero();\n    this._manager = manager;\n    this._manager.sprites.push(this);\n    this.uniqueId = this._manager.scene.getUniqueId();\n  }\n  /**\n   * Gets or sets the sprite size\n   */\n  get size() {\n    return this.width;\n  }\n  set size(value) {\n    this.width = value;\n    this.height = value;\n  }\n  /**\n   * Gets the manager of this sprite\n   */\n  get manager() {\n    return this._manager;\n  }\n  /**\n   * Returns the string \"Sprite\"\n   * @returns \"Sprite\"\n   */\n  getClassName() {\n    return \"Sprite\";\n  }\n  /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\n  get fromIndex() {\n    return this._fromIndex;\n  }\n  set fromIndex(value) {\n    this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\n  }\n  /** Gets or sets the end key for the animation (setting it will restart the animation)  */\n  get toIndex() {\n    return this._toIndex;\n  }\n  set toIndex(value) {\n    this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\n  }\n  /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\n  get loopAnimation() {\n    return this._loopAnimation;\n  }\n  set loopAnimation(value) {\n    this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\n  }\n  /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\n  get delay() {\n    return Math.max(this._delay, 1);\n  }\n  set delay(value) {\n    this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\n  }\n  /**\n   * Starts an animation\n   * @param from defines the initial key\n   * @param to defines the end key\n   * @param loop defines if the animation must loop\n   * @param delay defines the start delay (in ms)\n   * @param onAnimationEnd defines a callback to call when animation ends\n   */\n  playAnimation(from, to, loop, delay, onAnimationEnd = null) {\n    this._onAnimationEnd = onAnimationEnd;\n    super.playAnimation(from, to, loop, delay, this._endAnimation);\n  }\n  /** Release associated resources */\n  dispose() {\n    for (let i = 0; i < this._manager.sprites.length; i++) {\n      if (this._manager.sprites[i] == this) {\n        this._manager.sprites.splice(i, 1);\n      }\n    }\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n  }\n  /**\n   * Serializes the sprite to a JSON object\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.position = this.position.asArray();\n    serializationObject.color = this.color.asArray();\n    serializationObject.width = this.width;\n    serializationObject.height = this.height;\n    serializationObject.angle = this.angle;\n    serializationObject.cellIndex = this.cellIndex;\n    serializationObject.cellRef = this.cellRef;\n    serializationObject.invertU = this.invertU;\n    serializationObject.invertV = this.invertV;\n    serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\n    serializationObject.isPickable = this.isPickable;\n    serializationObject.isVisible = this.isVisible;\n    serializationObject.useAlphaForPicking = this.useAlphaForPicking;\n    serializationObject.animationStarted = this.animationStarted;\n    serializationObject.fromIndex = this.fromIndex;\n    serializationObject.toIndex = this.toIndex;\n    serializationObject.loopAnimation = this.loopAnimation;\n    serializationObject.delay = this.delay;\n    return serializationObject;\n  }\n  /**\n   * Parses a JSON object to create a new sprite\n   * @param parsedSprite The JSON object to parse\n   * @param manager defines the hosting manager\n   * @returns the new sprite\n   */\n  static Parse(parsedSprite, manager) {\n    const sprite = new Sprite(parsedSprite.name, manager);\n    sprite.position = Vector3.FromArray(parsedSprite.position);\n    sprite.color = Color4.FromArray(parsedSprite.color);\n    sprite.width = parsedSprite.width;\n    sprite.height = parsedSprite.height;\n    sprite.angle = parsedSprite.angle;\n    sprite.cellIndex = parsedSprite.cellIndex;\n    sprite.cellRef = parsedSprite.cellRef;\n    sprite.invertU = parsedSprite.invertU;\n    sprite.invertV = parsedSprite.invertV;\n    sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\n    sprite.isPickable = parsedSprite.isPickable;\n    sprite.isVisible = parsedSprite.isVisible;\n    sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\n    sprite.fromIndex = parsedSprite.fromIndex;\n    sprite.toIndex = parsedSprite.toIndex;\n    sprite.loopAnimation = parsedSprite.loopAnimation;\n    sprite.delay = parsedSprite.delay;\n    if (parsedSprite.animationStarted) {\n      sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\n    }\n    return sprite;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Color4","Observable","ThinSprite","Sprite","constructor","name","manager","Array","_onAnimationEnd","disposeWhenFinishedAnimating","dispose","color","position","Zero","_manager","sprites","push","uniqueId","scene","getUniqueId","size","width","value","height","getClassName","fromIndex","_fromIndex","playAnimation","_toIndex","_loopAnimation","_delay","toIndex","loopAnimation","delay","Math","max","from","to","loop","onAnimationEnd","_endAnimation","i","length","splice","onDisposeObservable","notifyObservers","clear","serialize","serializationObject","asArray","angle","cellIndex","cellRef","invertU","invertV","isPickable","isVisible","useAlphaForPicking","animationStarted","Parse","parsedSprite","sprite","FromArray"],"sourceRoot":"","sources":["../../../../lts/core/generated/Sprites/sprite.ts"],"sourcesContent":["import { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { ActionManager } from \"../Actions/actionManager\";\r\nimport type { ISpriteManager, SpriteManager } from \"./spriteManager\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { ThinSprite } from \"./thinSprite\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\n\r\n/**\r\n * Class used to represent a sprite\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/sprites\r\n */\r\nexport class Sprite extends ThinSprite implements IAnimatable {\r\n    /** Gets or sets the current world position */\r\n    public position: Vector3;\r\n    /** Gets or sets the main color */\r\n    public color: Color4;\r\n    /** Gets or sets a boolean indicating that this sprite should be disposed after animation ends */\r\n    public disposeWhenFinishedAnimating: boolean;\r\n    /** Gets the list of attached animations */\r\n    public animations: Nullable<Array<Animation>> = new Array<Animation>();\r\n    /** Gets or sets a boolean indicating if the sprite can be picked */\r\n    public isPickable = false;\r\n    /** Gets or sets a boolean indicating that sprite texture alpha will be used for precise picking (false by default) */\r\n    public useAlphaForPicking = false;\r\n\r\n    /**\r\n     * Gets or sets the associated action manager\r\n     */\r\n    public actionManager: Nullable<ActionManager>;\r\n\r\n    /**\r\n     * An event triggered when the control has been disposed\r\n     */\r\n    public onDisposeObservable = new Observable<Sprite>();\r\n\r\n    private _manager: ISpriteManager;\r\n    private _onAnimationEnd: Nullable<() => void> = null;\r\n\r\n    /**\r\n     * Gets or sets the sprite size\r\n     */\r\n    public get size(): number {\r\n        return this.width;\r\n    }\r\n\r\n    public set size(value: number) {\r\n        this.width = value;\r\n        this.height = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the unique id of the sprite\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Gets the manager of this sprite\r\n     */\r\n    public get manager() {\r\n        return this._manager;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Sprite\r\n     * @param name defines the name\r\n     * @param manager defines the manager\r\n     */\r\n    constructor(\r\n        /** defines the name */\r\n        public name: string,\r\n        manager: ISpriteManager\r\n    ) {\r\n        super();\r\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        this.position = Vector3.Zero();\r\n\r\n        this._manager = manager;\r\n        this._manager.sprites.push(this);\r\n        this.uniqueId = this._manager.scene.getUniqueId();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"Sprite\"\r\n     * @returns \"Sprite\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sprite\";\r\n    }\r\n\r\n    /** Gets or sets the initial key for the animation (setting it will restart the animation)  */\r\n    public get fromIndex() {\r\n        return this._fromIndex;\r\n    }\r\n    public set fromIndex(value: number) {\r\n        this.playAnimation(value, this._toIndex, this._loopAnimation, this._delay, this._onAnimationEnd);\r\n    }\r\n\r\n    /** Gets or sets the end key for the animation (setting it will restart the animation)  */\r\n    public get toIndex() {\r\n        return this._toIndex;\r\n    }\r\n    public set toIndex(value: number) {\r\n        this.playAnimation(this._fromIndex, value, this._loopAnimation, this._delay, this._onAnimationEnd);\r\n    }\r\n\r\n    /** Gets or sets a boolean indicating if the animation is looping (setting it will restart the animation)  */\r\n    public get loopAnimation() {\r\n        return this._loopAnimation;\r\n    }\r\n    public set loopAnimation(value: boolean) {\r\n        this.playAnimation(this._fromIndex, this._toIndex, value, this._delay, this._onAnimationEnd);\r\n    }\r\n\r\n    /** Gets or sets the delay between cell changes (setting it will restart the animation)  */\r\n    public get delay() {\r\n        return Math.max(this._delay, 1);\r\n    }\r\n    public set delay(value: number) {\r\n        this.playAnimation(this._fromIndex, this._toIndex, this._loopAnimation, value, this._onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Starts an animation\r\n     * @param from defines the initial key\r\n     * @param to defines the end key\r\n     * @param loop defines if the animation must loop\r\n     * @param delay defines the start delay (in ms)\r\n     * @param onAnimationEnd defines a callback to call when animation ends\r\n     */\r\n    public playAnimation(from: number, to: number, loop: boolean, delay: number, onAnimationEnd: Nullable<() => void> = null): void {\r\n        this._onAnimationEnd = onAnimationEnd;\r\n\r\n        super.playAnimation(from, to, loop, delay, this._endAnimation);\r\n    }\r\n\r\n    private _endAnimation = () => {\r\n        if (this._onAnimationEnd) {\r\n            this._onAnimationEnd();\r\n        }\r\n        if (this.disposeWhenFinishedAnimating) {\r\n            this.dispose();\r\n        }\r\n    };\r\n\r\n    /** Release associated resources */\r\n    public dispose(): void {\r\n        for (let i = 0; i < this._manager.sprites.length; i++) {\r\n            if (this._manager.sprites[i] == this) {\r\n                this._manager.sprites.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Serializes the sprite to a JSON object\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.position = this.position.asArray();\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.width = this.width;\r\n        serializationObject.height = this.height;\r\n        serializationObject.angle = this.angle;\r\n        serializationObject.cellIndex = this.cellIndex;\r\n        serializationObject.cellRef = this.cellRef;\r\n        serializationObject.invertU = this.invertU;\r\n        serializationObject.invertV = this.invertV;\r\n        serializationObject.disposeWhenFinishedAnimating = this.disposeWhenFinishedAnimating;\r\n        serializationObject.isPickable = this.isPickable;\r\n        serializationObject.isVisible = this.isVisible;\r\n        serializationObject.useAlphaForPicking = this.useAlphaForPicking;\r\n\r\n        serializationObject.animationStarted = this.animationStarted;\r\n        serializationObject.fromIndex = this.fromIndex;\r\n        serializationObject.toIndex = this.toIndex;\r\n        serializationObject.loopAnimation = this.loopAnimation;\r\n        serializationObject.delay = this.delay;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON object to create a new sprite\r\n     * @param parsedSprite The JSON object to parse\r\n     * @param manager defines the hosting manager\r\n     * @returns the new sprite\r\n     */\r\n    public static Parse(parsedSprite: any, manager: SpriteManager): Sprite {\r\n        const sprite = new Sprite(parsedSprite.name, manager);\r\n\r\n        sprite.position = Vector3.FromArray(parsedSprite.position);\r\n        sprite.color = Color4.FromArray(parsedSprite.color);\r\n        sprite.width = parsedSprite.width;\r\n        sprite.height = parsedSprite.height;\r\n        sprite.angle = parsedSprite.angle;\r\n        sprite.cellIndex = parsedSprite.cellIndex;\r\n        sprite.cellRef = parsedSprite.cellRef;\r\n        sprite.invertU = parsedSprite.invertU;\r\n        sprite.invertV = parsedSprite.invertV;\r\n        sprite.disposeWhenFinishedAnimating = parsedSprite.disposeWhenFinishedAnimating;\r\n        sprite.isPickable = parsedSprite.isPickable;\r\n        sprite.isVisible = parsedSprite.isVisible;\r\n        sprite.useAlphaForPicking = parsedSprite.useAlphaForPicking;\r\n\r\n        sprite.fromIndex = parsedSprite.fromIndex;\r\n        sprite.toIndex = parsedSprite.toIndex;\r\n        sprite.loopAnimation = parsedSprite.loopAnimation;\r\n        sprite.delay = parsedSprite.delay;\r\n\r\n        if (parsedSprite.animationStarted) {\r\n            sprite.playAnimation(sprite.fromIndex, sprite.toIndex, sprite.loopAnimation, sprite.delay);\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}