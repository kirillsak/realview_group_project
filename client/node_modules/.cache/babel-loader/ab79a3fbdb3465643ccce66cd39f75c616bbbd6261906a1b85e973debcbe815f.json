{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\n/**\n * Class containing a set of static utilities functions for arrays.\n */\nexport class ArrayTools {\n  /**\n   * Returns an array of the given size filled with elements built from the given constructor and the parameters.\n   * @param size the number of element to construct and put in the array.\n   * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\n   * @returns a new array filled with new objects.\n   */\n  static BuildArray(size, itemBuilder) {\n    const a = [];\n    for (let i = 0; i < size; ++i) {\n      a.push(itemBuilder());\n    }\n    return a;\n  }\n  /**\n   * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.\n   * @param size he number of element to construct and put in the tuple.\n   * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.\n   * @returns a new tuple filled with new objects.\n   */\n  static BuildTuple(size, itemBuilder) {\n    return ArrayTools.BuildArray(size, itemBuilder);\n  }\n}\n/**\n * Observes a function and calls the given callback when it is called.\n * @param object Defines the object the function to observe belongs to.\n * @param functionName Defines the name of the function to observe.\n * @param callback Defines the callback to call when the function is called.\n * @returns A function to call to stop observing\n */\nfunction _observeArrayfunction(object, functionName, callback) {\n  // Finds the function to observe\n  const oldFunction = object[functionName];\n  if (typeof oldFunction !== \"function\") {\n    return null;\n  }\n  // Creates a new function that calls the callback and the old function\n  const newFunction = function () {\n    const previousLength = object.length;\n    const returnValue = newFunction.previous.apply(object, arguments);\n    callback(functionName, previousLength);\n    return returnValue;\n  };\n  // Doublishly links the new function and the old function\n  oldFunction.next = newFunction;\n  newFunction.previous = oldFunction;\n  // Replaces the old function with the new function\n  object[functionName] = newFunction;\n  // Returns a function to disable the hook\n  return () => {\n    // Only unhook if the function is still hooked\n    const previous = newFunction.previous;\n    if (!previous) {\n      return;\n    }\n    // Finds the ref to the next function in the chain\n    const next = newFunction.next;\n    // If in the middle of the chain, link the previous and next functions\n    if (next) {\n      previous.next = next;\n      next.previous = previous;\n    }\n    // If at the end of the chain, remove the reference to the previous function\n    // and restore the previous function\n    else {\n      previous.next = undefined;\n      object[functionName] = previous;\n    }\n    // Lose reference to the previous and next functions\n    newFunction.next = undefined;\n    newFunction.previous = undefined;\n  };\n}\n/**\n * Defines the list of functions to proxy when observing an array.\n * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.\n */\nconst observedArrayFunctions = [\"push\", \"splice\", \"pop\", \"shift\", \"unshift\"];\n/**\n * Observes an array and notifies the given observer when the array is modified.\n * @param array Defines the array to observe\n * @param callback Defines the function to call when the array is modified (in the limit of the observed array functions)\n * @returns A function to call to stop observing the array\n * @internal\n */\nexport function _ObserveArray(array, callback) {\n  // Observes all the required array functions and stores the unhook functions\n  const unObserveFunctions = observedArrayFunctions.map(name => {\n    return _observeArrayfunction(array, name, callback);\n  });\n  // Returns a function that unhook all the observed functions\n  return () => {\n    unObserveFunctions.forEach(unObserveFunction => {\n      unObserveFunction === null || unObserveFunction === void 0 ? void 0 : unObserveFunction();\n    });\n  };\n}","map":{"version":3,"mappings":";AAAA;AAsBA;;;AAGA,OAAM,MAAOA,UAAU;EACnB;;;;;;EAMO,OAAOC,UAAU,CAAIC,IAAY,EAAEC,WAAoB;IAC1D,MAAMC,CAAC,GAAQ,EAAE;IACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,EAAE,EAAEG,CAAC,EAAE;MAC3BD,CAAC,CAACE,IAAI,CAACH,WAAW,EAAE,CAAC;;IAEzB,OAAOC,CAAC;EACZ;EAEA;;;;;;EAMO,OAAOG,UAAU,CAAyCL,IAAO,EAAEC,WAAoB;IAC1F,OAAOH,UAAU,CAACC,UAAU,CAACC,IAAI,EAAEC,WAAW,CAAQ;EAC1D;;AASJ;;;;;;;AAOA,SAASK,qBAAqB,CAACC,MAA8B,EAAEC,YAAoB,EAAEC,QAA0B;EAC3G;EACA,MAAMC,WAAW,GAAGH,MAAM,CAACC,YAAY,CAAC;EACxC,IAAI,OAAOE,WAAW,KAAK,UAAU,EAAE;IACnC,OAAO,IAAI;;EAGf;EACA,MAAMC,WAAW,GAAG;IAChB,MAAMC,cAAc,GAAGL,MAAM,CAACM,MAAM;IACpC,MAAMC,WAAW,GAAGH,WAAW,CAACI,QAAQ,CAACC,KAAK,CAACT,MAAM,EAAEU,SAAS,CAAC;IACjER,QAAQ,CAACD,YAAY,EAAEI,cAAc,CAAC;IACtC,OAAOE,WAAW;EACtB,CAAQ;EAER;EACAJ,WAAW,CAACQ,IAAI,GAAGP,WAAW;EAC9BA,WAAW,CAACI,QAAQ,GAAGL,WAAW;EAElC;EACAH,MAAM,CAACC,YAAY,CAAC,GAAGG,WAAW;EAElC;EACA,OAAO,MAAK;IACR;IACA,MAAMI,QAAQ,GAAGJ,WAAW,CAACI,QAAQ;IACrC,IAAI,CAACA,QAAQ,EAAE;MACX;;IAGJ;IACA,MAAMG,IAAI,GAAGP,WAAW,CAACO,IAAI;IAE7B;IACA,IAAIA,IAAI,EAAE;MACNH,QAAQ,CAACG,IAAI,GAAGA,IAAI;MACpBA,IAAI,CAACH,QAAQ,GAAGA,QAAQ;;IAE5B;IACA;IAAA,KACK;MACDA,QAAQ,CAACG,IAAI,GAAGC,SAAS;MACzBZ,MAAM,CAACC,YAAY,CAAC,GAAGO,QAAQ;;IAGnC;IACAJ,WAAW,CAACO,IAAI,GAAGC,SAAS;IAC5BR,WAAW,CAACI,QAAQ,GAAGI,SAAS;EACpC,CAAC;AACL;AAEA;;;;AAIA,MAAMC,sBAAsB,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,SAAS,CAAC;AAE5E;;;;;;;AAOA,OAAM,SAAUC,aAAa,CAAIC,KAAU,EAAEb,QAA0B;EACnE;EACA,MAAMc,kBAAkB,GAAGH,sBAAsB,CAACI,GAAG,CAAEC,IAAI,IAAI;IAC3D,OAAOnB,qBAAqB,CAACgB,KAAK,EAAEG,IAAI,EAAEhB,QAAQ,CAAC;EACvD,CAAC,CAAC;EAEF;EACA,OAAO,MAAK;IACRc,kBAAkB,CAACG,OAAO,CAAEC,iBAAiB,IAAI;MAC7CA,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,EAAI;IACzB,CAAC,CAAC;EACN,CAAC;AACL","names":["ArrayTools","BuildArray","size","itemBuilder","a","i","push","BuildTuple","_observeArrayfunction","object","functionName","callback","oldFunction","newFunction","previousLength","length","returnValue","previous","apply","arguments","next","undefined","observedArrayFunctions","_ObserveArray","array","unObserveFunctions","map","name","forEach","unObserveFunction"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/arrayTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport type { Nullable } from \"../types\";\r\n\r\n/** @internal */\r\ninterface TupleTypes<T> {\r\n    2: [T, T];\r\n    3: [T, T, T];\r\n    4: [T, T, T, T];\r\n    5: [T, T, T, T, T];\r\n    6: [T, T, T, T, T, T];\r\n    7: [T, T, T, T, T, T, T];\r\n    8: [T, T, T, T, T, T, T, T];\r\n    9: [T, T, T, T, T, T, T, T, T];\r\n    10: [T, T, T, T, T, T, T, T, T, T];\r\n    11: [T, T, T, T, T, T, T, T, T, T, T];\r\n    12: [T, T, T, T, T, T, T, T, T, T, T, T];\r\n    13: [T, T, T, T, T, T, T, T, T, T, T, T, T];\r\n    14: [T, T, T, T, T, T, T, T, T, T, T, T, T, T];\r\n    15: [T, T, T, T, T, T, T, T, T, T, T, T, T, T, T];\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for arrays.\r\n */\r\nexport class ArrayTools {\r\n    /**\r\n     * Returns an array of the given size filled with elements built from the given constructor and the parameters.\r\n     * @param size the number of element to construct and put in the array.\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.\r\n     * @returns a new array filled with new objects.\r\n     */\r\n    public static BuildArray<T>(size: number, itemBuilder: () => T): Array<T> {\r\n        const a: T[] = [];\r\n        for (let i = 0; i < size; ++i) {\r\n            a.push(itemBuilder());\r\n        }\r\n        return a;\r\n    }\r\n\r\n    /**\r\n     * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.\r\n     * @param size he number of element to construct and put in the tuple.\r\n     * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.\r\n     * @returns a new tuple filled with new objects.\r\n     */\r\n    public static BuildTuple<T, N extends keyof TupleTypes<unknown>>(size: N, itemBuilder: () => T): TupleTypes<T>[N] {\r\n        return ArrayTools.BuildArray(size, itemBuilder) as any;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the callback type used when an observed array function is triggered.\r\n * @internal\r\n */\r\nexport type _ObserveCallback = (functionName: string, previousLength: number) => void;\r\n\r\n/**\r\n * Observes a function and calls the given callback when it is called.\r\n * @param object Defines the object the function to observe belongs to.\r\n * @param functionName Defines the name of the function to observe.\r\n * @param callback Defines the callback to call when the function is called.\r\n * @returns A function to call to stop observing\r\n */\r\nfunction _observeArrayfunction(object: { [key: string]: any }, functionName: string, callback: _ObserveCallback): Nullable<() => void> {\r\n    // Finds the function to observe\r\n    const oldFunction = object[functionName];\r\n    if (typeof oldFunction !== \"function\") {\r\n        return null;\r\n    }\r\n\r\n    // Creates a new function that calls the callback and the old function\r\n    const newFunction = function () {\r\n        const previousLength = object.length;\r\n        const returnValue = newFunction.previous.apply(object, arguments);\r\n        callback(functionName, previousLength);\r\n        return returnValue;\r\n    } as any;\r\n\r\n    // Doublishly links the new function and the old function\r\n    oldFunction.next = newFunction;\r\n    newFunction.previous = oldFunction;\r\n\r\n    // Replaces the old function with the new function\r\n    object[functionName] = newFunction;\r\n\r\n    // Returns a function to disable the hook\r\n    return () => {\r\n        // Only unhook if the function is still hooked\r\n        const previous = newFunction.previous;\r\n        if (!previous) {\r\n            return;\r\n        }\r\n\r\n        // Finds the ref to the next function in the chain\r\n        const next = newFunction.next;\r\n\r\n        // If in the middle of the chain, link the previous and next functions\r\n        if (next) {\r\n            previous.next = next;\r\n            next.previous = previous;\r\n        }\r\n        // If at the end of the chain, remove the reference to the previous function\r\n        // and restore the previous function\r\n        else {\r\n            previous.next = undefined;\r\n            object[functionName] = previous;\r\n        }\r\n\r\n        // Lose reference to the previous and next functions\r\n        newFunction.next = undefined;\r\n        newFunction.previous = undefined;\r\n    };\r\n}\r\n\r\n/**\r\n * Defines the list of functions to proxy when observing an array.\r\n * The scope is currently reduced to the common functions used in the render target render list and the scene cameras.\r\n */\r\nconst observedArrayFunctions = [\"push\", \"splice\", \"pop\", \"shift\", \"unshift\"];\r\n\r\n/**\r\n * Observes an array and notifies the given observer when the array is modified.\r\n * @param array Defines the array to observe\r\n * @param callback Defines the function to call when the array is modified (in the limit of the observed array functions)\r\n * @returns A function to call to stop observing the array\r\n * @internal\r\n */\r\nexport function _ObserveArray<T>(array: T[], callback: _ObserveCallback) {\r\n    // Observes all the required array functions and stores the unhook functions\r\n    const unObserveFunctions = observedArrayFunctions.map((name) => {\r\n        return _observeArrayfunction(array, name, callback);\r\n    });\r\n\r\n    // Returns a function that unhook all the observed functions\r\n    return () => {\r\n        unObserveFunctions.forEach((unObserveFunction) => {\r\n            unObserveFunction?.();\r\n        });\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}