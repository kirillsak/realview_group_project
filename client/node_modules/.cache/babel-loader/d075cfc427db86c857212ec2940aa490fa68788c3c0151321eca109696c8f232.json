{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { IsWindowObjectExist } from \"../Misc/domManagement.js\";\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController.js\";\nimport { Xbox360Pad } from \"./xboxGamepad.js\";\nimport { Gamepad, GenericPad } from \"./gamepad.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { DualShockPad } from \"./dualShockGamepad.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * Manager for handling gamepads\n */\nexport class GamepadManager {\n  /**\n   * Initializes the gamepad manager\n   * @param _scene BabylonJS scene\n   */\n  constructor(_scene) {\n    this._scene = _scene;\n    this._babylonGamepads = [];\n    this._oneGamepadConnected = false;\n    /** @internal */\n    this._isMonitoring = false;\n    /**\n     * observable to be triggered when the gamepad controller has been disconnected\n     */\n    this.onGamepadDisconnectedObservable = new Observable();\n    if (!IsWindowObjectExist()) {\n      this._gamepadEventSupported = false;\n    } else {\n      this._gamepadEventSupported = \"GamepadEvent\" in window;\n      this._gamepadSupport = navigator && navigator.getGamepads;\n    }\n    this.onGamepadConnectedObservable = new Observable(observer => {\n      // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\n      for (const i in this._babylonGamepads) {\n        const gamepad = this._babylonGamepads[i];\n        if (gamepad && gamepad._isConnected) {\n          this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\n        }\n      }\n    });\n    this._onGamepadConnectedEvent = evt => {\n      const gamepad = evt.gamepad;\n      if (gamepad.index in this._babylonGamepads) {\n        if (this._babylonGamepads[gamepad.index].isConnected) {\n          return;\n        }\n      }\n      let newGamepad;\n      if (this._babylonGamepads[gamepad.index]) {\n        newGamepad = this._babylonGamepads[gamepad.index];\n        newGamepad.browserGamepad = gamepad;\n        newGamepad._isConnected = true;\n      } else {\n        newGamepad = this._addNewGamepad(gamepad);\n      }\n      this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n      this._startMonitoringGamepads();\n    };\n    this._onGamepadDisconnectedEvent = evt => {\n      const gamepad = evt.gamepad;\n      // Remove the gamepad from the list of gamepads to monitor.\n      for (const i in this._babylonGamepads) {\n        if (this._babylonGamepads[i].index === gamepad.index) {\n          const disconnectedGamepad = this._babylonGamepads[i];\n          disconnectedGamepad._isConnected = false;\n          this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\n          disconnectedGamepad.dispose && disconnectedGamepad.dispose();\n          break;\n        }\n      }\n    };\n    if (this._gamepadSupport) {\n      //first add already-connected gamepads\n      this._updateGamepadObjects();\n      if (this._babylonGamepads.length) {\n        this._startMonitoringGamepads();\n      }\n      // Checking if the gamepad connected event is supported (like in Firefox)\n      if (this._gamepadEventSupported) {\n        const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\n        if (hostWindow) {\n          hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\n          hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\n        }\n      } else {\n        this._startMonitoringGamepads();\n      }\n    }\n  }\n  /**\n   * The gamepads in the game pad manager\n   */\n  get gamepads() {\n    return this._babylonGamepads;\n  }\n  /**\n   * Get the gamepad controllers based on type\n   * @param type The type of gamepad controller\n   * @returns Nullable gamepad\n   */\n  getGamepadByType(type = Gamepad.XBOX) {\n    for (const gamepad of this._babylonGamepads) {\n      if (gamepad && gamepad.type === type) {\n        return gamepad;\n      }\n    }\n    return null;\n  }\n  /**\n   * Disposes the gamepad manager\n   */\n  dispose() {\n    if (this._gamepadEventSupported) {\n      if (this._onGamepadConnectedEvent) {\n        window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\n      }\n      if (this._onGamepadDisconnectedEvent) {\n        window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\n      }\n      this._onGamepadConnectedEvent = null;\n      this._onGamepadDisconnectedEvent = null;\n    }\n    this._babylonGamepads.forEach(gamepad => {\n      gamepad.dispose();\n    });\n    this.onGamepadConnectedObservable.clear();\n    this.onGamepadDisconnectedObservable.clear();\n    this._oneGamepadConnected = false;\n    this._stopMonitoringGamepads();\n    this._babylonGamepads = [];\n  }\n  _addNewGamepad(gamepad) {\n    if (!this._oneGamepadConnected) {\n      this._oneGamepadConnected = true;\n    }\n    let newGamepad;\n    const dualShock = gamepad.id.search(\"054c\") !== -1 && gamepad.id.search(\"0ce6\") === -1;\n    const xboxOne = gamepad.id.search(\"Xbox One\") !== -1;\n    if (xboxOne || gamepad.id.search(\"Xbox 360\") !== -1 || gamepad.id.search(\"xinput\") !== -1 || gamepad.id.search(\"045e\") !== -1 && gamepad.id.search(\"Surface Dock\") === -1) {\n      // make sure the Surface Dock Extender is not detected as an xbox controller\n      newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\n    } else if (dualShock) {\n      newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\n    }\n    // if pose is supported, use the (WebVR) pose enabled controller\n    else if (gamepad.pose) {\n      newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\n    } else {\n      newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\n    }\n    this._babylonGamepads[newGamepad.index] = newGamepad;\n    return newGamepad;\n  }\n  _startMonitoringGamepads() {\n    if (!this._isMonitoring) {\n      this._isMonitoring = true;\n      //back-comp\n      if (!this._scene) {\n        this._checkGamepadsStatus();\n      }\n    }\n  }\n  _stopMonitoringGamepads() {\n    this._isMonitoring = false;\n  }\n  /** @internal */\n  _checkGamepadsStatus() {\n    // Hack to be compatible Chrome\n    this._updateGamepadObjects();\n    for (const i in this._babylonGamepads) {\n      const gamepad = this._babylonGamepads[i];\n      if (!gamepad || !gamepad.isConnected) {\n        continue;\n      }\n      try {\n        gamepad.update();\n      } catch (_a) {\n        if (this._loggedErrors.indexOf(gamepad.index) === -1) {\n          Tools.Warn(`Error updating gamepad ${gamepad.id}`);\n          this._loggedErrors.push(gamepad.index);\n        }\n      }\n    }\n    if (this._isMonitoring && !this._scene) {\n      Engine.QueueNewFrame(() => {\n        this._checkGamepadsStatus();\n      });\n    }\n  }\n  // This function is called only on Chrome, which does not properly support\n  // connection/disconnection events and forces you to recopy again the gamepad object\n  _updateGamepadObjects() {\n    const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\n    for (let i = 0; i < gamepads.length; i++) {\n      const gamepad = gamepads[i];\n      if (gamepad) {\n        if (!this._babylonGamepads[gamepad.index]) {\n          const newGamepad = this._addNewGamepad(gamepad);\n          this.onGamepadConnectedObservable.notifyObservers(newGamepad);\n        } else {\n          // Forced to copy again this object for Chrome for unknown reason\n          this._babylonGamepads[i].browserGamepad = gamepad;\n          if (!this._babylonGamepads[i].isConnected) {\n            this._babylonGamepads[i]._isConnected = true;\n            this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","IsWindowObjectExist","PoseEnabledControllerHelper","Xbox360Pad","Gamepad","GenericPad","Engine","DualShockPad","Tools","GamepadManager","constructor","_scene","_gamepadEventSupported","window","_gamepadSupport","navigator","getGamepads","onGamepadConnectedObservable","observer","i","_babylonGamepads","gamepad","_isConnected","notifyObserver","_onGamepadConnectedEvent","evt","index","isConnected","newGamepad","browserGamepad","_addNewGamepad","notifyObservers","_startMonitoringGamepads","_onGamepadDisconnectedEvent","disconnectedGamepad","onGamepadDisconnectedObservable","dispose","_updateGamepadObjects","length","hostWindow","getEngine","getHostWindow","addEventListener","gamepads","getGamepadByType","type","XBOX","removeEventListener","forEach","clear","_oneGamepadConnected","_stopMonitoringGamepads","dualShock","id","search","xboxOne","pose","InitiateController","_isMonitoring","_checkGamepadsStatus","update","_loggedErrors","indexOf","Warn","push","QueueNewFrame"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gamepads/gamepadManager.ts"],"sourcesContent":["import { Observable } from \"../Misc/observable\";\r\nimport { IsWindowObjectExist } from \"../Misc/domManagement\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PoseEnabledControllerHelper } from \"../Gamepads/Controllers/poseEnabledController\";\r\nimport { Xbox360Pad } from \"./xboxGamepad\";\r\nimport { Gamepad, GenericPad } from \"./gamepad\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { DualShockPad } from \"./dualShockGamepad\";\r\nimport { Tools } from \"../Misc/tools\";\r\n/**\r\n * Manager for handling gamepads\r\n */\r\nexport class GamepadManager {\r\n    private _babylonGamepads: Array<Gamepad> = [];\r\n    private _oneGamepadConnected: boolean = false;\r\n\r\n    /** @internal */\r\n    public _isMonitoring: boolean = false;\r\n    private _gamepadEventSupported: boolean;\r\n    private _gamepadSupport?: () => Array<any>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been connected\r\n     */\r\n    public onGamepadConnectedObservable: Observable<Gamepad>;\r\n\r\n    /**\r\n     * observable to be triggered when the gamepad controller has been disconnected\r\n     */\r\n    public onGamepadDisconnectedObservable = new Observable<Gamepad>();\r\n\r\n    private _onGamepadConnectedEvent: Nullable<(evt: any) => void>;\r\n    private _onGamepadDisconnectedEvent: Nullable<(evt: any) => void>;\r\n\r\n    /**\r\n     * Initializes the gamepad manager\r\n     * @param _scene BabylonJS scene\r\n     */\r\n    constructor(private _scene?: Scene) {\r\n        if (!IsWindowObjectExist()) {\r\n            this._gamepadEventSupported = false;\r\n        } else {\r\n            this._gamepadEventSupported = \"GamepadEvent\" in window;\r\n            this._gamepadSupport = navigator && navigator.getGamepads;\r\n        }\r\n\r\n        this.onGamepadConnectedObservable = new Observable<Gamepad>((observer) => {\r\n            // This will be used to raise the onGamepadConnected for all gamepads ALREADY connected\r\n            for (const i in this._babylonGamepads) {\r\n                const gamepad = this._babylonGamepads[i];\r\n                if (gamepad && gamepad._isConnected) {\r\n                    this.onGamepadConnectedObservable.notifyObserver(observer, gamepad);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            if (gamepad.index in this._babylonGamepads) {\r\n                if (this._babylonGamepads[gamepad.index].isConnected) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            let newGamepad: Gamepad;\r\n\r\n            if (this._babylonGamepads[gamepad.index]) {\r\n                newGamepad = this._babylonGamepads[gamepad.index];\r\n                newGamepad.browserGamepad = gamepad;\r\n                newGamepad._isConnected = true;\r\n            } else {\r\n                newGamepad = this._addNewGamepad(gamepad);\r\n            }\r\n            this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n            this._startMonitoringGamepads();\r\n        };\r\n\r\n        this._onGamepadDisconnectedEvent = (evt) => {\r\n            const gamepad = evt.gamepad;\r\n\r\n            // Remove the gamepad from the list of gamepads to monitor.\r\n            for (const i in this._babylonGamepads) {\r\n                if (this._babylonGamepads[i].index === gamepad.index) {\r\n                    const disconnectedGamepad = this._babylonGamepads[i];\r\n                    disconnectedGamepad._isConnected = false;\r\n\r\n                    this.onGamepadDisconnectedObservable.notifyObservers(disconnectedGamepad);\r\n                    disconnectedGamepad.dispose && disconnectedGamepad.dispose();\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (this._gamepadSupport) {\r\n            //first add already-connected gamepads\r\n            this._updateGamepadObjects();\r\n            if (this._babylonGamepads.length) {\r\n                this._startMonitoringGamepads();\r\n            }\r\n            // Checking if the gamepad connected event is supported (like in Firefox)\r\n            if (this._gamepadEventSupported) {\r\n                const hostWindow = this._scene ? this._scene.getEngine().getHostWindow() : window;\r\n\r\n                if (hostWindow) {\r\n                    hostWindow.addEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent, false);\r\n                    hostWindow.addEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent, false);\r\n                }\r\n            } else {\r\n                this._startMonitoringGamepads();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The gamepads in the game pad manager\r\n     */\r\n    public get gamepads(): Gamepad[] {\r\n        return this._babylonGamepads;\r\n    }\r\n\r\n    /**\r\n     * Get the gamepad controllers based on type\r\n     * @param type The type of gamepad controller\r\n     * @returns Nullable gamepad\r\n     */\r\n    public getGamepadByType(type: number = Gamepad.XBOX): Nullable<Gamepad> {\r\n        for (const gamepad of this._babylonGamepads) {\r\n            if (gamepad && gamepad.type === type) {\r\n                return gamepad;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the gamepad manager\r\n     */\r\n    public dispose() {\r\n        if (this._gamepadEventSupported) {\r\n            if (this._onGamepadConnectedEvent) {\r\n                window.removeEventListener(\"gamepadconnected\", this._onGamepadConnectedEvent);\r\n            }\r\n\r\n            if (this._onGamepadDisconnectedEvent) {\r\n                window.removeEventListener(\"gamepaddisconnected\", this._onGamepadDisconnectedEvent);\r\n            }\r\n            this._onGamepadConnectedEvent = null;\r\n            this._onGamepadDisconnectedEvent = null;\r\n        }\r\n\r\n        this._babylonGamepads.forEach((gamepad) => {\r\n            gamepad.dispose();\r\n        });\r\n\r\n        this.onGamepadConnectedObservable.clear();\r\n        this.onGamepadDisconnectedObservable.clear();\r\n\r\n        this._oneGamepadConnected = false;\r\n        this._stopMonitoringGamepads();\r\n        this._babylonGamepads = [];\r\n    }\r\n\r\n    private _addNewGamepad(gamepad: any): Gamepad {\r\n        if (!this._oneGamepadConnected) {\r\n            this._oneGamepadConnected = true;\r\n        }\r\n\r\n        let newGamepad;\r\n        const dualShock: boolean = (<string>gamepad.id).search(\"054c\") !== -1 && (<string>gamepad.id).search(\"0ce6\") === -1;\r\n        const xboxOne: boolean = (<string>gamepad.id).search(\"Xbox One\") !== -1;\r\n        if (\r\n            xboxOne ||\r\n            (<string>gamepad.id).search(\"Xbox 360\") !== -1 ||\r\n            (<string>gamepad.id).search(\"xinput\") !== -1 ||\r\n            ((<string>gamepad.id).search(\"045e\") !== -1 && (<string>gamepad.id).search(\"Surface Dock\") === -1)\r\n        ) {\r\n            // make sure the Surface Dock Extender is not detected as an xbox controller\r\n            newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\r\n        } else if (dualShock) {\r\n            newGamepad = new DualShockPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        // if pose is supported, use the (WebVR) pose enabled controller\r\n        else if (gamepad.pose) {\r\n            newGamepad = PoseEnabledControllerHelper.InitiateController(gamepad);\r\n        } else {\r\n            newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\r\n        }\r\n        this._babylonGamepads[newGamepad.index] = newGamepad;\r\n        return newGamepad;\r\n    }\r\n\r\n    private _startMonitoringGamepads() {\r\n        if (!this._isMonitoring) {\r\n            this._isMonitoring = true;\r\n            //back-comp\r\n            if (!this._scene) {\r\n                this._checkGamepadsStatus();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _stopMonitoringGamepads() {\r\n        this._isMonitoring = false;\r\n    }\r\n\r\n    private _loggedErrors: number[];\r\n\r\n    /** @internal */\r\n    public _checkGamepadsStatus() {\r\n        // Hack to be compatible Chrome\r\n        this._updateGamepadObjects();\r\n\r\n        for (const i in this._babylonGamepads) {\r\n            const gamepad = this._babylonGamepads[i];\r\n            if (!gamepad || !gamepad.isConnected) {\r\n                continue;\r\n            }\r\n            try {\r\n                gamepad.update();\r\n            } catch {\r\n                if (this._loggedErrors.indexOf(gamepad.index) === -1) {\r\n                    Tools.Warn(`Error updating gamepad ${gamepad.id}`);\r\n                    this._loggedErrors.push(gamepad.index);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._isMonitoring && !this._scene) {\r\n            Engine.QueueNewFrame(() => {\r\n                this._checkGamepadsStatus();\r\n            });\r\n        }\r\n    }\r\n\r\n    // This function is called only on Chrome, which does not properly support\r\n    // connection/disconnection events and forces you to recopy again the gamepad object\r\n    private _updateGamepadObjects() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if (gamepad) {\r\n                if (!this._babylonGamepads[gamepad.index]) {\r\n                    const newGamepad = this._addNewGamepad(gamepad);\r\n                    this.onGamepadConnectedObservable.notifyObservers(newGamepad);\r\n                } else {\r\n                    // Forced to copy again this object for Chrome for unknown reason\r\n                    this._babylonGamepads[i].browserGamepad = gamepad;\r\n\r\n                    if (!this._babylonGamepads[i].isConnected) {\r\n                        this._babylonGamepads[i]._isConnected = true;\r\n                        this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[i]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}