{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\n * @param options the constructors options used to shape the mesh.\n * @returns the capsule VertexData\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsuleVertexData(options = {\n  subdivisions: 2,\n  tessellation: 16,\n  height: 1,\n  radius: 0.25,\n  capSubdivisions: 6\n}) {\n  const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\n  const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\n  const height = Math.max(options.height ? options.height : 1, 0);\n  const radius = Math.max(options.radius ? options.radius : 0.25, 0);\n  const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\n  const radialSegments = tessellation;\n  const heightSegments = subdivisions;\n  const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\n  const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\n  const heightMinusCaps = height - (radiusTop + radiusBottom);\n  const thetaStart = 0.0;\n  const thetaLength = 2.0 * Math.PI;\n  const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\n  const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\n  const alpha = Math.acos((radiusBottom - radiusTop) / height);\n  let indices = [];\n  const vertices = [];\n  const normals = [];\n  const uvs = [];\n  let index = 0;\n  const indexArray = [],\n    halfHeight = heightMinusCaps * 0.5;\n  const pi2 = Math.PI * 0.5;\n  let x, y;\n  const normal = Vector3.Zero();\n  const vertex = Vector3.Zero();\n  const cosAlpha = Math.cos(alpha);\n  const sinAlpha = Math.sin(alpha);\n  const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha).subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha)).length();\n  // Total length for v texture coord\n  const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\n  let v = 0;\n  for (y = 0; y <= capsTopSegments; y++) {\n    const indexRow = [];\n    const a = pi2 - alpha * (y / capsTopSegments);\n    v += radiusTop * alpha / capsTopSegments;\n    const cosA = Math.cos(a);\n    const sinA = Math.sin(a);\n    // calculate the radius of the current row\n    const _radius = cosA * radiusTop;\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * thetaLength + thetaStart;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      // vertex\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + sinA * radiusTop;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      // normal\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z);\n      // uv\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n      // save index of vertex in respective row\n      indexRow.push(index);\n      // increase index\n      index++;\n    }\n    // now save vertices of the row in our index array\n    indexArray.push(indexRow);\n  }\n  const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\n  const slope = sinAlpha * (radiusBottom - radiusTop) / coneHeight;\n  for (y = 1; y <= heightSegments; y++) {\n    const indexRow = [];\n    v += coneLength / heightSegments;\n    // calculate the radius of the current row\n    const _radius = sinAlpha * (y * (radiusBottom - radiusTop) / heightSegments + radiusTop);\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * thetaLength + thetaStart;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      // vertex\n      vertex.x = _radius * sinTheta;\n      vertex.y = halfHeight + cosAlpha * radiusTop - y * coneHeight / heightSegments;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      // normal\n      normal.set(sinTheta, slope, cosTheta).normalize();\n      normals.push(normal.x, normal.y, normal.z);\n      // uv\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n      // save index of vertex in respective row\n      indexRow.push(index);\n      // increase index\n      index++;\n    }\n    // now save vertices of the row in our index array\n    indexArray.push(indexRow);\n  }\n  for (y = 1; y <= capsBottomSegments; y++) {\n    const indexRow = [];\n    const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\n    v += radiusBottom * alpha / capsBottomSegments;\n    const cosA = Math.cos(a);\n    const sinA = Math.sin(a);\n    // calculate the radius of the current row\n    const _radius = cosA * radiusBottom;\n    for (x = 0; x <= radialSegments; x++) {\n      const u = x / radialSegments;\n      const theta = u * thetaLength + thetaStart;\n      const sinTheta = Math.sin(theta);\n      const cosTheta = Math.cos(theta);\n      // vertex\n      vertex.x = _radius * sinTheta;\n      vertex.y = -halfHeight + sinA * radiusBottom;\n      vertex.z = _radius * cosTheta;\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      // normal\n      normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\n      normals.push(normal.x, normal.y, normal.z);\n      // uv\n      uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\n      // save index of vertex in respective row\n      indexRow.push(index);\n      // increase index\n      index++;\n    }\n    // now save vertices of the row in our index array\n    indexArray.push(indexRow);\n  }\n  // generate indices\n  for (x = 0; x < radialSegments; x++) {\n    for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\n      // we use the index array to access the correct indices\n      const i1 = indexArray[y][x];\n      const i2 = indexArray[y + 1][x];\n      const i3 = indexArray[y + 1][x + 1];\n      const i4 = indexArray[y][x + 1];\n      // face one\n      indices.push(i1);\n      indices.push(i2);\n      indices.push(i4);\n      // face two\n      indices.push(i2);\n      indices.push(i3);\n      indices.push(i4);\n    }\n  }\n  indices = indices.reverse();\n  if (options.orientation && !options.orientation.equals(Vector3.Up())) {\n    const m = new Matrix();\n    options.orientation.clone().scale(Math.PI * 0.5).cross(Vector3.Up()).toQuaternion().toRotationMatrix(m);\n    const v = Vector3.Zero();\n    for (let i = 0; i < vertices.length; i += 3) {\n      v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\n      Vector3.TransformCoordinatesToRef(v.clone(), m, v);\n      vertices[i] = v.x;\n      vertices[i + 1] = v.y;\n      vertices[i + 2] = v.z;\n    }\n  }\n  const vDat = new VertexData();\n  vDat.positions = vertices;\n  vDat.normals = normals;\n  vDat.uvs = uvs;\n  vDat.indices = indices;\n  return vDat;\n}\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh\n * @param options The constructors options.\n * @param scene The scene the mesh is scoped to.\n * @returns Capsule Mesh\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function CreateCapsule(name, options = {\n  orientation: Vector3.Up(),\n  subdivisions: 2,\n  tessellation: 16,\n  height: 1,\n  radius: 0.25,\n  capSubdivisions: 6,\n  updatable: false\n}, scene = null) {\n  const capsule = new Mesh(name, scene);\n  const vertexData = CreateCapsuleVertexData(options);\n  vertexData.applyToMesh(capsule, options.updatable);\n  return capsule;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateCapsule directly\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const CapsuleBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateCapsule\n};\n/**\n * Creates a capsule or a pill mesh\n * @param name defines the name of the mesh.\n * @param options the constructors options used to shape the mesh.\n * @param scene defines the scene the mesh is scoped to.\n * @returns the capsule mesh\n * @see https://doc.babylonjs.com/how_to/capsule_shape\n */\nMesh.CreateCapsule = (name, options, scene) => {\n  return CreateCapsule(name, options, scene);\n};\nVertexData.CreateCapsule = CreateCapsuleVertexData;","map":{"version":3,"mappings":"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","names":["VertexData","Vector2","Vector3","Matrix","Mesh","CompatibilityOptions","CreateCapsuleVertexData","options","subdivisions","tessellation","height","radius","capSubdivisions","Math","max","capDetail","radialSegments","heightSegments","radiusTop","radiusBottom","heightMinusCaps","thetaStart","thetaLength","PI","capsTopSegments","topCapSubdivisions","capsBottomSegments","bottomCapSubdivisions","alpha","acos","indices","vertices","normals","uvs","index","indexArray","halfHeight","pi2","x","y","normal","Zero","vertex","cosAlpha","cos","sinAlpha","sin","coneLength","subtract","length","vl","v","indexRow","a","cosA","sinA","_radius","u","theta","sinTheta","cosTheta","z","push","set","UseOpenGLOrientationForUV","coneHeight","slope","normalize","i1","i2","i3","i4","reverse","orientation","equals","Up","m","clone","scale","cross","toQuaternion","toRotationMatrix","i","TransformCoordinatesToRef","vDat","positions","CreateCapsule","name","updatable","scene","capsule","vertexData","applyToMesh","CapsuleBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/capsuleBuilder.ts"],"sourcesContent":["import { VertexData } from \"../mesh.vertexData\";\r\nimport { Vector2, Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n/**\r\n * Scripts based off of https://github.com/maximeq/three-js-capsule-geometry/blob/master/src/CapsuleBufferGeometry.js\r\n * @param options the constructors options used to shape the mesh.\r\n * @returns the capsule VertexData\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/capsule\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsuleVertexData(\r\n    options: ICreateCapsuleOptions = {\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n    }\r\n): VertexData {\r\n    const subdivisions = Math.max(options.subdivisions ? options.subdivisions : 2, 1);\r\n    const tessellation = Math.max(options.tessellation ? options.tessellation : 16, 3);\r\n    const height = Math.max(options.height ? options.height : 1, 0);\r\n    const radius = Math.max(options.radius ? options.radius : 0.25, 0);\r\n    const capDetail = Math.max(options.capSubdivisions ? options.capSubdivisions : 6, 1);\r\n\r\n    const radialSegments = tessellation;\r\n    const heightSegments = subdivisions;\r\n\r\n    const radiusTop = Math.max(options.radiusTop ? options.radiusTop : radius, 0);\r\n    const radiusBottom = Math.max(options.radiusBottom ? options.radiusBottom : radius, 0);\r\n\r\n    const heightMinusCaps = height - (radiusTop + radiusBottom);\r\n\r\n    const thetaStart = 0.0;\r\n    const thetaLength = 2.0 * Math.PI;\r\n\r\n    const capsTopSegments = Math.max(options.topCapSubdivisions ? options.topCapSubdivisions : capDetail, 1);\r\n    const capsBottomSegments = Math.max(options.bottomCapSubdivisions ? options.bottomCapSubdivisions : capDetail, 1);\r\n\r\n    const alpha = Math.acos((radiusBottom - radiusTop) / height);\r\n\r\n    let indices = [];\r\n    const vertices = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    let index = 0;\r\n    const indexArray = [],\r\n        halfHeight = heightMinusCaps * 0.5;\r\n    const pi2 = Math.PI * 0.5;\r\n\r\n    let x, y;\r\n    const normal = Vector3.Zero();\r\n    const vertex = Vector3.Zero();\r\n\r\n    const cosAlpha = Math.cos(alpha);\r\n    const sinAlpha = Math.sin(alpha);\r\n\r\n    const coneLength = new Vector2(radiusTop * sinAlpha, halfHeight + radiusTop * cosAlpha)\r\n        .subtract(new Vector2(radiusBottom * sinAlpha, -halfHeight + radiusBottom * cosAlpha))\r\n        .length();\r\n\r\n    // Total length for v texture coord\r\n    const vl = radiusTop * alpha + coneLength + radiusBottom * (pi2 - alpha);\r\n\r\n    let v = 0;\r\n    for (y = 0; y <= capsTopSegments; y++) {\r\n        const indexRow = [];\r\n\r\n        const a = pi2 - alpha * (y / capsTopSegments);\r\n\r\n        v += (radiusTop * alpha) / capsTopSegments;\r\n\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusTop;\r\n\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + sinA * radiusTop;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    const coneHeight = height - radiusTop - radiusBottom + cosAlpha * radiusTop - cosAlpha * radiusBottom;\r\n    const slope = (sinAlpha * (radiusBottom - radiusTop)) / coneHeight;\r\n\r\n    for (y = 1; y <= heightSegments; y++) {\r\n        const indexRow = [];\r\n        v += coneLength / heightSegments;\r\n        // calculate the radius of the current row\r\n        const _radius = sinAlpha * ((y * (radiusBottom - radiusTop)) / heightSegments + radiusTop);\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = halfHeight + cosAlpha * radiusTop - (y * coneHeight) / heightSegments;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(sinTheta, slope, cosTheta).normalize();\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n\r\n    for (y = 1; y <= capsBottomSegments; y++) {\r\n        const indexRow = [];\r\n        const a = pi2 - alpha - (Math.PI - alpha) * (y / capsBottomSegments);\r\n        v += (radiusBottom * alpha) / capsBottomSegments;\r\n        const cosA = Math.cos(a);\r\n        const sinA = Math.sin(a);\r\n        // calculate the radius of the current row\r\n        const _radius = cosA * radiusBottom;\r\n        for (x = 0; x <= radialSegments; x++) {\r\n            const u = x / radialSegments;\r\n            const theta = u * thetaLength + thetaStart;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n            // vertex\r\n            vertex.x = _radius * sinTheta;\r\n            vertex.y = -halfHeight + sinA * radiusBottom;\r\n            vertex.z = _radius * cosTheta;\r\n            vertices.push(vertex.x, vertex.y, vertex.z);\r\n            // normal\r\n            normal.set(cosA * sinTheta, sinA, cosA * cosTheta);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            // uv\r\n            uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? v / vl : 1 - v / vl);\r\n            // save index of vertex in respective row\r\n            indexRow.push(index);\r\n            // increase index\r\n            index++;\r\n        }\r\n        // now save vertices of the row in our index array\r\n        indexArray.push(indexRow);\r\n    }\r\n    // generate indices\r\n    for (x = 0; x < radialSegments; x++) {\r\n        for (y = 0; y < capsTopSegments + heightSegments + capsBottomSegments; y++) {\r\n            // we use the index array to access the correct indices\r\n            const i1 = indexArray[y][x];\r\n            const i2 = indexArray[y + 1][x];\r\n            const i3 = indexArray[y + 1][x + 1];\r\n            const i4 = indexArray[y][x + 1];\r\n            // face one\r\n            indices.push(i1);\r\n            indices.push(i2);\r\n            indices.push(i4);\r\n            // face two\r\n            indices.push(i2);\r\n            indices.push(i3);\r\n            indices.push(i4);\r\n        }\r\n    }\r\n\r\n    indices = indices.reverse();\r\n\r\n    if (options.orientation && !options.orientation.equals(Vector3.Up())) {\r\n        const m = new Matrix();\r\n        options.orientation\r\n            .clone()\r\n            .scale(Math.PI * 0.5)\r\n            .cross(Vector3.Up())\r\n            .toQuaternion()\r\n            .toRotationMatrix(m);\r\n        const v = Vector3.Zero();\r\n        for (let i = 0; i < vertices.length; i += 3) {\r\n            v.set(vertices[i], vertices[i + 1], vertices[i + 2]);\r\n            Vector3.TransformCoordinatesToRef(v.clone(), m, v);\r\n            vertices[i] = v.x;\r\n            vertices[i + 1] = v.y;\r\n            vertices[i + 2] = v.z;\r\n        }\r\n    }\r\n\r\n    const vDat = new VertexData();\r\n    vDat.positions = vertices;\r\n    vDat.normals = normals;\r\n    vDat.uvs = uvs;\r\n    vDat.indices = indices;\r\n\r\n    return vDat;\r\n}\r\n\r\n/**\r\n * The options Interface for creating a Capsule Mesh\r\n */\r\nexport interface ICreateCapsuleOptions {\r\n    /** The Orientation of the capsule.  Default : Vector3.Up() */\r\n    orientation?: Vector3;\r\n\r\n    /** Number of sub segments on the tube section of the capsule running parallel to orientation. */\r\n    subdivisions?: number;\r\n\r\n    /** Number of cylindrical segments on the capsule. */\r\n    tessellation?: number;\r\n\r\n    /** Height or Length of the capsule. */\r\n    height?: number;\r\n\r\n    /** Radius of the capsule. */\r\n    radius?: number;\r\n\r\n    /** Number of sub segments on the cap sections of the capsule running parallel to orientation. */\r\n    capSubdivisions?: number;\r\n\r\n    /** Overwrite for the top radius. */\r\n    radiusTop?: number;\r\n\r\n    /** Overwrite for the bottom radius. */\r\n    radiusBottom?: number;\r\n\r\n    /** Overwrite for the top capSubdivisions. */\r\n    topCapSubdivisions?: number;\r\n\r\n    /** Overwrite for the bottom capSubdivisions. */\r\n    bottomCapSubdivisions?: number;\r\n\r\n    /** Internal geometry is supposed to change once created. */\r\n    updatable?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh\r\n * @param options The constructors options.\r\n * @param scene The scene the mesh is scoped to.\r\n * @returns Capsule Mesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateCapsule(\r\n    name: string,\r\n    options: ICreateCapsuleOptions = {\r\n        orientation: Vector3.Up(),\r\n        subdivisions: 2,\r\n        tessellation: 16,\r\n        height: 1,\r\n        radius: 0.25,\r\n        capSubdivisions: 6,\r\n        updatable: false,\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const capsule = new Mesh(name, scene);\r\n    const vertexData = CreateCapsuleVertexData(options);\r\n    vertexData.applyToMesh(capsule, options.updatable);\r\n    return capsule;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateCapsule directly\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const CapsuleBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateCapsule,\r\n};\r\n\r\n/**\r\n * Creates a capsule or a pill mesh\r\n * @param name defines the name of the mesh.\r\n * @param options the constructors options used to shape the mesh.\r\n * @param scene defines the scene the mesh is scoped to.\r\n * @returns the capsule mesh\r\n * @see https://doc.babylonjs.com/how_to/capsule_shape\r\n */\r\n(Mesh as any).CreateCapsule = (name: string, options: ICreateCapsuleOptions, scene?: Nullable<Scene>): Mesh => {\r\n    return CreateCapsule(name, options, scene);\r\n};\r\n\r\nVertexData.CreateCapsule = CreateCapsuleVertexData;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}