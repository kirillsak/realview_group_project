{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { SerializationHelper, serialize } from \"../Misc/decorators.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { TextureSampler } from \"../Materials/Textures/textureSampler.js\";\n/**\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\n */\nexport class ComputeShader {\n  /**\n   * Instantiates a new compute shader.\n   * @param name Defines the name of the compute shader in the scene\n   * @param engine Defines the engine the compute shader belongs to\n   * @param shaderPath Defines  the route to the shader code in one of three ways:\n   *  * object: { compute: \"custom\" }, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\n   *  * object: { computeElement: \"HTMLElementId\" }, used with shader code in script tags\n   *  * object: { computeSource: \"compute shader code string\" using with string containing the shader code\n   *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\n   * @param options Define the options used to create the shader\n   */\n  constructor(name, engine, shaderPath, options = {}) {\n    this._bindings = {};\n    this._samplers = {};\n    this._contextIsDirty = false;\n    /**\n     * Callback triggered when the shader is compiled\n     */\n    this.onCompiled = null;\n    /**\n     * Callback triggered when an error occurs\n     */\n    this.onError = null;\n    this.name = name;\n    this._engine = engine;\n    this.uniqueId = UniqueIdGenerator.UniqueId;\n    if (!this._engine.getCaps().supportComputeShaders) {\n      Logger.Error(\"This engine does not support compute shaders!\");\n      return;\n    }\n    if (!options.bindingsMapping) {\n      Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\n      return;\n    }\n    this._context = engine.createComputeContext();\n    this._shaderPath = shaderPath;\n    this._options = {\n      bindingsMapping: {},\n      defines: [],\n      ...options\n    };\n  }\n  /**\n   * The options used to create the shader\n   */\n  get options() {\n    return this._options;\n  }\n  /**\n   * The shaderPath used to create the shader\n   */\n  get shaderPath() {\n    return this._shaderPath;\n  }\n  /**\n   * Gets the current class name of the material e.g. \"ComputeShader\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ComputeShader\";\n  }\n  /**\n   * Binds a texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\n   */\n  setTexture(name, texture, bindSampler = true) {\n    const current = this._bindings[name];\n    this._bindings[name] = {\n      type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture || current.type !== this._bindings[name].type);\n  }\n  /**\n   * Binds a storage texture to the shader\n   * @param name Binding name of the texture\n   * @param texture Texture to bind\n   */\n  setStorageTexture(name, texture) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== texture);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageTexture,\n      object: texture,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a uniform buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n  setUniformBuffer(name, buffer) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeBindingType.UniformBuffer,\n      object: buffer,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a storage buffer to the shader\n   * @param name Binding name of the buffer\n   * @param buffer Buffer to bind\n   */\n  setStorageBuffer(name, buffer) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || current.object !== buffer);\n    this._bindings[name] = {\n      type: ComputeBindingType.StorageBuffer,\n      object: buffer,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Binds a texture sampler to the shader\n   * @param name Binding name of the sampler\n   * @param sampler Sampler to bind\n   */\n  setTextureSampler(name, sampler) {\n    const current = this._bindings[name];\n    this._contextIsDirty || (this._contextIsDirty = !current || !sampler.compareSampler(current.object));\n    this._bindings[name] = {\n      type: ComputeBindingType.Sampler,\n      object: sampler,\n      indexInGroupEntries: current === null || current === void 0 ? void 0 : current.indexInGroupEntries\n    };\n  }\n  /**\n   * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\n   * @returns true if the compute shader is ready to be executed\n   */\n  isReady() {\n    let effect = this._effect;\n    for (const key in this._bindings) {\n      const binding = this._bindings[key],\n        type = binding.type,\n        object = binding.object;\n      switch (type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            const texture = object;\n            if (!texture.isReady()) {\n              return false;\n            }\n            break;\n          }\n      }\n    }\n    const defines = [];\n    const shaderName = this._shaderPath;\n    if (this._options.defines) {\n      for (let index = 0; index < this._options.defines.length; index++) {\n        defines.push(this._options.defines[index]);\n      }\n    }\n    const join = defines.join(\"\\n\");\n    if (this._cachedDefines !== join) {\n      this._cachedDefines = join;\n      effect = this._engine.createComputeEffect(shaderName, {\n        defines: join,\n        entryPoint: this._options.entryPoint,\n        onCompiled: this.onCompiled,\n        onError: this.onError\n      });\n      this._effect = effect;\n    }\n    if (!effect.isReady()) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Dispatches (executes) the compute shader\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\n   */\n  dispatch(x, y, z) {\n    var _a;\n    if (!this.isReady()) {\n      return false;\n    }\n    // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\n    for (const key in this._bindings) {\n      const binding = this._bindings[key];\n      // TODO: remove this when browsers support reflection for wgsl shaders\n      if (!this._options.bindingsMapping[key]) {\n        throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\n      }\n      if (binding.type !== ComputeBindingType.Texture) {\n        continue;\n      }\n      const sampler = this._samplers[key];\n      const texture = binding.object;\n      if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\n        this._samplers[key] = new TextureSampler().setParameters(texture.wrapU, texture.wrapV, texture.wrapR, texture.anisotropicFilteringLevel, texture._texture.samplingMode, (_a = texture._texture) === null || _a === void 0 ? void 0 : _a._comparisonFunction);\n        this._contextIsDirty = true;\n      }\n    }\n    if (this._contextIsDirty) {\n      this._contextIsDirty = false;\n      this._context.clear();\n    }\n    this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\n    return true;\n  }\n  /**\n   * Waits for the compute shader to be ready and executes it\n   * @param x Number of workgroups to execute on the X dimension\n   * @param y Number of workgroups to execute on the Y dimension (default: 1)\n   * @param z Number of workgroups to execute on the Z dimension (default: 1)\n   * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\n   * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\n   */\n  dispatchWhenReady(x, y, z, delay = 10) {\n    return new Promise(resolve => {\n      const check = () => {\n        if (!this.dispatch(x, y, z)) {\n          setTimeout(check, delay);\n        } else {\n          resolve();\n        }\n      };\n      check();\n    });\n  }\n  /**\n   * Serializes this compute shader in a JSON representation\n   * @returns the serialized compute shader object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.options = this._options;\n    serializationObject.shaderPath = this._shaderPath;\n    serializationObject.bindings = {};\n    serializationObject.textures = {};\n    for (const key in this._bindings) {\n      const binding = this._bindings[key];\n      const object = binding.object;\n      switch (binding.type) {\n        case ComputeBindingType.Texture:\n        case ComputeBindingType.TextureWithoutSampler:\n        case ComputeBindingType.StorageTexture:\n          {\n            const serializedData = object.serialize();\n            if (serializedData) {\n              serializationObject.textures[key] = serializedData;\n              serializationObject.bindings[key] = {\n                type: binding.type\n              };\n            }\n            break;\n          }\n        case ComputeBindingType.UniformBuffer:\n          {\n            break;\n          }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a compute shader from parsed compute shader data\n   * @param source defines the JSON representation of the compute shader\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new compute shader\n   */\n  static Parse(source, scene, rootUrl) {\n    const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\n    for (const key in source.textures) {\n      const binding = source.bindings[key];\n      const texture = Texture.Parse(source.textures[key], scene, rootUrl);\n      if (binding.type === ComputeBindingType.Texture) {\n        compute.setTexture(key, texture);\n      } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\n        compute.setTexture(key, texture, false);\n      } else {\n        compute.setStorageTexture(key, texture);\n      }\n    }\n    return compute;\n  }\n}\n__decorate([serialize()], ComputeShader.prototype, \"name\", void 0);\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);","map":{"version":3,"mappings":"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","names":["SerializationHelper","serialize","RegisterClass","ComputeBindingType","Texture","UniqueIdGenerator","Logger","TextureSampler","ComputeShader","constructor","name","engine","shaderPath","options","_engine","uniqueId","UniqueId","getCaps","supportComputeShaders","Error","bindingsMapping","_context","createComputeContext","_shaderPath","_options","defines","getClassName","setTexture","texture","bindSampler","current","_bindings","type","TextureWithoutSampler","object","indexInGroupEntries","_contextIsDirty","setStorageTexture","StorageTexture","setUniformBuffer","buffer","UniformBuffer","setStorageBuffer","StorageBuffer","setTextureSampler","sampler","compareSampler","Sampler","isReady","effect","_effect","key","binding","shaderName","index","length","push","join","_cachedDefines","createComputeEffect","entryPoint","onCompiled","onError","dispatch","x","y","z","_samplers","_texture","setParameters","wrapU","wrapV","wrapR","anisotropicFilteringLevel","samplingMode","_comparisonFunction","clear","computeDispatch","dispatchWhenReady","delay","Promise","resolve","check","setTimeout","serializationObject","Serialize","bindings","textures","serializedData","Parse","source","scene","rootUrl","compute","getEngine","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Compute/computeShader.ts"],"sourcesContent":["import type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SerializationHelper, serialize } from \"../Misc/decorators\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { ComputeEffect, IComputeEffectCreationOptions } from \"./computeEffect\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Engines/Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Engines/Extensions/engine.computeShader\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { UniqueIdGenerator } from \"../Misc/uniqueIdGenerator\";\r\nimport type { IComputeContext } from \"./IComputeContext\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { TextureSampler } from \"../Materials/Textures/textureSampler\";\r\n\r\n/**\r\n * Defines the options associated with the creation of a compute shader.\r\n */\r\nexport interface IComputeShaderOptions {\r\n    /**\r\n     * list of bindings mapping (key is property name, value is binding location)\r\n     * Must be provided because browsers don't support reflection for wgsl shaders yet (so there's no way to query the binding/group from a variable name)\r\n     * TODO: remove this when browsers support reflection for wgsl shaders\r\n     */\r\n    bindingsMapping: ComputeBindingMapping;\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines?: string[];\r\n\r\n    /**\r\n     * The name of the entry point in the shader source (default: \"main\")\r\n     */\r\n    entryPoint?: string;\r\n\r\n    /**\r\n     * If provided, will be called with the shader code so that this code can be updated before it is compiled by the GPU\r\n     */\r\n    processFinalCode?: Nullable<(code: string) => string>;\r\n}\r\n\r\n/**\r\n * The ComputeShader object lets you execute a compute shader on your GPU (if supported by the engine)\r\n */\r\nexport class ComputeShader {\r\n    private _engine: ThinEngine;\r\n    private _shaderPath: any;\r\n    private _options: IComputeShaderOptions;\r\n    private _effect: ComputeEffect;\r\n    private _cachedDefines: string;\r\n    private _bindings: ComputeBindingList = {};\r\n    private _samplers: { [key: string]: TextureSampler } = {};\r\n    private _context: IComputeContext;\r\n    private _contextIsDirty = false;\r\n\r\n    /**\r\n     * Gets the unique id of the compute shader\r\n     */\r\n    public readonly uniqueId: number;\r\n\r\n    /**\r\n     * The name of the shader\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * The options used to create the shader\r\n     */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * The shaderPath used to create the shader\r\n     */\r\n    public get shaderPath() {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Callback triggered when the shader is compiled\r\n     */\r\n    public onCompiled: Nullable<(effect: ComputeEffect) => void> = null;\r\n\r\n    /**\r\n     * Callback triggered when an error occurs\r\n     */\r\n    public onError: Nullable<(effect: ComputeEffect, errors: string) => void> = null;\r\n\r\n    /**\r\n     * Instantiates a new compute shader.\r\n     * @param name Defines the name of the compute shader in the scene\r\n     * @param engine Defines the engine the compute shader belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: { compute: \"custom\" }, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: { computeElement: \"HTMLElementId\" }, used with shader code in script tags\r\n     *  * object: { computeSource: \"compute shader code string\" using with string containing the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, engine: ThinEngine, shaderPath: any, options: Partial<IComputeShaderOptions> = {}) {\r\n        this.name = name;\r\n        this._engine = engine;\r\n        this.uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n        if (!this._engine.getCaps().supportComputeShaders) {\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n        if (!options.bindingsMapping) {\r\n            Logger.Error(\"You must provide the binding mappings as browsers don't support reflection for wgsl shaders yet!\");\r\n            return;\r\n        }\r\n\r\n        this._context = engine.createComputeContext()!;\r\n        this._shaderPath = shaderPath;\r\n        this._options = {\r\n            bindingsMapping: {},\r\n            defines: [],\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ComputeShader\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ComputeShader\";\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._bindings[name] = {\r\n            type: bindSampler ? ComputeBindingType.Texture : ComputeBindingType.TextureWithoutSampler,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture || current.type !== this._bindings[name].type;\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== texture;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageTexture,\r\n            object: texture,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.UniformBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || current.object !== buffer;\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.StorageBuffer,\r\n            object: buffer,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        const current = this._bindings[name];\r\n\r\n        this._contextIsDirty ||= !current || !sampler.compareSampler(current.object);\r\n\r\n        this._bindings[name] = {\r\n            type: ComputeBindingType.Sampler,\r\n            object: sampler,\r\n            indexInGroupEntries: current?.indexInGroupEntries,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Specifies that the compute shader is ready to be executed (the compute effect and all the resources are ready)\r\n     * @returns true if the compute shader is ready to be executed\r\n     */\r\n    public isReady(): boolean {\r\n        let effect = this._effect;\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key],\r\n                type = binding.type,\r\n                object = binding.object;\r\n\r\n            switch (type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const texture = object as BaseTexture;\r\n                    if (!texture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const shaderName = this._shaderPath;\r\n\r\n        if (this._options.defines) {\r\n            for (let index = 0; index < this._options.defines.length; index++) {\r\n                defines.push(this._options.defines[index]);\r\n            }\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (this._cachedDefines !== join) {\r\n            this._cachedDefines = join;\r\n\r\n            effect = this._engine.createComputeEffect(shaderName, <IComputeEffectCreationOptions>{\r\n                defines: join,\r\n                entryPoint: this._options.entryPoint,\r\n                onCompiled: this.onCompiled,\r\n                onError: this.onError,\r\n            });\r\n\r\n            this._effect = effect;\r\n        }\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispatches (executes) the compute shader\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @returns True if the dispatch could be done, else false (meaning either the compute effect or at least one of the bound resources was not ready)\r\n     */\r\n    public dispatch(x: number, y?: number, z?: number): boolean {\r\n        if (!this.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        // If the sampling parameters of a texture bound to the shader have changed, we must clear the compute context so that it is recreated with the updated values\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n\r\n            // TODO: remove this when browsers support reflection for wgsl shaders\r\n            if (!this._options.bindingsMapping[key]) {\r\n                throw new Error(\"ComputeShader ('\" + this.name + \"'): No binding mapping has been provided for the property '\" + key + \"'\");\r\n            }\r\n\r\n            if (binding.type !== ComputeBindingType.Texture) {\r\n                continue;\r\n            }\r\n\r\n            const sampler = this._samplers[key];\r\n            const texture = binding.object as BaseTexture;\r\n\r\n            if (!sampler || !texture._texture || !sampler.compareSampler(texture._texture)) {\r\n                this._samplers[key] = new TextureSampler().setParameters(\r\n                    texture.wrapU,\r\n                    texture.wrapV,\r\n                    texture.wrapR,\r\n                    texture.anisotropicFilteringLevel,\r\n                    texture._texture!.samplingMode,\r\n                    texture._texture?._comparisonFunction\r\n                );\r\n                this._contextIsDirty = true;\r\n            }\r\n        }\r\n\r\n        if (this._contextIsDirty) {\r\n            this._contextIsDirty = false;\r\n            this._context.clear();\r\n        }\r\n\r\n        this._engine.computeDispatch(this._effect, this._context, this._bindings, x, y, z, this._options.bindingsMapping);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Waits for the compute shader to be ready and executes it\r\n     * @param x Number of workgroups to execute on the X dimension\r\n     * @param y Number of workgroups to execute on the Y dimension (default: 1)\r\n     * @param z Number of workgroups to execute on the Z dimension (default: 1)\r\n     * @param delay Delay between the retries while the shader is not ready (in milliseconds - 10 by default)\r\n     * @returns A promise that is resolved once the shader has been sent to the GPU. Note that it does not mean that the shader execution itself is finished!\r\n     */\r\n    public dispatchWhenReady(x: number, y?: number, z?: number, delay = 10): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            const check = () => {\r\n                if (!this.dispatch(x, y, z)) {\r\n                    setTimeout(check, delay);\r\n                } else {\r\n                    resolve();\r\n                }\r\n            };\r\n\r\n            check();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes this compute shader in a JSON representation\r\n     * @returns the serialized compute shader object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.bindings = {};\r\n        serializationObject.textures = {};\r\n\r\n        for (const key in this._bindings) {\r\n            const binding = this._bindings[key];\r\n            const object = binding.object;\r\n\r\n            switch (binding.type) {\r\n                case ComputeBindingType.Texture:\r\n                case ComputeBindingType.TextureWithoutSampler:\r\n                case ComputeBindingType.StorageTexture: {\r\n                    const serializedData = (object as BaseTexture).serialize();\r\n                    if (serializedData) {\r\n                        serializationObject.textures[key] = serializedData;\r\n                        serializationObject.bindings[key] = {\r\n                            type: binding.type,\r\n                        };\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                case ComputeBindingType.UniformBuffer: {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a compute shader from parsed compute shader data\r\n     * @param source defines the JSON representation of the compute shader\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new compute shader\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ComputeShader {\r\n        const compute = SerializationHelper.Parse(() => new ComputeShader(source.name, scene.getEngine(), source.shaderPath, source.options), source, scene, rootUrl);\r\n\r\n        for (const key in source.textures) {\r\n            const binding = source.bindings[key];\r\n            const texture = <Texture>Texture.Parse(source.textures[key], scene, rootUrl);\r\n\r\n            if (binding.type === ComputeBindingType.Texture) {\r\n                compute.setTexture(key, texture);\r\n            } else if (binding.type === ComputeBindingType.TextureWithoutSampler) {\r\n                compute.setTexture(key, texture, false);\r\n            } else {\r\n                compute.setStorageTexture(key, texture);\r\n            }\r\n        }\r\n\r\n        return compute;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ComputeShader\", ComputeShader);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}