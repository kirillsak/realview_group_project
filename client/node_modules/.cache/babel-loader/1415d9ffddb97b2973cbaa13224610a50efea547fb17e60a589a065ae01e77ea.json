{"ast":null,"code":"import { Vector3, Quaternion } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Gizmo } from \"./gizmo.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { DirectionalLight } from \"../Lights/directionalLight.js\";\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder.js\";\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder.js\";\nimport { SpotLight } from \"../Lights/spotLight.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder.js\";\n/**\n * Gizmo that enables viewing a light\n */\nexport class LightGizmo extends Gizmo {\n  /**\n   * Creates a LightGizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor(gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    super(gizmoLayer);\n    this._cachedPosition = new Vector3();\n    this._cachedForward = new Vector3(0, 0, 1);\n    this._pointerObserver = null;\n    /**\n     * Event that fires each time the gizmo is clicked\n     */\n    this.onClickedObservable = new Observable();\n    this._light = null;\n    this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\n    this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\n    this.attachedMesh.parent = this._attachedMeshParent;\n    this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\n    this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\n    this._material.specularColor = new Color3(0.1, 0.1, 0.1);\n    this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      if (!this._light) {\n        return;\n      }\n      this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(pointerInfo.pickInfo.pickedMesh) != -1);\n      if (this._isHovered && pointerInfo.event.button === 0) {\n        this.onClickedObservable.notifyObservers(this._light);\n      }\n    }, PointerEventTypes.POINTERDOWN);\n  }\n  /**\n   * Override attachedNode because lightgizmo only support attached mesh\n   * It will return the attached mesh (if any) and setting an attached node will log\n   * a warning\n   */\n  get attachedNode() {\n    return this.attachedMesh;\n  }\n  set attachedNode(value) {\n    console.warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\n  }\n  /**\n   * The light that the gizmo is attached to\n   */\n  set light(light) {\n    this._light = light;\n    if (light) {\n      // Create the mesh for the given light type\n      if (this._lightMesh) {\n        this._lightMesh.dispose();\n      }\n      if (light instanceof HemisphericLight) {\n        this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else if (light instanceof DirectionalLight) {\n        this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else if (light instanceof SpotLight) {\n        this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\n      } else {\n        this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\n      }\n      this._lightMesh.getChildMeshes(false).forEach(m => {\n        m.material = this._material;\n      });\n      this._lightMesh.parent = this._rootMesh;\n      // Add lighting to the light gizmo\n      const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\n      gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\n      this._lightMesh.rotationQuaternion = new Quaternion();\n      if (!this.attachedMesh.reservedDataStore) {\n        this.attachedMesh.reservedDataStore = {};\n      }\n      this.attachedMesh.reservedDataStore.lightGizmo = this;\n      if (light.parent) {\n        this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\n      }\n      // Get update position and direction if the light has it\n      if (light.position) {\n        this.attachedMesh.position.copyFrom(light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n      if (light.direction) {\n        this.attachedMesh.setDirection(light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      }\n      this._update();\n    }\n  }\n  get light() {\n    return this._light;\n  }\n  /**\n   * Gets the material used to render the light gizmo\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   * @internal\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    super._update();\n    if (!this._light) {\n      return;\n    }\n    if (this._light.parent) {\n      this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\n    }\n    // For light position and direction, a dirty flag is set to true in the setter\n    // It means setting values individually or copying values will not call setter and\n    // dirty flag will not be set to true. Hence creating a new Vector3.\n    if (this._light.position) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (!this.attachedMesh.position.equals(this._cachedPosition)) {\n        // update light to match gizmo\n        const position = this.attachedMesh.position;\n        this._light.position = new Vector3(position.x, position.y, position.z);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      } else {\n        // update gizmo to match light\n        this.attachedMesh.position.copyFrom(this._light.position);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedPosition.copyFrom(this.attachedMesh.position);\n      }\n    }\n    if (this._light.direction) {\n      // If the gizmo is moved update the light otherwise update the gizmo to match the light\n      if (Vector3.DistanceSquared(this.attachedMesh.forward, this._cachedForward) > 0.0001) {\n        // update light to match gizmo\n        const direction = this.attachedMesh.forward;\n        this._light.direction = new Vector3(direction.x, direction.y, direction.z);\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      } else if (Vector3.DistanceSquared(this.attachedMesh.forward, this._light.direction) > 0.0001) {\n        // update gizmo to match light\n        this.attachedMesh.setDirection(this._light.direction);\n        this.attachedMesh.computeWorldMatrix(true);\n        this._cachedForward.copyFrom(this.attachedMesh.forward);\n      }\n    }\n  }\n  /**\n   * Disposes of the light gizmo\n   */\n  dispose() {\n    this.onClickedObservable.clear();\n    this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\n    this._material.dispose();\n    super.dispose();\n    this._attachedMeshParent.dispose();\n  }\n  static _CreateHemisphericLightMesh(scene) {\n    const root = new Mesh(\"hemisphereLight\", scene);\n    const hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    hemisphere.position.z = -0.15;\n    hemisphere.rotation.x = Math.PI / 2;\n    hemisphere.parent = root;\n    const lines = this._CreateLightLines(3, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreatePointLightMesh(scene) {\n    const root = new Mesh(\"pointLight\", scene);\n    const sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.rotation.x = Math.PI / 2;\n    sphere.parent = root;\n    const lines = this._CreateLightLines(5, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreateSpotLightMesh(scene) {\n    const root = new Mesh(\"spotLight\", scene);\n    const sphere = CreateSphere(root.name, {\n      segments: 10,\n      diameter: 1\n    }, scene);\n    sphere.parent = root;\n    const hemisphere = CreateHemisphere(root.name, {\n      segments: 10,\n      diameter: 2\n    }, scene);\n    hemisphere.parent = root;\n    hemisphere.rotation.x = -Math.PI / 2;\n    const lines = this._CreateLightLines(2, scene);\n    lines.parent = root;\n    root.scaling.scaleInPlace(LightGizmo._Scale);\n    root.rotation.x = Math.PI / 2;\n    return root;\n  }\n  static _CreateDirectionalLightMesh(scene) {\n    const root = new Mesh(\"directionalLight\", scene);\n    const mesh = new Mesh(root.name, scene);\n    mesh.parent = root;\n    const sphere = CreateSphere(root.name, {\n      diameter: 1.2,\n      segments: 10\n    }, scene);\n    sphere.parent = mesh;\n    const line = CreateCylinder(root.name, {\n      updatable: false,\n      height: 6,\n      diameterTop: 0.3,\n      diameterBottom: 0.3,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    line.parent = mesh;\n    let left = line.clone(root.name);\n    left.scaling.y = 0.5;\n    left.position.x += 1.25;\n    let right = line.clone(root.name);\n    right.scaling.y = 0.5;\n    right.position.x += -1.25;\n    const arrowHead = CreateCylinder(root.name, {\n      updatable: false,\n      height: 1,\n      diameterTop: 0,\n      diameterBottom: 0.6,\n      tessellation: 6,\n      subdivisions: 1\n    }, scene);\n    arrowHead.position.y += 3;\n    arrowHead.parent = mesh;\n    left = arrowHead.clone(root.name);\n    left.position.y = 1.5;\n    left.position.x += 1.25;\n    right = arrowHead.clone(root.name);\n    right.position.y = 1.5;\n    right.position.x += -1.25;\n    mesh.scaling.scaleInPlace(LightGizmo._Scale);\n    mesh.rotation.z = Math.PI / 2;\n    mesh.rotation.y = Math.PI / 2;\n    return root;\n  }\n}\n// Static helper methods\nLightGizmo._Scale = 0.007;\n/**\n * Creates the lines for a light mesh\n * @param levels\n * @param scene\n */\nLightGizmo._CreateLightLines = (levels, scene) => {\n  const distFromSphere = 1.2;\n  const root = new Mesh(\"root\", scene);\n  root.rotation.x = Math.PI / 2;\n  // Create the top line, this will be cloned for all other lines\n  const linePivot = new Mesh(\"linePivot\", scene);\n  linePivot.parent = root;\n  const line = CreateCylinder(\"line\", {\n    updatable: false,\n    height: 2,\n    diameterTop: 0.2,\n    diameterBottom: 0.3,\n    tessellation: 6,\n    subdivisions: 1\n  }, scene);\n  line.position.y = line.scaling.y / 2 + distFromSphere;\n  line.parent = linePivot;\n  if (levels < 2) {\n    return linePivot;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"lineParentClone\");\n    l.rotation.z = Math.PI / 4;\n    l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n    l.getChildMeshes()[0].scaling.y = 0.5;\n    l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n    l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n  }\n  if (levels < 3) {\n    return root;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI / 2;\n    l.rotation.y = Math.PI / 2 * i;\n  }\n  if (levels < 4) {\n    return root;\n  }\n  for (let i = 0; i < 4; i++) {\n    const l = linePivot.clone(\"linePivotClone\");\n    l.rotation.z = Math.PI + Math.PI / 4;\n    l.rotation.y = Math.PI / 2 + Math.PI / 2 * i;\n    l.getChildMeshes()[0].scaling.y = 0.5;\n    l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\n    l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\n  }\n  if (levels < 5) {\n    return root;\n  }\n  const l = linePivot.clone(\"linePivotClone\");\n  l.rotation.z = Math.PI;\n  return root;\n};","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Color3","AbstractMesh","Mesh","Gizmo","UtilityLayerRenderer","StandardMaterial","HemisphericLight","DirectionalLight","CreateSphere","CreateHemisphere","SpotLight","TransformNode","PointerEventTypes","Observable","CreateCylinder","LightGizmo","constructor","gizmoLayer","DefaultUtilityLayer","attachedMesh","utilityLayerScene","_attachedMeshParent","parent","_material","diffuseColor","specularColor","_pointerObserver","onPointerObservable","add","pointerInfo","_light","_isHovered","pickInfo","_rootMesh","getChildMeshes","indexOf","pickedMesh","event","button","onClickedObservable","notifyObservers","POINTERDOWN","attachedNode","value","console","warn","light","_lightMesh","dispose","_CreateHemisphericLightMesh","_CreateDirectionalLightMesh","_CreateSpotLightMesh","_CreatePointLightMesh","forEach","m","material","gizmoLight","_getSharedGizmoLight","includedOnlyMeshes","concat","rotationQuaternion","reservedDataStore","lightGizmo","freezeWorldMatrix","getWorldMatrix","position","copyFrom","computeWorldMatrix","_cachedPosition","direction","setDirection","_cachedForward","forward","_update","equals","x","y","z","DistanceSquared","clear","remove","scene","root","hemisphere","name","segments","diameter","rotation","Math","PI","lines","_CreateLightLines","scaling","scaleInPlace","_Scale","sphere","mesh","line","updatable","height","diameterTop","diameterBottom","tessellation","subdivisions","left","clone","right","arrowHead","levels","distFromSphere","linePivot","i","l"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/lightGizmo.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Vector3, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { IGizmo } from \"./gizmo\";\r\nimport { Gizmo } from \"./gizmo\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { Node } from \"../node\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { Scene } from \"../scene\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"../Lights/directionalLight\";\r\nimport { CreateSphere } from \"../Meshes/Builders/sphereBuilder\";\r\nimport { CreateHemisphere } from \"../Meshes/Builders/hemisphereBuilder\";\r\nimport { SpotLight } from \"../Lights/spotLight\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { CreateCylinder } from \"../Meshes/Builders/cylinderBuilder\";\r\n\r\n/**\r\n * Interface for light gizmo\r\n */\r\nexport interface ILightGizmo extends IGizmo {\r\n    /** Event that fires each time the gizmo is clicked */\r\n    onClickedObservable: Observable<Light>;\r\n    /** The light that the gizmo is attached to */\r\n    light: Nullable<Light>;\r\n    /** The material used to render the light gizmo */\r\n    readonly material: StandardMaterial;\r\n}\r\n\r\n/**\r\n * Gizmo that enables viewing a light\r\n */\r\nexport class LightGizmo extends Gizmo implements ILightGizmo {\r\n    protected _lightMesh: Mesh;\r\n    protected _material: StandardMaterial;\r\n    protected _cachedPosition = new Vector3();\r\n    protected _cachedForward = new Vector3(0, 0, 1);\r\n    protected _attachedMeshParent: TransformNode;\r\n    protected _pointerObserver: Nullable<Observer<PointerInfo>> = null;\r\n\r\n    /**\r\n     * Event that fires each time the gizmo is clicked\r\n     */\r\n    public onClickedObservable = new Observable<Light>();\r\n\r\n    /**\r\n     * Creates a LightGizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer) {\r\n        super(gizmoLayer);\r\n        this.attachedMesh = new AbstractMesh(\"\", this.gizmoLayer.utilityLayerScene);\r\n        this._attachedMeshParent = new TransformNode(\"parent\", this.gizmoLayer.utilityLayerScene);\r\n\r\n        this.attachedMesh.parent = this._attachedMeshParent;\r\n        this._material = new StandardMaterial(\"light\", this.gizmoLayer.utilityLayerScene);\r\n        this._material.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n        this._material.specularColor = new Color3(0.1, 0.1, 0.1);\r\n\r\n        this._pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (!this._light) {\r\n                return;\r\n            }\r\n\r\n            this._isHovered = !!(pointerInfo.pickInfo && this._rootMesh.getChildMeshes().indexOf(<Mesh>pointerInfo.pickInfo.pickedMesh) != -1);\r\n            if (this._isHovered && pointerInfo.event.button === 0) {\r\n                this.onClickedObservable.notifyObservers(this._light);\r\n            }\r\n        }, PointerEventTypes.POINTERDOWN);\r\n    }\r\n    protected _light: Nullable<Light> = null;\r\n\r\n    /**\r\n     * Override attachedNode because lightgizmo only support attached mesh\r\n     * It will return the attached mesh (if any) and setting an attached node will log\r\n     * a warning\r\n     */\r\n    public get attachedNode() {\r\n        return this.attachedMesh;\r\n    }\r\n    public set attachedNode(value: Nullable<Node>) {\r\n        console.warn(\"Nodes cannot be attached to LightGizmo. Attach to a mesh instead.\");\r\n    }\r\n\r\n    /**\r\n     * The light that the gizmo is attached to\r\n     */\r\n    public set light(light: Nullable<Light>) {\r\n        this._light = light;\r\n        if (light) {\r\n            // Create the mesh for the given light type\r\n            if (this._lightMesh) {\r\n                this._lightMesh.dispose();\r\n            }\r\n\r\n            if (light instanceof HemisphericLight) {\r\n                this._lightMesh = LightGizmo._CreateHemisphericLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof DirectionalLight) {\r\n                this._lightMesh = LightGizmo._CreateDirectionalLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else if (light instanceof SpotLight) {\r\n                this._lightMesh = LightGizmo._CreateSpotLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            } else {\r\n                this._lightMesh = LightGizmo._CreatePointLightMesh(this.gizmoLayer.utilityLayerScene);\r\n            }\r\n            this._lightMesh.getChildMeshes(false).forEach((m) => {\r\n                m.material = this._material;\r\n            });\r\n            this._lightMesh.parent = this._rootMesh;\r\n\r\n            // Add lighting to the light gizmo\r\n            const gizmoLight = this.gizmoLayer._getSharedGizmoLight();\r\n            gizmoLight.includedOnlyMeshes = gizmoLight.includedOnlyMeshes.concat(this._lightMesh.getChildMeshes(false));\r\n\r\n            this._lightMesh.rotationQuaternion = new Quaternion();\r\n\r\n            if (!this.attachedMesh!.reservedDataStore) {\r\n                this.attachedMesh!.reservedDataStore = {};\r\n            }\r\n            this.attachedMesh!.reservedDataStore.lightGizmo = this;\r\n\r\n            if (light.parent) {\r\n                this._attachedMeshParent.freezeWorldMatrix(light.parent.getWorldMatrix());\r\n            }\r\n\r\n            // Get update position and direction if the light has it\r\n            if ((light as any).position) {\r\n                this.attachedMesh!.position.copyFrom((light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n            if ((light as any).direction) {\r\n                this.attachedMesh!.setDirection((light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            }\r\n\r\n            this._update();\r\n        }\r\n    }\r\n    public get light() {\r\n        return this._light;\r\n    }\r\n\r\n    /**\r\n     * Gets the material used to render the light gizmo\r\n     */\r\n    public get material() {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        super._update();\r\n        if (!this._light) {\r\n            return;\r\n        }\r\n\r\n        if (this._light.parent) {\r\n            this._attachedMeshParent.freezeWorldMatrix(this._light.parent.getWorldMatrix());\r\n        }\r\n\r\n        // For light position and direction, a dirty flag is set to true in the setter\r\n        // It means setting values individually or copying values will not call setter and\r\n        // dirty flag will not be set to true. Hence creating a new Vector3.\r\n        if ((this._light as any).position) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (!this.attachedMesh!.position.equals(this._cachedPosition)) {\r\n                // update light to match gizmo\r\n                const position = this.attachedMesh!.position;\r\n                (this._light as any).position = new Vector3(position.x, position.y, position.z);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            } else {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.position.copyFrom((this._light as any).position);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedPosition.copyFrom(this.attachedMesh!.position);\r\n            }\r\n        }\r\n        if ((this._light as any).direction) {\r\n            // If the gizmo is moved update the light otherwise update the gizmo to match the light\r\n            if (Vector3.DistanceSquared(this.attachedMesh!.forward, this._cachedForward) > 0.0001) {\r\n                // update light to match gizmo\r\n                const direction = this.attachedMesh!.forward;\r\n                (this._light as any).direction = new Vector3(direction.x, direction.y, direction.z);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            } else if (Vector3.DistanceSquared(this.attachedMesh!.forward, (this._light as any).direction) > 0.0001) {\r\n                // update gizmo to match light\r\n                this.attachedMesh!.setDirection((this._light as any).direction);\r\n                this.attachedMesh!.computeWorldMatrix(true);\r\n                this._cachedForward.copyFrom(this.attachedMesh!.forward);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Static helper methods\r\n    private static _Scale = 0.007;\r\n\r\n    /**\r\n     * Creates the lines for a light mesh\r\n     * @param levels\r\n     * @param scene\r\n     */\r\n    private static _CreateLightLines = (levels: number, scene: Scene) => {\r\n        const distFromSphere = 1.2;\r\n\r\n        const root = new Mesh(\"root\", scene);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        // Create the top line, this will be cloned for all other lines\r\n        const linePivot = new Mesh(\"linePivot\", scene);\r\n        linePivot.parent = root;\r\n        const line = CreateCylinder(\r\n            \"line\",\r\n            {\r\n                updatable: false,\r\n                height: 2,\r\n                diameterTop: 0.2,\r\n                diameterBottom: 0.3,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        line.position.y = line.scaling.y / 2 + distFromSphere;\r\n        line.parent = linePivot;\r\n\r\n        if (levels < 2) {\r\n            return linePivot;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"lineParentClone\")!;\r\n            l.rotation.z = Math.PI / 4;\r\n            l.rotation.y = Math.PI / 2 + (Math.PI / 2) * i;\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 3) {\r\n            return root;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI / 2;\r\n            l.rotation.y = (Math.PI / 2) * i;\r\n        }\r\n\r\n        if (levels < 4) {\r\n            return root;\r\n        }\r\n        for (let i = 0; i < 4; i++) {\r\n            const l = linePivot.clone(\"linePivotClone\");\r\n            l.rotation.z = Math.PI + Math.PI / 4;\r\n            l.rotation.y = Math.PI / 2 + (Math.PI / 2) * i;\r\n\r\n            l.getChildMeshes()[0].scaling.y = 0.5;\r\n            l.getChildMeshes()[0].scaling.x = l.getChildMeshes()[0].scaling.z = 0.8;\r\n            l.getChildMeshes()[0].position.y = l.getChildMeshes()[0].scaling.y / 2 + distFromSphere;\r\n        }\r\n\r\n        if (levels < 5) {\r\n            return root;\r\n        }\r\n        const l = linePivot.clone(\"linePivotClone\");\r\n        l.rotation.z = Math.PI;\r\n\r\n        return root;\r\n    };\r\n\r\n    /**\r\n     * Disposes of the light gizmo\r\n     */\r\n    public dispose() {\r\n        this.onClickedObservable.clear();\r\n        this.gizmoLayer.utilityLayerScene.onPointerObservable.remove(this._pointerObserver);\r\n        this._material.dispose();\r\n        super.dispose();\r\n        this._attachedMeshParent.dispose();\r\n    }\r\n\r\n    private static _CreateHemisphericLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"hemisphereLight\", scene);\r\n        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        hemisphere.position.z = -0.15;\r\n        hemisphere.rotation.x = Math.PI / 2;\r\n        hemisphere.parent = root;\r\n\r\n        const lines = this._CreateLightLines(3, scene);\r\n        lines.parent = root;\r\n\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreatePointLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"pointLight\", scene);\r\n        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.rotation.x = Math.PI / 2;\r\n        sphere.parent = root;\r\n\r\n        const lines = this._CreateLightLines(5, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateSpotLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"spotLight\", scene);\r\n        const sphere = CreateSphere(root.name, { segments: 10, diameter: 1 }, scene);\r\n        sphere.parent = root;\r\n\r\n        const hemisphere = CreateHemisphere(root.name, { segments: 10, diameter: 2 }, scene);\r\n        hemisphere.parent = root;\r\n        hemisphere.rotation.x = -Math.PI / 2;\r\n\r\n        const lines = this._CreateLightLines(2, scene);\r\n        lines.parent = root;\r\n        root.scaling.scaleInPlace(LightGizmo._Scale);\r\n        root.rotation.x = Math.PI / 2;\r\n\r\n        return root;\r\n    }\r\n\r\n    private static _CreateDirectionalLightMesh(scene: Scene) {\r\n        const root = new Mesh(\"directionalLight\", scene);\r\n\r\n        const mesh = new Mesh(root.name, scene);\r\n        mesh.parent = root;\r\n        const sphere = CreateSphere(root.name, { diameter: 1.2, segments: 10 }, scene);\r\n        sphere.parent = mesh;\r\n\r\n        const line = CreateCylinder(\r\n            root.name,\r\n            {\r\n                updatable: false,\r\n                height: 6,\r\n                diameterTop: 0.3,\r\n                diameterBottom: 0.3,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        line.parent = mesh;\r\n\r\n        let left = line.clone(root.name)!;\r\n        left.scaling.y = 0.5;\r\n        left.position.x += 1.25;\r\n\r\n        let right = line.clone(root.name)!;\r\n        right.scaling.y = 0.5;\r\n        right.position.x += -1.25;\r\n\r\n        const arrowHead = CreateCylinder(\r\n            root.name,\r\n            {\r\n                updatable: false,\r\n                height: 1,\r\n                diameterTop: 0,\r\n                diameterBottom: 0.6,\r\n                tessellation: 6,\r\n                subdivisions: 1,\r\n            },\r\n            scene\r\n        );\r\n        arrowHead.position.y += 3;\r\n        arrowHead.parent = mesh;\r\n\r\n        left = arrowHead.clone(root.name);\r\n        left.position.y = 1.5;\r\n        left.position.x += 1.25;\r\n\r\n        right = arrowHead.clone(root.name);\r\n        right.position.y = 1.5;\r\n        right.position.x += -1.25;\r\n\r\n        mesh.scaling.scaleInPlace(LightGizmo._Scale);\r\n        mesh.rotation.z = Math.PI / 2;\r\n        mesh.rotation.y = Math.PI / 2;\r\n        return root;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}