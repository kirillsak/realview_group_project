{"ast":null,"code":"import { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { BoundingSphere } from \"../Culling/boundingSphere.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\n/**\n * Represents one particle of a solid particle system.\n */\nexport class SolidParticle {\n  /**\n   * Creates a Solid Particle object.\n   * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\n   * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\n   * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\n   * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\n   * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\n   * @param shapeId (integer) is the model shape identifier in the SPS.\n   * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\n   * @param sps defines the sps it is associated to\n   * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\n   * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\n   */\n  constructor(particleIndex, particleId, positionIndex, indiceIndex, model, shapeId, idxInShape, sps, modelBoundingInfo = null, materialIndex = null) {\n    /**\n     * particle global index\n     */\n    this.idx = 0;\n    /**\n     * particle identifier\n     */\n    this.id = 0;\n    /**\n     * The color of the particle\n     */\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n    this.rotation = Vector3.Zero();\n    /**\n     * The scaling of the particle.\n     */\n    this.scaling = Vector3.One();\n    /**\n     * The uvs of the particle.\n     */\n    this.uvs = new Vector4(0.0, 0.0, 1.0, 1.0);\n    /**\n     * The current speed of the particle.\n     */\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n    this.translateFromPivot = false;\n    /**\n     * Is the particle active or not ?\n     */\n    this.alive = true;\n    /**\n     * Is the particle visible or not ?\n     */\n    this.isVisible = true;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @internal\n     */\n    this._pos = 0;\n    /**\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\n     */\n    this._ind = 0;\n    /**\n     * ModelShape id of this particle\n     */\n    this.shapeId = 0;\n    /**\n     * Index of the particle in its shape id\n     */\n    this.idxInShape = 0;\n    /**\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\n     */\n    this._stillInvisible = false;\n    /**\n     * @internal Last computed particle rotation matrix\n     */\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n    this.parentId = null;\n    /**\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\n     */\n    this.materialIndex = null;\n    /**\n     * Custom object or properties.\n     */\n    this.props = null;\n    /**\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\n     * The possible values are :\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\n     * */\n    this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\n    /**\n     * @internal Internal global position in the SPS.\n     */\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this.id = particleId;\n    this._pos = positionIndex;\n    this._ind = indiceIndex;\n    this._model = model;\n    this.shapeId = shapeId;\n    this.idxInShape = idxInShape;\n    this._sps = sps;\n    if (modelBoundingInfo) {\n      this._modelBoundingInfo = modelBoundingInfo;\n      this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n    }\n    if (materialIndex !== null) {\n      this.materialIndex = materialIndex;\n    }\n  }\n  /**\n   * Particle BoundingInfo object\n   * @returns a BoundingInfo\n   */\n  getBoundingInfo() {\n    return this._boundingInfo;\n  }\n  /**\n   * Returns true if there is already a bounding info\n   */\n  get hasBoundingInfo() {\n    return this._boundingInfo !== null;\n  }\n  /**\n   * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\n   * @param target the particle target\n   * @returns the current particle\n   */\n  copyToRef(target) {\n    target.position.copyFrom(this.position);\n    target.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      if (target.rotationQuaternion) {\n        target.rotationQuaternion.copyFrom(this.rotationQuaternion);\n      } else {\n        target.rotationQuaternion = this.rotationQuaternion.clone();\n      }\n    }\n    target.scaling.copyFrom(this.scaling);\n    if (this.color) {\n      if (target.color) {\n        target.color.copyFrom(this.color);\n      } else {\n        target.color = this.color.clone();\n      }\n    }\n    target.uvs.copyFrom(this.uvs);\n    target.velocity.copyFrom(this.velocity);\n    target.pivot.copyFrom(this.pivot);\n    target.translateFromPivot = this.translateFromPivot;\n    target.alive = this.alive;\n    target.isVisible = this.isVisible;\n    target.parentId = this.parentId;\n    target.cullingStrategy = this.cullingStrategy;\n    if (this.materialIndex !== null) {\n      target.materialIndex = this.materialIndex;\n    }\n    return this;\n  }\n  /**\n   * Legacy support, changed scale to scaling\n   */\n  get scale() {\n    return this.scaling;\n  }\n  /**\n   * Legacy support, changed scale to scaling\n   */\n  set scale(scale) {\n    this.scaling = scale;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  get quaternion() {\n    return this.rotationQuaternion;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  set quaternion(q) {\n    this.rotationQuaternion = q;\n  }\n  /**\n   * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\n   * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\n   * @param target is the object (solid particle or mesh) what the intersection is computed against.\n   * @returns true if it intersects\n   */\n  intersectsMesh(target) {\n    if (!this._boundingInfo || !target.hasBoundingInfo) {\n      return false;\n    }\n    if (this._sps._bSphereOnly) {\n      return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\n    }\n    return this._boundingInfo.intersects(target.getBoundingInfo(), false);\n  }\n  /**\n   * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\n   * A particle is in the frustum if its bounding box intersects the frustum\n   * @param frustumPlanes defines the frustum to test\n   * @returns true if the particle is in the frustum planes\n   */\n  isInFrustum(frustumPlanes) {\n    return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\n  }\n  /**\n   * get the rotation matrix of the particle\n   * @internal\n   */\n  getRotationMatrix(m) {\n    let quaternion;\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      const rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n    quaternion.toRotationMatrix(m);\n  }\n}\n/**\n * Represents the shape of the model used by one particle of a solid particle system.\n * SPS internal tool, don't use it manually.\n */\nexport class ModelShape {\n  /**\n   * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\n   * SPS internal tool, don't use it manually.\n   * @internal\n   */\n  constructor(id, shape, indices, normals, colors, shapeUV, posFunction, vtxFunction, material) {\n    /**\n     * length of the shape in the model indices array (internal use)\n     * @internal\n     */\n    this._indicesLength = 0;\n    this.shapeId = id;\n    this._shape = shape;\n    this._indices = indices;\n    this._indicesLength = indices.length;\n    this._shapeUV = shapeUV;\n    this._shapeColors = colors;\n    this._normals = normals;\n    this._positionFunction = posFunction;\n    this._vertexFunction = vtxFunction;\n    this._material = material;\n  }\n  /**\n   * Get or set the shapeId\n   * @deprecated Please use shapeId instead\n   */\n  get shapeID() {\n    return this.shapeId;\n  }\n  set shapeID(shapeID) {\n    this.shapeId = shapeID;\n  }\n}\n/**\n * Represents a Depth Sorted Particle in the solid particle system.\n * @internal\n */\nexport class DepthSortedParticle {\n  /**\n   * Creates a new sorted particle\n   * @param idx\n   * @param ind\n   * @param indLength\n   * @param materialIndex\n   */\n  constructor(idx, ind, indLength, materialIndex) {\n    /**\n     * Particle index\n     */\n    this.idx = 0;\n    /**\n     * Index of the particle in the \"indices\" array\n     */\n    this.ind = 0;\n    /**\n     * Length of the particle shape in the \"indices\" array\n     */\n    this.indicesLength = 0;\n    /**\n     * Squared distance from the particle to the camera\n     */\n    this.sqDistance = 0.0;\n    /**\n     * Material index when used with MultiMaterials\n     */\n    this.materialIndex = 0;\n    this.idx = idx;\n    this.ind = ind;\n    this.indicesLength = indLength;\n    this.materialIndex = materialIndex;\n  }\n}\n/**\n * Represents a solid particle vertex\n */\nexport class SolidParticleVertex {\n  /**\n   * Creates a new solid particle vertex\n   */\n  constructor() {\n    this.position = Vector3.Zero();\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    this.uv = Vector2.Zero();\n  }\n  // Getters and Setters for back-compatibility\n  /** Vertex x coordinate */\n  get x() {\n    return this.position.x;\n  }\n  set x(val) {\n    this.position.x = val;\n  }\n  /** Vertex y coordinate */\n  get y() {\n    return this.position.y;\n  }\n  set y(val) {\n    this.position.y = val;\n  }\n  /** Vertex z coordinate */\n  get z() {\n    return this.position.z;\n  }\n  set z(val) {\n    this.position.z = val;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","TmpVectors","Quaternion","Vector4","Vector2","Color4","BoundingInfo","BoundingSphere","AbstractMesh","SolidParticle","constructor","particleIndex","particleId","positionIndex","indiceIndex","model","shapeId","idxInShape","sps","modelBoundingInfo","materialIndex","Zero","One","CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY","idx","id","_pos","_ind","_model","_sps","_modelBoundingInfo","_boundingInfo","minimum","maximum","getBoundingInfo","hasBoundingInfo","copyToRef","target","position","copyFrom","rotation","rotationQuaternion","clone","scaling","color","uvs","velocity","pivot","translateFromPivot","alive","isVisible","parentId","cullingStrategy","scale","quaternion","q","intersectsMesh","_bSphereOnly","Intersects","boundingSphere","intersects","isInFrustum","frustumPlanes","getRotationMatrix","m","RotationYawPitchRollToRef","y","x","z","toRotationMatrix","ModelShape","shape","indices","normals","colors","shapeUV","posFunction","vtxFunction","material","_shape","_indices","_indicesLength","length","_shapeUV","_shapeColors","_normals","_positionFunction","_vertexFunction","_material","shapeID","DepthSortedParticle","ind","indLength","indicesLength","SolidParticleVertex","uv","val"],"sourceRoot":"","sources":["../../../../lts/core/generated/Particles/solidParticle.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Quaternion, Vector4, Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { BoundingSphere } from \"../Culling/boundingSphere\";\r\nimport type { SolidParticleSystem } from \"./solidParticleSystem\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport type { Material } from \"../Materials/material\";\r\n/**\r\n * Represents one particle of a solid particle system.\r\n */\r\nexport class SolidParticle {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * particle identifier\r\n     */\r\n    public id: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The scaling of the particle.\r\n     */\r\n    public scaling: Vector3 = Vector3.One();\r\n    /**\r\n     * The uvs of the particle.\r\n     */\r\n    public uvs: Vector4 = new Vector4(0.0, 0.0, 1.0, 1.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Is the particle active or not ?\r\n     */\r\n    public alive: boolean = true;\r\n    /**\r\n     * Is the particle visible or not ?\r\n     */\r\n    public isVisible: boolean = true;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @internal\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * @internal ModelShape of this particle (Internal use)\r\n     */\r\n    public _model: ModelShape;\r\n    /**\r\n     * ModelShape id of this particle\r\n     */\r\n    public shapeId: number = 0;\r\n    /**\r\n     * Index of the particle in its shape id\r\n     */\r\n    public idxInShape: number = 0;\r\n    /**\r\n     * @internal Reference to the shape model BoundingInfo object (Internal use)\r\n     */\r\n    public _modelBoundingInfo: BoundingInfo;\r\n    private _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @internal Reference to the SPS what the particle belongs to (Internal use)\r\n     */\r\n    public _sps: SolidParticleSystem;\r\n    /**\r\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @internal Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * The particle material identifier (integer) when MultiMaterials are enabled in the SPS.\r\n     */\r\n    public materialIndex: Nullable<number> = null;\r\n    /**\r\n     * Custom object or properties.\r\n     */\r\n    public props: Nullable<any> = null;\r\n    /**\r\n     * The culling strategy to use to check whether the solid particle must be culled or not when using isInFrustum().\r\n     * The possible values are :\r\n     * - AbstractMesh.CULLINGSTRATEGY_STANDARD\r\n     * - AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * - AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * The default value for solid particles is AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * Please read each static variable documentation in the class AbstractMesh to get details about the culling process.\r\n     * */\r\n    public cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;\r\n\r\n    /**\r\n     * @internal Internal global position in the SPS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Particle BoundingInfo object\r\n     * @returns a BoundingInfo\r\n     */\r\n    public getBoundingInfo(): BoundingInfo {\r\n        return this._boundingInfo;\r\n    }\r\n\r\n    /**\r\n     * Returns true if there is already a bounding info\r\n     */\r\n    public get hasBoundingInfo(): boolean {\r\n        return this._boundingInfo !== null;\r\n    }\r\n\r\n    /**\r\n     * Creates a Solid Particle object.\r\n     * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the Solid Particle System pool.\r\n     * @param particleId (integer) is the particle identifier. Unless some particles are removed from the SPS, it's the same value than the particle idx.\r\n     * @param positionIndex (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\r\n     * @param indiceIndex (integer) is the starting index of the particle indices in the SPS \"indices\" array.\r\n     * @param model (ModelShape) is a reference to the model shape on what the particle is designed.\r\n     * @param shapeId (integer) is the model shape identifier in the SPS.\r\n     * @param idxInShape (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\r\n     * @param sps defines the sps it is associated to\r\n     * @param modelBoundingInfo is the reference to the model BoundingInfo used for intersection computations.\r\n     * @param materialIndex is the particle material identifier (integer) when the MultiMaterials are enabled in the SPS.\r\n     */\r\n    constructor(\r\n        particleIndex: number,\r\n        particleId: number,\r\n        positionIndex: number,\r\n        indiceIndex: number,\r\n        model: Nullable<ModelShape>,\r\n        shapeId: number,\r\n        idxInShape: number,\r\n        sps: SolidParticleSystem,\r\n        modelBoundingInfo: Nullable<BoundingInfo> = null,\r\n        materialIndex: Nullable<number> = null\r\n    ) {\r\n        this.idx = particleIndex;\r\n        this.id = particleId;\r\n        this._pos = positionIndex;\r\n        this._ind = indiceIndex;\r\n        this._model = <ModelShape>model;\r\n        this.shapeId = shapeId;\r\n        this.idxInShape = idxInShape;\r\n        this._sps = sps;\r\n        if (modelBoundingInfo) {\r\n            this._modelBoundingInfo = modelBoundingInfo;\r\n            this._boundingInfo = new BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\r\n        }\r\n        if (materialIndex !== null) {\r\n            this.materialIndex = materialIndex;\r\n        }\r\n    }\r\n    /**\r\n     * Copies the particle property values into the existing target : position, rotation, scaling, uvs, colors, pivot, parent, visibility, alive\r\n     * @param target the particle target\r\n     * @returns the current particle\r\n     */\r\n    public copyToRef(target: SolidParticle): SolidParticle {\r\n        target.position.copyFrom(this.position);\r\n        target.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            if (target.rotationQuaternion) {\r\n                target.rotationQuaternion!.copyFrom(this.rotationQuaternion!);\r\n            } else {\r\n                target.rotationQuaternion = this.rotationQuaternion.clone();\r\n            }\r\n        }\r\n        target.scaling.copyFrom(this.scaling);\r\n        if (this.color) {\r\n            if (target.color) {\r\n                target.color!.copyFrom(this.color!);\r\n            } else {\r\n                target.color = this.color.clone();\r\n            }\r\n        }\r\n        target.uvs.copyFrom(this.uvs);\r\n        target.velocity.copyFrom(this.velocity);\r\n        target.pivot.copyFrom(this.pivot);\r\n        target.translateFromPivot = this.translateFromPivot;\r\n        target.alive = this.alive;\r\n        target.isVisible = this.isVisible;\r\n        target.parentId = this.parentId;\r\n        target.cullingStrategy = this.cullingStrategy;\r\n        if (this.materialIndex !== null) {\r\n            target.materialIndex = this.materialIndex;\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\r\n    public get scale(): Vector3 {\r\n        return this.scaling;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed scale to scaling\r\n     */\r\n    public set scale(scale: Vector3) {\r\n        this.scaling = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\r\n     * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\r\n     * @param target is the object (solid particle or mesh) what the intersection is computed against.\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh | SolidParticle): boolean {\r\n        if (!this._boundingInfo || !target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n        if (this._sps._bSphereOnly) {\r\n            return BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target.getBoundingInfo().boundingSphere);\r\n        }\r\n        return this._boundingInfo.intersects(target.getBoundingInfo(), false);\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the solid particle is within the frustum defined by the passed array of planes.\r\n     * A particle is in the frustum if its bounding box intersects the frustum\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @returns true if the particle is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Plane[]): boolean {\r\n        return this._boundingInfo !== null && this._boundingInfo.isInFrustum(frustumPlanes, this.cullingStrategy);\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @internal\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the shape of the model used by one particle of a solid particle system.\r\n * SPS internal tool, don't use it manually.\r\n */\r\nexport class ModelShape {\r\n    /**\r\n     * Get or set the shapeId\r\n     * @deprecated Please use shapeId instead\r\n     */\r\n    public get shapeID(): number {\r\n        return this.shapeId;\r\n    }\r\n    public set shapeID(shapeID: number) {\r\n        this.shapeId = shapeID;\r\n    }\r\n    /**\r\n     * The shape id\r\n     * @internal\r\n     */\r\n    public shapeId: number;\r\n    /**\r\n     * flat array of model positions (internal use)\r\n     * @internal\r\n     */\r\n    public _shape: Vector3[];\r\n    /**\r\n     * flat array of model UVs (internal use)\r\n     * @internal\r\n     */\r\n    public _shapeUV: number[];\r\n    /**\r\n     * color array of the model\r\n     * @internal\r\n     */\r\n    public _shapeColors: number[];\r\n    /**\r\n     * indices array of the model\r\n     * @internal\r\n     */\r\n    public _indices: number[];\r\n    /**\r\n     * normals array of the model\r\n     * @internal\r\n     */\r\n    public _normals: number[];\r\n    /**\r\n     * length of the shape in the model indices array (internal use)\r\n     * @internal\r\n     */\r\n    public _indicesLength: number = 0;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @internal\r\n     */\r\n    public _positionFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>;\r\n    /**\r\n     * Custom vertex function (internal use)\r\n     * @internal\r\n     */\r\n    public _vertexFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>;\r\n    /**\r\n     * Model material (internal use)\r\n     * @internal\r\n     */\r\n    public _material: Nullable<Material>;\r\n\r\n    /**\r\n     * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\r\n     * SPS internal tool, don't use it manually.\r\n     * @internal\r\n     */\r\n    constructor(\r\n        id: number,\r\n        shape: Vector3[],\r\n        indices: number[],\r\n        normals: number[],\r\n        colors: number[],\r\n        shapeUV: number[],\r\n        posFunction: Nullable<(particle: SolidParticle, i: number, s: number) => void>,\r\n        vtxFunction: Nullable<(particle: SolidParticle, vertex: Vector3, i: number) => void>,\r\n        material: Nullable<Material>\r\n    ) {\r\n        this.shapeId = id;\r\n        this._shape = shape;\r\n        this._indices = indices;\r\n        this._indicesLength = indices.length;\r\n        this._shapeUV = shapeUV;\r\n        this._shapeColors = colors;\r\n        this._normals = normals;\r\n        this._positionFunction = posFunction;\r\n        this._vertexFunction = vtxFunction;\r\n        this._material = material;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a Depth Sorted Particle in the solid particle system.\r\n * @internal\r\n */\r\nexport class DepthSortedParticle {\r\n    /**\r\n     * Particle index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * Index of the particle in the \"indices\" array\r\n     */\r\n    public ind: number = 0;\r\n    /**\r\n     * Length of the particle shape in the \"indices\" array\r\n     */\r\n    public indicesLength: number = 0;\r\n    /**\r\n     * Squared distance from the particle to the camera\r\n     */\r\n    public sqDistance: number = 0.0;\r\n    /**\r\n     * Material index when used with MultiMaterials\r\n     */\r\n    public materialIndex: number = 0;\r\n\r\n    /**\r\n     * Creates a new sorted particle\r\n     * @param idx\r\n     * @param ind\r\n     * @param indLength\r\n     * @param materialIndex\r\n     */\r\n    constructor(idx: number, ind: number, indLength: number, materialIndex: number) {\r\n        this.idx = idx;\r\n        this.ind = ind;\r\n        this.indicesLength = indLength;\r\n        this.materialIndex = materialIndex;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a solid particle vertex\r\n */\r\nexport class SolidParticleVertex {\r\n    /**\r\n     * Vertex position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Vertex color\r\n     */\r\n    public color: Color4;\r\n    /**\r\n     * Vertex UV\r\n     */\r\n    public uv: Vector2;\r\n    /**\r\n     * Creates a new solid particle vertex\r\n     */\r\n    constructor() {\r\n        this.position = Vector3.Zero();\r\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        this.uv = Vector2.Zero();\r\n    }\r\n    // Getters and Setters for back-compatibility\r\n    /** Vertex x coordinate */\r\n    public get x(): number {\r\n        return this.position.x;\r\n    }\r\n    public set x(val: number) {\r\n        this.position.x = val;\r\n    }\r\n    /** Vertex y coordinate */\r\n    public get y(): number {\r\n        return this.position.y;\r\n    }\r\n    public set y(val: number) {\r\n        this.position.y = val;\r\n    }\r\n    /** Vertex z coordinate */\r\n    public get z(): number {\r\n        return this.position.z;\r\n    }\r\n    public set z(val: number) {\r\n        this.position.z = val;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}