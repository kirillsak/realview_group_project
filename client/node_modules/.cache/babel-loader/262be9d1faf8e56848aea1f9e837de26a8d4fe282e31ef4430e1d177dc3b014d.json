{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Animation } from \"./animation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Tags } from \"../Misc/tags.js\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n  /**\n   * Returns the string \"TargetedAnimation\"\n   * @returns \"TargetedAnimation\"\n   */\n  getClassName() {\n    return \"TargetedAnimation\";\n  }\n  /**\n   * Serialize the object\n   * @returns the JSON object representing the current entity\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.animation = this.animation.serialize();\n    serializationObject.targetId = this.target.id;\n    return serializationObject;\n  }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n  /**\n   * Instantiates a new Animation Group.\n   * This helps managing several animations at once.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n   * @param name Defines the name of the group\n   * @param scene Defines the scene the group belongs to\n   */\n  constructor( /** The name of the animation group */\n  name, scene = null) {\n    this.name = name;\n    this._targetedAnimations = new Array();\n    this._animatables = new Array();\n    this._from = Number.MAX_VALUE;\n    this._to = -Number.MAX_VALUE;\n    this._speedRatio = 1;\n    this._loopAnimation = false;\n    this._isAdditive = false;\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * This observable will notify when one animation have ended\n     */\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when one animation loops\n     */\n    this.onAnimationLoopObservable = new Observable();\n    /**\n     * Observer raised when all animations have looped\n     */\n    this.onAnimationGroupLoopObservable = new Observable();\n    /**\n     * This observable will notify when all animations have ended.\n     */\n    this.onAnimationGroupEndObservable = new Observable();\n    /**\n     * This observable will notify when all animations have paused.\n     */\n    this.onAnimationGroupPauseObservable = new Observable();\n    /**\n     * This observable will notify when all animations are playing.\n     */\n    this.onAnimationGroupPlayObservable = new Observable();\n    /**\n     * Gets or sets an object used to store user defined information for the node\n     */\n    this.metadata = null;\n    this._animationLoopFlags = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.uniqueId = this._scene.getUniqueId();\n    this._scene.addAnimationGroup(this);\n  }\n  /**\n   * Gets the first frame\n   */\n  get from() {\n    return this._from;\n  }\n  /**\n   * Gets the last frame\n   */\n  get to() {\n    return this._to;\n  }\n  /**\n   * Define if the animations are started\n   */\n  get isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a value indicating that the current group is playing\n   */\n  get isPlaying() {\n    return this._isStarted && !this._isPaused;\n  }\n  /**\n   * Gets or sets the speed ratio to use for all animations\n   */\n  get speedRatio() {\n    return this._speedRatio;\n  }\n  /**\n   * Gets or sets the speed ratio to use for all animations\n   */\n  set speedRatio(value) {\n    if (this._speedRatio === value) {\n      return;\n    }\n    this._speedRatio = value;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.speedRatio = this._speedRatio;\n    }\n  }\n  /**\n   * Gets or sets if all animations should loop or not\n   */\n  get loopAnimation() {\n    return this._loopAnimation;\n  }\n  set loopAnimation(value) {\n    if (this._loopAnimation === value) {\n      return;\n    }\n    this._loopAnimation = value;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.loopAnimation = this._loopAnimation;\n    }\n  }\n  /**\n   * Gets or sets if all animations should be evaluated additively\n   */\n  get isAdditive() {\n    return this._isAdditive;\n  }\n  set isAdditive(value) {\n    if (this._isAdditive === value) {\n      return;\n    }\n    this._isAdditive = value;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.isAdditive = this._isAdditive;\n    }\n  }\n  /**\n   * Gets the targeted animations for this animation group\n   */\n  get targetedAnimations() {\n    return this._targetedAnimations;\n  }\n  /**\n   * returning the list of animatables controlled by this animation group.\n   */\n  get animatables() {\n    return this._animatables;\n  }\n  /**\n   * Gets the list of target animations\n   */\n  get children() {\n    return this._targetedAnimations;\n  }\n  /**\n   * Add an animation (with its target) in the group\n   * @param animation defines the animation we want to add\n   * @param target defines the target of the animation\n   * @returns the TargetedAnimation object\n   */\n  addTargetedAnimation(animation, target) {\n    const targetedAnimation = new TargetedAnimation();\n    targetedAnimation.animation = animation;\n    targetedAnimation.target = target;\n    const keys = animation.getKeys();\n    if (this._from > keys[0].frame) {\n      this._from = keys[0].frame;\n    }\n    if (this._to < keys[keys.length - 1].frame) {\n      this._to = keys[keys.length - 1].frame;\n    }\n    this._targetedAnimations.push(targetedAnimation);\n    return targetedAnimation;\n  }\n  /**\n   * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n   * It can add constant keys at begin or end\n   * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n   * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n   * @returns the animation group\n   */\n  normalize(beginFrame = null, endFrame = null) {\n    if (beginFrame == null) {\n      beginFrame = this._from;\n    }\n    if (endFrame == null) {\n      endFrame = this._to;\n    }\n    for (let index = 0; index < this._targetedAnimations.length; index++) {\n      const targetedAnimation = this._targetedAnimations[index];\n      const keys = targetedAnimation.animation.getKeys();\n      const startKey = keys[0];\n      const endKey = keys[keys.length - 1];\n      if (startKey.frame > beginFrame) {\n        const newKey = {\n          frame: beginFrame,\n          value: startKey.value,\n          inTangent: startKey.inTangent,\n          outTangent: startKey.outTangent,\n          interpolation: startKey.interpolation\n        };\n        keys.splice(0, 0, newKey);\n      }\n      if (endKey.frame < endFrame) {\n        const newKey = {\n          frame: endFrame,\n          value: endKey.value,\n          inTangent: endKey.inTangent,\n          outTangent: endKey.outTangent,\n          interpolation: endKey.interpolation\n        };\n        keys.push(newKey);\n      }\n    }\n    this._from = beginFrame;\n    this._to = endFrame;\n    return this;\n  }\n  _processLoop(animatable, targetedAnimation, index) {\n    animatable.onAnimationLoop = () => {\n      this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n      if (this._animationLoopFlags[index]) {\n        return;\n      }\n      this._animationLoopFlags[index] = true;\n      this._animationLoopCount++;\n      if (this._animationLoopCount === this._targetedAnimations.length) {\n        this.onAnimationGroupLoopObservable.notifyObservers(this);\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n      }\n    };\n  }\n  /**\n   * Start all animations on given targets\n   * @param loop defines if animations must loop\n   * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n   * @param from defines the from key (optional)\n   * @param to defines the to key (optional)\n   * @param isAdditive defines the additive state for the resulting animatables (optional)\n   * @returns the current animation group\n   */\n  start(loop = false, speedRatio = 1, from, to, isAdditive) {\n    if (this._isStarted || this._targetedAnimations.length === 0) {\n      return this;\n    }\n    this._loopAnimation = loop;\n    this._animationLoopCount = 0;\n    this._animationLoopFlags.length = 0;\n    for (let index = 0; index < this._targetedAnimations.length; index++) {\n      const targetedAnimation = this._targetedAnimations[index];\n      const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n      animatable.onAnimationEnd = () => {\n        this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n        this._checkAnimationGroupEnded(animatable);\n      };\n      this._processLoop(animatable, targetedAnimation, index);\n      this._animatables.push(animatable);\n    }\n    this._speedRatio = speedRatio;\n    this._isStarted = true;\n    this._isPaused = false;\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Pause all animations\n   * @returns the animation group\n   */\n  pause() {\n    if (!this._isStarted) {\n      return this;\n    }\n    this._isPaused = true;\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.pause();\n    }\n    this.onAnimationGroupPauseObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Play all animations to initial state\n   * This function will start() the animations if they were not started or will restart() them if they were paused\n   * @param loop defines if animations must loop\n   * @returns the animation group\n   */\n  play(loop) {\n    // only if all animatables are ready and exist\n    if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\n      if (loop !== undefined) {\n        this.loopAnimation = loop;\n      }\n      this.restart();\n    } else {\n      this.stop();\n      this.start(loop, this._speedRatio);\n    }\n    this._isPaused = false;\n    return this;\n  }\n  /**\n   * Reset all animations to initial state\n   * @returns the animation group\n   */\n  reset() {\n    if (!this._isStarted) {\n      this.play();\n      this.goToFrame(0);\n      this.stop();\n      return this;\n    }\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.reset();\n    }\n    return this;\n  }\n  /**\n   * Restart animations from key 0\n   * @returns the animation group\n   */\n  restart() {\n    if (!this._isStarted) {\n      return this;\n    }\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.restart();\n    }\n    this.onAnimationGroupPlayObservable.notifyObservers(this);\n    return this;\n  }\n  /**\n   * Stop all animations\n   * @returns the animation group\n   */\n  stop() {\n    if (!this._isStarted) {\n      return this;\n    }\n    const list = this._animatables.slice();\n    for (let index = 0; index < list.length; index++) {\n      list[index].stop();\n    }\n    this._isStarted = false;\n    return this;\n  }\n  /**\n   * Set animation weight for all animatables\n   * @param weight defines the weight to use\n   * @returns the animationGroup\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n   */\n  setWeightForAllAnimatables(weight) {\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.weight = weight;\n    }\n    return this;\n  }\n  /**\n   * Synchronize and normalize all animatables with a source animatable\n   * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n   * @returns the animationGroup\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n   */\n  syncAllAnimationsWith(root) {\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.syncWith(root);\n    }\n    return this;\n  }\n  /**\n   * Goes to a specific frame in this animation group\n   * @param frame the frame number to go to\n   * @returns the animationGroup\n   */\n  goToFrame(frame) {\n    if (!this._isStarted) {\n      return this;\n    }\n    for (let index = 0; index < this._animatables.length; index++) {\n      const animatable = this._animatables[index];\n      animatable.goToFrame(frame);\n    }\n    return this;\n  }\n  /**\n   * Dispose all associated resources\n   */\n  dispose() {\n    this._targetedAnimations.length = 0;\n    this._animatables.length = 0;\n    // Remove from scene\n    const index = this._scene.animationGroups.indexOf(this);\n    if (index > -1) {\n      this._scene.animationGroups.splice(index, 1);\n    }\n    if (this._parentContainer) {\n      const index = this._parentContainer.animationGroups.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.animationGroups.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    this.onAnimationEndObservable.clear();\n    this.onAnimationGroupEndObservable.clear();\n    this.onAnimationGroupPauseObservable.clear();\n    this.onAnimationGroupPlayObservable.clear();\n    this.onAnimationLoopObservable.clear();\n    this.onAnimationGroupLoopObservable.clear();\n  }\n  _checkAnimationGroupEnded(animatable) {\n    // animatable should be taken out of the array\n    const idx = this._animatables.indexOf(animatable);\n    if (idx > -1) {\n      this._animatables.splice(idx, 1);\n    }\n    // all animatables were removed? animation group ended!\n    if (this._animatables.length === 0) {\n      this._isStarted = false;\n      this.onAnimationGroupEndObservable.notifyObservers(this);\n    }\n  }\n  /**\n   * Clone the current animation group and returns a copy\n   * @param newName defines the name of the new group\n   * @param targetConverter defines an optional function used to convert current animation targets to new ones\n   * @param cloneAnimations defines if the animations should be cloned or referenced\n   * @returns the new animation group\n   */\n  clone(newName, targetConverter, cloneAnimations = false) {\n    const newGroup = new AnimationGroup(newName || this.name, this._scene);\n    for (const targetAnimation of this._targetedAnimations) {\n      newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n    }\n    return newGroup;\n  }\n  /**\n   * Serializes the animationGroup to an object\n   * @returns Serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.from = this.from;\n    serializationObject.to = this.to;\n    serializationObject.targetedAnimations = [];\n    for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n      const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n      serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n    }\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    // Metadata\n    if (this.metadata) {\n      serializationObject.metadata = this.metadata;\n    }\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Returns a new AnimationGroup object parsed from the source provided.\n   * @param parsedAnimationGroup defines the source\n   * @param scene defines the scene that will receive the animationGroup\n   * @returns a new AnimationGroup\n   */\n  static Parse(parsedAnimationGroup, scene) {\n    const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\n    for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n      const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n      const animation = Animation.Parse(targetedAnimation.animation);\n      const id = targetedAnimation.targetId;\n      if (targetedAnimation.animation.property === \"influence\") {\n        // morph target animation\n        const morphTarget = scene.getMorphTargetById(id);\n        if (morphTarget) {\n          animationGroup.addTargetedAnimation(animation, morphTarget);\n        }\n      } else {\n        const targetNode = scene.getNodeById(id);\n        if (targetNode != null) {\n          animationGroup.addTargetedAnimation(animation, targetNode);\n        }\n      }\n    }\n    if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n      animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n    }\n    if (Tags) {\n      Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n    }\n    if (parsedAnimationGroup.metadata !== undefined) {\n      animationGroup.metadata = parsedAnimationGroup.metadata;\n    }\n    return animationGroup;\n  }\n  /**\n   * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\n   * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\n   * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\n   * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\n   * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\n   */\n  static MakeAnimationAdditive(sourceAnimationGroup, referenceFrame = 0, range, cloneOriginal = false, clonedName) {\n    let animationGroup = sourceAnimationGroup;\n    if (cloneOriginal) {\n      animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\n    }\n    const targetedAnimations = animationGroup.targetedAnimations;\n    for (let index = 0; index < targetedAnimations.length; index++) {\n      const targetedAnimation = targetedAnimations[index];\n      Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\n    }\n    animationGroup.isAdditive = true;\n    return animationGroup;\n  }\n  /**\n   * Returns the string \"AnimationGroup\"\n   * @returns \"AnimationGroup\"\n   */\n  getClassName() {\n    return \"AnimationGroup\";\n  }\n  /**\n   * Creates a detailed string about the object\n   * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n   * @returns a string representing the object\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    ret += \", type: \" + this.getClassName();\n    if (fullDetails) {\n      ret += \", from: \" + this._from;\n      ret += \", to: \" + this._to;\n      ret += \", isStarted: \" + this._isStarted;\n      ret += \", speedRatio: \" + this._speedRatio;\n      ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n      ret += \", animatables length: \" + this._animatables;\n    }\n    return ret;\n  }\n}","map":{"version":3,"mappings":"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","names":["Animation","Observable","EngineStore","Tags","TargetedAnimation","getClassName","serialize","serializationObject","animation","targetId","target","id","AnimationGroup","constructor","name","scene","Array","Number","MAX_VALUE","_scene","LastCreatedScene","uniqueId","getUniqueId","addAnimationGroup","from","_from","to","_to","isStarted","_isStarted","isPlaying","_isPaused","speedRatio","_speedRatio","value","index","_animatables","length","animatable","loopAnimation","_loopAnimation","isAdditive","_isAdditive","targetedAnimations","_targetedAnimations","animatables","children","addTargetedAnimation","targetedAnimation","keys","getKeys","frame","push","normalize","beginFrame","endFrame","startKey","endKey","newKey","inTangent","outTangent","interpolation","splice","_processLoop","onAnimationLoop","onAnimationLoopObservable","notifyObservers","_animationLoopFlags","_animationLoopCount","onAnimationGroupLoopObservable","start","loop","beginDirectAnimation","undefined","onAnimationEnd","onAnimationEndObservable","_checkAnimationGroupEnded","onAnimationGroupPlayObservable","pause","onAnimationGroupPauseObservable","play","restart","stop","reset","goToFrame","list","slice","setWeightForAllAnimatables","weight","syncAllAnimationsWith","root","syncWith","dispose","animationGroups","indexOf","_parentContainer","clear","onAnimationGroupEndObservable","idx","clone","newName","targetConverter","cloneAnimations","newGroup","targetAnimation","targetedAnimationIndex","HasTags","tags","GetTags","metadata","Parse","parsedAnimationGroup","animationGroup","i","property","morphTarget","getMorphTargetById","targetNode","getNodeById","AddTagsTo","MakeAnimationAdditive","sourceAnimationGroup","referenceFrame","range","cloneOriginal","clonedName","toString","fullDetails","ret"],"sourceRoot":"","sources":["../../../../lts/core/generated/Animations/animationGroup.ts"],"sourcesContent":["import type { Animatable } from \"./animatable\";\r\nimport { Animation } from \"./animation\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { Tags } from \"../Misc/tags\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Gets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    /**\r\n     * Gets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        const targetedAnimation = new TargetedAnimation();\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        const keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) {\r\n            beginFrame = this._from;\r\n        }\r\n        if (endFrame == null) {\r\n            endFrame = this._to;\r\n        }\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const keys = targetedAnimation.animation.getKeys();\r\n            const startKey = keys[0];\r\n            const endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation,\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation,\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[] = [];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._targetedAnimations.length) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags.length = 0;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags.length = 0;\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if all animatables are ready and exist\r\n        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        this._isPaused = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop();\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from key 0\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @returns the animation group\r\n     */\r\n    public stop(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        const list = this._animatables.slice();\r\n        for (let index = 0; index < list.length; index++) {\r\n            list[index].stop();\r\n        }\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     * @param weight defines the weight to use\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Nullable<Animatable>): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group\r\n     * @param frame the frame number to go to\r\n     * @returns the animationGroup\r\n     */\r\n    public goToFrame(frame: number): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.goToFrame(frame);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._targetedAnimations.length = 0;\r\n        this._animatables.length = 0;\r\n\r\n        // Remove from scene\r\n        const index = this._scene.animationGroups.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._scene.animationGroups.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.animationGroups.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.animationGroups.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable) {\r\n        // animatable should be taken out of the array\r\n        const idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === 0) {\r\n            this._isStarted = false;\r\n            this.onAnimationGroupEndObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @param cloneAnimations defines if the animations should be cloned or referenced\r\n     * @returns the new animation group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any, cloneAnimations = false): AnimationGroup {\r\n        const newGroup = new AnimationGroup(newName || this.name, this._scene);\r\n\r\n        for (const targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(\r\n                cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation,\r\n                targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target\r\n            );\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.targetedAnimations = [];\r\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene): AnimationGroup {\r\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene);\r\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            const animation = Animation.Parse(targetedAnimation.animation);\r\n            const id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") {\r\n                // morph target animation\r\n                const morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            } else {\r\n                const targetNode = scene.getNodeById(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\r\n        }\r\n\r\n        if (parsedAnimationGroup.metadata !== undefined) {\r\n            animationGroup.metadata = parsedAnimationGroup.metadata;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame = 0, range?: string, cloneOriginal = false, clonedName?: string): AnimationGroup {\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (cloneOriginal) {\r\n            animationGroup = sourceAnimationGroup.clone(clonedName || animationGroup.name);\r\n        }\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            Animation.MakeAnimationAdditive(targetedAnimation.animation, referenceFrame, range);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailed string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}