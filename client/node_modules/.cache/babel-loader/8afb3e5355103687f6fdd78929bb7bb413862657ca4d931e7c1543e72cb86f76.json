{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { LayerSceneComponent } from \"./layerSceneComponent.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport \"../Shaders/layer.fragment.js\";\nimport \"../Shaders/layer.vertex.js\";\n/**\n * This represents a full screen 2d layer.\n * This can be useful to display a picture in the  background of your scene for instance.\n * @see https://www.babylonjs-playground.com/#08A2BS#1\n */\nexport class Layer {\n  /**\n   * Instantiates a new layer.\n   * This represents a full screen 2d layer.\n   * This can be useful to display a picture in the  background of your scene for instance.\n   * @see https://www.babylonjs-playground.com/#08A2BS#1\n   * @param name Define the name of the layer in the scene\n   * @param imgUrl Define the url of the texture to display in the layer\n   * @param scene Define the scene the layer belongs to\n   * @param isBackground Defines whether the layer is displayed in front or behind the scene\n   * @param color Defines a color for the layer\n   */\n  constructor(\n  /**\n   * Define the name of the layer.\n   */\n  name, imgUrl, scene, isBackground, color) {\n    this.name = name;\n    this._applyPostProcess = true;\n    /**\n     * Define the scale of the layer in order to zoom in out of the texture.\n     */\n    this.scale = new Vector2(1, 1);\n    /**\n     * Define an offset for the layer in order to shift the texture.\n     */\n    this.offset = new Vector2(0, 0);\n    /**\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\n     */\n    this.alphaBlendingMode = 2;\n    /**\n     * Define a mask to restrict the layer to only some of the scene cameras.\n     */\n    this.layerMask = 0x0fffffff;\n    /**\n     * Define the list of render target the layer is visible into.\n     */\n    this.renderTargetTextures = [];\n    /**\n     * Define if the layer is only used in renderTarget or if it also\n     * renders in the main frame buffer of the canvas.\n     */\n    this.renderOnlyInRenderTargetTextures = false;\n    /**\n     * Define if the layer is enabled (ie. should be displayed). Default: true\n     */\n    this.isEnabled = true;\n    this._vertexBuffers = {};\n    /**\n     * An event triggered when the layer is disposed.\n     */\n    this.onDisposeObservable = new Observable();\n    /**\n     * An event triggered before rendering the scene\n     */\n    this.onBeforeRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene\n     */\n    this.onAfterRenderObservable = new Observable();\n    this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\n    this.isBackground = isBackground === undefined ? true : isBackground;\n    this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER);\n    if (!layerComponent) {\n      layerComponent = new LayerSceneComponent(this._scene);\n      this._scene._addComponent(layerComponent);\n    }\n    this._scene.layers.push(this);\n    const engine = this._scene.getEngine();\n    this._drawWrapper = new DrawWrapper(engine);\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\n    this._createIndexBuffer();\n  }\n  /**\n   * Determines if the layer is drawn before (true) or after (false) post-processing.\n   * If the layer is background, it is always before.\n   */\n  set applyPostProcess(value) {\n    this._applyPostProcess = value;\n  }\n  get applyPostProcess() {\n    return this.isBackground || this._applyPostProcess;\n  }\n  /**\n   * Back compatibility with callback before the onDisposeObservable existed.\n   * The set callback will be triggered when the layer has been disposed.\n   */\n  set onDispose(callback) {\n    if (this._onDisposeObserver) {\n      this.onDisposeObservable.remove(this._onDisposeObserver);\n    }\n    this._onDisposeObserver = this.onDisposeObservable.add(callback);\n  }\n  /**\n   * Back compatibility with callback before the onBeforeRenderObservable existed.\n   * The set callback will be triggered just before rendering the layer.\n   */\n  set onBeforeRender(callback) {\n    if (this._onBeforeRenderObserver) {\n      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n    }\n    this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n  }\n  /**\n   * Back compatibility with callback before the onAfterRenderObservable existed.\n   * The set callback will be triggered just after rendering the layer.\n   */\n  set onAfterRender(callback) {\n    if (this._onAfterRenderObserver) {\n      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n    }\n    this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n  }\n  _createIndexBuffer() {\n    const engine = this._scene.getEngine();\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = engine.createIndexBuffer(indices);\n  }\n  /** @internal */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n  }\n  /**\n   * Renders the layer in the scene.\n   */\n  render() {\n    if (!this.isEnabled) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    let defines = \"\";\n    if (this.alphaTest) {\n      defines = \"#define ALPHATEST\";\n    }\n    if (this.texture && !this.texture.gammaSpace) {\n      defines += \"\\r\\n#define LINEAR\";\n    }\n    if (this._previousDefines !== defines) {\n      this._previousDefines = defines;\n      this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\n    }\n    const currentEffect = this._drawWrapper.effect;\n    // Check\n    if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {\n      return;\n    }\n    this.onBeforeRenderObservable.notifyObservers(this);\n    // Render\n    engine.enableEffect(this._drawWrapper);\n    engine.setState(false);\n    // Texture\n    currentEffect.setTexture(\"textureSampler\", this.texture);\n    currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\n    // Color\n    currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\n    // Scale / offset\n    currentEffect.setVector2(\"offset\", this.offset);\n    currentEffect.setVector2(\"scale\", this.scale);\n    // VBOs\n    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\n    // Draw order\n    if (!this.alphaTest) {\n      engine.setAlphaMode(this.alphaBlendingMode);\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n      engine.setAlphaMode(0);\n    } else {\n      engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    }\n    this.onAfterRenderObservable.notifyObservers(this);\n  }\n  /**\n   * Disposes and releases the associated resources.\n   */\n  dispose() {\n    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vertexBuffer) {\n      vertexBuffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n    if (this.texture) {\n      this.texture.dispose();\n      this.texture = null;\n    }\n    // Clean RTT list\n    this.renderTargetTextures = [];\n    // Remove from scene\n    const index = this._scene.layers.indexOf(this);\n    this._scene.layers.splice(index, 1);\n    // Callback\n    this.onDisposeObservable.notifyObservers(this);\n    this.onDisposeObservable.clear();\n    this.onAfterRenderObservable.clear();\n    this.onBeforeRenderObservable.clear();\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","Vector2","Color4","EngineStore","VertexBuffer","Material","Texture","SceneComponentConstants","LayerSceneComponent","DrawWrapper","Layer","constructor","name","imgUrl","scene","isBackground","color","texture","undefined","_scene","LastCreatedScene","layerComponent","_getComponent","NAME_LAYER","_addComponent","layers","push","engine","getEngine","_drawWrapper","vertices","vertexBuffer","PositionKind","_vertexBuffers","_createIndexBuffer","applyPostProcess","value","_applyPostProcess","onDispose","callback","_onDisposeObserver","onDisposeObservable","remove","add","onBeforeRender","_onBeforeRenderObserver","onBeforeRenderObservable","onAfterRender","_onAfterRenderObserver","onAfterRenderObservable","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","render","isEnabled","defines","alphaTest","gammaSpace","_previousDefines","effect","createEffect","currentEffect","isReady","notifyObservers","enableEffect","setState","setTexture","setMatrix","getTextureMatrix","setFloat4","r","g","b","a","setVector2","offset","scale","bindBuffers","setAlphaMode","alphaBlendingMode","drawElementsType","TriangleFillMode","dispose","_releaseBuffer","renderTargetTextures","index","indexOf","splice","clear"],"sourceRoot":"","sources":["../../../../lts/core/generated/Layers/layer.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { LayerSceneComponent } from \"./layerSceneComponent\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\n\r\nimport \"../Shaders/layer.fragment\";\r\nimport \"../Shaders/layer.vertex\";\r\n\r\n/**\r\n * This represents a full screen 2d layer.\r\n * This can be useful to display a picture in the  background of your scene for instance.\r\n * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n */\r\nexport class Layer {\r\n    /**\r\n     * Define the texture the layer should display.\r\n     */\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Is the layer in background or foreground.\r\n     */\r\n    public isBackground: boolean;\r\n\r\n    private _applyPostProcess: boolean = true;\r\n    /**\r\n     * Determines if the layer is drawn before (true) or after (false) post-processing.\r\n     * If the layer is background, it is always before.\r\n     */\r\n    public set applyPostProcess(value: boolean) {\r\n        this._applyPostProcess = value;\r\n    }\r\n    public get applyPostProcess(): boolean {\r\n        return this.isBackground || this._applyPostProcess;\r\n    }\r\n\r\n    /**\r\n     * Define the color of the layer (instead of texture).\r\n     */\r\n    public color: Color4;\r\n\r\n    /**\r\n     * Define the scale of the layer in order to zoom in out of the texture.\r\n     */\r\n    public scale = new Vector2(1, 1);\r\n\r\n    /**\r\n     * Define an offset for the layer in order to shift the texture.\r\n     */\r\n    public offset = new Vector2(0, 0);\r\n\r\n    /**\r\n     * Define the alpha blending mode used in the layer in case the texture or color has an alpha.\r\n     */\r\n    public alphaBlendingMode = Constants.ALPHA_COMBINE;\r\n\r\n    /**\r\n     * Define if the layer should alpha test or alpha blend with the rest of the scene.\r\n     * Alpha test will not mix with the background color in case of transparency.\r\n     * It will either use the texture color or the background depending on the alpha value of the current pixel.\r\n     */\r\n    public alphaTest: boolean;\r\n\r\n    /**\r\n     * Define a mask to restrict the layer to only some of the scene cameras.\r\n     */\r\n    public layerMask: number = 0x0fffffff;\r\n\r\n    /**\r\n     * Define the list of render target the layer is visible into.\r\n     */\r\n    public renderTargetTextures: RenderTargetTexture[] = [];\r\n\r\n    /**\r\n     * Define if the layer is only used in renderTarget or if it also\r\n     * renders in the main frame buffer of the canvas.\r\n     */\r\n    public renderOnlyInRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Define if the layer is enabled (ie. should be displayed). Default: true\r\n     */\r\n    public isEnabled = true;\r\n\r\n    private _scene: Scene;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _drawWrapper: DrawWrapper;\r\n    private _previousDefines: string;\r\n\r\n    /**\r\n     * An event triggered when the layer is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<Layer>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onDisposeObservable existed.\r\n     * The set callback will be triggered when the layer has been disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered before rendering the scene\r\n     */\r\n    public onBeforeRenderObservable = new Observable<Layer>();\r\n\r\n    private _onBeforeRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onBeforeRenderObservable existed.\r\n     * The set callback will be triggered just before rendering the layer.\r\n     */\r\n    public set onBeforeRender(callback: () => void) {\r\n        if (this._onBeforeRenderObserver) {\r\n            this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\r\n        }\r\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * An event triggered after rendering the scene\r\n     */\r\n    public onAfterRenderObservable = new Observable<Layer>();\r\n\r\n    private _onAfterRenderObserver: Nullable<Observer<Layer>>;\r\n    /**\r\n     * Back compatibility with callback before the onAfterRenderObservable existed.\r\n     * The set callback will be triggered just after rendering the layer.\r\n     */\r\n    public set onAfterRender(callback: () => void) {\r\n        if (this._onAfterRenderObserver) {\r\n            this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\r\n        }\r\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new layer.\r\n     * This represents a full screen 2d layer.\r\n     * This can be useful to display a picture in the  background of your scene for instance.\r\n     * @see https://www.babylonjs-playground.com/#08A2BS#1\r\n     * @param name Define the name of the layer in the scene\r\n     * @param imgUrl Define the url of the texture to display in the layer\r\n     * @param scene Define the scene the layer belongs to\r\n     * @param isBackground Defines whether the layer is displayed in front or behind the scene\r\n     * @param color Defines a color for the layer\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define the name of the layer.\r\n         */\r\n        public name: string,\r\n        imgUrl: Nullable<string>,\r\n        scene: Nullable<Scene>,\r\n        isBackground?: boolean,\r\n        color?: Color4\r\n    ) {\r\n        this.texture = imgUrl ? new Texture(imgUrl, scene, true) : null;\r\n        this.isBackground = isBackground === undefined ? true : isBackground;\r\n        this.color = color === undefined ? new Color4(1, 1, 1, 1) : color;\r\n\r\n        this._scene = <Scene>(scene || EngineStore.LastCreatedScene);\r\n        let layerComponent = this._scene._getComponent(SceneComponentConstants.NAME_LAYER) as LayerSceneComponent;\r\n        if (!layerComponent) {\r\n            layerComponent = new LayerSceneComponent(this._scene);\r\n            this._scene._addComponent(layerComponent);\r\n        }\r\n        this._scene.layers.push(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._drawWrapper = new DrawWrapper(engine);\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        const vertexBuffer = new VertexBuffer(engine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = vertexBuffer;\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * Renders the layer in the scene.\r\n     */\r\n    public render(): void {\r\n        if (!this.isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        let defines = \"\";\r\n\r\n        if (this.alphaTest) {\r\n            defines = \"#define ALPHATEST\";\r\n        }\r\n\r\n        if (this.texture && !this.texture.gammaSpace) {\r\n            defines += \"\\r\\n#define LINEAR\";\r\n        }\r\n\r\n        if (this._previousDefines !== defines) {\r\n            this._previousDefines = defines;\r\n            this._drawWrapper.effect = engine.createEffect(\"layer\", [VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], defines);\r\n        }\r\n        const currentEffect = this._drawWrapper.effect;\r\n\r\n        // Check\r\n        if (!currentEffect || !currentEffect.isReady() || !this.texture || !this.texture.isReady()) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeRenderObservable.notifyObservers(this);\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        engine.setState(false);\r\n\r\n        // Texture\r\n        currentEffect.setTexture(\"textureSampler\", this.texture);\r\n        currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\r\n\r\n        // Color\r\n        currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\r\n\r\n        // Scale / offset\r\n        currentEffect.setVector2(\"offset\", this.offset);\r\n        currentEffect.setVector2(\"scale\", this.scale);\r\n\r\n        // VBOs\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\r\n\r\n        // Draw order\r\n        if (!this.alphaTest) {\r\n            engine.setAlphaMode(this.alphaBlendingMode);\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        } else {\r\n            engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n        }\r\n\r\n        this.onAfterRenderObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Disposes and releases the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        if (this.texture) {\r\n            this.texture.dispose();\r\n            this.texture = null;\r\n        }\r\n\r\n        // Clean RTT list\r\n        this.renderTargetTextures = [];\r\n\r\n        // Remove from scene\r\n        const index = this._scene.layers.indexOf(this);\r\n        this._scene.layers.splice(index, 1);\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n\r\n        this.onDisposeObservable.clear();\r\n        this.onAfterRenderObservable.clear();\r\n        this.onBeforeRenderObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}