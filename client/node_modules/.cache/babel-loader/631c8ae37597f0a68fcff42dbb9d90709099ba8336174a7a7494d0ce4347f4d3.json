{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport \"../../Engines/Extensions/engine.cubeTexture.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/**\n * Class for creating a cube texture\n */\nexport class CubeTexture extends BaseTexture {\n  /**\n   * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\n   * as prefiltered data.\n   * @param rootUrl defines the url of the texture or the root name of the six images\n   * @param sceneOrEngine defines the scene or engine the texture is attached to\n   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n   * @param noMipmap defines if mipmaps should be created or not\n   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n   * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\n   * @param onError defines a callback triggered in case of error during load\n   * @param format defines the internal format to use for the texture once loaded\n   * @param prefiltered defines whether or not the texture is created from prefiltered data\n   * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @param loaderOptions options to be passed to the loader\n   * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\n   * @returns the cube texture\n   */\n  constructor(rootUrl, sceneOrEngine, extensions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = 0.8, lodOffset = 0, loaderOptions, useSRGBBuffer) {\n    var _a;\n    super(sceneOrEngine);\n    this._lodScale = 0.8;\n    this._lodOffset = 0;\n    /**\n     * Observable triggered once the texture has been loaded.\n     */\n    this.onLoadObservable = new Observable();\n    /**\n     * Gets or sets the center of the bounding box associated with the cube texture.\n     * It must define where the camera used to render the texture was set\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n     */\n    this.boundingBoxPosition = Vector3.Zero();\n    this._rotationY = 0;\n    /** @internal */\n    this._files = null;\n    this._forcedExtension = null;\n    this._extensions = null;\n    this.name = rootUrl;\n    this.url = rootUrl;\n    this._noMipmap = noMipmap;\n    this.hasAlpha = false;\n    this._format = format;\n    this.isCube = true;\n    this._textureMatrix = Matrix.Identity();\n    this._createPolynomials = createPolynomials;\n    this.coordinatesMode = Texture.CUBIC_MODE;\n    this._extensions = extensions;\n    this._files = files;\n    this._forcedExtension = forcedExtension;\n    this._loaderOptions = loaderOptions;\n    this._useSRGBBuffer = useSRGBBuffer;\n    this._lodScale = lodScale;\n    this._lodOffset = lodOffset;\n    if (!rootUrl && !files) {\n      return;\n    }\n    this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading, files);\n  }\n  /**\n   * Gets or sets the size of the bounding box associated with the cube texture\n   * When defined, the cubemap will switch to local mode\n   * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n   * @example https://www.babylonjs-playground.com/#RNASML\n   */\n  set boundingBoxSize(value) {\n    if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n      return;\n    }\n    this._boundingBoxSize = value;\n    const scene = this.getScene();\n    if (scene) {\n      scene.markAllMaterialsAsDirty(1);\n    }\n  }\n  /**\n   * Returns the bounding box size\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n   */\n  get boundingBoxSize() {\n    return this._boundingBoxSize;\n  }\n  /**\n   * Sets texture matrix rotation angle around Y axis in radians.\n   */\n  set rotationY(value) {\n    this._rotationY = value;\n    this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n  }\n  /**\n   * Gets texture matrix rotation angle around Y axis radians.\n   */\n  get rotationY() {\n    return this._rotationY;\n  }\n  /**\n   * Are mip maps generated for this texture or not.\n   */\n  get noMipmap() {\n    return this._noMipmap;\n  }\n  /**\n   * Gets the forced extension (if any)\n   */\n  get forcedExtension() {\n    return this._forcedExtension;\n  }\n  /**\n   * Creates a cube texture from an array of image urls\n   * @param files defines an array of image urls\n   * @param scene defines the hosting scene\n   * @param noMipmap specifies if mip maps are not used\n   * @returns a cube texture\n   */\n  static CreateFromImages(files, scene, noMipmap) {\n    let rootUrlKey = \"\";\n    files.forEach(url => rootUrlKey += url);\n    return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n  }\n  /**\n   * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\n   * @param url defines the url of the prefiltered texture\n   * @param scene defines the scene the texture is attached to\n   * @param forcedExtension defines the extension of the file if different from the url\n   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n   * @returns the prefiltered texture\n   */\n  static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {\n    const oldValue = scene.useDelayedTextureLoading;\n    scene.useDelayedTextureLoading = false;\n    const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n    scene.useDelayedTextureLoading = oldValue;\n    return result;\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"CubeTexture\"\n   */\n  getClassName() {\n    return \"CubeTexture\";\n  }\n  /**\n   * Update the url (and optional buffer) of this texture if url was null during construction.\n   * @param url the url of the texture\n   * @param forcedExtension defines the extension to use\n   * @param onLoad callback called when the texture is loaded  (defaults to null)\n   * @param prefiltered Defines whether the updated texture is prefiltered or not\n   * @param onError callback called if there was an error during the loading process (defaults to null)\n   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n   * @param delayLoad defines if the texture should be loaded now (false by default)\n   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n   */\n  updateURL(url, forcedExtension, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null) {\n    if (!this.name || this.name.startsWith(\"data:\")) {\n      this.name = url;\n    }\n    this.url = url;\n    if (forcedExtension) {\n      this._forcedExtension = forcedExtension;\n    }\n    const lastDot = url.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    const isDDS = extension.indexOf(\".dds\") === 0;\n    const isEnv = extension.indexOf(\".env\") === 0;\n    const isBasis = extension.indexOf(\".basis\") === 0;\n    if (isEnv) {\n      this.gammaSpace = false;\n      this._prefiltered = false;\n      this.anisotropicFilteringLevel = 1;\n    } else {\n      this._prefiltered = prefiltered;\n      if (prefiltered) {\n        this.gammaSpace = false;\n        this.anisotropicFilteringLevel = 1;\n      }\n    }\n    if (files) {\n      this._files = files;\n    } else {\n      if (!isBasis && !isEnv && !isDDS && !extensions) {\n        extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n      }\n      this._files = this._files || [];\n      this._files.length = 0;\n      if (extensions) {\n        for (let index = 0; index < extensions.length; index++) {\n          this._files.push(url + extensions[index]);\n        }\n        this._extensions = extensions;\n      }\n    }\n    if (delayLoad) {\n      this.delayLoadState = 4;\n      this._delayedOnLoad = onLoad;\n      this._delayedOnError = onError;\n    } else {\n      this._loadTexture(onLoad, onError);\n    }\n  }\n  /**\n   * Delays loading of the cube texture\n   * @param forcedExtension defines the extension to use\n   */\n  delayLoad(forcedExtension) {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n    if (forcedExtension) {\n      this._forcedExtension = forcedExtension;\n    }\n    this.delayLoadState = 1;\n    this._loadTexture(this._delayedOnLoad, this._delayedOnError);\n  }\n  /**\n   * Returns the reflection texture matrix\n   * @returns the reflection texture matrix\n   */\n  getReflectionTextureMatrix() {\n    return this._textureMatrix;\n  }\n  /**\n   * Sets the reflection texture matrix\n   * @param value Reflection texture matrix\n   */\n  setReflectionTextureMatrix(value) {\n    var _a;\n    if (value.updateFlag === this._textureMatrix.updateFlag) {\n      return;\n    }\n    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n      (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, mat => mat.getActiveTextures().indexOf(this) !== -1);\n    }\n    this._textureMatrix = value;\n  }\n  _loadTexture(onLoad = null, onError = null) {\n    var _a;\n    const scene = this.getScene();\n    const oldTexture = this._texture;\n    this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\n    const onLoadProcessing = () => {\n      var _a;\n      this.onLoadObservable.notifyObservers(this);\n      if (oldTexture) {\n        oldTexture.dispose();\n        (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1);\n      }\n      if (onLoad) {\n        onLoad();\n      }\n    };\n    const errorHandler = (message, exception) => {\n      this._loadingError = true;\n      this._errorObject = {\n        message,\n        exception\n      };\n      if (onError) {\n        onError(message, exception);\n      }\n      Texture.OnTextureLoadErrorObservable.notifyObservers(this);\n    };\n    if (!this._texture) {\n      if (this._prefiltered) {\n        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);\n      } else {\n        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer);\n      }\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\n    } else {\n      if (this._texture.isReady) {\n        Tools.SetImmediate(() => onLoadProcessing());\n      } else {\n        this._texture.onLoadedObservable.add(() => onLoadProcessing());\n      }\n    }\n  }\n  /**\n   * Parses text to create a cube texture\n   * @param parsedTexture define the serialized text to read from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url of the cube texture\n   * @returns a cube texture\n   */\n  static Parse(parsedTexture, scene, rootUrl) {\n    const texture = SerializationHelper.Parse(() => {\n      let prefiltered = false;\n      if (parsedTexture.prefiltered) {\n        prefiltered = parsedTexture.prefiltered;\n      }\n      return new CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n    }, parsedTexture, scene);\n    // Local Cubemaps\n    if (parsedTexture.boundingBoxPosition) {\n      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n    }\n    if (parsedTexture.boundingBoxSize) {\n      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n    }\n    // Animations\n    if (parsedTexture.animations) {\n      for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n        const parsedAnimation = parsedTexture.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          texture.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n    }\n    return texture;\n  }\n  /**\n   * Makes a clone, or deep copy, of the cube texture\n   * @returns a new cube texture\n   */\n  clone() {\n    let uniqueId = 0;\n    const newCubeTexture = SerializationHelper.Clone(() => {\n      const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);\n      uniqueId = cubeTexture.uniqueId;\n      return cubeTexture;\n    }, this);\n    newCubeTexture.uniqueId = uniqueId;\n    return newCubeTexture;\n  }\n}\n__decorate([serialize()], CubeTexture.prototype, \"url\", void 0);\n__decorate([serialize(\"rotationY\")], CubeTexture.prototype, \"rotationY\", null);\n__decorate([serialize(\"files\")], CubeTexture.prototype, \"_files\", void 0);\n__decorate([serialize(\"forcedExtension\")], CubeTexture.prototype, \"_forcedExtension\", void 0);\n__decorate([serialize(\"extensions\")], CubeTexture.prototype, \"_extensions\", void 0);\n__decorate([serializeAsMatrix(\"textureMatrix\")], CubeTexture.prototype, \"_textureMatrix\", void 0);\nTexture._CubeTextureParser = CubeTexture.Parse;\n// Some exporters relies on Tools.Instantiate\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsMatrix","SerializationHelper","Tools","Matrix","Vector3","BaseTexture","Texture","GetClass","RegisterClass","Observable","CubeTexture","constructor","rootUrl","sceneOrEngine","extensions","noMipmap","files","onLoad","onError","format","lodScale","Zero","name","url","_noMipmap","hasAlpha","_format","isCube","_textureMatrix","Identity","_createPolynomials","createPolynomials","coordinatesMode","CUBIC_MODE","_extensions","_files","_forcedExtension","forcedExtension","_loaderOptions","loaderOptions","_useSRGBBuffer","useSRGBBuffer","_lodScale","_lodOffset","lodOffset","updateURL","prefiltered","getScene","useDelayedTextureLoading","boundingBoxSize","value","_boundingBoxSize","equals","scene","markAllMaterialsAsDirty","rotationY","_rotationY","setReflectionTextureMatrix","RotationY","CreateFromImages","rootUrlKey","forEach","CreateFromPrefilteredData","oldValue","result","undefined","getClassName","delayLoad","startsWith","lastDot","lastIndexOf","extension","substring","toLowerCase","isDDS","indexOf","isEnv","isBasis","gammaSpace","_prefiltered","anisotropicFilteringLevel","length","index","push","delayLoadState","_delayedOnLoad","_delayedOnError","_loadTexture","getReflectionTextureMatrix","updateFlag","isIdentity","mat","oldTexture","_texture","_getFromCache","onLoadProcessing","onLoadObservable","notifyObservers","dispose","errorHandler","message","exception","_loadingError","_errorObject","OnTextureLoadErrorObservable","_getEngine","createPrefilteredCubeTexture","createCubeTexture","onLoadedObservable","add","isReady","SetImmediate","Parse","parsedTexture","texture","boundingBoxPosition","FromArray","animations","animationIndex","parsedAnimation","internalClass","clone","uniqueId","newCubeTexture","Clone","cubeTexture","__decorate","_CubeTextureParser"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/cubeTexture.ts"],"sourcesContent":["import { serialize, serializeAsMatrix, SerializationHelper } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\nimport \"../../Engines/Extensions/engine.cubeTexture\";\r\nimport { Observable } from \"../../Misc/observable\";\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number = 0.8;\r\n    private _lodOffset: number = 0;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    /** @internal */\r\n    @serialize(\"files\")\r\n    public _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        files.forEach((url) => (rootUrlKey += url));\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @returns the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @returns the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | ThinEngine,\r\n        extensions: Nullable<string[]> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = 0.8,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this._format = format;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this._createPolynomials = createPolynomials;\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n        this._extensions = extensions;\r\n        this._files = files;\r\n        this._forcedExtension = forcedExtension;\r\n        this._loaderOptions = loaderOptions;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._lodScale = lodScale;\r\n        this._lodOffset = lodOffset;\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension?: string,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null\r\n    ): void {\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n        const isBasis = extension.indexOf(\".basis\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + parsedTexture.name,\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}