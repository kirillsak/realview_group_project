{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { ShaderCodeNode } from \"./shaderCodeNode.js\";\nimport { ShaderCodeCursor } from \"./shaderCodeCursor.js\";\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode.js\";\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode.js\";\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator.js\";\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator.js\";\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator.js\";\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression.js\";\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator.js\";\nimport { _WarnImport } from \"../../Misc/devTools.js\";\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage.js\";\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\n/** @internal */\nexport class ShaderProcessor {\n  static Initialize(options) {\n    if (options.processor && options.processor.initializeShaders) {\n      options.processor.initializeShaders(options.processingContext);\n    }\n  }\n  static Process(sourceCode, options, callback, engine) {\n    var _a;\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n    this._ProcessIncludes(sourceCode, options, codeWithIncludes => {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n      const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\n      callback(migratedCode, codeWithIncludes);\n    });\n  }\n  static PreProcess(sourceCode, options, callback, engine) {\n    var _a;\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {\n      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\n    }\n    this._ProcessIncludes(sourceCode, options, codeWithIncludes => {\n      if (options.processCodeAfterIncludes) {\n        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\n      }\n      const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);\n      callback(migratedCode, codeWithIncludes);\n    });\n  }\n  static Finalize(vertexCode, fragmentCode, options) {\n    if (!options.processor || !options.processor.finalizeShaders) {\n      return {\n        vertexCode,\n        fragmentCode\n      };\n    }\n    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\n  }\n  static _ProcessPrecision(source, options) {\n    var _a;\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {\n      return source;\n    }\n    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\n    if (source.indexOf(\"precision highp float\") === -1) {\n      if (!shouldUseHighPrecisionShader) {\n        source = \"precision mediump float;\\n\" + source;\n      } else {\n        source = \"precision highp float;\\n\" + source;\n      }\n    } else {\n      if (!shouldUseHighPrecisionShader) {\n        // Moving highp to mediump\n        source = source.replace(\"precision highp float\", \"precision mediump float\");\n      }\n    }\n    return source;\n  }\n  static _ExtractOperation(expression) {\n    const regex = /defined\\((.+)\\)/;\n    const match = regex.exec(expression);\n    if (match && match.length) {\n      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\n    }\n    const operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\n    let operator = \"\";\n    let indexOperator = 0;\n    for (operator of operators) {\n      indexOperator = expression.indexOf(operator);\n      if (indexOperator > -1) {\n        break;\n      }\n    }\n    if (indexOperator === -1) {\n      return new ShaderDefineIsDefinedOperator(expression);\n    }\n    const define = expression.substring(0, indexOperator).trim();\n    const value = expression.substring(indexOperator + operator.length).trim();\n    return new ShaderDefineArithmeticOperator(define, operator, value);\n  }\n  static _BuildSubExpression(expression) {\n    expression = expression.replace(regexSE, \"defined[$1]\");\n    const postfix = ShaderDefineExpression.infixToPostfix(expression);\n    const stack = [];\n    for (const c of postfix) {\n      if (c !== \"||\" && c !== \"&&\") {\n        stack.push(c);\n      } else if (stack.length >= 2) {\n        let v1 = stack[stack.length - 1],\n          v2 = stack[stack.length - 2];\n        stack.length -= 2;\n        const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\n        if (typeof v1 === \"string\") {\n          v1 = v1.replace(regexSERevert, \"defined($1)\");\n        }\n        if (typeof v2 === \"string\") {\n          v2 = v2.replace(regexSERevert, \"defined($1)\");\n        }\n        operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\n        operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\n        stack.push(operator);\n      }\n    }\n    let result = stack[stack.length - 1];\n    if (typeof result === \"string\") {\n      result = result.replace(regexSERevert, \"defined($1)\");\n    }\n    // note: stack.length !== 1 if there was an error in the parsing\n    return typeof result === \"string\" ? this._ExtractOperation(result) : result;\n  }\n  static _BuildExpression(line, start) {\n    const node = new ShaderCodeTestNode();\n    const command = line.substring(0, start);\n    let expression = line.substring(start);\n    expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\n    if (command === \"#ifdef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression);\n    } else if (command === \"#ifndef\") {\n      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\n    } else {\n      node.testExpression = this._BuildSubExpression(expression);\n    }\n    return node;\n  }\n  static _MoveCursorWithinIf(cursor, rootNode, ifNode) {\n    let line = cursor.currentLine;\n    while (this._MoveCursor(cursor, ifNode)) {\n      line = cursor.currentLine;\n      const first5 = line.substring(0, 5).toLowerCase();\n      if (first5 === \"#else\") {\n        const elseNode = new ShaderCodeNode();\n        rootNode.children.push(elseNode);\n        this._MoveCursor(cursor, elseNode);\n        return;\n      } else if (first5 === \"#elif\") {\n        const elifNode = this._BuildExpression(line, 5);\n        rootNode.children.push(elifNode);\n        ifNode = elifNode;\n      }\n    }\n  }\n  static _MoveCursor(cursor, rootNode) {\n    while (cursor.canRead) {\n      cursor.lineIndex++;\n      const line = cursor.currentLine;\n      const keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\n      const matches = keywords.exec(line);\n      if (matches && matches.length) {\n        const keyword = matches[0];\n        switch (keyword) {\n          case \"#ifdef\":\n            {\n              const newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n              const ifNode = this._BuildExpression(line, 6);\n              newRootNode.children.push(ifNode);\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n              break;\n            }\n          case \"#else\":\n          case \"#elif\":\n            return true;\n          case \"#endif\":\n            return false;\n          case \"#ifndef\":\n            {\n              const newRootNode = new ShaderCodeConditionNode();\n              rootNode.children.push(newRootNode);\n              const ifNode = this._BuildExpression(line, 7);\n              newRootNode.children.push(ifNode);\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n              break;\n            }\n          case \"#if\":\n            {\n              const newRootNode = new ShaderCodeConditionNode();\n              const ifNode = this._BuildExpression(line, 3);\n              rootNode.children.push(newRootNode);\n              newRootNode.children.push(ifNode);\n              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\n              break;\n            }\n        }\n      } else {\n        const newNode = new ShaderCodeNode();\n        newNode.line = line;\n        rootNode.children.push(newNode);\n        // Detect additional defines\n        if (line[0] === \"#\" && line[1] === \"d\") {\n          const split = line.replace(\";\", \"\").split(\" \");\n          newNode.additionalDefineKey = split[1];\n          if (split.length === 3) {\n            newNode.additionalDefineValue = split[2];\n          }\n        }\n      }\n    }\n    return false;\n  }\n  static _EvaluatePreProcessors(sourceCode, preprocessors, options) {\n    const rootNode = new ShaderCodeNode();\n    const cursor = new ShaderCodeCursor();\n    cursor.lineIndex = -1;\n    cursor.lines = sourceCode.split(\"\\n\");\n    // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\n    this._MoveCursor(cursor, rootNode);\n    // Recompose\n    return rootNode.process(preprocessors, options);\n  }\n  static _PreparePreProcessors(options, engine) {\n    var _a;\n    const defines = options.defines;\n    const preprocessors = {};\n    for (const define of defines) {\n      const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\n      const split = keyValue.split(\" \");\n      preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\n    }\n    if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {\n      preprocessors[\"GL_ES\"] = \"true\";\n    }\n    preprocessors[\"__VERSION__\"] = options.version;\n    preprocessors[options.platformName] = \"true\";\n    engine._getGlobalDefines(preprocessors);\n    return preprocessors;\n  }\n  static _ProcessShaderConversion(sourceCode, options, engine) {\n    let preparedSourceCode = this._ProcessPrecision(sourceCode, options);\n    if (!options.processor) {\n      return preparedSourceCode;\n    }\n    // Already converted\n    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n      preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\n      if (!options.processor.parseGLES3) {\n        return preparedSourceCode;\n      }\n    }\n    const defines = options.defines;\n    const preprocessors = this._PreparePreProcessors(options, engine);\n    // General pre processing\n    if (options.processor.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\n    // Post processing\n    if (options.processor.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    }\n    // Inline functions tagged with #define inline\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n    return preparedSourceCode;\n  }\n  static _ApplyPreProcessing(sourceCode, options, engine) {\n    var _a, _b;\n    let preparedSourceCode = sourceCode;\n    const defines = options.defines;\n    const preprocessors = this._PreparePreProcessors(options, engine);\n    // General pre processing\n    if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {\n      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\n    }\n    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\n    // Post processing\n    if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {\n      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\n    }\n    // Inline functions tagged with #define inline\n    if (engine._features.needShaderCodeInlining) {\n      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\n    }\n    return preparedSourceCode;\n  }\n  static _ProcessIncludes(sourceCode, options, callback) {\n    let match = regexShaderInclude.exec(sourceCode);\n    let returnValue = new String(sourceCode);\n    let keepProcessing = false;\n    while (match != null) {\n      let includeFile = match[1];\n      // Uniform declaration\n      if (includeFile.indexOf(\"__decl__\") !== -1) {\n        includeFile = includeFile.replace(/__decl__/, \"\");\n        if (options.supportsUniformBuffers) {\n          includeFile = includeFile.replace(/Vertex/, \"Ubo\");\n          includeFile = includeFile.replace(/Fragment/, \"Ubo\");\n        }\n        includeFile = includeFile + \"Declaration\";\n      }\n      if (options.includesShadersStore[includeFile]) {\n        // Substitution\n        let includeContent = options.includesShadersStore[includeFile];\n        if (match[2]) {\n          const splits = match[3].split(\",\");\n          for (let index = 0; index < splits.length; index += 2) {\n            const source = new RegExp(splits[index], \"g\");\n            const dest = splits[index + 1];\n            includeContent = includeContent.replace(source, dest);\n          }\n        }\n        if (match[4]) {\n          const indexString = match[5];\n          if (indexString.indexOf(\"..\") !== -1) {\n            const indexSplits = indexString.split(\"..\");\n            const minIndex = parseInt(indexSplits[0]);\n            let maxIndex = parseInt(indexSplits[1]);\n            let sourceIncludeContent = includeContent.slice(0);\n            includeContent = \"\";\n            if (isNaN(maxIndex)) {\n              maxIndex = options.indexParameters[indexSplits[1]];\n            }\n            for (let i = minIndex; i < maxIndex; i++) {\n              if (!options.supportsUniformBuffers) {\n                // Ubo replacement\n                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, (str, p1) => {\n                  return p1 + \"{X}\";\n                });\n              }\n              includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\n            }\n          } else {\n            if (!options.supportsUniformBuffers) {\n              // Ubo replacement\n              includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, (str, p1) => {\n                return p1 + \"{X}\";\n              });\n            }\n            includeContent = includeContent.replace(/\\{X\\}/g, indexString);\n          }\n        }\n        // Replace\n        returnValue = returnValue.replace(match[0], includeContent);\n        keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\n      } else {\n        const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n        ShaderProcessor._FileToolsLoadFile(includeShaderUrl, fileContent => {\n          options.includesShadersStore[includeFile] = fileContent;\n          this._ProcessIncludes(returnValue, options, callback);\n        });\n        return;\n      }\n      match = regexShaderInclude.exec(sourceCode);\n    }\n    if (keepProcessing) {\n      this._ProcessIncludes(returnValue.toString(), options, callback);\n    } else {\n      callback(returnValue);\n    }\n  }\n  /**\n   * Loads a file from a url\n   * @param url url to load\n   * @param onSuccess callback called when the file successfully loads\n   * @param onProgress callback called while file is loading (if the server supports this mode)\n   * @param offlineProvider defines the offline provider for caching\n   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n   * @param onError callback called when the file fails to load\n   * @returns a file request object\n   * @internal\n   */\n  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {\n    throw _WarnImport(\"FileTools\");\n  }\n}","map":{"version":3,"mappings":"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","names":["ShaderCodeNode","ShaderCodeCursor","ShaderCodeConditionNode","ShaderCodeTestNode","ShaderDefineIsDefinedOperator","ShaderDefineOrOperator","ShaderDefineAndOperator","ShaderDefineExpression","ShaderDefineArithmeticOperator","_WarnImport","ShaderLanguage","regexSE","regexSERevert","regexShaderInclude","ShaderProcessor","Initialize","options","processor","initializeShaders","processingContext","Process","sourceCode","callback","engine","preProcessShaderCode","isFragment","_ProcessIncludes","codeWithIncludes","processCodeAfterIncludes","migratedCode","_ProcessShaderConversion","PreProcess","_ApplyPreProcessing","Finalize","vertexCode","fragmentCode","finalizeShaders","_ProcessPrecision","source","noPrecision","shouldUseHighPrecisionShader","indexOf","replace","_ExtractOperation","expression","regex","match","exec","length","trim","operators","operator","indexOperator","define","substring","value","_BuildSubExpression","postfix","infixToPostfix","stack","c","push","v1","v2","leftOperand","rightOperand","result","_BuildExpression","line","start","node","command","testExpression","_MoveCursorWithinIf","cursor","rootNode","ifNode","currentLine","_MoveCursor","first5","toLowerCase","elseNode","children","elifNode","canRead","lineIndex","keywords","matches","keyword","newRootNode","newNode","split","additionalDefineKey","additionalDefineValue","_EvaluatePreProcessors","preprocessors","lines","process","_PreparePreProcessors","defines","keyValue","shaderLanguage","GLSL","version","platformName","_getGlobalDefines","preparedSourceCode","parseGLES3","preProcessor","postProcessor","_features","needShaderCodeInlining","inlineShaderCode","returnValue","String","keepProcessing","includeFile","supportsUniformBuffers","includesShadersStore","includeContent","splits","index","RegExp","dest","indexString","indexSplits","minIndex","parseInt","maxIndex","sourceIncludeContent","slice","isNaN","indexParameters","i","str","p1","toString","includeShaderUrl","shadersRepository","_FileToolsLoadFile","fileContent","url","onSuccess","onProgress","offlineProvider","useArrayBuffer","onError"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Processors/shaderProcessor.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { ShaderCodeNode } from \"./shaderCodeNode\";\r\nimport { ShaderCodeCursor } from \"./shaderCodeCursor\";\r\nimport { ShaderCodeConditionNode } from \"./shaderCodeConditionNode\";\r\nimport { ShaderCodeTestNode } from \"./shaderCodeTestNode\";\r\nimport { ShaderDefineIsDefinedOperator } from \"./Expressions/Operators/shaderDefineIsDefinedOperator\";\r\nimport { ShaderDefineOrOperator } from \"./Expressions/Operators/shaderDefineOrOperator\";\r\nimport { ShaderDefineAndOperator } from \"./Expressions/Operators/shaderDefineAndOperator\";\r\nimport { ShaderDefineExpression } from \"./Expressions/shaderDefineExpression\";\r\nimport { ShaderDefineArithmeticOperator } from \"./Expressions/Operators/shaderDefineArithmeticOperator\";\r\nimport type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport { ShaderLanguage } from \"../../Materials/shaderLanguage\";\r\n\r\ndeclare type WebRequest = import(\"../../Misc/webRequest\").WebRequest;\r\ndeclare type LoadFileError = import(\"../../Misc/fileTools\").LoadFileError;\r\ndeclare type IOfflineProvider = import(\"../../Offline/IOfflineProvider\").IOfflineProvider;\r\ndeclare type IFileRequest = import(\"../../Misc/fileRequest\").IFileRequest;\r\ndeclare type ThinEngine = import(\"../thinEngine\").ThinEngine;\r\n\r\nconst regexSE = /defined\\s*?\\((.+?)\\)/g;\r\nconst regexSERevert = /defined\\s*?\\[(.+?)\\]/g;\r\nconst regexShaderInclude = /#include\\s?<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\r\n\r\n/** @internal */\r\nexport class ShaderProcessor {\r\n    public static Initialize(options: ProcessingOptions): void {\r\n        if (options.processor && options.processor.initializeShaders) {\r\n            options.processor.initializeShaders(options.processingContext);\r\n        }\r\n    }\r\n\r\n    public static Process(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: ThinEngine) {\r\n        if (options.processor?.preProcessShaderCode) {\r\n            sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n        }\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            if (options.processCodeAfterIncludes) {\r\n                codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\r\n            }\r\n            const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);\r\n            callback(migratedCode, codeWithIncludes);\r\n        });\r\n    }\r\n\r\n    public static PreProcess(sourceCode: string, options: ProcessingOptions, callback: (migratedCode: string, codeBeforeMigration: string) => void, engine: ThinEngine) {\r\n        if (options.processor?.preProcessShaderCode) {\r\n            sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);\r\n        }\r\n        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {\r\n            if (options.processCodeAfterIncludes) {\r\n                codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? \"fragment\" : \"vertex\", codeWithIncludes);\r\n            }\r\n            const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);\r\n            callback(migratedCode, codeWithIncludes);\r\n        });\r\n    }\r\n\r\n    public static Finalize(vertexCode: string, fragmentCode: string, options: ProcessingOptions): { vertexCode: string; fragmentCode: string } {\r\n        if (!options.processor || !options.processor.finalizeShaders) {\r\n            return { vertexCode, fragmentCode };\r\n        }\r\n\r\n        return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);\r\n    }\r\n\r\n    private static _ProcessPrecision(source: string, options: ProcessingOptions): string {\r\n        if (options.processor?.noPrecision) {\r\n            return source;\r\n        }\r\n\r\n        const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;\r\n\r\n        if (source.indexOf(\"precision highp float\") === -1) {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                source = \"precision mediump float;\\n\" + source;\r\n            } else {\r\n                source = \"precision highp float;\\n\" + source;\r\n            }\r\n        } else {\r\n            if (!shouldUseHighPrecisionShader) {\r\n                // Moving highp to mediump\r\n                source = source.replace(\"precision highp float\", \"precision mediump float\");\r\n            }\r\n        }\r\n\r\n        return source;\r\n    }\r\n\r\n    private static _ExtractOperation(expression: string) {\r\n        const regex = /defined\\((.+)\\)/;\r\n\r\n        const match = regex.exec(expression);\r\n\r\n        if (match && match.length) {\r\n            return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === \"!\");\r\n        }\r\n\r\n        const operators = [\"==\", \">=\", \"<=\", \"<\", \">\"];\r\n        let operator = \"\";\r\n        let indexOperator = 0;\r\n\r\n        for (operator of operators) {\r\n            indexOperator = expression.indexOf(operator);\r\n\r\n            if (indexOperator > -1) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (indexOperator === -1) {\r\n            return new ShaderDefineIsDefinedOperator(expression);\r\n        }\r\n\r\n        const define = expression.substring(0, indexOperator).trim();\r\n        const value = expression.substring(indexOperator + operator.length).trim();\r\n\r\n        return new ShaderDefineArithmeticOperator(define, operator, value);\r\n    }\r\n\r\n    private static _BuildSubExpression(expression: string): ShaderDefineExpression {\r\n        expression = expression.replace(regexSE, \"defined[$1]\");\r\n\r\n        const postfix = ShaderDefineExpression.infixToPostfix(expression);\r\n\r\n        const stack: (string | ShaderDefineExpression)[] = [];\r\n\r\n        for (const c of postfix) {\r\n            if (c !== \"||\" && c !== \"&&\") {\r\n                stack.push(c);\r\n            } else if (stack.length >= 2) {\r\n                let v1 = stack[stack.length - 1],\r\n                    v2 = stack[stack.length - 2];\r\n\r\n                stack.length -= 2;\r\n\r\n                const operator = c == \"&&\" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();\r\n\r\n                if (typeof v1 === \"string\") {\r\n                    v1 = v1.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                if (typeof v2 === \"string\") {\r\n                    v2 = v2.replace(regexSERevert, \"defined($1)\");\r\n                }\r\n\r\n                operator.leftOperand = typeof v2 === \"string\" ? this._ExtractOperation(v2) : v2;\r\n                operator.rightOperand = typeof v1 === \"string\" ? this._ExtractOperation(v1) : v1;\r\n\r\n                stack.push(operator);\r\n            }\r\n        }\r\n\r\n        let result = stack[stack.length - 1];\r\n\r\n        if (typeof result === \"string\") {\r\n            result = result.replace(regexSERevert, \"defined($1)\");\r\n        }\r\n\r\n        // note: stack.length !== 1 if there was an error in the parsing\r\n\r\n        return typeof result === \"string\" ? this._ExtractOperation(result) : result;\r\n    }\r\n\r\n    private static _BuildExpression(line: string, start: number): ShaderCodeTestNode {\r\n        const node = new ShaderCodeTestNode();\r\n        const command = line.substring(0, start);\r\n        let expression = line.substring(start);\r\n\r\n        expression = expression.substring(0, (expression.indexOf(\"//\") + 1 || expression.length + 1) - 1).trim();\r\n\r\n        if (command === \"#ifdef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression);\r\n        } else if (command === \"#ifndef\") {\r\n            node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);\r\n        } else {\r\n            node.testExpression = this._BuildSubExpression(expression);\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private static _MoveCursorWithinIf(cursor: ShaderCodeCursor, rootNode: ShaderCodeConditionNode, ifNode: ShaderCodeNode) {\r\n        let line = cursor.currentLine;\r\n        while (this._MoveCursor(cursor, ifNode)) {\r\n            line = cursor.currentLine;\r\n            const first5 = line.substring(0, 5).toLowerCase();\r\n\r\n            if (first5 === \"#else\") {\r\n                const elseNode = new ShaderCodeNode();\r\n                rootNode.children.push(elseNode);\r\n                this._MoveCursor(cursor, elseNode);\r\n                return;\r\n            } else if (first5 === \"#elif\") {\r\n                const elifNode = this._BuildExpression(line, 5);\r\n\r\n                rootNode.children.push(elifNode);\r\n                ifNode = elifNode;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _MoveCursor(cursor: ShaderCodeCursor, rootNode: ShaderCodeNode): boolean {\r\n        while (cursor.canRead) {\r\n            cursor.lineIndex++;\r\n            const line = cursor.currentLine;\r\n            const keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;\r\n            const matches = keywords.exec(line);\r\n\r\n            if (matches && matches.length) {\r\n                const keyword = matches[0];\r\n\r\n                switch (keyword) {\r\n                    case \"#ifdef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = this._BuildExpression(line, 6);\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#else\":\r\n                    case \"#elif\":\r\n                        return true;\r\n                    case \"#endif\":\r\n                        return false;\r\n                    case \"#ifndef\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        const ifNode = this._BuildExpression(line, 7);\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                    case \"#if\": {\r\n                        const newRootNode = new ShaderCodeConditionNode();\r\n                        const ifNode = this._BuildExpression(line, 3);\r\n                        rootNode.children.push(newRootNode);\r\n\r\n                        newRootNode.children.push(ifNode);\r\n                        this._MoveCursorWithinIf(cursor, newRootNode, ifNode);\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                const newNode = new ShaderCodeNode();\r\n                newNode.line = line;\r\n                rootNode.children.push(newNode);\r\n\r\n                // Detect additional defines\r\n                if (line[0] === \"#\" && line[1] === \"d\") {\r\n                    const split = line.replace(\";\", \"\").split(\" \");\r\n                    newNode.additionalDefineKey = split[1];\r\n\r\n                    if (split.length === 3) {\r\n                        newNode.additionalDefineValue = split[2];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private static _EvaluatePreProcessors(sourceCode: string, preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        const rootNode = new ShaderCodeNode();\r\n        const cursor = new ShaderCodeCursor();\r\n\r\n        cursor.lineIndex = -1;\r\n        cursor.lines = sourceCode.split(\"\\n\");\r\n\r\n        // Decompose (We keep it in 2 steps so it is easier to maintain and perf hit is insignificant)\r\n        this._MoveCursor(cursor, rootNode);\r\n\r\n        // Recompose\r\n        return rootNode.process(preprocessors, options);\r\n    }\r\n\r\n    private static _PreparePreProcessors(options: ProcessingOptions, engine: ThinEngine): { [key: string]: string } {\r\n        const defines = options.defines;\r\n        const preprocessors: { [key: string]: string } = {};\r\n\r\n        for (const define of defines) {\r\n            const keyValue = define.replace(\"#define\", \"\").replace(\";\", \"\").trim();\r\n            const split = keyValue.split(\" \");\r\n            preprocessors[split[0]] = split.length > 1 ? split[1] : \"\";\r\n        }\r\n\r\n        if (options.processor?.shaderLanguage === ShaderLanguage.GLSL) {\r\n            preprocessors[\"GL_ES\"] = \"true\";\r\n        }\r\n        preprocessors[\"__VERSION__\"] = options.version;\r\n        preprocessors[options.platformName] = \"true\";\r\n\r\n        engine._getGlobalDefines(preprocessors);\r\n\r\n        return preprocessors;\r\n    }\r\n\r\n    private static _ProcessShaderConversion(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n        let preparedSourceCode = this._ProcessPrecision(sourceCode, options);\r\n\r\n        if (!options.processor) {\r\n            return preparedSourceCode;\r\n        }\r\n\r\n        // Already converted\r\n        if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf(\"#version 3\") !== -1) {\r\n            preparedSourceCode = preparedSourceCode.replace(\"#version 300 es\", \"\");\r\n            if (!options.processor.parseGLES3) {\r\n                return preparedSourceCode;\r\n            }\r\n        }\r\n\r\n        const defines = options.defines;\r\n\r\n        const preprocessors = this._PreparePreProcessors(options, engine);\r\n\r\n        // General pre processing\r\n        if (options.processor.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\r\n        }\r\n\r\n        // Inline functions tagged with #define inline\r\n        if (engine._features.needShaderCodeInlining) {\r\n            preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    private static _ApplyPreProcessing(sourceCode: string, options: ProcessingOptions, engine: ThinEngine): string {\r\n        let preparedSourceCode = sourceCode;\r\n\r\n        const defines = options.defines;\r\n\r\n        const preprocessors = this._PreparePreProcessors(options, engine);\r\n\r\n        // General pre processing\r\n        if (options.processor?.preProcessor) {\r\n            preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);\r\n        }\r\n\r\n        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);\r\n\r\n        // Post processing\r\n        if (options.processor?.postProcessor) {\r\n            preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);\r\n        }\r\n\r\n        // Inline functions tagged with #define inline\r\n        if (engine._features.needShaderCodeInlining) {\r\n            preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);\r\n        }\r\n\r\n        return preparedSourceCode;\r\n    }\r\n\r\n    private static _ProcessIncludes(sourceCode: string, options: ProcessingOptions, callback: (data: any) => void): void {\r\n        let match = regexShaderInclude.exec(sourceCode);\r\n\r\n        let returnValue = new String(sourceCode);\r\n        let keepProcessing = false;\r\n\r\n        while (match != null) {\r\n            let includeFile = match[1];\r\n\r\n            // Uniform declaration\r\n            if (includeFile.indexOf(\"__decl__\") !== -1) {\r\n                includeFile = includeFile.replace(/__decl__/, \"\");\r\n                if (options.supportsUniformBuffers) {\r\n                    includeFile = includeFile.replace(/Vertex/, \"Ubo\");\r\n                    includeFile = includeFile.replace(/Fragment/, \"Ubo\");\r\n                }\r\n                includeFile = includeFile + \"Declaration\";\r\n            }\r\n\r\n            if (options.includesShadersStore[includeFile]) {\r\n                // Substitution\r\n                let includeContent = options.includesShadersStore[includeFile];\r\n                if (match[2]) {\r\n                    const splits = match[3].split(\",\");\r\n\r\n                    for (let index = 0; index < splits.length; index += 2) {\r\n                        const source = new RegExp(splits[index], \"g\");\r\n                        const dest = splits[index + 1];\r\n\r\n                        includeContent = includeContent.replace(source, dest);\r\n                    }\r\n                }\r\n\r\n                if (match[4]) {\r\n                    const indexString = match[5];\r\n\r\n                    if (indexString.indexOf(\"..\") !== -1) {\r\n                        const indexSplits = indexString.split(\"..\");\r\n                        const minIndex = parseInt(indexSplits[0]);\r\n                        let maxIndex = parseInt(indexSplits[1]);\r\n                        let sourceIncludeContent = includeContent.slice(0);\r\n                        includeContent = \"\";\r\n\r\n                        if (isNaN(maxIndex)) {\r\n                            maxIndex = options.indexParameters[indexSplits[1]];\r\n                        }\r\n\r\n                        for (let i = minIndex; i < maxIndex; i++) {\r\n                            if (!options.supportsUniformBuffers) {\r\n                                // Ubo replacement\r\n                                sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, (str: string, p1: string) => {\r\n                                    return p1 + \"{X}\";\r\n                                });\r\n                            }\r\n                            includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i.toString()) + \"\\n\";\r\n                        }\r\n                    } else {\r\n                        if (!options.supportsUniformBuffers) {\r\n                            // Ubo replacement\r\n                            includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, (str: string, p1: string) => {\r\n                                return p1 + \"{X}\";\r\n                            });\r\n                        }\r\n                        includeContent = includeContent.replace(/\\{X\\}/g, indexString);\r\n                    }\r\n                }\r\n\r\n                // Replace\r\n                returnValue = returnValue.replace(match[0], includeContent);\r\n\r\n                keepProcessing = keepProcessing || includeContent.indexOf(\"#include<\") >= 0 || includeContent.indexOf(\"#include <\") >= 0;\r\n            } else {\r\n                const includeShaderUrl = options.shadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\r\n\r\n                ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {\r\n                    options.includesShadersStore[includeFile] = fileContent as string;\r\n                    this._ProcessIncludes(<string>returnValue, options, callback);\r\n                });\r\n                return;\r\n            }\r\n\r\n            match = regexShaderInclude.exec(sourceCode);\r\n        }\r\n\r\n        if (keepProcessing) {\r\n            this._ProcessIncludes(returnValue.toString(), options, callback);\r\n        } else {\r\n            callback(returnValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a file from a url\r\n     * @param url url to load\r\n     * @param onSuccess callback called when the file successfully loads\r\n     * @param onProgress callback called while file is loading (if the server supports this mode)\r\n     * @param offlineProvider defines the offline provider for caching\r\n     * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\r\n     * @param onError callback called when the file fails to load\r\n     * @returns a file request object\r\n     * @internal\r\n     */\r\n    public static _FileToolsLoadFile(\r\n        url: string,\r\n        onSuccess: (data: string | ArrayBuffer, responseURL?: string) => void,\r\n        onProgress?: (ev: ProgressEvent) => void,\r\n        offlineProvider?: IOfflineProvider,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void\r\n    ): IFileRequest {\r\n        throw _WarnImport(\"FileTools\");\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}