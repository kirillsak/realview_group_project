{"ast":null,"code":"import { ThinEngine } from \"../../Engines/thinEngine.js\";\n\n/**\n * Allocate a typed array depending on a texture type. Optionally can copy existing data in the buffer.\n * @param type type of the texture\n * @param sizeOrDstBuffer size of the array OR an existing buffer that will be used as the destination of the copy (if copyBuffer is provided)\n * @param sizeInBytes true if the size of the array is given in bytes, false if it is the number of elements of the array\n * @param copyBuffer if provided, buffer to copy into the destination buffer (either a newly allocated buffer if sizeOrDstBuffer is a number or use sizeOrDstBuffer as the destination buffer otherwise)\n * @returns the allocated buffer or sizeOrDstBuffer if the latter is an ArrayBuffer\n */\nexport function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes = false, copyBuffer) {\n  switch (type) {\n    case 3:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Int8Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 0:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Uint8Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 4:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Int16Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 5:\n    case 8:\n    case 9:\n    case 10:\n    case 2:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Uint16Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 6:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Int32Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 7:\n    case 11:\n    case 12:\n    case 13:\n    case 14:\n    case 15:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Uint32Array(copyBuffer));\n        }\n        return buffer;\n      }\n    case 1:\n      {\n        const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\n        if (copyBuffer) {\n          buffer.set(new Float32Array(copyBuffer));\n        }\n        return buffer;\n      }\n  }\n  const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\n  if (copyBuffer) {\n    buffer.set(new Uint8Array(copyBuffer));\n  }\n  return buffer;\n}\nThinEngine.prototype._readTexturePixelsSync = function (texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {\n  var _a, _b;\n  const gl = this._gl;\n  if (!gl) {\n    throw new Error(\"Engine does not have gl rendering context.\");\n  }\n  if (!this._dummyFramebuffer) {\n    const dummy = gl.createFramebuffer();\n    if (!dummy) {\n      throw new Error(\"Unable to create dummy framebuffer\");\n    }\n    this._dummyFramebuffer = dummy;\n  }\n  gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);\n  if (faceIndex > -1) {\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level);\n  } else {\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b = texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, level);\n  }\n  let readType = texture.type !== undefined ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;\n  if (!noDataConversion) {\n    switch (readType) {\n      case gl.UNSIGNED_BYTE:\n        if (!buffer) {\n          buffer = new Uint8Array(4 * width * height);\n        }\n        readType = gl.UNSIGNED_BYTE;\n        break;\n      default:\n        if (!buffer) {\n          buffer = new Float32Array(4 * width * height);\n        }\n        readType = gl.FLOAT;\n        break;\n    }\n  } else if (!buffer) {\n    buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);\n  }\n  if (flushRenderer) {\n    this.flushFramebuffer();\n  }\n  gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);\n  return buffer;\n};\nThinEngine.prototype._readTexturePixels = function (texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {\n  return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));\n};","map":{"version":3,"mappings":"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","names":["ThinEngine","allocateAndCopyTypedBuffer","type","sizeOrDstBuffer","sizeInBytes","copyBuffer","buffer","ArrayBuffer","Int8Array","set","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","prototype","_readTexturePixelsSync","texture","width","height","faceIndex","level","flushRenderer","noDataConversion","x","y","gl","_gl","Error","_dummyFramebuffer","dummy","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","TEXTURE_CUBE_MAP_POSITIVE_X","_hardwareTexture","underlyingResource","TEXTURE_2D","readType","undefined","_getWebGLTextureType","UNSIGNED_BYTE","FLOAT","flushFramebuffer","readPixels","RGBA","_currentFramebuffer","_readTexturePixels","Promise","resolve"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Extensions/engine.readTexture.ts"],"sourcesContent":["import { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /** @internal */\r\n        _readTexturePixels(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): Promise<ArrayBufferView>;\r\n\r\n        /** @internal */\r\n        _readTexturePixelsSync(\r\n            texture: InternalTexture,\r\n            width: number,\r\n            height: number,\r\n            faceIndex?: number,\r\n            level?: number,\r\n            buffer?: Nullable<ArrayBufferView>,\r\n            flushRenderer?: boolean,\r\n            noDataConversion?: boolean,\r\n            x?: number,\r\n            y?: number\r\n        ): ArrayBufferView;\r\n    }\r\n}\r\n\r\n/**\r\n * Allocate a typed array depending on a texture type. Optionally can copy existing data in the buffer.\r\n * @param type type of the texture\r\n * @param sizeOrDstBuffer size of the array OR an existing buffer that will be used as the destination of the copy (if copyBuffer is provided)\r\n * @param sizeInBytes true if the size of the array is given in bytes, false if it is the number of elements of the array\r\n * @param copyBuffer if provided, buffer to copy into the destination buffer (either a newly allocated buffer if sizeOrDstBuffer is a number or use sizeOrDstBuffer as the destination buffer otherwise)\r\n * @returns the allocated buffer or sizeOrDstBuffer if the latter is an ArrayBuffer\r\n */\r\nexport function allocateAndCopyTypedBuffer(type: number, sizeOrDstBuffer: number | ArrayBuffer, sizeInBytes = false, copyBuffer?: ArrayBuffer): ArrayBufferView {\r\n    switch (type) {\r\n        case Constants.TEXTURETYPE_BYTE: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint8Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_SHORT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1:\r\n        case Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5:\r\n        case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint16Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_INT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Int32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_UNSIGNED_INTEGER:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_24_8:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV:\r\n        case Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV:\r\n        case Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Uint32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n        case Constants.TEXTURETYPE_FLOAT: {\r\n            const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);\r\n            if (copyBuffer) {\r\n                buffer.set(new Float32Array(copyBuffer));\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);\r\n    if (copyBuffer) {\r\n        buffer.set(new Uint8Array(copyBuffer));\r\n    }\r\n    return buffer;\r\n}\r\n\r\nThinEngine.prototype._readTexturePixelsSync = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): ArrayBufferView {\r\n    const gl = this._gl;\r\n    if (!gl) {\r\n        throw new Error(\"Engine does not have gl rendering context.\");\r\n    }\r\n    if (!this._dummyFramebuffer) {\r\n        const dummy = gl.createFramebuffer();\r\n\r\n        if (!dummy) {\r\n            throw new Error(\"Unable to create dummy framebuffer\");\r\n        }\r\n\r\n        this._dummyFramebuffer = dummy;\r\n    }\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);\r\n\r\n    if (faceIndex > -1) {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture._hardwareTexture?.underlyingResource, level);\r\n    } else {\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture?.underlyingResource, level);\r\n    }\r\n\r\n    let readType = texture.type !== undefined ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;\r\n\r\n    if (!noDataConversion) {\r\n        switch (readType) {\r\n            case gl.UNSIGNED_BYTE:\r\n                if (!buffer) {\r\n                    buffer = new Uint8Array(4 * width * height);\r\n                }\r\n                readType = gl.UNSIGNED_BYTE;\r\n                break;\r\n            default:\r\n                if (!buffer) {\r\n                    buffer = new Float32Array(4 * width * height);\r\n                }\r\n                readType = gl.FLOAT;\r\n                break;\r\n        }\r\n    } else if (!buffer) {\r\n        buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);\r\n    }\r\n\r\n    if (flushRenderer) {\r\n        this.flushFramebuffer();\r\n    }\r\n\r\n    gl.readPixels(x, y, width, height, gl.RGBA, readType, <DataView>buffer);\r\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);\r\n\r\n    return buffer;\r\n};\r\n\r\nThinEngine.prototype._readTexturePixels = function (\r\n    texture: InternalTexture,\r\n    width: number,\r\n    height: number,\r\n    faceIndex = -1,\r\n    level = 0,\r\n    buffer: Nullable<ArrayBufferView> = null,\r\n    flushRenderer = true,\r\n    noDataConversion = false,\r\n    x = 0,\r\n    y = 0\r\n): Promise<ArrayBufferView> {\r\n    return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}