{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Vector2, Vector3 } from \"../Maths/math.vector.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Effect } from \"../Materials/effect.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/spriteMap.fragment.js\";\nimport \"../Shaders/spriteMap.vertex.js\";\n/**\n * Class used to manage a grid restricted sprite deployment on an Output plane.\n */\nexport class SpriteMap {\n  /**\n   * Creates a new SpriteMap\n   * @param name defines the SpriteMaps Name\n   * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\n   * @param spriteSheet is the Texture that the Sprites are on.\n   * @param options a basic deployment configuration\n   * @param scene The Scene that the map is deployed on\n   */\n  constructor(name, atlasJSON, spriteSheet, options, scene) {\n    this.name = name;\n    this.sprites = [];\n    this.atlasJSON = atlasJSON;\n    this.sprites = this.atlasJSON[\"frames\"];\n    this.spriteSheet = spriteSheet;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n    this.options = options;\n    options.stageSize = options.stageSize || new Vector2(1, 1);\n    options.outputSize = options.outputSize || options.stageSize;\n    options.outputPosition = options.outputPosition || Vector3.Zero();\n    options.outputRotation = options.outputRotation || Vector3.Zero();\n    options.layerCount = options.layerCount || 1;\n    options.maxAnimationFrames = options.maxAnimationFrames || 0;\n    options.baseTile = options.baseTile || 0;\n    options.flipU = options.flipU || false;\n    options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\n    this._scene = scene;\n    this._frameMap = this._createFrameBuffer();\n    this._tileMaps = new Array();\n    for (let i = 0; i < options.layerCount; i++) {\n      this._tileMaps.push(this._createTileBuffer(null, i));\n    }\n    this._animationMap = this._createTileAnimationBuffer(null);\n    const defines = [];\n    defines.push(\"#define LAYERS \" + options.layerCount);\n    if (options.flipU) {\n      defines.push(\"#define FLIPU\");\n    }\n    defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\n    const shaderString = Effect.ShadersStore[\"spriteMapPixelShader\"];\n    let layerSampleString;\n    if (!scene.getEngine()._features.supportSwitchCaseInShader) {\n      layerSampleString = \"\";\n      for (let i = 0; i < options.layerCount; i++) {\n        layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\n      }\n    } else {\n      layerSampleString = \"switch(i) {\";\n      for (let i = 0; i < options.layerCount; i++) {\n        layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\n        layerSampleString += \"break;\";\n      }\n      layerSampleString += \"}\";\n    }\n    Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\n    this._material = new ShaderMaterial(\"spriteMap:\" + this.name, this._scene, {\n      vertex: \"spriteMap\",\n      fragment: \"spriteMap\" + this.name\n    }, {\n      defines,\n      attributes: [\"position\", \"normal\", \"uv\"],\n      uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\n      samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\n      needAlphaBlending: true\n    });\n    this._time = 0;\n    this._material.setFloat(\"spriteCount\", this.spriteCount);\n    this._material.setVector2(\"stageSize\", options.stageSize);\n    this._material.setVector2(\"outputSize\", options.outputSize);\n    this._material.setTexture(\"spriteSheet\", this.spriteSheet);\n    this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n    let tickSave = 0;\n    const bindSpriteTexture = () => {\n      if (this.spriteSheet && this.spriteSheet.isReady()) {\n        if (this.spriteSheet._texture) {\n          this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\n          return;\n        }\n      }\n      if (tickSave < 100) {\n        setTimeout(() => {\n          tickSave++;\n          bindSpriteTexture();\n        }, 100);\n      }\n    };\n    bindSpriteTexture();\n    this._material.setVector3(\"colorMul\", options.colorMultiply);\n    this._material.setTexture(\"frameMap\", this._frameMap);\n    this._material.setTextureArray(\"tileMaps\", this._tileMaps);\n    this._material.setTexture(\"animationMap\", this._animationMap);\n    this._material.setFloat(\"time\", this._time);\n    this._output = CreatePlane(name + \":output\", {\n      size: 1,\n      updatable: true\n    }, scene);\n    this._output.scaling.x = options.outputSize.x;\n    this._output.scaling.y = options.outputSize.y;\n    this.position = options.outputPosition;\n    this.rotation = options.outputRotation;\n    const obfunction = () => {\n      this._time += this._scene.getEngine().getDeltaTime();\n      this._material.setFloat(\"time\", this._time);\n    };\n    this._scene.onBeforeRenderObservable.add(obfunction);\n    this._output.material = this._material;\n  }\n  /** Returns the Number of Sprites in the System */\n  get spriteCount() {\n    return this.sprites.length;\n  }\n  /** Returns the Position of Output Plane*/\n  get position() {\n    return this._output.position;\n  }\n  /** Returns the Position of Output Plane*/\n  set position(v) {\n    this._output.position = v;\n  }\n  /** Returns the Rotation of Output Plane*/\n  get rotation() {\n    return this._output.rotation;\n  }\n  /** Returns the Rotation of Output Plane*/\n  set rotation(v) {\n    this._output.rotation = v;\n  }\n  /** Sets the AnimationMap*/\n  get animationMap() {\n    return this._animationMap;\n  }\n  /** Sets the AnimationMap*/\n  set animationMap(v) {\n    const buffer = v._texture._bufferView;\n    const am = this._createTileAnimationBuffer(buffer);\n    this._animationMap.dispose();\n    this._animationMap = am;\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  }\n  /**\n   * Returns tileID location\n   * @returns Vector2 the cell position ID\n   */\n  getTileID() {\n    const p = this.getMousePosition();\n    p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\n    p.x = Math.floor(p.x);\n    p.y = Math.floor(p.y);\n    return p;\n  }\n  /**\n   * Gets the UV location of the mouse over the SpriteMap.\n   * @returns Vector2 the UV position of the mouse interaction\n   */\n  getMousePosition() {\n    const out = this._output;\n    const pickinfo = this._scene.pick(this._scene.pointerX, this._scene.pointerY, mesh => {\n      if (mesh !== out) {\n        return false;\n      }\n      return true;\n    });\n    if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\n      return new Vector2(-1, -1);\n    }\n    const coords = pickinfo.getTextureCoordinates();\n    if (coords) {\n      return coords;\n    }\n    return new Vector2(-1, -1);\n  }\n  /**\n   * Creates the \"frame\" texture Buffer\n   * -------------------------------------\n   * Structure of frames\n   *  \"filename\": \"Falling-Water-2.png\",\n   * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\n   * \"rotated\": true,\n   * \"trimmed\": true,\n   * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\n   * \"sourceSize\": {\"w\":32,\"h\":32}\n   * @returns RawTexture of the frameMap\n   */\n  _createFrameBuffer() {\n    const data = new Array();\n    //Do two Passes\n    for (let i = 0; i < this.spriteCount; i++) {\n      data.push(0, 0, 0, 0); //frame\n      data.push(0, 0, 0, 0); //spriteSourceSize\n      data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\n      data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\n    }\n    //Second Pass\n    for (let i = 0; i < this.spriteCount; i++) {\n      const f = this.sprites[i][\"frame\"];\n      const sss = this.sprites[i][\"spriteSourceSize\"];\n      const ss = this.sprites[i][\"sourceSize\"];\n      const r = this.sprites[i][\"rotated\"] ? 1 : 0;\n      const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\n      //frame\n      data[i * 4] = f.x;\n      data[i * 4 + 1] = f.y;\n      data[i * 4 + 2] = f.w;\n      data[i * 4 + 3] = f.h;\n      //spriteSourceSize\n      data[i * 4 + this.spriteCount * 4] = sss.x;\n      data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\n      data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\n      //sourceSize, rotated, trimmed\n      data[i * 4 + this.spriteCount * 8] = ss.w;\n      data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\n      data[i * 4 + 2 + this.spriteCount * 8] = r;\n      data[i * 4 + 3 + this.spriteCount * 8] = t;\n    }\n    const floatArray = new Float32Array(data);\n    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Creates the tileMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\n   * @returns RawTexture of the tileMap\n   */\n  _createTileBuffer(buffer, _layer = 0) {\n    let data = new Array();\n    const _ty = this.options.stageSize.y || 0;\n    const _tx = this.options.stageSize.x || 0;\n    if (!buffer) {\n      let bt = this.options.baseTile;\n      if (_layer != 0) {\n        bt = 0;\n      }\n      for (let y = 0; y < _ty; y++) {\n        for (let x = 0; x < _tx * 4; x += 4) {\n          data.push(bt, 0, 0, 0);\n        }\n      }\n    } else {\n      data = buffer;\n    }\n    const floatArray = new Float32Array(data);\n    const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Modifies the data of the tileMaps\n   * @param _layer is the ID of the layer you want to edit on the SpriteMap\n   * @param pos is the iVector2 Coordinates of the Tile\n   * @param tile The SpriteIndex of the new Tile\n   */\n  changeTiles(_layer = 0, pos, tile = 0) {\n    const buffer = this._tileMaps[_layer]._texture._bufferView;\n    if (buffer === null) {\n      return;\n    }\n    let p = new Array();\n    if (pos instanceof Vector2) {\n      p.push(pos);\n    } else {\n      p = pos;\n    }\n    const _tx = this.options.stageSize.x || 0;\n    for (let i = 0; i < p.length; i++) {\n      const _p = p[i];\n      _p.x = Math.floor(_p.x);\n      _p.y = Math.floor(_p.y);\n      const id = _p.x * 4 + _p.y * (_tx * 4);\n      buffer[id] = tile;\n    }\n    const t = this._createTileBuffer(buffer);\n    this._tileMaps[_layer].dispose();\n    this._tileMaps[_layer] = t;\n    this._material.setTextureArray(\"tileMap\", this._tileMaps);\n  }\n  /**\n   * Creates the animationMap texture Buffer\n   * @param buffer normally and array of numbers, or a false to generate from scratch\n   * @returns RawTexture of the animationMap\n   */\n  _createTileAnimationBuffer(buffer) {\n    const data = new Array();\n    let floatArray;\n    if (!buffer) {\n      for (let i = 0; i < this.spriteCount; i++) {\n        data.push(0, 0, 0, 0);\n        let count = 1;\n        while (count < (this.options.maxAnimationFrames || 4)) {\n          data.push(0, 0, 0, 0);\n          count++;\n        }\n      }\n      floatArray = new Float32Array(data);\n    } else {\n      floatArray = buffer;\n    }\n    const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, this.options.maxAnimationFrames || 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\n    return t;\n  }\n  /**\n   * Modifies the data of the animationMap\n   * @param cellID is the Index of the Sprite\n   * @param _frame is the target Animation frame\n   * @param toCell is the Target Index of the next frame of the animation\n   * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\n   * @param speed is a global scalar of the time variable on the map.\n   */\n  addAnimationToTile(cellID = 0, _frame = 0, toCell = 0, time = 0, speed = 1) {\n    const buffer = this._animationMap._texture._bufferView;\n    const id = cellID * 4 + this.spriteCount * 4 * _frame;\n    if (!buffer) {\n      return;\n    }\n    buffer[id] = toCell;\n    buffer[id + 1] = time;\n    buffer[id + 2] = speed;\n    const t = this._createTileAnimationBuffer(buffer);\n    this._animationMap.dispose();\n    this._animationMap = t;\n    this._material.setTexture(\"animationMap\", this._animationMap);\n  }\n  /**\n   * Exports the .tilemaps file\n   */\n  saveTileMaps() {\n    let maps = \"\";\n    for (let i = 0; i < this._tileMaps.length; i++) {\n      if (i > 0) {\n        maps += \"\\n\\r\";\n      }\n      maps += this._tileMaps[i]._texture._bufferView.toString();\n    }\n    const hiddenElement = document.createElement(\"a\");\n    hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\n    hiddenElement.target = \"_blank\";\n    hiddenElement.download = this.name + \".tilemaps\";\n    hiddenElement.click();\n    hiddenElement.remove();\n  }\n  /**\n   * Imports the .tilemaps file\n   * @param url of the .tilemaps file\n   */\n  loadTileMaps(url) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    const _lc = this.options.layerCount || 0;\n    xhr.onload = () => {\n      const data = xhr.response.split(\"\\n\\r\");\n      for (let i = 0; i < _lc; i++) {\n        const d = data[i].split(\",\").map(Number);\n        const t = this._createTileBuffer(d);\n        this._tileMaps[i].dispose();\n        this._tileMaps[i] = t;\n      }\n      this._material.setTextureArray(\"tileMap\", this._tileMaps);\n    };\n    xhr.send();\n  }\n  /**\n   * Release associated resources\n   */\n  dispose() {\n    this._output.dispose();\n    this._material.dispose();\n    this._animationMap.dispose();\n    this._tileMaps.forEach(tm => {\n      tm.dispose();\n    });\n    this._frameMap.dispose();\n  }\n}","map":{"version":3,"mappings":"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","names":["Engine","Vector2","Vector3","Texture","RawTexture","ShaderMaterial","Effect","CreatePlane","SpriteMap","constructor","name","atlasJSON","spriteSheet","options","scene","sprites","stageSize","outputSize","outputPosition","Zero","outputRotation","layerCount","maxAnimationFrames","baseTile","flipU","colorMultiply","_scene","_frameMap","_createFrameBuffer","_tileMaps","Array","i","push","_createTileBuffer","_animationMap","_createTileAnimationBuffer","defines","shaderString","ShadersStore","layerSampleString","getEngine","_features","supportSwitchCaseInShader","replace","_material","vertex","fragment","attributes","uniforms","samplers","needAlphaBlending","_time","setFloat","spriteCount","setVector2","setTexture","setVector3","tickSave","bindSpriteTexture","isReady","_texture","baseWidth","baseHeight","setTimeout","setTextureArray","_output","size","updatable","scaling","x","y","position","rotation","obfunction","getDeltaTime","onBeforeRenderObservable","add","material","length","v","animationMap","buffer","_bufferView","am","dispose","getTileID","p","getMousePosition","multiplyInPlace","Math","floor","out","pickinfo","pick","pointerX","pointerY","mesh","hit","getTextureCoordinates","coords","data","f","sss","ss","r","t","w","h","floatArray","Float32Array","CreateRGBATexture","NEAREST_NEAREST","TEXTURETYPE_FLOAT","_layer","_ty","_tx","bt","changeTiles","pos","tile","_p","id","count","addAnimationToTile","cellID","_frame","toCell","time","speed","saveTileMaps","maps","toString","hiddenElement","document","createElement","href","encodeURI","target","download","click","remove","loadTileMaps","url","xhr","XMLHttpRequest","open","_lc","onload","response","split","d","map","Number","send","forEach","tm"],"sourceRoot":"","sources":["../../../../lts/core/generated/Sprites/spriteMap.ts"],"sourcesContent":["import { Engine } from \"../Engines/engine\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Vector2, Vector3 } from \"../Maths/math.vector\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { ISpriteJSONSprite, ISpriteJSONAtlas } from \"./ISprites\";\r\nimport { Effect } from \"../Materials/effect\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\nimport \"../Shaders/spriteMap.fragment\";\r\nimport \"../Shaders/spriteMap.vertex\";\r\n\r\n/**\r\n * Defines the basic options interface of a SpriteMap\r\n */\r\nexport interface ISpriteMapOptions {\r\n    /**\r\n     * Vector2 of the number of cells in the grid.\r\n     */\r\n    stageSize?: Vector2;\r\n\r\n    /**\r\n     * Vector2 of the size of the output plane in World Units.\r\n     */\r\n    outputSize?: Vector2;\r\n\r\n    /**\r\n     * Vector3 of the position of the output plane in World Units.\r\n     */\r\n    outputPosition?: Vector3;\r\n\r\n    /**\r\n     * Vector3 of the rotation of the output plane.\r\n     */\r\n    outputRotation?: Vector3;\r\n\r\n    /**\r\n     * number of layers that the system will reserve in resources.\r\n     */\r\n    layerCount?: number;\r\n\r\n    /**\r\n     * number of max animation frames a single cell will reserve in resources.\r\n     */\r\n    maxAnimationFrames?: number;\r\n\r\n    /**\r\n     * number cell index of the base tile when the system compiles.\r\n     */\r\n    baseTile?: number;\r\n\r\n    /**\r\n     * boolean flip the sprite after its been repositioned by the framing data.\r\n     */\r\n    flipU?: boolean;\r\n\r\n    /**\r\n     * Vector3 scalar of the global RGB values of the SpriteMap.\r\n     */\r\n    colorMultiply?: Vector3;\r\n}\r\n\r\n/**\r\n * Defines the IDisposable interface in order to be cleanable from resources.\r\n */\r\nexport interface ISpriteMap extends IDisposable {\r\n    /**\r\n     * String name of the SpriteMap.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The JSON Array file from a https://www.codeandweb.com/texturepacker export.  Or similar structure.\r\n     */\r\n    atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /**\r\n     * Texture of the SpriteMap.\r\n     */\r\n    spriteSheet: Texture;\r\n\r\n    /**\r\n     * The parameters to initialize the SpriteMap with.\r\n     */\r\n    options: ISpriteMapOptions;\r\n}\r\n\r\n/**\r\n * Class used to manage a grid restricted sprite deployment on an Output plane.\r\n */\r\nexport class SpriteMap implements ISpriteMap {\r\n    /** The Name of the spriteMap */\r\n    public name: string;\r\n\r\n    /** The JSON file with the frame and meta data */\r\n    public atlasJSON: ISpriteJSONAtlas;\r\n\r\n    /** The systems Sprite Sheet Texture */\r\n    public spriteSheet: Texture;\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ISpriteMapOptions;\r\n\r\n    /** Public Sprite Storage array, parsed from atlasJSON */\r\n    public sprites: Array<ISpriteJSONSprite>;\r\n\r\n    /** Returns the Number of Sprites in the System */\r\n    public get spriteCount(): number {\r\n        return this.sprites.length;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public get position(): Vector3 {\r\n        return this._output.position;\r\n    }\r\n\r\n    /** Returns the Position of Output Plane*/\r\n    public set position(v: Vector3) {\r\n        this._output.position = v;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public get rotation(): Vector3 {\r\n        return this._output.rotation;\r\n    }\r\n\r\n    /** Returns the Rotation of Output Plane*/\r\n    public set rotation(v: Vector3) {\r\n        this._output.rotation = v;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public get animationMap() {\r\n        return this._animationMap;\r\n    }\r\n\r\n    /** Sets the AnimationMap*/\r\n    public set animationMap(v: RawTexture) {\r\n        const buffer = v!._texture!._bufferView;\r\n        const am = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = am;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /** Scene that the SpriteMap was created in */\r\n    private _scene: Scene;\r\n\r\n    /** Texture Buffer of Float32 that holds tile frame data*/\r\n    private _frameMap: RawTexture;\r\n\r\n    /** Texture Buffers of Float32 that holds tileMap data*/\r\n    private _tileMaps: RawTexture[];\r\n\r\n    /** Texture Buffer of Float32 that holds Animation Data*/\r\n    private _animationMap: RawTexture;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _material: ShaderMaterial;\r\n\r\n    /** Custom ShaderMaterial Central to the System*/\r\n    private _output: Mesh;\r\n\r\n    /** Systems Time Ticker*/\r\n    private _time: number;\r\n\r\n    /**\r\n     * Creates a new SpriteMap\r\n     * @param name defines the SpriteMaps Name\r\n     * @param atlasJSON is the JSON file that controls the Sprites Frames and Meta\r\n     * @param spriteSheet is the Texture that the Sprites are on.\r\n     * @param options a basic deployment configuration\r\n     * @param scene The Scene that the map is deployed on\r\n     */\r\n    constructor(name: string, atlasJSON: ISpriteJSONAtlas, spriteSheet: Texture, options: ISpriteMapOptions, scene: Scene) {\r\n        this.name = name;\r\n        this.sprites = [];\r\n        this.atlasJSON = atlasJSON;\r\n        this.sprites = this.atlasJSON[\"frames\"];\r\n        this.spriteSheet = spriteSheet;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        options.stageSize = options.stageSize || new Vector2(1, 1);\r\n        options.outputSize = options.outputSize || options.stageSize;\r\n        options.outputPosition = options.outputPosition || Vector3.Zero();\r\n        options.outputRotation = options.outputRotation || Vector3.Zero();\r\n        options.layerCount = options.layerCount || 1;\r\n        options.maxAnimationFrames = options.maxAnimationFrames || 0;\r\n        options.baseTile = options.baseTile || 0;\r\n        options.flipU = options.flipU || false;\r\n        options.colorMultiply = options.colorMultiply || new Vector3(1, 1, 1);\r\n\r\n        this._scene = scene;\r\n\r\n        this._frameMap = this._createFrameBuffer();\r\n\r\n        this._tileMaps = new Array();\r\n        for (let i = 0; i < options.layerCount; i++) {\r\n            this._tileMaps.push(this._createTileBuffer(null, i));\r\n        }\r\n\r\n        this._animationMap = this._createTileAnimationBuffer(null);\r\n\r\n        const defines = [];\r\n        defines.push(\"#define LAYERS \" + options.layerCount);\r\n\r\n        if (options.flipU) {\r\n            defines.push(\"#define FLIPU\");\r\n        }\r\n\r\n        defines.push(`#define MAX_ANIMATION_FRAMES ${options.maxAnimationFrames}.0`);\r\n\r\n        const shaderString: string = Effect.ShadersStore[\"spriteMapPixelShader\"];\r\n\r\n        let layerSampleString: string;\r\n        if (!scene.getEngine()._features.supportSwitchCaseInShader) {\r\n            layerSampleString = \"\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += `if (${i} == i) { frameID = texture2D(tileMaps[${i}], (tileID + 0.5) / stageSize, 0.).x; }`;\r\n            }\r\n        } else {\r\n            layerSampleString = \"switch(i) {\";\r\n            for (let i = 0; i < options.layerCount; i++) {\r\n                layerSampleString += \"case \" + i + \" : frameID = texture(tileMaps[\" + i + \"], (tileID + 0.5) / stageSize, 0.).x;\";\r\n                layerSampleString += \"break;\";\r\n            }\r\n            layerSampleString += \"}\";\r\n        }\r\n\r\n        Effect.ShadersStore[\"spriteMap\" + this.name + \"PixelShader\"] = shaderString.replace(\"#define LAYER_ID_SWITCH\", layerSampleString);\r\n\r\n        this._material = new ShaderMaterial(\r\n            \"spriteMap:\" + this.name,\r\n            this._scene,\r\n            {\r\n                vertex: \"spriteMap\",\r\n                fragment: \"spriteMap\" + this.name,\r\n            },\r\n            {\r\n                defines,\r\n                attributes: [\"position\", \"normal\", \"uv\"],\r\n                uniforms: [\"worldViewProjection\", \"time\", \"stageSize\", \"outputSize\", \"spriteMapSize\", \"spriteCount\", \"time\", \"colorMul\", \"mousePosition\", \"curTile\", \"flipU\"],\r\n                samplers: [\"spriteSheet\", \"frameMap\", \"tileMaps\", \"animationMap\"],\r\n                needAlphaBlending: true,\r\n            }\r\n        );\r\n\r\n        this._time = 0;\r\n\r\n        this._material.setFloat(\"spriteCount\", this.spriteCount);\r\n        this._material.setVector2(\"stageSize\", options.stageSize);\r\n        this._material.setVector2(\"outputSize\", options.outputSize);\r\n        this._material.setTexture(\"spriteSheet\", this.spriteSheet);\r\n        this._material.setVector2(\"spriteMapSize\", new Vector2(1, 1));\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n\r\n        let tickSave = 0;\r\n\r\n        const bindSpriteTexture = () => {\r\n            if (this.spriteSheet && this.spriteSheet.isReady()) {\r\n                if (this.spriteSheet._texture) {\r\n                    this._material.setVector2(\"spriteMapSize\", new Vector2(this.spriteSheet._texture.baseWidth || 1, this.spriteSheet._texture.baseHeight || 1));\r\n                    return;\r\n                }\r\n            }\r\n            if (tickSave < 100) {\r\n                setTimeout(() => {\r\n                    tickSave++;\r\n                    bindSpriteTexture();\r\n                }, 100);\r\n            }\r\n        };\r\n\r\n        bindSpriteTexture();\r\n\r\n        this._material.setVector3(\"colorMul\", options.colorMultiply);\r\n        this._material.setTexture(\"frameMap\", this._frameMap);\r\n        this._material.setTextureArray(\"tileMaps\", this._tileMaps);\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n        this._material.setFloat(\"time\", this._time);\r\n\r\n        this._output = CreatePlane(name + \":output\", { size: 1, updatable: true }, scene);\r\n        this._output.scaling.x = options.outputSize.x;\r\n        this._output.scaling.y = options.outputSize.y;\r\n        this.position = options.outputPosition;\r\n        this.rotation = options.outputRotation;\r\n\r\n        const obfunction = () => {\r\n            this._time += this._scene.getEngine().getDeltaTime();\r\n            this._material.setFloat(\"time\", this._time);\r\n        };\r\n\r\n        this._scene.onBeforeRenderObservable.add(obfunction);\r\n        this._output.material = this._material;\r\n    }\r\n\r\n    /**\r\n     * Returns tileID location\r\n     * @returns Vector2 the cell position ID\r\n     */\r\n    public getTileID(): Vector2 {\r\n        const p = this.getMousePosition();\r\n        p.multiplyInPlace(this.options.stageSize || Vector2.Zero());\r\n        p.x = Math.floor(p.x);\r\n        p.y = Math.floor(p.y);\r\n        return p;\r\n    }\r\n\r\n    /**\r\n     * Gets the UV location of the mouse over the SpriteMap.\r\n     * @returns Vector2 the UV position of the mouse interaction\r\n     */\r\n    public getMousePosition(): Vector2 {\r\n        const out = this._output;\r\n        const pickinfo: Nullable<PickingInfo> = this._scene.pick(this._scene.pointerX, this._scene.pointerY, (mesh) => {\r\n            if (mesh !== out) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n\r\n        if (!pickinfo || !pickinfo.hit || !pickinfo.getTextureCoordinates) {\r\n            return new Vector2(-1, -1);\r\n        }\r\n\r\n        const coords = pickinfo.getTextureCoordinates();\r\n        if (coords) {\r\n            return coords;\r\n        }\r\n\r\n        return new Vector2(-1, -1);\r\n    }\r\n\r\n    /**\r\n     * Creates the \"frame\" texture Buffer\r\n     * -------------------------------------\r\n     * Structure of frames\r\n     *  \"filename\": \"Falling-Water-2.png\",\r\n     * \"frame\": {\"x\":69,\"y\":103,\"w\":24,\"h\":32},\r\n     * \"rotated\": true,\r\n     * \"trimmed\": true,\r\n     * \"spriteSourceSize\": {\"x\":4,\"y\":0,\"w\":24,\"h\":32},\r\n     * \"sourceSize\": {\"w\":32,\"h\":32}\r\n     * @returns RawTexture of the frameMap\r\n     */\r\n    private _createFrameBuffer(): RawTexture {\r\n        const data = new Array();\r\n        //Do two Passes\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            data.push(0, 0, 0, 0); //frame\r\n            data.push(0, 0, 0, 0); //spriteSourceSize\r\n            data.push(0, 0, 0, 0); //sourceSize, rotated, trimmed\r\n            data.push(0, 0, 0, 0); //Keep it pow2 cause I\"m cool like that... it helps with sampling accuracy as well. Plus then we have 4 other parameters for future stuff.\r\n        }\r\n        //Second Pass\r\n        for (let i = 0; i < this.spriteCount; i++) {\r\n            const f = this.sprites[i][\"frame\"];\r\n            const sss = this.sprites[i][\"spriteSourceSize\"];\r\n            const ss = this.sprites[i][\"sourceSize\"];\r\n            const r = this.sprites[i][\"rotated\"] ? 1 : 0;\r\n            const t = this.sprites[i][\"trimmed\"] ? 1 : 0;\r\n\r\n            //frame\r\n            data[i * 4] = f.x;\r\n            data[i * 4 + 1] = f.y;\r\n            data[i * 4 + 2] = f.w;\r\n            data[i * 4 + 3] = f.h;\r\n            //spriteSourceSize\r\n            data[i * 4 + this.spriteCount * 4] = sss.x;\r\n            data[i * 4 + 1 + this.spriteCount * 4] = sss.y;\r\n            data[i * 4 + 3 + this.spriteCount * 4] = sss.h;\r\n            //sourceSize, rotated, trimmed\r\n            data[i * 4 + this.spriteCount * 8] = ss.w;\r\n            data[i * 4 + 1 + this.spriteCount * 8] = ss.h;\r\n            data[i * 4 + 2 + this.spriteCount * 8] = r;\r\n            data[i * 4 + 3 + this.spriteCount * 8] = t;\r\n        }\r\n\r\n        const floatArray = new Float32Array(data);\r\n\r\n        const t = RawTexture.CreateRGBATexture(floatArray, this.spriteCount, 4, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Creates the tileMap texture Buffer\r\n     * @param buffer normally and array of numbers, or a false to generate from scratch\r\n     * @param _layer indicates what layer for a logic trigger dealing with the baseTile.  The system uses this\r\n     * @returns RawTexture of the tileMap\r\n     */\r\n    private _createTileBuffer(buffer: any, _layer: number = 0): RawTexture {\r\n        let data = new Array();\r\n        const _ty = this.options.stageSize!.y || 0;\r\n        const _tx = this.options.stageSize!.x || 0;\r\n\r\n        if (!buffer) {\r\n            let bt = this.options.baseTile;\r\n            if (_layer != 0) {\r\n                bt = 0;\r\n            }\r\n\r\n            for (let y = 0; y < _ty; y++) {\r\n                for (let x = 0; x < _tx * 4; x += 4) {\r\n                    data.push(bt, 0, 0, 0);\r\n                }\r\n            }\r\n        } else {\r\n            data = buffer;\r\n        }\r\n\r\n        const floatArray = new Float32Array(data);\r\n        const t = RawTexture.CreateRGBATexture(floatArray, _tx, _ty, this._scene, false, false, Texture.NEAREST_NEAREST, Engine.TEXTURETYPE_FLOAT);\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Modifies the data of the tileMaps\r\n     * @param _layer is the ID of the layer you want to edit on the SpriteMap\r\n     * @param pos is the iVector2 Coordinates of the Tile\r\n     * @param tile The SpriteIndex of the new Tile\r\n     */\r\n    public changeTiles(_layer: number = 0, pos: Vector2 | Vector2[], tile: number = 0): void {\r\n        const buffer = this._tileMaps[_layer]!._texture!._bufferView;\r\n        if (buffer === null) {\r\n            return;\r\n        }\r\n\r\n        let p = new Array();\r\n        if (pos instanceof Vector2) {\r\n            p.push(pos);\r\n        } else {\r\n            p = pos;\r\n        }\r\n\r\n        const _tx = this.options.stageSize!.x || 0;\r\n\r\n        for (let i = 0; i < p.length; i++) {\r\n            const _p = p[i];\r\n            _p.x = Math.floor(_p.x);\r\n            _p.y = Math.floor(_p.y);\r\n            const id: number = _p.x * 4 + _p.y * (_tx * 4);\r\n            (buffer as any)[id] = tile;\r\n        }\r\n\r\n        const t = this._createTileBuffer(buffer);\r\n        this._tileMaps[_layer].dispose();\r\n        this._tileMaps[_layer] = t;\r\n        this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n    }\r\n\r\n    /**\r\n     * Creates the animationMap texture Buffer\r\n     * @param buffer normally and array of numbers, or a false to generate from scratch\r\n     * @returns RawTexture of the animationMap\r\n     */\r\n    private _createTileAnimationBuffer(buffer: Nullable<ArrayBufferView>): RawTexture {\r\n        const data = new Array();\r\n        let floatArray;\r\n        if (!buffer) {\r\n            for (let i = 0; i < this.spriteCount; i++) {\r\n                data.push(0, 0, 0, 0);\r\n                let count = 1;\r\n                while (count < (this.options.maxAnimationFrames || 4)) {\r\n                    data.push(0, 0, 0, 0);\r\n                    count++;\r\n                }\r\n            }\r\n            floatArray = new Float32Array(data);\r\n        } else {\r\n            floatArray = buffer;\r\n        }\r\n\r\n        const t = RawTexture.CreateRGBATexture(\r\n            floatArray,\r\n            this.spriteCount,\r\n            this.options.maxAnimationFrames || 4,\r\n            this._scene,\r\n            false,\r\n            false,\r\n            Texture.NEAREST_NEAREST,\r\n            Engine.TEXTURETYPE_FLOAT\r\n        );\r\n\r\n        return t;\r\n    }\r\n\r\n    /**\r\n     * Modifies the data of the animationMap\r\n     * @param cellID is the Index of the Sprite\r\n     * @param _frame is the target Animation frame\r\n     * @param toCell is the Target Index of the next frame of the animation\r\n     * @param time is a value between 0-1 that is the trigger for when the frame should change tiles\r\n     * @param speed is a global scalar of the time variable on the map.\r\n     */\r\n    public addAnimationToTile(cellID: number = 0, _frame: number = 0, toCell: number = 0, time: number = 0, speed: number = 1): void {\r\n        const buffer: any = this._animationMap!._texture!._bufferView;\r\n        const id: number = cellID * 4 + this.spriteCount * 4 * _frame;\r\n        if (!buffer) {\r\n            return;\r\n        }\r\n        buffer[id] = toCell;\r\n        buffer[id + 1] = time;\r\n        buffer[id + 2] = speed;\r\n        const t = this._createTileAnimationBuffer(buffer);\r\n        this._animationMap.dispose();\r\n        this._animationMap = t;\r\n        this._material.setTexture(\"animationMap\", this._animationMap);\r\n    }\r\n\r\n    /**\r\n     * Exports the .tilemaps file\r\n     */\r\n    public saveTileMaps(): void {\r\n        let maps = \"\";\r\n        for (let i = 0; i < this._tileMaps.length; i++) {\r\n            if (i > 0) {\r\n                maps += \"\\n\\r\";\r\n            }\r\n\r\n            maps += this._tileMaps[i]!._texture!._bufferView!.toString();\r\n        }\r\n        const hiddenElement = document.createElement(\"a\");\r\n        hiddenElement.href = \"data:octet/stream;charset=utf-8,\" + encodeURI(maps);\r\n        hiddenElement.target = \"_blank\";\r\n        hiddenElement.download = this.name + \".tilemaps\";\r\n        hiddenElement.click();\r\n        hiddenElement.remove();\r\n    }\r\n\r\n    /**\r\n     * Imports the .tilemaps file\r\n     * @param url of the .tilemaps file\r\n     */\r\n    public loadTileMaps(url: string): void {\r\n        const xhr = new XMLHttpRequest();\r\n        xhr.open(\"GET\", url);\r\n\r\n        const _lc = this.options!.layerCount || 0;\r\n\r\n        xhr.onload = () => {\r\n            const data = xhr.response.split(\"\\n\\r\");\r\n            for (let i = 0; i < _lc; i++) {\r\n                const d = data[i].split(\",\").map(Number);\r\n                const t = this._createTileBuffer(d);\r\n                this._tileMaps[i].dispose();\r\n                this._tileMaps[i] = t;\r\n            }\r\n            this._material.setTextureArray(\"tileMap\", this._tileMaps);\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        this._output.dispose();\r\n        this._material.dispose();\r\n        this._animationMap.dispose();\r\n        this._tileMaps.forEach((tm) => {\r\n            tm.dispose();\r\n        });\r\n        this._frameMap.dispose();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}