{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector2 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { SceneLoader } from \"@babylonjs/core/Loading/sceneLoader.js\";\nimport { AssetContainer } from \"@babylonjs/core/assetContainer.js\";\nimport { MTLFileLoader } from \"./mtlFileLoader.js\";\nimport { SolidParser } from \"./solidParser.js\";\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader {\n  /**\n   * Creates loader for .OBJ files\n   *\n   * @param loadingOptions options for loading and parsing OBJ/MTL files.\n   */\n  constructor(loadingOptions) {\n    /**\n     * Defines the name of the plugin.\n     */\n    this.name = \"obj\";\n    /**\n     * Defines the extension the plugin is able to load.\n     */\n    this.extensions = \".obj\";\n    this._assetContainer = null;\n    this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\n  }\n  /**\n   * Invert Y-Axis of referenced textures on load\n   */\n  static get INVERT_TEXTURE_Y() {\n    return MTLFileLoader.INVERT_TEXTURE_Y;\n  }\n  static set INVERT_TEXTURE_Y(value) {\n    MTLFileLoader.INVERT_TEXTURE_Y = value;\n  }\n  static get _DefaultLoadingOptions() {\n    return {\n      computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n      optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n      importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n      invertY: OBJFileLoader.INVERT_Y,\n      invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      UVScaling: OBJFileLoader.UV_SCALING,\n      materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n      optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n      skipMaterials: OBJFileLoader.SKIP_MATERIALS\n    };\n  }\n  /**\n   * Calls synchronously the MTL file attached to this obj.\n   * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n   * Without this function materials are not displayed in the first frame (but displayed after).\n   * In consequence it is impossible to get material information in your HTML file\n   *\n   * @param url The URL of the MTL file\n   * @param rootUrl defines where to load data from\n   * @param onSuccess Callback function to be called when the MTL file is loaded\n   * @param onFailure\n   */\n  _loadMTL(url, rootUrl, onSuccess, onFailure) {\n    //The complete path to the mtl file\n    const pathOfFile = rootUrl + url;\n    // Loads through the babylon tools to allow fileInput search.\n    Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request, exception) => {\n      onFailure(pathOfFile, exception);\n    });\n  }\n  /**\n   * Instantiates a OBJ file loader plugin.\n   * @returns the created plugin\n   */\n  createPlugin() {\n    return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\n  }\n  /**\n   * If the data string can be loaded directly.\n   * @returns if the data can be loaded directly\n   */\n  canDirectLoad() {\n    return false;\n  }\n  /**\n   * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n   * @param scene the scene the meshes should be added to\n   * @param data the OBJ data to load\n   * @param rootUrl root url to load from\n   * @returns a promise containing the loaded meshes, particles, skeletons and animations\n   */\n  importMeshAsync(meshesNames, scene, data, rootUrl) {\n    //get the meshes from OBJ file\n    return this._parseSolid(meshesNames, scene, data, rootUrl).then(meshes => {\n      return {\n        meshes: meshes,\n        particleSystems: [],\n        skeletons: [],\n        animationGroups: [],\n        transformNodes: [],\n        geometries: [],\n        lights: []\n      };\n    });\n  }\n  /**\n   * Imports all objects from the loaded OBJ data and adds them to the scene\n   * @param scene the scene the objects should be added to\n   * @param data the OBJ data to load\n   * @param rootUrl root url to load from\n   * @returns a promise which completes when objects have been loaded to the scene\n   */\n  loadAsync(scene, data, rootUrl) {\n    //Get the 3D model\n    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n      // return void\n    });\n  }\n  /**\n   * Load into an asset container.\n   * @param scene The scene to load into\n   * @param data The data to import\n   * @param rootUrl The root url for scene and resources\n   * @returns The loaded asset container\n   */\n  loadAssetContainerAsync(scene, data, rootUrl) {\n    const container = new AssetContainer(scene);\n    this._assetContainer = container;\n    return this.importMeshAsync(null, scene, data, rootUrl).then(result => {\n      result.meshes.forEach(mesh => container.meshes.push(mesh));\n      result.meshes.forEach(mesh => {\n        const material = mesh.material;\n        if (material) {\n          // Materials\n          if (container.materials.indexOf(material) == -1) {\n            container.materials.push(material);\n            // Textures\n            const textures = material.getActiveTextures();\n            textures.forEach(t => {\n              if (container.textures.indexOf(t) == -1) {\n                container.textures.push(t);\n              }\n            });\n          }\n        }\n      });\n      this._assetContainer = null;\n      return container;\n    }).catch(ex => {\n      this._assetContainer = null;\n      throw ex;\n    });\n  }\n  /**\n   * Read the OBJ file and create an Array of meshes.\n   * Each mesh contains all information given by the OBJ and the MTL file.\n   * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n   * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n   * @param scene defines the scene where are displayed the data\n   * @param data defines the content of the obj file\n   * @param rootUrl defines the path to the folder\n   * @returns the list of loaded meshes\n   */\n  _parseSolid(meshesNames, scene, data, rootUrl) {\n    let fileToLoad = \"\"; //The name of the mtlFile to load\n    const materialsFromMTLFile = new MTLFileLoader();\n    const materialToUse = new Array();\n    const babylonMeshesArray = []; //The mesh for babylon\n    // Main function\n    const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n    solidParser.parse(meshesNames, data, scene, this._assetContainer, fileName => {\n      fileToLoad = fileName;\n    });\n    // load the materials\n    const mtlPromises = [];\n    // Check if we have a file to load\n    if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n      //Load the file synchronously\n      mtlPromises.push(new Promise((resolve, reject) => {\n        this._loadMTL(fileToLoad, rootUrl, dataLoaded => {\n          try {\n            //Create materials thanks MTLLoader function\n            materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n            //Look at each material loaded in the mtl file\n            for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\n              //Three variables to get all meshes with the same material\n              let startIndex = 0;\n              const _indices = [];\n              let _index;\n              //The material from MTL file is used in the meshes loaded\n              //Push the indice in an array\n              //Check if the material is not used for another mesh\n              while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                _indices.push(_index);\n                startIndex = _index + 1;\n              }\n              //If the material is not used dispose it\n              if (_index === -1 && _indices.length === 0) {\n                //If the material is not needed, remove it\n                materialsFromMTLFile.materials[n].dispose();\n              } else {\n                for (let o = 0; o < _indices.length; o++) {\n                  //Apply the material to the Mesh for each mesh with the material\n                  const mesh = babylonMeshesArray[_indices[o]];\n                  const material = materialsFromMTLFile.materials[n];\n                  mesh.material = material;\n                  if (!mesh.getTotalIndices()) {\n                    // No indices, we need to turn on point cloud\n                    material.pointsCloud = true;\n                  }\n                }\n              }\n            }\n            resolve();\n          } catch (e) {\n            Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n            if (this._loadingOptions.materialLoadingFailsSilently) {\n              resolve();\n            } else {\n              reject(e);\n            }\n          }\n        }, (pathOfFile, exception) => {\n          Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n          if (this._loadingOptions.materialLoadingFailsSilently) {\n            resolve();\n          } else {\n            reject(exception);\n          }\n        });\n      }));\n    }\n    //Return an array with all Mesh\n    return Promise.all(mtlPromises).then(() => {\n      return babylonMeshesArray;\n    });\n  }\n}\n/**\n * Defines if UVs are optimized by default during load.\n */\nOBJFileLoader.OPTIMIZE_WITH_UV = true;\n/**\n * Invert model on y-axis (does a model scaling inversion)\n */\nOBJFileLoader.INVERT_Y = false;\n/**\n * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n */\nOBJFileLoader.IMPORT_VERTEX_COLORS = false;\n/**\n * Compute the normals for the model, even if normals are present in the file.\n */\nOBJFileLoader.COMPUTE_NORMALS = false;\n/**\n * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n */\nOBJFileLoader.OPTIMIZE_NORMALS = false;\n/**\n * Defines custom scaling of UV coordinates of loaded meshes.\n */\nOBJFileLoader.UV_SCALING = new Vector2(1, 1);\n/**\n * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n */\nOBJFileLoader.SKIP_MATERIALS = false;\n/**\n * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n *\n * Defaults to true for backwards compatibility.\n */\nOBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\nif (SceneLoader) {\n  //Add this loader into the register plugin\n  SceneLoader.RegisterPlugin(new OBJFileLoader());\n}","map":{"version":3,"mappings":"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","names":["Vector2","Tools","SceneLoader","AssetContainer","MTLFileLoader","SolidParser","OBJFileLoader","constructor","loadingOptions","_loadingOptions","_DefaultLoadingOptions","INVERT_TEXTURE_Y","value","computeNormals","COMPUTE_NORMALS","optimizeNormals","OPTIMIZE_NORMALS","importVertexColors","IMPORT_VERTEX_COLORS","invertY","INVERT_Y","invertTextureY","UVScaling","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","optimizeWithUV","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","_loadMTL","url","rootUrl","onSuccess","onFailure","pathOfFile","LoadFile","undefined","request","exception","createPlugin","canDirectLoad","importMeshAsync","meshesNames","scene","data","_parseSolid","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","loadAsync","loadAssetContainerAsync","container","_assetContainer","result","forEach","mesh","push","material","materials","indexOf","textures","getActiveTextures","t","catch","ex","fileToLoad","materialsFromMTLFile","materialToUse","Array","babylonMeshesArray","solidParser","parse","fileName","mtlPromises","Promise","resolve","reject","dataLoaded","parseMTL","n","length","startIndex","_indices","_index","name","dispose","o","getTotalIndices","pointsCloud","e","Warn","all","RegisterPlugin"],"sourceRoot":"","sources":["../../../../lts/loaders/generated/OBJ/objFileLoader.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult } from \"core/Loading/sceneLoader\";\r\nimport { SceneLoader } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport { MTLFileLoader } from \"./mtlFileLoader\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { SolidParser } from \"./solidParser\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines if UVs are optimized by default during load.\r\n     */\r\n    public static OPTIMIZE_WITH_UV = true;\r\n    /**\r\n     * Invert model on y-axis (does a model scaling inversion)\r\n     */\r\n    public static INVERT_Y = false;\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static get INVERT_TEXTURE_Y() {\r\n        return MTLFileLoader.INVERT_TEXTURE_Y;\r\n    }\r\n\r\n    public static set INVERT_TEXTURE_Y(value: boolean) {\r\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\r\n    }\r\n\r\n    /**\r\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n     */\r\n    public static IMPORT_VERTEX_COLORS = false;\r\n    /**\r\n     * Compute the normals for the model, even if normals are present in the file.\r\n     */\r\n    public static COMPUTE_NORMALS = false;\r\n    /**\r\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\r\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\r\n     */\r\n    public static OPTIMIZE_NORMALS = false;\r\n    /**\r\n     * Defines custom scaling of UV coordinates of loaded meshes.\r\n     */\r\n    public static UV_SCALING = new Vector2(1, 1);\r\n    /**\r\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n     */\r\n    public static SKIP_MATERIALS = false;\r\n\r\n    /**\r\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n     *\r\n     * Defaults to true for backwards compatibility.\r\n     */\r\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public name = \"obj\";\r\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\r\n    public extensions = \".obj\";\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n\r\n    /**\r\n     * Creates loader for .OBJ files\r\n     *\r\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\r\n     */\r\n    constructor(loadingOptions?: OBJLoadingOptions) {\r\n        this._loadingOptions = loadingOptions || OBJFileLoader._DefaultLoadingOptions;\r\n    }\r\n\r\n    private static get _DefaultLoadingOptions(): OBJLoadingOptions {\r\n        return {\r\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\r\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\r\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\r\n            invertY: OBJFileLoader.INVERT_Y,\r\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            UVScaling: OBJFileLoader.UV_SCALING,\r\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\r\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\r\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calls synchronously the MTL file attached to this obj.\r\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n     * Without this function materials are not displayed in the first frame (but displayed after).\r\n     * In consequence it is impossible to get material information in your HTML file\r\n     *\r\n     * @param url The URL of the MTL file\r\n     * @param rootUrl defines where to load data from\r\n     * @param onSuccess Callback function to be called when the MTL file is loaded\r\n     * @param onFailure\r\n     */\r\n    private _loadMTL(\r\n        url: string,\r\n        rootUrl: string,\r\n        onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any,\r\n        onFailure: (pathOfFile: string, exception?: any) => void\r\n    ) {\r\n        //The complete path to the mtl file\r\n        const pathOfFile = rootUrl + url;\r\n\r\n        // Loads through the babylon tools to allow fileInput search.\r\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request?: WebRequest | undefined, exception?: any) => {\r\n            onFailure(pathOfFile, exception);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Instantiates a OBJ file loader plugin.\r\n     * @returns the created plugin\r\n     */\r\n    createPlugin(): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\r\n        return new OBJFileLoader(OBJFileLoader._DefaultLoadingOptions);\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<ISceneLoaderAsyncResult> {\r\n        //get the meshes from OBJ file\r\n        return this._parseSolid(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return this.importMeshAsync(null, scene, data, rootUrl)\r\n            .then((result) => {\r\n                result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                result.meshes.forEach((mesh) => {\r\n                    const material = mesh.material;\r\n                    if (material) {\r\n                        // Materials\r\n                        if (container.materials.indexOf(material) == -1) {\r\n                            container.materials.push(material);\r\n\r\n                            // Textures\r\n                            const textures = material.getActiveTextures();\r\n                            textures.forEach((t) => {\r\n                                if (container.textures.indexOf(t) == -1) {\r\n                                    container.textures.push(t);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                this._assetContainer = null;\r\n                return container;\r\n            })\r\n            .catch((ex) => {\r\n                this._assetContainer = null;\r\n                throw ex;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Read the OBJ file and create an Array of meshes.\r\n     * Each mesh contains all information given by the OBJ and the MTL file.\r\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene defines the scene where are displayed the data\r\n     * @param data defines the content of the obj file\r\n     * @param rootUrl defines the path to the folder\r\n     * @returns the list of loaded meshes\r\n     */\r\n    private _parseSolid(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        let fileToLoad: string = \"\"; //The name of the mtlFile to load\r\n        const materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\r\n        const materialToUse = new Array<string>();\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        // Main function\r\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\r\n\r\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\r\n            fileToLoad = fileName;\r\n        });\r\n\r\n        // load the materials\r\n        const mtlPromises: Array<Promise<void>> = [];\r\n        // Check if we have a file to load\r\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\r\n            //Load the file synchronously\r\n            mtlPromises.push(\r\n                new Promise((resolve, reject) => {\r\n                    this._loadMTL(\r\n                        fileToLoad,\r\n                        rootUrl,\r\n                        (dataLoaded) => {\r\n                            try {\r\n                                //Create materials thanks MTLLoader function\r\n                                materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\r\n                                //Look at each material loaded in the mtl file\r\n                                for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\r\n                                    //Three variables to get all meshes with the same material\r\n                                    let startIndex = 0;\r\n                                    const _indices = [];\r\n                                    let _index;\r\n\r\n                                    //The material from MTL file is used in the meshes loaded\r\n                                    //Push the indice in an array\r\n                                    //Check if the material is not used for another mesh\r\n                                    while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\r\n                                        _indices.push(_index);\r\n                                        startIndex = _index + 1;\r\n                                    }\r\n                                    //If the material is not used dispose it\r\n                                    if (_index === -1 && _indices.length === 0) {\r\n                                        //If the material is not needed, remove it\r\n                                        materialsFromMTLFile.materials[n].dispose();\r\n                                    } else {\r\n                                        for (let o = 0; o < _indices.length; o++) {\r\n                                            //Apply the material to the Mesh for each mesh with the material\r\n                                            const mesh = babylonMeshesArray[_indices[o]];\r\n                                            const material = materialsFromMTLFile.materials[n];\r\n                                            mesh.material = material;\r\n\r\n                                            if (!mesh.getTotalIndices()) {\r\n                                                // No indices, we need to turn on point cloud\r\n                                                material.pointsCloud = true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                resolve();\r\n                            } catch (e) {\r\n                                Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\r\n                                if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                    resolve();\r\n                                } else {\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        },\r\n                        (pathOfFile: string, exception?: any) => {\r\n                            Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\r\n                            if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                resolve();\r\n                            } else {\r\n                                reject(exception);\r\n                            }\r\n                        }\r\n                    );\r\n                })\r\n            );\r\n        }\r\n        //Return an array with all Mesh\r\n        return Promise.all(mtlPromises).then(() => {\r\n            return babylonMeshesArray;\r\n        });\r\n    }\r\n}\r\n\r\nif (SceneLoader) {\r\n    //Add this loader into the register plugin\r\n    SceneLoader.RegisterPlugin(new OBJFileLoader());\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}