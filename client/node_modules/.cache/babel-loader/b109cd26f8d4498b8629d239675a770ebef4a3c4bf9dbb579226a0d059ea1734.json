{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../tslib.es6.js\";\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators.js\";\nimport { Observable } from \"../../../Misc/observable.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Texture } from \"../../../Materials/Textures/texture.js\";\nimport { GlowLayer } from \"../../../Layers/glowLayer.js\";\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess.js\";\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess.js\";\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess.js\";\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess.js\";\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess.js\";\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline.js\";\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect.js\";\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect.js\";\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent.js\";\n/**\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/defaultRenderingPipeline\n */\nexport class DefaultRenderingPipeline extends PostProcessRenderPipeline {\n  /**\n   * Instantiates a DefaultRenderingPipeline.\n   * @param name The rendering pipeline name (default: \"\")\n   * @param hdr If high dynamic range textures should be used (default: true)\n   * @param scene The scene linked to this pipeline (default: the last created scene)\n   * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\n   * @param automaticBuild If false, you will have to manually call prepare() to update the pipeline (default: true)\n   */\n  constructor(name = \"\", hdr = true, scene = EngineStore.LastCreatedScene, cameras, automaticBuild = true) {\n    super(scene.getEngine(), name);\n    this._camerasToBeAttached = [];\n    /**\n     * ID of the sharpen post process,\n     */\n    this.SharpenPostProcessId = \"SharpenPostProcessEffect\";\n    /**\n     * @ignore\n     * ID of the image processing post process;\n     */\n    this.ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\n    /**\n     * @ignore\n     * ID of the Fast Approximate Anti-Aliasing post process;\n     */\n    this.FxaaPostProcessId = \"FxaaPostProcessEffect\";\n    /**\n     * ID of the chromatic aberration post process,\n     */\n    this.ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\";\n    /**\n     * ID of the grain post process\n     */\n    this.GrainPostProcessId = \"GrainPostProcessEffect\";\n    /**\n     * Glow post process which adds a glow to emissive areas of the image\n     */\n    this._glowLayer = null;\n    /**\n     * Animations which can be used to tweak settings over a period of time\n     */\n    this.animations = [];\n    this._imageProcessingConfigurationObserver = null;\n    // Values\n    this._sharpenEnabled = false;\n    this._bloomEnabled = false;\n    this._depthOfFieldEnabled = false;\n    this._depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\n    this._fxaaEnabled = false;\n    this._imageProcessingEnabled = true;\n    this._bloomScale = 0.5;\n    this._chromaticAberrationEnabled = false;\n    this._grainEnabled = false;\n    this._buildAllowed = true;\n    /**\n     * This is triggered each time the pipeline has been built.\n     */\n    this.onBuildObservable = new Observable();\n    this._resizeObserver = null;\n    this._hardwareScaleLevel = 1.0;\n    this._bloomKernel = 64;\n    /**\n     * Specifies the weight of the bloom in the final rendering\n     */\n    this._bloomWeight = 0.15;\n    /**\n     * Specifies the luma threshold for the area that will be blurred by the bloom\n     */\n    this._bloomThreshold = 0.9;\n    this._samples = 1;\n    this._hasCleared = false;\n    this._prevPostProcess = null;\n    this._prevPrevPostProcess = null;\n    this._depthOfFieldSceneObserver = null;\n    this._activeCameraChangedObserver = null;\n    this._activeCamerasChangedObserver = null;\n    this._cameras = cameras || scene.cameras;\n    this._cameras = this._cameras.slice();\n    this._camerasToBeAttached = this._cameras.slice();\n    this._buildAllowed = automaticBuild;\n    // Initialize\n    this._scene = scene;\n    const caps = this._scene.getEngine().getCaps();\n    this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\n    // Misc\n    if (this._hdr) {\n      if (caps.textureHalfFloatRender) {\n        this._defaultPipelineTextureType = 2;\n      } else if (caps.textureFloatRender) {\n        this._defaultPipelineTextureType = 1;\n      }\n    } else {\n      this._defaultPipelineTextureType = 0;\n    }\n    // Attach\n    scene.postProcessRenderPipelineManager.addPipeline(this);\n    const engine = this._scene.getEngine();\n    // Create post processes before hand so they can be modified before enabled.\n    // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\n    this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\n    this._sharpenEffect = new PostProcessRenderEffect(engine, this.SharpenPostProcessId, () => {\n      return this.sharpen;\n    }, true);\n    this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);\n    // To keep the bloom sizes consistent across different display densities, factor in the hardware scaling level.\n    this._hardwareScaleLevel = engine.getHardwareScalingLevel();\n    this._resizeObserver = engine.onResizeObservable.add(() => {\n      this._hardwareScaleLevel = engine.getHardwareScalingLevel();\n      this.bloomKernel = this._bloomKernel;\n    });\n    this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);\n    this.chromaticAberration = new ChromaticAberrationPostProcess(\"ChromaticAberration\", engine.getRenderWidth(), engine.getRenderHeight(), 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\n    this._chromaticAberrationEffect = new PostProcessRenderEffect(engine, this.ChromaticAberrationPostProcessId, () => {\n      return this.chromaticAberration;\n    }, true);\n    this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\n    this._grainEffect = new PostProcessRenderEffect(engine, this.GrainPostProcessId, () => {\n      return this.grain;\n    }, true);\n    this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\n      this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;\n      if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {\n        this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;\n        this._buildPipeline();\n      }\n    });\n    this._buildPipeline();\n  }\n  /**\n   * Enable or disable automatic building of the pipeline when effects are enabled and disabled.\n   * If false, you will have to manually call prepare() to update the pipeline.\n   */\n  get automaticBuild() {\n    return this._buildAllowed;\n  }\n  set automaticBuild(value) {\n    this._buildAllowed = value;\n  }\n  /**\n   * Gets active scene\n   */\n  get scene() {\n    return this._scene;\n  }\n  /**\n   * Enable or disable the sharpen process from the pipeline\n   */\n  set sharpenEnabled(enabled) {\n    if (this._sharpenEnabled === enabled) {\n      return;\n    }\n    this._sharpenEnabled = enabled;\n    this._buildPipeline();\n  }\n  get sharpenEnabled() {\n    return this._sharpenEnabled;\n  }\n  /**\n   * Specifies the size of the bloom blur kernel, relative to the final output size\n   */\n  get bloomKernel() {\n    return this._bloomKernel;\n  }\n  set bloomKernel(value) {\n    this._bloomKernel = value;\n    this.bloom.kernel = value / this._hardwareScaleLevel;\n  }\n  /**\n   * The strength of the bloom.\n   */\n  set bloomWeight(value) {\n    if (this._bloomWeight === value) {\n      return;\n    }\n    this.bloom.weight = value;\n    this._bloomWeight = value;\n  }\n  get bloomWeight() {\n    return this._bloomWeight;\n  }\n  /**\n   * The luminance threshold to find bright areas of the image to bloom.\n   */\n  set bloomThreshold(value) {\n    if (this._bloomThreshold === value) {\n      return;\n    }\n    this.bloom.threshold = value;\n    this._bloomThreshold = value;\n  }\n  get bloomThreshold() {\n    return this._bloomThreshold;\n  }\n  /**\n   * The scale of the bloom, lower value will provide better performance.\n   */\n  set bloomScale(value) {\n    if (this._bloomScale === value) {\n      return;\n    }\n    this._bloomScale = value;\n    // recreate bloom and dispose old as this setting is not dynamic\n    this._rebuildBloom();\n    this._buildPipeline();\n  }\n  get bloomScale() {\n    return this._bloomScale;\n  }\n  /**\n   * Enable or disable the bloom from the pipeline\n   */\n  set bloomEnabled(enabled) {\n    if (this._bloomEnabled === enabled) {\n      return;\n    }\n    this._bloomEnabled = enabled;\n    this._buildPipeline();\n  }\n  get bloomEnabled() {\n    return this._bloomEnabled;\n  }\n  _rebuildBloom() {\n    // recreate bloom and dispose old as this setting is not dynamic\n    const oldBloom = this.bloom;\n    this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);\n    this.bloom.threshold = oldBloom.threshold;\n    for (let i = 0; i < this._cameras.length; i++) {\n      oldBloom.disposeEffects(this._cameras[i]);\n    }\n  }\n  /**\n   * If the depth of field is enabled.\n   */\n  get depthOfFieldEnabled() {\n    return this._depthOfFieldEnabled;\n  }\n  set depthOfFieldEnabled(enabled) {\n    if (this._depthOfFieldEnabled === enabled) {\n      return;\n    }\n    this._depthOfFieldEnabled = enabled;\n    this._buildPipeline();\n  }\n  /**\n   * Blur level of the depth of field effect. (Higher blur will effect performance)\n   */\n  get depthOfFieldBlurLevel() {\n    return this._depthOfFieldBlurLevel;\n  }\n  set depthOfFieldBlurLevel(value) {\n    if (this._depthOfFieldBlurLevel === value) {\n      return;\n    }\n    this._depthOfFieldBlurLevel = value;\n    // recreate dof and dispose old as this setting is not dynamic\n    const oldDof = this.depthOfField;\n    this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\n    this.depthOfField.focalLength = oldDof.focalLength;\n    this.depthOfField.focusDistance = oldDof.focusDistance;\n    this.depthOfField.fStop = oldDof.fStop;\n    this.depthOfField.lensSize = oldDof.lensSize;\n    for (let i = 0; i < this._cameras.length; i++) {\n      oldDof.disposeEffects(this._cameras[i]);\n    }\n    this._buildPipeline();\n  }\n  /**\n   * If the anti aliasing is enabled.\n   */\n  set fxaaEnabled(enabled) {\n    if (this._fxaaEnabled === enabled) {\n      return;\n    }\n    this._fxaaEnabled = enabled;\n    this._buildPipeline();\n  }\n  get fxaaEnabled() {\n    return this._fxaaEnabled;\n  }\n  /**\n   * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\n   */\n  set samples(sampleCount) {\n    if (this._samples === sampleCount) {\n      return;\n    }\n    this._samples = sampleCount;\n    this._buildPipeline();\n  }\n  get samples() {\n    return this._samples;\n  }\n  /**\n   * If image processing is enabled.\n   */\n  set imageProcessingEnabled(enabled) {\n    if (this._imageProcessingEnabled === enabled) {\n      return;\n    }\n    this._scene.imageProcessingConfiguration.isEnabled = enabled;\n  }\n  get imageProcessingEnabled() {\n    return this._imageProcessingEnabled;\n  }\n  /**\n   * If glow layer is enabled. (Adds a glow effect to emmissive materials)\n   */\n  set glowLayerEnabled(enabled) {\n    if (enabled && !this._glowLayer) {\n      this._glowLayer = new GlowLayer(\"\", this._scene);\n    } else if (!enabled && this._glowLayer) {\n      this._glowLayer.dispose();\n      this._glowLayer = null;\n    }\n  }\n  get glowLayerEnabled() {\n    return this._glowLayer != null;\n  }\n  /**\n   * Gets the glow layer (or null if not defined)\n   */\n  get glowLayer() {\n    return this._glowLayer;\n  }\n  /**\n   * Enable or disable the chromaticAberration process from the pipeline\n   */\n  set chromaticAberrationEnabled(enabled) {\n    if (this._chromaticAberrationEnabled === enabled) {\n      return;\n    }\n    this._chromaticAberrationEnabled = enabled;\n    this._buildPipeline();\n  }\n  get chromaticAberrationEnabled() {\n    return this._chromaticAberrationEnabled;\n  }\n  /**\n   * Enable or disable the grain process from the pipeline\n   */\n  set grainEnabled(enabled) {\n    if (this._grainEnabled === enabled) {\n      return;\n    }\n    this._grainEnabled = enabled;\n    this._buildPipeline();\n  }\n  get grainEnabled() {\n    return this._grainEnabled;\n  }\n  /**\n   * Get the class name\n   * @returns \"DefaultRenderingPipeline\"\n   */\n  getClassName() {\n    return \"DefaultRenderingPipeline\";\n  }\n  /**\n   * Force the compilation of the entire pipeline.\n   */\n  prepare() {\n    const previousState = this._buildAllowed;\n    this._buildAllowed = true;\n    this._buildPipeline();\n    this._buildAllowed = previousState;\n  }\n  _setAutoClearAndTextureSharing(postProcess, skipTextureSharing = false) {\n    if (this._hasCleared) {\n      postProcess.autoClear = false;\n    } else {\n      postProcess.autoClear = true;\n      this._scene.autoClear = false;\n      this._hasCleared = true;\n    }\n    if (!skipTextureSharing) {\n      if (this._prevPrevPostProcess) {\n        postProcess.shareOutputWith(this._prevPrevPostProcess);\n      } else {\n        postProcess.useOwnOutput();\n      }\n      if (this._prevPostProcess) {\n        this._prevPrevPostProcess = this._prevPostProcess;\n      }\n      this._prevPostProcess = postProcess;\n    }\n  }\n  _buildPipeline() {\n    if (!this._buildAllowed) {\n      return;\n    }\n    this._scene.autoClear = true;\n    const engine = this._scene.getEngine();\n    this._disposePostProcesses();\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n      // get back cameras to be used to reattach pipeline\n      this._cameras = this._camerasToBeAttached.slice();\n    }\n    this._reset();\n    this._prevPostProcess = null;\n    this._prevPrevPostProcess = null;\n    this._hasCleared = false;\n    if (this.depthOfFieldEnabled) {\n      // Multi camera suport\n      if (this._cameras.length > 1) {\n        for (const camera of this._cameras) {\n          const depthRenderer = this._scene.enableDepthRenderer(camera);\n          depthRenderer.useOnlyInActiveCamera = true;\n        }\n        this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add(scene => {\n          if (this._cameras.indexOf(scene.activeCamera) > -1) {\n            this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\n          }\n        });\n      } else {\n        this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n        const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\n        this.depthOfField.depthTexture = depthRenderer.getDepthMap();\n      }\n      if (!this.depthOfField._isReady()) {\n        this.depthOfField._updateEffects();\n      }\n      this.addEffect(this.depthOfField);\n      this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\n    } else {\n      this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n    }\n    if (this.bloomEnabled) {\n      if (!this.bloom._isReady()) {\n        this.bloom._updateEffects();\n      }\n      this.addEffect(this.bloom);\n      this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\n    }\n    if (this._imageProcessingEnabled) {\n      this.imageProcessing = new ImageProcessingPostProcess(\"imageProcessing\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, this.scene.imageProcessingConfiguration);\n      if (this._hdr) {\n        this.addEffect(new PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, () => {\n          return this.imageProcessing;\n        }, true));\n        this._setAutoClearAndTextureSharing(this.imageProcessing);\n      } else {\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n      }\n      if (!this._cameras || this._cameras.length === 0) {\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n      }\n      if (!this.imageProcessing.getEffect()) {\n        this.imageProcessing._updateParameters();\n      }\n    }\n    if (this.sharpenEnabled) {\n      if (!this.sharpen.isReady()) {\n        this.sharpen.updateEffect();\n      }\n      this.addEffect(this._sharpenEffect);\n      this._setAutoClearAndTextureSharing(this.sharpen);\n    }\n    if (this.grainEnabled) {\n      if (!this.grain.isReady()) {\n        this.grain.updateEffect();\n      }\n      this.addEffect(this._grainEffect);\n      this._setAutoClearAndTextureSharing(this.grain);\n    }\n    if (this.chromaticAberrationEnabled) {\n      if (!this.chromaticAberration.isReady()) {\n        this.chromaticAberration.updateEffect();\n      }\n      this.addEffect(this._chromaticAberrationEffect);\n      this._setAutoClearAndTextureSharing(this.chromaticAberration);\n    }\n    if (this.fxaaEnabled) {\n      this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n      this.addEffect(new PostProcessRenderEffect(engine, this.FxaaPostProcessId, () => {\n        return this.fxaa;\n      }, true));\n      this._setAutoClearAndTextureSharing(this.fxaa, true);\n    }\n    if (this._cameras !== null) {\n      this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n    }\n    // In multicamera mode, the scene needs to autoclear in between cameras.\n    if (this._scene.activeCameras && this._scene.activeCameras.length > 1 || this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\n      this._scene.autoClear = true;\n    }\n    // The active camera on the scene can be changed anytime\n    if (!this._activeCameraChangedObserver) {\n      this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {\n        if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\n          this._scene.autoClear = true;\n        }\n      });\n    }\n    if (!this._activeCamerasChangedObserver) {\n      this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {\n        if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\n          this._scene.autoClear = true;\n        }\n      });\n    }\n    if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\n      Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\n    }\n    this.onBuildObservable.notifyObservers(this);\n  }\n  _disposePostProcesses(disposeNonRecreated = false) {\n    for (let i = 0; i < this._cameras.length; i++) {\n      const camera = this._cameras[i];\n      if (this.imageProcessing) {\n        this.imageProcessing.dispose(camera);\n      }\n      if (this.fxaa) {\n        this.fxaa.dispose(camera);\n      }\n      // These are created in the constructor and should not be disposed on every pipeline change\n      if (disposeNonRecreated) {\n        if (this.sharpen) {\n          this.sharpen.dispose(camera);\n        }\n        if (this.depthOfField) {\n          this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\n          this.depthOfField.disposeEffects(camera);\n        }\n        if (this.bloom) {\n          this.bloom.disposeEffects(camera);\n        }\n        if (this.chromaticAberration) {\n          this.chromaticAberration.dispose(camera);\n        }\n        if (this.grain) {\n          this.grain.dispose(camera);\n        }\n        if (this._glowLayer) {\n          this._glowLayer.dispose();\n        }\n      }\n    }\n    this.imageProcessing = null;\n    this.fxaa = null;\n    if (disposeNonRecreated) {\n      this.sharpen = null;\n      this._sharpenEffect = null;\n      this.depthOfField = null;\n      this.bloom = null;\n      this.chromaticAberration = null;\n      this._chromaticAberrationEffect = null;\n      this.grain = null;\n      this._grainEffect = null;\n      this._glowLayer = null;\n    }\n  }\n  /**\n   * Adds a camera to the pipeline\n   * @param camera the camera to be added\n   */\n  addCamera(camera) {\n    this._camerasToBeAttached.push(camera);\n    this._buildPipeline();\n  }\n  /**\n   * Removes a camera from the pipeline\n   * @param camera the camera to remove\n   */\n  removeCamera(camera) {\n    const index = this._camerasToBeAttached.indexOf(camera);\n    this._camerasToBeAttached.splice(index, 1);\n    this._buildPipeline();\n  }\n  /**\n   * Dispose of the pipeline and stop all post processes\n   */\n  dispose() {\n    this.onBuildObservable.clear();\n    this._disposePostProcesses(true);\n    this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n    this._scene.autoClear = true;\n    if (this._resizeObserver) {\n      this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\n      this._resizeObserver = null;\n    }\n    this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);\n    this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);\n    this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\n    super.dispose();\n  }\n  /**\n   * Serialize the rendering pipeline (Used when exporting)\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"DefaultRenderingPipeline\";\n    return serializationObject;\n  }\n  /**\n   * Parse the serialized pipeline\n   * @param source Source pipeline.\n   * @param scene The scene to load the pipeline to.\n   * @param rootUrl The URL of the serialized pipeline.\n   * @returns An instantiated pipeline from the serialized object.\n   */\n  static Parse(source, scene, rootUrl) {\n    return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);\n  }\n}\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"sharpenEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomKernel\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"_bloomWeight\", void 0);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"_bloomThreshold\", void 0);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"_hdr\", void 0);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomWeight\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomThreshold\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomScale\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"bloomEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"depthOfFieldEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"depthOfFieldBlurLevel\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"fxaaEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"samples\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"imageProcessingEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"glowLayerEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"chromaticAberrationEnabled\", null);\n__decorate([serialize()], DefaultRenderingPipeline.prototype, \"grainEnabled\", null);\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","Observable","Logger","Texture","GlowLayer","SharpenPostProcess","ImageProcessingPostProcess","ChromaticAberrationPostProcess","GrainPostProcess","FxaaPostProcess","PostProcessRenderPipeline","PostProcessRenderEffect","DepthOfFieldEffect","DepthOfFieldEffectBlurLevel","BloomEffect","RegisterClass","EngineStore","DefaultRenderingPipeline","constructor","name","hdr","scene","LastCreatedScene","cameras","automaticBuild","getEngine","Low","_cameras","slice","_camerasToBeAttached","_buildAllowed","_scene","caps","getCaps","_hdr","textureHalfFloatRender","textureFloatRender","_defaultPipelineTextureType","postProcessRenderPipelineManager","addPipeline","engine","sharpen","BILINEAR_SAMPLINGMODE","_sharpenEffect","SharpenPostProcessId","depthOfField","_depthOfFieldBlurLevel","_hardwareScaleLevel","getHardwareScalingLevel","_resizeObserver","onResizeObservable","add","bloomKernel","_bloomKernel","bloom","_bloomScale","_bloomWeight","chromaticAberration","getRenderWidth","getRenderHeight","_chromaticAberrationEffect","ChromaticAberrationPostProcessId","grain","_grainEffect","GrainPostProcessId","_imageProcessingConfigurationObserver","imageProcessingConfiguration","onUpdateParameters","_downscale","_exposure","exposure","imageProcessingEnabled","isEnabled","_imageProcessingEnabled","_buildPipeline","value","sharpenEnabled","enabled","_sharpenEnabled","kernel","bloomWeight","weight","bloomThreshold","_bloomThreshold","threshold","bloomScale","_rebuildBloom","bloomEnabled","_bloomEnabled","oldBloom","i","length","disposeEffects","depthOfFieldEnabled","_depthOfFieldEnabled","depthOfFieldBlurLevel","oldDof","focalLength","focusDistance","fStop","lensSize","fxaaEnabled","_fxaaEnabled","samples","sampleCount","_samples","glowLayerEnabled","_glowLayer","dispose","glowLayer","chromaticAberrationEnabled","_chromaticAberrationEnabled","grainEnabled","_grainEnabled","getClassName","prepare","previousState","_setAutoClearAndTextureSharing","postProcess","skipTextureSharing","_hasCleared","autoClear","_prevPrevPostProcess","shareOutputWith","useOwnOutput","_prevPostProcess","_disposePostProcesses","detachCamerasFromRenderPipeline","_name","_reset","camera","depthRenderer","enableDepthRenderer","useOnlyInActiveCamera","_depthOfFieldSceneObserver","onAfterRenderTargetsRenderObservable","indexOf","activeCamera","depthTexture","getDepthMap","remove","_isReady","_updateEffects","addEffect","_effects","imageProcessing","ImageProcessingPostProcessId","applyByPostProcess","getEffect","_updateParameters","isReady","updateEffect","fxaa","FxaaPostProcessId","attachCamerasToRenderPipeline","activeCameras","_activeCameraChangedObserver","onActiveCameraChanged","_activeCamerasChangedObserver","onActiveCamerasChanged","_enableMSAAOnFirstPostProcess","Warn","onBuildObservable","notifyObservers","disposeNonRecreated","addCamera","push","removeCamera","index","splice","clear","serializationObject","Serialize","customType","Parse","source","rootUrl","__decorate"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/PostProcesses/RenderPipeline/Pipelines/defaultRenderingPipeline.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../../types\";\r\nimport { serialize, SerializationHelper } from \"../../../Misc/decorators\";\r\nimport type { Observer } from \"../../../Misc/observable\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { IAnimatable } from \"../../../Animations/animatable.interface\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Camera } from \"../../../Cameras/camera\";\r\nimport type { ImageProcessingConfiguration } from \"../../../Materials/imageProcessingConfiguration\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { Engine } from \"../../../Engines/engine\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport type { IDisposable, Scene } from \"../../../scene\";\r\nimport { GlowLayer } from \"../../../Layers/glowLayer\";\r\n\r\nimport type { PostProcess } from \"../../../PostProcesses/postProcess\";\r\nimport { SharpenPostProcess } from \"../../../PostProcesses/sharpenPostProcess\";\r\nimport { ImageProcessingPostProcess } from \"../../../PostProcesses/imageProcessingPostProcess\";\r\nimport { ChromaticAberrationPostProcess } from \"../../../PostProcesses/chromaticAberrationPostProcess\";\r\nimport { GrainPostProcess } from \"../../../PostProcesses/grainPostProcess\";\r\nimport { FxaaPostProcess } from \"../../../PostProcesses/fxaaPostProcess\";\r\nimport { PostProcessRenderPipeline } from \"../../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\r\nimport { PostProcessRenderEffect } from \"../../../PostProcesses/RenderPipeline/postProcessRenderEffect\";\r\nimport { DepthOfFieldEffect, DepthOfFieldEffectBlurLevel } from \"../../../PostProcesses/depthOfFieldEffect\";\r\nimport { BloomEffect } from \"../../../PostProcesses/bloomEffect\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\n\r\nimport \"../../../PostProcesses/RenderPipeline/postProcessRenderPipelineManagerSceneComponent\";\r\n\r\ndeclare type Animation = import(\"../../../Animations/animation\").Animation;\r\n\r\n/**\r\n * The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/defaultRenderingPipeline\r\n */\r\nexport class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable {\r\n    private _scene: Scene;\r\n    private _camerasToBeAttached: Array<Camera> = [];\r\n    /**\r\n     * ID of the sharpen post process,\r\n     */\r\n    private readonly SharpenPostProcessId = \"SharpenPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the image processing post process;\r\n     */\r\n    readonly ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\r\n    /**\r\n     * @ignore\r\n     * ID of the Fast Approximate Anti-Aliasing post process;\r\n     */\r\n    readonly FxaaPostProcessId = \"FxaaPostProcessEffect\";\r\n    /**\r\n     * ID of the chromatic aberration post process,\r\n     */\r\n    private readonly ChromaticAberrationPostProcessId = \"ChromaticAberrationPostProcessEffect\";\r\n    /**\r\n     * ID of the grain post process\r\n     */\r\n    private readonly GrainPostProcessId = \"GrainPostProcessEffect\";\r\n\r\n    // Post-processes\r\n    /**\r\n     * Sharpen post process which will apply a sharpen convolution to enhance edges\r\n     */\r\n    public sharpen: SharpenPostProcess;\r\n    private _sharpenEffect: PostProcessRenderEffect;\r\n    private bloom: BloomEffect;\r\n    /**\r\n     * Depth of field effect, applies a blur based on how far away objects are from the focus distance.\r\n     */\r\n    public depthOfField: DepthOfFieldEffect;\r\n    /**\r\n     * The Fast Approximate Anti-Aliasing post process which attempts to remove aliasing from an image.\r\n     */\r\n    public fxaa: FxaaPostProcess;\r\n    /**\r\n     * Image post processing pass used to perform operations such as tone mapping or color grading.\r\n     */\r\n    public imageProcessing: ImageProcessingPostProcess;\r\n    /**\r\n     * Chromatic aberration post process which will shift rgb colors in the image\r\n     */\r\n    public chromaticAberration: ChromaticAberrationPostProcess;\r\n    private _chromaticAberrationEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Grain post process which add noise to the image\r\n     */\r\n    public grain: GrainPostProcess;\r\n    private _grainEffect: PostProcessRenderEffect;\r\n    /**\r\n     * Glow post process which adds a glow to emissive areas of the image\r\n     */\r\n    private _glowLayer: Nullable<GlowLayer> = null;\r\n\r\n    /**\r\n     * Animations which can be used to tweak settings over a period of time\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    private _imageProcessingConfigurationObserver: Nullable<Observer<ImageProcessingConfiguration>> = null;\r\n    // Values\r\n    private _sharpenEnabled: boolean = false;\r\n    private _bloomEnabled: boolean = false;\r\n    private _depthOfFieldEnabled: boolean = false;\r\n    private _depthOfFieldBlurLevel = DepthOfFieldEffectBlurLevel.Low;\r\n    private _fxaaEnabled: boolean = false;\r\n    private _imageProcessingEnabled: boolean = true;\r\n    private _defaultPipelineTextureType: number;\r\n    private _bloomScale: number = 0.5;\r\n    private _chromaticAberrationEnabled: boolean = false;\r\n    private _grainEnabled: boolean = false;\r\n\r\n    private _buildAllowed = true;\r\n\r\n    /**\r\n     * Enable or disable automatic building of the pipeline when effects are enabled and disabled.\r\n     * If false, you will have to manually call prepare() to update the pipeline.\r\n     */\r\n    public get automaticBuild() {\r\n        return this._buildAllowed;\r\n    }\r\n    public set automaticBuild(value: boolean) {\r\n        this._buildAllowed = value;\r\n    }\r\n\r\n    /**\r\n     * This is triggered each time the pipeline has been built.\r\n     */\r\n    public onBuildObservable = new Observable<DefaultRenderingPipeline>();\r\n\r\n    /**\r\n     * Gets active scene\r\n     */\r\n    public get scene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the sharpen process from the pipeline\r\n     */\r\n    public set sharpenEnabled(enabled: boolean) {\r\n        if (this._sharpenEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._sharpenEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get sharpenEnabled(): boolean {\r\n        return this._sharpenEnabled;\r\n    }\r\n\r\n    private _resizeObserver: Nullable<Observer<Engine>> = null;\r\n    private _hardwareScaleLevel = 1.0;\r\n    private _bloomKernel: number = 64;\r\n    /**\r\n     * Specifies the size of the bloom blur kernel, relative to the final output size\r\n     */\r\n    @serialize()\r\n    public get bloomKernel(): number {\r\n        return this._bloomKernel;\r\n    }\r\n    public set bloomKernel(value: number) {\r\n        this._bloomKernel = value;\r\n        this.bloom.kernel = value / this._hardwareScaleLevel;\r\n    }\r\n\r\n    /**\r\n     * Specifies the weight of the bloom in the final rendering\r\n     */\r\n    @serialize()\r\n    private _bloomWeight: number = 0.15;\r\n    /**\r\n     * Specifies the luma threshold for the area that will be blurred by the bloom\r\n     */\r\n    @serialize()\r\n    private _bloomThreshold: number = 0.9;\r\n\r\n    @serialize()\r\n    private _hdr: boolean;\r\n\r\n    /**\r\n     * The strength of the bloom.\r\n     */\r\n    public set bloomWeight(value: number) {\r\n        if (this._bloomWeight === value) {\r\n            return;\r\n        }\r\n        this.bloom.weight = value;\r\n\r\n        this._bloomWeight = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomWeight(): number {\r\n        return this._bloomWeight;\r\n    }\r\n\r\n    /**\r\n     * The luminance threshold to find bright areas of the image to bloom.\r\n     */\r\n    public set bloomThreshold(value: number) {\r\n        if (this._bloomThreshold === value) {\r\n            return;\r\n        }\r\n        this.bloom.threshold = value;\r\n        this._bloomThreshold = value;\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomThreshold(): number {\r\n        return this._bloomThreshold;\r\n    }\r\n\r\n    /**\r\n     * The scale of the bloom, lower value will provide better performance.\r\n     */\r\n    public set bloomScale(value: number) {\r\n        if (this._bloomScale === value) {\r\n            return;\r\n        }\r\n        this._bloomScale = value;\r\n\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        this._rebuildBloom();\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomScale(): number {\r\n        return this._bloomScale;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the bloom from the pipeline\r\n     */\r\n    public set bloomEnabled(enabled: boolean) {\r\n        if (this._bloomEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._bloomEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get bloomEnabled(): boolean {\r\n        return this._bloomEnabled;\r\n    }\r\n\r\n    private _rebuildBloom() {\r\n        // recreate bloom and dispose old as this setting is not dynamic\r\n        const oldBloom = this.bloom;\r\n        this.bloom = new BloomEffect(this._scene, this.bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, false);\r\n        this.bloom.threshold = oldBloom.threshold;\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldBloom.disposeEffects(this._cameras[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * If the depth of field is enabled.\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldEnabled(): boolean {\r\n        return this._depthOfFieldEnabled;\r\n    }\r\n\r\n    public set depthOfFieldEnabled(enabled: boolean) {\r\n        if (this._depthOfFieldEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._depthOfFieldEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Blur level of the depth of field effect. (Higher blur will effect performance)\r\n     */\r\n    @serialize()\r\n    public get depthOfFieldBlurLevel(): DepthOfFieldEffectBlurLevel {\r\n        return this._depthOfFieldBlurLevel;\r\n    }\r\n\r\n    public set depthOfFieldBlurLevel(value: DepthOfFieldEffectBlurLevel) {\r\n        if (this._depthOfFieldBlurLevel === value) {\r\n            return;\r\n        }\r\n        this._depthOfFieldBlurLevel = value;\r\n\r\n        // recreate dof and dispose old as this setting is not dynamic\r\n        const oldDof = this.depthOfField;\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, false);\r\n        this.depthOfField.focalLength = oldDof.focalLength;\r\n        this.depthOfField.focusDistance = oldDof.focusDistance;\r\n        this.depthOfField.fStop = oldDof.fStop;\r\n        this.depthOfField.lensSize = oldDof.lensSize;\r\n\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            oldDof.disposeEffects(this._cameras[i]);\r\n        }\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * If the anti aliasing is enabled.\r\n     */\r\n    public set fxaaEnabled(enabled: boolean) {\r\n        if (this._fxaaEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._fxaaEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get fxaaEnabled(): boolean {\r\n        return this._fxaaEnabled;\r\n    }\r\n\r\n    private _samples = 1;\r\n    /**\r\n     * MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)\r\n     */\r\n    public set samples(sampleCount: number) {\r\n        if (this._samples === sampleCount) {\r\n            return;\r\n        }\r\n        this._samples = sampleCount;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get samples(): number {\r\n        return this._samples;\r\n    }\r\n\r\n    /**\r\n     * If image processing is enabled.\r\n     */\r\n    public set imageProcessingEnabled(enabled: boolean) {\r\n        if (this._imageProcessingEnabled === enabled) {\r\n            return;\r\n        }\r\n\r\n        this._scene.imageProcessingConfiguration.isEnabled = enabled;\r\n    }\r\n\r\n    @serialize()\r\n    public get imageProcessingEnabled(): boolean {\r\n        return this._imageProcessingEnabled;\r\n    }\r\n\r\n    /**\r\n     * If glow layer is enabled. (Adds a glow effect to emmissive materials)\r\n     */\r\n    public set glowLayerEnabled(enabled: boolean) {\r\n        if (enabled && !this._glowLayer) {\r\n            this._glowLayer = new GlowLayer(\"\", this._scene);\r\n        } else if (!enabled && this._glowLayer) {\r\n            this._glowLayer.dispose();\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    @serialize()\r\n    public get glowLayerEnabled(): boolean {\r\n        return this._glowLayer != null;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow layer (or null if not defined)\r\n     */\r\n    public get glowLayer() {\r\n        return this._glowLayer;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the chromaticAberration process from the pipeline\r\n     */\r\n    public set chromaticAberrationEnabled(enabled: boolean) {\r\n        if (this._chromaticAberrationEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._chromaticAberrationEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get chromaticAberrationEnabled(): boolean {\r\n        return this._chromaticAberrationEnabled;\r\n    }\r\n    /**\r\n     * Enable or disable the grain process from the pipeline\r\n     */\r\n    public set grainEnabled(enabled: boolean) {\r\n        if (this._grainEnabled === enabled) {\r\n            return;\r\n        }\r\n        this._grainEnabled = enabled;\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    @serialize()\r\n    public get grainEnabled(): boolean {\r\n        return this._grainEnabled;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a DefaultRenderingPipeline.\r\n     * @param name The rendering pipeline name (default: \"\")\r\n     * @param hdr If high dynamic range textures should be used (default: true)\r\n     * @param scene The scene linked to this pipeline (default: the last created scene)\r\n     * @param cameras The array of cameras that the rendering pipeline will be attached to (default: scene.cameras)\r\n     * @param automaticBuild If false, you will have to manually call prepare() to update the pipeline (default: true)\r\n     */\r\n    constructor(name = \"\", hdr = true, scene: Scene = EngineStore.LastCreatedScene!, cameras?: Camera[], automaticBuild = true) {\r\n        super(scene.getEngine(), name);\r\n        this._cameras = cameras || scene.cameras;\r\n        this._cameras = this._cameras.slice();\r\n        this._camerasToBeAttached = this._cameras.slice();\r\n\r\n        this._buildAllowed = automaticBuild;\r\n\r\n        // Initialize\r\n        this._scene = scene;\r\n        const caps = this._scene.getEngine().getCaps();\r\n        this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\r\n\r\n        // Misc\r\n        if (this._hdr) {\r\n            if (caps.textureHalfFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                this._defaultPipelineTextureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        } else {\r\n            this._defaultPipelineTextureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        // Attach\r\n        scene.postProcessRenderPipelineManager.addPipeline(this);\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Create post processes before hand so they can be modified before enabled.\r\n        // Block compilation flag is set to true to avoid compilation prior to use, these will be updated on first use in build pipeline.\r\n        this.sharpen = new SharpenPostProcess(\"sharpen\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._sharpenEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.SharpenPostProcessId,\r\n            () => {\r\n                return this.sharpen;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.depthOfField = new DepthOfFieldEffect(this._scene, null, this._depthOfFieldBlurLevel, this._defaultPipelineTextureType, true);\r\n\r\n        // To keep the bloom sizes consistent across different display densities, factor in the hardware scaling level.\r\n        this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n        this._resizeObserver = engine.onResizeObservable.add(() => {\r\n            this._hardwareScaleLevel = engine.getHardwareScalingLevel();\r\n            this.bloomKernel = this._bloomKernel;\r\n        });\r\n\r\n        this.bloom = new BloomEffect(this._scene, this._bloomScale, this._bloomWeight, this.bloomKernel / this._hardwareScaleLevel, this._defaultPipelineTextureType, true);\r\n\r\n        this.chromaticAberration = new ChromaticAberrationPostProcess(\r\n            \"ChromaticAberration\",\r\n            engine.getRenderWidth(),\r\n            engine.getRenderHeight(),\r\n            1.0,\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            this._defaultPipelineTextureType,\r\n            true\r\n        );\r\n        this._chromaticAberrationEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.ChromaticAberrationPostProcessId,\r\n            () => {\r\n                return this.chromaticAberration;\r\n            },\r\n            true\r\n        );\r\n\r\n        this.grain = new GrainPostProcess(\"Grain\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType, true);\r\n        this._grainEffect = new PostProcessRenderEffect(\r\n            engine,\r\n            this.GrainPostProcessId,\r\n            () => {\r\n                return this.grain;\r\n            },\r\n            true\r\n        );\r\n\r\n        this._imageProcessingConfigurationObserver = this._scene.imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n            this.bloom._downscale._exposure = this._scene.imageProcessingConfiguration.exposure;\r\n\r\n            if (this.imageProcessingEnabled !== this._scene.imageProcessingConfiguration.isEnabled) {\r\n                this._imageProcessingEnabled = this._scene.imageProcessingConfiguration.isEnabled;\r\n                this._buildPipeline();\r\n            }\r\n        });\r\n\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns \"DefaultRenderingPipeline\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DefaultRenderingPipeline\";\r\n    }\r\n\r\n    /**\r\n     * Force the compilation of the entire pipeline.\r\n     */\r\n    public prepare(): void {\r\n        const previousState = this._buildAllowed;\r\n        this._buildAllowed = true;\r\n        this._buildPipeline();\r\n        this._buildAllowed = previousState;\r\n    }\r\n\r\n    private _hasCleared = false;\r\n    private _prevPostProcess: Nullable<PostProcess> = null;\r\n    private _prevPrevPostProcess: Nullable<PostProcess> = null;\r\n\r\n    private _setAutoClearAndTextureSharing(postProcess: PostProcess, skipTextureSharing = false) {\r\n        if (this._hasCleared) {\r\n            postProcess.autoClear = false;\r\n        } else {\r\n            postProcess.autoClear = true;\r\n            this._scene.autoClear = false;\r\n            this._hasCleared = true;\r\n        }\r\n\r\n        if (!skipTextureSharing) {\r\n            if (this._prevPrevPostProcess) {\r\n                postProcess.shareOutputWith(this._prevPrevPostProcess);\r\n            } else {\r\n                postProcess.useOwnOutput();\r\n            }\r\n\r\n            if (this._prevPostProcess) {\r\n                this._prevPrevPostProcess = this._prevPostProcess;\r\n            }\r\n            this._prevPostProcess = postProcess;\r\n        }\r\n    }\r\n\r\n    private _depthOfFieldSceneObserver: Nullable<Observer<Scene>> = null;\r\n    private _activeCameraChangedObserver: Nullable<Observer<Scene>> = null;\r\n    private _activeCamerasChangedObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    private _buildPipeline() {\r\n        if (!this._buildAllowed) {\r\n            return;\r\n        }\r\n        this._scene.autoClear = true;\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._disposePostProcesses();\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n            // get back cameras to be used to reattach pipeline\r\n            this._cameras = this._camerasToBeAttached.slice();\r\n        }\r\n        this._reset();\r\n        this._prevPostProcess = null;\r\n        this._prevPrevPostProcess = null;\r\n        this._hasCleared = false;\r\n\r\n        if (this.depthOfFieldEnabled) {\r\n            // Multi camera suport\r\n            if (this._cameras.length > 1) {\r\n                for (const camera of this._cameras) {\r\n                    const depthRenderer = this._scene.enableDepthRenderer(camera);\r\n                    depthRenderer.useOnlyInActiveCamera = true;\r\n                }\r\n\r\n                this._depthOfFieldSceneObserver = this._scene.onAfterRenderTargetsRenderObservable.add((scene) => {\r\n                    if (this._cameras.indexOf(scene.activeCamera!) > -1) {\r\n                        this.depthOfField.depthTexture = scene.enableDepthRenderer(scene.activeCamera).getDepthMap();\r\n                    }\r\n                });\r\n            } else {\r\n                this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                const depthRenderer = this._scene.enableDepthRenderer(this._cameras[0]);\r\n                this.depthOfField.depthTexture = depthRenderer.getDepthMap();\r\n            }\r\n\r\n            if (!this.depthOfField._isReady()) {\r\n                this.depthOfField._updateEffects();\r\n            }\r\n            this.addEffect(this.depthOfField);\r\n            this._setAutoClearAndTextureSharing(this.depthOfField._effects[0], true);\r\n        } else {\r\n            this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n        }\r\n\r\n        if (this.bloomEnabled) {\r\n            if (!this.bloom._isReady()) {\r\n                this.bloom._updateEffects();\r\n            }\r\n            this.addEffect(this.bloom);\r\n            this._setAutoClearAndTextureSharing(this.bloom._effects[0], true);\r\n        }\r\n\r\n        if (this._imageProcessingEnabled) {\r\n            this.imageProcessing = new ImageProcessingPostProcess(\r\n                \"imageProcessing\",\r\n                1.0,\r\n                null,\r\n                Texture.BILINEAR_SAMPLINGMODE,\r\n                engine,\r\n                false,\r\n                this._defaultPipelineTextureType,\r\n                this.scene.imageProcessingConfiguration\r\n            );\r\n            if (this._hdr) {\r\n                this.addEffect(\r\n                    new PostProcessRenderEffect(\r\n                        engine,\r\n                        this.ImageProcessingPostProcessId,\r\n                        () => {\r\n                            return this.imageProcessing;\r\n                        },\r\n                        true\r\n                    )\r\n                );\r\n                this._setAutoClearAndTextureSharing(this.imageProcessing);\r\n            } else {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this._cameras || this._cameras.length === 0) {\r\n                this._scene.imageProcessingConfiguration.applyByPostProcess = false;\r\n            }\r\n\r\n            if (!this.imageProcessing.getEffect()) {\r\n                this.imageProcessing._updateParameters();\r\n            }\r\n        }\r\n\r\n        if (this.sharpenEnabled) {\r\n            if (!this.sharpen.isReady()) {\r\n                this.sharpen.updateEffect();\r\n            }\r\n            this.addEffect(this._sharpenEffect);\r\n            this._setAutoClearAndTextureSharing(this.sharpen);\r\n        }\r\n\r\n        if (this.grainEnabled) {\r\n            if (!this.grain.isReady()) {\r\n                this.grain.updateEffect();\r\n            }\r\n            this.addEffect(this._grainEffect);\r\n            this._setAutoClearAndTextureSharing(this.grain);\r\n        }\r\n\r\n        if (this.chromaticAberrationEnabled) {\r\n            if (!this.chromaticAberration.isReady()) {\r\n                this.chromaticAberration.updateEffect();\r\n            }\r\n            this.addEffect(this._chromaticAberrationEffect);\r\n            this._setAutoClearAndTextureSharing(this.chromaticAberration);\r\n        }\r\n\r\n        if (this.fxaaEnabled) {\r\n            this.fxaa = new FxaaPostProcess(\"fxaa\", 1.0, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\r\n            this.addEffect(\r\n                new PostProcessRenderEffect(\r\n                    engine,\r\n                    this.FxaaPostProcessId,\r\n                    () => {\r\n                        return this.fxaa;\r\n                    },\r\n                    true\r\n                )\r\n            );\r\n            this._setAutoClearAndTextureSharing(this.fxaa, true);\r\n        }\r\n\r\n        if (this._cameras !== null) {\r\n            this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\r\n        }\r\n\r\n        // In multicamera mode, the scene needs to autoclear in between cameras.\r\n        if ((this._scene.activeCameras && this._scene.activeCameras.length > 1) || (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1)) {\r\n            this._scene.autoClear = true;\r\n        }\r\n        // The active camera on the scene can be changed anytime\r\n        if (!this._activeCameraChangedObserver) {\r\n            this._activeCameraChangedObserver = this._scene.onActiveCameraChanged.add(() => {\r\n                if (this._scene.activeCamera && this._cameras.indexOf(this._scene.activeCamera) === -1) {\r\n                    this._scene.autoClear = true;\r\n                }\r\n            });\r\n        }\r\n        if (!this._activeCamerasChangedObserver) {\r\n            this._activeCamerasChangedObserver = this._scene.onActiveCamerasChanged.add(() => {\r\n                if (this._scene.activeCameras && this._scene.activeCameras.length > 1) {\r\n                    this._scene.autoClear = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!this._enableMSAAOnFirstPostProcess(this.samples) && this.samples > 1) {\r\n            Logger.Warn(\"MSAA failed to enable, MSAA is only supported in browsers that support webGL >= 2.0\");\r\n        }\r\n\r\n        this.onBuildObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _disposePostProcesses(disposeNonRecreated = false): void {\r\n        for (let i = 0; i < this._cameras.length; i++) {\r\n            const camera = this._cameras[i];\r\n\r\n            if (this.imageProcessing) {\r\n                this.imageProcessing.dispose(camera);\r\n            }\r\n\r\n            if (this.fxaa) {\r\n                this.fxaa.dispose(camera);\r\n            }\r\n\r\n            // These are created in the constructor and should not be disposed on every pipeline change\r\n            if (disposeNonRecreated) {\r\n                if (this.sharpen) {\r\n                    this.sharpen.dispose(camera);\r\n                }\r\n\r\n                if (this.depthOfField) {\r\n                    this._scene.onAfterRenderTargetsRenderObservable.remove(this._depthOfFieldSceneObserver);\r\n                    this.depthOfField.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.bloom) {\r\n                    this.bloom.disposeEffects(camera);\r\n                }\r\n\r\n                if (this.chromaticAberration) {\r\n                    this.chromaticAberration.dispose(camera);\r\n                }\r\n\r\n                if (this.grain) {\r\n                    this.grain.dispose(camera);\r\n                }\r\n                if (this._glowLayer) {\r\n                    this._glowLayer.dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        (<any>this.imageProcessing) = null;\r\n        (<any>this.fxaa) = null;\r\n\r\n        if (disposeNonRecreated) {\r\n            (<any>this.sharpen) = null;\r\n            (<any>this._sharpenEffect) = null;\r\n            (<any>this.depthOfField) = null;\r\n            (<any>this.bloom) = null;\r\n            (<any>this.chromaticAberration) = null;\r\n            (<any>this._chromaticAberrationEffect) = null;\r\n            (<any>this.grain) = null;\r\n            (<any>this._grainEffect) = null;\r\n            this._glowLayer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a camera to the pipeline\r\n     * @param camera the camera to be added\r\n     */\r\n    public addCamera(camera: Camera): void {\r\n        this._camerasToBeAttached.push(camera);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Removes a camera from the pipeline\r\n     * @param camera the camera to remove\r\n     */\r\n    public removeCamera(camera: Camera): void {\r\n        const index = this._camerasToBeAttached.indexOf(camera);\r\n        this._camerasToBeAttached.splice(index, 1);\r\n        this._buildPipeline();\r\n    }\r\n\r\n    /**\r\n     * Dispose of the pipeline and stop all post processes\r\n     */\r\n    public dispose(): void {\r\n        this.onBuildObservable.clear();\r\n        this._disposePostProcesses(true);\r\n        this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\r\n        this._scene.autoClear = true;\r\n        if (this._resizeObserver) {\r\n            this._scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n            this._resizeObserver = null;\r\n        }\r\n\r\n        this._scene.onActiveCameraChanged.remove(this._activeCameraChangedObserver);\r\n        this._scene.onActiveCamerasChanged.remove(this._activeCamerasChangedObserver);\r\n\r\n        this._scene.imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingConfigurationObserver);\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the rendering pipeline (Used when exporting)\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"DefaultRenderingPipeline\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the serialized pipeline\r\n     * @param source Source pipeline.\r\n     * @param scene The scene to load the pipeline to.\r\n     * @param rootUrl The URL of the serialized pipeline.\r\n     * @returns An instantiated pipeline from the serialized object.\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): DefaultRenderingPipeline {\r\n        return SerializationHelper.Parse(() => new DefaultRenderingPipeline(source._name, source._name._hdr, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.DefaultRenderingPipeline\", DefaultRenderingPipeline);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}