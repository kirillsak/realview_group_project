{"ast":null,"code":"import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { ReflectionTextureBaseBlock } from \"./reflectionTextureBaseBlock.js\";\n/**\n * Block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBlock extends ReflectionTextureBaseBlock {\n  _onGenerateOnlyFragmentCodeChanged() {\n    if (this.position.isConnected) {\n      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n      console.error(\"The position input must not be connected to be able to switch!\");\n      return false;\n    }\n    if (this.worldPosition.isConnected) {\n      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n      console.error(\"The worldPosition input must not be connected to be able to switch!\");\n      return false;\n    }\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    super._setTarget();\n    this.getInputByName(\"position\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n    this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n  }\n  /**\n   * Create a new ReflectionTextureBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment); // Flagging as fragment as the normal can be changed by fragment code\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionTextureBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the world input component\n   */\n  get world() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  autoConfigure(material) {\n    super.autoConfigure(material);\n    if (!this.cameraPosition.isConnected) {\n      let cameraPositionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.CameraPosition);\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (!this.texture) {\n      state.compilationString += this.writeOutputs(state, \"vec4(0.)\");\n      return this;\n    }\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      state.compilationString += this.handleVertexSide(state);\n      return this;\n    }\n    if (this.generateOnlyFragmentCode) {\n      state.compilationString += this.handleVertexSide(state);\n    }\n    this.handleFragmentSideInits(state);\n    const normalWUnit = state._getFreeVariableName(\"normalWUnit\");\n    state.compilationString += `vec4 ${normalWUnit} = normalize(${this.worldNormal.associatedVariableName});\\r\\n`;\n    state.compilationString += this.handleFragmentSideCodeReflectionCoords(normalWUnit);\n    state.compilationString += this.handleFragmentSideCodeReflectionColor(undefined, \"\");\n    state.compilationString += this.writeOutputs(state, this._reflectionColorName);\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.ReflectionTextureBlock\", ReflectionTextureBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","InputBlock","NodeMaterialSystemValues","ReflectionTextureBaseBlock","ReflectionTextureBlock","_onGenerateOnlyFragmentCodeChanged","position","isConnected","generateOnlyFragmentCode","console","error","worldPosition","_setTarget","getInputByName","target","Fragment","Vertex","constructor","name","registerInput","AutoDetect","Vector4","Matrix","Vector3","registerOutput","Color3","Color4","Float","_inputs","addExcludedConnectionPointFromAllowedTypes","getClassName","worldNormal","world","cameraPosition","view","rgb","_outputs","rgba","r","g","b","a","autoConfigure","material","cameraPositionInput","getInputBlockByPredicate","systemValue","CameraPosition","setAsSystemValue","output","connectTo","_buildBlock","state","texture","compilationString","writeOutputs","handleVertexSide","handleFragmentSideInits","normalWUnit","_getFreeVariableName","associatedVariableName","handleFragmentSideCodeReflectionCoords","handleFragmentSideCodeReflectionColor","undefined","_reflectionColorName"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/reflectionTextureBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterial } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { ReflectionTextureBaseBlock } from \"./reflectionTextureBaseBlock\";\r\n\r\n/**\r\n * Block used to read a reflection texture from a sampler\r\n */\r\nexport class ReflectionTextureBlock extends ReflectionTextureBaseBlock {\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        if (this.position.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            console.error(\"The position input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        if (this.worldPosition.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            console.error(\"The worldPosition input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        this._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        super._setTarget();\r\n        this.getInputByName(\"position\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n        this.getInputByName(\"worldPosition\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment); // Flagging as fragment as the normal can be changed by fragment code\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        super.autoConfigure(material);\r\n\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.texture) {\r\n            state.compilationString += this.writeOutputs(state, \"vec4(0.)\");\r\n            return this;\r\n        }\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            state.compilationString += this.handleVertexSide(state);\r\n            return this;\r\n        }\r\n\r\n        if (this.generateOnlyFragmentCode) {\r\n            state.compilationString += this.handleVertexSide(state);\r\n        }\r\n\r\n        this.handleFragmentSideInits(state);\r\n\r\n        const normalWUnit = state._getFreeVariableName(\"normalWUnit\");\r\n\r\n        state.compilationString += `vec4 ${normalWUnit} = normalize(${this.worldNormal.associatedVariableName});\\r\\n`;\r\n\r\n        state.compilationString += this.handleFragmentSideCodeReflectionCoords(normalWUnit);\r\n\r\n        state.compilationString += this.handleFragmentSideCodeReflectionColor(undefined, \"\");\r\n\r\n        state.compilationString += this.writeOutputs(state, this._reflectionColorName);\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBlock\", ReflectionTextureBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}