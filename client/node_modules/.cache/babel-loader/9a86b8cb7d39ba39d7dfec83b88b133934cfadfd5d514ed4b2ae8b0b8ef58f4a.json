{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport \"../Shaders/depth.fragment.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper.js\";\n/**\n * This represents a depth renderer in Babylon.\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\n */\nexport class DepthRenderer {\n  /**\n   * Instantiates a depth renderer\n   * @param scene The scene the renderer belongs to\n   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\n   * @param camera The camera to be used to render the depth map (default: scene's active camera)\n   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\n   * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\n   */\n  constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE) {\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\n    this.enabled = true;\n    /** Force writing the transparent objects into the depth map */\n    this.forceDepthWriteTransparentMeshes = false;\n    /**\n     * Specifies that the depth renderer will only be used within\n     * the camera it is created for.\n     * This can help forcing its rendering during the camera processing.\n     */\n    this.useOnlyInActiveCamera = false;\n    this._scene = scene;\n    this._storeNonLinearDepth = storeNonLinearDepth;\n    this.isPacked = type === 0;\n    if (this.isPacked) {\n      this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\n    } else {\n      this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\n    }\n    DepthRenderer._SceneComponentInitialization(this._scene);\n    const engine = scene.getEngine();\n    this._camera = camera;\n    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\n      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {\n        samplingMode = Texture.NEAREST_SAMPLINGMODE;\n      }\n    }\n    // Render target\n    const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;\n    this._depthMap = new RenderTargetTexture(\"DepthRenderer\", {\n      width: engine.getRenderWidth(),\n      height: engine.getRenderHeight()\n    }, this._scene, false, true, type, false, samplingMode, undefined, undefined, undefined, format);\n    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._depthMap.refreshRate = 1;\n    this._depthMap.renderParticles = false;\n    this._depthMap.renderList = null;\n    // Camera to get depth map from to support multiple concurrent cameras\n    this._depthMap.activeCamera = this._camera;\n    this._depthMap.ignoreCameraViewport = true;\n    this._depthMap.useCameraPostProcesses = false;\n    // set default depth value to 1.0 (far away)\n    this._depthMap.onClearObservable.add(engine => {\n      engine.clear(this._clearColor, true, true, true);\n    });\n    this._depthMap.onBeforeBindObservable.add(() => {\n      var _a;\n      (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, \"depth renderer\", 1);\n    });\n    this._depthMap.onAfterUnbindObservable.add(() => {\n      var _a;\n      (_a = engine._debugPopGroup) === null || _a === void 0 ? void 0 : _a.call(engine, 1);\n    });\n    this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const renderingMesh = subMesh.getRenderingMesh();\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n          if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    // Custom render function\n    const renderSubMesh = subMesh => {\n      var _a, _b;\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      const scene = this._scene;\n      const engine = scene.getEngine();\n      const material = subMesh.getMaterial();\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\n        return;\n      }\n      // Culling\n      const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\n      let sideOrientation = (_a = renderingMesh.overrideMaterialSideOrientation) !== null && _a !== void 0 ? _a : material.sideOrientation;\n      if (detNeg) {\n        sideOrientation = sideOrientation === 0 ? 1 : 0;\n      }\n      const reverseSideOrientation = sideOrientation === 0;\n      engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces);\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined || renderingMesh.hasThinInstances);\n      const camera = this._camera || scene.activeCamera;\n      if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\n        subMesh._renderId = scene.getRenderId();\n        const renderingMaterial = (_b = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _b === void 0 ? void 0 : _b[engine.currentRenderPassId];\n        let drawWrapper = subMesh._getDrawWrapper();\n        if (!drawWrapper && renderingMaterial) {\n          drawWrapper = renderingMaterial._getDrawWrapper();\n        }\n        const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (!renderingMaterial) {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        } else {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        }\n        let minZ, maxZ;\n        if (cameraIsOrtho) {\n          minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n        } else {\n          minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n          maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n        }\n        effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n        if (!renderingMaterial) {\n          // Alpha test\n          if (material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            if (alphaTexture) {\n              effect.setTexture(\"diffuseSampler\", alphaTexture);\n              effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          }\n          // Bones\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            const skeleton = renderingMesh.skeleton;\n            if (skeleton.isUsingTextureForMatrices) {\n              const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\n              if (!boneTexture) {\n                return;\n              }\n              effect.setTexture(\"boneSampler\", boneTexture);\n              effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n            } else {\n              effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\n            }\n          }\n          // Clip planes\n          bindClipPlane(effect, material, scene);\n          // Morph targets\n          MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\n          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n            renderingMesh.morphTargetManager._bind(effect);\n          }\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix(\"world\", world));\n      }\n    };\n    this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      let index;\n      if (depthOnlySubMeshes.length) {\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (this.forceDepthWriteTransparentMeshes) {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          renderSubMesh(transparentSubMeshes.data[index]);\n        }\n      } else {\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n        }\n      }\n    };\n  }\n  /**\n   * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\n   * @param mesh mesh or array of meshes\n   * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\n   */\n  setMaterialForRendering(mesh, material) {\n    this._depthMap.setMaterialForRendering(mesh, material);\n  }\n  /**\n   * Creates the depth rendering effect and checks if the effect is ready.\n   * @param subMesh The submesh to be used to render the depth map of\n   * @param useInstances If multiple world instances should be used\n   * @returns if the depth renderer is ready to render the depth map\n   */\n  isReady(subMesh, useInstances) {\n    var _a;\n    const engine = this._scene.getEngine();\n    const mesh = subMesh.getMesh();\n    const scene = mesh.getScene();\n    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const material = subMesh.getMaterial();\n    if (!material || material.disableDepthWrite) {\n      return false;\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    // Alpha test\n    if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\n      defines.push(\"#define ALPHATEST\");\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      if (mesh.numBoneInfluencers > 4) {\n        attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n      }\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n      const skeleton = subMesh.getRenderingMesh().skeleton;\n      if (skeleton === null || skeleton === void 0 ? void 0 : skeleton.isUsingTextureForMatrices) {\n        defines.push(\"#define BONETEXTURE\");\n      }\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Morph targets\n    const morphTargetManager = mesh.morphTargetManager;\n    let numMorphInfluencers = 0;\n    if (morphTargetManager) {\n      if (morphTargetManager.numInfluencers > 0) {\n        numMorphInfluencers = morphTargetManager.numInfluencers;\n        defines.push(\"#define MORPHTARGETS\");\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\n        if (morphTargetManager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n        }\n        MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\n      }\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // None linear depth\n    if (this._storeNonLinearDepth) {\n      defines.push(\"#define NONLINEARDEPTH\");\n    }\n    // Float Mode\n    if (this.isPacked) {\n      defines.push(\"#define PACKED\");\n    }\n    // Clip planes\n    prepareDefinesForClipPlanes(material, scene, defines);\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      const uniforms = [\"world\", \"mBones\", \"boneTextureWidth\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\", \"morphTargetInfluences\", \"morphTargetTextureInfo\", \"morphTargetTextureIndices\"];\n      addClipPlaneUniforms(uniforms);\n      drawWrapper.setEffect(engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: numMorphInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Gets the texture which the depth map will be written to.\n   * @returns The depth map texture\n   */\n  getDepthMap() {\n    return this._depthMap;\n  }\n  /**\n   * Disposes of the depth renderer.\n   */\n  dispose() {\n    const keysToDelete = [];\n    for (const key in this._scene._depthRenderer) {\n      const depthRenderer = this._scene._depthRenderer[key];\n      if (depthRenderer === this) {\n        keysToDelete.push(key);\n      }\n    }\n    if (keysToDelete.length > 0) {\n      this._depthMap.dispose();\n      for (const key of keysToDelete) {\n        delete this._scene._depthRenderer[key];\n      }\n    }\n  }\n}\n/**\n * @internal\n */\nDepthRenderer._SceneComponentInitialization = _ => {\n  throw _WarnImport(\"DepthRendererSceneComponent\");\n};","map":{"version":3,"mappings":";AACA,SAASA,MAAM,QAAQ,wBAAsB;AAG7C,SAASC,YAAY,QAAQ,sBAAoB;AAGjD,SAASC,OAAO,QAAQ,kCAAgC;AACxD,SAASC,mBAAmB,QAAQ,8CAA4C;AAChF,SAASC,cAAc,QAAQ,gCAA8B;AAC7D,SAASC,MAAM,QAAQ,sBAAoB;AAG3C,OAAO,8BAA4B;AACnC,OAAO,4BAA0B;AACjC,SAASC,WAAW,QAAQ,qBAAmB;AAC/C,SAASC,oBAAoB,EAAEC,aAAa,EAAEC,2BAA2B,QAAQ,yCAAuC;AAKxH;;;;AAIA,OAAM,MAAOC,aAAa;EAwCtB;;;;;;;;EAQAC,YACIC,KAAY,EACZC,OAAe,SAAS,GAAC,yBACzB,GAA2B,KAC3B,wBAAsB,uBACP;IA1CnB;IACO,YAAO,GAAG,IAAI;IAErB;IACO,qCAAgC,GAAG,KAAK;IAE/C;;;;;IAKO,0BAAqB,GAAY,KAAK;IAiCzC,IAAI,CAACC,MAAM,GAAGF,KAAK;IACnB,IAAI,CAACG,oBAAoB,GAAGC,mBAAmB;IAC/C,IAAI,CAACC,QAAQ,GAAGJ,IAAI,KAAK;IACzB,IAAI,IAAI,CAACI,QAAQ,EAAE;MACf,IAAI,CAACC,WAAW,GAAG,IAAIlB,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;KACpD,MAAM;MACH,IAAI,CAACkB,WAAW,GAAG,IAAIlB,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;;IAGrDU,aAAa,CAACS,6BAA6B,CAAC,IAAI,CAACL,MAAM,CAAC;IAExD,MAAMM,MAAM,GAAGR,KAAK,CAACS,SAAS,EAAE;IAEhC,IAAI,CAACC,OAAO,GAAGC,MAAM;IAErB,IAAIC,YAAY,KAAKtB,OAAO,CAACuB,oBAAoB,EAAE;MAC/C,IAAIZ,IAAI,KAAK,YAAU,kCAAmC;QACtDW,YAAY,GAAGtB,OAAO,CAACuB,oBAAoB;;MAE/C,IAAIZ,IAAI,KAAK,YAAU,sCAAwC;QAC3DW,YAAY,GAAGtB,OAAO,CAACuB,oBAAoB;;;IAInD;IACA,MAAMC,MAAM,GAAG,IAAI,CAACT,QAAQ,IAAI,CAACG,MAAM,CAACO,SAAS,CAACC,6BAA6B,GAAG;IAClF,IAAI,CAACC,SAAS,GAAG,IAAI1B,mBAAmB,CACpC,eAAe,EACf;MAAE2B,KAAK,EAAEV,MAAM,CAACW,cAAc,EAAE;MAAEC,MAAM,EAAEZ,MAAM,CAACa,eAAe;IAAE,CAAE,EACpE,IAAI,CAACnB,MAAM,EACX,KAAK,EACL,IAAI,EACJD,IAAI,EACJ,KAAK,EACLW,YAAY,EACZU,SAAS,EACTA,SAAS,EACTA,SAAS,EACTR,MAAM,CACT;IACD,IAAI,CAACG,SAAS,CAACM,KAAK,GAAGjC,OAAO,CAACkC,iBAAiB;IAChD,IAAI,CAACP,SAAS,CAACQ,KAAK,GAAGnC,OAAO,CAACkC,iBAAiB;IAChD,IAAI,CAACP,SAAS,CAACS,WAAW,GAAG,CAAC;IAC9B,IAAI,CAACT,SAAS,CAACU,eAAe,GAAG,KAAK;IACtC,IAAI,CAACV,SAAS,CAACW,UAAU,GAAG,IAAI;IAEhC;IACA,IAAI,CAACX,SAAS,CAACY,YAAY,GAAG,IAAI,CAACnB,OAAO;IAC1C,IAAI,CAACO,SAAS,CAACa,oBAAoB,GAAG,IAAI;IAC1C,IAAI,CAACb,SAAS,CAACc,sBAAsB,GAAG,KAAK;IAE7C;IACA,IAAI,CAACd,SAAS,CAACe,iBAAiB,CAACC,GAAG,CAAEzB,MAAM,IAAI;MAC5CA,MAAM,CAAC0B,KAAK,CAAC,IAAI,CAAC5B,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IACpD,CAAC,CAAC;IAEF,IAAI,CAACW,SAAS,CAACkB,sBAAsB,CAACF,GAAG,CAAC,MAAK;;MAC3C,YAAM,CAACG,eAAe,uDAAG,gBAAgB,EAAE,CAAC,CAAC;IACjD,CAAC,CAAC;IAEF,IAAI,CAACnB,SAAS,CAACoB,uBAAuB,CAACJ,GAAG,CAAC,MAAK;;MAC5C,YAAM,CAACK,cAAc,uDAAG,CAAC,CAAC;IAC9B,CAAC,CAAC;IAEF,IAAI,CAACrB,SAAS,CAACsB,qBAAqB,GAAG,CAACC,IAAkB,EAAEd,WAAmB,EAAEe,OAAiB,KAAI;MAClG,IAAI,CAACA,OAAO,IAAIf,WAAW,KAAK,CAAC,KAAKc,IAAI,CAACE,SAAS,EAAE;QAClD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,CAACE,SAAS,CAACE,MAAM,EAAE,EAAED,CAAC,EAAE;UAC5C,MAAME,OAAO,GAAGL,IAAI,CAACE,SAAS,CAACC,CAAC,CAAC;UACjC,MAAMG,aAAa,GAAGD,OAAO,CAACE,gBAAgB,EAAE;UAEhD,MAAMC,KAAK,GAAGF,aAAa,CAACG,uBAAuB,CAACJ,OAAO,CAACK,GAAG,EAAE,CAAC,CAACL,OAAO,CAACM,kBAAkB,EAAE,CAAC;UAChG,MAAMC,0BAA0B,GAC5B5C,MAAM,CAAC6C,OAAO,EAAE,CAACC,eAAe,KAC9BN,KAAK,CAACO,gBAAgB,CAACV,OAAO,CAACK,GAAG,CAAC,KAAK,IAAI,IAAIF,KAAK,CAACO,gBAAgB,CAACV,OAAO,CAACK,GAAG,CAAC,KAAK5B,SAAS,IAAKwB,aAAa,CAACU,gBAAgB,CAAC;UAE3I,IAAI,CAAC,IAAI,CAACC,OAAO,CAACZ,OAAO,EAAEO,0BAA0B,CAAC,EAAE;YACpD,OAAO,KAAK;;;;MAKxB,OAAO,IAAI;IACf,CAAC;IAED;IACA,MAAMM,aAAa,GAAIb,OAAgB,IAAU;;MAC7C,MAAMC,aAAa,GAAGD,OAAO,CAACE,gBAAgB,EAAE;MAChD,MAAMY,aAAa,GAAGd,OAAO,CAACe,gBAAgB,EAAE;MAChD,MAAM5D,KAAK,GAAG,IAAI,CAACE,MAAM;MACzB,MAAMM,MAAM,GAAGR,KAAK,CAACS,SAAS,EAAE;MAChC,MAAMoD,QAAQ,GAAGhB,OAAO,CAACiB,WAAW,EAAE;MAEtCH,aAAa,CAACI,6BAA6B,CAACC,qBAAqB,GAAG,KAAK;MAEzE,IAAI,CAACH,QAAQ,IAAIF,aAAa,CAACM,gBAAgB,IAAIJ,QAAQ,CAACK,iBAAiB,IAAIrB,OAAO,CAACsB,aAAa,KAAK,CAAC,IAAItB,OAAO,CAACuB,SAAS,KAAKpE,KAAK,CAACqE,WAAW,EAAE,EAAE;QACvJ;;MAGJ;MACA,MAAMC,MAAM,GAAGX,aAAa,CAACY,0BAA0B,EAAE,GAAG,CAAC;MAC7D,IAAIC,eAAe,GAAG,mBAAa,CAACC,+BAA+B,mCAAIZ,QAAQ,CAACW,eAAe;MAC/F,IAAIF,MAAM,EAAE;QACRE,eAAe,GACXA,eAAe,KAAK,IACd,IACA;;MAEd,MAAME,sBAAsB,GAAGF,eAAe,KAAK;MAEnDhE,MAAM,CAACmE,QAAQ,CAACd,QAAQ,CAACe,eAAe,EAAE,CAAC,EAAE,KAAK,EAAEF,sBAAsB,EAAEb,QAAQ,CAACgB,aAAa,CAAC;MAEnG;MACA,MAAM7B,KAAK,GAAGF,aAAa,CAACG,uBAAuB,CAACJ,OAAO,CAACK,GAAG,EAAE,CAAC,CAACL,OAAO,CAACM,kBAAkB,EAAE,CAAC;MAEhG,IAAIH,KAAK,CAAC8B,UAAU,EAAE;QAClB;;MAGJ,MAAM1B,0BAA0B,GAC5B5C,MAAM,CAAC6C,OAAO,EAAE,CAACC,eAAe,KAC9BN,KAAK,CAACO,gBAAgB,CAACV,OAAO,CAACK,GAAG,CAAC,KAAK,IAAI,IAAIF,KAAK,CAACO,gBAAgB,CAACV,OAAO,CAACK,GAAG,CAAC,KAAK5B,SAAS,IAAKwB,aAAa,CAACU,gBAAgB,CAAC;MAE3I,MAAM7C,MAAM,GAAG,IAAI,CAACD,OAAO,IAAIV,KAAK,CAAC6B,YAAY;MACjD,IAAI,IAAI,CAAC4B,OAAO,CAACZ,OAAO,EAAEO,0BAA0B,CAAC,IAAIzC,MAAM,EAAE;QAC7DkC,OAAO,CAACuB,SAAS,GAAGpE,KAAK,CAACqE,WAAW,EAAE;QAEvC,MAAMU,iBAAiB,GAAG,mBAAa,CAAChB,6BAA6B,CAACiB,sBAAsB,0CAAGxE,MAAM,CAACyE,mBAAmB,CAAC;QAE1H,IAAIC,WAAW,GAAGrC,OAAO,CAACsC,eAAe,EAAE;QAC3C,IAAI,CAACD,WAAW,IAAIH,iBAAiB,EAAE;UACnCG,WAAW,GAAGH,iBAAiB,CAACI,eAAe,EAAE;;QAErD,MAAMC,aAAa,GAAGzE,MAAM,CAAC0E,IAAI,KAAK5F,MAAM,CAAC6F,mBAAmB;QAEhE,IAAI,CAACJ,WAAW,EAAE;UACd;;QAGJ,MAAMK,MAAM,GAAGL,WAAW,CAACK,MAAO;QAElC/E,MAAM,CAACgF,YAAY,CAACN,WAAW,CAAC;QAEhC,IAAI,CAAC9B,0BAA0B,EAAE;UAC7BN,aAAa,CAAC2C,KAAK,CAAC5C,OAAO,EAAE0C,MAAM,EAAE1B,QAAQ,CAAC6B,QAAQ,CAAC;;QAG3D,IAAI,CAACX,iBAAiB,EAAE;UACpBQ,MAAM,CAACI,SAAS,CAAC,gBAAgB,EAAE3F,KAAK,CAAC4F,kBAAkB,EAAE,CAAC;UAC9DL,MAAM,CAACI,SAAS,CAAC,OAAO,EAAEhC,aAAa,CAACkC,cAAc,EAAE,CAAC;SAC5D,MAAM;UACHd,iBAAiB,CAACe,cAAc,CAACnC,aAAa,CAACkC,cAAc,EAAE,EAAElC,aAAqB,EAAEd,OAAO,CAAC;;QAGpG,IAAIkD,IAAY,EAAEC,IAAY;QAE9B,IAAIZ,aAAa,EAAE;UACfW,IAAI,GAAG,CAACvF,MAAM,CAACyF,qBAAqB,IAAIzF,MAAM,CAAC0F,eAAe,GAAG,CAAC,GAAG,CAAC;UACtEF,IAAI,GAAGxF,MAAM,CAACyF,qBAAqB,IAAIzF,MAAM,CAAC0F,eAAe,GAAG,CAAC,GAAG,CAAC;SACxE,MAAM;UACHH,IAAI,GAAGvF,MAAM,CAACyF,qBAAqB,IAAIzF,MAAM,CAAC0F,eAAe,GAAGvF,MAAM,CAACoF,IAAI,GAAGvF,MAAM,CAAC0F,eAAe,GAAG,CAAC,GAAGvF,MAAM,CAACoF,IAAI;UACtHC,IAAI,GAAGxF,MAAM,CAACyF,qBAAqB,IAAIzF,MAAM,CAAC0F,eAAe,GAAG,CAAC,GAAGvF,MAAM,CAACqF,IAAI;;QAGnFT,MAAM,CAACY,SAAS,CAAC,aAAa,EAAEJ,IAAI,EAAEA,IAAI,GAAGC,IAAI,CAAC;QAElD,IAAI,CAACjB,iBAAiB,EAAE;UACpB;UACA,IAAIlB,QAAQ,CAACuC,gBAAgB,EAAE,EAAE;YAC7B,MAAMC,YAAY,GAAGxC,QAAQ,CAACyC,mBAAmB,EAAE;YAEnD,IAAID,YAAY,EAAE;cACdd,MAAM,CAACgB,UAAU,CAAC,gBAAgB,EAAEF,YAAY,CAAC;cACjDd,MAAM,CAACI,SAAS,CAAC,eAAe,EAAEU,YAAY,CAACG,gBAAgB,EAAE,CAAC;;;UAI1E;UACA,IAAI1D,aAAa,CAAC2D,QAAQ,IAAI3D,aAAa,CAAC4D,wBAAwB,IAAI5D,aAAa,CAAC6D,QAAQ,EAAE;YAC5F,MAAMA,QAAQ,GAAG7D,aAAa,CAAC6D,QAAQ;YAEvC,IAAIA,QAAQ,CAACC,yBAAyB,EAAE;cACpC,MAAMC,WAAW,GAAGF,QAAQ,CAACG,yBAAyB,CAAChE,aAAa,CAAC;cACrE,IAAI,CAAC+D,WAAW,EAAE;gBACd;;cAGJtB,MAAM,CAACgB,UAAU,CAAC,aAAa,EAAEM,WAAW,CAAC;cAC7CtB,MAAM,CAACwB,QAAQ,CAAC,kBAAkB,EAAE,GAAG,IAAIJ,QAAQ,CAACK,KAAK,CAACpE,MAAM,GAAG,CAAC,CAAC,CAAC;aACzE,MAAM;cACH2C,MAAM,CAAC0B,WAAW,CAAC,QAAQ,EAAEN,QAAQ,CAACO,oBAAoB,CAACpE,aAAa,CAAC,CAAC;;;UAIlF;UACAlD,aAAa,CAAC2F,MAAM,EAAE1B,QAAQ,EAAE7D,KAAK,CAAC;UAEtC;UACAR,cAAc,CAAC2H,yBAAyB,CAACrE,aAAa,EAAEyC,MAAM,CAAC;UAC/D,IAAIzC,aAAa,CAACsE,kBAAkB,IAAItE,aAAa,CAACsE,kBAAkB,CAACC,wBAAwB,EAAE;YAC/FvE,aAAa,CAACsE,kBAAkB,CAAC3B,KAAK,CAACF,MAAM,CAAC;;;QAItD;QACAzC,aAAa,CAACwE,iBAAiB,CAAC3D,aAAa,EAAEd,OAAO,EAAE0C,MAAM,EAAE1B,QAAQ,CAAC6B,QAAQ,EAAE1C,KAAK,EAAEI,0BAA0B,EAAE,CAACmE,UAAU,EAAEC,KAAK,KACpIjC,MAAM,CAACI,SAAS,CAAC,OAAO,EAAE6B,KAAK,CAAC,CACnC;;IAET,CAAC;IAED,IAAI,CAACvG,SAAS,CAACwG,oBAAoB,GAAG,CAClCC,eAAoC,EACpCC,kBAAuC,EACvCC,oBAAyC,EACzCC,kBAAuC,KACjC;MACN,IAAIC,KAAK;MAET,IAAID,kBAAkB,CAACjF,MAAM,EAAE;QAC3B,KAAKkF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,kBAAkB,CAACjF,MAAM,EAAEkF,KAAK,EAAE,EAAE;UACxDpE,aAAa,CAACmE,kBAAkB,CAACE,IAAI,CAACD,KAAK,CAAC,CAAC;;;MAIrD,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGJ,eAAe,CAAC9E,MAAM,EAAEkF,KAAK,EAAE,EAAE;QACrDpE,aAAa,CAACgE,eAAe,CAACK,IAAI,CAACD,KAAK,CAAC,CAAC;;MAG9C,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,kBAAkB,CAAC/E,MAAM,EAAEkF,KAAK,EAAE,EAAE;QACxDpE,aAAa,CAACiE,kBAAkB,CAACI,IAAI,CAACD,KAAK,CAAC,CAAC;;MAGjD,IAAI,IAAI,CAACE,gCAAgC,EAAE;QACvC,KAAKF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,oBAAoB,CAAChF,MAAM,EAAEkF,KAAK,EAAE,EAAE;UAC1DpE,aAAa,CAACkE,oBAAoB,CAACG,IAAI,CAACD,KAAK,CAAC,CAAC;;OAEtD,MAAM;QACH,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,oBAAoB,CAAChF,MAAM,EAAEkF,KAAK,EAAE,EAAE;UAC1DF,oBAAoB,CAACG,IAAI,CAACD,KAAK,CAAC,CAAClE,gBAAgB,EAAE,CAACG,6BAA6B,CAACC,qBAAqB,GAAG,KAAK;;;IAG3H,CAAC;EACL;EA1QA;;;;;EAKOiE,uBAAuB,CAACzF,IAAmC,EAAEqB,QAAmB;IACnF,IAAI,CAAC5C,SAAS,CAACgH,uBAAuB,CAACzF,IAAI,EAAEqB,QAAQ,CAAC;EAC1D;EAqQA;;;;;;EAMOJ,OAAO,CAACZ,OAAgB,EAAEqF,YAAqB;;IAClD,MAAM1H,MAAM,GAAG,IAAI,CAACN,MAAM,CAACO,SAAS,EAAE;IACtC,MAAM+B,IAAI,GAAGK,OAAO,CAACsF,OAAO,EAAE;IAC9B,MAAMnI,KAAK,GAAGwC,IAAI,CAAC4F,QAAQ,EAAE;IAE7B,MAAMrD,iBAAiB,GAAG,UAAI,CAAChB,6BAA6B,CAACiB,sBAAsB,0CAAGxE,MAAM,CAACyE,mBAAmB,CAAC;IAEjH,IAAIF,iBAAiB,EAAE;MACnB,OAAOA,iBAAiB,CAACsD,iBAAiB,CAAC7F,IAAI,EAAEK,OAAO,EAAEqF,YAAY,CAAC;;IAG3E,MAAMrE,QAAQ,GAAGhB,OAAO,CAACiB,WAAW,EAAE;IACtC,IAAI,CAACD,QAAQ,IAAIA,QAAQ,CAACK,iBAAiB,EAAE;MACzC,OAAO,KAAK;;IAGhB,MAAMoE,OAAO,GAAG,EAAE;IAElB,MAAMC,OAAO,GAAG,CAAClJ,YAAY,CAACmJ,YAAY,CAAC;IAE3C;IACA,IAAI3E,QAAQ,IAAIA,QAAQ,CAACuC,gBAAgB,EAAE,IAAIvC,QAAQ,CAACyC,mBAAmB,EAAE,EAAE;MAC3EgC,OAAO,CAACG,IAAI,CAAC,mBAAmB,CAAC;MACjC,IAAIjG,IAAI,CAACkG,qBAAqB,CAACrJ,YAAY,CAACsJ,MAAM,CAAC,EAAE;QACjDJ,OAAO,CAACE,IAAI,CAACpJ,YAAY,CAACsJ,MAAM,CAAC;QACjCL,OAAO,CAACG,IAAI,CAAC,aAAa,CAAC;;MAE/B,IAAIjG,IAAI,CAACkG,qBAAqB,CAACrJ,YAAY,CAACuJ,OAAO,CAAC,EAAE;QAClDL,OAAO,CAACE,IAAI,CAACpJ,YAAY,CAACuJ,OAAO,CAAC;QAClCN,OAAO,CAACG,IAAI,CAAC,aAAa,CAAC;;;IAInC;IACA,IAAIjG,IAAI,CAACiE,QAAQ,IAAIjE,IAAI,CAACkE,wBAAwB,EAAE;MAChD6B,OAAO,CAACE,IAAI,CAACpJ,YAAY,CAACwJ,mBAAmB,CAAC;MAC9CN,OAAO,CAACE,IAAI,CAACpJ,YAAY,CAACyJ,mBAAmB,CAAC;MAC9C,IAAItG,IAAI,CAACuG,kBAAkB,GAAG,CAAC,EAAE;QAC7BR,OAAO,CAACE,IAAI,CAACpJ,YAAY,CAAC2J,wBAAwB,CAAC;QACnDT,OAAO,CAACE,IAAI,CAACpJ,YAAY,CAAC4J,wBAAwB,CAAC;;MAEvDX,OAAO,CAACG,IAAI,CAAC,+BAA+B,GAAGjG,IAAI,CAACuG,kBAAkB,CAAC;MACvET,OAAO,CAACG,IAAI,CAAC,uBAAuB,IAAIjG,IAAI,CAACmE,QAAQ,GAAGnE,IAAI,CAACmE,QAAQ,CAACK,KAAK,CAACpE,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MAE5F,MAAM+D,QAAQ,GAAG9D,OAAO,CAACE,gBAAgB,EAAE,CAAC4D,QAAQ;MAEpD,IAAIA,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEC,yBAAyB,EAAE;QACrC0B,OAAO,CAACG,IAAI,CAAC,qBAAqB,CAAC;;KAE1C,MAAM;MACHH,OAAO,CAACG,IAAI,CAAC,gCAAgC,CAAC;;IAGlD;IACA,MAAMrB,kBAAkB,GAAI5E,IAAa,CAAC4E,kBAAkB;IAC5D,IAAI8B,mBAAmB,GAAG,CAAC;IAC3B,IAAI9B,kBAAkB,EAAE;MACpB,IAAIA,kBAAkB,CAAC+B,cAAc,GAAG,CAAC,EAAE;QACvCD,mBAAmB,GAAG9B,kBAAkB,CAAC+B,cAAc;QAEvDb,OAAO,CAACG,IAAI,CAAC,sBAAsB,CAAC;QACpCH,OAAO,CAACG,IAAI,CAAC,gCAAgC,GAAGS,mBAAmB,CAAC;QAEpE,IAAI9B,kBAAkB,CAACC,wBAAwB,EAAE;UAC7CiB,OAAO,CAACG,IAAI,CAAC,8BAA8B,CAAC;;QAGhDjJ,cAAc,CAAC4J,2CAA2C,CAACb,OAAO,EAAE/F,IAAI,EAAE0G,mBAAmB,CAAC;;;IAItG;IACA,IAAIhB,YAAY,EAAE;MACdI,OAAO,CAACG,IAAI,CAAC,mBAAmB,CAAC;MACjCjJ,cAAc,CAAC6J,0BAA0B,CAACd,OAAO,CAAC;MAClD,IAAI1F,OAAO,CAACE,gBAAgB,EAAE,CAACS,gBAAgB,EAAE;QAC7C8E,OAAO,CAACG,IAAI,CAAC,wBAAwB,CAAC;;;IAI9C;IACA,IAAI,IAAI,CAACtI,oBAAoB,EAAE;MAC3BmI,OAAO,CAACG,IAAI,CAAC,wBAAwB,CAAC;;IAG1C;IACA,IAAI,IAAI,CAACpI,QAAQ,EAAE;MACfiI,OAAO,CAACG,IAAI,CAAC,gBAAgB,CAAC;;IAGlC;IACA5I,2BAA2B,CAACgE,QAAQ,EAAE7D,KAAK,EAAEsI,OAAO,CAAC;IAErD;IACA,MAAMpD,WAAW,GAAGrC,OAAO,CAACsC,eAAe,CAAC7D,SAAS,EAAE,IAAI,CAAE;IAC7D,MAAMgI,aAAa,GAAGpE,WAAW,CAACoD,OAAO;IACzC,MAAMiB,IAAI,GAAGjB,OAAO,CAACiB,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAID,aAAa,KAAKC,IAAI,EAAE;MACxB,MAAMC,QAAQ,GAAG,CACb,OAAO,EACP,QAAQ,EACR,kBAAkB,EAClB,gBAAgB,EAChB,eAAe,EACf,aAAa,EACb,uBAAuB,EACvB,wBAAwB,EACxB,2BAA2B,CAC9B;MACD7J,oBAAoB,CAAC6J,QAAQ,CAAC;MAE9BtE,WAAW,CAACuE,SAAS,CACjBjJ,MAAM,CAACkJ,YAAY,CAAC,OAAO,EAAEnB,OAAO,EAAEiB,QAAQ,EAAE,CAAC,gBAAgB,EAAE,cAAc,EAAE,aAAa,CAAC,EAAED,IAAI,EAAEjI,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE;QACtIqI,2BAA2B,EAAET;OAChC,CAAC,EACFK,IAAI,CACP;;IAGL,OAAOrE,WAAW,CAACK,MAAO,CAAC9B,OAAO,EAAE;EACxC;EAEA;;;;EAIOmG,WAAW;IACd,OAAO,IAAI,CAAC3I,SAAS;EACzB;EAEA;;;EAGO4I,OAAO;IACV,MAAMC,YAAY,GAAG,EAAE;IACvB,KAAK,MAAMC,GAAG,IAAI,IAAI,CAAC7J,MAAM,CAAC8J,cAAc,EAAE;MAC1C,MAAMC,aAAa,GAAG,IAAI,CAAC/J,MAAM,CAAC8J,cAAc,CAACD,GAAG,CAAC;MACrD,IAAIE,aAAa,KAAK,IAAI,EAAE;QACxBH,YAAY,CAACrB,IAAI,CAACsB,GAAG,CAAC;;;IAI9B,IAAID,YAAY,CAAClH,MAAM,GAAG,CAAC,EAAE;MACzB,IAAI,CAAC3B,SAAS,CAAC4I,OAAO,EAAE;MAExB,KAAK,MAAME,GAAG,IAAID,YAAY,EAAE;QAC5B,OAAO,IAAI,CAAC5J,MAAM,CAAC8J,cAAc,CAACD,GAAG,CAAC;;;EAGlD;;AA9aA;;;AAGcjK,2CAA6B,GAA4BoK,CAAC,IAAI;EACxE,MAAMxK,WAAW,CAAC,6BAA6B,CAAC;AACpD,CAAC","names":["Color4","VertexBuffer","Texture","RenderTargetTexture","MaterialHelper","Camera","_WarnImport","addClipPlaneUniforms","bindClipPlane","prepareDefinesForClipPlanes","DepthRenderer","constructor","scene","type","_scene","_storeNonLinearDepth","storeNonLinearDepth","isPacked","_clearColor","_SceneComponentInitialization","engine","getEngine","_camera","camera","samplingMode","NEAREST_SAMPLINGMODE","format","_features","supportExtendedTextureFormats","_depthMap","width","getRenderWidth","height","getRenderHeight","undefined","wrapU","CLAMP_ADDRESSMODE","wrapV","refreshRate","renderParticles","renderList","activeCamera","ignoreCameraViewport","useCameraPostProcesses","onClearObservable","add","clear","onBeforeBindObservable","_debugPushGroup","onAfterUnbindObservable","_debugPopGroup","customIsReadyFunction","mesh","preWarm","subMeshes","i","length","subMesh","renderingMesh","getRenderingMesh","batch","_getInstancesRenderList","_id","getReplacementMesh","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","hasThinInstances","isReady","renderSubMesh","effectiveMesh","getEffectiveMesh","material","getMaterial","_internalAbstractMeshDataInfo","_isActiveIntermediate","infiniteDistance","disableDepthWrite","verticesCount","_renderId","getRenderId","detNeg","_getWorldMatrixDeterminant","sideOrientation","overrideMaterialSideOrientation","reverseSideOrientation","setState","backFaceCulling","cullBackFaces","mustReturn","renderingMaterial","_materialForRenderPass","currentRenderPassId","drawWrapper","_getDrawWrapper","cameraIsOrtho","mode","ORTHOGRAPHIC_CAMERA","effect","enableEffect","_bind","fillMode","setMatrix","getTransformMatrix","getWorldMatrix","bindForSubMesh","minZ","maxZ","useReverseDepthBuffer","isNDCHalfZRange","setFloat2","needAlphaTesting","alphaTexture","getAlphaTestTexture","setTexture","getTextureMatrix","useBones","computeBonesUsingShaders","skeleton","isUsingTextureForMatrices","boneTexture","getTransformMatrixTexture","setFloat","bones","setMatrices","getTransformMatrices","BindMorphTargetParameters","morphTargetManager","isUsingTextureForTargets","_processRendering","isInstance","world","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","data","forceDepthWriteTransparentMeshes","setMaterialForRendering","useInstances","getMesh","getScene","isReadyForSubMesh","defines","attribs","PositionKind","push","isVerticesDataPresent","UVKind","UV2Kind","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","numMorphInfluencers","numInfluencers","PrepareAttributesForMorphTargetsInfluencers","PushAttributesForInstances","cachedDefines","join","uniforms","setEffect","createEffect","maxSimultaneousMorphTargets","getDepthMap","dispose","keysToDelete","key","_depthRenderer","depthRenderer","_"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/depthRenderer.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/depth.fragment\";\r\nimport \"../Shaders/depth.vertex\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\r\n\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * This represents a depth renderer in Babylon.\r\n * A depth renderer will render to it's depth map every frame which can be displayed or used in post processing\r\n */\r\nexport class DepthRenderer {\r\n    private _scene: Scene;\r\n    private _depthMap: RenderTargetTexture;\r\n    private readonly _storeNonLinearDepth: boolean;\r\n    private readonly _clearColor: Color4;\r\n\r\n    /** Get if the depth renderer is using packed depth or not */\r\n    public readonly isPacked: boolean;\r\n\r\n    private _camera: Nullable<Camera>;\r\n\r\n    /** Enable or disable the depth renderer. When disabled, the depth texture is not updated */\r\n    public enabled = true;\r\n\r\n    /** Force writing the transparent objects into the depth map */\r\n    public forceDepthWriteTransparentMeshes = false;\r\n\r\n    /**\r\n     * Specifies that the depth renderer will only be used within\r\n     * the camera it is created for.\r\n     * This can help forcing its rendering during the camera processing.\r\n     */\r\n    public useOnlyInActiveCamera: boolean = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"DepthRendererSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer\r\n     * @param mesh mesh or array of meshes\r\n     * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.\r\n     */\r\n    public setMaterialForRendering(mesh: AbstractMesh | AbstractMesh[], material?: Material): void {\r\n        this._depthMap.setMaterialForRendering(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Instantiates a depth renderer\r\n     * @param scene The scene the renderer belongs to\r\n     * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)\r\n     * @param camera The camera to be used to render the depth map (default: scene's active camera)\r\n     * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z\r\n     * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        type: number = Constants.TEXTURETYPE_FLOAT,\r\n        camera: Nullable<Camera> = null,\r\n        storeNonLinearDepth = false,\r\n        samplingMode = Texture.TRILINEAR_SAMPLINGMODE\r\n    ) {\r\n        this._scene = scene;\r\n        this._storeNonLinearDepth = storeNonLinearDepth;\r\n        this.isPacked = type === Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (this.isPacked) {\r\n            this._clearColor = new Color4(1.0, 1.0, 1.0, 1.0);\r\n        } else {\r\n            this._clearColor = new Color4(1.0, 0.0, 0.0, 1.0);\r\n        }\r\n\r\n        DepthRenderer._SceneComponentInitialization(this._scene);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._camera = camera;\r\n\r\n        if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {\r\n            if (type === Constants.TEXTURETYPE_FLOAT && !engine._caps.textureFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n            if (type === Constants.TEXTURETYPE_HALF_FLOAT && !engine._caps.textureHalfFloatLinearFiltering) {\r\n                samplingMode = Texture.NEAREST_SAMPLINGMODE;\r\n            }\r\n        }\r\n\r\n        // Render target\r\n        const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_R;\r\n        this._depthMap = new RenderTargetTexture(\r\n            \"DepthRenderer\",\r\n            { width: engine.getRenderWidth(), height: engine.getRenderHeight() },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            type,\r\n            false,\r\n            samplingMode,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            format\r\n        );\r\n        this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._depthMap.refreshRate = 1;\r\n        this._depthMap.renderParticles = false;\r\n        this._depthMap.renderList = null;\r\n\r\n        // Camera to get depth map from to support multiple concurrent cameras\r\n        this._depthMap.activeCamera = this._camera;\r\n        this._depthMap.ignoreCameraViewport = true;\r\n        this._depthMap.useCameraPostProcesses = false;\r\n\r\n        // set default depth value to 1.0 (far away)\r\n        this._depthMap.onClearObservable.add((engine) => {\r\n            engine.clear(this._clearColor, true, true, true);\r\n        });\r\n\r\n        this._depthMap.onBeforeBindObservable.add(() => {\r\n            engine._debugPushGroup?.(\"depth renderer\", 1);\r\n        });\r\n\r\n        this._depthMap.onAfterUnbindObservable.add(() => {\r\n            engine._debugPopGroup?.(1);\r\n        });\r\n\r\n        this._depthMap.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering =\r\n                        engine.getCaps().instancedArrays &&\r\n                        ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this.isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        // Custom render function\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            const scene = this._scene;\r\n            const engine = scene.getEngine();\r\n            const material = subMesh.getMaterial();\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {\r\n                return;\r\n            }\r\n\r\n            // Culling\r\n            const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;\r\n            let sideOrientation = renderingMesh.overrideMaterialSideOrientation ?? material.sideOrientation;\r\n            if (detNeg) {\r\n                sideOrientation =\r\n                    sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation\r\n                        ? Constants.MATERIAL_CounterClockWiseSideOrientation\r\n                        : Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n            const reverseSideOrientation = sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n\r\n            engine.setState(material.backFaceCulling, 0, false, reverseSideOrientation, material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering =\r\n                engine.getCaps().instancedArrays &&\r\n                ((batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== undefined) || renderingMesh.hasThinInstances);\r\n\r\n            const camera = this._camera || scene.activeCamera;\r\n            if (this.isReady(subMesh, hardwareInstancedRendering) && camera) {\r\n                subMesh._renderId = scene.getRenderId();\r\n\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (!drawWrapper && renderingMaterial) {\r\n                    drawWrapper = renderingMaterial._getDrawWrapper();\r\n                }\r\n                const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (!renderingMaterial) {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                } else {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                }\r\n\r\n                let minZ: number, maxZ: number;\r\n\r\n                if (cameraIsOrtho) {\r\n                    minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n                } else {\r\n                    minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\r\n                    maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\r\n                }\r\n\r\n                effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\r\n\r\n                if (!renderingMaterial) {\r\n                    // Alpha test\r\n                    if (material.needAlphaTesting()) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        const skeleton = renderingMesh.skeleton;\r\n\r\n                        if (skeleton.isUsingTextureForMatrices) {\r\n                            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);\r\n                            if (!boneTexture) {\r\n                                return;\r\n                            }\r\n\r\n                            effect.setTexture(\"boneSampler\", boneTexture);\r\n                            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n                        } else {\r\n                            effect.setMatrices(\"mBones\", skeleton.getTransformMatrices(renderingMesh));\r\n                        }\r\n                    }\r\n\r\n                    // Clip planes\r\n                    bindClipPlane(effect, material, scene);\r\n\r\n                    // Morph targets\r\n                    MaterialHelper.BindMorphTargetParameters(renderingMesh, effect);\r\n                    if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\r\n                        renderingMesh.morphTargetManager._bind(effect);\r\n                    }\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\r\n                    effect.setMatrix(\"world\", world)\r\n                );\r\n            }\r\n        };\r\n\r\n        this._depthMap.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            let index;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (this.forceDepthWriteTransparentMeshes) {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    renderSubMesh(transparentSubMeshes.data[index]);\r\n                }\r\n            } else {\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates the depth rendering effect and checks if the effect is ready.\r\n     * @param subMesh The submesh to be used to render the depth map of\r\n     * @param useInstances If multiple world instances should be used\r\n     * @returns if the depth renderer is ready to render the depth map\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const engine = this._scene.getEngine();\r\n        const mesh = subMesh.getMesh();\r\n        const scene = mesh.getScene();\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const material = subMesh.getMaterial();\r\n        if (!material || material.disableDepthWrite) {\r\n            return false;\r\n        }\r\n\r\n        const defines = [];\r\n\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        // Alpha test\r\n        if (material && material.needAlphaTesting() && material.getAlphaTestTexture()) {\r\n            defines.push(\"#define ALPHATEST\");\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n\r\n            const skeleton = subMesh.getRenderingMesh().skeleton;\r\n\r\n            if (skeleton?.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph targets\r\n        const morphTargetManager = (mesh as Mesh).morphTargetManager;\r\n        let numMorphInfluencers = 0;\r\n        if (morphTargetManager) {\r\n            if (morphTargetManager.numInfluencers > 0) {\r\n                numMorphInfluencers = morphTargetManager.numInfluencers;\r\n\r\n                defines.push(\"#define MORPHTARGETS\");\r\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n                if (morphTargetManager.isUsingTextureForTargets) {\r\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n                }\r\n\r\n                MaterialHelper.PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, numMorphInfluencers);\r\n            }\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // None linear depth\r\n        if (this._storeNonLinearDepth) {\r\n            defines.push(\"#define NONLINEARDEPTH\");\r\n        }\r\n\r\n        // Float Mode\r\n        if (this.isPacked) {\r\n            defines.push(\"#define PACKED\");\r\n        }\r\n\r\n        // Clip planes\r\n        prepareDefinesForClipPlanes(material, scene, defines);\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            const uniforms = [\r\n                \"world\",\r\n                \"mBones\",\r\n                \"boneTextureWidth\",\r\n                \"viewProjection\",\r\n                \"diffuseMatrix\",\r\n                \"depthValues\",\r\n                \"morphTargetInfluences\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n            ];\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            drawWrapper.setEffect(\r\n                engine.createEffect(\"depth\", attribs, uniforms, [\"diffuseSampler\", \"morphTargets\", \"boneSampler\"], join, undefined, undefined, undefined, {\r\n                    maxSimultaneousMorphTargets: numMorphInfluencers,\r\n                }),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Gets the texture which the depth map will be written to.\r\n     * @returns The depth map texture\r\n     */\r\n    public getDepthMap(): RenderTargetTexture {\r\n        return this._depthMap;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the depth renderer.\r\n     */\r\n    public dispose(): void {\r\n        const keysToDelete = [];\r\n        for (const key in this._scene._depthRenderer) {\r\n            const depthRenderer = this._scene._depthRenderer[key];\r\n            if (depthRenderer === this) {\r\n                keysToDelete.push(key);\r\n            }\r\n        }\r\n\r\n        if (keysToDelete.length > 0) {\r\n            this._depthMap.dispose();\r\n\r\n            for (const key of keysToDelete) {\r\n                delete this._scene._depthRenderer[key];\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}