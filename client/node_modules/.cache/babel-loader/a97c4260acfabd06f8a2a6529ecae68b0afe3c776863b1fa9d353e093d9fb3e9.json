{"ast":null,"code":"import { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\n/**\n * Block used for the particle ramp gradient section\n */\nexport class ParticleRampGradientBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ParticleRampGradientBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._isUnique = true;\n    this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ParticleRampGradientBlock\";\n  }\n  /**\n   * Gets the color input component\n   */\n  get color() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the rampColor output component\n   */\n  get rampColor() {\n    return this._outputs[0];\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"remapRanges\");\n    state._excludeVariableName(\"rampSampler\");\n    state._excludeVariableName(\"baseColor\");\n    state._excludeVariableName(\"alpha\");\n    state._excludeVariableName(\"remappedColorIndex\");\n    state._excludeVariableName(\"rampColor\");\n    state._excludeVariableName(\"finalAlpha\");\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target === NodeMaterialBlockTargets.Vertex) {\n      return;\n    }\n    state._emit2DSampler(\"rampSampler\");\n    state._emitVaryingFromString(\"remapRanges\", \"vec4\", \"RAMPGRADIENT\");\n    state.compilationString += `\n            #ifdef RAMPGRADIENT\n                vec4 baseColor = ${this.color.associatedVariableName};\n                float alpha = ${this.color.associatedVariableName}.a;\n\n                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);\n\n                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));\n                baseColor.rgb *= rampColor.rgb;\n\n                // Remapped alpha\n                float finalAlpha = baseColor.a;\n                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);\n\n                ${this._declareOutput(this.rampColor, state)} = baseColor;\n            #else\n                ${this._declareOutput(this.rampColor, state)} = ${this.color.associatedVariableName};\n            #endif\n        `;\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.ParticleRampGradientBlock\", ParticleRampGradientBlock);","map":{"version":3,"mappings":"AAAA,SAASA,iBAAiB,QAAQ,4BAA0B;AAC5D,SAASC,qCAAqC,QAAQ,sDAAoD;AAE1G,SAASC,wBAAwB,QAAQ,yCAAuC;AAEhF,SAASC,aAAa,QAAQ,+BAA6B;AAE3D;;;AAGA,OAAM,MAAOC,yBAA0B,SAAQJ,iBAAiB;EAC5D;;;;EAIAK,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,EAAEJ,wBAAwB,CAACK,QAAQ,CAAC;IAE9C,IAAI,CAACC,SAAS,GAAG,IAAI;IAErB,IAAI,CAACC,aAAa,CAAC,OAAO,EAAER,qCAAqC,CAACS,MAAM,EAAE,KAAK,EAAER,wBAAwB,CAACK,QAAQ,CAAC;IAEnH,IAAI,CAACI,cAAc,CAAC,WAAW,EAAEV,qCAAqC,CAACS,MAAM,EAAER,wBAAwB,CAACK,QAAQ,CAAC;EACrH;EAEA;;;;EAIOK,YAAY;IACf,OAAO,2BAA2B;EACtC;EAEA;;;EAGA,IAAWC,KAAK;IACZ,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,SAAS;IAChB,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;;EAIOC,UAAU,CAACC,KAA6B;IAC3CA,KAAK,CAACC,oBAAoB,CAAC,aAAa,CAAC;IACzCD,KAAK,CAACC,oBAAoB,CAAC,aAAa,CAAC;IACzCD,KAAK,CAACC,oBAAoB,CAAC,WAAW,CAAC;IACvCD,KAAK,CAACC,oBAAoB,CAAC,OAAO,CAAC;IACnCD,KAAK,CAACC,oBAAoB,CAAC,oBAAoB,CAAC;IAChDD,KAAK,CAACC,oBAAoB,CAAC,WAAW,CAAC;IACvCD,KAAK,CAACC,oBAAoB,CAAC,YAAY,CAAC;EAC5C;EAEUC,WAAW,CAACF,KAA6B;IAC/C,KAAK,CAACE,WAAW,CAACF,KAAK,CAAC;IAExB,IAAIA,KAAK,CAACG,MAAM,KAAKnB,wBAAwB,CAACoB,MAAM,EAAE;MAClD;;IAGJJ,KAAK,CAACK,cAAc,CAAC,aAAa,CAAC;IACnCL,KAAK,CAACM,sBAAsB,CAAC,aAAa,EAAE,MAAM,EAAE,cAAc,CAAC;IAEnEN,KAAK,CAACO,iBAAiB,IAAI;;mCAEA,IAAI,CAACZ,KAAK,CAACa,sBAAsB;gCACpC,IAAI,CAACb,KAAK,CAACa,sBAAsB;;;;;;;;;;;kBAW/C,IAAI,CAACC,cAAc,CAAC,IAAI,CAACZ,SAAS,EAAEG,KAAK,CAAC;;kBAE1C,IAAI,CAACS,cAAc,CAAC,IAAI,CAACZ,SAAS,EAAEG,KAAK,CAAC,MAAM,IAAI,CAACL,KAAK,CAACa,sBAAsB;;SAE1F;IAED,OAAO,IAAI;EACf;;AAGJvB,aAAa,CAAC,mCAAmC,EAAEC,yBAAyB,CAAC","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","ParticleRampGradientBlock","constructor","name","Fragment","_isUnique","registerInput","Color4","registerOutput","getClassName","color","_inputs","rampColor","_outputs","initialize","state","_excludeVariableName","_buildBlock","target","Vertex","_emit2DSampler","_emitVaryingFromString","compilationString","associatedVariableName","_declareOutput"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Particle/particleRampGradientBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\n/**\r\n * Block used for the particle ramp gradient section\r\n */\r\nexport class ParticleRampGradientBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Create a new ParticleRampGradientBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color4, false, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\"rampColor\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ParticleRampGradientBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rampColor output component\r\n     */\r\n    public get rampColor(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"remapRanges\");\r\n        state._excludeVariableName(\"rampSampler\");\r\n        state._excludeVariableName(\"baseColor\");\r\n        state._excludeVariableName(\"alpha\");\r\n        state._excludeVariableName(\"remappedColorIndex\");\r\n        state._excludeVariableName(\"rampColor\");\r\n        state._excludeVariableName(\"finalAlpha\");\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return;\r\n        }\r\n\r\n        state._emit2DSampler(\"rampSampler\");\r\n        state._emitVaryingFromString(\"remapRanges\", \"vec4\", \"RAMPGRADIENT\");\r\n\r\n        state.compilationString += `\r\n            #ifdef RAMPGRADIENT\r\n                vec4 baseColor = ${this.color.associatedVariableName};\r\n                float alpha = ${this.color.associatedVariableName}.a;\r\n\r\n                float remappedColorIndex = clamp((alpha - remapRanges.x) / remapRanges.y, 0.0, 1.0);\r\n\r\n                vec4 rampColor = texture2D(rampSampler, vec2(1.0 - remappedColorIndex, 0.));\r\n                baseColor.rgb *= rampColor.rgb;\r\n\r\n                // Remapped alpha\r\n                float finalAlpha = baseColor.a;\r\n                baseColor.a = clamp((alpha * rampColor.a - remapRanges.z) / remapRanges.w, 0.0, 1.0);\r\n\r\n                ${this._declareOutput(this.rampColor, state)} = baseColor;\r\n            #else\r\n                ${this._declareOutput(this.rampColor, state)} = ${this.color.associatedVariableName};\r\n            #endif\r\n        `;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ParticleRampGradientBlock\", ParticleRampGradientBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}