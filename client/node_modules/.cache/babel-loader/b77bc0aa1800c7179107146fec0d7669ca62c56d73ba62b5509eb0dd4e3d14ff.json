{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { GroundMesh } from \"../groundMesh.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a Ground\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n *  - width the width (x direction) of the ground, optional, default 1\n *  - height the height (z direction) of the ground, optional, default 1\n *  - subdivisions the number of subdivisions per side, optional, default 1\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @returns the VertexData of the Ground\n */\nexport function CreateGroundVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  let row, col;\n  const width = options.width || 1;\n  const height = options.height || 1;\n  const subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  const subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n  for (row = 0; row <= subdivisionsY; row++) {\n    for (col = 0; col <= subdivisionsX; col++) {\n      const position = new Vector3(col * width / subdivisionsX - width / 2.0, 0, (subdivisionsY - row) * height / subdivisionsY - height / 2.0);\n      const normal = new Vector3(0, 1.0, 0);\n      positions.push(position.x, position.y, position.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\n    }\n  }\n  for (row = 0; row < subdivisionsY; row++) {\n    for (col = 0; col < subdivisionsX; col++) {\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + row * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n      indices.push(col + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n      indices.push(col + row * (subdivisionsX + 1));\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\n * * xmin the ground minimum X coordinate, optional, default -1\n * * zmin the ground minimum Z coordinate, optional, default -1\n * * xmax the ground maximum X coordinate, optional, default 1\n * * zmax the ground maximum Z coordinate, optional, default 1\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @returns the VertexData of the TiledGround\n */\nexport function CreateTiledGroundVertexData(options) {\n  const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\n  const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\n  const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\n  const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\n  const subdivisions = options.subdivisions || {\n    w: 1,\n    h: 1\n  };\n  const precision = options.precision || {\n    w: 1,\n    h: 1\n  };\n  const indices = new Array();\n  const positions = new Array();\n  const normals = new Array();\n  const uvs = new Array();\n  let row, col, tileRow, tileCol;\n  subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\n  subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\n  precision.w = precision.w < 1 ? 1 : precision.w;\n  precision.h = precision.h < 1 ? 1 : precision.h;\n  const tileSize = {\n    w: (xmax - xmin) / subdivisions.w,\n    h: (zmax - zmin) / subdivisions.h\n  };\n  function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n    // Indices\n    const base = positions.length / 3;\n    const rowLength = precision.w + 1;\n    for (row = 0; row < precision.h; row++) {\n      for (col = 0; col < precision.w; col++) {\n        const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\n        indices.push(square[1]);\n        indices.push(square[2]);\n        indices.push(square[3]);\n        indices.push(square[0]);\n        indices.push(square[1]);\n        indices.push(square[3]);\n      }\n    }\n    // Position, normals and uvs\n    const position = Vector3.Zero();\n    const normal = new Vector3(0, 1.0, 0);\n    for (row = 0; row <= precision.h; row++) {\n      position.z = row * (zTileMax - zTileMin) / precision.h + zTileMin;\n      for (col = 0; col <= precision.w; col++) {\n        position.x = col * (xTileMax - xTileMin) / precision.w + xTileMin;\n        position.y = 0;\n        positions.push(position.x, position.y, position.z);\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(col / precision.w, row / precision.h);\n      }\n    }\n  }\n  for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n    for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n      applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n    }\n  }\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates the VertexData of the Ground designed from a heightmap\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\n * * width the width (x direction) of the ground\n * * height the height (z direction) of the ground\n * * subdivisions the number of subdivisions per side\n * * minHeight the minimum altitude on the ground, optional, default 0\n * * maxHeight the maximum altitude on the ground, optional default 1\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\n * * buffer the array holding the image color data\n * * bufferWidth the width of image\n * * bufferHeight the height of image\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.buffer\n * @param options.bufferWidth\n * @param options.bufferHeight\n * @param options.alphaFilter\n * @returns the VertexData of the Ground designed from a heightmap\n */\nexport function CreateGroundFromHeightMapVertexData(options) {\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  let row, col;\n  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  const alphaFilter = options.alphaFilter || 0.0;\n  let invert = false;\n  if (options.minHeight > options.maxHeight) {\n    invert = true;\n    const temp = options.maxHeight;\n    options.maxHeight = options.minHeight;\n    options.minHeight = temp;\n  }\n  // Vertices\n  for (row = 0; row <= options.subdivisions; row++) {\n    for (col = 0; col <= options.subdivisions; col++) {\n      const position = new Vector3(col * options.width / options.subdivisions - options.width / 2.0, 0, (options.subdivisions - row) * options.height / options.subdivisions - options.height / 2.0);\n      // Compute height\n      const heightMapX = (position.x + options.width / 2) / options.width * (options.bufferWidth - 1) | 0;\n      const heightMapY = (1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1) | 0;\n      const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n      let r = options.buffer[pos] / 255.0;\n      let g = options.buffer[pos + 1] / 255.0;\n      let b = options.buffer[pos + 2] / 255.0;\n      const a = options.buffer[pos + 3] / 255.0;\n      if (invert) {\n        r = 1.0 - r;\n        g = 1.0 - g;\n        b = 1.0 - b;\n      }\n      const gradient = r * filter.r + g * filter.g + b * filter.b;\n      // If our alpha channel is not within our filter then we will assign a 'special' height\n      // Then when building the indices, we will ignore any vertex that is using the special height\n      if (a >= alphaFilter) {\n        position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n      } else {\n        position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\n      }\n      // Add  vertex\n      positions.push(position.x, position.y, position.z);\n      normals.push(0, 0, 0);\n      uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n    }\n  }\n  // Indices\n  for (row = 0; row < options.subdivisions; row++) {\n    for (col = 0; col < options.subdivisions; col++) {\n      // Calculate Indices\n      const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\n      const idx2 = col + 1 + row * (options.subdivisions + 1);\n      const idx3 = col + row * (options.subdivisions + 1);\n      const idx4 = col + (row + 1) * (options.subdivisions + 1);\n      // Check that all indices are visible (based on our special height)\n      // Only display the vertex if all Indices are visible\n      // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\n      const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\n      const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\n      const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\n      if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\n        indices.push(idx1);\n        indices.push(idx2);\n        indices.push(idx3);\n      }\n      const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\n      if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\n        indices.push(idx4);\n        indices.push(idx1);\n        indices.push(idx3);\n      }\n    }\n  }\n  // Normals\n  VertexData.ComputeNormals(positions, indices, normals);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a ground mesh\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.subdivisionsX\n * @param options.subdivisionsY\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\n */\nexport function CreateGround(name, options = {}, scene) {\n  const ground = new GroundMesh(name, scene);\n  ground._setReady(false);\n  ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n  ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n  ground._width = options.width || 1;\n  ground._height = options.height || 1;\n  ground._maxX = ground._width / 2;\n  ground._maxZ = ground._height / 2;\n  ground._minX = -ground._maxX;\n  ground._minZ = -ground._maxZ;\n  const vertexData = CreateGroundVertexData(options);\n  vertexData.applyToMesh(ground, options.updatable);\n  ground._setReady(true);\n  return ground;\n}\n/**\n * Creates a tiled ground mesh\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.xmin\n * @param options.zmin\n * @param options.xmax\n * @param options.zmax\n * @param options.subdivisions\n * @param options.subdivisions.w\n * @param options.subdivisions.h\n * @param options.precision\n * @param options.precision.w\n * @param options.precision.h\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the tiled ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\n */\nexport function CreateTiledGround(name, options, scene = null) {\n  const tiledGround = new Mesh(name, scene);\n  const vertexData = CreateTiledGroundVertexData(options);\n  vertexData.applyToMesh(tiledGround, options.updatable);\n  return tiledGround;\n}\n/**\n * Creates a ground mesh from a height map\n * * The parameter `url` sets the URL of the height map image resource.\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n * @param name defines the name of the mesh\n * @param url defines the url to the height map\n * @param options defines the options used to create the mesh\n * @param options.width\n * @param options.height\n * @param options.subdivisions\n * @param options.minHeight\n * @param options.maxHeight\n * @param options.colorFilter\n * @param options.alphaFilter\n * @param options.updatable\n * @param options.onReady\n * @param scene defines the hosting scene\n * @returns the ground mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\n */\nexport function CreateGroundFromHeightMap(name, url, options = {}, scene = null) {\n  const width = options.width || 10.0;\n  const height = options.height || 10.0;\n  const subdivisions = options.subdivisions || 1 | 0;\n  const minHeight = options.minHeight || 0.0;\n  const maxHeight = options.maxHeight || 1.0;\n  const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\n  const alphaFilter = options.alphaFilter || 0.0;\n  const updatable = options.updatable;\n  const onReady = options.onReady;\n  scene = scene || EngineStore.LastCreatedScene;\n  const ground = new GroundMesh(name, scene);\n  ground._subdivisionsX = subdivisions;\n  ground._subdivisionsY = subdivisions;\n  ground._width = width;\n  ground._height = height;\n  ground._maxX = ground._width / 2.0;\n  ground._maxZ = ground._height / 2.0;\n  ground._minX = -ground._maxX;\n  ground._minZ = -ground._maxZ;\n  ground._setReady(false);\n  const onload = img => {\n    const bufferWidth = img.width;\n    const bufferHeight = img.height;\n    if (scene.isDisposed) {\n      return;\n    }\n    const buffer = scene === null || scene === void 0 ? void 0 : scene.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\n    const vertexData = CreateGroundFromHeightMapVertexData({\n      width: width,\n      height: height,\n      subdivisions: subdivisions,\n      minHeight: minHeight,\n      maxHeight: maxHeight,\n      colorFilter: filter,\n      buffer: buffer,\n      bufferWidth: bufferWidth,\n      bufferHeight: bufferHeight,\n      alphaFilter: alphaFilter\n    });\n    vertexData.applyToMesh(ground, updatable);\n    //execute ready callback, if set\n    if (onReady) {\n      onReady(ground);\n    }\n    ground._setReady(true);\n  };\n  Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\n  return ground;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the functions directly from the module\n */\nexport const GroundBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateGround,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateGroundFromHeightMap,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledGround\n};\nVertexData.CreateGround = CreateGroundVertexData;\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\nMesh.CreateGround = (name, width, height, subdivisions, scene, updatable) => {\n  const options = {\n    width,\n    height,\n    subdivisions,\n    updatable\n  };\n  return CreateGround(name, options, scene);\n};\nMesh.CreateTiledGround = (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) => {\n  const options = {\n    xmin,\n    zmin,\n    xmax,\n    zmax,\n    subdivisions,\n    precision,\n    updatable\n  };\n  return CreateTiledGround(name, options, scene);\n};\nMesh.CreateGroundFromHeightMap = (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) => {\n  const options = {\n    width,\n    height,\n    subdivisions,\n    minHeight,\n    maxHeight,\n    updatable,\n    onReady,\n    alphaFilter\n  };\n  return CreateGroundFromHeightMap(name, url, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Color3","Mesh","VertexData","GroundMesh","Tools","EngineStore","Epsilon","CompatibilityOptions","CreateGroundVertexData","options","indices","positions","normals","uvs","row","col","width","height","subdivisionsX","subdivisions","subdivisionsY","position","normal","push","x","y","z","UseOpenGLOrientationForUV","vertexData","CreateTiledGroundVertexData","xmin","undefined","zmin","xmax","zmax","w","h","precision","Array","tileRow","tileCol","tileSize","applyTile","xTileMin","zTileMin","xTileMax","zTileMax","base","length","rowLength","square","Zero","CreateGroundFromHeightMapVertexData","filter","colorFilter","alphaFilter","invert","minHeight","maxHeight","temp","heightMapX","bufferWidth","heightMapY","bufferHeight","pos","r","buffer","g","b","a","gradient","idx1","idx2","idx3","idx4","isVisibleIdx1","isVisibleIdx2","isVisibleIdx3","isVisibleIdx4","ComputeNormals","CreateGround","name","scene","ground","_setReady","_subdivisionsX","_subdivisionsY","_width","_height","_maxX","_maxZ","_minX","_minZ","applyToMesh","updatable","CreateTiledGround","tiledGround","CreateGroundFromHeightMap","url","onReady","LastCreatedScene","onload","img","isDisposed","getEngine","resizeImageBitmap","LoadImage","offlineProvider","GroundBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/groundBuilder.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ground\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n *  - width the width (x direction) of the ground, optional, default 1\r\n *  - height the height (z direction) of the ground, optional, default 1\r\n *  - subdivisions the number of subdivisions per side, optional, default 1\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.subdivisionsX\r\n * @param options.subdivisionsY\r\n * @returns the VertexData of the Ground\r\n */\r\nexport function CreateGroundVertexData(options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row: number, col: number;\r\n\r\n    const width: number = options.width || 1;\r\n    const height: number = options.height || 1;\r\n    const subdivisionsX: number = options.subdivisionsX || options.subdivisions || 1;\r\n    const subdivisionsY: number = options.subdivisionsY || options.subdivisions || 1;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\r\n            const normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, CompatibilityOptions.UseOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n * * xmin the ground minimum X coordinate, optional, default -1\r\n * * zmin the ground minimum Z coordinate, optional, default -1\r\n * * xmax the ground maximum X coordinate, optional, default 1\r\n * * zmax the ground maximum Z coordinate, optional, default 1\r\n * * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n * * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n * @param options.xmin\r\n * @param options.zmin\r\n * @param options.xmax\r\n * @param options.zmax\r\n * @param options.subdivisions\r\n * @param options.subdivisions.w\r\n * @param options.subdivisions.h\r\n * @param options.precision\r\n * @param options.precision.w\r\n * @param options.precision.h\r\n * @returns the VertexData of the TiledGround\r\n */\r\nexport function CreateTiledGroundVertexData(options: {\r\n    xmin: number;\r\n    zmin: number;\r\n    xmax: number;\r\n    zmax: number;\r\n    subdivisions?: { w: number; h: number };\r\n    precision?: { w: number; h: number };\r\n}): VertexData {\r\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\r\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\r\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\r\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\r\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    const precision = options.precision || { w: 1, h: 1 };\r\n\r\n    const indices = new Array<number>();\r\n    const positions = new Array<number>();\r\n    const normals = new Array<number>();\r\n    const uvs = new Array<number>();\r\n    let row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\r\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\r\n    precision.w = precision.w < 1 ? 1 : precision.w;\r\n    precision.h = precision.h < 1 ? 1 : precision.h;\r\n\r\n    const tileSize = {\r\n        w: (xmax - xmin) / subdivisions.w,\r\n        h: (zmax - zmin) / subdivisions.h,\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        const base = positions.length / 3;\r\n        const rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        const position = Vector3.Zero();\r\n        const normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData of the Ground designed from a heightmap\r\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n * * width the width (x direction) of the ground\r\n * * height the height (z direction) of the ground\r\n * * subdivisions the number of subdivisions per side\r\n * * minHeight the minimum altitude on the ground, optional, default 0\r\n * * maxHeight the maximum altitude on the ground, optional default 1\r\n * * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n * * buffer the array holding the image color data\r\n * * bufferWidth the width of image\r\n * * bufferHeight the height of image\r\n * * alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.minHeight\r\n * @param options.maxHeight\r\n * @param options.colorFilter\r\n * @param options.buffer\r\n * @param options.bufferWidth\r\n * @param options.bufferHeight\r\n * @param options.alphaFilter\r\n * @returns the VertexData of the Ground designed from a heightmap\r\n */\r\nexport function CreateGroundFromHeightMapVertexData(options: {\r\n    width: number;\r\n    height: number;\r\n    subdivisions: number;\r\n    minHeight: number;\r\n    maxHeight: number;\r\n    colorFilter: Color3;\r\n    buffer: Uint8Array;\r\n    bufferWidth: number;\r\n    bufferHeight: number;\r\n    alphaFilter: number;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row, col;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    let invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        const temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            const position = new Vector3(\r\n                (col * options.width) / options.subdivisions - options.width / 2.0,\r\n                0,\r\n                ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0\r\n            );\r\n\r\n            // Compute height\r\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n\r\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            let r = options.buffer[pos] / 255.0;\r\n            let g = options.buffer[pos + 1] / 255.0;\r\n            let b = options.buffer[pos + 2] / 255.0;\r\n            const a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            } else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\r\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\r\n            const idx3 = col + row * (options.subdivisions + 1);\r\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh\r\n * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.subdivisionsX\r\n * @param options.subdivisionsY\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\r\n */\r\nexport function CreateGround(\r\n    name: string,\r\n    options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number; updatable?: boolean } = {},\r\n    scene?: Scene\r\n): GroundMesh {\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._setReady(false);\r\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    ground._width = options.width || 1;\r\n    ground._height = options.height || 1;\r\n    ground._maxX = ground._width / 2;\r\n    ground._maxZ = ground._height / 2;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    const vertexData = CreateGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(ground, options.updatable);\r\n\r\n    ground._setReady(true);\r\n\r\n    return ground;\r\n}\r\n\r\n/**\r\n * Creates a tiled ground mesh\r\n * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.xmin\r\n * @param options.zmin\r\n * @param options.xmax\r\n * @param options.zmax\r\n * @param options.subdivisions\r\n * @param options.subdivisions.w\r\n * @param options.subdivisions.h\r\n * @param options.precision\r\n * @param options.precision.w\r\n * @param options.precision.h\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the tiled ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\r\n */\r\nexport function CreateTiledGround(\r\n    name: string,\r\n    options: { xmin: number; zmin: number; xmax: number; zmax: number; subdivisions?: { w: number; h: number }; precision?: { w: number; h: number }; updatable?: boolean },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const tiledGround = new Mesh(name, scene);\r\n\r\n    const vertexData = CreateTiledGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n    return tiledGround;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh from a height map\r\n * * The parameter `url` sets the URL of the height map image resource.\r\n * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n * @param name defines the name of the mesh\r\n * @param url defines the url to the height map\r\n * @param options defines the options used to create the mesh\r\n * @param options.width\r\n * @param options.height\r\n * @param options.subdivisions\r\n * @param options.minHeight\r\n * @param options.maxHeight\r\n * @param options.colorFilter\r\n * @param options.alphaFilter\r\n * @param options.updatable\r\n * @param options.onReady\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\r\n */\r\nexport function CreateGroundFromHeightMap(\r\n    name: string,\r\n    url: string,\r\n    options: {\r\n        width?: number;\r\n        height?: number;\r\n        subdivisions?: number;\r\n        minHeight?: number;\r\n        maxHeight?: number;\r\n        colorFilter?: Color3;\r\n        alphaFilter?: number;\r\n        updatable?: boolean;\r\n        onReady?: (mesh: GroundMesh) => void;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): GroundMesh {\r\n    const width = options.width || 10.0;\r\n    const height = options.height || 10.0;\r\n    const subdivisions = options.subdivisions || 1 | 0;\r\n    const minHeight = options.minHeight || 0.0;\r\n    const maxHeight = options.maxHeight || 1.0;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    const updatable = options.updatable;\r\n    const onReady = options.onReady;\r\n\r\n    scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._subdivisionsX = subdivisions;\r\n    ground._subdivisionsY = subdivisions;\r\n    ground._width = width;\r\n    ground._height = height;\r\n    ground._maxX = ground._width / 2.0;\r\n    ground._maxZ = ground._height / 2.0;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    ground._setReady(false);\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        const bufferWidth = img.width;\r\n        const bufferHeight = img.height;\r\n\r\n        if (scene!.isDisposed) {\r\n            return;\r\n        }\r\n\r\n        const buffer = <Uint8Array>scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\r\n\r\n        const vertexData = CreateGroundFromHeightMapVertexData({\r\n            width: width,\r\n            height: height,\r\n            subdivisions: subdivisions,\r\n            minHeight: minHeight,\r\n            maxHeight: maxHeight,\r\n            colorFilter: filter,\r\n            buffer: buffer,\r\n            bufferWidth: bufferWidth,\r\n            bufferHeight: bufferHeight,\r\n            alphaFilter: alphaFilter,\r\n        });\r\n\r\n        vertexData.applyToMesh(ground, updatable);\r\n\r\n        //execute ready callback, if set\r\n        if (onReady) {\r\n            onReady(ground);\r\n        }\r\n\r\n        ground._setReady(true);\r\n    };\r\n\r\n    Tools.LoadImage(url, onload, () => {}, scene.offlineProvider);\r\n\r\n    return ground;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const GroundBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGround,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGroundFromHeightMap,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledGround,\r\n};\r\n\r\nVertexData.CreateGround = CreateGroundVertexData;\r\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\r\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\r\n\r\n(Mesh as any).CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        updatable,\r\n    };\r\n\r\n    return CreateGround(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateTiledGround = (\r\n    name: string,\r\n    xmin: number,\r\n    zmin: number,\r\n    xmax: number,\r\n    zmax: number,\r\n    subdivisions: { w: number; h: number },\r\n    precision: { w: number; h: number },\r\n    scene: Scene,\r\n    updatable?: boolean\r\n): Mesh => {\r\n    const options = {\r\n        xmin,\r\n        zmin,\r\n        xmax,\r\n        zmax,\r\n        subdivisions,\r\n        precision,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTiledGround(name, options, scene);\r\n};\r\n\r\n(Mesh as any).CreateGroundFromHeightMap = (\r\n    name: string,\r\n    url: string,\r\n    width: number,\r\n    height: number,\r\n    subdivisions: number,\r\n    minHeight: number,\r\n    maxHeight: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    onReady?: (mesh: GroundMesh) => void,\r\n    alphaFilter?: number\r\n): GroundMesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        minHeight,\r\n        maxHeight,\r\n        updatable,\r\n        onReady,\r\n        alphaFilter,\r\n    };\r\n\r\n    return CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}