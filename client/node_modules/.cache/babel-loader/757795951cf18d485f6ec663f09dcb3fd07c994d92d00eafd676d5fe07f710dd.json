{"ast":null,"code":"import { ComputeEffect } from \"../../../Compute/computeEffect.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport { WebGPUComputeContext } from \"../webgpuComputeContext.js\";\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext.js\";\nimport * as WebGPUConstants from \"../webgpuConstants.js\";\nWebGPUEngine.prototype.createComputeContext = function () {\n  return new WebGPUComputeContext(this._device, this._cacheSampler);\n};\nWebGPUEngine.prototype.createComputeEffect = function (baseName, options) {\n  const compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;\n  const name = compute + \"@\" + options.defines;\n  if (this._compiledComputeEffects[name]) {\n    const compiledEffect = this._compiledComputeEffects[name];\n    if (options.onCompiled && compiledEffect.isReady()) {\n      options.onCompiled(compiledEffect);\n    }\n    return compiledEffect;\n  }\n  const effect = new ComputeEffect(baseName, options, this, name);\n  this._compiledComputeEffects[name] = effect;\n  return effect;\n};\nWebGPUEngine.prototype.createComputePipelineContext = function () {\n  return new WebGPUComputePipelineContext(this);\n};\nWebGPUEngine.prototype.areAllComputeEffectsReady = function () {\n  for (const key in this._compiledComputeEffects) {\n    const effect = this._compiledComputeEffects[key];\n    if (!effect.isReady()) {\n      return false;\n    }\n  }\n  return true;\n};\nWebGPUEngine.prototype.computeDispatch = function (effect, context, bindings, x, y, z, bindingsMapping) {\n  if (this._currentRenderTarget) {\n    // A render target pass is currently in effect (meaning beingRenderPass has been called on the command encoder this._renderTargetEncoder): we are not allowed to open\n    // another pass on this command encoder (even if it's a compute pass) until endPass has been called, so we need to defer the compute pass for after the current render target pass is closed\n    this._onAfterUnbindFrameBufferObservable.addOnce(() => {\n      this.computeDispatch(effect, context, bindings, x, y, z, bindingsMapping);\n    });\n    return;\n  }\n  const contextPipeline = effect._pipelineContext;\n  const computeContext = context;\n  if (!contextPipeline.computePipeline) {\n    contextPipeline.computePipeline = this._device.createComputePipeline({\n      layout: WebGPUConstants.AutoLayoutMode.Auto,\n      compute: contextPipeline.stage\n    });\n  }\n  const commandEncoder = this._renderTargetEncoder;\n  const computePass = commandEncoder.beginComputePass();\n  computePass.setPipeline(contextPipeline.computePipeline);\n  const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\n  for (let i = 0; i < bindGroups.length; ++i) {\n    const bindGroup = bindGroups[i];\n    if (!bindGroup) {\n      continue;\n    }\n    computePass.setBindGroup(i, bindGroup);\n  }\n  computePass.dispatchWorkgroups(x, y, z);\n  computePass.end();\n};\nWebGPUEngine.prototype.releaseComputeEffects = function () {\n  for (const name in this._compiledComputeEffects) {\n    const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext();\n    this._deleteComputePipelineContext(webGPUPipelineContextCompute);\n  }\n  this._compiledComputeEffects = {};\n};\nWebGPUEngine.prototype._prepareComputePipelineContext = function (pipelineContext, computeSourceCode, rawComputeSourceCode, defines, entryPoint) {\n  const webGpuContext = pipelineContext;\n  if (this.dbgShowShaderCode) {\n    console.log(defines);\n    console.log(computeSourceCode);\n  }\n  webGpuContext.sources = {\n    compute: computeSourceCode,\n    rawCompute: rawComputeSourceCode\n  };\n  webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\n};\nWebGPUEngine.prototype._releaseComputeEffect = function (effect) {\n  if (this._compiledComputeEffects[effect._key]) {\n    delete this._compiledComputeEffects[effect._key];\n    this._deleteComputePipelineContext(effect.getPipelineContext());\n  }\n};\nWebGPUEngine.prototype._rebuildComputeEffects = function () {\n  for (const key in this._compiledComputeEffects) {\n    const effect = this._compiledComputeEffects[key];\n    effect._pipelineContext = null;\n    effect._wasPreviouslyReady = false;\n    effect._prepareEffect();\n  }\n};\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext) {\n  const webgpuPipelineContext = pipelineContext;\n  if (webgpuPipelineContext) {\n    pipelineContext.dispose();\n  }\n};\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader, defines, entryPoint) {\n  if (defines) {\n    defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\n  } else {\n    defines = \"\";\n  }\n  return {\n    module: this._device.createShaderModule({\n      code: defines + computeShader\n    }),\n    entryPoint\n  };\n};","map":{"version":3,"mappings":"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","names":["ComputeEffect","WebGPUEngine","WebGPUComputeContext","WebGPUComputePipelineContext","WebGPUConstants","prototype","createComputeContext","_device","_cacheSampler","createComputeEffect","baseName","options","compute","computeElement","computeToken","computeSource","name","defines","_compiledComputeEffects","compiledEffect","onCompiled","isReady","effect","createComputePipelineContext","areAllComputeEffectsReady","key","computeDispatch","context","bindings","x","y","z","bindingsMapping","_currentRenderTarget","_onAfterUnbindFrameBufferObservable","addOnce","contextPipeline","_pipelineContext","computeContext","computePipeline","createComputePipeline","layout","AutoLayoutMode","Auto","stage","commandEncoder","_renderTargetEncoder","computePass","beginComputePass","setPipeline","bindGroups","getBindGroups","i","length","bindGroup","setBindGroup","dispatchWorkgroups","end","releaseComputeEffects","webGPUPipelineContextCompute","getPipelineContext","_deleteComputePipelineContext","_prepareComputePipelineContext","pipelineContext","computeSourceCode","rawComputeSourceCode","entryPoint","webGpuContext","dbgShowShaderCode","console","log","sources","rawCompute","_createComputePipelineStageDescriptor","_releaseComputeEffect","_key","_rebuildComputeEffects","_wasPreviouslyReady","_prepareEffect","webgpuPipelineContext","dispose","computeShader","split","join","module","createShaderModule","code"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.computeShader.ts"],"sourcesContent":["import type { IComputeEffectCreationOptions } from \"../../../Compute/computeEffect\";\r\nimport { ComputeEffect } from \"../../../Compute/computeEffect\";\r\nimport type { IComputeContext } from \"../../../Compute/IComputeContext\";\r\nimport type { IComputePipelineContext } from \"../../../Compute/IComputePipelineContext\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../../Extensions/engine.computeShader\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport { WebGPUComputeContext } from \"../webgpuComputeContext\";\r\nimport { WebGPUComputePipelineContext } from \"../webgpuComputePipelineContext\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\n\r\ndeclare module \"../../webgpuEngine\" {\r\n    export interface WebGPUEngine {\r\n        /** @internal */\r\n        _createComputePipelineStageDescriptor(computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage;\r\n    }\r\n}\r\n\r\nWebGPUEngine.prototype.createComputeContext = function (): IComputeContext | undefined {\r\n    return new WebGPUComputeContext(this._device, this._cacheSampler);\r\n};\r\n\r\nWebGPUEngine.prototype.createComputeEffect = function (baseName: any, options: IComputeEffectCreationOptions): ComputeEffect {\r\n    const compute = baseName.computeElement || baseName.compute || baseName.computeToken || baseName.computeSource || baseName;\r\n\r\n    const name = compute + \"@\" + options.defines;\r\n    if (this._compiledComputeEffects[name]) {\r\n        const compiledEffect = <ComputeEffect>this._compiledComputeEffects[name];\r\n        if (options.onCompiled && compiledEffect.isReady()) {\r\n            options.onCompiled(compiledEffect);\r\n        }\r\n\r\n        return compiledEffect;\r\n    }\r\n    const effect = new ComputeEffect(baseName, options, this, name);\r\n    this._compiledComputeEffects[name] = effect;\r\n\r\n    return effect;\r\n};\r\n\r\nWebGPUEngine.prototype.createComputePipelineContext = function (): IComputePipelineContext {\r\n    return new WebGPUComputePipelineContext(this);\r\n};\r\n\r\nWebGPUEngine.prototype.areAllComputeEffectsReady = function (): boolean {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        if (!effect.isReady()) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nWebGPUEngine.prototype.computeDispatch = function (\r\n    effect: ComputeEffect,\r\n    context: IComputeContext,\r\n    bindings: ComputeBindingList,\r\n    x: number,\r\n    y?: number,\r\n    z?: number,\r\n    bindingsMapping?: ComputeBindingMapping\r\n): void {\r\n    if (this._currentRenderTarget) {\r\n        // A render target pass is currently in effect (meaning beingRenderPass has been called on the command encoder this._renderTargetEncoder): we are not allowed to open\r\n        // another pass on this command encoder (even if it's a compute pass) until endPass has been called, so we need to defer the compute pass for after the current render target pass is closed\r\n        this._onAfterUnbindFrameBufferObservable.addOnce(() => {\r\n            this.computeDispatch(effect, context, bindings, x, y, z, bindingsMapping);\r\n        });\r\n        return;\r\n    }\r\n\r\n    const contextPipeline = effect._pipelineContext as WebGPUComputePipelineContext;\r\n    const computeContext = context as WebGPUComputeContext;\r\n\r\n    if (!contextPipeline.computePipeline) {\r\n        contextPipeline.computePipeline = this._device.createComputePipeline({\r\n            layout: WebGPUConstants.AutoLayoutMode.Auto,\r\n            compute: contextPipeline.stage!,\r\n        });\r\n    }\r\n\r\n    const commandEncoder = this._renderTargetEncoder;\r\n    const computePass = commandEncoder.beginComputePass();\r\n\r\n    computePass.setPipeline(contextPipeline.computePipeline);\r\n\r\n    const bindGroups = computeContext.getBindGroups(bindings, contextPipeline.computePipeline, bindingsMapping);\r\n    for (let i = 0; i < bindGroups.length; ++i) {\r\n        const bindGroup = bindGroups[i];\r\n        if (!bindGroup) {\r\n            continue;\r\n        }\r\n        computePass.setBindGroup(i, bindGroup);\r\n    }\r\n\r\n    computePass.dispatchWorkgroups(x, y, z);\r\n    computePass.end();\r\n};\r\n\r\nWebGPUEngine.prototype.releaseComputeEffects = function () {\r\n    for (const name in this._compiledComputeEffects) {\r\n        const webGPUPipelineContextCompute = this._compiledComputeEffects[name].getPipelineContext() as WebGPUComputePipelineContext;\r\n        this._deleteComputePipelineContext(webGPUPipelineContextCompute);\r\n    }\r\n\r\n    this._compiledComputeEffects = {};\r\n};\r\n\r\nWebGPUEngine.prototype._prepareComputePipelineContext = function (\r\n    pipelineContext: IComputePipelineContext,\r\n    computeSourceCode: string,\r\n    rawComputeSourceCode: string,\r\n    defines: Nullable<string>,\r\n    entryPoint: string\r\n): void {\r\n    const webGpuContext = pipelineContext as WebGPUComputePipelineContext;\r\n\r\n    if (this.dbgShowShaderCode) {\r\n        console.log(defines);\r\n        console.log(computeSourceCode);\r\n    }\r\n\r\n    webGpuContext.sources = {\r\n        compute: computeSourceCode,\r\n        rawCompute: rawComputeSourceCode,\r\n    };\r\n\r\n    webGpuContext.stage = this._createComputePipelineStageDescriptor(computeSourceCode, defines, entryPoint);\r\n};\r\n\r\nWebGPUEngine.prototype._releaseComputeEffect = function (effect: ComputeEffect): void {\r\n    if (this._compiledComputeEffects[effect._key]) {\r\n        delete this._compiledComputeEffects[effect._key];\r\n\r\n        this._deleteComputePipelineContext(effect.getPipelineContext() as WebGPUComputePipelineContext);\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._rebuildComputeEffects = function (): void {\r\n    for (const key in this._compiledComputeEffects) {\r\n        const effect = this._compiledComputeEffects[key];\r\n\r\n        effect._pipelineContext = null;\r\n        effect._wasPreviouslyReady = false;\r\n        effect._prepareEffect();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._deleteComputePipelineContext = function (pipelineContext: IComputePipelineContext): void {\r\n    const webgpuPipelineContext = pipelineContext as WebGPUComputePipelineContext;\r\n    if (webgpuPipelineContext) {\r\n        pipelineContext.dispose();\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype._createComputePipelineStageDescriptor = function (computeShader: string, defines: Nullable<string>, entryPoint: string): GPUProgrammableStage {\r\n    if (defines) {\r\n        defines = \"//\" + defines.split(\"\\n\").join(\"\\n//\") + \"\\n\";\r\n    } else {\r\n        defines = \"\";\r\n    }\r\n    return {\r\n        module: this._device.createShaderModule({\r\n            code: defines + computeShader,\r\n        }),\r\n        entryPoint,\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}