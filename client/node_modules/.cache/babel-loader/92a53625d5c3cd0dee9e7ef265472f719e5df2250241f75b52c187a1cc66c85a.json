{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { WebRequest } from \"./webRequest.js\";\nimport { IsWindowObjectExist } from \"./domManagement.js\";\nimport { Observable } from \"./observable.js\";\nimport { FilesInputStore } from \"./filesInputStore.js\";\nimport { RetryStrategy } from \"./retryStrategy.js\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error.js\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools.js\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor.js\";\nimport { ThinEngine } from \"../Engines/thinEngine.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"./logger.js\";\nimport { TimingTools } from \"./timingTools.js\";\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\nexport class LoadFileError extends RuntimeError {\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param object defines the optional web request\n   */\n  constructor(message, object) {\n    super(message, ErrorCodes.LoadFileError);\n    this.name = \"LoadFileError\";\n    BaseError._setPrototypeOf(this, LoadFileError.prototype);\n    if (object instanceof WebRequest) {\n      this.request = object;\n    } else {\n      this.file = object;\n    }\n  }\n}\n/** @ignore */\nexport class RequestFileError extends RuntimeError {\n  /**\n   * Creates a new LoadFileError\n   * @param message defines the message of the error\n   * @param request defines the optional web request\n   */\n  constructor(message, request) {\n    super(message, ErrorCodes.RequestFileError);\n    this.request = request;\n    this.name = \"RequestFileError\";\n    BaseError._setPrototypeOf(this, RequestFileError.prototype);\n  }\n}\n/** @ignore */\nexport class ReadFileError extends RuntimeError {\n  /**\n   * Creates a new ReadFileError\n   * @param message defines the message of the error\n   * @param file defines the optional file\n   */\n  constructor(message, file) {\n    super(message, ErrorCodes.ReadFileError);\n    this.file = file;\n    this.name = \"ReadFileError\";\n    BaseError._setPrototypeOf(this, ReadFileError.prototype);\n  }\n}\n/**\n * @internal\n */\nexport const FileToolsOptions = {\n  /**\n   * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n   * When defining this function, return the wait time before trying again or return -1 to\n   * stop retrying and error out.\n   */\n  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n  /**\n   * Gets or sets the base URL to use to load assets\n   */\n  BaseUrl: \"\",\n  /**\n   * Default behaviour for cors in the application.\n   * It can be a string if the expected behavior is identical in the entire app.\n   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n   */\n  CorsBehavior: \"anonymous\",\n  /**\n   * Gets or sets a function used to pre-process url before using them to load assets\n   * @param url\n   */\n  PreprocessUrl: url => {\n    return url;\n  }\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\nconst _CleanUrl = url => {\n  url = url.replace(/#/gm, \"%23\");\n  return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @internal\n */\nexport const SetCorsBehavior = (url, element) => {\n  if (url && url.indexOf(\"data:\") === 0) {\n    return;\n  }\n  if (FileToolsOptions.CorsBehavior) {\n    if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n      element.crossOrigin = FileToolsOptions.CorsBehavior;\n    } else {\n      const result = FileToolsOptions.CorsBehavior(url);\n      if (result) {\n        element.crossOrigin = result;\n      }\n    }\n  }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @internal\n */\nexport const LoadImage = (input, onLoad, onError, offlineProvider, mimeType = \"\", imageBitmapOptions) => {\n  var _a;\n  let url;\n  let usingObjectURL = false;\n  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n    if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\n      url = URL.createObjectURL(new Blob([input], {\n        type: mimeType\n      }));\n      usingObjectURL = true;\n    } else {\n      url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\n    }\n  } else if (input instanceof Blob) {\n    url = URL.createObjectURL(input);\n    usingObjectURL = true;\n  } else {\n    url = _CleanUrl(input);\n    url = FileToolsOptions.PreprocessUrl(input);\n  }\n  const engine = EngineStore.LastCreatedEngine;\n  const onErrorHandler = exception => {\n    if (onError) {\n      const inputText = url || input.toString();\n      onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\n    }\n  };\n  if (typeof Image === \"undefined\" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {\n    LoadFile(url, data => {\n      engine.createImageBitmap(new Blob([data], {\n        type: mimeType\n      }), {\n        premultiplyAlpha: \"none\",\n        ...imageBitmapOptions\n      }).then(imgBmp => {\n        onLoad(imgBmp);\n        if (usingObjectURL) {\n          URL.revokeObjectURL(url);\n        }\n      }).catch(reason => {\n        if (onError) {\n          onError(\"Error while trying to load image: \" + input, reason);\n        }\n      });\n    }, undefined, offlineProvider || undefined, true, (request, exception) => {\n      onErrorHandler(exception);\n    });\n    return null;\n  }\n  const img = new Image();\n  SetCorsBehavior(url, img);\n  const handlersList = [];\n  const loadHandlersList = () => {\n    handlersList.forEach(handler => {\n      handler.target.addEventListener(handler.name, handler.handler);\n    });\n  };\n  const unloadHandlersList = () => {\n    handlersList.forEach(handler => {\n      handler.target.removeEventListener(handler.name, handler.handler);\n    });\n    handlersList.length = 0;\n  };\n  const loadHandler = () => {\n    unloadHandlersList();\n    onLoad(img);\n    // Must revoke the URL after calling onLoad to avoid security exceptions in\n    // certain scenarios (e.g. when hosted in vscode).\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n  const errorHandler = err => {\n    unloadHandlersList();\n    onErrorHandler(err);\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n  };\n  const cspHandler = err => {\n    unloadHandlersList();\n    const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\n    EngineStore.UseFallbackTexture = false;\n    onErrorHandler(cspException);\n    if (usingObjectURL && img.src) {\n      URL.revokeObjectURL(img.src);\n    }\n    img.src = \"\";\n  };\n  handlersList.push({\n    target: img,\n    name: \"load\",\n    handler: loadHandler\n  });\n  handlersList.push({\n    target: img,\n    name: \"error\",\n    handler: errorHandler\n  });\n  handlersList.push({\n    target: document,\n    name: \"securitypolicyviolation\",\n    handler: cspHandler\n  });\n  loadHandlersList();\n  const fromBlob = url.substring(0, 5) === \"blob:\";\n  const fromData = url.substring(0, 5) === \"data:\";\n  const noOfflineSupport = () => {\n    if (fromBlob || fromData) {\n      img.src = url;\n    } else {\n      LoadFile(url, (data, _, contentType) => {\n        const type = !mimeType && contentType ? contentType : mimeType;\n        const blob = new Blob([data], {\n          type\n        });\n        const url = URL.createObjectURL(blob);\n        usingObjectURL = true;\n        img.src = url;\n      }, undefined, offlineProvider || undefined, true, (request, exception) => {\n        onErrorHandler(exception);\n      });\n    }\n  };\n  const loadFromOfflineSupport = () => {\n    if (offlineProvider) {\n      offlineProvider.loadImage(url, img);\n    }\n  };\n  if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    if (url.indexOf(\"file:\") !== -1) {\n      const textureName = decodeURIComponent(url.substring(5).toLowerCase());\n      if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\n        try {\n          let blobURL;\n          try {\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          } catch (ex) {\n            // Chrome doesn't support oneTimeOnly parameter\n            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n          }\n          img.src = blobURL;\n          usingObjectURL = true;\n        } catch (e) {\n          img.src = \"\";\n        }\n        return img;\n      }\n    }\n    noOfflineSupport();\n  }\n  return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @internal\n */\nexport const ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {\n  const reader = new FileReader();\n  const fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: () => reader.abort()\n  };\n  reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n  if (onError) {\n    reader.onerror = () => {\n      onError(new ReadFileError(`Unable to read ${file.name}`, file));\n    };\n  }\n  reader.onload = e => {\n    //target doesn't have result from ts 1.3\n    onSuccess(e.target[\"result\"]);\n  };\n  if (onProgress) {\n    reader.onprogress = onProgress;\n  }\n  if (!useArrayBuffer) {\n    // Asynchronous read\n    reader.readAsText(file);\n  } else {\n    reader.readAsArrayBuffer(file);\n  }\n  return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n  if (fileOrUrl.name) {\n    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? error => {\n      onError(undefined, error);\n    } : undefined);\n  }\n  const url = fileOrUrl;\n  // If file and file input are set\n  if (url.indexOf(\"file:\") !== -1) {\n    let fileName = decodeURIComponent(url.substring(5).toLowerCase());\n    if (fileName.indexOf(\"./\") === 0) {\n      fileName = fileName.substring(2);\n    }\n    const file = FilesInputStore.FilesToLoad[fileName];\n    if (file) {\n      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? error => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\n    }\n  }\n  // For a Base64 Data URL\n  const {\n    match,\n    type\n  } = TestBase64DataUrl(url);\n  if (match) {\n    const fileRequest = {\n      onCompleteObservable: new Observable(),\n      abort: () => () => {}\n    };\n    try {\n      const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\n      onSuccess(data, undefined, type);\n    } catch (error) {\n      if (onError) {\n        onError(undefined, error);\n      } else {\n        Logger.Error(error.message || \"Failed to parse the Data URL\");\n      }\n    }\n    TimingTools.SetImmediate(() => {\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n    });\n    return fileRequest;\n  }\n  return RequestFile(url, (data, request) => {\n    onSuccess(data, request === null || request === void 0 ? void 0 : request.responseURL, request === null || request === void 0 ? void 0 : request.getResponseHeader(\"content-type\"));\n  }, onProgress, offlineProvider, useArrayBuffer, onError ? error => {\n    onError(error.request, new LoadFileError(error.message, error.request));\n  } : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @internal\n */\nexport const RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {\n  url = _CleanUrl(url);\n  url = FileToolsOptions.PreprocessUrl(url);\n  const loadUrl = FileToolsOptions.BaseUrl + url;\n  let aborted = false;\n  const fileRequest = {\n    onCompleteObservable: new Observable(),\n    abort: () => aborted = true\n  };\n  const requestFile = () => {\n    let request = new WebRequest();\n    let retryHandle = null;\n    let onReadyStateChange;\n    const unbindEvents = () => {\n      if (!request) {\n        return;\n      }\n      if (onProgress) {\n        request.removeEventListener(\"progress\", onProgress);\n      }\n      if (onReadyStateChange) {\n        request.removeEventListener(\"readystatechange\", onReadyStateChange);\n      }\n      request.removeEventListener(\"loadend\", onLoadEnd);\n    };\n    let onLoadEnd = () => {\n      unbindEvents();\n      fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n      fileRequest.onCompleteObservable.clear();\n      onProgress = undefined;\n      onReadyStateChange = null;\n      onLoadEnd = null;\n      onError = undefined;\n      onOpened = undefined;\n      onSuccess = undefined;\n    };\n    fileRequest.abort = () => {\n      aborted = true;\n      if (onLoadEnd) {\n        onLoadEnd();\n      }\n      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n        request.abort();\n      }\n      if (retryHandle !== null) {\n        clearTimeout(retryHandle);\n        retryHandle = null;\n      }\n      request = null;\n    };\n    const handleError = error => {\n      const message = error.message || \"Unknown error\";\n      if (onError && request) {\n        onError(new RequestFileError(message, request));\n      } else {\n        Logger.Error(message);\n      }\n    };\n    const retryLoop = retryIndex => {\n      if (!request) {\n        return;\n      }\n      request.open(\"GET\", loadUrl);\n      if (onOpened) {\n        try {\n          onOpened(request);\n        } catch (e) {\n          handleError(e);\n          return;\n        }\n      }\n      if (useArrayBuffer) {\n        request.responseType = \"arraybuffer\";\n      }\n      if (onProgress) {\n        request.addEventListener(\"progress\", onProgress);\n      }\n      if (onLoadEnd) {\n        request.addEventListener(\"loadend\", onLoadEnd);\n      }\n      onReadyStateChange = () => {\n        if (aborted || !request) {\n          return;\n        }\n        // In case of undefined state in some browsers.\n        if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n          // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n          if (onReadyStateChange) {\n            request.removeEventListener(\"readystatechange\", onReadyStateChange);\n          }\n          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {\n            try {\n              if (onSuccess) {\n                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n              }\n            } catch (e) {\n              handleError(e);\n            }\n            return;\n          }\n          const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n          if (retryStrategy) {\n            const waitTime = retryStrategy(loadUrl, request, retryIndex);\n            if (waitTime !== -1) {\n              // Prevent the request from completing for retry.\n              unbindEvents();\n              request = new WebRequest();\n              retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\n              return;\n            }\n          }\n          const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n          if (onError) {\n            onError(error);\n          }\n        }\n      };\n      request.addEventListener(\"readystatechange\", onReadyStateChange);\n      request.send();\n    };\n    retryLoop(0);\n  };\n  // Caching all files\n  if (offlineProvider && offlineProvider.enableSceneOffline) {\n    const noOfflineSupport = request => {\n      if (request && request.status > 400) {\n        if (onError) {\n          onError(request);\n        }\n      } else {\n        requestFile();\n      }\n    };\n    const loadFromOfflineSupport = () => {\n      // TODO: database needs to support aborting and should return a IFileRequest\n      if (offlineProvider) {\n        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, data => {\n          if (!aborted && onSuccess) {\n            onSuccess(data);\n          }\n          fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        }, onProgress ? event => {\n          if (!aborted && onProgress) {\n            onProgress(event);\n          }\n        } : undefined, noOfflineSupport, useArrayBuffer);\n      }\n    };\n    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n  } else {\n    requestFile();\n  }\n  return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @internal\n */\nexport const IsFileURL = () => {\n  return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @returns True if the uri is a base64 data url or false otherwise\n * @internal\n */\nexport const IsBase64DataUrl = uri => {\n  return Base64DataUrlRegEx.test(uri);\n};\nexport const TestBase64DataUrl = uri => {\n  const results = Base64DataUrlRegEx.exec(uri);\n  if (results === null || results.length === 0) {\n    return {\n      match: false,\n      type: \"\"\n    };\n  } else {\n    const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\n    return {\n      match: true,\n      type\n    };\n  }\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport function DecodeBase64UrlToBinary(uri) {\n  return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport const DecodeBase64UrlToString = uri => {\n  return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  ThinEngine._FileToolsLoadImage = LoadImage;\n  ThinEngine._FileToolsLoadFile = LoadFile;\n  ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\ninitSideEffects();\n/**\n* FileTools defined as any.\n* This should not be imported or used in future releases or in any module in the framework\n* @internal\n* @deprecated import the needed function from fileTools.ts\n*/\nexport let FileTools;\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @internal\n */\nexport const _injectLTSFileTools = (DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior) => {\n  /**\n   * Backwards compatibility.\n   * @internal\n   * @deprecated\n   */\n  FileTools = {\n    DecodeBase64UrlToBinary,\n    DecodeBase64UrlToString,\n    DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n    BaseUrl: FileToolsOptions.BaseUrl,\n    CorsBehavior: FileToolsOptions.CorsBehavior,\n    PreprocessUrl: FileToolsOptions.PreprocessUrl,\n    IsBase64DataUrl,\n    IsFileURL,\n    LoadFile,\n    LoadImage,\n    ReadFile,\n    RequestFile,\n    SetCorsBehavior\n  };\n  Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n    get: function () {\n      return FileToolsOptions.DefaultRetryStrategy;\n    },\n    set: function (value) {\n      FileToolsOptions.DefaultRetryStrategy = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"BaseUrl\", {\n    get: function () {\n      return FileToolsOptions.BaseUrl;\n    },\n    set: function (value) {\n      FileToolsOptions.BaseUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"PreprocessUrl\", {\n    get: function () {\n      return FileToolsOptions.PreprocessUrl;\n    },\n    set: function (value) {\n      FileToolsOptions.PreprocessUrl = value;\n    }\n  });\n  Object.defineProperty(FileTools, \"CorsBehavior\", {\n    get: function () {\n      return FileToolsOptions.CorsBehavior;\n    },\n    set: function (value) {\n      FileToolsOptions.CorsBehavior = value;\n    }\n  });\n};\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);","map":{"version":3,"mappings":"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","names":["WebRequest","IsWindowObjectExist","Observable","FilesInputStore","RetryStrategy","BaseError","ErrorCodes","RuntimeError","DecodeBase64ToBinary","DecodeBase64ToString","EncodeArrayBufferToBase64","ShaderProcessor","ThinEngine","EngineStore","Logger","TimingTools","Base64DataUrlRegEx","RegExp","LoadFileError","constructor","message","object","name","_setPrototypeOf","prototype","request","file","RequestFileError","ReadFileError","FileToolsOptions","DefaultRetryStrategy","ExponentialBackoff","BaseUrl","CorsBehavior","PreprocessUrl","url","_CleanUrl","replace","SetCorsBehavior","element","indexOf","String","crossOrigin","result","LoadImage","input","onLoad","onError","offlineProvider","mimeType","imageBitmapOptions","usingObjectURL","ArrayBuffer","isView","Blob","URL","createObjectURL","type","engine","LastCreatedEngine","onErrorHandler","exception","inputText","toString","length","slice","Image","_features","forceBitmapOverHTMLImageElement","LoadFile","data","createImageBitmap","premultiplyAlpha","then","imgBmp","revokeObjectURL","catch","reason","undefined","img","handlersList","loadHandlersList","forEach","handler","target","addEventListener","unloadHandlersList","removeEventListener","loadHandler","src","errorHandler","err","cspHandler","cspException","Error","effectiveDirective","blockedURI","originalPolicy","UseFallbackTexture","push","document","fromBlob","substring","fromData","noOfflineSupport","_","contentType","blob","loadFromOfflineSupport","loadImage","enableTexturesOffline","open","textureName","decodeURIComponent","toLowerCase","FilesToLoad","blobURL","ex","e","ReadFile","onSuccess","onProgress","useArrayBuffer","reader","FileReader","fileRequest","onCompleteObservable","abort","onloadend","notifyObservers","onerror","onload","onprogress","readAsText","readAsArrayBuffer","fileOrUrl","onOpened","error","fileName","match","TestBase64DataUrl","DecodeBase64UrlToBinary","DecodeBase64UrlToString","SetImmediate","RequestFile","responseURL","getResponseHeader","loadUrl","aborted","requestFile","retryHandle","onReadyStateChange","unbindEvents","onLoadEnd","clear","readyState","XMLHttpRequest","DONE","clearTimeout","handleError","retryLoop","retryIndex","responseType","status","IsFileURL","response","responseText","retryStrategy","waitTime","setTimeout","statusText","send","enableSceneOffline","loadFile","event","location","protocol","IsBase64DataUrl","uri","test","results","exec","split","initSideEffects","_FileToolsLoadImage","_FileToolsLoadFile","FileTools","_injectLTSFileTools","Object","defineProperty","get","set","value"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/fileTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport { WebRequest } from \"./webRequest\";\nimport { IsWindowObjectExist } from \"./domManagement\";\nimport type { Nullable } from \"../types\";\nimport type { IOfflineProvider } from \"../Offline/IOfflineProvider\";\nimport type { IFileRequest } from \"./fileRequest\";\nimport { Observable } from \"./observable\";\nimport { FilesInputStore } from \"./filesInputStore\";\nimport { RetryStrategy } from \"./retryStrategy\";\nimport { BaseError, ErrorCodes, RuntimeError } from \"./error\";\nimport { DecodeBase64ToBinary, DecodeBase64ToString, EncodeArrayBufferToBase64 } from \"./stringTools\";\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\nimport { ThinEngine } from \"../Engines/thinEngine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"./logger\";\nimport { TimingTools } from \"./timingTools\";\nconst Base64DataUrlRegEx = new RegExp(/^data:([^,]+\\/[^,]+)?;base64,/i);\n/** @ignore */\nexport class LoadFileError extends RuntimeError {\n    public request?: WebRequest;\n    public file?: File;\n    /**\n     * Creates a new LoadFileError\n     * @param message defines the message of the error\n     * @param object defines the optional web request\n     */\n    constructor(message: string, object?: WebRequest | File) {\n        super(message, ErrorCodes.LoadFileError);\n        this.name = \"LoadFileError\";\n        BaseError._setPrototypeOf(this, LoadFileError.prototype);\n        if (object instanceof WebRequest) {\n            this.request = object;\n        }\n        else {\n            this.file = object;\n        }\n    }\n}\n/** @ignore */\nexport class RequestFileError extends RuntimeError {\n    /**\n     * Creates a new LoadFileError\n     * @param message defines the message of the error\n     * @param request defines the optional web request\n     */\n    constructor(message: string, public request: WebRequest) {\n        super(message, ErrorCodes.RequestFileError);\n        this.name = \"RequestFileError\";\n        BaseError._setPrototypeOf(this, RequestFileError.prototype);\n    }\n}\n/** @ignore */\nexport class ReadFileError extends RuntimeError {\n    /**\n     * Creates a new ReadFileError\n     * @param message defines the message of the error\n     * @param file defines the optional file\n     */\n    constructor(message: string, public file: File) {\n        super(message, ErrorCodes.ReadFileError);\n        this.name = \"ReadFileError\";\n        BaseError._setPrototypeOf(this, ReadFileError.prototype);\n    }\n}\n/**\n * @internal\n */\nexport const FileToolsOptions: {\n    DefaultRetryStrategy: (url: string, request: WebRequest, retryIndex: number) => number;\n    BaseUrl: string;\n    CorsBehavior: string | ((url: string | string[]) => string);\n    PreprocessUrl: (url: string) => string;\n} = {\n    /**\n     * Gets or sets the retry strategy to apply when an error happens while loading an asset.\n     * When defining this function, return the wait time before trying again or return -1 to\n     * stop retrying and error out.\n     */\n    DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),\n    /**\n     * Gets or sets the base URL to use to load assets\n     */\n    BaseUrl: \"\",\n    /**\n     * Default behaviour for cors in the application.\n     * It can be a string if the expected behavior is identical in the entire app.\n     * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)\n     */\n    CorsBehavior: \"anonymous\",\n    /**\n     * Gets or sets a function used to pre-process url before using them to load assets\n     * @param url\n     */\n    PreprocessUrl: (url: string) => {\n        return url;\n    }\n};\n/**\n * Removes unwanted characters from an url\n * @param url defines the url to clean\n * @returns the cleaned url\n */\nconst _CleanUrl = (url: string): string => {\n    url = url.replace(/#/gm, \"%23\");\n    return url;\n};\n/**\n * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.\n * @param url define the url we are trying\n * @param element define the dom element where to configure the cors policy\n * @internal\n */\nexport const SetCorsBehavior = (url: string | string[], element: {\n    crossOrigin: string | null;\n}): void => {\n    if (url && url.indexOf(\"data:\") === 0) {\n        return;\n    }\n    if (FileToolsOptions.CorsBehavior) {\n        if (typeof FileToolsOptions.CorsBehavior === \"string\" || FileToolsOptions.CorsBehavior instanceof String) {\n            element.crossOrigin = <string>FileToolsOptions.CorsBehavior;\n        }\n        else {\n            const result = FileToolsOptions.CorsBehavior(url);\n            if (result) {\n                element.crossOrigin = result;\n            }\n        }\n    }\n};\n/**\n * Loads an image as an HTMLImageElement.\n * @param input url string, ArrayBuffer, or Blob to load\n * @param onLoad callback called when the image successfully loads\n * @param onError callback called when the image fails to load\n * @param offlineProvider offline provider for caching\n * @param mimeType optional mime type\n * @param imageBitmapOptions\n * @returns the HTMLImageElement of the loaded image\n * @internal\n */\nexport const LoadImage = (input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType: string = \"\", imageBitmapOptions?: ImageBitmapOptions): Nullable<HTMLImageElement> => {\n    let url: string;\n    let usingObjectURL = false;\n    if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {\n        if (typeof Blob !== \"undefined\" && typeof URL !== \"undefined\") {\n            url = URL.createObjectURL(new Blob([input], { type: mimeType }));\n            usingObjectURL = true;\n        }\n        else {\n            url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);\n        }\n    }\n    else if (input instanceof Blob) {\n        url = URL.createObjectURL(input);\n        usingObjectURL = true;\n    }\n    else {\n        url = _CleanUrl(input);\n        url = FileToolsOptions.PreprocessUrl(input);\n    }\n    const engine = EngineStore.LastCreatedEngine;\n    const onErrorHandler = (exception: any) => {\n        if (onError) {\n            const inputText = url || input.toString();\n            onError(`Error while trying to load image: ${inputText.indexOf(\"http\") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + \"...\"}`, exception);\n        }\n    };\n    if (typeof Image === \"undefined\" || (engine?._features.forceBitmapOverHTMLImageElement ?? false)) {\n        LoadFile(url, (data) => {\n            engine!\n                .createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: \"none\", ...imageBitmapOptions })\n                .then((imgBmp) => {\n                onLoad(imgBmp);\n                if (usingObjectURL) {\n                    URL.revokeObjectURL(url);\n                }\n            })\n                .catch((reason) => {\n                if (onError) {\n                    onError(\"Error while trying to load image: \" + input, reason);\n                }\n            });\n        }, undefined, offlineProvider || undefined, true, (request, exception) => {\n            onErrorHandler(exception);\n        });\n        return null;\n    }\n    const img = new Image();\n    SetCorsBehavior(url, img);\n    const handlersList: {\n        target: any;\n        name: string;\n        handler: any;\n    }[] = [];\n    const loadHandlersList = () => {\n        handlersList.forEach((handler) => {\n            handler.target.addEventListener(handler.name, handler.handler);\n        });\n    };\n    const unloadHandlersList = () => {\n        handlersList.forEach((handler) => {\n            handler.target.removeEventListener(handler.name, handler.handler);\n        });\n        handlersList.length = 0;\n    };\n    const loadHandler = () => {\n        unloadHandlersList();\n        onLoad(img);\n        // Must revoke the URL after calling onLoad to avoid security exceptions in\n        // certain scenarios (e.g. when hosted in vscode).\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n    };\n    const errorHandler = (err: any) => {\n        unloadHandlersList();\n        onErrorHandler(err);\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n    };\n    const cspHandler = (err: any) => {\n        unloadHandlersList();\n        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);\n        EngineStore.UseFallbackTexture = false;\n        onErrorHandler(cspException);\n        if (usingObjectURL && img.src) {\n            URL.revokeObjectURL(img.src);\n        }\n        img.src = \"\";\n    };\n    handlersList.push({ target: img, name: \"load\", handler: loadHandler });\n    handlersList.push({ target: img, name: \"error\", handler: errorHandler });\n    handlersList.push({ target: document, name: \"securitypolicyviolation\", handler: cspHandler });\n    loadHandlersList();\n    const fromBlob = url.substring(0, 5) === \"blob:\";\n    const fromData = url.substring(0, 5) === \"data:\";\n    const noOfflineSupport = () => {\n        if (fromBlob || fromData) {\n            img.src = url;\n        }\n        else {\n            LoadFile(url, (data, _, contentType) => {\n                const type = !mimeType && contentType ? contentType : mimeType;\n                const blob = new Blob([data], { type });\n                const url = URL.createObjectURL(blob);\n                usingObjectURL = true;\n                img.src = url;\n            }, undefined, offlineProvider || undefined, true, (request, exception) => {\n                onErrorHandler(exception);\n            });\n        }\n    };\n    const loadFromOfflineSupport = () => {\n        if (offlineProvider) {\n            offlineProvider.loadImage(url, img);\n        }\n    };\n    if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    }\n    else {\n        if (url.indexOf(\"file:\") !== -1) {\n            const textureName = decodeURIComponent(url.substring(5).toLowerCase());\n            if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== \"undefined\") {\n                try {\n                    let blobURL;\n                    try {\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n                    }\n                    catch (ex) {\n                        // Chrome doesn't support oneTimeOnly parameter\n                        blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);\n                    }\n                    img.src = blobURL;\n                    usingObjectURL = true;\n                }\n                catch (e) {\n                    img.src = \"\";\n                }\n                return img;\n            }\n        }\n        noOfflineSupport();\n    }\n    return img;\n};\n/**\n * Reads a file from a File object\n * @param file defines the file to load\n * @param onSuccess defines the callback to call when data is loaded\n * @param onProgress defines the callback to call during loading process\n * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer\n * @param onError defines the callback to call when an error occurs\n * @returns a file request object\n * @internal\n */\nexport const ReadFile = (file: File, onSuccess: (data: any) => void, onProgress?: (ev: ProgressEvent) => any, useArrayBuffer?: boolean, onError?: (error: ReadFileError) => void): IFileRequest => {\n    const reader = new FileReader();\n    const fileRequest: IFileRequest = {\n        onCompleteObservable: new Observable<IFileRequest>(),\n        abort: () => reader.abort()\n    };\n    reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n    if (onError) {\n        reader.onerror = () => {\n            onError(new ReadFileError(`Unable to read ${file.name}`, file));\n        };\n    }\n    reader.onload = (e) => {\n        //target doesn't have result from ts 1.3\n        onSuccess((<any>e.target)[\"result\"]);\n    };\n    if (onProgress) {\n        reader.onprogress = onProgress;\n    }\n    if (!useArrayBuffer) {\n        // Asynchronous read\n        reader.readAsText(file);\n    }\n    else {\n        reader.readAsArrayBuffer(file);\n    }\n    return fileRequest;\n};\n/**\n * Loads a file from a url, a data url, or a file url\n * @param fileOrUrl file, url, data url, or file url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened\n * @returns a file request object\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const LoadFile = (fileOrUrl: File | string, onSuccess: (data: string | ArrayBuffer, responseURL?: string, contentType?: Nullable<string>) => void, onProgress?: (ev: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (request?: WebRequest, exception?: LoadFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest => {\n    if ((fileOrUrl as File).name) {\n        return ReadFile(fileOrUrl as File, onSuccess, onProgress, useArrayBuffer, onError\n            ? (error: ReadFileError) => {\n                onError(undefined, error);\n            }\n            : undefined);\n    }\n    const url = fileOrUrl as string;\n    // If file and file input are set\n    if (url.indexOf(\"file:\") !== -1) {\n        let fileName = decodeURIComponent(url.substring(5).toLowerCase());\n        if (fileName.indexOf(\"./\") === 0) {\n            fileName = fileName.substring(2);\n        }\n        const file = FilesInputStore.FilesToLoad[fileName];\n        if (file) {\n            return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(undefined, new LoadFileError(error.message, error.file)) : undefined);\n        }\n    }\n    // For a Base64 Data URL\n    const { match, type } = TestBase64DataUrl(url);\n    if (match) {\n        const fileRequest: IFileRequest = {\n            onCompleteObservable: new Observable<IFileRequest>(),\n            abort: () => () => { }\n        };\n        try {\n            const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);\n            onSuccess(data, undefined, type);\n        }\n        catch (error) {\n            if (onError) {\n                onError(undefined, error);\n            }\n            else {\n                Logger.Error(error.message || \"Failed to parse the Data URL\");\n            }\n        }\n        TimingTools.SetImmediate(() => {\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n        });\n        return fileRequest;\n    }\n    return RequestFile(url, (data, request) => {\n        onSuccess(data, request?.responseURL, request?.getResponseHeader(\"content-type\"));\n    }, onProgress, offlineProvider, useArrayBuffer, onError\n        ? (error) => {\n            onError(error.request, new LoadFileError(error.message, error.request));\n        }\n        : undefined, onOpened);\n};\n/**\n * Loads a file from a url\n * @param url url to load\n * @param onSuccess callback called when the file successfully loads\n * @param onProgress callback called while file is loading (if the server supports this mode)\n * @param offlineProvider defines the offline provider for caching\n * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer\n * @param onError callback called when the file fails to load\n * @param onOpened callback called when the web request is opened\n * @returns a file request object\n * @internal\n */\nexport const RequestFile = (url: string, onSuccess?: (data: string | ArrayBuffer, request?: WebRequest) => void, onProgress?: (event: ProgressEvent) => void, offlineProvider?: IOfflineProvider, useArrayBuffer?: boolean, onError?: (error: RequestFileError) => void, onOpened?: (request: WebRequest) => void): IFileRequest => {\n    url = _CleanUrl(url);\n    url = FileToolsOptions.PreprocessUrl(url);\n    const loadUrl = FileToolsOptions.BaseUrl + url;\n    let aborted = false;\n    const fileRequest: IFileRequest = {\n        onCompleteObservable: new Observable<IFileRequest>(),\n        abort: () => (aborted = true)\n    };\n    const requestFile = () => {\n        let request: Nullable<WebRequest> = new WebRequest();\n        let retryHandle: Nullable<ReturnType<typeof setTimeout>> = null;\n        let onReadyStateChange: Nullable<() => void>;\n        const unbindEvents = () => {\n            if (!request) {\n                return;\n            }\n            if (onProgress) {\n                request.removeEventListener(\"progress\", onProgress);\n            }\n            if (onReadyStateChange) {\n                request.removeEventListener(\"readystatechange\", onReadyStateChange);\n            }\n            request.removeEventListener(\"loadend\", onLoadEnd!);\n        };\n        let onLoadEnd: Nullable<() => void> = () => {\n            unbindEvents();\n            fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n            fileRequest.onCompleteObservable.clear();\n            onProgress = undefined;\n            onReadyStateChange = null;\n            onLoadEnd = null;\n            onError = undefined;\n            onOpened = undefined;\n            onSuccess = undefined;\n        };\n        fileRequest.abort = () => {\n            aborted = true;\n            if (onLoadEnd) {\n                onLoadEnd();\n            }\n            if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {\n                request.abort();\n            }\n            if (retryHandle !== null) {\n                clearTimeout(retryHandle);\n                retryHandle = null;\n            }\n            request = null;\n        };\n        const handleError = (error: any) => {\n            const message = error.message || \"Unknown error\";\n            if (onError && request) {\n                onError(new RequestFileError(message, request));\n            }\n            else {\n                Logger.Error(message);\n            }\n        };\n        const retryLoop = (retryIndex: number) => {\n            if (!request) {\n                return;\n            }\n            request.open(\"GET\", loadUrl);\n            if (onOpened) {\n                try {\n                    onOpened(request);\n                }\n                catch (e) {\n                    handleError(e);\n                    return;\n                }\n            }\n            if (useArrayBuffer) {\n                request.responseType = \"arraybuffer\";\n            }\n            if (onProgress) {\n                request.addEventListener(\"progress\", onProgress);\n            }\n            if (onLoadEnd) {\n                request.addEventListener(\"loadend\", onLoadEnd);\n            }\n            onReadyStateChange = () => {\n                if (aborted || !request) {\n                    return;\n                }\n                // In case of undefined state in some browsers.\n                if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n                    // Some browsers have issues where onreadystatechange can be called multiple times with the same value.\n                    if (onReadyStateChange) {\n                        request.removeEventListener(\"readystatechange\", onReadyStateChange);\n                    }\n                    if ((request.status >= 200 && request.status < 300) || (request.status === 0 && (!IsWindowObjectExist() || IsFileURL()))) {\n                        try {\n                            if (onSuccess) {\n                                onSuccess(useArrayBuffer ? request.response : request.responseText, request);\n                            }\n                        }\n                        catch (e) {\n                            handleError(e);\n                        }\n                        return;\n                    }\n                    const retryStrategy = FileToolsOptions.DefaultRetryStrategy;\n                    if (retryStrategy) {\n                        const waitTime = retryStrategy(loadUrl, request, retryIndex);\n                        if (waitTime !== -1) {\n                            // Prevent the request from completing for retry.\n                            unbindEvents();\n                            request = new WebRequest();\n                            retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);\n                            return;\n                        }\n                    }\n                    const error = new RequestFileError(\"Error status: \" + request.status + \" \" + request.statusText + \" - Unable to load \" + loadUrl, request);\n                    if (onError) {\n                        onError(error);\n                    }\n                }\n            };\n            request.addEventListener(\"readystatechange\", onReadyStateChange);\n            request.send();\n        };\n        retryLoop(0);\n    };\n    // Caching all files\n    if (offlineProvider && offlineProvider.enableSceneOffline) {\n        const noOfflineSupport = (request?: any) => {\n            if (request && request.status > 400) {\n                if (onError) {\n                    onError(request);\n                }\n            }\n            else {\n                requestFile();\n            }\n        };\n        const loadFromOfflineSupport = () => {\n            // TODO: database needs to support aborting and should return a IFileRequest\n            if (offlineProvider) {\n                offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {\n                    if (!aborted && onSuccess) {\n                        onSuccess(data);\n                    }\n                    fileRequest.onCompleteObservable.notifyObservers(fileRequest);\n                }, onProgress\n                    ? (event) => {\n                        if (!aborted && onProgress) {\n                            onProgress(event);\n                        }\n                    }\n                    : undefined, noOfflineSupport, useArrayBuffer);\n            }\n        };\n        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);\n    }\n    else {\n        requestFile();\n    }\n    return fileRequest;\n};\n/**\n * Checks if the loaded document was accessed via `file:`-Protocol.\n * @returns boolean\n * @internal\n */\nexport const IsFileURL = (): boolean => {\n    return typeof location !== \"undefined\" && location.protocol === \"file:\";\n};\n/**\n * Test if the given uri is a valid base64 data url\n * @param uri The uri to test\n * @returns True if the uri is a base64 data url or false otherwise\n * @internal\n */\nexport const IsBase64DataUrl = (uri: string): boolean => {\n    return Base64DataUrlRegEx.test(uri);\n};\nexport const TestBase64DataUrl = (uri: string): {\n    match: boolean;\n    type: string;\n} => {\n    const results = Base64DataUrlRegEx.exec(uri);\n    if (results === null || results.length === 0) {\n        return { match: false, type: \"\" };\n    }\n    else {\n        const type = results[0].replace(\"data:\", \"\").replace(\"base64,\", \"\");\n        return { match: true, type };\n    }\n};\n/**\n * Decode the given base64 uri.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport function DecodeBase64UrlToBinary(uri: string): ArrayBuffer {\n    return DecodeBase64ToBinary(uri.split(\",\")[1]);\n}\n/**\n * Decode the given base64 uri into a UTF-8 encoded string.\n * @param uri The uri to decode\n * @returns The decoded base64 data.\n * @internal\n */\nexport const DecodeBase64UrlToString = (uri: string): string => {\n    return DecodeBase64ToString(uri.split(\",\")[1]);\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n    ThinEngine._FileToolsLoadImage = LoadImage;\n    ThinEngine._FileToolsLoadFile = LoadFile;\n    ShaderProcessor._FileToolsLoadFile = LoadFile;\n};\ninitSideEffects();\n\n    /**\n * FileTools defined as any.\n * This should not be imported or used in future releases or in any module in the framework\n * @internal\n * @deprecated import the needed function from fileTools.ts\n */\nexport let FileTools: {\n    DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer;\n    DecodeBase64UrlToString: (uri: string) => string;\n    DefaultRetryStrategy: any;\n    BaseUrl: any;\n    CorsBehavior: any;\n    PreprocessUrl: any;\n    IsBase64DataUrl: (uri: string) => boolean;\n    IsFileURL: () => boolean;\n    LoadFile: (fileOrUrl: string | File, onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest;\n    LoadImage: (input: string | ArrayBuffer | Blob | ArrayBufferView, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string | undefined, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string | undefined, imageBitmapOptions?: ImageBitmapOptions | undefined) => Nullable<HTMLImageElement>;\n    ReadFile: (file: File, onSuccess: (data: any) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: ReadFileError) => void) | undefined) => IFileRequest;\n    RequestFile: (url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void, onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: RequestFileError) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest;\n    SetCorsBehavior: (url: string | string[], element: {\n        crossOrigin: string | null;\n    }) => void;\n};\n/**\n * @param DecodeBase64UrlToBinary\n * @param DecodeBase64UrlToString\n * @param FileToolsOptions\n * @internal\n */\nexport const _injectLTSFileTools = (DecodeBase64UrlToBinary: (uri: string) => ArrayBuffer, DecodeBase64UrlToString: (uri: string) => string, FileToolsOptions: {\n    DefaultRetryStrategy: any;\n    BaseUrl: any;\n    CorsBehavior: any;\n    PreprocessUrl: any;\n}, IsBase64DataUrl: (uri: string) => boolean, IsFileURL: () => boolean, LoadFile: (fileOrUrl: string | File, onSuccess: (data: string | ArrayBuffer, responseURL?: string | undefined) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((request?: WebRequest | undefined, exception?: LoadFileError | undefined) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest, LoadImage: (input: string | ArrayBuffer | ArrayBufferView | Blob, onLoad: (img: HTMLImageElement | ImageBitmap) => void, onError: (message?: string | undefined, exception?: any) => void, offlineProvider: Nullable<IOfflineProvider>, mimeType?: string, imageBitmapOptions?: ImageBitmapOptions | undefined) => Nullable<HTMLImageElement>, ReadFile: (file: File, onSuccess: (data: any) => void, onProgress?: ((ev: ProgressEvent<EventTarget>) => any) | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: ReadFileError) => void) | undefined) => IFileRequest, RequestFile: (url: string, onSuccess: (data: string | ArrayBuffer, request?: WebRequest | undefined) => void, onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined, offlineProvider?: IOfflineProvider | undefined, useArrayBuffer?: boolean | undefined, onError?: ((error: RequestFileError) => void) | undefined, onOpened?: ((request: WebRequest) => void) | undefined) => IFileRequest, SetCorsBehavior: (url: string | string[], element: {\n    crossOrigin: string | null;\n}) => void) => {\n    /**\n     * Backwards compatibility.\n     * @internal\n     * @deprecated\n     */\n    FileTools = {\n        DecodeBase64UrlToBinary,\n        DecodeBase64UrlToString,\n        DefaultRetryStrategy: FileToolsOptions.DefaultRetryStrategy,\n        BaseUrl: FileToolsOptions.BaseUrl,\n        CorsBehavior: FileToolsOptions.CorsBehavior,\n        PreprocessUrl: FileToolsOptions.PreprocessUrl,\n        IsBase64DataUrl,\n        IsFileURL,\n        LoadFile,\n        LoadImage,\n        ReadFile,\n        RequestFile,\n        SetCorsBehavior\n    };\n    Object.defineProperty(FileTools, \"DefaultRetryStrategy\", {\n        get: function (this: null) {\n            return FileToolsOptions.DefaultRetryStrategy;\n        },\n        set: function (this: null, value: (url: string, request: WebRequest, retryIndex: number) => number) {\n            FileToolsOptions.DefaultRetryStrategy = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"BaseUrl\", {\n        get: function (this: null) {\n            return FileToolsOptions.BaseUrl;\n        },\n        set: function (this: null, value: string) {\n            FileToolsOptions.BaseUrl = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"PreprocessUrl\", {\n        get: function (this: null) {\n            return FileToolsOptions.PreprocessUrl;\n        },\n        set: function (this: null, value: (url: string) => string) {\n            FileToolsOptions.PreprocessUrl = value;\n        }\n    });\n    Object.defineProperty(FileTools, \"CorsBehavior\", {\n        get: function (this: null) {\n            return FileToolsOptions.CorsBehavior;\n        },\n        set: function (this: null, value: string | ((url: string | string[]) => string)) {\n            FileToolsOptions.CorsBehavior = value;\n        }\n    });\n};\n_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}