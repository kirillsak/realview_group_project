{"ast":null,"code":"/**\n * Base class of the scene acting as a container for the different elements composing a scene.\n * This class is dynamically extended by the different components of the scene increasing\n * flexibility and reducing coupling\n */\nexport class AbstractScene {\n  constructor() {\n    /**\n     * Gets the list of root nodes (ie. nodes with no parent)\n     */\n    this.rootNodes = new Array();\n    /** All of the cameras added to this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n     */\n    this.cameras = new Array();\n    /**\n     * All of the lights added to this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     */\n    this.lights = new Array();\n    /**\n     * All of the (abstract) meshes added to this scene\n     */\n    this.meshes = new Array();\n    /**\n     * The list of skeletons added to the scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n     */\n    this.skeletons = new Array();\n    /**\n     * All of the particle systems added to this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\n     */\n    this.particleSystems = new Array();\n    /**\n     * Gets a list of Animations associated with the scene\n     */\n    this.animations = [];\n    /**\n     * All of the animation groups added to this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n     */\n    this.animationGroups = new Array();\n    /**\n     * All of the multi-materials added to this scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\n     */\n    this.multiMaterials = new Array();\n    /**\n     * All of the materials added to this scene\n     * In the context of a Scene, it is not supposed to be modified manually.\n     * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\n     * Note also that the order of the Material within the array is not significant and might change.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n     */\n    this.materials = new Array();\n    /**\n     * The list of morph target managers added to the scene\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph\n     */\n    this.morphTargetManagers = new Array();\n    /**\n     * The list of geometries used in the scene.\n     */\n    this.geometries = new Array();\n    /**\n     * All of the transform nodes added to this scene\n     * In the context of a Scene, it is not supposed to be modified manually.\n     * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\n     * Note also that the order of the TransformNode within the array is not significant and might change.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\n     */\n    this.transformNodes = new Array();\n    /**\n     * ActionManagers available on the scene.\n     * @deprecated\n     */\n    this.actionManagers = new Array();\n    /**\n     * Textures to keep.\n     */\n    this.textures = new Array();\n    /** @internal */\n    this._environmentTexture = null;\n    /**\n     * The list of postprocesses added to the scene\n     */\n    this.postProcesses = new Array();\n  }\n  /**\n   * Adds a parser in the list of available ones\n   * @param name Defines the name of the parser\n   * @param parser Defines the parser to add\n   */\n  static AddParser(name, parser) {\n    this._BabylonFileParsers[name] = parser;\n  }\n  /**\n   * Gets a general parser from the list of available ones\n   * @param name Defines the name of the parser\n   * @returns the requested parser or null\n   */\n  static GetParser(name) {\n    if (this._BabylonFileParsers[name]) {\n      return this._BabylonFileParsers[name];\n    }\n    return null;\n  }\n  /**\n   * Adds n individual parser in the list of available ones\n   * @param name Defines the name of the parser\n   * @param parser Defines the parser to add\n   */\n  static AddIndividualParser(name, parser) {\n    this._IndividualBabylonFileParsers[name] = parser;\n  }\n  /**\n   * Gets an individual parser from the list of available ones\n   * @param name Defines the name of the parser\n   * @returns the requested parser or null\n   */\n  static GetIndividualParser(name) {\n    if (this._IndividualBabylonFileParsers[name]) {\n      return this._IndividualBabylonFileParsers[name];\n    }\n    return null;\n  }\n  /**\n   * Parser json data and populate both a scene and its associated container object\n   * @param jsonData Defines the data to parse\n   * @param scene Defines the scene to parse the data for\n   * @param container Defines the container attached to the parsing sequence\n   * @param rootUrl Defines the root url of the data\n   */\n  static Parse(jsonData, scene, container, rootUrl) {\n    for (const parserName in this._BabylonFileParsers) {\n      if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {\n        this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\n      }\n    }\n  }\n  /**\n   * Texture used in all pbr material as the reflection texture.\n   * As in the majority of the scene they are the same (exception for multi room and so on),\n   * this is easier to reference from here than from all the materials.\n   */\n  get environmentTexture() {\n    return this._environmentTexture;\n  }\n  set environmentTexture(value) {\n    this._environmentTexture = value;\n  }\n  /**\n   * @returns all meshes, lights, cameras, transformNodes and bones\n   */\n  getNodes() {\n    let nodes = new Array();\n    nodes = nodes.concat(this.meshes);\n    nodes = nodes.concat(this.lights);\n    nodes = nodes.concat(this.cameras);\n    nodes = nodes.concat(this.transformNodes); // dummies\n    this.skeletons.forEach(skeleton => nodes = nodes.concat(skeleton.bones));\n    return nodes;\n  }\n}\n/**\n * Stores the list of available parsers in the application.\n */\nAbstractScene._BabylonFileParsers = {};\n/**\n * Stores the list of available individual parsers in the application.\n */\nAbstractScene._IndividualBabylonFileParsers = {};","map":{"version":3,"mappings":"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","names":["AbstractScene","constructor","Array","AddParser","name","parser","_BabylonFileParsers","GetParser","AddIndividualParser","_IndividualBabylonFileParsers","GetIndividualParser","Parse","jsonData","scene","container","rootUrl","parserName","Object","prototype","hasOwnProperty","call","environmentTexture","_environmentTexture","value","getNodes","nodes","concat","meshes","lights","cameras","transformNodes","skeletons","forEach","skeleton","bones"],"sourceRoot":"","sources":["../../../lts/core/generated/abstractScene.ts"],"sourcesContent":["import type { Scene } from \"./scene\";\r\nimport type { Nullable } from \"./types\";\r\nimport type { AbstractMesh } from \"./Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"./Meshes/transformNode\";\r\nimport type { Geometry } from \"./Meshes/geometry\";\r\nimport type { Skeleton } from \"./Bones/skeleton\";\r\nimport type { MorphTargetManager } from \"./Morph/morphTargetManager\";\r\nimport type { AssetContainer } from \"./assetContainer\";\r\nimport type { IParticleSystem } from \"./Particles/IParticleSystem\";\r\nimport type { AnimationGroup } from \"./Animations/animationGroup\";\r\nimport type { BaseTexture } from \"./Materials/Textures/baseTexture\";\r\nimport type { Material } from \"./Materials/material\";\r\nimport type { MultiMaterial } from \"./Materials/multiMaterial\";\r\nimport type { AbstractActionManager } from \"./Actions/abstractActionManager\";\r\nimport type { Camera } from \"./Cameras/camera\";\r\nimport type { Light } from \"./Lights/light\";\r\nimport type { Node } from \"./node\";\r\n\r\ndeclare type Animation = import(\"./Animations/animation\").Animation;\r\ndeclare type PostProcess = import(\"./PostProcesses/postProcess\").PostProcess;\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Base class of the scene acting as a container for the different elements composing a scene.\r\n * This class is dynamically extended by the different components of the scene increasing\r\n * flexibility and reducing coupling\r\n */\r\nexport abstract class AbstractScene {\r\n    /**\r\n     * Stores the list of available parsers in the application.\r\n     */\r\n    private static _BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n    /**\r\n     * Stores the list of available individual parsers in the application.\r\n     */\r\n    private static _IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n    /**\r\n     * Adds a parser in the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @param parser Defines the parser to add\r\n     */\r\n    public static AddParser(name: string, parser: BabylonFileParser): void {\r\n        this._BabylonFileParsers[name] = parser;\r\n    }\r\n\r\n    /**\r\n     * Gets a general parser from the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @returns the requested parser or null\r\n     */\r\n    public static GetParser(name: string): Nullable<BabylonFileParser> {\r\n        if (this._BabylonFileParsers[name]) {\r\n            return this._BabylonFileParsers[name];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Adds n individual parser in the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @param parser Defines the parser to add\r\n     */\r\n    public static AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n        this._IndividualBabylonFileParsers[name] = parser;\r\n    }\r\n\r\n    /**\r\n     * Gets an individual parser from the list of available ones\r\n     * @param name Defines the name of the parser\r\n     * @returns the requested parser or null\r\n     */\r\n    public static GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n        if (this._IndividualBabylonFileParsers[name]) {\r\n            return this._IndividualBabylonFileParsers[name];\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parser json data and populate both a scene and its associated container object\r\n     * @param jsonData Defines the data to parse\r\n     * @param scene Defines the scene to parse the data for\r\n     * @param container Defines the container attached to the parsing sequence\r\n     * @param rootUrl Defines the root url of the data\r\n     */\r\n    public static Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n        for (const parserName in this._BabylonFileParsers) {\r\n            if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {\r\n                this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the list of root nodes (ie. nodes with no parent)\r\n     */\r\n    public rootNodes = new Array<Node>();\r\n\r\n    /** All of the cameras added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     */\r\n    public cameras = new Array<Camera>();\r\n\r\n    /**\r\n     * All of the lights added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     */\r\n    public lights = new Array<Light>();\r\n\r\n    /**\r\n     * All of the (abstract) meshes added to this scene\r\n     */\r\n    public meshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * The list of skeletons added to the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n     */\r\n    public skeletons = new Array<Skeleton>();\r\n\r\n    /**\r\n     * All of the particle systems added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/particles/particle_system/particle_system_intro\r\n     */\r\n    public particleSystems = new Array<IParticleSystem>();\r\n\r\n    /**\r\n     * Gets a list of Animations associated with the scene\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * All of the animation groups added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     */\r\n    public animationGroups = new Array<AnimationGroup>();\r\n\r\n    /**\r\n     * All of the multi-materials added to this scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n     */\r\n    public multiMaterials = new Array<MultiMaterial>();\r\n\r\n    /**\r\n     * All of the materials added to this scene\r\n     * In the context of a Scene, it is not supposed to be modified manually.\r\n     * Any addition or removal should be done using the addMaterial and removeMaterial Scene methods.\r\n     * Note also that the order of the Material within the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n     */\r\n    public materials = new Array<Material>();\r\n\r\n    /**\r\n     * The list of morph target managers added to the scene\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph\r\n     */\r\n    public morphTargetManagers = new Array<MorphTargetManager>();\r\n\r\n    /**\r\n     * The list of geometries used in the scene.\r\n     */\r\n    public geometries = new Array<Geometry>();\r\n\r\n    /**\r\n     * All of the transform nodes added to this scene\r\n     * In the context of a Scene, it is not supposed to be modified manually.\r\n     * Any addition or removal should be done using the addTransformNode and removeTransformNode Scene methods.\r\n     * Note also that the order of the TransformNode within the array is not significant and might change.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/transform_node\r\n     */\r\n    public transformNodes = new Array<TransformNode>();\r\n\r\n    /**\r\n     * ActionManagers available on the scene.\r\n     * @deprecated\r\n     */\r\n    public actionManagers = new Array<AbstractActionManager>();\r\n\r\n    /**\r\n     * Textures to keep.\r\n     */\r\n    public textures = new Array<BaseTexture>();\r\n\r\n    /** @internal */\r\n    protected _environmentTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Texture used in all pbr material as the reflection texture.\r\n     * As in the majority of the scene they are the same (exception for multi room and so on),\r\n     * this is easier to reference from here than from all the materials.\r\n     */\r\n    public get environmentTexture(): Nullable<BaseTexture> {\r\n        return this._environmentTexture;\r\n    }\r\n\r\n    public set environmentTexture(value: Nullable<BaseTexture>) {\r\n        this._environmentTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The list of postprocesses added to the scene\r\n     */\r\n    public postProcesses = new Array<PostProcess>();\r\n\r\n    /**\r\n     * @returns all meshes, lights, cameras, transformNodes and bones\r\n     */\r\n    public getNodes(): Array<Node> {\r\n        let nodes = new Array<Node>();\r\n        nodes = nodes.concat(this.meshes);\r\n        nodes = nodes.concat(this.lights);\r\n        nodes = nodes.concat(this.cameras);\r\n        nodes = nodes.concat(this.transformNodes); // dummies\r\n        this.skeletons.forEach((skeleton) => (nodes = nodes.concat(skeleton.bones)));\r\n        return nodes;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}