{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial.js\";\nimport { ToLinearSpace } from \"../../Maths/math.constants.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nclass FileFaceOrientation {\n  constructor(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n    this.name = name;\n    this.worldAxisForNormal = worldAxisForNormal;\n    this.worldAxisForFileX = worldAxisForFileX;\n    this.worldAxisForFileY = worldAxisForFileY;\n  }\n}\n/**\n * Helper class dealing with the extraction of spherical polynomial dataArray\n * from a cube map.\n */\nexport class CubeMapToSphericalPolynomialTools {\n  /**\n   * Converts a texture to the according Spherical Polynomial data.\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\n   *\n   * @param texture The texture to extract the information from.\n   * @returns The Spherical Polynomial data.\n   */\n  static ConvertCubeMapTextureToSphericalPolynomial(texture) {\n    var _a;\n    if (!texture.isCube) {\n      // Only supports cube Textures currently.\n      return null;\n    }\n    (_a = texture.getScene()) === null || _a === void 0 ? void 0 : _a.getEngine().flushFramebuffer();\n    const size = texture.getSize().width;\n    const rightPromise = texture.readPixels(0, undefined, undefined, false);\n    const leftPromise = texture.readPixels(1, undefined, undefined, false);\n    let upPromise;\n    let downPromise;\n    if (texture.isRenderTarget) {\n      upPromise = texture.readPixels(3, undefined, undefined, false);\n      downPromise = texture.readPixels(2, undefined, undefined, false);\n    } else {\n      upPromise = texture.readPixels(2, undefined, undefined, false);\n      downPromise = texture.readPixels(3, undefined, undefined, false);\n    }\n    const frontPromise = texture.readPixels(4, undefined, undefined, false);\n    const backPromise = texture.readPixels(5, undefined, undefined, false);\n    const gammaSpace = texture.gammaSpace;\n    // Always read as RGBA.\n    const format = 5;\n    let type = 0;\n    if (texture.textureType == 1 || texture.textureType == 2) {\n      type = 1;\n    }\n    return new Promise(resolve => {\n      Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\n        const cubeInfo = {\n          size,\n          right,\n          left,\n          up,\n          down,\n          front,\n          back,\n          format,\n          type,\n          gammaSpace\n        };\n        resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\n      });\n    });\n  }\n  /**\n   * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\n   * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\n   * @param x\n   * @param y\n   */\n  static _AreaElement(x, y) {\n    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\n  }\n  /**\n   * Converts a cubemap to the according Spherical Polynomial data.\n   * This extracts the first 3 orders only as they are the only one used in the lighting.\n   *\n   * @param cubeInfo The Cube map to extract the information from.\n   * @returns The Spherical Polynomial data.\n   */\n  static ConvertCubeMapToSphericalPolynomial(cubeInfo) {\n    const sphericalHarmonics = new SphericalHarmonics();\n    let totalSolidAngle = 0.0;\n    // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n    const du = 2.0 / cubeInfo.size;\n    const dv = du;\n    const halfTexel = 0.5 * du;\n    // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n    const minUV = halfTexel - 1.0;\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\n      const fileFace = this._FileFaces[faceIndex];\n      const dataArray = cubeInfo[fileFace.name];\n      let v = minUV;\n      // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n      // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n      // Because SP is still linear, so summation is fine in that basis.\n      const stride = cubeInfo.format === 5 ? 4 : 3;\n      for (let y = 0; y < cubeInfo.size; y++) {\n        let u = minUV;\n        for (let x = 0; x < cubeInfo.size; x++) {\n          // World direction (not normalised)\n          const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n          worldDirection.normalize();\n          const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);\n          let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\n          let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\n          let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\n          // Prevent NaN harmonics with extreme HDRI data.\n          if (isNaN(r)) {\n            r = 0;\n          }\n          if (isNaN(g)) {\n            g = 0;\n          }\n          if (isNaN(b)) {\n            b = 0;\n          }\n          // Handle Integer types.\n          if (cubeInfo.type === 0) {\n            r /= 255;\n            g /= 255;\n            b /= 255;\n          }\n          // Handle Gamma space textures.\n          if (cubeInfo.gammaSpace) {\n            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\n            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\n            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\n          }\n          // Prevent to explode in case of really high dynamic ranges.\n          // sh 3 would not be enough to accurately represent it.\n          const max = 4096;\n          r = Scalar.Clamp(r, 0, max);\n          g = Scalar.Clamp(g, 0, max);\n          b = Scalar.Clamp(b, 0, max);\n          const color = new Color3(r, g, b);\n          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n          totalSolidAngle += deltaSolidAngle;\n          u += du;\n        }\n        v += dv;\n      }\n    }\n    // Solid angle for entire sphere is 4*pi\n    const sphereSolidAngle = 4.0 * Math.PI;\n    // Adjust the solid angle to allow for how many faces we processed.\n    const facesProcessed = 6.0;\n    const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0;\n    // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\n    // This is needed because the numerical integration over the cube uses a\n    // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n    // and also to compensate for accumulative error due to float precision in the summation.\n    const correctionFactor = expectedSolidAngle / totalSolidAngle;\n    sphericalHarmonics.scaleInPlace(correctionFactor);\n    sphericalHarmonics.convertIncidentRadianceToIrradiance();\n    sphericalHarmonics.convertIrradianceToLambertianRadiance();\n    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\n  }\n}\nCubeMapToSphericalPolynomialTools._FileFaces = [new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)) // -Z bottom\n];","map":{"version":3,"mappings":"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","names":["Vector3","Scalar","SphericalPolynomial","SphericalHarmonics","ToLinearSpace","Color3","FileFaceOrientation","constructor","name","worldAxisForNormal","worldAxisForFileX","worldAxisForFileY","CubeMapToSphericalPolynomialTools","ConvertCubeMapTextureToSphericalPolynomial","texture","isCube","getScene","getEngine","flushFramebuffer","size","getSize","width","rightPromise","readPixels","undefined","leftPromise","upPromise","downPromise","isRenderTarget","frontPromise","backPromise","gammaSpace","format","type","textureType","Promise","resolve","all","then","left","right","up","down","front","back","cubeInfo","ConvertCubeMapToSphericalPolynomial","_AreaElement","x","y","Math","atan2","sqrt","sphericalHarmonics","totalSolidAngle","du","dv","halfTexel","minUV","faceIndex","fileFace","_FileFaces","dataArray","v","stride","u","worldDirection","scale","add","normalize","deltaSolidAngle","r","g","b","isNaN","pow","Clamp","max","color","addLight","sphereSolidAngle","PI","facesProcessed","expectedSolidAngle","correctionFactor","scaleInPlace","convertIncidentRadianceToIrradiance","convertIrradianceToLambertianRadiance","FromHarmonics"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts"],"sourcesContent":["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Scalar.Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Scalar.Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Scalar.Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = 4096;\r\n                    r = Scalar.Clamp(r, 0, max);\r\n                    g = Scalar.Clamp(g, 0, max);\r\n                    b = Scalar.Clamp(b, 0, max);\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}