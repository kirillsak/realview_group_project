{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for an ellipsoid, defaults to a sphere\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * segments sets the number of horizontal strips optional, default 32\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.dedupTopBottomIndices\n * @returns the VertexData of the ellipsoid\n */\nexport function CreateSphereVertexData(options) {\n  const segments = options.segments || 32;\n  const diameterX = options.diameterX || options.diameter || 1;\n  const diameterY = options.diameterY || options.diameter || 1;\n  const diameterZ = options.diameterZ || options.diameter || 1;\n  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n  const slice = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\n  const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n  const totalZRotationSteps = 2 + segments;\n  const totalYRotationSteps = 2 * totalZRotationSteps;\n  const indices = [];\n  const positions = [];\n  const normals = [];\n  const uvs = [];\n  for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    const normalizedZ = zRotationStep / totalZRotationSteps;\n    const angleZ = normalizedZ * Math.PI * slice;\n    for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      const normalizedY = yRotationStep / totalYRotationSteps;\n      const angleY = normalizedY * Math.PI * 2 * arc;\n      const rotationZ = Matrix.RotationZ(-angleZ);\n      const rotationY = Matrix.RotationY(angleY);\n      const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\n      const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\n      const vertex = complete.multiply(radius);\n      const normal = complete.divide(radius).normalize();\n      positions.push(vertex.x, vertex.y, vertex.z);\n      normals.push(normal.x, normal.y, normal.z);\n      uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\n    }\n    if (zRotationStep > 0) {\n      const verticesCount = positions.length / 3;\n      for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        if (dedupTopBottomIndices) {\n          if (zRotationStep > 1) {\n            indices.push(firstIndex);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 1);\n          }\n          if (zRotationStep < totalZRotationSteps || slice < 1.0) {\n            indices.push(firstIndex + totalYRotationSteps + 1);\n            indices.push(firstIndex + 1);\n            indices.push(firstIndex + totalYRotationSteps + 2);\n          }\n        } else {\n          indices.push(firstIndex);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + totalYRotationSteps + 1);\n          indices.push(firstIndex + 1);\n          indices.push(firstIndex + totalYRotationSteps + 2);\n        }\n      }\n    }\n  }\n  // Sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  return vertexData;\n}\n/**\n * Creates a sphere mesh\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.segments\n * @param options.diameter\n * @param options.diameterX\n * @param options.diameterY\n * @param options.diameterZ\n * @param options.arc\n * @param options.slice\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the sphere mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\n */\nexport function CreateSphere(name, options = {}, scene = null) {\n  const sphere = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  sphere._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateSphereVertexData(options);\n  vertexData.applyToMesh(sphere, options.updatable);\n  return sphere;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateSphere directly\n */\nexport const SphereBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateSphere\n};\nVertexData.CreateSphere = CreateSphereVertexData;\nMesh.CreateSphere = (name, segments, diameter, scene, updatable, sideOrientation) => {\n  const options = {\n    segments: segments,\n    diameterX: diameter,\n    diameterY: diameter,\n    diameterZ: diameter,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateSphere(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","Mesh","VertexData","CompatibilityOptions","CreateSphereVertexData","options","segments","diameterX","diameter","diameterY","diameterZ","arc","slice","sideOrientation","DEFAULTSIDE","dedupTopBottomIndices","radius","totalZRotationSteps","totalYRotationSteps","indices","positions","normals","uvs","zRotationStep","normalizedZ","angleZ","Math","PI","yRotationStep","normalizedY","angleY","rotationZ","RotationZ","rotationY","RotationY","afterRotZ","TransformCoordinates","Up","complete","vertex","multiply","normal","divide","normalize","push","x","y","z","UseOpenGLOrientationForUV","verticesCount","length","firstIndex","_ComputeSides","frontUVs","backUVs","vertexData","CreateSphere","name","scene","sphere","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","SphereBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/sphereBuilder.ts"],"sourcesContent":["import type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for an ellipsoid, defaults to a sphere\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * segments sets the number of horizontal strips optional, default 32\r\n * * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1\r\n * * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter\r\n * * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter\r\n * * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter\r\n * * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1\r\n * * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.dedupTopBottomIndices\r\n * @returns the VertexData of the ellipsoid\r\n */\r\nexport function CreateSphereVertexData(options: {\r\n    segments?: number;\r\n    diameter?: number;\r\n    diameterX?: number;\r\n    diameterY?: number;\r\n    diameterZ?: number;\r\n    arc?: number;\r\n    slice?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    dedupTopBottomIndices?: boolean;\r\n}): VertexData {\r\n    const segments: number = options.segments || 32;\r\n    const diameterX: number = options.diameterX || options.diameter || 1;\r\n    const diameterY: number = options.diameterY || options.diameter || 1;\r\n    const diameterZ: number = options.diameterZ || options.diameter || 1;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const slice: number = options.slice && options.slice <= 0 ? 1.0 : options.slice || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n    const dedupTopBottomIndices = !!options.dedupTopBottomIndices;\r\n\r\n    const radius = new Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\r\n\r\n    const totalZRotationSteps = 2 + segments;\r\n    const totalYRotationSteps = 2 * totalZRotationSteps;\r\n\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    for (let zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        const normalizedZ = zRotationStep / totalZRotationSteps;\r\n        const angleZ = normalizedZ * Math.PI * slice;\r\n\r\n        for (let yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            const normalizedY = yRotationStep / totalYRotationSteps;\r\n\r\n            const angleY = normalizedY * Math.PI * 2 * arc;\r\n\r\n            const rotationZ = Matrix.RotationZ(-angleZ);\r\n            const rotationY = Matrix.RotationY(angleY);\r\n            const afterRotZ = Vector3.TransformCoordinates(Vector3.Up(), rotationZ);\r\n            const complete = Vector3.TransformCoordinates(afterRotZ, rotationY);\r\n\r\n            const vertex = complete.multiply(radius);\r\n            const normal = complete.divide(radius).normalize();\r\n\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - normalizedZ : normalizedZ);\r\n        }\r\n\r\n        if (zRotationStep > 0) {\r\n            const verticesCount = positions.length / 3;\r\n            for (let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\r\n                if (dedupTopBottomIndices) {\r\n                    if (zRotationStep > 1) {\r\n                        indices.push(firstIndex);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    }\r\n                    if (zRotationStep < totalZRotationSteps || slice < 1.0) {\r\n                        indices.push(firstIndex + totalYRotationSteps + 1);\r\n                        indices.push(firstIndex + 1);\r\n                        indices.push(firstIndex + totalYRotationSteps + 2);\r\n                    }\r\n                } else {\r\n                    indices.push(firstIndex);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n\r\n                    indices.push(firstIndex + totalYRotationSteps + 1);\r\n                    indices.push(firstIndex + 1);\r\n                    indices.push(firstIndex + totalYRotationSteps + 2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a sphere mesh\r\n * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.segments\r\n * @param options.diameter\r\n * @param options.diameterX\r\n * @param options.diameterY\r\n * @param options.diameterZ\r\n * @param options.arc\r\n * @param options.slice\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the sphere mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#sphere\r\n */\r\nexport function CreateSphere(\r\n    name: string,\r\n    options: {\r\n        segments?: number;\r\n        diameter?: number;\r\n        diameterX?: number;\r\n        diameterY?: number;\r\n        diameterZ?: number;\r\n        arc?: number;\r\n        slice?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const sphere = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateSphereVertexData(options);\r\n\r\n    vertexData.applyToMesh(sphere, options.updatable);\r\n\r\n    return sphere;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateSphere directly\r\n */\r\nexport const SphereBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateSphere,\r\n};\r\n\r\nVertexData.CreateSphere = CreateSphereVertexData;\r\n\r\n(Mesh as any).CreateSphere = (name: string, segments: number, diameter: number, scene?: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateSphere(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}