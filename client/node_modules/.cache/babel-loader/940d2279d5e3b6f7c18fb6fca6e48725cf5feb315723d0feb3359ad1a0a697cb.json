{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nconst NAME = \"KHR_materials_variants\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_variants {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n  }\n  /**\n   * Gets the list of available variant names for this asset.\n   * @param rootMesh The glTF root mesh\n   * @returns the list of all the variant names for this model\n   */\n  static GetAvailableVariants(rootMesh) {\n    const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n    if (!extensionMetadata) {\n      return [];\n    }\n    return Object.keys(extensionMetadata.variants);\n  }\n  /**\n   * Gets the list of available variant names for this asset.\n   * @param rootMesh The glTF root mesh\n   * @returns the list of all the variant names for this model\n   */\n  getAvailableVariants(rootMesh) {\n    return KHR_materials_variants.GetAvailableVariants(rootMesh);\n  }\n  /**\n   * Select a variant given a variant name or a list of variant names.\n   * @param rootMesh The glTF root mesh\n   * @param variantName The variant name(s) to select.\n   */\n  static SelectVariant(rootMesh, variantName) {\n    const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n    if (!extensionMetadata) {\n      throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\n    }\n    const select = variantName => {\n      const entries = extensionMetadata.variants[variantName];\n      if (entries) {\n        for (const entry of entries) {\n          entry.mesh.material = entry.material;\n        }\n      }\n    };\n    if (variantName instanceof Array) {\n      for (const name of variantName) {\n        select(name);\n      }\n    } else {\n      select(variantName);\n    }\n    extensionMetadata.lastSelected = variantName;\n  }\n  /**\n   * Select a variant given a variant name or a list of variant names.\n   * @param rootMesh The glTF root mesh\n   * @param variantName The variant name(s) to select.\n   */\n  selectVariant(rootMesh, variantName) {\n    return KHR_materials_variants.SelectVariant(rootMesh, variantName);\n  }\n  /**\n   * Reset back to the original before selecting a variant.\n   * @param rootMesh The glTF root mesh\n   */\n  static Reset(rootMesh) {\n    const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n    if (!extensionMetadata) {\n      throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\n    }\n    for (const entry of extensionMetadata.original) {\n      entry.mesh.material = entry.material;\n    }\n    extensionMetadata.lastSelected = null;\n  }\n  /**\n   * Reset back to the original before selecting a variant.\n   * @param rootMesh The glTF root mesh\n   */\n  reset(rootMesh) {\n    return KHR_materials_variants.Reset(rootMesh);\n  }\n  /**\n   * Gets the last selected variant name(s) or null if original.\n   * @param rootMesh The glTF root mesh\n   * @returns The selected variant name(s).\n   */\n  static GetLastSelectedVariant(rootMesh) {\n    const extensionMetadata = this._GetExtensionMetadata(rootMesh);\n    if (!extensionMetadata) {\n      throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\n    }\n    return extensionMetadata.lastSelected;\n  }\n  /**\n   * Gets the last selected variant name(s) or null if original.\n   * @param rootMesh The glTF root mesh\n   * @returns The selected variant name(s).\n   */\n  getLastSelectedVariant(rootMesh) {\n    return KHR_materials_variants.GetLastSelectedVariant(rootMesh);\n  }\n  static _GetExtensionMetadata(rootMesh) {\n    var _a, _b;\n    return ((_b = (_a = rootMesh === null || rootMesh === void 0 ? void 0 : rootMesh._internalMetadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME]) || null;\n  }\n  /** @internal */\n  onLoading() {\n    const extensions = this._loader.gltf.extensions;\n    if (extensions && extensions[this.name]) {\n      const extension = extensions[this.name];\n      this._variants = extension.variants;\n    }\n  }\n  /**\n   * @internal\n   */\n  _loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign) {\n    return GLTFLoader.LoadExtensionAsync(context, primitive, this.name, (extensionContext, extension) => {\n      const promises = new Array();\n      promises.push(this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, babylonMesh => {\n        assign(babylonMesh);\n        if (babylonMesh instanceof Mesh) {\n          const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\n          const root = this._loader.rootBabylonMesh;\n          const metadata = root ? root._internalMetadata = root._internalMetadata || {} : {};\n          const gltf = metadata.gltf = metadata.gltf || {};\n          const extensionMetadata = gltf[NAME] = gltf[NAME] || {\n            lastSelected: null,\n            original: [],\n            variants: {}\n          };\n          // Store the original material.\n          extensionMetadata.original.push({\n            mesh: babylonMesh,\n            material: babylonMesh.material\n          });\n          // For each mapping, look at the variants and make a new entry for them.\n          for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\n            const mapping = extension.mappings[mappingIndex];\n            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\n            promises.push(this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, babylonMaterial => {\n              for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\n                const variantIndex = mapping.variants[mappingVariantIndex];\n                const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\n                extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\n                extensionMetadata.variants[variant.name].push({\n                  mesh: babylonMesh,\n                  material: babylonMaterial\n                });\n                // Replace the target when original mesh is cloned\n                babylonMesh.onClonedObservable.add(newOne => {\n                  const newMesh = newOne;\n                  let metadata = null;\n                  let newRoot = newMesh;\n                  // Find root to get medata\n                  do {\n                    newRoot = newRoot.parent;\n                    if (!newRoot) {\n                      return;\n                    }\n                    metadata = KHR_materials_variants._GetExtensionMetadata(newRoot);\n                  } while (metadata === null);\n                  // Need to clone the metadata on the root (first time only)\n                  if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\n                    // Copy main metadata\n                    newRoot._internalMetadata = {};\n                    for (const key in root._internalMetadata) {\n                      newRoot._internalMetadata[key] = root._internalMetadata[key];\n                    }\n                    // Copy the gltf metadata\n                    newRoot._internalMetadata.gltf = [];\n                    for (const key in root._internalMetadata.gltf) {\n                      newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\n                    }\n                    // Duplicate the extension specific metadata\n                    newRoot._internalMetadata.gltf[NAME] = {\n                      lastSelected: null,\n                      original: [],\n                      variants: {}\n                    };\n                    for (const original of metadata.original) {\n                      newRoot._internalMetadata.gltf[NAME].original.push({\n                        mesh: original.mesh,\n                        material: original.material\n                      });\n                    }\n                    for (const key in metadata.variants) {\n                      if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\n                        newRoot._internalMetadata.gltf[NAME].variants[key] = [];\n                        for (const variantEntry of metadata.variants[key]) {\n                          newRoot._internalMetadata.gltf[NAME].variants[key].push({\n                            mesh: variantEntry.mesh,\n                            material: variantEntry.material\n                          });\n                        }\n                      }\n                    }\n                    metadata = newRoot._internalMetadata.gltf[NAME];\n                  }\n                  // Relocate\n                  for (const target of metadata.original) {\n                    if (target.mesh === babylonMesh) {\n                      target.mesh = newMesh;\n                    }\n                  }\n                  for (const target of metadata.variants[variant.name]) {\n                    if (target.mesh === babylonMesh) {\n                      target.mesh = newMesh;\n                    }\n                  }\n                });\n              }\n            }));\n          }\n        }\n      }));\n      return Promise.all(promises).then(([babylonMesh]) => {\n        return babylonMesh;\n      });\n    });\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new KHR_materials_variants(loader));","map":{"version":3,"mappings":"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","names":["GLTFLoader","ArrayItem","Mesh","NAME","KHR_materials_variants","constructor","loader","_loader","enabled","isExtensionUsed","dispose","GetAvailableVariants","rootMesh","extensionMetadata","_GetExtensionMetadata","Object","keys","variants","getAvailableVariants","SelectVariant","variantName","Error","select","entries","entry","mesh","material","Array","name","lastSelected","selectVariant","Reset","original","reset","GetLastSelectedVariant","getLastSelectedVariant","_internalMetadata","gltf","onLoading","extensions","extension","_variants","_loadMeshPrimitiveAsync","context","node","primitive","assign","LoadExtensionAsync","extensionContext","promises","push","babylonMesh","babylonDrawMode","_GetDrawMode","mode","root","rootBabylonMesh","metadata","mappingIndex","mappings","length","mapping","Get","materials","_loadMaterialAsync","babylonMaterial","mappingVariantIndex","variantIndex","variant","onClonedObservable","add","newOne","newMesh","newRoot","parent","key","prototype","hasOwnProperty","call","variantEntry","target","Promise","all","then","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_variants.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootMesh: Mesh): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootMesh: Mesh): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootMesh);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootMesh The glTF root mesh\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootMesh: Mesh, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootMesh The glTF root mesh\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootMesh: Mesh, variantName: string | string[]): void {\r\n        return KHR_materials_variants.SelectVariant(rootMesh, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootMesh The glTF root mesh\r\n     */\r\n    public static Reset(rootMesh: Mesh): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootMesh The glTF root mesh\r\n     */\r\n    public reset(rootMesh: Mesh): void {\r\n        return KHR_materials_variants.Reset(rootMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootMesh);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootMesh The glTF root mesh\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootMesh: Mesh): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootMesh);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootMesh: Nullable<Mesh>): Nullable<IExtensionMetadata> {\r\n        return rootMesh?._internalMetadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot!.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot._internalMetadata = {};\r\n                                                for (const key in root._internalMetadata) {\r\n                                                    newRoot._internalMetadata[key] = root._internalMetadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot._internalMetadata.gltf = [];\r\n                                                for (const key in root._internalMetadata.gltf) {\r\n                                                    newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot._internalMetadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot._internalMetadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot._internalMetadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            return Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_variants(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}