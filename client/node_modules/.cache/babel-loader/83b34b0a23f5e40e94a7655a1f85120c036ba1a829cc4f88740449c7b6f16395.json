{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * A multi-material is used to apply different materials to different parts of the same object without the need of\n * separate meshes. This can be use to improve performances.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\n */\nexport class MultiMaterial extends Material {\n  /**\n   * Instantiates a new Multi Material\n   * A multi-material is used to apply different materials to different parts of the same object without the need of\n   * separate meshes. This can be use to improve performances.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\n   * @param name Define the name in the scene\n   * @param scene Define the scene the material belongs to\n   */\n  constructor(name, scene) {\n    super(name, scene, true);\n    /** @internal */\n    this._waitingSubMaterialsUniqueIds = [];\n    this.getScene().multiMaterials.push(this);\n    this.subMaterials = new Array();\n    this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\n  }\n  /**\n   * Gets or Sets the list of Materials used within the multi material.\n   * They need to be ordered according to the submeshes order in the associated mesh\n   */\n  get subMaterials() {\n    return this._subMaterials;\n  }\n  set subMaterials(value) {\n    this._subMaterials = value;\n    this._hookArray(value);\n  }\n  /**\n   * Function used to align with Node.getChildren()\n   * @returns the list of Materials used within the multi material\n   */\n  getChildren() {\n    return this.subMaterials;\n  }\n  _hookArray(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      this._markAllSubMeshesAsTexturesDirty();\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      this._markAllSubMeshesAsTexturesDirty();\n      return deleted;\n    };\n  }\n  /**\n   * Get one of the submaterial by its index in the submaterials array\n   * @param index The index to look the sub material at\n   * @returns The Material if the index has been defined\n   */\n  getSubMaterial(index) {\n    if (index < 0 || index >= this.subMaterials.length) {\n      return this.getScene().defaultMaterial;\n    }\n    return this.subMaterials[index];\n  }\n  /**\n   * Get the list of active textures for the whole sub materials list.\n   * @returns All the textures that will be used during the rendering\n   */\n  getActiveTextures() {\n    return super.getActiveTextures().concat(...this.subMaterials.map(subMaterial => {\n      if (subMaterial) {\n        return subMaterial.getActiveTextures();\n      } else {\n        return [];\n      }\n    }));\n  }\n  /**\n   * Specifies if any sub-materials of this multi-material use a given texture.\n   * @param texture Defines the texture to check against this multi-material's sub-materials.\n   * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\n   */\n  hasTexture(texture) {\n    var _a;\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    for (let i = 0; i < this.subMaterials.length; i++) {\n      if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Gets the current class name of the material e.g. \"MultiMaterial\"\n   * Mainly use in serialization.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MultiMaterial\";\n  }\n  /**\n   * Checks if the material is ready to render the requested sub mesh\n   * @param mesh Define the mesh the submesh belongs to\n   * @param subMesh Define the sub mesh to look readiness for\n   * @param useInstances Define whether or not the material is used with instances\n   * @returns true if ready, otherwise false\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances) {\n    for (let index = 0; index < this.subMaterials.length; index++) {\n      const subMaterial = this.subMaterials[index];\n      if (subMaterial) {\n        if (subMaterial._storeEffectOnSubMeshes) {\n          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\n            return false;\n          }\n          continue;\n        }\n        if (!subMaterial.isReady(mesh)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Clones the current material and its related sub materials\n   * @param name Define the name of the newly cloned material\n   * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\n   * @returns the cloned material\n   */\n  clone(name, cloneChildren) {\n    const newMultiMaterial = new MultiMaterial(name, this.getScene());\n    for (let index = 0; index < this.subMaterials.length; index++) {\n      let subMaterial = null;\n      const current = this.subMaterials[index];\n      if (cloneChildren && current) {\n        subMaterial = current.clone(name + \"-\" + current.name);\n      } else {\n        subMaterial = this.subMaterials[index];\n      }\n      newMultiMaterial.subMaterials.push(subMaterial);\n    }\n    return newMultiMaterial;\n  }\n  /**\n   * Serializes the materials into a JSON representation.\n   * @returns the JSON representation\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    if (Tags) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    serializationObject.materialsUniqueIds = [];\n    serializationObject.materials = [];\n    for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\n      const subMat = this.subMaterials[matIndex];\n      if (subMat) {\n        serializationObject.materialsUniqueIds.push(subMat.uniqueId);\n        serializationObject.materials.push(subMat.id);\n      } else {\n        serializationObject.materialsUniqueIds.push(null);\n        serializationObject.materials.push(null);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Dispose the material and release its associated resources\n   * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\n   * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\n   * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    if (forceDisposeChildren) {\n      for (let index = 0; index < this.subMaterials.length; index++) {\n        const subMaterial = this.subMaterials[index];\n        if (subMaterial) {\n          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\n        }\n      }\n    }\n    const index = scene.multiMaterials.indexOf(this);\n    if (index >= 0) {\n      scene.multiMaterials.splice(index, 1);\n    }\n    super.dispose(forceDisposeEffect, forceDisposeTextures);\n  }\n  /**\n   * Creates a MultiMaterial from parsed MultiMaterial data.\n   * @param parsedMultiMaterial defines parsed MultiMaterial data.\n   * @param scene defines the hosting scene\n   * @returns a new MultiMaterial\n   */\n  static ParseMultiMaterial(parsedMultiMaterial, scene) {\n    const multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\n    multiMaterial.id = parsedMultiMaterial.id;\n    multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\n    }\n    if (parsedMultiMaterial.materialsUniqueIds) {\n      multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;\n    } else {\n      parsedMultiMaterial.materials.forEach(subMatId => multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId)));\n    }\n    return multiMaterial;\n  }\n}\nRegisterClass(\"BABYLON.MultiMaterial\", MultiMaterial);","map":{"version":3,"mappings":"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","names":["Material","Tags","RegisterClass","MultiMaterial","constructor","name","scene","getScene","multiMaterials","push","subMaterials","Array","_storeEffectOnSubMeshes","_subMaterials","value","_hookArray","getChildren","array","oldPush","items","result","apply","_markAllSubMeshesAsTexturesDirty","oldSplice","splice","index","deleteCount","deleted","getSubMaterial","length","defaultMaterial","getActiveTextures","concat","map","subMaterial","hasTexture","texture","i","getClassName","isReadyForSubMesh","mesh","subMesh","useInstances","isReady","clone","cloneChildren","newMultiMaterial","current","serialize","serializationObject","id","uniqueId","tags","GetTags","materialsUniqueIds","materials","matIndex","subMat","dispose","forceDisposeEffect","forceDisposeTextures","forceDisposeChildren","indexOf","ParseMultiMaterial","parsedMultiMaterial","multiMaterial","_loadedUniqueId","AddTagsTo","_waitingSubMaterialsUniqueIds","forEach","subMatId","getLastMaterialById"],"sourceRoot":"","sources":["../../../../lts/core/generated/Materials/multiMaterial.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\n/**\r\n * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n * separate meshes. This can be use to improve performances.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n */\r\nexport class MultiMaterial extends Material {\r\n    private _subMaterials: Nullable<Material>[];\r\n    /** @internal */\r\n    public _waitingSubMaterialsUniqueIds: string[] = [];\r\n\r\n    /**\r\n     * Gets or Sets the list of Materials used within the multi material.\r\n     * They need to be ordered according to the submeshes order in the associated mesh\r\n     */\r\n    public get subMaterials(): Nullable<Material>[] {\r\n        return this._subMaterials;\r\n    }\r\n\r\n    public set subMaterials(value: Nullable<Material>[]) {\r\n        this._subMaterials = value;\r\n        this._hookArray(value);\r\n    }\r\n\r\n    /**\r\n     * Function used to align with Node.getChildren()\r\n     * @returns the list of Materials used within the multi material\r\n     */\r\n    public getChildren(): Nullable<Material>[] {\r\n        return this.subMaterials;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Multi Material\r\n     * A multi-material is used to apply different materials to different parts of the same object without the need of\r\n     * separate meshes. This can be use to improve performances.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/multiMaterials\r\n     * @param name Define the name in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, true);\r\n\r\n        this.getScene().multiMaterials.push(this);\r\n\r\n        this.subMaterials = new Array<Material>();\r\n\r\n        this._storeEffectOnSubMeshes = true; // multimaterial is considered like a push material\r\n    }\r\n\r\n    private _hookArray(array: Nullable<Material>[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: Nullable<Material>[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            return deleted;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get one of the submaterial by its index in the submaterials array\r\n     * @param index The index to look the sub material at\r\n     * @returns The Material if the index has been defined\r\n     */\r\n    public getSubMaterial(index: number): Nullable<Material> {\r\n        if (index < 0 || index >= this.subMaterials.length) {\r\n            return this.getScene().defaultMaterial;\r\n        }\r\n\r\n        return this.subMaterials[index];\r\n    }\r\n\r\n    /**\r\n     * Get the list of active textures for the whole sub materials list.\r\n     * @returns All the textures that will be used during the rendering\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        return super.getActiveTextures().concat(\r\n            ...this.subMaterials.map((subMaterial) => {\r\n                if (subMaterial) {\r\n                    return subMaterial.getActiveTextures();\r\n                } else {\r\n                    return [];\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Specifies if any sub-materials of this multi-material use a given texture.\r\n     * @param texture Defines the texture to check against this multi-material's sub-materials.\r\n     * @returns A boolean specifying if any sub-material of this multi-material uses the texture.\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (let i = 0; i < this.subMaterials.length; i++) {\r\n            if (this.subMaterials[i]?.hasTexture(texture)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"MultiMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"MultiMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested sub mesh\r\n     * @param mesh Define the mesh the submesh belongs to\r\n     * @param subMesh Define the sub mesh to look readiness for\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        for (let index = 0; index < this.subMaterials.length; index++) {\r\n            const subMaterial = this.subMaterials[index];\r\n            if (subMaterial) {\r\n                if (subMaterial._storeEffectOnSubMeshes) {\r\n                    if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {\r\n                        return false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!subMaterial.isReady(mesh)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones the current material and its related sub materials\r\n     * @param name Define the name of the newly cloned material\r\n     * @param cloneChildren Define if submaterial will be cloned or shared with the parent instance\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string, cloneChildren?: boolean): MultiMaterial {\r\n        const newMultiMaterial = new MultiMaterial(name, this.getScene());\r\n\r\n        for (let index = 0; index < this.subMaterials.length; index++) {\r\n            let subMaterial: Nullable<Material> = null;\r\n            const current = this.subMaterials[index];\r\n            if (cloneChildren && current) {\r\n                subMaterial = current.clone(name + \"-\" + current.name);\r\n            } else {\r\n                subMaterial = this.subMaterials[index];\r\n            }\r\n            newMultiMaterial.subMaterials.push(subMaterial);\r\n        }\r\n\r\n        return newMultiMaterial;\r\n    }\r\n\r\n    /**\r\n     * Serializes the materials into a JSON representation.\r\n     * @returns the JSON representation\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        if (Tags) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n        serializationObject.materialsUniqueIds = [];\r\n        serializationObject.materials = [];\r\n\r\n        for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\r\n            const subMat = this.subMaterials[matIndex];\r\n\r\n            if (subMat) {\r\n                serializationObject.materialsUniqueIds.push(subMat.uniqueId);\r\n                serializationObject.materials.push(subMat.id);\r\n            } else {\r\n                serializationObject.materialsUniqueIds.push(null);\r\n                serializationObject.materials.push(null);\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Dispose the material and release its associated resources\r\n     * @param forceDisposeEffect Define if we want to force disposing the associated effect (if false the shader is not released and could be reuse later on)\r\n     * @param forceDisposeTextures Define if we want to force disposing the associated textures (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     * @param forceDisposeChildren Define if we want to force disposing the associated submaterials (if false, they will not be disposed and can still be use elsewhere in the app)\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, forceDisposeChildren?: boolean): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (forceDisposeChildren) {\r\n            for (let index = 0; index < this.subMaterials.length; index++) {\r\n                const subMaterial = this.subMaterials[index];\r\n                if (subMaterial) {\r\n                    subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);\r\n                }\r\n            }\r\n        }\r\n\r\n        const index = scene.multiMaterials.indexOf(this);\r\n        if (index >= 0) {\r\n            scene.multiMaterials.splice(index, 1);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Creates a MultiMaterial from parsed MultiMaterial data.\r\n     * @param parsedMultiMaterial defines parsed MultiMaterial data.\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MultiMaterial\r\n     */\r\n    public static ParseMultiMaterial(parsedMultiMaterial: any, scene: Scene): MultiMaterial {\r\n        const multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);\r\n\r\n        multiMaterial.id = parsedMultiMaterial.id;\r\n        multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\r\n        }\r\n\r\n        if (parsedMultiMaterial.materialsUniqueIds) {\r\n            multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;\r\n        } else {\r\n            parsedMultiMaterial.materials.forEach((subMatId: string) => multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId)));\r\n        }\r\n\r\n        return multiMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MultiMaterial\", MultiMaterial);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}