{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\n/** @internal */\nexport class WebGPUComputeContext {\n  constructor(device, cacheSampler) {\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this.uniqueId = WebGPUComputeContext._Counter++;\n    this._bindGroupEntries = [];\n    this.clear();\n  }\n  getBindGroups(bindings, computePipeline, bindingsMapping) {\n    if (!bindingsMapping) {\n      throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\n    }\n    if (this._bindGroups.length === 0) {\n      const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\n      for (const key in bindings) {\n        const binding = bindings[key],\n          location = bindingsMapping[key],\n          group = location.group,\n          index = location.binding,\n          type = binding.type,\n          object = binding.object;\n        let indexInGroupEntries = binding.indexInGroupEntries;\n        let entries = this._bindGroupEntries[group];\n        if (!entries) {\n          entries = this._bindGroupEntries[group] = [];\n        }\n        switch (type) {\n          case ComputeBindingType.Sampler:\n            {\n              const sampler = object;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: this._cacheSampler.getSampler(sampler)\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.Texture:\n          case ComputeBindingType.TextureWithoutSampler:\n            {\n              const texture = object;\n              const hardwareTexture = texture._texture._hardwareTexture;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                if (type === ComputeBindingType.Texture) {\n                  entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture);\n                }\n                entries[indexInGroupEntries].resource = hardwareTexture.view;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                if (type === ComputeBindingType.Texture) {\n                  entries.push({\n                    binding: index - 1,\n                    resource: this._cacheSampler.getSampler(texture._texture)\n                  });\n                }\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.view\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.StorageTexture:\n            {\n              const texture = object;\n              const hardwareTexture = texture._texture._hardwareTexture;\n              if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\n                Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\n              }\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: hardwareTexture.viewForWriting\n                });\n              }\n              break;\n            }\n          case ComputeBindingType.UniformBuffer:\n          case ComputeBindingType.StorageBuffer:\n            {\n              const buffer = type === ComputeBindingType.UniformBuffer ? object : object;\n              const dataBuffer = buffer.getBuffer();\n              const webgpuBuffer = dataBuffer.underlyingResource;\n              if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\n                entries[indexInGroupEntries].resource.buffer = webgpuBuffer;\n                entries[indexInGroupEntries].resource.size = dataBuffer.capacity;\n              } else {\n                binding.indexInGroupEntries = entries.length;\n                entries.push({\n                  binding: index,\n                  resource: {\n                    buffer: webgpuBuffer,\n                    offset: 0,\n                    size: dataBuffer.capacity\n                  }\n                });\n              }\n              break;\n            }\n        }\n      }\n      for (let i = 0; i < this._bindGroupEntries.length; ++i) {\n        const entries = this._bindGroupEntries[i];\n        if (!entries) {\n          this._bindGroups[i] = undefined;\n          continue;\n        }\n        this._bindGroups[i] = this._device.createBindGroup({\n          layout: computePipeline.getBindGroupLayout(i),\n          entries\n        });\n      }\n      this._bindGroups.length = this._bindGroupEntries.length;\n    }\n    return this._bindGroups;\n  }\n  clear() {\n    this._bindGroups = [];\n    // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\n  }\n}\n\nWebGPUComputeContext._Counter = 0;","map":{"version":3,"mappings":"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","names":["Logger","ComputeBindingType","WebGPUConstants","WebGPUComputeContext","constructor","device","cacheSampler","_device","_cacheSampler","uniqueId","_Counter","_bindGroupEntries","clear","getBindGroups","bindings","computePipeline","bindingsMapping","Error","_bindGroups","length","bindGroupEntriesExist","key","binding","location","group","index","type","object","indexInGroupEntries","entries","Sampler","sampler","undefined","resource","getSampler","push","Texture","TextureWithoutSampler","texture","hardwareTexture","_texture","_hardwareTexture","view","StorageTexture","textureAdditionalUsages","TextureUsage","StorageBinding","name","viewForWriting","UniformBuffer","StorageBuffer","buffer","dataBuffer","getBuffer","webgpuBuffer","underlyingResource","size","capacity","offset","i","createBindGroup","layout","getBindGroupLayout"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuComputeContext.ts"],"sourcesContent":["import type { StorageBuffer } from \"../../Buffers/storageBuffer\";\r\nimport type { IComputeContext } from \"../../Compute/IComputeContext\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { ComputeBindingList, ComputeBindingMapping } from \"../Extensions/engine.computeShader\";\r\nimport { ComputeBindingType } from \"../Extensions/engine.computeShader\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\n\r\n/** @internal */\r\nexport class WebGPUComputeContext implements IComputeContext {\r\n    private static _Counter = 0;\r\n\r\n    public readonly uniqueId: number;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _bindGroups: GPUBindGroup[];\r\n    private _bindGroupEntries: GPUBindGroupEntry[][];\r\n\r\n    public getBindGroups(bindings: ComputeBindingList, computePipeline: GPUComputePipeline, bindingsMapping?: ComputeBindingMapping): GPUBindGroup[] {\r\n        if (!bindingsMapping) {\r\n            throw new Error(\"WebGPUComputeContext.getBindGroups: bindingsMapping is required until browsers support reflection for wgsl shaders!\");\r\n        }\r\n        if (this._bindGroups.length === 0) {\r\n            const bindGroupEntriesExist = this._bindGroupEntries.length > 0;\r\n            for (const key in bindings) {\r\n                const binding = bindings[key],\r\n                    location = bindingsMapping[key],\r\n                    group = location.group,\r\n                    index = location.binding,\r\n                    type = binding.type,\r\n                    object = binding.object;\r\n                let indexInGroupEntries = binding.indexInGroupEntries;\r\n\r\n                let entries = this._bindGroupEntries[group];\r\n                if (!entries) {\r\n                    entries = this._bindGroupEntries[group] = [];\r\n                }\r\n\r\n                switch (type) {\r\n                    case ComputeBindingType.Sampler: {\r\n                        const sampler = object as TextureSampler;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = this._cacheSampler.getSampler(sampler);\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: this._cacheSampler.getSampler(sampler),\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.Texture:\r\n                    case ComputeBindingType.TextureWithoutSampler: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries[indexInGroupEntries++].resource = this._cacheSampler.getSampler(texture._texture!);\r\n                            }\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.view!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            if (type === ComputeBindingType.Texture) {\r\n                                entries.push({\r\n                                    binding: index - 1,\r\n                                    resource: this._cacheSampler.getSampler(texture._texture!),\r\n                                });\r\n                            }\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.view!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.StorageTexture: {\r\n                        const texture = object as BaseTexture;\r\n                        const hardwareTexture = texture._texture!._hardwareTexture as WebGPUHardwareTexture;\r\n                        if ((hardwareTexture.textureAdditionalUsages & WebGPUConstants.TextureUsage.StorageBinding) === 0) {\r\n                            Logger.Error(`computeDispatch: The texture (name=${texture.name}, uniqueId=${texture.uniqueId}) is not a storage texture!`, 50);\r\n                        }\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            entries[indexInGroupEntries].resource = hardwareTexture.viewForWriting!;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: hardwareTexture.viewForWriting!,\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    case ComputeBindingType.UniformBuffer:\r\n                    case ComputeBindingType.StorageBuffer: {\r\n                        const buffer = type === ComputeBindingType.UniformBuffer ? (object as UniformBuffer) : (object as StorageBuffer);\r\n                        const dataBuffer = buffer.getBuffer()!;\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        if (indexInGroupEntries !== undefined && bindGroupEntriesExist) {\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                            (entries[indexInGroupEntries].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                        } else {\r\n                            binding.indexInGroupEntries = entries.length;\r\n                            entries.push({\r\n                                binding: index,\r\n                                resource: {\r\n                                    buffer: webgpuBuffer,\r\n                                    offset: 0,\r\n                                    size: dataBuffer.capacity,\r\n                                },\r\n                            });\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this._bindGroupEntries.length; ++i) {\r\n                const entries = this._bindGroupEntries[i];\r\n                if (!entries) {\r\n                    this._bindGroups[i] = undefined as any;\r\n                    continue;\r\n                }\r\n                this._bindGroups[i] = this._device.createBindGroup({\r\n                    layout: computePipeline.getBindGroupLayout(i),\r\n                    entries,\r\n                });\r\n            }\r\n\r\n            this._bindGroups.length = this._bindGroupEntries.length;\r\n        }\r\n\r\n        return this._bindGroups;\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this.uniqueId = WebGPUComputeContext._Counter++;\r\n        this._bindGroupEntries = [];\r\n        this.clear();\r\n    }\r\n\r\n    public clear(): void {\r\n        this._bindGroups = [];\r\n        // Don't reset _bindGroupEntries if they have already been created, they are still ok even if we have to clear _bindGroups (the layout of the compute shader can't change once created)\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}