{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators.js\";\nimport { Color3 } from \"../../Maths/math.color.js\";\nimport { MaterialFlags } from \"../materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { TmpVectors } from \"../../Maths/math.vector.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.SUBSURFACE = false;\n    this.SS_REFRACTION = false;\n    this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n    this.SS_TRANSLUCENCY = false;\n    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n    this.SS_SCATTERING = false;\n    this.SS_THICKNESSANDMASK_TEXTURE = false;\n    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n    this.SS_HAS_THICKNESS = false;\n    this.SS_REFRACTIONINTENSITY_TEXTURE = false;\n    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n    this.SS_REFRACTIONMAP_3D = false;\n    this.SS_REFRACTIONMAP_OPPOSITEZ = false;\n    this.SS_LODINREFRACTIONALPHA = false;\n    this.SS_GAMMAREFRACTION = false;\n    this.SS_RGBDREFRACTION = false;\n    this.SS_LINEARSPECULARREFRACTION = false;\n    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n    this.SS_ALBEDOFORREFRACTIONTINT = false;\n    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n    this.SS_USE_THICKNESS_AS_DEPTH = false;\n    this.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n    this.SS_USE_GLTF_TEXTURES = false;\n  }\n}\n/**\n * Plugin that implements the sub surface component of the PBR material\n */\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\n  constructor(material, addToPluginList = true) {\n    super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\n    this._isRefractionEnabled = false;\n    /**\n     * Defines if the refraction is enabled in the material.\n     */\n    this.isRefractionEnabled = false;\n    this._isTranslucencyEnabled = false;\n    /**\n     * Defines if the translucency is enabled in the material.\n     */\n    this.isTranslucencyEnabled = false;\n    this._isScatteringEnabled = false;\n    /**\n     * Defines if the sub surface scattering is enabled in the material.\n     */\n    this.isScatteringEnabled = false;\n    this._scatteringDiffusionProfileIndex = 0;\n    /**\n     * Defines the refraction intensity of the material.\n     * The refraction when enabled replaces the Diffuse part of the material.\n     * The intensity helps transitioning between diffuse and refraction.\n     */\n    this.refractionIntensity = 1;\n    /**\n     * Defines the translucency intensity of the material.\n     * When translucency has been enabled, this defines how much of the \"translucency\"\n     * is added to the diffuse part of the material.\n     */\n    this.translucencyIntensity = 1;\n    /**\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n    this.useAlbedoToTintRefraction = false;\n    /**\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\n     */\n    this.useAlbedoToTintTranslucency = false;\n    this._thicknessTexture = null;\n    /**\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\n     * 0 would mean minimumThickness\n     * 1 would mean maximumThickness\n     * The other channels might be use as a mask to vary the different effects intensity.\n     */\n    this.thicknessTexture = null;\n    this._refractionTexture = null;\n    /**\n     * Defines the texture to use for refraction.\n     */\n    this.refractionTexture = null;\n    /** @internal */\n    this._indexOfRefraction = 1.5;\n    /**\n     * Index of refraction of the material base layer.\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\n     *\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\n     *\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\n     */\n    this.indexOfRefraction = 1.5;\n    this._volumeIndexOfRefraction = -1.0;\n    this._invertRefractionY = false;\n    /**\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\n     */\n    this.invertRefractionY = false;\n    /** @internal */\n    this._linkRefractionWithTransparency = false;\n    /**\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\n     * Materials half opaque for instance using refraction could benefit from this control.\n     */\n    this.linkRefractionWithTransparency = false;\n    /**\n     * Defines the minimum thickness stored in the thickness map.\n     * If no thickness map is defined, this value will be used to simulate thickness.\n     */\n    this.minimumThickness = 0;\n    /**\n     * Defines the maximum thickness stored in the thickness map.\n     */\n    this.maximumThickness = 1;\n    /**\n     * Defines that the thickness should be used as a measure of the depth volume.\n     */\n    this.useThicknessAsDepth = false;\n    /**\n     * Defines the volume tint of the material.\n     * This is used for both translucency and scattering.\n     */\n    this.tintColor = Color3.White();\n    /**\n     * Defines the distance at which the tint color should be found in the media.\n     * This is used for refraction only.\n     */\n    this.tintColorAtDistance = 1;\n    /**\n     * Defines how far each channel transmit through the media.\n     * It is defined as a color to simplify it selection.\n     */\n    this.diffusionDistance = Color3.White();\n    this._useMaskFromThicknessTexture = false;\n    /**\n     * Stores the intensity of the different subsurface effects in the thickness texture.\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     * * the blue channel is the translucency intensity.\n     */\n    this.useMaskFromThicknessTexture = false;\n    this._refractionIntensityTexture = null;\n    /**\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\n     */\n    this.refractionIntensityTexture = null;\n    this._translucencyIntensityTexture = null;\n    /**\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\n     * * the blue channel is the translucency intensity.\n     */\n    this.translucencyIntensityTexture = null;\n    this._useGltfStyleTextures = false;\n    /**\n     * Use channels layout used by glTF:\n     * * thicknessTexture: the green (instead of red) channel is the thickness\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\n     */\n    this.useGltfStyleTextures = false;\n    this._scene = material.getScene();\n    this.registerForExtraEvents = true;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];\n  }\n  /**\n   * Diffusion profile for subsurface scattering.\n   * Useful for better scattering in the skins or foliages.\n   */\n  get scatteringDiffusionProfile() {\n    if (!this._scene.subSurfaceConfiguration) {\n      return null;\n    }\n    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\n  }\n  set scatteringDiffusionProfile(c) {\n    if (!this._scene.enableSubSurfaceForPrePass()) {\n      // Not supported\n      return;\n    }\n    // addDiffusionProfile automatically checks for doubles\n    if (c) {\n      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);\n    }\n  }\n  /**\n   * Index of refraction of the material's volume.\n   * https://en.wikipedia.org/wiki/List_of_refractive_indices\n   *\n   * This ONLY impacts refraction. If not provided or given a non-valid value,\n   * the volume will use the same IOR as the surface.\n   */\n  get volumeIndexOfRefraction() {\n    if (this._volumeIndexOfRefraction >= 1.0) {\n      return this._volumeIndexOfRefraction;\n    }\n    return this._indexOfRefraction;\n  }\n  set volumeIndexOfRefraction(value) {\n    if (value >= 1.0) {\n      this._volumeIndexOfRefraction = value;\n    } else {\n      this._volumeIndexOfRefraction = -1.0;\n    }\n  }\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  /** @internal */\n  _markScenePrePassDirty() {\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n    this._internalMarkScenePrePassDirty();\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n          if (!this._thicknessTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n        const refractionTexture = this._getRefractionTexture(scene);\n        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n          if (!refractionTexture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      defines.SUBSURFACE = false;\n      defines.SS_TRANSLUCENCY = false;\n      defines.SS_SCATTERING = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      return;\n    }\n    if (defines._areTexturesDirty) {\n      defines.SUBSURFACE = true;\n      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_SCATTERING = this._isScatteringEnabled;\n      defines.SS_THICKNESSANDMASK_TEXTURE = false;\n      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\n      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\n      defines.SS_HAS_THICKNESS = false;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\n      defines.SS_USE_GLTF_TEXTURES = false;\n      defines.SS_REFRACTION = false;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\n      defines.SS_REFRACTIONMAP_3D = false;\n      defines.SS_GAMMAREFRACTION = false;\n      defines.SS_RGBDREFRACTION = false;\n      defines.SS_LINEARSPECULARREFRACTION = false;\n      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\n      defines.SS_LODINREFRACTIONALPHA = false;\n      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\n      defines.SS_ALBEDOFORREFRACTIONTINT = false;\n      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\n      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\n      defines.SS_USE_THICKNESS_AS_DEPTH = false;\n      const refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\n      const translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\n      // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\n      const useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\n          }\n          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\n          }\n          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\n          }\n        }\n      }\n      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\n      defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\n      defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\n      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\n      if (this._isRefractionEnabled) {\n        if (scene.texturesEnabled) {\n          const refractionTexture = this._getRefractionTexture(scene);\n          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n            defines.SS_REFRACTION = true;\n            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\n            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\n            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\n            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\n            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\n            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;\n            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\n          }\n        }\n      }\n      if (this._isTranslucencyEnabled) {\n        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\n      }\n    }\n  }\n  /**\n   * Binds the material data (this function is called even if mustRebind() returns false)\n   * @param uniformBuffer defines the Uniform buffer to fill in.\n   * @param scene defines the scene the material belongs to.\n   * @param engine defines the engine the material belongs to.\n   * @param subMesh the submesh to bind data for\n   */\n  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n    subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\n    const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\n    uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\n  }\n  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\n      return;\n    }\n    const defines = subMesh.materialDefines;\n    const isFrozen = this._material.isFrozen;\n    const realTimeFiltering = this._material.realTimeFiltering;\n    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\n    const refractionTexture = this._getRefractionTexture(scene);\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\n        MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\n      }\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\n        MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\n      }\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\n        MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\n      }\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\n        let depth = 1.0;\n        if (!refractionTexture.isCube) {\n          if (refractionTexture.depth) {\n            depth = refractionTexture.depth;\n          }\n        }\n        const width = refractionTexture.getSize().width;\n        const refractionIor = this.volumeIndexOfRefraction;\n        uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\n        uniformBuffer.updateFloat4(\"vRefractionMicrosurfaceInfos\", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1.0 / this.indexOfRefraction);\n        if (realTimeFiltering) {\n          uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\n        }\n        if (refractionTexture.boundingBoxSize) {\n          const cubeTexture = refractionTexture;\n          uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\n          uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\n        }\n      }\n      if (this._isScatteringEnabled) {\n        uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\n      }\n      uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\n      uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\n      uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\n        uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\n      }\n      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\n      }\n      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\n        uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\n      }\n      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\n        if (lodBasedMicrosurface) {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n        } else {\n          uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n          uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n        }\n      }\n    }\n  }\n  /**\n   * Returns the texture used for refraction or null if none is used.\n   * @param scene defines the scene the material belongs to.\n   * @returns - Refraction texture if present.  If no refraction texture and refraction\n   * is linked with transparency, returns environment texture.  Otherwise, returns null.\n   */\n  _getRefractionTexture(scene) {\n    if (this._refractionTexture) {\n      return this._refractionTexture;\n    }\n    if (this._isRefractionEnabled) {\n      return scene.environmentTexture;\n    }\n    return null;\n  }\n  /**\n   * Returns true if alpha blending should be disabled.\n   */\n  get disableAlphaBlending() {\n    return this._isRefractionEnabled && this._linkRefractionWithTransparency;\n  }\n  /**\n   * Fills the list of render target textures.\n   * @param renderTargets the list of render targets to update\n   */\n  fillRenderTargetTextures(renderTargets) {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      renderTargets.push(this._refractionTexture);\n    }\n  }\n  hasTexture(texture) {\n    if (this._thicknessTexture === texture) {\n      return true;\n    }\n    if (this._refractionTexture === texture) {\n      return true;\n    }\n    return false;\n  }\n  hasRenderTargetTextures() {\n    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._thicknessTexture) {\n      activeTextures.push(this._thicknessTexture);\n    }\n    if (this._refractionTexture) {\n      activeTextures.push(this._refractionTexture);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\n      animatables.push(this._thicknessTexture);\n    }\n    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n      animatables.push(this._refractionTexture);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._thicknessTexture) {\n        this._thicknessTexture.dispose();\n      }\n      if (this._refractionTexture) {\n        this._refractionTexture.dispose();\n      }\n    }\n  }\n  getClassName() {\n    return \"PBRSubSurfaceConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.SS_SCATTERING) {\n      fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\n    }\n    if (defines.SS_TRANSLUCENCY) {\n      fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vRefractionMicrosurfaceInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vRefractionFilteringInfo\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vTranslucencyIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionInfos\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"refractionMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vRefractionIntensityInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"thicknessMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"refractionIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"translucencyIntensityMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }, {\n        name: \"vThicknessParam\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"vDiffusionDistance\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vTintColor\",\n        size: 4,\n        type: \"vec4\"\n      }, {\n        name: \"vSubSurfaceIntensity\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionPosition\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vRefractionSize\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"scatteringDiffusionProfile\",\n        size: 1,\n        type: \"float\"\n      }]\n    };\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isRefractionEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"isTranslucencyEnabled\", void 0);\n__decorate([serialize(), expandToProperty(\"_markScenePrePassDirty\")], PBRSubSurfaceConfiguration.prototype, \"isScatteringEnabled\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_scatteringDiffusionProfileIndex\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"refractionIntensity\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensity\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintRefraction\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useAlbedoToTintTranslucency\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"thicknessTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"indexOfRefraction\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"_volumeIndexOfRefraction\", void 0);\n__decorate([expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"volumeIndexOfRefraction\", null);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"invertRefractionY\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"linkRefractionWithTransparency\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"minimumThickness\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"maximumThickness\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"useThicknessAsDepth\", void 0);\n__decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"tintColor\", void 0);\n__decorate([serialize()], PBRSubSurfaceConfiguration.prototype, \"tintColorAtDistance\", void 0);\n__decorate([serializeAsColor3()], PBRSubSurfaceConfiguration.prototype, \"diffusionDistance\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useMaskFromThicknessTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"refractionIntensityTexture\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"translucencyIntensityTexture\", void 0);\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRSubSurfaceConfiguration.prototype, \"useGltfStyleTextures\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsTexture","expandToProperty","serializeAsColor3","Color3","MaterialFlags","MaterialHelper","Scalar","TmpVectors","MaterialPluginBase","MaterialDefines","MaterialSubSurfaceDefines","constructor","PBRSubSurfaceConfiguration","material","addToPluginList","White","_scene","getScene","registerForExtraEvents","_internalMarkAllSubMeshesAsTexturesDirty","_dirtyCallbacks","_internalMarkScenePrePassDirty","scatteringDiffusionProfile","subSurfaceConfiguration","ssDiffusionProfileColors","_scatteringDiffusionProfileIndex","c","enableSubSurfaceForPrePass","addDiffusionProfile","volumeIndexOfRefraction","_volumeIndexOfRefraction","_indexOfRefraction","value","_markAllSubMeshesAsTexturesDirty","_enable","_isRefractionEnabled","_isTranslucencyEnabled","_isScatteringEnabled","_markScenePrePassDirty","isReadyForSubMesh","defines","scene","_areTexturesDirty","texturesEnabled","_thicknessTexture","ThicknessTextureEnabled","isReadyOrNotBlocking","refractionTexture","_getRefractionTexture","RefractionTextureEnabled","prepareDefinesBeforeAttributes","SUBSURFACE","SS_TRANSLUCENCY","SS_SCATTERING","SS_REFRACTION","SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE","SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE","SS_THICKNESSANDMASK_TEXTURE","SS_THICKNESSANDMASK_TEXTUREDIRECTUV","SS_HAS_THICKNESS","SS_REFRACTIONINTENSITY_TEXTURE","SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV","SS_TRANSLUCENCYINTENSITY_TEXTURE","SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV","SS_REFRACTIONMAP_3D","SS_REFRACTIONMAP_OPPOSITEZ","SS_LODINREFRACTIONALPHA","SS_GAMMAREFRACTION","SS_RGBDREFRACTION","SS_LINEARSPECULARREFRACTION","SS_LINKREFRACTIONTOTRANSPARENCY","SS_ALBEDOFORREFRACTIONTINT","SS_ALBEDOFORTRANSLUCENCYTINT","SS_USE_LOCAL_REFRACTIONMAP_CUBIC","SS_USE_THICKNESS_AS_DEPTH","SS_MASK_FROM_THICKNESS_TEXTURE","SS_USE_GLTF_TEXTURES","refractionIntensityTextureIsThicknessTexture","_refractionIntensityTexture","checkTransformsAreIdentical","_texture","translucencyIntensityTextureIsThicknessTexture","_translucencyIntensityTexture","useOnlyThicknessTexture","PrepareDefinesForMergedUV","RefractionIntensityTextureEnabled","TranslucencyIntensityTextureEnabled","maximumThickness","minimumThickness","_useMaskFromThicknessTexture","_useGltfStyleTextures","isCube","gammaSpace","isRGBD","linearSpecularLOD","invertZ","lodLevelInAlpha","_linkRefractionWithTransparency","useAlbedoToTintRefraction","boundingBoxSize","useThicknessAsDepth","useAlbedoToTintTranslucency","hardBindForSubMesh","uniformBuffer","engine","subMesh","getRenderingMesh","getWorldMatrix","decompose","Vector3","thicknessScale","Math","max","abs","x","y","z","updateFloat2","bindForSubMesh","materialDefines","isFrozen","_material","realTimeFiltering","lodBasedMicrosurface","LODBASEDMICROSFURACE","useUbo","isSync","coordinatesIndex","level","BindTextureMatrix","updateMatrix","getReflectionTextureMatrix","depth","width","getSize","refractionIor","updateFloat4","_invertRefractionY","lodGenerationScale","lodGenerationOffset","indexOfRefraction","Log2","cubeTexture","updateVector3","boundingBoxPosition","updateFloat","updateColor3","diffusionDistance","tintColor","r","g","b","tintColorAtDistance","updateFloat3","refractionIntensity","translucencyIntensity","setTexture","_lodTextureMid","_lodTextureLow","_lodTextureHigh","_refractionTexture","environmentTexture","disableAlphaBlending","fillRenderTargetTextures","renderTargets","isRenderTarget","push","hasTexture","texture","hasRenderTargetTextures","getActiveTextures","activeTextures","getAnimatables","animatables","animations","length","dispose","forceDisposeTextures","getClassName","addFallbacks","fallbacks","currentRank","addFallback","getSamplers","samplers","getUniforms","ubo","name","size","type","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/PBR/pbrSubSurfaceConfiguration.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { serialize, serializeAsTexture, expandToProperty, serializeAsColor3 } from \"../../Misc/decorators\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport type { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { CubeTexture } from \"../Textures/cubeTexture\";\r\nimport { TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\ndeclare type Engine = import(\"../../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\ndeclare type PBRBaseMaterial = import(\"./pbrBaseMaterial\").PBRBaseMaterial;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialSubSurfaceDefines extends MaterialDefines {\r\n    public SUBSURFACE = false;\r\n\r\n    public SS_REFRACTION = false;\r\n    public SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_TRANSLUCENCY = false;\r\n    public SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n    public SS_SCATTERING = false;\r\n\r\n    public SS_THICKNESSANDMASK_TEXTURE = false;\r\n    public SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n    public SS_HAS_THICKNESS = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n    public SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n    public SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n\r\n    public SS_REFRACTIONMAP_3D = false;\r\n    public SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n    public SS_LODINREFRACTIONALPHA = false;\r\n    public SS_GAMMAREFRACTION = false;\r\n    public SS_RGBDREFRACTION = false;\r\n    public SS_LINEARSPECULARREFRACTION = false;\r\n    public SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n    public SS_ALBEDOFORREFRACTIONTINT = false;\r\n    public SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n    public SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n    public SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n    public SS_USE_GLTF_TEXTURES = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the sub surface component of the PBR material\r\n */\r\nexport class PBRSubSurfaceConfiguration extends MaterialPluginBase {\r\n    protected _material: PBRBaseMaterial;\r\n\r\n    private _isRefractionEnabled = false;\r\n    /**\r\n     * Defines if the refraction is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isRefractionEnabled = false;\r\n\r\n    private _isTranslucencyEnabled = false;\r\n    /**\r\n     * Defines if the translucency is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isTranslucencyEnabled = false;\r\n\r\n    private _isScatteringEnabled = false;\r\n    /**\r\n     * Defines if the sub surface scattering is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markScenePrePassDirty\")\r\n    public isScatteringEnabled = false;\r\n\r\n    @serialize()\r\n    private _scatteringDiffusionProfileIndex = 0;\r\n\r\n    /**\r\n     * Diffusion profile for subsurface scattering.\r\n     * Useful for better scattering in the skins or foliages.\r\n     */\r\n    public get scatteringDiffusionProfile(): Nullable<Color3> {\r\n        if (!this._scene.subSurfaceConfiguration) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];\r\n    }\r\n\r\n    public set scatteringDiffusionProfile(c: Nullable<Color3>) {\r\n        if (!this._scene.enableSubSurfaceForPrePass()) {\r\n            // Not supported\r\n            return;\r\n        }\r\n\r\n        // addDiffusionProfile automatically checks for doubles\r\n        if (c) {\r\n            this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration!.addDiffusionProfile(c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the refraction intensity of the material.\r\n     * The refraction when enabled replaces the Diffuse part of the material.\r\n     * The intensity helps transitioning between diffuse and refraction.\r\n     */\r\n    @serialize()\r\n    public refractionIntensity: number = 1;\r\n\r\n    /**\r\n     * Defines the translucency intensity of the material.\r\n     * When translucency has been enabled, this defines how much of the \"translucency\"\r\n     * is added to the diffuse part of the material.\r\n     */\r\n    @serialize()\r\n    public translucencyIntensity: number = 1;\r\n\r\n    /**\r\n     * When enabled, transparent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintRefraction: boolean = false;\r\n\r\n    /**\r\n     * When enabled, translucent surfaces will be tinted with the albedo colour (independent of thickness)\r\n     */\r\n    @serialize()\r\n    public useAlbedoToTintTranslucency: boolean = false;\r\n\r\n    private _thicknessTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the average thickness of a mesh in a texture (The texture is holding the values linearly).\r\n     * The red (or green if useGltfStyleTextures=true) channel of the texture should contain the thickness remapped between 0 and 1.\r\n     * 0 would mean minimumThickness\r\n     * 1 would mean maximumThickness\r\n     * The other channels might be use as a mask to vary the different effects intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public thicknessTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Defines the texture to use for refraction.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    public _indexOfRefraction = 1.5;\r\n    /**\r\n     * Index of refraction of the material base layer.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This does not only impact refraction but also the Base F0 of Dielectric Materials.\r\n     *\r\n     * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public indexOfRefraction = 1.5;\r\n\r\n    @serialize()\r\n    private _volumeIndexOfRefraction = -1.0;\r\n\r\n    /**\r\n     * Index of refraction of the material's volume.\r\n     * https://en.wikipedia.org/wiki/List_of_refractive_indices\r\n     *\r\n     * This ONLY impacts refraction. If not provided or given a non-valid value,\r\n     * the volume will use the same IOR as the surface.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public get volumeIndexOfRefraction(): number {\r\n        if (this._volumeIndexOfRefraction >= 1.0) {\r\n            return this._volumeIndexOfRefraction;\r\n        }\r\n        return this._indexOfRefraction;\r\n    }\r\n    public set volumeIndexOfRefraction(value: number) {\r\n        if (value >= 1.0) {\r\n            this._volumeIndexOfRefraction = value;\r\n        } else {\r\n            this._volumeIndexOfRefraction = -1.0;\r\n        }\r\n    }\r\n\r\n    private _invertRefractionY = false;\r\n    /**\r\n     * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertRefractionY = false;\r\n\r\n    /** @internal */\r\n    public _linkRefractionWithTransparency = false;\r\n    /**\r\n     * This parameters will make the material used its opacity to control how much it is refracting against not.\r\n     * Materials half opaque for instance using refraction could benefit from this control.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkRefractionWithTransparency = false;\r\n\r\n    /**\r\n     * Defines the minimum thickness stored in the thickness map.\r\n     * If no thickness map is defined, this value will be used to simulate thickness.\r\n     */\r\n    @serialize()\r\n    public minimumThickness: number = 0;\r\n\r\n    /**\r\n     * Defines the maximum thickness stored in the thickness map.\r\n     */\r\n    @serialize()\r\n    public maximumThickness: number = 1;\r\n\r\n    /**\r\n     * Defines that the thickness should be used as a measure of the depth volume.\r\n     */\r\n    @serialize()\r\n    public useThicknessAsDepth = false;\r\n\r\n    /**\r\n     * Defines the volume tint of the material.\r\n     * This is used for both translucency and scattering.\r\n     */\r\n    @serializeAsColor3()\r\n    public tintColor = Color3.White();\r\n\r\n    /**\r\n     * Defines the distance at which the tint color should be found in the media.\r\n     * This is used for refraction only.\r\n     */\r\n    @serialize()\r\n    public tintColorAtDistance = 1;\r\n\r\n    /**\r\n     * Defines how far each channel transmit through the media.\r\n     * It is defined as a color to simplify it selection.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffusionDistance = Color3.White();\r\n\r\n    private _useMaskFromThicknessTexture = false;\r\n    /**\r\n     * Stores the intensity of the different subsurface effects in the thickness texture.\r\n     * Note that if refractionIntensityTexture and/or translucencyIntensityTexture is provided it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useMaskFromThicknessTexture: boolean = false;\r\n\r\n    private _refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the refraction. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the green (red if useGltfStyleTextures = true) channel is the refraction intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the intensity of the translucency. If provided, it takes precedence over thicknessTexture + useMaskFromThicknessTexture\r\n     * * the blue channel is the translucency intensity.\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public translucencyIntensityTexture: Nullable<BaseTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _useGltfStyleTextures = false;\r\n    /**\r\n     * Use channels layout used by glTF:\r\n     * * thicknessTexture: the green (instead of red) channel is the thickness\r\n     * * thicknessTexture/refractionIntensityTexture: the red (instead of green) channel is the refraction intensity\r\n     * * thicknessTexture/translucencyIntensityTexture: no change, use the blue channel for the translucency intensity\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGltfStyleTextures: boolean = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n    private _internalMarkScenePrePassDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n    /** @internal */\r\n    public _markScenePrePassDirty(): void {\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n        this._internalMarkScenePrePassDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRSubSurface\", 130, new MaterialSubSurfaceDefines(), addToPluginList);\r\n\r\n        this._scene = material.getScene();\r\n        this.registerForExtraEvents = true;\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[Constants.MATERIAL_PrePassDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialSubSurfaceDefines, scene: Scene): boolean {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                    if (!this._thicknessTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                const refractionTexture = this._getRefractionTexture(scene);\r\n                if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                    if (!refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialSubSurfaceDefines, scene: Scene): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            defines.SUBSURFACE = false;\r\n            defines.SS_TRANSLUCENCY = false;\r\n            defines.SS_SCATTERING = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            return;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            defines.SUBSURFACE = true;\r\n\r\n            defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_SCATTERING = this._isScatteringEnabled;\r\n            defines.SS_THICKNESSANDMASK_TEXTURE = false;\r\n            defines.SS_REFRACTIONINTENSITY_TEXTURE = false;\r\n            defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;\r\n            defines.SS_HAS_THICKNESS = false;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;\r\n            defines.SS_USE_GLTF_TEXTURES = false;\r\n            defines.SS_REFRACTION = false;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;\r\n            defines.SS_REFRACTIONMAP_3D = false;\r\n            defines.SS_GAMMAREFRACTION = false;\r\n            defines.SS_RGBDREFRACTION = false;\r\n            defines.SS_LINEARSPECULARREFRACTION = false;\r\n            defines.SS_REFRACTIONMAP_OPPOSITEZ = false;\r\n            defines.SS_LODINREFRACTIONALPHA = false;\r\n            defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;\r\n            defines.SS_ALBEDOFORREFRACTIONTINT = false;\r\n            defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;\r\n            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n            defines.SS_USE_THICKNESS_AS_DEPTH = false;\r\n\r\n            const refractionIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._refractionIntensityTexture &&\r\n                this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._refractionIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            const translucencyIntensityTextureIsThicknessTexture =\r\n                !!this._thicknessTexture &&\r\n                !!this._translucencyIntensityTexture &&\r\n                this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) &&\r\n                this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;\r\n\r\n            // if true, it means the refraction/translucency textures are the same than the thickness texture so there's no need to pass them to the shader, only thicknessTexture\r\n            const useOnlyThicknessTexture =\r\n                (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) &&\r\n                (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, \"SS_THICKNESSANDMASK_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, \"SS_REFRACTIONINTENSITY_TEXTURE\");\r\n                    }\r\n\r\n                    if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, \"SS_TRANSLUCENCYINTENSITY_TEXTURE\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0.0;\r\n            defines.SS_MASK_FROM_THICKNESS_TEXTURE =\r\n                (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;\r\n            defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;\r\n            defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;\r\n\r\n            if (this._isRefractionEnabled) {\r\n                if (scene.texturesEnabled) {\r\n                    const refractionTexture = this._getRefractionTexture(scene);\r\n                    if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                        defines.SS_REFRACTION = true;\r\n                        defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;\r\n                        defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;\r\n                        defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;\r\n                        defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;\r\n                        defines.SS_REFRACTIONMAP_OPPOSITEZ = refractionTexture.invertZ;\r\n                        defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;\r\n                        defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;\r\n                        defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;\r\n                        defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && (<any>refractionTexture).boundingBoxSize;\r\n                        defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this._isTranslucencyEnabled) {\r\n                defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    public hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);\r\n\r\n        const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));\r\n\r\n        uniformBuffer.updateFloat2(\"vThicknessParam\", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {\r\n        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {\r\n            return;\r\n        }\r\n\r\n        const defines = subMesh!.materialDefines as unknown as MaterialSubSurfaceDefines;\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n        const realTimeFiltering = this._material.realTimeFiltering;\r\n        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;\r\n\r\n        const refractionTexture = this._getRefractionTexture(scene);\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vThicknessInfos\", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, \"thickness\");\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vRefractionIntensityInfos\", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, \"refractionIntensity\");\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.updateFloat2(\"vTranslucencyIntensityInfos\", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);\r\n                MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, \"translucencyIntensity\");\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\r\n\r\n                let depth = 1.0;\r\n                if (!refractionTexture.isCube) {\r\n                    if ((<any>refractionTexture).depth) {\r\n                        depth = (<any>refractionTexture).depth;\r\n                    }\r\n                }\r\n\r\n                const width = refractionTexture.getSize().width;\r\n                const refractionIor = this.volumeIndexOfRefraction;\r\n                uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);\r\n                uniformBuffer.updateFloat4(\r\n                    \"vRefractionMicrosurfaceInfos\",\r\n                    width,\r\n                    refractionTexture.lodGenerationScale,\r\n                    refractionTexture.lodGenerationOffset,\r\n                    1.0 / this.indexOfRefraction\r\n                );\r\n\r\n                if (realTimeFiltering) {\r\n                    uniformBuffer.updateFloat2(\"vRefractionFilteringInfo\", width, Scalar.Log2(width));\r\n                }\r\n\r\n                if ((<any>refractionTexture).boundingBoxSize) {\r\n                    const cubeTexture = <CubeTexture>refractionTexture;\r\n\r\n                    uniformBuffer.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                    uniformBuffer.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                }\r\n            }\r\n\r\n            if (this._isScatteringEnabled) {\r\n                uniformBuffer.updateFloat(\"scatteringDiffusionProfile\", this._scatteringDiffusionProfileIndex);\r\n            }\r\n            uniformBuffer.updateColor3(\"vDiffusionDistance\", this.diffusionDistance);\r\n\r\n            uniformBuffer.updateFloat4(\"vTintColor\", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(0.00001, this.tintColorAtDistance));\r\n\r\n            uniformBuffer.updateFloat3(\"vSubSurfaceIntensity\", this.refractionIntensity, this.translucencyIntensity, 0);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {\r\n                uniformBuffer.setTexture(\"thicknessSampler\", this._thicknessTexture);\r\n            }\r\n\r\n            if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"refractionIntensitySampler\", this._refractionIntensityTexture);\r\n            }\r\n\r\n            if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {\r\n                uniformBuffer.setTexture(\"translucencyIntensitySampler\", this._translucencyIntensityTexture);\r\n            }\r\n\r\n            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {\r\n                if (lodBasedMicrosurface) {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\r\n                } else {\r\n                    uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\r\n                    uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for refraction or null if none is used.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @returns - Refraction texture if present.  If no refraction texture and refraction\r\n     * is linked with transparency, returns environment texture.  Otherwise, returns null.\r\n     */\r\n    private _getRefractionTexture(scene: Scene): Nullable<BaseTexture> {\r\n        if (this._refractionTexture) {\r\n            return this._refractionTexture;\r\n        }\r\n\r\n        if (this._isRefractionEnabled) {\r\n            return scene.environmentTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns true if alpha blending should be disabled.\r\n     */\r\n    public get disableAlphaBlending(): boolean {\r\n        return this._isRefractionEnabled && this._linkRefractionWithTransparency;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._thicknessTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._thicknessTexture) {\r\n            activeTextures.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {\r\n            animatables.push(this._thicknessTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            animatables.push(this._refractionTexture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._thicknessTexture) {\r\n                this._thicknessTexture.dispose();\r\n            }\r\n\r\n            if (this._refractionTexture) {\r\n                this._refractionTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRSubSurfaceConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialSubSurfaceDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.SS_SCATTERING) {\r\n            fallbacks.addFallback(currentRank++, \"SS_SCATTERING\");\r\n        }\r\n        if (defines.SS_TRANSLUCENCY) {\r\n            fallbacks.addFallback(currentRank++, \"SS_TRANSLUCENCY\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"thicknessSampler\", \"refractionIntensitySampler\", \"translucencyIntensitySampler\", \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vRefractionMicrosurfaceInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"vRefractionFilteringInfo\", size: 2, type: \"vec2\" },\r\n                { name: \"vTranslucencyIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"refractionMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"vRefractionIntensityInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"thicknessMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"refractionIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"translucencyIntensityMatrix\", size: 16, type: \"mat4\" },\r\n                { name: \"vThicknessParam\", size: 2, type: \"vec2\" },\r\n                { name: \"vDiffusionDistance\", size: 3, type: \"vec3\" },\r\n                { name: \"vTintColor\", size: 4, type: \"vec4\" },\r\n                { name: \"vSubSurfaceIntensity\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionPosition\", size: 3, type: \"vec3\" },\r\n                { name: \"vRefractionSize\", size: 3, type: \"vec3\" },\r\n                { name: \"scatteringDiffusionProfile\", size: 1, type: \"float\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}