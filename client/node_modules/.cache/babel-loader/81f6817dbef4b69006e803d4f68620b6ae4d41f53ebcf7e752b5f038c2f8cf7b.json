{"ast":null,"code":"import { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Vector3, Quaternion } from \"../../Maths/math.vector.js\";\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor.js\";\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder.js\";\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager.js\";\nimport { Logger } from \"../../Misc/logger.js\";\n/**\n * Options for the controller physics feature\n */\nexport class IWebXRControllerPhysicsOptions {}\n/**\n * Add physics impostor to your webxr controllers,\n * including naive calculation of their linear and angular velocity\n */\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\n  /**\n   * Construct a new Controller Physics Feature\n   * @param _xrSessionManager the corresponding xr session manager\n   * @param _options options to create this feature with\n   */\n  constructor(_xrSessionManager, _options) {\n    super(_xrSessionManager);\n    this._options = _options;\n    this._attachController = xrController => {\n      if (this._controllers[xrController.uniqueId]) {\n        // already attached\n        return;\n      }\n      if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\n        Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\n      }\n      // if no motion controller available, create impostors!\n      if (this._options.physicsProperties.useControllerMesh && xrController.inputSource.gamepad) {\n        xrController.onMotionControllerInitObservable.addOnce(motionController => {\n          if (!motionController._doNotLoadControllerMesh) {\n            motionController.onModelLoadedObservable.addOnce(() => {\n              const impostor = new PhysicsImpostor(motionController.rootMesh, PhysicsImpostor.MeshImpostor, {\n                mass: 0,\n                ...this._options.physicsProperties\n              });\n              const controllerMesh = xrController.grip || xrController.pointer;\n              this._controllers[xrController.uniqueId] = {\n                xrController,\n                impostor,\n                oldPos: controllerMesh.position.clone(),\n                oldRotation: controllerMesh.rotationQuaternion.clone()\n              };\n            });\n          } else {\n            // This controller isn't using a model, create impostors instead\n            this._createPhysicsImpostor(xrController);\n          }\n        });\n      } else {\n        this._createPhysicsImpostor(xrController);\n      }\n    };\n    this._controllers = {};\n    this._debugMode = false;\n    this._delta = 0;\n    this._lastTimestamp = 0;\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVector = new Vector3();\n    if (!this._options.physicsProperties) {\n      this._options.physicsProperties = {};\n    }\n  }\n  _createPhysicsImpostor(xrController) {\n    const impostorType = this._options.physicsProperties.impostorType || PhysicsImpostor.SphereImpostor;\n    const impostorSize = this._options.physicsProperties.impostorSize || 0.1;\n    const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\n      diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n      diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n      diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n    });\n    impostorMesh.isVisible = this._debugMode;\n    impostorMesh.isPickable = false;\n    impostorMesh.rotationQuaternion = new Quaternion();\n    const controllerMesh = xrController.grip || xrController.pointer;\n    impostorMesh.position.copyFrom(controllerMesh.position);\n    impostorMesh.rotationQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n    const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\n      mass: 0,\n      ...this._options.physicsProperties\n    });\n    this._controllers[xrController.uniqueId] = {\n      xrController,\n      impostor,\n      impostorMesh\n    };\n  }\n  /**\n   * @internal\n   * enable debugging - will show console outputs and the impostor mesh\n   */\n  _enablePhysicsDebug() {\n    this._debugMode = true;\n    Object.keys(this._controllers).forEach(controllerId => {\n      const controllerData = this._controllers[controllerId];\n      if (controllerData.impostorMesh) {\n        controllerData.impostorMesh.isVisible = true;\n      }\n    });\n  }\n  /**\n   * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\n   * @param xrController the controller to add\n   */\n  addController(xrController) {\n    this._attachController(xrController);\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    if (!this._options.xrInput) {\n      return true;\n    }\n    this._options.xrInput.controllers.forEach(this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\n    this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, controller => {\n      // REMOVE the controller\n      this._detachController(controller.uniqueId);\n    });\n    if (this._options.enableHeadsetImpostor) {\n      const params = this._options.headsetImpostorParams || {\n        impostorType: PhysicsImpostor.SphereImpostor,\n        restitution: 0.8,\n        impostorSize: 0.3\n      };\n      const impostorSize = params.impostorSize || 0.3;\n      this._headsetMesh = CreateSphere(\"headset-mesh\", {\n        diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\n        diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\n        diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth\n      });\n      this._headsetMesh.rotationQuaternion = new Quaternion();\n      this._headsetMesh.isVisible = false;\n      this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, {\n        mass: 0,\n        ...params\n      });\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      this._detachController(controllerId);\n    });\n    if (this._headsetMesh) {\n      this._headsetMesh.dispose();\n    }\n    return true;\n  }\n  /**\n   * Get the headset impostor, if enabled\n   * @returns the impostor\n   */\n  getHeadsetImpostor() {\n    return this._headsetImpostor;\n  }\n  /**\n   * Get the physics impostor of a specific controller.\n   * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\n   * @param controller the controller or the controller id of which to get the impostor\n   * @returns the impostor or null\n   */\n  getImpostorForController(controller) {\n    const id = typeof controller === \"string\" ? controller : controller.uniqueId;\n    if (this._controllers[id]) {\n      return this._controllers[id].impostor;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Update the physics properties provided in the constructor\n   * @param newProperties the new properties object\n   * @param newProperties.impostorType\n   * @param newProperties.impostorSize\n   * @param newProperties.friction\n   * @param newProperties.restitution\n   */\n  setPhysicsProperties(newProperties) {\n    this._options.physicsProperties = {\n      ...this._options.physicsProperties,\n      ...newProperties\n    };\n  }\n  _onXRFrame(_xrFrame) {\n    var _a, _b;\n    this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\n    this._lastTimestamp = this._xrSessionManager.currentTimestamp;\n    if (this._headsetMesh && this._headsetImpostor) {\n      this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\n      this._headsetMesh.rotationQuaternion.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\n      if ((_a = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n        const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n        this._headsetImpostor.setLinearVelocity(this._tmpVector);\n      }\n      if ((_b = this._options.xrInput.xrCamera._lastXRViewerPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n        const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\n        this._tmpVector.set(av.x, av.y, av.z);\n        this._headsetImpostor.setAngularVelocity(this._tmpVector);\n      }\n    }\n    Object.keys(this._controllers).forEach(controllerId => {\n      var _a, _b;\n      const controllerData = this._controllers[controllerId];\n      const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\n      const comparedPosition = controllerData.oldPos || controllerData.impostorMesh.position;\n      if ((_a = controllerData.xrController._lastXRPose) === null || _a === void 0 ? void 0 : _a.linearVelocity) {\n        const lv = controllerData.xrController._lastXRPose.linearVelocity;\n        this._tmpVector.set(lv.x, lv.y, lv.z);\n        controllerData.impostor.setLinearVelocity(this._tmpVector);\n      } else {\n        controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\n        this._tmpVector.scaleInPlace(1000 / this._delta);\n        controllerData.impostor.setLinearVelocity(this._tmpVector);\n      }\n      comparedPosition.copyFrom(controllerMesh.position);\n      if (this._debugMode) {\n        console.log(this._tmpVector, \"linear\");\n      }\n      const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh.rotationQuaternion;\n      if ((_b = controllerData.xrController._lastXRPose) === null || _b === void 0 ? void 0 : _b.angularVelocity) {\n        const av = controllerData.xrController._lastXRPose.angularVelocity;\n        this._tmpVector.set(av.x, av.y, av.z);\n        controllerData.impostor.setAngularVelocity(this._tmpVector);\n      } else {\n        if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion)) {\n          // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\n          comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion, this._tmpQuaternion);\n          const len = Math.sqrt(this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z);\n          this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\n          // define a better epsilon\n          if (len < 0.001) {\n            this._tmpVector.scaleInPlace(2);\n          } else {\n            const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\n            this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\n          }\n          controllerData.impostor.setAngularVelocity(this._tmpVector);\n        }\n      }\n      comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion);\n      if (this._debugMode) {\n        console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\n      }\n    });\n  }\n  _detachController(xrControllerUniqueId) {\n    const controllerData = this._controllers[xrControllerUniqueId];\n    if (!controllerData) {\n      return;\n    }\n    if (controllerData.impostorMesh) {\n      controllerData.impostorMesh.dispose();\n    }\n    // remove from the map\n    delete this._controllers[xrControllerUniqueId];\n  }\n}\n/**\n * The module's name\n */\nWebXRControllerPhysics.Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the webxr specs version\n */\nWebXRControllerPhysics.Version = 1;\n//register the plugin\nWebXRFeaturesManager.AddWebXRFeature(WebXRControllerPhysics.Name, (xrSessionManager, options) => {\n  return () => new WebXRControllerPhysics(xrSessionManager, options);\n}, WebXRControllerPhysics.Version, true);","map":{"version":3,"mappings":"AAAA,SAASA,oBAAoB,QAAQ,2BAAyB;AAC9D,SAASC,OAAO,EAAEC,UAAU,QAAQ,4BAA0B;AAE9D,SAASC,eAAe,QAAQ,qCAAmC;AAInE,SAASC,YAAY,QAAQ,wCAAsC;AACnE,SAASC,gBAAgB,EAAEC,oBAAoB,QAAQ,4BAA0B;AACjF,SAASC,MAAM,QAAQ,sBAAoB;AAG3C;;;AAGA,OAAM,MAAOC,8BAA8B;AA0D3C;;;;AAIA,OAAM,MAAOC,sBAAuB,SAAQT,oBAAoB;EA2F5D;;;;;EAKAU,YAAYC,iBAAsC,EAAmBC,QAAwC;IACzG,KAAK,CAACD,iBAAiB,CAAC;IADyC,aAAQ,GAARC,QAAQ;IA/FrE,sBAAiB,GAAIC,YAA8B,IAAI;MAC3D,IAAI,IAAI,CAACC,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC,EAAE;QAC1C;QACA;;MAEJ,IAAI,CAAC,IAAI,CAACJ,iBAAiB,CAACK,KAAK,CAACC,gBAAgB,EAAE,EAAE;QAClDV,MAAM,CAACW,IAAI,CAAC,2EAA2E,CAAC;;MAE5F;MACA,IAAI,IAAI,CAACN,QAAQ,CAACO,iBAAkB,CAACC,iBAAiB,IAAIP,YAAY,CAACQ,WAAW,CAACC,OAAO,EAAE;QACxFT,YAAY,CAACU,gCAAgC,CAACC,OAAO,CAAEC,gBAAgB,IAAI;UACvE,IAAI,CAACA,gBAAgB,CAACC,wBAAwB,EAAE;YAC5CD,gBAAgB,CAACE,uBAAuB,CAACH,OAAO,CAAC,MAAK;cAClD,MAAMI,QAAQ,GAAG,IAAIzB,eAAe,CAACsB,gBAAgB,CAACI,QAAS,EAAE1B,eAAe,CAAC2B,YAAY,EAAE;gBAC3FC,IAAI,EAAE,CAAC;gBACP,GAAG,IAAI,CAACnB,QAAQ,CAACO;eACpB,CAAC;cAEF,MAAMa,cAAc,GAAGnB,YAAY,CAACoB,IAAI,IAAIpB,YAAY,CAACqB,OAAO;cAChE,IAAI,CAACpB,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC,GAAG;gBACvCF,YAAY;gBACZe,QAAQ;gBACRO,MAAM,EAAEH,cAAc,CAACI,QAAQ,CAACC,KAAK,EAAE;gBACvCC,WAAW,EAAEN,cAAc,CAACO,kBAAmB,CAACF,KAAK;eACxD;YACL,CAAC,CAAC;WACL,MAAM;YACH;YACA,IAAI,CAACG,sBAAsB,CAAC3B,YAAY,CAAC;;QAEjD,CAAC,CAAC;OACL,MAAM;QACH,IAAI,CAAC2B,sBAAsB,CAAC3B,YAAY,CAAC;;IAEjD,CAAC;IA2BO,iBAAY,GAShB,EAAE;IACE,eAAU,GAAG,KAAK;IAClB,WAAM,GAAW,CAAC;IAGlB,mBAAc,GAAW,CAAC;IAC1B,mBAAc,GAAe,IAAIX,UAAU,EAAE;IAC7C,eAAU,GAAY,IAAID,OAAO,EAAE;IAoBvC,IAAI,CAAC,IAAI,CAACW,QAAQ,CAACO,iBAAiB,EAAE;MAClC,IAAI,CAACP,QAAQ,CAACO,iBAAiB,GAAG,EAAE;;EAE5C;EAhEQqB,sBAAsB,CAAC3B,YAA8B;IACzD,MAAM4B,YAAY,GAAW,IAAI,CAAC7B,QAAQ,CAACO,iBAAkB,CAACsB,YAAY,IAAItC,eAAe,CAACuC,cAAc;IAC5G,MAAMC,YAAY,GAA8D,IAAI,CAAC/B,QAAQ,CAACO,iBAAkB,CAACwB,YAAY,IAAI,GAAG;IACpI,MAAMC,YAAY,GAAGxC,YAAY,CAAC,gBAAgB,GAAGS,YAAY,CAACE,QAAQ,EAAE;MACxE8B,SAAS,EAAE,OAAOF,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACG,KAAK;MAC/EC,SAAS,EAAE,OAAOJ,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACK,MAAM;MAChFC,SAAS,EAAE,OAAON,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACO;KAC7E,CAAC;IACFN,YAAY,CAACO,SAAS,GAAG,IAAI,CAACC,UAAU;IACxCR,YAAY,CAACS,UAAU,GAAG,KAAK;IAC/BT,YAAY,CAACL,kBAAkB,GAAG,IAAIrC,UAAU,EAAE;IAClD,MAAM8B,cAAc,GAAGnB,YAAY,CAACoB,IAAI,IAAIpB,YAAY,CAACqB,OAAO;IAChEU,YAAY,CAACR,QAAQ,CAACkB,QAAQ,CAACtB,cAAc,CAACI,QAAQ,CAAC;IACvDQ,YAAY,CAACL,kBAAmB,CAACe,QAAQ,CAACtB,cAAc,CAACO,kBAAmB,CAAC;IAC7E,MAAMX,QAAQ,GAAG,IAAIzB,eAAe,CAACyC,YAAY,EAAEH,YAAY,EAAE;MAC7DV,IAAI,EAAE,CAAC;MACP,GAAG,IAAI,CAACnB,QAAQ,CAACO;KACpB,CAAC;IACF,IAAI,CAACL,YAAY,CAACD,YAAY,CAACE,QAAQ,CAAC,GAAG;MACvCF,YAAY;MACZe,QAAQ;MACRgB;KACH;EACL;EA2CA;;;;EAIOW,mBAAmB;IACtB,IAAI,CAACH,UAAU,GAAG,IAAI;IACtBI,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC3C,YAAY,CAAC,CAAC4C,OAAO,CAAEC,YAAY,IAAI;MACpD,MAAMC,cAAc,GAAG,IAAI,CAAC9C,YAAY,CAAC6C,YAAY,CAAC;MACtD,IAAIC,cAAc,CAAChB,YAAY,EAAE;QAC7BgB,cAAc,CAAChB,YAAY,CAACO,SAAS,GAAG,IAAI;;IAEpD,CAAC,CAAC;EACN;EAEA;;;;EAIOU,aAAa,CAAChD,YAA8B;IAC/C,IAAI,CAACiD,iBAAiB,CAACjD,YAAY,CAAC;EACxC;EAEA;;;;;;EAMOkD,MAAM;IACT,IAAI,CAAC,KAAK,CAACA,MAAM,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhB,IAAI,CAAC,IAAI,CAACnD,QAAQ,CAACoD,OAAO,EAAE;MACxB,OAAO,IAAI;;IAGf,IAAI,CAACpD,QAAQ,CAACoD,OAAO,CAACC,WAAW,CAACP,OAAO,CAAC,IAAI,CAACI,iBAAiB,CAAC;IACjE,IAAI,CAACI,qBAAqB,CAAC,IAAI,CAACtD,QAAQ,CAACoD,OAAO,CAACG,2BAA2B,EAAE,IAAI,CAACL,iBAAiB,CAAC;IACrG,IAAI,CAACI,qBAAqB,CAAC,IAAI,CAACtD,QAAQ,CAACoD,OAAO,CAACI,6BAA6B,EAAGC,UAAU,IAAI;MAC3F;MACA,IAAI,CAACC,iBAAiB,CAACD,UAAU,CAACtD,QAAQ,CAAC;IAC/C,CAAC,CAAC;IAEF,IAAI,IAAI,CAACH,QAAQ,CAAC2D,qBAAqB,EAAE;MACrC,MAAMC,MAAM,GAAG,IAAI,CAAC5D,QAAQ,CAAC6D,qBAAqB,IAAI;QAClDhC,YAAY,EAAEtC,eAAe,CAACuC,cAAc;QAC5CgC,WAAW,EAAE,GAAG;QAChB/B,YAAY,EAAE;OACjB;MACD,MAAMA,YAAY,GAAG6B,MAAM,CAAC7B,YAAY,IAAI,GAAG;MAC/C,IAAI,CAACgC,YAAY,GAAGvE,YAAY,CAAC,cAAc,EAAE;QAC7CyC,SAAS,EAAE,OAAOF,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACG,KAAK;QAC/EC,SAAS,EAAE,OAAOJ,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACK,MAAM;QAChFC,SAAS,EAAE,OAAON,YAAY,KAAK,QAAQ,GAAGA,YAAY,GAAGA,YAAY,CAACO;OAC7E,CAAC;MACF,IAAI,CAACyB,YAAY,CAACpC,kBAAkB,GAAG,IAAIrC,UAAU,EAAE;MACvD,IAAI,CAACyE,YAAY,CAACxB,SAAS,GAAG,KAAK;MACnC,IAAI,CAACyB,gBAAgB,GAAG,IAAIzE,eAAe,CAAC,IAAI,CAACwE,YAAY,EAAEH,MAAM,CAAC/B,YAAY,EAAE;QAAEV,IAAI,EAAE,CAAC;QAAE,GAAGyC;MAAM,CAAE,CAAC;;IAG/G,OAAO,IAAI;EACf;EAEA;;;;;;EAMOK,MAAM;IACT,IAAI,CAAC,KAAK,CAACA,MAAM,EAAE,EAAE;MACjB,OAAO,KAAK;;IAGhBrB,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC3C,YAAY,CAAC,CAAC4C,OAAO,CAAEC,YAAY,IAAI;MACpD,IAAI,CAACW,iBAAiB,CAACX,YAAY,CAAC;IACxC,CAAC,CAAC;IAEF,IAAI,IAAI,CAACgB,YAAY,EAAE;MACnB,IAAI,CAACA,YAAY,CAACG,OAAO,EAAE;;IAG/B,OAAO,IAAI;EACf;EAEA;;;;EAIOC,kBAAkB;IACrB,OAAO,IAAI,CAACH,gBAAgB;EAChC;EAEA;;;;;;EAMOI,wBAAwB,CAACX,UAAqC;IACjE,MAAMY,EAAE,GAAG,OAAOZ,UAAU,KAAK,QAAQ,GAAGA,UAAU,GAAGA,UAAU,CAACtD,QAAQ;IAC5E,IAAI,IAAI,CAACD,YAAY,CAACmE,EAAE,CAAC,EAAE;MACvB,OAAO,IAAI,CAACnE,YAAY,CAACmE,EAAE,CAAC,CAACrD,QAAQ;KACxC,MAAM;MACH,OAAO,IAAI;;EAEnB;EAEA;;;;;;;;EAQOsD,oBAAoB,CAACC,aAK3B;IACG,IAAI,CAACvE,QAAQ,CAACO,iBAAiB,GAAG;MAC9B,GAAG,IAAI,CAACP,QAAQ,CAACO,iBAAiB;MAClC,GAAGgE;KACN;EACL;EAEUC,UAAU,CAACC,QAAa;;IAC9B,IAAI,CAACC,MAAM,GAAG,IAAI,CAAC3E,iBAAiB,CAAC4E,gBAAgB,GAAG,IAAI,CAACC,cAAc;IAC3E,IAAI,CAACA,cAAc,GAAG,IAAI,CAAC7E,iBAAiB,CAAC4E,gBAAgB;IAC7D,IAAI,IAAI,CAACZ,YAAY,IAAI,IAAI,CAACC,gBAAgB,EAAE;MAC5C,IAAI,CAACD,YAAY,CAACvC,QAAQ,CAACkB,QAAQ,CAAC,IAAI,CAAC1C,QAAQ,CAACoD,OAAO,CAACyB,QAAQ,CAACC,cAAc,CAAC;MAClF,IAAI,CAACf,YAAY,CAACpC,kBAAmB,CAACe,QAAQ,CAAC,IAAI,CAAC1C,QAAQ,CAACoD,OAAO,CAACyB,QAAQ,CAACE,gBAAgB,CAAC;MAC/F,IAAI,UAAI,CAAC/E,QAAQ,CAACoD,OAAO,CAACyB,QAAQ,CAACG,iBAAiB,0CAAEC,cAAc,EAAE;QAClE,MAAMC,EAAE,GAAG,IAAI,CAAClF,QAAQ,CAACoD,OAAO,CAACyB,QAAQ,CAACG,iBAAiB,CAACC,cAAc;QAC1E,IAAI,CAACE,UAAU,CAACC,GAAG,CAACF,EAAE,CAACG,CAAC,EAAEH,EAAE,CAACI,CAAC,EAAEJ,EAAE,CAACK,CAAC,CAAC;QACrC,IAAI,CAACvB,gBAAgB,CAACwB,iBAAiB,CAAC,IAAI,CAACL,UAAU,CAAC;;MAE5D,IAAI,UAAI,CAACnF,QAAQ,CAACoD,OAAO,CAACyB,QAAQ,CAACG,iBAAiB,0CAAES,eAAe,EAAE;QACnE,MAAMC,EAAE,GAAG,IAAI,CAAC1F,QAAQ,CAACoD,OAAO,CAACyB,QAAQ,CAACG,iBAAiB,CAACS,eAAe;QAC3E,IAAI,CAACN,UAAU,CAACC,GAAG,CAACM,EAAE,CAACL,CAAC,EAAEK,EAAE,CAACJ,CAAC,EAAEI,EAAE,CAACH,CAAC,CAAC;QACrC,IAAI,CAACvB,gBAAgB,CAAC2B,kBAAkB,CAAC,IAAI,CAACR,UAAU,CAAC;;;IAGjEvC,MAAM,CAACC,IAAI,CAAC,IAAI,CAAC3C,YAAY,CAAC,CAAC4C,OAAO,CAAEC,YAAY,IAAI;;MACpD,MAAMC,cAAc,GAAG,IAAI,CAAC9C,YAAY,CAAC6C,YAAY,CAAC;MACtD,MAAM3B,cAAc,GAAG4B,cAAc,CAAC/C,YAAY,CAACoB,IAAI,IAAI2B,cAAc,CAAC/C,YAAY,CAACqB,OAAO;MAC9F,MAAMsE,gBAAgB,GAAG5C,cAAc,CAACzB,MAAM,IAAIyB,cAAc,CAAChB,YAAa,CAACR,QAAQ;MACvF,IAAI,oBAAc,CAACvB,YAAY,CAAC4F,WAAW,0CAAEZ,cAAc,EAAE;QACzD,MAAMC,EAAE,GAAGlC,cAAc,CAAC/C,YAAY,CAAC4F,WAAW,CAACZ,cAAc;QACjE,IAAI,CAACE,UAAU,CAACC,GAAG,CAACF,EAAE,CAACG,CAAC,EAAEH,EAAE,CAACI,CAAC,EAAEJ,EAAE,CAACK,CAAC,CAAC;QACrCvC,cAAc,CAAChC,QAAQ,CAACwE,iBAAiB,CAAC,IAAI,CAACL,UAAU,CAAC;OAC7D,MAAM;QACH/D,cAAc,CAACI,QAAQ,CAACsE,aAAa,CAACF,gBAAgB,EAAE,IAAI,CAACT,UAAU,CAAC;QACxE,IAAI,CAACA,UAAU,CAACY,YAAY,CAAC,IAAI,GAAG,IAAI,CAACrB,MAAM,CAAC;QAChD1B,cAAc,CAAChC,QAAQ,CAACwE,iBAAiB,CAAC,IAAI,CAACL,UAAU,CAAC;;MAE9DS,gBAAgB,CAAClD,QAAQ,CAACtB,cAAc,CAACI,QAAQ,CAAC;MAClD,IAAI,IAAI,CAACgB,UAAU,EAAE;QACjBwD,OAAO,CAACC,GAAG,CAAC,IAAI,CAACd,UAAU,EAAE,QAAQ,CAAC;;MAG1C,MAAMe,kBAAkB,GAAGlD,cAAc,CAACtB,WAAW,IAAIsB,cAAc,CAAChB,YAAa,CAACL,kBAAmB;MACzG,IAAI,oBAAc,CAAC1B,YAAY,CAAC4F,WAAW,0CAAEJ,eAAe,EAAE;QAC1D,MAAMC,EAAE,GAAG1C,cAAc,CAAC/C,YAAY,CAAC4F,WAAW,CAACJ,eAAe;QAClE,IAAI,CAACN,UAAU,CAACC,GAAG,CAACM,EAAE,CAACL,CAAC,EAAEK,EAAE,CAACJ,CAAC,EAAEI,EAAE,CAACH,CAAC,CAAC;QACrCvC,cAAc,CAAChC,QAAQ,CAAC2E,kBAAkB,CAAC,IAAI,CAACR,UAAU,CAAC;OAC9D,MAAM;QACH,IAAI,CAACe,kBAAkB,CAACC,iBAAiB,CAAC/E,cAAc,CAACO,kBAAmB,CAAC,EAAE;UAC3E;UACAuE,kBAAkB,CAACE,gBAAgB,EAAE,CAACC,aAAa,CAACjF,cAAc,CAACO,kBAAmB,EAAE,IAAI,CAAC2E,cAAc,CAAC;UAC5G,MAAMC,GAAG,GAAGC,IAAI,CAACC,IAAI,CACjB,IAAI,CAACH,cAAc,CAACjB,CAAC,GAAG,IAAI,CAACiB,cAAc,CAACjB,CAAC,GAAG,IAAI,CAACiB,cAAc,CAAChB,CAAC,GAAG,IAAI,CAACgB,cAAc,CAAChB,CAAC,GAAG,IAAI,CAACgB,cAAc,CAACf,CAAC,GAAG,IAAI,CAACe,cAAc,CAACf,CAAC,CAChJ;UACD,IAAI,CAACJ,UAAU,CAACC,GAAG,CAAC,IAAI,CAACkB,cAAc,CAACjB,CAAC,EAAE,IAAI,CAACiB,cAAc,CAAChB,CAAC,EAAE,IAAI,CAACgB,cAAc,CAACf,CAAC,CAAC;UACxF;UACA,IAAIgB,GAAG,GAAG,KAAK,EAAE;YACb,IAAI,CAACpB,UAAU,CAACY,YAAY,CAAC,CAAC,CAAC;WAClC,MAAM;YACH,MAAMW,KAAK,GAAG,CAAC,GAAGF,IAAI,CAACG,KAAK,CAACJ,GAAG,EAAE,IAAI,CAACD,cAAc,CAACM,CAAC,CAAC;YACxD,IAAI,CAACzB,UAAU,CAACY,YAAY,CAACW,KAAK,IAAIH,GAAG,IAAI,IAAI,CAAC7B,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC;;UAEtE1B,cAAc,CAAChC,QAAQ,CAAC2E,kBAAkB,CAAC,IAAI,CAACR,UAAU,CAAC;;;MAGnEe,kBAAkB,CAACxD,QAAQ,CAACtB,cAAc,CAACO,kBAAmB,CAAC;MAC/D,IAAI,IAAI,CAACa,UAAU,EAAE;QACjBwD,OAAO,CAACC,GAAG,CAAC,IAAI,CAACd,UAAU,EAAE,IAAI,CAACmB,cAAc,EAAE,SAAS,CAAC;;IAEpE,CAAC,CAAC;EACN;EAEQ5C,iBAAiB,CAACmD,oBAA4B;IAClD,MAAM7D,cAAc,GAAG,IAAI,CAAC9C,YAAY,CAAC2G,oBAAoB,CAAC;IAC9D,IAAI,CAAC7D,cAAc,EAAE;MACjB;;IAEJ,IAAIA,cAAc,CAAChB,YAAY,EAAE;MAC7BgB,cAAc,CAAChB,YAAY,CAACkC,OAAO,EAAE;;IAEzC;IACA,OAAO,IAAI,CAAChE,YAAY,CAAC2G,oBAAoB,CAAC;EAClD;;AAnOA;;;AAGuBhH,2BAAI,GAAGJ,gBAAgB,CAACqH,mBAAmB;AAClE;;;;;AAKuBjH,8BAAO,GAAG,CAAC;AA6NtC;AACAH,oBAAoB,CAACqH,eAAe,CAChClH,sBAAsB,CAACmH,IAAI,EAC3B,CAACC,gBAAgB,EAAEC,OAAO,KAAI;EAC1B,OAAO,MAAM,IAAIrH,sBAAsB,CAACoH,gBAAgB,EAAEC,OAAO,CAAC;AACtE,CAAC,EACDrH,sBAAsB,CAACsH,OAAO,EAC9B,IAAI,CACP","names":["WebXRAbstractFeature","Vector3","Quaternion","PhysicsImpostor","CreateSphere","WebXRFeatureName","WebXRFeaturesManager","Logger","IWebXRControllerPhysicsOptions","WebXRControllerPhysics","constructor","_xrSessionManager","_options","xrController","_controllers","uniqueId","scene","isPhysicsEnabled","Warn","physicsProperties","useControllerMesh","inputSource","gamepad","onMotionControllerInitObservable","addOnce","motionController","_doNotLoadControllerMesh","onModelLoadedObservable","impostor","rootMesh","MeshImpostor","mass","controllerMesh","grip","pointer","oldPos","position","clone","oldRotation","rotationQuaternion","_createPhysicsImpostor","impostorType","SphereImpostor","impostorSize","impostorMesh","diameterX","width","diameterY","height","diameterZ","depth","isVisible","_debugMode","isPickable","copyFrom","_enablePhysicsDebug","Object","keys","forEach","controllerId","controllerData","addController","_attachController","attach","xrInput","controllers","_addNewAttachObserver","onControllerAddedObservable","onControllerRemovedObservable","controller","_detachController","enableHeadsetImpostor","params","headsetImpostorParams","restitution","_headsetMesh","_headsetImpostor","detach","dispose","getHeadsetImpostor","getImpostorForController","id","setPhysicsProperties","newProperties","_onXRFrame","_xrFrame","_delta","currentTimestamp","_lastTimestamp","xrCamera","globalPosition","absoluteRotation","_lastXRViewerPose","linearVelocity","lv","_tmpVector","set","x","y","z","setLinearVelocity","angularVelocity","av","setAngularVelocity","comparedPosition","_lastXRPose","subtractToRef","scaleInPlace","console","log","comparedQuaternion","equalsWithEpsilon","conjugateInPlace","multiplyToRef","_tmpQuaternion","len","Math","sqrt","angle","atan2","w","xrControllerUniqueId","PHYSICS_CONTROLLERS","AddWebXRFeature","Name","xrSessionManager","options","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRControllerPhysics.ts"],"sourcesContent":["import { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Vector3, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { WebXRInputSource } from \"../webXRInputSource\";\r\nimport { PhysicsImpostor } from \"../../Physics/v1/physicsImpostor\";\r\nimport type { WebXRInput } from \"../webXRInput\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { CreateSphere } from \"../../Meshes/Builders/sphereBuilder\";\r\nimport { WebXRFeatureName, WebXRFeaturesManager } from \"../webXRFeaturesManager\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Options for the controller physics feature\r\n */\r\nexport class IWebXRControllerPhysicsOptions {\r\n    /**\r\n     * Should the headset get its own impostor\r\n     */\r\n    enableHeadsetImpostor?: boolean;\r\n    /**\r\n     * Optional parameters for the headset impostor\r\n     */\r\n    headsetImpostorParams?: {\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * The physics properties of the future impostors\r\n     */\r\n    physicsProperties?: {\r\n        /**\r\n         * If set to true, a mesh impostor will be created when the controller mesh was loaded\r\n         * Note that this requires a physics engine that supports mesh impostors!\r\n         */\r\n        useControllerMesh?: boolean;\r\n        /**\r\n         * The type of impostor to create. Default is sphere\r\n         */\r\n        impostorType?: number;\r\n        /**\r\n         * the size of the impostor. Defaults to 10cm\r\n         */\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        /**\r\n         * Friction definitions\r\n         */\r\n        friction?: number;\r\n        /**\r\n         * Restitution\r\n         */\r\n        restitution?: number;\r\n    };\r\n    /**\r\n     * the xr input to use with this pointer selection\r\n     */\r\n    public xrInput: WebXRInput;\r\n}\r\n\r\n/**\r\n * Add physics impostor to your webxr controllers,\r\n * including naive calculation of their linear and angular velocity\r\n */\r\nexport class WebXRControllerPhysics extends WebXRAbstractFeature {\r\n    private _attachController = (xrController: WebXRInputSource) => {\r\n        if (this._controllers[xrController.uniqueId]) {\r\n            // already attached\r\n            return;\r\n        }\r\n        if (!this._xrSessionManager.scene.isPhysicsEnabled()) {\r\n            Logger.Warn(\"physics engine not enabled, skipped. Please add this controller manually.\");\r\n        }\r\n        // if no motion controller available, create impostors!\r\n        if (this._options.physicsProperties!.useControllerMesh && xrController.inputSource.gamepad) {\r\n            xrController.onMotionControllerInitObservable.addOnce((motionController) => {\r\n                if (!motionController._doNotLoadControllerMesh) {\r\n                    motionController.onModelLoadedObservable.addOnce(() => {\r\n                        const impostor = new PhysicsImpostor(motionController.rootMesh!, PhysicsImpostor.MeshImpostor, {\r\n                            mass: 0,\r\n                            ...this._options.physicsProperties,\r\n                        });\r\n\r\n                        const controllerMesh = xrController.grip || xrController.pointer;\r\n                        this._controllers[xrController.uniqueId] = {\r\n                            xrController,\r\n                            impostor,\r\n                            oldPos: controllerMesh.position.clone(),\r\n                            oldRotation: controllerMesh.rotationQuaternion!.clone(),\r\n                        };\r\n                    });\r\n                } else {\r\n                    // This controller isn't using a model, create impostors instead\r\n                    this._createPhysicsImpostor(xrController);\r\n                }\r\n            });\r\n        } else {\r\n            this._createPhysicsImpostor(xrController);\r\n        }\r\n    };\r\n\r\n    private _createPhysicsImpostor(xrController: WebXRInputSource) {\r\n        const impostorType: number = this._options.physicsProperties!.impostorType || PhysicsImpostor.SphereImpostor;\r\n        const impostorSize: number | { width: number; height: number; depth: number } = this._options.physicsProperties!.impostorSize || 0.1;\r\n        const impostorMesh = CreateSphere(\"impostor-mesh-\" + xrController.uniqueId, {\r\n            diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n            diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n            diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n        });\r\n        impostorMesh.isVisible = this._debugMode;\r\n        impostorMesh.isPickable = false;\r\n        impostorMesh.rotationQuaternion = new Quaternion();\r\n        const controllerMesh = xrController.grip || xrController.pointer;\r\n        impostorMesh.position.copyFrom(controllerMesh.position);\r\n        impostorMesh.rotationQuaternion!.copyFrom(controllerMesh.rotationQuaternion!);\r\n        const impostor = new PhysicsImpostor(impostorMesh, impostorType, {\r\n            mass: 0,\r\n            ...this._options.physicsProperties,\r\n        });\r\n        this._controllers[xrController.uniqueId] = {\r\n            xrController,\r\n            impostor,\r\n            impostorMesh,\r\n        };\r\n    }\r\n\r\n    private _controllers: {\r\n        [id: string]: {\r\n            xrController: WebXRInputSource;\r\n            impostorMesh?: AbstractMesh;\r\n            impostor: PhysicsImpostor;\r\n            oldPos?: Vector3;\r\n            oldSpeed?: Vector3;\r\n            oldRotation?: Quaternion;\r\n        };\r\n    } = {};\r\n    private _debugMode = false;\r\n    private _delta: number = 0;\r\n    private _headsetImpostor?: PhysicsImpostor;\r\n    private _headsetMesh?: AbstractMesh;\r\n    private _lastTimestamp: number = 0;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVector: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.PHYSICS_CONTROLLERS;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the webxr specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Construct a new Controller Physics Feature\r\n     * @param _xrSessionManager the corresponding xr session manager\r\n     * @param _options options to create this feature with\r\n     */\r\n    constructor(_xrSessionManager: WebXRSessionManager, private readonly _options: IWebXRControllerPhysicsOptions) {\r\n        super(_xrSessionManager);\r\n        if (!this._options.physicsProperties) {\r\n            this._options.physicsProperties = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * enable debugging - will show console outputs and the impostor mesh\r\n     */\r\n    public _enablePhysicsDebug() {\r\n        this._debugMode = true;\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            if (controllerData.impostorMesh) {\r\n                controllerData.impostorMesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Manually add a controller (if no xrInput was provided or physics engine was not enabled)\r\n     * @param xrController the controller to add\r\n     */\r\n    public addController(xrController: WebXRInputSource) {\r\n        this._attachController(xrController);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._options.xrInput) {\r\n            return true;\r\n        }\r\n\r\n        this._options.xrInput.controllers.forEach(this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerAddedObservable, this._attachController);\r\n        this._addNewAttachObserver(this._options.xrInput.onControllerRemovedObservable, (controller) => {\r\n            // REMOVE the controller\r\n            this._detachController(controller.uniqueId);\r\n        });\r\n\r\n        if (this._options.enableHeadsetImpostor) {\r\n            const params = this._options.headsetImpostorParams || {\r\n                impostorType: PhysicsImpostor.SphereImpostor,\r\n                restitution: 0.8,\r\n                impostorSize: 0.3,\r\n            };\r\n            const impostorSize = params.impostorSize || 0.3;\r\n            this._headsetMesh = CreateSphere(\"headset-mesh\", {\r\n                diameterX: typeof impostorSize === \"number\" ? impostorSize : impostorSize.width,\r\n                diameterY: typeof impostorSize === \"number\" ? impostorSize : impostorSize.height,\r\n                diameterZ: typeof impostorSize === \"number\" ? impostorSize : impostorSize.depth,\r\n            });\r\n            this._headsetMesh.rotationQuaternion = new Quaternion();\r\n            this._headsetMesh.isVisible = false;\r\n            this._headsetImpostor = new PhysicsImpostor(this._headsetMesh, params.impostorType, { mass: 0, ...params });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            this._detachController(controllerId);\r\n        });\r\n\r\n        if (this._headsetMesh) {\r\n            this._headsetMesh.dispose();\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the headset impostor, if enabled\r\n     * @returns the impostor\r\n     */\r\n    public getHeadsetImpostor() {\r\n        return this._headsetImpostor;\r\n    }\r\n\r\n    /**\r\n     * Get the physics impostor of a specific controller.\r\n     * The impostor is not attached to a mesh because a mesh for each controller is not obligatory\r\n     * @param controller the controller or the controller id of which to get the impostor\r\n     * @returns the impostor or null\r\n     */\r\n    public getImpostorForController(controller: WebXRInputSource | string): Nullable<PhysicsImpostor> {\r\n        const id = typeof controller === \"string\" ? controller : controller.uniqueId;\r\n        if (this._controllers[id]) {\r\n            return this._controllers[id].impostor;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the physics properties provided in the constructor\r\n     * @param newProperties the new properties object\r\n     * @param newProperties.impostorType\r\n     * @param newProperties.impostorSize\r\n     * @param newProperties.friction\r\n     * @param newProperties.restitution\r\n     */\r\n    public setPhysicsProperties(newProperties: {\r\n        impostorType?: number;\r\n        impostorSize?: number | { width: number; height: number; depth: number };\r\n        friction?: number;\r\n        restitution?: number;\r\n    }) {\r\n        this._options.physicsProperties = {\r\n            ...this._options.physicsProperties,\r\n            ...newProperties,\r\n        };\r\n    }\r\n\r\n    protected _onXRFrame(_xrFrame: any): void {\r\n        this._delta = this._xrSessionManager.currentTimestamp - this._lastTimestamp;\r\n        this._lastTimestamp = this._xrSessionManager.currentTimestamp;\r\n        if (this._headsetMesh && this._headsetImpostor) {\r\n            this._headsetMesh.position.copyFrom(this._options.xrInput.xrCamera.globalPosition);\r\n            this._headsetMesh.rotationQuaternion!.copyFrom(this._options.xrInput.xrCamera.absoluteRotation);\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.linearVelocity) {\r\n                const lv = this._options.xrInput.xrCamera._lastXRViewerPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                this._headsetImpostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            if (this._options.xrInput.xrCamera._lastXRViewerPose?.angularVelocity) {\r\n                const av = this._options.xrInput.xrCamera._lastXRViewerPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                this._headsetImpostor.setAngularVelocity(this._tmpVector);\r\n            }\r\n        }\r\n        Object.keys(this._controllers).forEach((controllerId) => {\r\n            const controllerData = this._controllers[controllerId];\r\n            const controllerMesh = controllerData.xrController.grip || controllerData.xrController.pointer;\r\n            const comparedPosition = controllerData.oldPos || controllerData.impostorMesh!.position;\r\n            if (controllerData.xrController._lastXRPose?.linearVelocity) {\r\n                const lv = controllerData.xrController._lastXRPose.linearVelocity;\r\n                this._tmpVector.set(lv.x, lv.y, lv.z);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            } else {\r\n                controllerMesh.position.subtractToRef(comparedPosition, this._tmpVector);\r\n                this._tmpVector.scaleInPlace(1000 / this._delta);\r\n                controllerData.impostor.setLinearVelocity(this._tmpVector);\r\n            }\r\n            comparedPosition.copyFrom(controllerMesh.position);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, \"linear\");\r\n            }\r\n\r\n            const comparedQuaternion = controllerData.oldRotation || controllerData.impostorMesh!.rotationQuaternion!;\r\n            if (controllerData.xrController._lastXRPose?.angularVelocity) {\r\n                const av = controllerData.xrController._lastXRPose.angularVelocity;\r\n                this._tmpVector.set(av.x, av.y, av.z);\r\n                controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n            } else {\r\n                if (!comparedQuaternion.equalsWithEpsilon(controllerMesh.rotationQuaternion!)) {\r\n                    // roughly based on this - https://www.gamedev.net/forums/topic/347752-quaternion-and-angular-velocity/\r\n                    comparedQuaternion.conjugateInPlace().multiplyToRef(controllerMesh.rotationQuaternion!, this._tmpQuaternion);\r\n                    const len = Math.sqrt(\r\n                        this._tmpQuaternion.x * this._tmpQuaternion.x + this._tmpQuaternion.y * this._tmpQuaternion.y + this._tmpQuaternion.z * this._tmpQuaternion.z\r\n                    );\r\n                    this._tmpVector.set(this._tmpQuaternion.x, this._tmpQuaternion.y, this._tmpQuaternion.z);\r\n                    // define a better epsilon\r\n                    if (len < 0.001) {\r\n                        this._tmpVector.scaleInPlace(2);\r\n                    } else {\r\n                        const angle = 2 * Math.atan2(len, this._tmpQuaternion.w);\r\n                        this._tmpVector.scaleInPlace(angle / (len * (this._delta / 1000)));\r\n                    }\r\n                    controllerData.impostor.setAngularVelocity(this._tmpVector);\r\n                }\r\n            }\r\n            comparedQuaternion.copyFrom(controllerMesh.rotationQuaternion!);\r\n            if (this._debugMode) {\r\n                console.log(this._tmpVector, this._tmpQuaternion, \"angular\");\r\n            }\r\n        });\r\n    }\r\n\r\n    private _detachController(xrControllerUniqueId: string) {\r\n        const controllerData = this._controllers[xrControllerUniqueId];\r\n        if (!controllerData) {\r\n            return;\r\n        }\r\n        if (controllerData.impostorMesh) {\r\n            controllerData.impostorMesh.dispose();\r\n        }\r\n        // remove from the map\r\n        delete this._controllers[xrControllerUniqueId];\r\n    }\r\n}\r\n\r\n//register the plugin\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRControllerPhysics.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRControllerPhysics(xrSessionManager, options);\r\n    },\r\n    WebXRControllerPhysics.Version,\r\n    true\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}