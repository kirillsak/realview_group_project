{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nclass WebGPUBindGroupCacheNode {\n  constructor() {\n    this.values = {};\n  }\n}\n/** @internal */\nexport class WebGPUCacheBindGroups {\n  constructor(device, cacheSampler, engine) {\n    this.disabled = false;\n    this._device = device;\n    this._cacheSampler = cacheSampler;\n    this._engine = engine;\n  }\n  static get Statistics() {\n    return {\n      totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\n      lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\n      lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\n      noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame\n    };\n  }\n  endFrame() {\n    WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\n    WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\n    WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\n  }\n  /**\n   * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\n   * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\n   * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\n   * @param webgpuPipelineContext\n   * @param drawContext\n   * @param materialContext\n   */\n  getBindGroups(webgpuPipelineContext, drawContext, materialContext) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    let bindGroups = undefined;\n    let node = WebGPUCacheBindGroups._Cache;\n    const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\n    if (!cacheIsDisabled) {\n      if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\n        return drawContext.bindGroups;\n      }\n      for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\n        const uboId = (_b = (_a = drawContext.buffers[bufferName]) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : 0;\n        let nextNode = node.values[uboId];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[uboId] = nextNode;\n        }\n        node = nextNode;\n      }\n      for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\n        const samplerHashCode = (_d = (_c = materialContext.samplers[samplerName]) === null || _c === void 0 ? void 0 : _c.hashCode) !== null && _d !== void 0 ? _d : 0;\n        let nextNode = node.values[samplerHashCode];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[samplerHashCode] = nextNode;\n        }\n        node = nextNode;\n      }\n      for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\n        const textureId = (_g = (_f = (_e = materialContext.textures[textureName]) === null || _e === void 0 ? void 0 : _e.texture) === null || _f === void 0 ? void 0 : _f.uniqueId) !== null && _g !== void 0 ? _g : 0;\n        let nextNode = node.values[textureId];\n        if (!nextNode) {\n          nextNode = new WebGPUBindGroupCacheNode();\n          node.values[textureId] = nextNode;\n        }\n        node = nextNode;\n      }\n      bindGroups = node.bindGroups;\n    }\n    drawContext.resetIsDirty(materialContext.updateId);\n    materialContext.isDirty = false;\n    if (bindGroups) {\n      drawContext.bindGroups = bindGroups;\n      WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\n      return bindGroups;\n    }\n    bindGroups = [];\n    drawContext.bindGroups = bindGroups;\n    if (!cacheIsDisabled) {\n      node.bindGroups = bindGroups;\n    }\n    WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\n    WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\n    const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;\n    for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\n      const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\n      const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\n      for (let j = 0; j < setDefinition.length; j++) {\n        const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\n        const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\n        const name = (_h = entryInfo.nameInArrayOfTexture) !== null && _h !== void 0 ? _h : entryInfo.name;\n        if (entry.sampler) {\n          const bindingInfo = materialContext.samplers[name];\n          if (bindingInfo) {\n            const sampler = bindingInfo.sampler;\n            if (!sampler) {\n              if (this._engine.dbgSanityChecks) {\n                Logger.Error(`Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              }\n              continue;\n            }\n            entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);\n          } else {\n            Logger.Error(`Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.texture || entry.storageTexture) {\n          const bindingInfo = materialContext.textures[name];\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(`Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            const hardwareTexture = bindingInfo.texture._hardwareTexture;\n            if (this._engine.dbgSanityChecks && (!hardwareTexture || entry.texture && !hardwareTexture.view || entry.storageTexture && !hardwareTexture.viewForWriting)) {\n              Logger.Error(`Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, isReady=${(_j = bindingInfo.texture) === null || _j === void 0 ? void 0 : _j.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting : hardwareTexture.view;\n          } else {\n            Logger.Error(`Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.externalTexture) {\n          const bindingInfo = materialContext.textures[name];\n          if (bindingInfo) {\n            if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\n              Logger.Error(`Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            const externalTexture = bindingInfo.texture.underlyingResource;\n            if (this._engine.dbgSanityChecks && !externalTexture) {\n              Logger.Error(`Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(bindingInfo, (key, value) => key === \"texture\" ? \"<no dump>\" : value)}, isReady=${(_k = bindingInfo.texture) === null || _k === void 0 ? void 0 : _k.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`, 50);\n              continue;\n            }\n            entries[j].resource = this._device.importExternalTexture({\n              source: externalTexture\n            });\n          } else {\n            Logger.Error(`Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key, value) => key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value)}`, 50);\n          }\n        } else if (entry.buffer) {\n          const dataBuffer = drawContext.buffers[name];\n          if (dataBuffer) {\n            const webgpuBuffer = dataBuffer.underlyingResource;\n            entries[j].resource.buffer = webgpuBuffer;\n            entries[j].resource.size = dataBuffer.capacity;\n          } else {\n            Logger.Error(`Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${drawContext.uniqueId}`, 50);\n          }\n        }\n      }\n      const groupLayout = bindGroupLayouts[i];\n      bindGroups[i] = this._device.createBindGroup({\n        layout: groupLayout,\n        entries\n      });\n    }\n    return bindGroups;\n  }\n}\nWebGPUCacheBindGroups.NumBindGroupsCreatedTotal = 0;\nWebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = 0;\nWebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = 0;\nWebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = 0;\nWebGPUCacheBindGroups._Cache = new WebGPUBindGroupCacheNode();\nWebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\nWebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\nWebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;","map":{"version":3,"mappings":"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","names":["Logger","WebGPUBindGroupCacheNode","constructor","values","WebGPUCacheBindGroups","device","cacheSampler","engine","_device","_cacheSampler","_engine","Statistics","totalCreated","NumBindGroupsCreatedTotal","lastFrameCreated","NumBindGroupsCreatedLastFrame","lookupLastFrame","NumBindGroupsLookupLastFrame","noLookupLastFrame","NumBindGroupsNoLookupLastFrame","endFrame","_NumBindGroupsCreatedCurrentFrame","_NumBindGroupsLookupCurrentFrame","_NumBindGroupsNoLookupCurrentFrame","getBindGroups","webgpuPipelineContext","drawContext","materialContext","bindGroups","undefined","node","_Cache","cacheIsDisabled","disabled","forceBindGroupCreation","isDirty","updateId","bufferName","shaderProcessingContext","bufferNames","uboId","buffers","uniqueId","nextNode","samplerName","samplerNames","samplerHashCode","samplers","hashCode","textureName","textureNames","textureId","textures","texture","resetIsDirty","bindGroupLayouts","i","bindGroupLayoutEntries","length","setDefinition","entries","bindGroupEntries","j","entry","entryInfo","bindGroupLayoutEntryInfo","binding","name","nameInArrayOfTexture","sampler","bindingInfo","dbgSanityChecks","Error","JSON","stringify","key","value","resource","getSampler","storageTexture","hardwareTexture","_hardwareTexture","view","viewForWriting","isReady","externalTexture","underlyingResource","importExternalTexture","source","buffer","dataBuffer","webgpuBuffer","size","capacity","groupLayout","createBindGroup","layout"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuCacheBindGroups.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\nimport type { WebGPUMaterialContext } from \"./webgpuMaterialContext\";\r\nimport type { WebGPUPipelineContext } from \"./webgpuPipelineContext\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUHardwareTexture } from \"./webgpuHardwareTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { WebGPUDrawContext } from \"./webgpuDrawContext\";\r\n\r\nclass WebGPUBindGroupCacheNode {\r\n    public values: { [id: number]: WebGPUBindGroupCacheNode };\r\n    public bindGroups: GPUBindGroup[];\r\n\r\n    constructor() {\r\n        this.values = {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUCacheBindGroups {\r\n    public static NumBindGroupsCreatedTotal = 0;\r\n    public static NumBindGroupsCreatedLastFrame = 0;\r\n    public static NumBindGroupsLookupLastFrame = 0;\r\n    public static NumBindGroupsNoLookupLastFrame = 0;\r\n\r\n    private static _Cache: WebGPUBindGroupCacheNode = new WebGPUBindGroupCacheNode();\r\n\r\n    private static _NumBindGroupsCreatedCurrentFrame = 0;\r\n    private static _NumBindGroupsLookupCurrentFrame = 0;\r\n    private static _NumBindGroupsNoLookupCurrentFrame = 0;\r\n\r\n    private _device: GPUDevice;\r\n    private _cacheSampler: WebGPUCacheSampler;\r\n    private _engine: WebGPUEngine;\r\n\r\n    public disabled = false;\r\n\r\n    public static get Statistics() {\r\n        return {\r\n            totalCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedTotal,\r\n            lastFrameCreated: WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame,\r\n            lookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame,\r\n            noLookupLastFrame: WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame,\r\n        };\r\n    }\r\n\r\n    constructor(device: GPUDevice, cacheSampler: WebGPUCacheSampler, engine: WebGPUEngine) {\r\n        this._device = device;\r\n        this._cacheSampler = cacheSampler;\r\n        this._engine = engine;\r\n    }\r\n\r\n    public endFrame(): void {\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedLastFrame = WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame;\r\n        WebGPUCacheBindGroups.NumBindGroupsNoLookupLastFrame = WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame = 0;\r\n        WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame = 0;\r\n    }\r\n\r\n    /**\r\n     * Cache is currently based on the uniform/storage buffers, samplers and textures used by the binding groups.\r\n     * Note that all uniform buffers have an offset of 0 in Babylon and we don't have a use case where we would have the same buffer used with different capacity values:\r\n     * that means we don't need to factor in the offset/size of the buffer in the cache, only the id\r\n     * @param webgpuPipelineContext\r\n     * @param drawContext\r\n     * @param materialContext\r\n     */\r\n    public getBindGroups(webgpuPipelineContext: WebGPUPipelineContext, drawContext: WebGPUDrawContext, materialContext: WebGPUMaterialContext): GPUBindGroup[] {\r\n        let bindGroups: GPUBindGroup[] | undefined = undefined;\r\n        let node = WebGPUCacheBindGroups._Cache;\r\n\r\n        const cacheIsDisabled = this.disabled || materialContext.forceBindGroupCreation;\r\n        if (!cacheIsDisabled) {\r\n            if (!drawContext.isDirty(materialContext.updateId) && !materialContext.isDirty) {\r\n                WebGPUCacheBindGroups._NumBindGroupsNoLookupCurrentFrame++;\r\n                return drawContext.bindGroups!;\r\n            }\r\n\r\n            for (const bufferName of webgpuPipelineContext.shaderProcessingContext.bufferNames) {\r\n                const uboId = drawContext.buffers[bufferName]?.uniqueId ?? 0;\r\n                let nextNode = node.values[uboId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[uboId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const samplerName of webgpuPipelineContext.shaderProcessingContext.samplerNames) {\r\n                const samplerHashCode = materialContext.samplers[samplerName]?.hashCode ?? 0;\r\n                let nextNode = node.values[samplerHashCode];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[samplerHashCode] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            for (const textureName of webgpuPipelineContext.shaderProcessingContext.textureNames) {\r\n                const textureId = materialContext.textures[textureName]?.texture?.uniqueId ?? 0;\r\n                let nextNode = node.values[textureId];\r\n                if (!nextNode) {\r\n                    nextNode = new WebGPUBindGroupCacheNode();\r\n                    node.values[textureId] = nextNode;\r\n                }\r\n                node = nextNode;\r\n            }\r\n\r\n            bindGroups = node.bindGroups;\r\n        }\r\n\r\n        drawContext.resetIsDirty(materialContext.updateId);\r\n        materialContext.isDirty = false;\r\n\r\n        if (bindGroups) {\r\n            drawContext.bindGroups = bindGroups;\r\n            WebGPUCacheBindGroups._NumBindGroupsLookupCurrentFrame++;\r\n            return bindGroups;\r\n        }\r\n\r\n        bindGroups = [];\r\n        drawContext.bindGroups = bindGroups;\r\n\r\n        if (!cacheIsDisabled) {\r\n            node.bindGroups = bindGroups;\r\n        }\r\n\r\n        WebGPUCacheBindGroups.NumBindGroupsCreatedTotal++;\r\n        WebGPUCacheBindGroups._NumBindGroupsCreatedCurrentFrame++;\r\n\r\n        const bindGroupLayouts = webgpuPipelineContext.bindGroupLayouts;\r\n        for (let i = 0; i < webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries.length; i++) {\r\n            const setDefinition = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i];\r\n\r\n            const entries = webgpuPipelineContext.shaderProcessingContext.bindGroupEntries[i];\r\n            for (let j = 0; j < setDefinition.length; j++) {\r\n                const entry = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntries[i][j];\r\n                const entryInfo = webgpuPipelineContext.shaderProcessingContext.bindGroupLayoutEntryInfo[i][entry.binding];\r\n                const name = entryInfo.nameInArrayOfTexture ?? entryInfo.name;\r\n\r\n                if (entry.sampler) {\r\n                    const bindingInfo = materialContext.samplers[name];\r\n                    if (bindingInfo) {\r\n                        const sampler = bindingInfo.sampler;\r\n                        if (!sampler) {\r\n                            if (this._engine.dbgSanityChecks) {\r\n                                Logger.Error(\r\n                                    `Trying to bind a null sampler! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                        bindingInfo,\r\n                                        (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                    )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                    50\r\n                                );\r\n                            }\r\n                            continue;\r\n                        }\r\n                        entries[j].resource = this._cacheSampler.getSampler(sampler, false, bindingInfo.hashCode);\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Sampler \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.texture || entry.storageTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null texture! entry=${JSON.stringify(entry)}, bindingInfo=${JSON.stringify(bindingInfo, (key: string, value: any) =>\r\n                                    key === \"texture\" ? \"<no dump>\" : value\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const hardwareTexture = (bindingInfo.texture as InternalTexture)._hardwareTexture as WebGPUHardwareTexture;\r\n\r\n                        if (\r\n                            this._engine.dbgSanityChecks &&\r\n                            (!hardwareTexture || (entry.texture && !hardwareTexture.view) || (entry.storageTexture && !hardwareTexture.viewForWriting))\r\n                        ) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu texture or view! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = entry.storageTexture ? hardwareTexture.viewForWriting! : hardwareTexture.view!;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.externalTexture) {\r\n                    const bindingInfo = materialContext.textures[name];\r\n                    if (bindingInfo) {\r\n                        if (this._engine.dbgSanityChecks && bindingInfo.texture === null) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n                        const externalTexture = (bindingInfo.texture as ExternalTexture).underlyingResource;\r\n\r\n                        if (this._engine.dbgSanityChecks && !externalTexture) {\r\n                            Logger.Error(\r\n                                `Trying to bind a null gpu external texture! entry=${JSON.stringify(entry)}, name=${name}, bindingInfo=${JSON.stringify(\r\n                                    bindingInfo,\r\n                                    (key: string, value: any) => (key === \"texture\" ? \"<no dump>\" : value)\r\n                                )}, isReady=${bindingInfo.texture?.isReady}, materialContext.uniqueId=${materialContext.uniqueId}`,\r\n                                50\r\n                            );\r\n                            continue;\r\n                        }\r\n\r\n                        entries[j].resource = this._device.importExternalTexture({ source: externalTexture });\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Texture \"${name}\" could not be bound. entry=${JSON.stringify(entry)}, materialContext=${JSON.stringify(materialContext, (key: string, value: any) =>\r\n                                key === \"texture\" || key === \"sampler\" ? \"<no dump>\" : value\r\n                            )}`,\r\n                            50\r\n                        );\r\n                    }\r\n                } else if (entry.buffer) {\r\n                    const dataBuffer = drawContext.buffers[name];\r\n                    if (dataBuffer) {\r\n                        const webgpuBuffer = dataBuffer.underlyingResource as GPUBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).buffer = webgpuBuffer;\r\n                        (entries[j].resource as GPUBufferBinding).size = dataBuffer.capacity;\r\n                    } else {\r\n                        Logger.Error(\r\n                            `Can't find buffer \"${name}\". entry=${JSON.stringify(entry)}, buffers=${JSON.stringify(drawContext.buffers)}, drawContext.uniqueId=${\r\n                                drawContext.uniqueId\r\n                            }`,\r\n                            50\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const groupLayout = bindGroupLayouts[i];\r\n            bindGroups[i] = this._device.createBindGroup({\r\n                layout: groupLayout,\r\n                entries,\r\n            });\r\n        }\r\n\r\n        return bindGroups;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}