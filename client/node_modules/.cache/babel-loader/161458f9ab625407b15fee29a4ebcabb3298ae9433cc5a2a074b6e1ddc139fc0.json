{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport \"../Shaders/kernelBlur.fragment.js\";\nimport \"../Shaders/kernelBlur.vertex.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { serialize, serializeAsVector2, SerializationHelper } from \"../Misc/decorators.js\";\n/**\n * The Blur Post Process which blurs an image based on a kernel and direction.\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\n */\nexport class BlurPostProcess extends PostProcess {\n  /**\n   * Creates a new instance BlurPostProcess\n   * @param name The name of the effect.\n   * @param direction The direction in which to blur the image.\n   * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param defines\n   * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   */\n  constructor(name, direction, kernel, options, camera, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = \"\", _blockCompilation = false, textureFormat = 5) {\n    super(name, \"kernelBlur\", [\"delta\", \"direction\"], [\"circleOfConfusionSampler\"], options, camera, samplingMode, engine, reusable, null, textureType, \"kernelBlur\", {\n      varyingCount: 0,\n      depCount: 0\n    }, true, textureFormat);\n    this._blockCompilation = _blockCompilation;\n    this._packedFloat = false;\n    this._staticDefines = \"\";\n    this._staticDefines = defines;\n    this.direction = direction;\n    this.onApplyObservable.add(effect => {\n      if (this._outputTexture) {\n        effect.setFloat2(\"delta\", 1 / this._outputTexture.width * this.direction.x, 1 / this._outputTexture.height * this.direction.y);\n      } else {\n        effect.setFloat2(\"delta\", 1 / this.width * this.direction.x, 1 / this.height * this.direction.y);\n      }\n    });\n    this.kernel = kernel;\n  }\n  /**\n   * Sets the length in pixels of the blur sample region\n   */\n  set kernel(v) {\n    if (this._idealKernel === v) {\n      return;\n    }\n    v = Math.max(v, 1);\n    this._idealKernel = v;\n    this._kernel = this._nearestBestKernel(v);\n    if (!this._blockCompilation) {\n      this._updateParameters();\n    }\n  }\n  /**\n   * Gets the length in pixels of the blur sample region\n   */\n  get kernel() {\n    return this._idealKernel;\n  }\n  /**\n   * Sets whether or not the blur needs to unpack/repack floats\n   */\n  set packedFloat(v) {\n    if (this._packedFloat === v) {\n      return;\n    }\n    this._packedFloat = v;\n    if (!this._blockCompilation) {\n      this._updateParameters();\n    }\n  }\n  /**\n   * Gets whether or not the blur is unpacking/repacking floats\n   */\n  get packedFloat() {\n    return this._packedFloat;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"BlurPostProcess\" string\n   */\n  getClassName() {\n    return \"BlurPostProcess\";\n  }\n  /**\n   * Updates the effect with the current post process compile time values and recompiles the shader.\n   * @param defines Define statements that should be added at the beginning of the shader. (default: null)\n   * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\n   * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\n   * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\n   * @param onCompiled Called when the shader has been compiled.\n   * @param onError Called if there is an error when compiling a shader.\n   */\n  updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError) {\n    this._updateParameters(onCompiled, onError);\n  }\n  _updateParameters(onCompiled, onError) {\n    // Generate sampling offsets and weights\n    const N = this._kernel;\n    const centerIndex = (N - 1) / 2;\n    // Generate Gaussian sampling weights over kernel\n    let offsets = [];\n    let weights = [];\n    let totalWeight = 0;\n    for (let i = 0; i < N; i++) {\n      const u = i / (N - 1);\n      const w = this._gaussianWeight(u * 2.0 - 1);\n      offsets[i] = i - centerIndex;\n      weights[i] = w;\n      totalWeight += w;\n    }\n    // Normalize weights\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] /= totalWeight;\n    }\n    // Optimize: combine samples to take advantage of hardware linear sampling\n    // Walk from left to center, combining pairs (symmetrically)\n    const linearSamplingWeights = [];\n    const linearSamplingOffsets = [];\n    const linearSamplingMap = [];\n    for (let i = 0; i <= centerIndex; i += 2) {\n      const j = Math.min(i + 1, Math.floor(centerIndex));\n      const singleCenterSample = i === j;\n      if (singleCenterSample) {\n        linearSamplingMap.push({\n          o: offsets[i],\n          w: weights[i]\n        });\n      } else {\n        const sharedCell = j === centerIndex;\n        const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\n        const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\n        if (offsetLinear === 0) {\n          linearSamplingMap.push({\n            o: offsets[i],\n            w: weights[i]\n          });\n          linearSamplingMap.push({\n            o: offsets[i + 1],\n            w: weights[i + 1]\n          });\n        } else {\n          linearSamplingMap.push({\n            o: offsetLinear,\n            w: weightLinear\n          });\n          linearSamplingMap.push({\n            o: -offsetLinear,\n            w: weightLinear\n          });\n        }\n      }\n    }\n    for (let i = 0; i < linearSamplingMap.length; i++) {\n      linearSamplingOffsets[i] = linearSamplingMap[i].o;\n      linearSamplingWeights[i] = linearSamplingMap[i].w;\n    }\n    // Replace with optimized\n    offsets = linearSamplingOffsets;\n    weights = linearSamplingWeights;\n    // Generate shaders\n    const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\n    const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\n    let varyingCount = Math.min(offsets.length, freeVaryingVec2);\n    let defines = \"\";\n    defines += this._staticDefines;\n    // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\n    if (this._staticDefines.indexOf(\"DOF\") != -1) {\n      defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\r\\n`;\n      varyingCount--;\n    }\n    for (let i = 0; i < varyingCount; i++) {\n      defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\r\\n`;\n      defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\r\\n`;\n    }\n    let depCount = 0;\n    for (let i = freeVaryingVec2; i < offsets.length; i++) {\n      defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\r\\n`;\n      defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\r\\n`;\n      depCount++;\n    }\n    if (this.packedFloat) {\n      defines += `#define PACKEDFLOAT 1`;\n    }\n    this._blockCompilation = false;\n    super.updateEffect(defines, null, null, {\n      varyingCount: varyingCount,\n      depCount: depCount\n    }, onCompiled, onError);\n  }\n  /**\n   * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\n   * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\n   * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\n   * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\n   * The gaps between physical kernels are compensated for in the weighting of the samples\n   * @param idealKernel Ideal blur kernel.\n   * @returns Nearest best kernel.\n   */\n  _nearestBestKernel(idealKernel) {\n    const v = Math.round(idealKernel);\n    for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\n      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\n        return Math.max(k, 3);\n      }\n    }\n    return Math.max(v, 3);\n  }\n  /**\n   * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\n   * @param x The point on the Gaussian distribution to sample.\n   * @returns the value of the Gaussian function at x.\n   */\n  _gaussianWeight(x) {\n    //reference: Engines/ImageProcessingBlur.cpp #dcc760\n    // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\n    // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\n    // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\n    // truncated at around 1.3% of peak strength.\n    //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\n    const sigma = 1 / 3;\n    const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\n    const exponent = -(x * x / (2.0 * sigma * sigma));\n    const weight = 1.0 / denominator * Math.exp(exponent);\n    return weight;\n  }\n  /**\n   * Generates a string that can be used as a floating point number in GLSL.\n   * @param x Value to print.\n   * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\n   * @returns GLSL float string.\n   */\n  _glslFloat(x, decimalFigures = 8) {\n    return x.toFixed(decimalFigures).replace(/0+$/, \"\");\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, undefined, false);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize(\"kernel\")], BlurPostProcess.prototype, \"_kernel\", void 0);\n__decorate([serialize(\"packedFloat\")], BlurPostProcess.prototype, \"_packedFloat\", void 0);\n__decorate([serializeAsVector2()], BlurPostProcess.prototype, \"direction\", void 0);\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);","map":{"version":3,"mappings":"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","names":["PostProcess","Texture","RegisterClass","serialize","serializeAsVector2","SerializationHelper","BlurPostProcess","constructor","name","direction","kernel","options","camera","samplingMode","BILINEAR_SAMPLINGMODE","engine","reusable","textureType","textureFormat","varyingCount","depCount","_blockCompilation","_staticDefines","defines","onApplyObservable","add","effect","_outputTexture","setFloat2","width","x","height","y","v","_idealKernel","Math","max","_kernel","_nearestBestKernel","_updateParameters","packedFloat","_packedFloat","getClassName","updateEffect","uniforms","samplers","indexParameters","onCompiled","onError","N","centerIndex","offsets","weights","totalWeight","i","u","w","_gaussianWeight","length","linearSamplingWeights","linearSamplingOffsets","linearSamplingMap","j","min","floor","singleCenterSample","push","o","sharedCell","weightLinear","offsetLinear","maxVaryingRows","getEngine","getCaps","maxVaryingVectors","freeVaryingVec2","indexOf","_glslFloat","idealKernel","round","k","sigma","denominator","sqrt","PI","exponent","weight","exp","decimalFigures","toFixed","replace","_Parse","parsedPostProcess","targetCamera","scene","rootUrl","Parse","renderTargetSamplingMode","undefined","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/blurPostProcess.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport \"../Shaders/kernelBlur.fragment\";\r\nimport \"../Shaders/kernelBlur.vertex\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { serialize, serializeAsVector2, SerializationHelper } from \"../Misc/decorators\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The Blur Post Process which blurs an image based on a kernel and direction.\r\n * Can be used twice in x and y directions to perform a gaussian blur in two passes.\r\n */\r\nexport class BlurPostProcess extends PostProcess {\r\n    @serialize(\"kernel\")\r\n    protected _kernel: number;\r\n    protected _idealKernel: number;\r\n    @serialize(\"packedFloat\")\r\n    protected _packedFloat: boolean = false;\r\n    private _staticDefines: string = \"\";\r\n\r\n    /** The direction in which to blur the image. */\r\n    @serializeAsVector2()\r\n    public direction: Vector2;\r\n\r\n    /**\r\n     * Sets the length in pixels of the blur sample region\r\n     */\r\n    public set kernel(v: number) {\r\n        if (this._idealKernel === v) {\r\n            return;\r\n        }\r\n\r\n        v = Math.max(v, 1);\r\n        this._idealKernel = v;\r\n        this._kernel = this._nearestBestKernel(v);\r\n        if (!this._blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length in pixels of the blur sample region\r\n     */\r\n    public get kernel(): number {\r\n        return this._idealKernel;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not the blur needs to unpack/repack floats\r\n     */\r\n    public set packedFloat(v: boolean) {\r\n        if (this._packedFloat === v) {\r\n            return;\r\n        }\r\n        this._packedFloat = v;\r\n        if (!this._blockCompilation) {\r\n            this._updateParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not the blur is unpacking/repacking floats\r\n     */\r\n    public get packedFloat(): boolean {\r\n        return this._packedFloat;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"BlurPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"BlurPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance BlurPostProcess\r\n     * @param name The name of the effect.\r\n     * @param direction The direction in which to blur the image.\r\n     * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param defines\r\n     * @param _blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        direction: Vector2,\r\n        kernel: number,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        defines = \"\",\r\n        private _blockCompilation = false,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ) {\r\n        super(\r\n            name,\r\n            \"kernelBlur\",\r\n            [\"delta\", \"direction\"],\r\n            [\"circleOfConfusionSampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            null,\r\n            textureType,\r\n            \"kernelBlur\",\r\n            { varyingCount: 0, depCount: 0 },\r\n            true,\r\n            textureFormat\r\n        );\r\n        this._staticDefines = defines;\r\n        this.direction = direction;\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            if (this._outputTexture) {\r\n                effect.setFloat2(\"delta\", (1 / this._outputTexture.width) * this.direction.x, (1 / this._outputTexture.height) * this.direction.y);\r\n            } else {\r\n                effect.setFloat2(\"delta\", (1 / this.width) * this.direction.x, (1 / this.height) * this.direction.y);\r\n            }\r\n        });\r\n\r\n        this.kernel = kernel;\r\n    }\r\n\r\n    /**\r\n     * Updates the effect with the current post process compile time values and recompiles the shader.\r\n     * @param defines Define statements that should be added at the beginning of the shader. (default: null)\r\n     * @param uniforms Set of uniform variables that will be passed to the shader. (default: null)\r\n     * @param samplers Set of Texture2D variables that will be passed to the shader. (default: null)\r\n     * @param indexParameters The index parameters to be used for babylons include syntax \"#include<kernelBlurVaryingDeclaration>[0..varyingCount]\". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx\r\n     * @param onCompiled Called when the shader has been compiled.\r\n     * @param onError Called if there is an error when compiling a shader.\r\n     */\r\n    public updateEffect(\r\n        defines: Nullable<string> = null,\r\n        uniforms: Nullable<string[]> = null,\r\n        samplers: Nullable<string[]> = null,\r\n        indexParameters?: any,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void\r\n    ) {\r\n        this._updateParameters(onCompiled, onError);\r\n    }\r\n\r\n    protected _updateParameters(onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void): void {\r\n        // Generate sampling offsets and weights\r\n        const N = this._kernel;\r\n        const centerIndex = (N - 1) / 2;\r\n\r\n        // Generate Gaussian sampling weights over kernel\r\n        let offsets = [];\r\n        let weights = [];\r\n        let totalWeight = 0;\r\n        for (let i = 0; i < N; i++) {\r\n            const u = i / (N - 1);\r\n            const w = this._gaussianWeight(u * 2.0 - 1);\r\n            offsets[i] = i - centerIndex;\r\n            weights[i] = w;\r\n            totalWeight += w;\r\n        }\r\n\r\n        // Normalize weights\r\n        for (let i = 0; i < weights.length; i++) {\r\n            weights[i] /= totalWeight;\r\n        }\r\n\r\n        // Optimize: combine samples to take advantage of hardware linear sampling\r\n        // Walk from left to center, combining pairs (symmetrically)\r\n        const linearSamplingWeights = [];\r\n        const linearSamplingOffsets = [];\r\n\r\n        const linearSamplingMap = [];\r\n\r\n        for (let i = 0; i <= centerIndex; i += 2) {\r\n            const j = Math.min(i + 1, Math.floor(centerIndex));\r\n\r\n            const singleCenterSample = i === j;\r\n\r\n            if (singleCenterSample) {\r\n                linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n            } else {\r\n                const sharedCell = j === centerIndex;\r\n\r\n                const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);\r\n                const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\r\n\r\n                if (offsetLinear === 0) {\r\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\r\n                    linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\r\n                } else {\r\n                    linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\r\n                    linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < linearSamplingMap.length; i++) {\r\n            linearSamplingOffsets[i] = linearSamplingMap[i].o;\r\n            linearSamplingWeights[i] = linearSamplingMap[i].w;\r\n        }\r\n\r\n        // Replace with optimized\r\n        offsets = linearSamplingOffsets;\r\n        weights = linearSamplingWeights;\r\n\r\n        // Generate shaders\r\n        const maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\r\n        const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1; // Because of sampleCenter\r\n\r\n        let varyingCount = Math.min(offsets.length, freeVaryingVec2);\r\n\r\n        let defines = \"\";\r\n        defines += this._staticDefines;\r\n\r\n        // The DOF fragment should ignore the center pixel when looping as it is handled manually in the fragment shader.\r\n        if (this._staticDefines.indexOf(\"DOF\") != -1) {\r\n            defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}\\r\\n`;\r\n            varyingCount--;\r\n        }\r\n\r\n        for (let i = 0; i < varyingCount; i++) {\r\n            defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}\\r\\n`;\r\n            defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}\\r\\n`;\r\n        }\r\n\r\n        let depCount = 0;\r\n        for (let i = freeVaryingVec2; i < offsets.length; i++) {\r\n            defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}\\r\\n`;\r\n            defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}\\r\\n`;\r\n            depCount++;\r\n        }\r\n\r\n        if (this.packedFloat) {\r\n            defines += `#define PACKEDFLOAT 1`;\r\n        }\r\n\r\n        this._blockCompilation = false;\r\n        super.updateEffect(\r\n            defines,\r\n            null,\r\n            null,\r\n            {\r\n                varyingCount: varyingCount,\r\n                depCount: depCount,\r\n            },\r\n            onCompiled,\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\r\n     * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\r\n     * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\r\n     * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\r\n     * The gaps between physical kernels are compensated for in the weighting of the samples\r\n     * @param idealKernel Ideal blur kernel.\r\n     * @returns Nearest best kernel.\r\n     */\r\n    protected _nearestBestKernel(idealKernel: number): number {\r\n        const v = Math.round(idealKernel);\r\n        for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {\r\n            if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {\r\n                return Math.max(k, 3);\r\n            }\r\n        }\r\n        return Math.max(v, 3);\r\n    }\r\n\r\n    /**\r\n     * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\r\n     * @param x The point on the Gaussian distribution to sample.\r\n     * @returns the value of the Gaussian function at x.\r\n     */\r\n    protected _gaussianWeight(x: number): number {\r\n        //reference: Engines/ImageProcessingBlur.cpp #dcc760\r\n        // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\r\n        // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\r\n        // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\r\n        // truncated at around 1.3% of peak strength.\r\n\r\n        //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\r\n        const sigma = 1 / 3;\r\n        const denominator = Math.sqrt(2.0 * Math.PI) * sigma;\r\n        const exponent = -((x * x) / (2.0 * sigma * sigma));\r\n        const weight = (1.0 / denominator) * Math.exp(exponent);\r\n        return weight;\r\n    }\r\n\r\n    /**\r\n     * Generates a string that can be used as a floating point number in GLSL.\r\n     * @param x Value to print.\r\n     * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\r\n     * @returns GLSL float string.\r\n     */\r\n    protected _glslFloat(x: number, decimalFigures = 8) {\r\n        return x.toFixed(decimalFigures).replace(/0+$/, \"\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string): Nullable<BlurPostProcess> {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new BlurPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.direction,\r\n                    parsedPostProcess.kernel,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.reusable,\r\n                    parsedPostProcess.textureType,\r\n                    undefined,\r\n                    false\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.BlurPostProcess\", BlurPostProcess);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}