{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\n\n/**\n * PostProcessManager is used to manage one or more post processes or post process pipelines\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\n */\nexport class PostProcessManager {\n  /**\n   * Creates a new instance PostProcess\n   * @param scene The scene that the post process is associated with.\n   */\n  constructor(scene) {\n    this._vertexBuffers = {};\n    this._scene = scene;\n  }\n  _prepareBuffers() {\n    if (this._vertexBuffers[VertexBuffer.PositionKind]) {\n      return;\n    }\n    // VBO\n    const vertices = [];\n    vertices.push(1, 1);\n    vertices.push(-1, 1);\n    vertices.push(-1, -1);\n    vertices.push(1, -1);\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);\n    this._buildIndexBuffer();\n  }\n  _buildIndexBuffer() {\n    // Indices\n    const indices = [];\n    indices.push(0);\n    indices.push(1);\n    indices.push(2);\n    indices.push(0);\n    indices.push(2);\n    indices.push(3);\n    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n  }\n  /**\n   * Rebuilds the vertex buffers of the manager.\n   * @internal\n   */\n  _rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (!vb) {\n      return;\n    }\n    vb._rebuild();\n    this._buildIndexBuffer();\n  }\n  // Methods\n  /**\n   * Prepares a frame to be run through a post process.\n   * @param sourceTexture The input texture to the post processes. (default: null)\n   * @param postProcesses An array of post processes to be run. (default: null)\n   * @returns True if the post processes were able to be run.\n   * @internal\n   */\n  _prepareFrame(sourceTexture = null, postProcesses = null) {\n    const camera = this._scene.activeCamera;\n    if (!camera) {\n      return false;\n    }\n    postProcesses = postProcesses || camera._postProcesses.filter(pp => {\n      return pp != null;\n    });\n    if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\n      return false;\n    }\n    postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\n    return true;\n  }\n  /**\n   * Manually render a set of post processes to a texture.\n   * Please note, the frame buffer won't be unbound after the call in case you have more render to do.\n   * @param postProcesses An array of post processes to be run.\n   * @param targetTexture The render target wrapper to render to.\n   * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight\n   * @param faceIndex defines the face to render to if a cubemap is defined as the target\n   * @param lodLevel defines which lod of the texture to render to\n   * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously\n   */\n  directRender(postProcesses, targetTexture = null, forceFullscreenViewport = false, faceIndex = 0, lodLevel = 0, doNotBindFrambuffer = false) {\n    var _a;\n    const engine = this._scene.getEngine();\n    for (let index = 0; index < postProcesses.length; index++) {\n      if (index < postProcesses.length - 1) {\n        postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);\n      } else {\n        if (targetTexture) {\n          engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport, lodLevel);\n        } else if (!doNotBindFrambuffer) {\n          engine.restoreDefaultFramebuffer();\n        }\n        (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);\n      }\n      const pp = postProcesses[index];\n      const effect = pp.apply();\n      if (effect) {\n        pp.onBeforeRenderObservable.notifyObservers(effect);\n        // VBOs\n        this._prepareBuffers();\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n        // Draw order\n        engine.drawElementsType(0, 0, 6);\n        pp.onAfterRenderObservable.notifyObservers(effect);\n      }\n    }\n    // Restore depth buffer\n    engine.setDepthBuffer(true);\n    engine.setDepthWrite(true);\n  }\n  /**\n   * Finalize the result of the output of the postprocesses.\n   * @param doNotPresent If true the result will not be displayed to the screen.\n   * @param targetTexture The render target wrapper to render to.\n   * @param faceIndex The index of the face to bind the target texture to.\n   * @param postProcesses The array of post processes to render.\n   * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)\n   * @internal\n   */\n  _finalizeFrame(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport = false) {\n    var _a;\n    const camera = this._scene.activeCamera;\n    if (!camera) {\n      return;\n    }\n    postProcesses = postProcesses || camera._postProcesses.filter(pp => {\n      return pp != null;\n    });\n    if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\n      return;\n    }\n    const engine = this._scene.getEngine();\n    for (let index = 0, len = postProcesses.length; index < len; index++) {\n      const pp = postProcesses[index];\n      if (index < len - 1) {\n        pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);\n      } else {\n        if (targetTexture) {\n          engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport);\n          pp._outputTexture = targetTexture;\n        } else {\n          engine.restoreDefaultFramebuffer();\n          pp._outputTexture = null;\n        }\n        (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);\n      }\n      if (doNotPresent) {\n        break;\n      }\n      const effect = pp.apply();\n      if (effect) {\n        pp.onBeforeRenderObservable.notifyObservers(effect);\n        // VBOs\n        this._prepareBuffers();\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n        // Draw order\n        engine.drawElementsType(0, 0, 6);\n        pp.onAfterRenderObservable.notifyObservers(effect);\n      }\n    }\n    // Restore states\n    engine.setDepthBuffer(true);\n    engine.setDepthWrite(true);\n    engine.setAlphaMode(0);\n  }\n  /**\n   * Disposes of the post process manager.\n   */\n  dispose() {\n    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (buffer) {\n      buffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    if (this._indexBuffer) {\n      this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n      this._indexBuffer = null;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["VertexBuffer","PostProcessManager","constructor","scene","_scene","_prepareBuffers","_vertexBuffers","PositionKind","vertices","push","getEngine","_buildIndexBuffer","indices","_indexBuffer","createIndexBuffer","_rebuild","vb","_prepareFrame","sourceTexture","postProcesses","camera","activeCamera","_postProcesses","filter","pp","length","postProcessesEnabled","activate","undefined","directRender","targetTexture","forceFullscreenViewport","faceIndex","lodLevel","doNotBindFrambuffer","engine","index","texture","bindFramebuffer","restoreDefaultFramebuffer","_debugInsertMarker","name","effect","apply","onBeforeRenderObservable","notifyObservers","bindBuffers","drawElementsType","onAfterRenderObservable","setDepthBuffer","setDepthWrite","_finalizeFrame","doNotPresent","len","_outputTexture","setAlphaMode","dispose","buffer","_releaseBuffer"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/postProcessManager.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport type { PostProcess } from \"./postProcess\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * PostProcessManager is used to manage one or more post processes or post process pipelines\r\n * See https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses\r\n */\r\nexport class PostProcessManager {\r\n    private _scene: Scene;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n\r\n    /**\r\n     * Creates a new instance PostProcess\r\n     * @param scene The scene that the post process is associated with.\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _prepareBuffers(): void {\r\n        if (this._vertexBuffers[VertexBuffer.PositionKind]) {\r\n            return;\r\n        }\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    private _buildIndexBuffer(): void {\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the vertex buffers of the manager.\r\n     * @internal\r\n     */\r\n    public _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (!vb) {\r\n            return;\r\n        }\r\n        vb._rebuild();\r\n        this._buildIndexBuffer();\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Prepares a frame to be run through a post process.\r\n     * @param sourceTexture The input texture to the post processes. (default: null)\r\n     * @param postProcesses An array of post processes to be run. (default: null)\r\n     * @returns True if the post processes were able to be run.\r\n     * @internal\r\n     */\r\n    public _prepareFrame(sourceTexture: Nullable<InternalTexture> = null, postProcesses: Nullable<PostProcess[]> = null): boolean {\r\n        const camera = this._scene.activeCamera;\r\n        if (!camera) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses = postProcesses || <Nullable<PostProcess[]>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n\r\n        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return false;\r\n        }\r\n\r\n        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually render a set of post processes to a texture.\r\n     * Please note, the frame buffer won't be unbound after the call in case you have more render to do.\r\n     * @param postProcesses An array of post processes to be run.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight\r\n     * @param faceIndex defines the face to render to if a cubemap is defined as the target\r\n     * @param lodLevel defines which lod of the texture to render to\r\n     * @param doNotBindFrambuffer If set to true, assumes that the framebuffer has been bound previously\r\n     */\r\n    public directRender(\r\n        postProcesses: PostProcess[],\r\n        targetTexture: Nullable<RenderTargetWrapper> = null,\r\n        forceFullscreenViewport = false,\r\n        faceIndex = 0,\r\n        lodLevel = 0,\r\n        doNotBindFrambuffer = false\r\n    ): void {\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0; index < postProcesses.length; index++) {\r\n            if (index < postProcesses.length - 1) {\r\n                postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport, lodLevel);\r\n                } else if (!doNotBindFrambuffer) {\r\n                    engine.restoreDefaultFramebuffer();\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            const pp = postProcesses[index];\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore depth buffer\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    /**\r\n     * Finalize the result of the output of the postprocesses.\r\n     * @param doNotPresent If true the result will not be displayed to the screen.\r\n     * @param targetTexture The render target wrapper to render to.\r\n     * @param faceIndex The index of the face to bind the target texture to.\r\n     * @param postProcesses The array of post processes to render.\r\n     * @param forceFullscreenViewport force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)\r\n     * @internal\r\n     */\r\n    public _finalizeFrame(\r\n        doNotPresent?: boolean,\r\n        targetTexture?: RenderTargetWrapper,\r\n        faceIndex?: number,\r\n        postProcesses?: Array<PostProcess>,\r\n        forceFullscreenViewport = false\r\n    ): void {\r\n        const camera = this._scene.activeCamera;\r\n\r\n        if (!camera) {\r\n            return;\r\n        }\r\n\r\n        postProcesses = postProcesses || <Array<PostProcess>>camera._postProcesses.filter((pp) => {\r\n                return pp != null;\r\n            });\r\n        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\r\n            return;\r\n        }\r\n        const engine = this._scene.getEngine();\r\n\r\n        for (let index = 0, len = postProcesses.length; index < len; index++) {\r\n            const pp = postProcesses[index];\r\n\r\n            if (index < len - 1) {\r\n                pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture?.texture);\r\n            } else {\r\n                if (targetTexture) {\r\n                    engine.bindFramebuffer(targetTexture, faceIndex, undefined, undefined, forceFullscreenViewport);\r\n                    pp._outputTexture = targetTexture;\r\n                } else {\r\n                    engine.restoreDefaultFramebuffer();\r\n                    pp._outputTexture = null;\r\n                }\r\n                engine._debugInsertMarker?.(`post process ${postProcesses[index].name} output`);\r\n            }\r\n\r\n            if (doNotPresent) {\r\n                break;\r\n            }\r\n\r\n            const effect = pp.apply();\r\n\r\n            if (effect) {\r\n                pp.onBeforeRenderObservable.notifyObservers(effect);\r\n\r\n                // VBOs\r\n                this._prepareBuffers();\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Constants.MATERIAL_TriangleFillMode, 0, 6);\r\n\r\n                pp.onAfterRenderObservable.notifyObservers(effect);\r\n            }\r\n        }\r\n\r\n        // Restore states\r\n        engine.setDepthBuffer(true);\r\n        engine.setDepthWrite(true);\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n    }\r\n\r\n    /**\r\n     * Disposes of the post process manager.\r\n     */\r\n    public dispose(): void {\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer) {\r\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n            this._indexBuffer = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}