{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Vector3, Matrix, Quaternion } from \"../../../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { PhysicsImpostor } from \"..//physicsImpostor.js\";\nimport { PhysicsJoint } from \"../physicsJoint.js\";\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult.js\";\nimport { PhysicsEngine } from \"../physicsEngine.js\";\nimport { Epsilon } from \"../../../Maths/math.constants.js\";\n/** @internal */\nexport class CannonJSPlugin {\n  constructor(_useDeltaForWorldStep = true, iterations = 10, cannonInjection = CANNON) {\n    this._useDeltaForWorldStep = _useDeltaForWorldStep;\n    this.name = \"CannonJSPlugin\";\n    this._physicsMaterials = new Array();\n    this._fixedTimeStep = 1 / 60;\n    this._physicsBodiesToRemoveAfterStep = new Array();\n    this._firstFrame = true;\n    this._tmpQuaternion = new Quaternion();\n    this._minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n    this._tmpPosition = Vector3.Zero();\n    this._tmpDeltaPosition = Vector3.Zero();\n    this._tmpUnityRotation = new Quaternion();\n    this.BJSCANNON = cannonInjection;\n    if (!this.isSupported()) {\n      Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    this._extendNamespace();\n    this.world = new this.BJSCANNON.World();\n    this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\n    this.world.solver.iterations = iterations;\n    this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\n    this._raycastResult = new PhysicsRaycastResult();\n  }\n  /**\n   *\n   * @returns plugin version\n   */\n  getPluginVersion() {\n    return 1;\n  }\n  setGravity(gravity) {\n    const vec = gravity;\n    this.world.gravity.set(vec.x, vec.y, vec.z);\n  }\n  setTimeStep(timeStep) {\n    this._fixedTimeStep = timeStep;\n  }\n  getTimeStep() {\n    return this._fixedTimeStep;\n  }\n  executeStep(delta, impostors) {\n    // due to cannon's architecture, the first frame's before-step is skipped.\n    if (this._firstFrame) {\n      this._firstFrame = false;\n      for (const impostor of impostors) {\n        if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\n          impostor.beforeStep();\n        }\n      }\n    }\n    this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\n    this._removeMarkedPhysicsBodiesFromWorld();\n  }\n  _removeMarkedPhysicsBodiesFromWorld() {\n    if (this._physicsBodiesToRemoveAfterStep.length > 0) {\n      this._physicsBodiesToRemoveAfterStep.forEach(physicsBody => {\n        if (typeof this.world.removeBody === \"function\") {\n          this.world.removeBody(physicsBody);\n        } else {\n          this.world.remove(physicsBody);\n        }\n      });\n      this._physicsBodiesToRemoveAfterStep.length = 0;\n    }\n  }\n  applyImpulse(impostor, force, contactPoint) {\n    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyImpulse(impulse, worldPoint);\n  }\n  applyForce(impostor, force, contactPoint) {\n    const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n    const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\n    impostor.physicsBody.applyForce(impulse, worldPoint);\n  }\n  generatePhysicsBody(impostor) {\n    // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\n    this._removeMarkedPhysicsBodiesFromWorld();\n    //parent-child relationship. Does this impostor have a parent impostor?\n    if (impostor.parent) {\n      if (impostor.physicsBody) {\n        this.removePhysicsBody(impostor);\n        //TODO is that needed?\n        impostor.forceUpdate();\n      }\n      return;\n    }\n    //should a new body be created for this impostor?\n    if (impostor.isBodyInitRequired()) {\n      const shape = this._createShape(impostor);\n      if (!shape) {\n        Logger.Warn(\"It was not possible to create a physics body for this object.\");\n        return;\n      }\n      //unregister events if body is being changed\n      const oldBody = impostor.physicsBody;\n      if (oldBody) {\n        this.removePhysicsBody(impostor);\n      }\n      //create the body and material\n      const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n      const bodyCreationObject = {\n        mass: impostor.getParam(\"mass\"),\n        material: material\n      };\n      // A simple extend, in case native options were used.\n      const nativeOptions = impostor.getParam(\"nativeOptions\");\n      for (const key in nativeOptions) {\n        if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\n          bodyCreationObject[key] = nativeOptions[key];\n        }\n      }\n      impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\n      impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n      this.world.addEventListener(\"preStep\", impostor.beforeStep);\n      this.world.addEventListener(\"postStep\", impostor.afterStep);\n      impostor.physicsBody.addShape(shape);\n      if (typeof this.world.addBody === \"function\") {\n        this.world.addBody(impostor.physicsBody);\n      } else {\n        this.world.add(impostor.physicsBody);\n      }\n      //try to keep the body moving in the right direction by taking old properties.\n      //Should be tested!\n      if (oldBody) {\n        [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\n          const vec = oldBody[param];\n          impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\n        });\n      }\n      this._processChildMeshes(impostor);\n    }\n    //now update the body's transformation\n    this._updatePhysicsBodyTransformation(impostor);\n  }\n  _processChildMeshes(mainImpostor) {\n    const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\n    const mainRotation = mainImpostor.object.rotationQuaternion;\n    if (mainRotation) {\n      mainRotation.conjugateToRef(this._tmpQuaternion);\n    } else {\n      this._tmpQuaternion.set(0, 0, 0, 1);\n    }\n    if (meshChildren.length) {\n      const processMesh = mesh => {\n        if (!mesh.rotationQuaternion) {\n          return;\n        }\n        const childImpostor = mesh.getPhysicsImpostor();\n        if (childImpostor) {\n          const parent = childImpostor.parent;\n          if (parent !== mainImpostor && mesh.parent) {\n            const pPosition = mesh.getAbsolutePosition().subtract(mesh.parent.getAbsolutePosition());\n            const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\n            if (childImpostor.physicsBody) {\n              this.removePhysicsBody(childImpostor);\n              childImpostor.physicsBody = null;\n            }\n            childImpostor.parent = mainImpostor;\n            childImpostor.resetUpdateFlags();\n            mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w));\n            //Add the mass of the children.\n            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n          }\n        }\n        mesh.getChildMeshes(true).filter(m => !!m.physicsImpostor).forEach(processMesh);\n      };\n      meshChildren.filter(m => !!m.physicsImpostor).forEach(processMesh);\n    }\n  }\n  removePhysicsBody(impostor) {\n    impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n    this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n    this.world.removeEventListener(\"postStep\", impostor.afterStep);\n    // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\n    if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\n      this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);\n    }\n  }\n  generateJoint(impostorJoint) {\n    const mainBody = impostorJoint.mainImpostor.physicsBody;\n    const connectedBody = impostorJoint.connectedImpostor.physicsBody;\n    if (!mainBody || !connectedBody) {\n      return;\n    }\n    let constraint;\n    const jointData = impostorJoint.joint.jointData;\n    //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\n    const constraintData = {\n      pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\n      pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\n      axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\n      axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\n      maxForce: jointData.nativeParams.maxForce,\n      collideConnected: !!jointData.collision\n    };\n    switch (impostorJoint.joint.type) {\n      case PhysicsJoint.HingeJoint:\n      case PhysicsJoint.Hinge2Joint:\n        constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n        break;\n      case PhysicsJoint.DistanceJoint:\n        constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n        break;\n      case PhysicsJoint.SpringJoint:\n        {\n          const springData = jointData;\n          constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\n            restLength: springData.length,\n            stiffness: springData.stiffness,\n            damping: springData.damping,\n            localAnchorA: constraintData.pivotA,\n            localAnchorB: constraintData.pivotB\n          });\n          break;\n        }\n      case PhysicsJoint.LockJoint:\n        constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\n        break;\n      case PhysicsJoint.PointToPointJoint:\n      case PhysicsJoint.BallAndSocketJoint:\n      default:\n        constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\n        break;\n    }\n    //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n    constraint.collideConnected = !!jointData.collision;\n    impostorJoint.joint.physicsJoint = constraint;\n    //don't add spring as constraint, as it is not one.\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.addConstraint(constraint);\n    } else {\n      impostorJoint.joint.jointData.forceApplicationCallback = impostorJoint.joint.jointData.forceApplicationCallback || function () {\n        constraint.applyForce();\n      };\n      impostorJoint.mainImpostor.registerAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  }\n  removeJoint(impostorJoint) {\n    if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\n      this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n    } else {\n      impostorJoint.mainImpostor.unregisterAfterPhysicsStep(impostorJoint.joint.jointData.forceApplicationCallback);\n    }\n  }\n  _addMaterial(name, friction, restitution) {\n    let index;\n    let mat;\n    for (index = 0; index < this._physicsMaterials.length; index++) {\n      mat = this._physicsMaterials[index];\n      if (mat.friction === friction && mat.restitution === restitution) {\n        return mat;\n      }\n    }\n    const currentMat = new this.BJSCANNON.Material(name);\n    currentMat.friction = friction;\n    currentMat.restitution = restitution;\n    this._physicsMaterials.push(currentMat);\n    return currentMat;\n  }\n  _checkWithEpsilon(value) {\n    return value < Epsilon ? Epsilon : value;\n  }\n  _createShape(impostor) {\n    const object = impostor.object;\n    let returnValue;\n    const impostorExtents = impostor.getObjectExtents();\n    switch (impostor.type) {\n      case PhysicsImpostor.SphereImpostor:\n        {\n          const radiusX = impostorExtents.x;\n          const radiusY = impostorExtents.y;\n          const radiusZ = impostorExtents.z;\n          returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n          break;\n        }\n      //TMP also for cylinder - TODO Cannon supports cylinder natively.\n      case PhysicsImpostor.CylinderImpostor:\n        {\n          let nativeParams = impostor.getParam(\"nativeOptions\");\n          if (!nativeParams) {\n            nativeParams = {};\n          }\n          const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;\n          const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;\n          const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);\n          const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\n          returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\n          // Rotate 90 degrees as this shape is horizontal in cannon\n          const quat = new this.BJSCANNON.Quaternion();\n          quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\n          const translation = new this.BJSCANNON.Vec3(0, 0, 0);\n          returnValue.transformAllPoints(translation, quat);\n          break;\n        }\n      case PhysicsImpostor.BoxImpostor:\n        {\n          const box = impostorExtents.scale(0.5);\n          returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n          break;\n        }\n      case PhysicsImpostor.PlaneImpostor:\n        Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n        returnValue = new this.BJSCANNON.Plane();\n        break;\n      case PhysicsImpostor.MeshImpostor:\n        {\n          // should transform the vertex data to world coordinates!!\n          const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\n          const rawFaces = object.getIndices ? object.getIndices() : [];\n          if (!rawVerts) {\n            Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\n            return;\n          }\n          // get only scale! so the object could transform correctly.\n          const oldPosition = object.position.clone();\n          const oldRotation = object.rotation && object.rotation.clone();\n          const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          const transform = object.computeWorldMatrix(true);\n          // convert rawVerts to object space\n          const transformedVertices = new Array();\n          let index;\n          for (index = 0; index < rawVerts.length; index += 3) {\n            Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);\n          }\n          Logger.Warn(\"MeshImpostor only collides against spheres.\");\n          returnValue = new this.BJSCANNON.Trimesh(transformedVertices, rawFaces);\n          //now set back the transformation!\n          object.position.copyFrom(oldPosition);\n          oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\n          oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\n          break;\n        }\n      case PhysicsImpostor.HeightmapImpostor:\n        {\n          const oldPosition2 = object.position.clone();\n          const oldRotation2 = object.rotation && object.rotation.clone();\n          const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\n          object.position.copyFromFloats(0, 0, 0);\n          object.rotation && object.rotation.copyFromFloats(0, 0, 0);\n          object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\n          object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\n          object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\n          returnValue = this._createHeightmap(object);\n          object.position.copyFrom(oldPosition2);\n          oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\n          oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\n          object.computeWorldMatrix(true);\n          break;\n        }\n      case PhysicsImpostor.ParticleImpostor:\n        returnValue = new this.BJSCANNON.Particle();\n        break;\n      case PhysicsImpostor.NoImpostor:\n        returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\n        break;\n    }\n    return returnValue;\n  }\n  _createHeightmap(object, pointDepth) {\n    let pos = object.getVerticesData(VertexBuffer.PositionKind);\n    const transform = object.computeWorldMatrix(true);\n    // convert rawVerts to object space\n    const transformedVertices = new Array();\n    let index;\n    for (index = 0; index < pos.length; index += 3) {\n      Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);\n    }\n    pos = transformedVertices;\n    const matrix = new Array();\n    //For now pointDepth will not be used and will be automatically calculated.\n    //Future reference - try and find the best place to add a reference to the pointDepth variable.\n    const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n    const boundingInfo = object.getBoundingInfo();\n    const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\n    const minY = boundingInfo.boundingBox.extendSizeWorld.z;\n    const elementSize = dim * 2 / arraySize;\n    for (let i = 0; i < pos.length; i = i + 3) {\n      const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\n      const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\n      const y = -pos[i + 2] + minY;\n      if (!matrix[x]) {\n        matrix[x] = [];\n      }\n      if (!matrix[x][z]) {\n        matrix[x][z] = y;\n      }\n      matrix[x][z] = Math.max(y, matrix[x][z]);\n    }\n    for (let x = 0; x <= arraySize; ++x) {\n      if (!matrix[x]) {\n        let loc = 1;\n        while (!matrix[(x + loc) % arraySize]) {\n          loc++;\n        }\n        matrix[x] = matrix[(x + loc) % arraySize].slice();\n        //console.log(\"missing x\", x);\n      }\n\n      for (let z = 0; z <= arraySize; ++z) {\n        if (!matrix[x][z]) {\n          let loc = 1;\n          let newValue;\n          while (newValue === undefined) {\n            newValue = matrix[x][(z + loc++) % arraySize];\n          }\n          matrix[x][z] = newValue;\n        }\n      }\n    }\n    const shape = new this.BJSCANNON.Heightfield(matrix, {\n      elementSize: elementSize\n    });\n    //For future reference, needed for body transformation\n    shape.minY = minY;\n    return shape;\n  }\n  _updatePhysicsBodyTransformation(impostor) {\n    const object = impostor.object;\n    //make sure it is updated...\n    object.computeWorldMatrix && object.computeWorldMatrix(true);\n    if (!object.getBoundingInfo()) {\n      return;\n    }\n    const center = impostor.getObjectCenter();\n    //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\n    // The delta between the mesh position and the mesh bounding box center\n    this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\n    this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\n    this._tmpPosition.copyFrom(center);\n    let quaternion = object.rotationQuaternion;\n    if (!quaternion) {\n      return;\n    }\n    //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n    //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\n    if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      //-90 DEG in X, precalculated\n      quaternion = quaternion.multiply(this._minus90X);\n      //Invert! (Precalculated, 90 deg in X)\n      //No need to clone. this will never change.\n      impostor.setDeltaRotation(this._plus90X);\n    }\n    //If it is a heightfield, if should be centered.\n    if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\n      const mesh = object;\n      let boundingInfo = mesh.getBoundingInfo();\n      //calculate the correct body position:\n      const rotationQuaternion = mesh.rotationQuaternion;\n      mesh.rotationQuaternion = this._tmpUnityRotation;\n      mesh.computeWorldMatrix(true);\n      //get original center with no rotation\n      const c = center.clone();\n      let oldPivot = mesh.getPivotMatrix();\n      if (oldPivot) {\n        // create a copy the pivot Matrix as it is modified in place\n        oldPivot = oldPivot.clone();\n      } else {\n        oldPivot = Matrix.Identity();\n      }\n      //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\n      const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\n      mesh.setPreTransformMatrix(p);\n      mesh.computeWorldMatrix(true);\n      // force bounding box recomputation\n      boundingInfo = mesh.getBoundingInfo();\n      //calculate the translation\n      const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n      this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\n      //add it inverted to the delta\n      this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\n      this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\n      //rotation is back\n      mesh.rotationQuaternion = rotationQuaternion;\n      mesh.setPreTransformMatrix(oldPivot);\n      mesh.computeWorldMatrix(true);\n    } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\n      this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n    }\n    impostor.setDeltaPosition(this._tmpDeltaPosition);\n    //Now update the impostor object\n    impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\n    impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n  }\n  setTransformationFromPhysicsBody(impostor) {\n    impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\n    if (impostor.object.rotationQuaternion) {\n      const q = impostor.physicsBody.quaternion;\n      impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\n    }\n  }\n  setPhysicsBodyTransformation(impostor, newPosition, newRotation) {\n    impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\n    impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\n  }\n  isSupported() {\n    return this.BJSCANNON !== undefined;\n  }\n  setLinearVelocity(impostor, velocity) {\n    impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  setAngularVelocity(impostor, velocity) {\n    impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\n  }\n  getLinearVelocity(impostor) {\n    const v = impostor.physicsBody.velocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  getAngularVelocity(impostor) {\n    const v = impostor.physicsBody.angularVelocity;\n    if (!v) {\n      return null;\n    }\n    return new Vector3(v.x, v.y, v.z);\n  }\n  setBodyMass(impostor, mass) {\n    impostor.physicsBody.mass = mass;\n    impostor.physicsBody.updateMassProperties();\n  }\n  getBodyMass(impostor) {\n    return impostor.physicsBody.mass;\n  }\n  getBodyFriction(impostor) {\n    return impostor.physicsBody.material.friction;\n  }\n  setBodyFriction(impostor, friction) {\n    impostor.physicsBody.material.friction = friction;\n  }\n  getBodyRestitution(impostor) {\n    return impostor.physicsBody.material.restitution;\n  }\n  setBodyRestitution(impostor, restitution) {\n    impostor.physicsBody.material.restitution = restitution;\n  }\n  sleepBody(impostor) {\n    impostor.physicsBody.sleep();\n  }\n  wakeUpBody(impostor) {\n    impostor.physicsBody.wakeUp();\n  }\n  updateDistanceJoint(joint, maxDistance) {\n    joint.physicsJoint.distance = maxDistance;\n  }\n  setMotor(joint, speed, maxForce, motorIndex) {\n    if (!motorIndex) {\n      joint.physicsJoint.enableMotor();\n      joint.physicsJoint.setMotorSpeed(speed);\n      if (maxForce) {\n        this.setLimit(joint, maxForce);\n      }\n    }\n  }\n  setLimit(joint, minForce, maxForce) {\n    joint.physicsJoint.motorEquation.maxForce = maxForce;\n    joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;\n  }\n  syncMeshWithImpostor(mesh, impostor) {\n    const body = impostor.physicsBody;\n    mesh.position.x = body.position.x;\n    mesh.position.y = body.position.y;\n    mesh.position.z = body.position.z;\n    if (mesh.rotationQuaternion) {\n      mesh.rotationQuaternion.x = body.quaternion.x;\n      mesh.rotationQuaternion.y = body.quaternion.y;\n      mesh.rotationQuaternion.z = body.quaternion.z;\n      mesh.rotationQuaternion.w = body.quaternion.w;\n    }\n  }\n  getRadius(impostor) {\n    const shape = impostor.physicsBody.shapes[0];\n    return shape.boundingSphereRadius;\n  }\n  getBoxSizeToRef(impostor, result) {\n    const shape = impostor.physicsBody.shapes[0];\n    result.x = shape.halfExtents.x * 2;\n    result.y = shape.halfExtents.y * 2;\n    result.z = shape.halfExtents.z * 2;\n  }\n  dispose() {}\n  _extendNamespace() {\n    //this will force cannon to execute at least one step when using interpolation\n    const step_tmp1 = new this.BJSCANNON.Vec3();\n    const engine = this.BJSCANNON;\n    this.BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {\n      maxSubSteps = maxSubSteps || 10;\n      timeSinceLastCalled = timeSinceLastCalled || 0;\n      if (timeSinceLastCalled === 0) {\n        this.internalStep(dt);\n        this.time += dt;\n      } else {\n        let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\n        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\n        const t0 = performance.now();\n        for (let i = 0; i !== internalSteps; i++) {\n          this.internalStep(dt);\n          if (performance.now() - t0 > dt * 1000) {\n            break;\n          }\n        }\n        this.time += timeSinceLastCalled;\n        const h = this.time % dt;\n        const h_div_dt = h / dt;\n        const interpvelo = step_tmp1;\n        const bodies = this.bodies;\n        for (let j = 0; j !== bodies.length; j++) {\n          const b = bodies[j];\n          if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\n            b.position.vsub(b.previousPosition, interpvelo);\n            interpvelo.scale(h_div_dt, interpvelo);\n            b.position.vadd(interpvelo, b.interpolatedPosition);\n          } else {\n            b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\n            b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\n          }\n        }\n      }\n    };\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @returns PhysicsRaycastResult\n   */\n  raycast(from, to) {\n    this._raycastResult.reset(from, to);\n    this.raycastToRef(from, to, this._raycastResult);\n    return this._raycastResult;\n  }\n  /**\n   * Does a raycast in the physics world\n   * @param from when should the ray start?\n   * @param to when should the ray end?\n   * @param result resulting PhysicsRaycastResult\n   */\n  raycastToRef(from, to, result) {\n    this._cannonRaycastResult.reset();\n    this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\n    result.reset(from, to);\n    if (this._cannonRaycastResult.hasHit) {\n      // TODO: do we also want to get the body it hit?\n      result.setHitData({\n        x: this._cannonRaycastResult.hitNormalWorld.x,\n        y: this._cannonRaycastResult.hitNormalWorld.y,\n        z: this._cannonRaycastResult.hitNormalWorld.z\n      }, {\n        x: this._cannonRaycastResult.hitPointWorld.x,\n        y: this._cannonRaycastResult.hitPointWorld.y,\n        z: this._cannonRaycastResult.hitPointWorld.z\n      });\n      result.setHitDistance(this._cannonRaycastResult.distance);\n    }\n  }\n}\nPhysicsEngine.DefaultPluginFactory = () => {\n  return new CannonJSPlugin();\n};","map":{"version":3,"mappings":"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","names":["Logger","Vector3","Matrix","Quaternion","VertexBuffer","PhysicsImpostor","PhysicsJoint","PhysicsRaycastResult","PhysicsEngine","Epsilon","CannonJSPlugin","constructor","_useDeltaForWorldStep","iterations","cannonInjection","CANNON","Array","Zero","BJSCANNON","isSupported","Error","_extendNamespace","world","World","broadphase","NaiveBroadphase","solver","_cannonRaycastResult","RaycastResult","_raycastResult","getPluginVersion","setGravity","gravity","vec","set","x","y","z","setTimeStep","timeStep","_fixedTimeStep","getTimeStep","executeStep","delta","impostors","_firstFrame","impostor","type","HeightmapImpostor","PlaneImpostor","beforeStep","step","_removeMarkedPhysicsBodiesFromWorld","_physicsBodiesToRemoveAfterStep","length","forEach","physicsBody","removeBody","remove","applyImpulse","force","contactPoint","worldPoint","Vec3","impulse","applyForce","generatePhysicsBody","parent","removePhysicsBody","forceUpdate","isBodyInitRequired","shape","_createShape","Warn","oldBody","material","_addMaterial","uniqueId","getParam","bodyCreationObject","mass","nativeOptions","key","Object","prototype","hasOwnProperty","call","Body","addEventListener","onCollide","afterStep","addShape","addBody","add","param","_processChildMeshes","_updatePhysicsBodyTransformation","mainImpostor","meshChildren","object","getChildMeshes","mainRotation","rotationQuaternion","conjugateToRef","_tmpQuaternion","processMesh","mesh","childImpostor","getPhysicsImpostor","pPosition","getAbsolutePosition","subtract","q","multiply","resetUpdateFlags","w","filter","m","physicsImpostor","removeEventListener","indexOf","push","generateJoint","impostorJoint","mainBody","connectedBody","connectedImpostor","constraint","jointData","joint","constraintData","pivotA","mainPivot","pivotB","connectedPivot","axisA","mainAxis","axisB","connectedAxis","maxForce","nativeParams","collideConnected","collision","HingeJoint","Hinge2Joint","HingeConstraint","DistanceJoint","DistanceConstraint","maxDistance","SpringJoint","springData","Spring","restLength","stiffness","damping","localAnchorA","localAnchorB","LockJoint","LockConstraint","PointToPointJoint","BallAndSocketJoint","PointToPointConstraint","physicsJoint","addConstraint","forceApplicationCallback","registerAfterPhysicsStep","removeJoint","removeConstraint","unregisterAfterPhysicsStep","name","friction","restitution","index","mat","_physicsMaterials","currentMat","Material","_checkWithEpsilon","value","returnValue","impostorExtents","getObjectExtents","SphereImpostor","radiusX","radiusY","radiusZ","Sphere","Math","max","CylinderImpostor","radiusTop","undefined","radiusBottom","height","numSegments","Cylinder","quat","setFromAxisAngle","PI","translation","transformAllPoints","BoxImpostor","box","scale","Box","Plane","MeshImpostor","rawVerts","getVerticesData","PositionKind","rawFaces","getIndices","oldPosition","position","clone","oldRotation","rotation","oldQuaternion","copyFromFloats","copyFrom","getParentsRotation","conjugateInPlace","transform","computeWorldMatrix","transformedVertices","TransformCoordinates","FromArray","toArray","Trimesh","oldPosition2","oldRotation2","oldQuaternion2","multiplyInPlace","_minus90X","_createHeightmap","ParticleImpostor","Particle","NoImpostor","pointDepth","pos","matrix","arraySize","sqrt","boundingInfo","getBoundingInfo","dim","min","boundingBox","extendSizeWorld","minY","elementSize","i","round","loc","slice","newValue","Heightfield","center","getObjectCenter","_tmpDeltaPosition","getAbsolutePivotPoint","divideInPlace","scaling","_tmpPosition","quaternion","setDeltaRotation","_plus90X","_tmpUnityRotation","c","oldPivot","getPivotMatrix","Identity","p","Translation","setPreTransformMatrix","centerWorld","negate","setDeltaPosition","setTransformationFromPhysicsBody","setPhysicsBodyTransformation","newPosition","newRotation","setLinearVelocity","velocity","setAngularVelocity","angularVelocity","getLinearVelocity","v","getAngularVelocity","setBodyMass","updateMassProperties","getBodyMass","getBodyFriction","setBodyFriction","getBodyRestitution","setBodyRestitution","sleepBody","sleep","wakeUpBody","wakeUp","updateDistanceJoint","distance","setMotor","speed","motorIndex","enableMotor","setMotorSpeed","setLimit","minForce","motorEquation","syncMeshWithImpostor","body","getRadius","shapes","boundingSphereRadius","getBoxSizeToRef","result","halfExtents","dispose","step_tmp1","engine","dt","timeSinceLastCalled","maxSubSteps","internalStep","time","internalSteps","floor","t0","performance","now","h","h_div_dt","interpvelo","bodies","j","b","STATIC","sleepState","SLEEPING","vsub","previousPosition","vadd","interpolatedPosition","interpolatedQuaternion","raycast","from","to","reset","raycastToRef","raycastClosest","hasHit","setHitData","hitNormalWorld","hitPointWorld","setHitDistance","DefaultPluginFactory"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Physics/v1/Plugins/cannonJSPlugin.ts"],"sourcesContent":["import type { Nullable, FloatArray } from \"../../../types\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Vector3, Matrix, Quaternion } from \"../../../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { IPhysicsEnginePlugin, PhysicsImpostorJoint } from \"../IPhysicsEnginePlugin\";\r\nimport type { IPhysicsEnabledObject } from \"..//physicsImpostor\";\r\nimport { PhysicsImpostor } from \"..//physicsImpostor\";\r\nimport type { IMotorEnabledJoint, DistanceJointData, SpringJointData } from \"../physicsJoint\";\r\nimport { PhysicsJoint } from \"../physicsJoint\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport type { TransformNode } from \"../../../Meshes/transformNode\";\r\nimport { PhysicsEngine } from \"../physicsEngine\";\r\nimport { Epsilon } from \"../../../Maths/math.constants\";\r\n\r\n//declare var require: any;\r\ndeclare let CANNON: any;\r\n\r\n/** @internal */\r\nexport class CannonJSPlugin implements IPhysicsEnginePlugin {\r\n    public world: any;\r\n    public name: string = \"CannonJSPlugin\";\r\n    private _physicsMaterials = new Array();\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _cannonRaycastResult: any;\r\n    private _raycastResult: PhysicsRaycastResult;\r\n    private _physicsBodiesToRemoveAfterStep = new Array<any>();\r\n    private _firstFrame = true;\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public BJSCANNON: any;\r\n\r\n    public constructor(private _useDeltaForWorldStep: boolean = true, iterations: number = 10, cannonInjection = CANNON) {\r\n        this.BJSCANNON = cannonInjection;\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"CannonJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n\r\n        this._extendNamespace();\r\n\r\n        this.world = new this.BJSCANNON.World();\r\n        this.world.broadphase = new this.BJSCANNON.NaiveBroadphase();\r\n        this.world.solver.iterations = iterations;\r\n        this._cannonRaycastResult = new this.BJSCANNON.RaycastResult();\r\n        this._raycastResult = new PhysicsRaycastResult();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @returns plugin version\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 1;\r\n    }\r\n\r\n    public setGravity(gravity: Vector3): void {\r\n        const vec = gravity;\r\n        this.world.gravity.set(vec.x, vec.y, vec.z);\r\n    }\r\n\r\n    public setTimeStep(timeStep: number) {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    public executeStep(delta: number, impostors: Array<PhysicsImpostor>): void {\r\n        // due to cannon's architecture, the first frame's before-step is skipped.\r\n        if (this._firstFrame) {\r\n            this._firstFrame = false;\r\n            for (const impostor of impostors) {\r\n                if (!(impostor.type == PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.PlaneImpostor)) {\r\n                    impostor.beforeStep();\r\n                }\r\n            }\r\n        }\r\n        this.world.step(this._useDeltaForWorldStep ? delta : this._fixedTimeStep);\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n    }\r\n\r\n    private _removeMarkedPhysicsBodiesFromWorld(): void {\r\n        if (this._physicsBodiesToRemoveAfterStep.length > 0) {\r\n            this._physicsBodiesToRemoveAfterStep.forEach((physicsBody) => {\r\n                if (typeof this.world.removeBody === \"function\") {\r\n                    this.world.removeBody(physicsBody);\r\n                } else {\r\n                    this.world.remove(physicsBody);\r\n                }\r\n            });\r\n            this._physicsBodiesToRemoveAfterStep.length = 0;\r\n        }\r\n    }\r\n\r\n    public applyImpulse(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyImpulse(impulse, worldPoint);\r\n    }\r\n\r\n    public applyForce(impostor: PhysicsImpostor, force: Vector3, contactPoint: Vector3) {\r\n        const worldPoint = new this.BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\r\n        const impulse = new this.BJSCANNON.Vec3(force.x, force.y, force.z);\r\n\r\n        impostor.physicsBody.applyForce(impulse, worldPoint);\r\n    }\r\n\r\n    public generatePhysicsBody(impostor: PhysicsImpostor) {\r\n        // When calling forceUpdate generatePhysicsBody is called again, ensure that the updated body does not instantly collide with removed body\r\n        this._removeMarkedPhysicsBodiesFromWorld();\r\n\r\n        //parent-child relationship. Does this impostor have a parent impostor?\r\n        if (impostor.parent) {\r\n            if (impostor.physicsBody) {\r\n                this.removePhysicsBody(impostor);\r\n                //TODO is that needed?\r\n                impostor.forceUpdate();\r\n            }\r\n            return;\r\n        }\r\n\r\n        //should a new body be created for this impostor?\r\n        if (impostor.isBodyInitRequired()) {\r\n            const shape = this._createShape(impostor);\r\n            if (!shape) {\r\n                Logger.Warn(\"It was not possible to create a physics body for this object.\");\r\n                return;\r\n            }\r\n\r\n            //unregister events if body is being changed\r\n            const oldBody = impostor.physicsBody;\r\n            if (oldBody) {\r\n                this.removePhysicsBody(impostor);\r\n            }\r\n\r\n            //create the body and material\r\n            const material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\r\n\r\n            const bodyCreationObject = {\r\n                mass: impostor.getParam(\"mass\"),\r\n                material: material,\r\n            };\r\n            // A simple extend, in case native options were used.\r\n            const nativeOptions = impostor.getParam(\"nativeOptions\");\r\n            for (const key in nativeOptions) {\r\n                if (Object.prototype.hasOwnProperty.call(nativeOptions, key)) {\r\n                    (<any>bodyCreationObject)[key] = nativeOptions[key];\r\n                }\r\n            }\r\n            impostor.physicsBody = new this.BJSCANNON.Body(bodyCreationObject);\r\n            impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\r\n            this.world.addEventListener(\"preStep\", impostor.beforeStep);\r\n            this.world.addEventListener(\"postStep\", impostor.afterStep);\r\n            impostor.physicsBody.addShape(shape);\r\n            if (typeof this.world.addBody === \"function\") {\r\n                this.world.addBody(impostor.physicsBody);\r\n            } else {\r\n                this.world.add(impostor.physicsBody);\r\n            }\r\n\r\n            //try to keep the body moving in the right direction by taking old properties.\r\n            //Should be tested!\r\n            if (oldBody) {\r\n                [\"force\", \"torque\", \"velocity\", \"angularVelocity\"].forEach(function (param) {\r\n                    const vec = oldBody[param];\r\n                    impostor.physicsBody[param].set(vec.x, vec.y, vec.z);\r\n                });\r\n            }\r\n            this._processChildMeshes(impostor);\r\n        }\r\n\r\n        //now update the body's transformation\r\n        this._updatePhysicsBodyTransformation(impostor);\r\n    }\r\n\r\n    private _processChildMeshes(mainImpostor: PhysicsImpostor) {\r\n        const meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];\r\n        const mainRotation: Nullable<Quaternion> = mainImpostor.object.rotationQuaternion;\r\n        if (mainRotation) {\r\n            mainRotation.conjugateToRef(this._tmpQuaternion);\r\n        } else {\r\n            this._tmpQuaternion.set(0, 0, 0, 1);\r\n        }\r\n\r\n        if (meshChildren.length) {\r\n            const processMesh = (mesh: AbstractMesh) => {\r\n                if (!mesh.rotationQuaternion) {\r\n                    return;\r\n                }\r\n\r\n                const childImpostor = mesh.getPhysicsImpostor();\r\n                if (childImpostor) {\r\n                    const parent = childImpostor.parent;\r\n                    if (parent !== mainImpostor && mesh.parent) {\r\n                        const pPosition = mesh.getAbsolutePosition().subtract((mesh.parent as TransformNode).getAbsolutePosition());\r\n                        const q = mesh.rotationQuaternion.multiply(this._tmpQuaternion);\r\n\r\n                        if (childImpostor.physicsBody) {\r\n                            this.removePhysicsBody(childImpostor);\r\n                            childImpostor.physicsBody = null;\r\n                        }\r\n                        childImpostor.parent = mainImpostor;\r\n                        childImpostor.resetUpdateFlags();\r\n                        mainImpostor.physicsBody.addShape(\r\n                            this._createShape(childImpostor),\r\n                            new this.BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z),\r\n                            new this.BJSCANNON.Quaternion(q.x, q.y, q.z, q.w)\r\n                        );\r\n                        //Add the mass of the children.\r\n                        mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\r\n                    }\r\n                }\r\n                mesh.getChildMeshes(true)\r\n                    .filter((m) => !!m.physicsImpostor)\r\n                    .forEach(processMesh);\r\n            };\r\n            meshChildren.filter((m) => !!m.physicsImpostor).forEach(processMesh);\r\n        }\r\n    }\r\n\r\n    public removePhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\r\n        this.world.removeEventListener(\"preStep\", impostor.beforeStep);\r\n        this.world.removeEventListener(\"postStep\", impostor.afterStep);\r\n\r\n        // Only remove the physics body after the physics step to avoid disrupting cannon's internal state\r\n        if (this._physicsBodiesToRemoveAfterStep.indexOf(impostor.physicsBody) === -1) {\r\n            this._physicsBodiesToRemoveAfterStep.push(impostor.physicsBody);\r\n        }\r\n    }\r\n\r\n    public generateJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        const mainBody = impostorJoint.mainImpostor.physicsBody;\r\n        const connectedBody = impostorJoint.connectedImpostor.physicsBody;\r\n        if (!mainBody || !connectedBody) {\r\n            return;\r\n        }\r\n        let constraint: any;\r\n        const jointData = impostorJoint.joint.jointData;\r\n        //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html\r\n        const constraintData = {\r\n            pivotA: jointData.mainPivot ? new this.BJSCANNON.Vec3().set(jointData.mainPivot.x, jointData.mainPivot.y, jointData.mainPivot.z) : null,\r\n            pivotB: jointData.connectedPivot ? new this.BJSCANNON.Vec3().set(jointData.connectedPivot.x, jointData.connectedPivot.y, jointData.connectedPivot.z) : null,\r\n            axisA: jointData.mainAxis ? new this.BJSCANNON.Vec3().set(jointData.mainAxis.x, jointData.mainAxis.y, jointData.mainAxis.z) : null,\r\n            axisB: jointData.connectedAxis ? new this.BJSCANNON.Vec3().set(jointData.connectedAxis.x, jointData.connectedAxis.y, jointData.connectedAxis.z) : null,\r\n            maxForce: jointData.nativeParams.maxForce,\r\n            collideConnected: !!jointData.collision,\r\n        };\r\n        switch (impostorJoint.joint.type) {\r\n            case PhysicsJoint.HingeJoint:\r\n            case PhysicsJoint.Hinge2Joint:\r\n                constraint = new this.BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.DistanceJoint:\r\n                constraint = new this.BJSCANNON.DistanceConstraint(mainBody, connectedBody, (<DistanceJointData>jointData).maxDistance || 2);\r\n                break;\r\n            case PhysicsJoint.SpringJoint: {\r\n                const springData = <SpringJointData>jointData;\r\n                constraint = new this.BJSCANNON.Spring(mainBody, connectedBody, {\r\n                    restLength: springData.length,\r\n                    stiffness: springData.stiffness,\r\n                    damping: springData.damping,\r\n                    localAnchorA: constraintData.pivotA,\r\n                    localAnchorB: constraintData.pivotB,\r\n                });\r\n                break;\r\n            }\r\n            case PhysicsJoint.LockJoint:\r\n                constraint = new this.BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);\r\n                break;\r\n            case PhysicsJoint.PointToPointJoint:\r\n            case PhysicsJoint.BallAndSocketJoint:\r\n            default:\r\n                constraint = new this.BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotB, constraintData.maxForce);\r\n                break;\r\n        }\r\n        //set the collideConnected flag after the creation, since DistanceJoint ignores it.\r\n        constraint.collideConnected = !!jointData.collision;\r\n        impostorJoint.joint.physicsJoint = constraint;\r\n        //don't add spring as constraint, as it is not one.\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.addConstraint(constraint);\r\n        } else {\r\n            (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback =\r\n                (<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback ||\r\n                function () {\r\n                    constraint.applyForce();\r\n                };\r\n            impostorJoint.mainImpostor.registerAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    public removeJoint(impostorJoint: PhysicsImpostorJoint) {\r\n        if (impostorJoint.joint.type !== PhysicsJoint.SpringJoint) {\r\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\r\n        } else {\r\n            impostorJoint.mainImpostor.unregisterAfterPhysicsStep((<SpringJointData>impostorJoint.joint.jointData).forceApplicationCallback);\r\n        }\r\n    }\r\n\r\n    private _addMaterial(name: string, friction: number, restitution: number) {\r\n        let index;\r\n        let mat;\r\n\r\n        for (index = 0; index < this._physicsMaterials.length; index++) {\r\n            mat = this._physicsMaterials[index];\r\n\r\n            if (mat.friction === friction && mat.restitution === restitution) {\r\n                return mat;\r\n            }\r\n        }\r\n\r\n        const currentMat = new this.BJSCANNON.Material(name);\r\n        currentMat.friction = friction;\r\n        currentMat.restitution = restitution;\r\n\r\n        this._physicsMaterials.push(currentMat);\r\n        return currentMat;\r\n    }\r\n\r\n    private _checkWithEpsilon(value: number): number {\r\n        return value < Epsilon ? Epsilon : value;\r\n    }\r\n\r\n    private _createShape(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n\r\n        let returnValue;\r\n        const impostorExtents = impostor.getObjectExtents();\r\n        switch (impostor.type) {\r\n            case PhysicsImpostor.SphereImpostor: {\r\n                const radiusX = impostorExtents.x;\r\n                const radiusY = impostorExtents.y;\r\n                const radiusZ = impostorExtents.z;\r\n\r\n                returnValue = new this.BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\r\n\r\n                break;\r\n            }\r\n            //TMP also for cylinder - TODO Cannon supports cylinder natively.\r\n            case PhysicsImpostor.CylinderImpostor: {\r\n                let nativeParams = impostor.getParam(\"nativeOptions\");\r\n                if (!nativeParams) {\r\n                    nativeParams = {};\r\n                }\r\n                const radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(impostorExtents.x) / 2;\r\n                const radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(impostorExtents.x) / 2;\r\n                const height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(impostorExtents.y);\r\n                const numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;\r\n                returnValue = new this.BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);\r\n\r\n                // Rotate 90 degrees as this shape is horizontal in cannon\r\n                const quat = new this.BJSCANNON.Quaternion();\r\n                quat.setFromAxisAngle(new this.BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);\r\n                const translation = new this.BJSCANNON.Vec3(0, 0, 0);\r\n                returnValue.transformAllPoints(translation, quat);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.BoxImpostor: {\r\n                const box = impostorExtents.scale(0.5);\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\r\n                break;\r\n            }\r\n            case PhysicsImpostor.PlaneImpostor:\r\n                Logger.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\r\n                returnValue = new this.BJSCANNON.Plane();\r\n                break;\r\n            case PhysicsImpostor.MeshImpostor: {\r\n                // should transform the vertex data to world coordinates!!\r\n                const rawVerts = object.getVerticesData ? object.getVerticesData(VertexBuffer.PositionKind) : [];\r\n                const rawFaces = object.getIndices ? object.getIndices() : [];\r\n                if (!rawVerts) {\r\n                    Logger.Warn(\"Tried to create a MeshImpostor for an object without vertices. This will fail.\");\r\n                    return;\r\n                }\r\n                // get only scale! so the object could transform correctly.\r\n                const oldPosition = object.position.clone();\r\n                const oldRotation = object.rotation && object.rotation.clone();\r\n                const oldQuaternion = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n\r\n                const transform = object.computeWorldMatrix(true);\r\n                // convert rawVerts to object space\r\n                const transformedVertices = new Array<number>();\r\n                let index: number;\r\n                for (index = 0; index < rawVerts.length; index += 3) {\r\n                    Vector3.TransformCoordinates(Vector3.FromArray(rawVerts, index), transform).toArray(transformedVertices, index);\r\n                }\r\n\r\n                Logger.Warn(\"MeshImpostor only collides against spheres.\");\r\n                returnValue = new this.BJSCANNON.Trimesh(transformedVertices, <number[]>rawFaces);\r\n                //now set back the transformation!\r\n                object.position.copyFrom(oldPosition);\r\n                oldRotation && object.rotation && object.rotation.copyFrom(oldRotation);\r\n                oldQuaternion && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.HeightmapImpostor: {\r\n                const oldPosition2 = object.position.clone();\r\n                const oldRotation2 = object.rotation && object.rotation.clone();\r\n                const oldQuaternion2 = object.rotationQuaternion && object.rotationQuaternion.clone();\r\n                object.position.copyFromFloats(0, 0, 0);\r\n                object.rotation && object.rotation.copyFromFloats(0, 0, 0);\r\n                object.rotationQuaternion && object.rotationQuaternion.copyFrom(impostor.getParentsRotation());\r\n                object.rotationQuaternion && object.parent && object.rotationQuaternion.conjugateInPlace();\r\n                object.rotationQuaternion && object.rotationQuaternion.multiplyInPlace(this._minus90X);\r\n\r\n                returnValue = this._createHeightmap(object);\r\n                object.position.copyFrom(oldPosition2);\r\n                oldRotation2 && object.rotation && object.rotation.copyFrom(oldRotation2);\r\n                oldQuaternion2 && object.rotationQuaternion && object.rotationQuaternion.copyFrom(oldQuaternion2);\r\n                object.computeWorldMatrix(true);\r\n                break;\r\n            }\r\n            case PhysicsImpostor.ParticleImpostor:\r\n                returnValue = new this.BJSCANNON.Particle();\r\n                break;\r\n            case PhysicsImpostor.NoImpostor:\r\n                returnValue = new this.BJSCANNON.Box(new this.BJSCANNON.Vec3(0, 0, 0));\r\n                break;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n\r\n    private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {\r\n        let pos = <FloatArray>object.getVerticesData(VertexBuffer.PositionKind);\r\n        const transform = object.computeWorldMatrix(true);\r\n        // convert rawVerts to object space\r\n        const transformedVertices = new Array<number>();\r\n        let index: number;\r\n        for (index = 0; index < pos.length; index += 3) {\r\n            Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(transformedVertices, index);\r\n        }\r\n        pos = transformedVertices;\r\n        const matrix = new Array<Array<any>>();\r\n\r\n        //For now pointDepth will not be used and will be automatically calculated.\r\n        //Future reference - try and find the best place to add a reference to the pointDepth variable.\r\n        const arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\r\n        const boundingInfo = object.getBoundingInfo();\r\n        const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);\r\n        const minY = boundingInfo.boundingBox.extendSizeWorld.z;\r\n\r\n        const elementSize = (dim * 2) / arraySize;\r\n\r\n        for (let i = 0; i < pos.length; i = i + 3) {\r\n            const x = Math.round(pos[i + 0] / elementSize + arraySize / 2);\r\n            const z = Math.round((pos[i + 1] / elementSize - arraySize / 2) * -1);\r\n            const y = -pos[i + 2] + minY;\r\n            if (!matrix[x]) {\r\n                matrix[x] = [];\r\n            }\r\n            if (!matrix[x][z]) {\r\n                matrix[x][z] = y;\r\n            }\r\n            matrix[x][z] = Math.max(y, matrix[x][z]);\r\n        }\r\n\r\n        for (let x = 0; x <= arraySize; ++x) {\r\n            if (!matrix[x]) {\r\n                let loc = 1;\r\n                while (!matrix[(x + loc) % arraySize]) {\r\n                    loc++;\r\n                }\r\n                matrix[x] = matrix[(x + loc) % arraySize].slice();\r\n                //console.log(\"missing x\", x);\r\n            }\r\n            for (let z = 0; z <= arraySize; ++z) {\r\n                if (!matrix[x][z]) {\r\n                    let loc = 1;\r\n                    let newValue;\r\n                    while (newValue === undefined) {\r\n                        newValue = matrix[x][(z + loc++) % arraySize];\r\n                    }\r\n                    matrix[x][z] = newValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        const shape = new this.BJSCANNON.Heightfield(matrix, {\r\n            elementSize: elementSize,\r\n        });\r\n\r\n        //For future reference, needed for body transformation\r\n        shape.minY = minY;\r\n\r\n        return shape;\r\n    }\r\n\r\n    private _minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\r\n    private _tmpPosition: Vector3 = Vector3.Zero();\r\n    private _tmpDeltaPosition: Vector3 = Vector3.Zero();\r\n    private _tmpUnityRotation: Quaternion = new Quaternion();\r\n\r\n    private _updatePhysicsBodyTransformation(impostor: PhysicsImpostor) {\r\n        const object = impostor.object;\r\n        //make sure it is updated...\r\n        object.computeWorldMatrix && object.computeWorldMatrix(true);\r\n        if (!object.getBoundingInfo()) {\r\n            return;\r\n        }\r\n        const center = impostor.getObjectCenter();\r\n        //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)\r\n        // The delta between the mesh position and the mesh bounding box center\r\n        this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));\r\n        this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);\r\n        this._tmpPosition.copyFrom(center);\r\n        let quaternion = object.rotationQuaternion;\r\n\r\n        if (!quaternion) {\r\n            return;\r\n        }\r\n\r\n        //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\r\n        //ideally these would be rotated at time of creation like cylinder but they dont extend ConvexPolyhedron\r\n        if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            //-90 DEG in X, precalculated\r\n            quaternion = quaternion.multiply(this._minus90X);\r\n            //Invert! (Precalculated, 90 deg in X)\r\n            //No need to clone. this will never change.\r\n            impostor.setDeltaRotation(this._plus90X);\r\n        }\r\n\r\n        //If it is a heightfield, if should be centered.\r\n        if (impostor.type === PhysicsImpostor.HeightmapImpostor) {\r\n            const mesh = <AbstractMesh>(<any>object);\r\n            let boundingInfo = mesh.getBoundingInfo();\r\n            //calculate the correct body position:\r\n            const rotationQuaternion = mesh.rotationQuaternion;\r\n            mesh.rotationQuaternion = this._tmpUnityRotation;\r\n            mesh.computeWorldMatrix(true);\r\n\r\n            //get original center with no rotation\r\n            const c = center.clone();\r\n\r\n            let oldPivot = mesh.getPivotMatrix();\r\n            if (oldPivot) {\r\n                // create a copy the pivot Matrix as it is modified in place\r\n                oldPivot = oldPivot.clone();\r\n            } else {\r\n                oldPivot = Matrix.Identity();\r\n            }\r\n\r\n            //calculate the new center using a pivot (since this.BJSCANNON.js doesn't center height maps)\r\n            const p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);\r\n            mesh.setPreTransformMatrix(p);\r\n            mesh.computeWorldMatrix(true);\r\n            // force bounding box recomputation\r\n            boundingInfo = mesh.getBoundingInfo();\r\n\r\n            //calculate the translation\r\n            const translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\r\n\r\n            this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);\r\n            //add it inverted to the delta\r\n            this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));\r\n            this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;\r\n            //rotation is back\r\n            mesh.rotationQuaternion = rotationQuaternion;\r\n\r\n            mesh.setPreTransformMatrix(oldPivot);\r\n            mesh.computeWorldMatrix(true);\r\n        } else if (impostor.type === PhysicsImpostor.MeshImpostor) {\r\n            this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\r\n        }\r\n\r\n        impostor.setDeltaPosition(this._tmpDeltaPosition);\r\n        //Now update the impostor object\r\n        impostor.physicsBody.position.set(this._tmpPosition.x, this._tmpPosition.y, this._tmpPosition.z);\r\n        impostor.physicsBody.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\r\n    }\r\n\r\n    public setTransformationFromPhysicsBody(impostor: PhysicsImpostor) {\r\n        impostor.object.position.set(impostor.physicsBody.position.x, impostor.physicsBody.position.y, impostor.physicsBody.position.z);\r\n        if (impostor.object.rotationQuaternion) {\r\n            const q = impostor.physicsBody.quaternion;\r\n            impostor.object.rotationQuaternion.set(q.x, q.y, q.z, q.w);\r\n        }\r\n    }\r\n\r\n    public setPhysicsBodyTransformation(impostor: PhysicsImpostor, newPosition: Vector3, newRotation: Quaternion) {\r\n        impostor.physicsBody.position.set(newPosition.x, newPosition.y, newPosition.z);\r\n        impostor.physicsBody.quaternion.set(newRotation.x, newRotation.y, newRotation.z, newRotation.w);\r\n    }\r\n\r\n    public isSupported(): boolean {\r\n        return this.BJSCANNON !== undefined;\r\n    }\r\n\r\n    public setLinearVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.velocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public setAngularVelocity(impostor: PhysicsImpostor, velocity: Vector3) {\r\n        impostor.physicsBody.angularVelocity.set(velocity.x, velocity.y, velocity.z);\r\n    }\r\n\r\n    public getLinearVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.velocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n    public getAngularVelocity(impostor: PhysicsImpostor): Nullable<Vector3> {\r\n        const v = impostor.physicsBody.angularVelocity;\r\n        if (!v) {\r\n            return null;\r\n        }\r\n        return new Vector3(v.x, v.y, v.z);\r\n    }\r\n\r\n    public setBodyMass(impostor: PhysicsImpostor, mass: number) {\r\n        impostor.physicsBody.mass = mass;\r\n        impostor.physicsBody.updateMassProperties();\r\n    }\r\n\r\n    public getBodyMass(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.mass;\r\n    }\r\n\r\n    public getBodyFriction(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.friction;\r\n    }\r\n\r\n    public setBodyFriction(impostor: PhysicsImpostor, friction: number) {\r\n        impostor.physicsBody.material.friction = friction;\r\n    }\r\n\r\n    public getBodyRestitution(impostor: PhysicsImpostor): number {\r\n        return impostor.physicsBody.material.restitution;\r\n    }\r\n\r\n    public setBodyRestitution(impostor: PhysicsImpostor, restitution: number) {\r\n        impostor.physicsBody.material.restitution = restitution;\r\n    }\r\n\r\n    public sleepBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.sleep();\r\n    }\r\n\r\n    public wakeUpBody(impostor: PhysicsImpostor) {\r\n        impostor.physicsBody.wakeUp();\r\n    }\r\n\r\n    public updateDistanceJoint(joint: PhysicsJoint, maxDistance: number) {\r\n        joint.physicsJoint.distance = maxDistance;\r\n    }\r\n\r\n    public setMotor(joint: IMotorEnabledJoint, speed?: number, maxForce?: number, motorIndex?: number) {\r\n        if (!motorIndex) {\r\n            joint.physicsJoint.enableMotor();\r\n            joint.physicsJoint.setMotorSpeed(speed);\r\n            if (maxForce) {\r\n                this.setLimit(joint, maxForce);\r\n            }\r\n        }\r\n    }\r\n\r\n    public setLimit(joint: IMotorEnabledJoint, minForce: number, maxForce?: number) {\r\n        joint.physicsJoint.motorEquation.maxForce = maxForce;\r\n        joint.physicsJoint.motorEquation.minForce = minForce === void 0 ? -minForce : minForce;\r\n    }\r\n\r\n    public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {\r\n        const body = impostor.physicsBody;\r\n\r\n        mesh.position.x = body.position.x;\r\n        mesh.position.y = body.position.y;\r\n        mesh.position.z = body.position.z;\r\n\r\n        if (mesh.rotationQuaternion) {\r\n            mesh.rotationQuaternion.x = body.quaternion.x;\r\n            mesh.rotationQuaternion.y = body.quaternion.y;\r\n            mesh.rotationQuaternion.z = body.quaternion.z;\r\n            mesh.rotationQuaternion.w = body.quaternion.w;\r\n        }\r\n    }\r\n\r\n    public getRadius(impostor: PhysicsImpostor): number {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        return shape.boundingSphereRadius;\r\n    }\r\n\r\n    public getBoxSizeToRef(impostor: PhysicsImpostor, result: Vector3): void {\r\n        const shape = impostor.physicsBody.shapes[0];\r\n        result.x = shape.halfExtents.x * 2;\r\n        result.y = shape.halfExtents.y * 2;\r\n        result.z = shape.halfExtents.z * 2;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    private _extendNamespace() {\r\n        //this will force cannon to execute at least one step when using interpolation\r\n        const step_tmp1 = new this.BJSCANNON.Vec3();\r\n        const engine = this.BJSCANNON;\r\n        this.BJSCANNON.World.prototype.step = function (dt: number, timeSinceLastCalled: number, maxSubSteps: number) {\r\n            maxSubSteps = maxSubSteps || 10;\r\n            timeSinceLastCalled = timeSinceLastCalled || 0;\r\n            if (timeSinceLastCalled === 0) {\r\n                this.internalStep(dt);\r\n                this.time += dt;\r\n            } else {\r\n                let internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);\r\n                internalSteps = Math.min(internalSteps, maxSubSteps) || 1;\r\n                const t0 = performance.now();\r\n                for (let i = 0; i !== internalSteps; i++) {\r\n                    this.internalStep(dt);\r\n                    if (performance.now() - t0 > dt * 1000) {\r\n                        break;\r\n                    }\r\n                }\r\n                this.time += timeSinceLastCalled;\r\n                const h = this.time % dt;\r\n                const h_div_dt = h / dt;\r\n                const interpvelo = step_tmp1;\r\n                const bodies = this.bodies;\r\n                for (let j = 0; j !== bodies.length; j++) {\r\n                    const b = bodies[j];\r\n                    if (b.type !== engine.Body.STATIC && b.sleepState !== engine.Body.SLEEPING) {\r\n                        b.position.vsub(b.previousPosition, interpvelo);\r\n                        interpvelo.scale(h_div_dt, interpvelo);\r\n                        b.position.vadd(interpvelo, b.interpolatedPosition);\r\n                    } else {\r\n                        b.interpolatedPosition.set(b.position.x, b.position.y, b.position.z);\r\n                        b.interpolatedQuaternion.set(b.quaternion.x, b.quaternion.y, b.quaternion.z, b.quaternion.w);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @returns PhysicsRaycastResult\r\n     */\r\n    public raycast(from: Vector3, to: Vector3): PhysicsRaycastResult {\r\n        this._raycastResult.reset(from, to);\r\n        this.raycastToRef(from, to, this._raycastResult);\r\n        return this._raycastResult;\r\n    }\r\n\r\n    /**\r\n     * Does a raycast in the physics world\r\n     * @param from when should the ray start?\r\n     * @param to when should the ray end?\r\n     * @param result resulting PhysicsRaycastResult\r\n     */\r\n    public raycastToRef(from: Vector3, to: Vector3, result: PhysicsRaycastResult): void {\r\n        this._cannonRaycastResult.reset();\r\n        this.world.raycastClosest(from, to, {}, this._cannonRaycastResult);\r\n\r\n        result.reset(from, to);\r\n        if (this._cannonRaycastResult.hasHit) {\r\n            // TODO: do we also want to get the body it hit?\r\n            result.setHitData(\r\n                {\r\n                    x: this._cannonRaycastResult.hitNormalWorld.x,\r\n                    y: this._cannonRaycastResult.hitNormalWorld.y,\r\n                    z: this._cannonRaycastResult.hitNormalWorld.z,\r\n                },\r\n                {\r\n                    x: this._cannonRaycastResult.hitPointWorld.x,\r\n                    y: this._cannonRaycastResult.hitPointWorld.y,\r\n                    z: this._cannonRaycastResult.hitPointWorld.z,\r\n                }\r\n            );\r\n            result.setHitDistance(this._cannonRaycastResult.distance);\r\n        }\r\n    }\r\n}\r\n\r\nPhysicsEngine.DefaultPluginFactory = () => {\r\n    return new CannonJSPlugin();\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}