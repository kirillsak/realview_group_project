{"ast":null,"code":"import { Logger } from \"../../Misc/logger.js\";\nimport { Texture } from \"../../Materials/Textures/texture.js\";\nimport \"../../Engines/Extensions/engine.dynamicTexture.js\";\n/**\n * A class extending Texture allowing drawing on a texture\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\n */\nexport class DynamicTexture extends Texture {\n  /**\n   * Creates a DynamicTexture\n   * @param name defines the name of the texture\n   * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\n   * @param scene defines the scene where you want the texture\n   * @param generateMipMaps defines the use of MinMaps or not (default is false)\n   * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\n   * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\n   * @param invertY defines if the texture needs to be inverted on the y axis during loading\n   */\n  constructor(name, options, scene = null, generateMipMaps = false, samplingMode = 3, format = 5, invertY) {\n    super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\n    this.name = name;\n    this.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._generateMipMaps = generateMipMaps;\n    const engine = this._getEngine();\n    if (!engine) {\n      return;\n    }\n    if (options.getContext) {\n      this._canvas = options;\n      this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n    } else {\n      this._canvas = engine.createCanvas(1, 1);\n      if (options.width || options.width === 0) {\n        this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n      } else {\n        this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n      }\n    }\n    const textureSize = this.getSize();\n    if (this._canvas.width !== textureSize.width) {\n      this._canvas.width = textureSize.width;\n    }\n    if (this._canvas.height !== textureSize.height) {\n      this._canvas.height = textureSize.height;\n    }\n    this._context = this._canvas.getContext(\"2d\");\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"DynamicTexture\"\n   */\n  getClassName() {\n    return \"DynamicTexture\";\n  }\n  /**\n   * Gets the current state of canRescale\n   */\n  get canRescale() {\n    return true;\n  }\n  _recreate(textureSize) {\n    this._canvas.width = textureSize.width;\n    this._canvas.height = textureSize.height;\n    this.releaseInternalTexture();\n    this._texture = this._getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\n  }\n  /**\n   * Scales the texture\n   * @param ratio the scale factor to apply to both width and height\n   */\n  scale(ratio) {\n    const textureSize = this.getSize();\n    textureSize.width *= ratio;\n    textureSize.height *= ratio;\n    this._recreate(textureSize);\n  }\n  /**\n   * Resizes the texture\n   * @param width the new width\n   * @param height the new height\n   */\n  scaleTo(width, height) {\n    const textureSize = this.getSize();\n    textureSize.width = width;\n    textureSize.height = height;\n    this._recreate(textureSize);\n  }\n  /**\n   * Gets the context of the canvas used by the texture\n   * @returns the canvas context of the dynamic texture\n   */\n  getContext() {\n    return this._context;\n  }\n  /**\n   * Clears the texture\n   */\n  clear() {\n    const size = this.getSize();\n    this._context.fillRect(0, 0, size.width, size.height);\n  }\n  /**\n   * Updates the texture\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n   * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\n   * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\n   */\n  update(invertY, premulAlpha = false, allowGPUOptimization = false) {\n    this._getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, premulAlpha, this._format || undefined, undefined, allowGPUOptimization);\n  }\n  /**\n   * Draws text onto the texture\n   * @param text defines the text to be drawn\n   * @param x defines the placement of the text from the left\n   * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\n   * @param font defines the font to be used with font-style, font-size, font-name\n   * @param color defines the color used for the text\n   * @param clearColor defines the color for the canvas, use null to not overwrite canvas\n   * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\n   * @param update defines whether texture is immediately update (default is true)\n   */\n  drawText(text, x, y, font, color, clearColor, invertY, update = true) {\n    const size = this.getSize();\n    if (clearColor) {\n      this._context.fillStyle = clearColor;\n      this._context.fillRect(0, 0, size.width, size.height);\n    }\n    this._context.font = font;\n    if (x === null || x === undefined) {\n      const textSize = this._context.measureText(text);\n      x = (size.width - textSize.width) / 2;\n    }\n    if (y === null || y === undefined) {\n      const fontSize = parseInt(font.replace(/\\D/g, \"\"));\n      y = size.height / 2 + fontSize / 3.65;\n    }\n    this._context.fillStyle = color || \"\";\n    this._context.fillText(text, x, y);\n    if (update) {\n      this.update(invertY);\n    }\n  }\n  /**\n   * Clones the texture\n   * @returns the clone of the texture.\n   */\n  clone() {\n    const scene = this.getScene();\n    if (!scene) {\n      return this;\n    }\n    const textureSize = this.getSize();\n    const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // Dynamic Texture\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    return newTexture;\n  }\n  /**\n   * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\n   * @returns a serialized dynamic texture object\n   */\n  serialize() {\n    const scene = this.getScene();\n    if (scene && !scene.isReady()) {\n      Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\n    }\n    const serializationObject = super.serialize();\n    if (DynamicTexture._IsCanvasElement(this._canvas)) {\n      serializationObject.base64String = this._canvas.toDataURL();\n    }\n    serializationObject.invertY = this._invertY;\n    serializationObject.samplingMode = this.samplingMode;\n    return serializationObject;\n  }\n  static _IsCanvasElement(canvas) {\n    return canvas.toDataURL !== undefined;\n  }\n  /** @internal */\n  _rebuild() {\n    this.update();\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","Texture","DynamicTexture","constructor","name","options","scene","generateMipMaps","samplingMode","invertY","undefined","format","wrapU","CLAMP_ADDRESSMODE","wrapV","_generateMipMaps","engine","_getEngine","getContext","_canvas","_texture","createDynamicTexture","width","height","createCanvas","textureSize","getSize","_context","getClassName","canRescale","_recreate","releaseInternalTexture","scale","ratio","scaleTo","clear","size","fillRect","update","premulAlpha","allowGPUOptimization","updateDynamicTexture","_format","drawText","text","x","y","font","color","clearColor","fillStyle","textSize","measureText","fontSize","parseInt","replace","fillText","clone","getScene","newTexture","hasAlpha","level","serialize","isReady","Warn","serializationObject","_IsCanvasElement","base64String","toDataURL","_invertY","canvas","_rebuild"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/dynamicTexture.ts"],"sourcesContent":["import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n\r\n    constructor(\r\n        name: string,\r\n        options: any,\r\n        scene: Nullable<Scene> = null,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if (options.getContext) {\r\n            this._canvas = options;\r\n            this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n\r\n            if (options.width || options.width === 0) {\r\n                this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     */\r\n    public clear(): void {\r\n        const size = this.getSize();\r\n        this._context.fillRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param clearColor defines the color for the canvas, use null to not overwrite canvas\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        clearColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}