{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\nimport { PushMaterial } from \"../pushMaterial.js\";\nimport { ScenePerformancePriority } from \"../../scene.js\";\nimport { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../Maths/math.color.js\";\nimport { Engine } from \"../../Engines/engine.js\";\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState.js\";\nimport { Effect } from \"../effect.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData.js\";\nimport { MaterialDefines } from \"../../Materials/materialDefines.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { TransformBlock } from \"./Blocks/transformBlock.js\";\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock.js\";\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock.js\";\nimport { InputBlock } from \"./Blocks/Input/inputBlock.js\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore.js\";\nimport { serialize, SerializationHelper } from \"../../Misc/decorators.js\";\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock.js\";\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock.js\";\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock.js\";\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock.js\";\nimport { EffectFallbacks } from \"../effectFallbacks.js\";\nimport { WebRequest } from \"../../Misc/webRequest.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock.js\";\nimport { RemapBlock } from \"./Blocks/remapBlock.js\";\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock.js\";\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes.js\";\nimport { Texture } from \"../Textures/texture.js\";\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem.js\";\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock.js\";\nimport { TimingTools } from \"../../Misc/timingTools.js\";\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture.js\";\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes.js\";\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock.js\";\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues.js\";\nimport { EngineStore } from \"../../Engines/engineStore.js\";\nimport { MaterialHelper } from \"../materialHelper.js\";\nconst onCreatedEffectParameters = {\n  effect: null,\n  subMesh: null\n};\n/** @internal */\nexport class NodeMaterialDefines extends MaterialDefines {\n  constructor() {\n    super();\n    this.NORMAL = false;\n    this.TANGENT = false;\n    this.UV1 = false;\n    this.UV2 = false;\n    this.UV3 = false;\n    this.UV4 = false;\n    this.UV5 = false;\n    this.UV6 = false;\n    /** BONES */\n    this.NUM_BONE_INFLUENCERS = 0;\n    this.BonesPerMesh = 0;\n    this.BONETEXTURE = false;\n    /** MORPH TARGETS */\n    this.MORPHTARGETS = false;\n    this.MORPHTARGETS_NORMAL = false;\n    this.MORPHTARGETS_TANGENT = false;\n    this.MORPHTARGETS_UV = false;\n    this.NUM_MORPH_INFLUENCERS = 0;\n    this.MORPHTARGETS_TEXTURE = false;\n    /** IMAGE PROCESSING */\n    this.IMAGEPROCESSING = false;\n    this.VIGNETTE = false;\n    this.VIGNETTEBLENDMODEMULTIPLY = false;\n    this.VIGNETTEBLENDMODEOPAQUE = false;\n    this.TONEMAPPING = false;\n    this.TONEMAPPING_ACES = false;\n    this.CONTRAST = false;\n    this.EXPOSURE = false;\n    this.COLORCURVES = false;\n    this.COLORGRADING = false;\n    this.COLORGRADING3D = false;\n    this.SAMPLER3DGREENDEPTH = false;\n    this.SAMPLER3DBGRMAP = false;\n    this.DITHER = false;\n    this.IMAGEPROCESSINGPOSTPROCESS = false;\n    this.SKIPFINALCOLORCLAMP = false;\n    /** MISC. */\n    this.BUMPDIRECTUV = 0;\n    this.CAMERA_ORTHOGRAPHIC = false;\n    this.CAMERA_PERSPECTIVE = false;\n    this.rebuild();\n  }\n  setValue(name, value, markAsUnprocessedIfDirty = false) {\n    if (this[name] === undefined) {\n      this._keys.push(name);\n    }\n    if (markAsUnprocessedIfDirty && this[name] !== value) {\n      this.markAsUnprocessed();\n    }\n    this[name] = value;\n  }\n}\n/**\n * Class used to create a node based material built by assembling shader blocks\n */\nexport class NodeMaterial extends PushMaterial {\n  /**\n   * Create a new node based material\n   * @param name defines the material name\n   * @param scene defines the hosting scene\n   * @param options defines creation option\n   */\n  constructor(name, scene, options = {}) {\n    super(name, scene || EngineStore.LastCreatedScene);\n    this._buildId = NodeMaterial._BuildIdGenerator++;\n    this._buildWasSuccessful = false;\n    this._cachedWorldViewMatrix = new Matrix();\n    this._cachedWorldViewProjectionMatrix = new Matrix();\n    this._optimizers = new Array();\n    this._animationFrame = -1;\n    this.BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\n    /**\n     * Gets or sets data used by visual editor\n     * @see https://nme.babylonjs.com\n     */\n    this.editorData = null;\n    /**\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\n     */\n    this.ignoreAlpha = false;\n    /**\n     * Defines the maximum number of lights that can be used in the material\n     */\n    this.maxSimultaneousLights = 4;\n    /**\n     * Observable raised when the material is built\n     */\n    this.onBuildObservable = new Observable();\n    /**\n     * Gets or sets the root nodes of the material vertex shader\n     */\n    this._vertexOutputNodes = new Array();\n    /**\n     * Gets or sets the root nodes of the material fragment (pixel) shader\n     */\n    this._fragmentOutputNodes = new Array();\n    /**\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\n     */\n    this.attachedBlocks = new Array();\n    /**\n     * Specifies the mode of the node material\n     * @internal\n     */\n    this._mode = NodeMaterialModes.Material;\n    /**\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\n     */\n    this.forceAlphaBlending = false;\n    this._options = {\n      emitComments: false,\n      ...options\n    };\n    // Setup the default processing configuration to the scene.\n    this._attachImageProcessingConfiguration(null);\n  }\n  /**\n   * Checks if a block is a texture block\n   * @param block The block to check\n   * @returns True if the block is a texture block\n   */\n  static _BlockIsTextureBlock(block) {\n    return block.getClassName() === \"TextureBlock\" || block.getClassName() === \"ReflectionTextureBaseBlock\" || block.getClassName() === \"RefractionBlock\" || block.getClassName() === \"CurrentScreenBlock\" || block.getClassName() === \"ParticleTextureBlock\" || block.getClassName() === \"ImageSourceBlock\" || block.getClassName() === \"TriPlanarBlock\" || block.getClassName() === \"BiPlanarBlock\";\n  }\n  /** Get the inspector from bundle or global */\n  _getGlobalNodeMaterialEditor() {\n    // UMD Global name detection from Webpack Bundle UMD Name.\n    if (typeof NODEEDITOR !== \"undefined\") {\n      return NODEEDITOR;\n    }\n    // In case of module let's check the global emitted from the editor entry point.\n    if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\n      return BABYLON;\n    }\n    return undefined;\n  }\n  /** Gets or sets options to control the node material overall behavior */\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this._options = options;\n  }\n  /**\n   * Gets the image processing configuration used either in this material.\n   */\n  get imageProcessingConfiguration() {\n    return this._imageProcessingConfiguration;\n  }\n  /**\n   * Sets the Default image processing configuration used either in the this material.\n   *\n   * If sets to null, the scene one is in use.\n   */\n  set imageProcessingConfiguration(value) {\n    this._attachImageProcessingConfiguration(value);\n    // Ensure the effect will be rebuilt.\n    this._markAllSubMeshesAsTexturesDirty();\n  }\n  /**\n   * Gets or sets the mode property\n   */\n  get mode() {\n    return this._mode;\n  }\n  set mode(value) {\n    this._mode = value;\n  }\n  /** Gets or sets the unique identifier used to identified the effect associated with the material */\n  get buildId() {\n    return this._buildId;\n  }\n  set buildId(value) {\n    this._buildId = value;\n  }\n  /**\n   * Gets the current class name of the material e.g. \"NodeMaterial\"\n   * @returns the class name\n   */\n  getClassName() {\n    return \"NodeMaterial\";\n  }\n  /**\n   * Attaches a new image processing configuration to the Standard Material.\n   * @param configuration\n   */\n  _attachImageProcessingConfiguration(configuration) {\n    if (configuration === this._imageProcessingConfiguration) {\n      return;\n    }\n    // Detaches observer.\n    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n    }\n    // Pick the scene configuration if needed.\n    if (!configuration) {\n      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n    } else {\n      this._imageProcessingConfiguration = configuration;\n    }\n    // Attaches observer.\n    if (this._imageProcessingConfiguration) {\n      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n        this._markAllSubMeshesAsImageProcessingDirty();\n      });\n    }\n  }\n  /**\n   * Get a block by its name\n   * @param name defines the name of the block to retrieve\n   * @returns the required block or null if not found\n   */\n  getBlockByName(name) {\n    let result = null;\n    for (const block of this.attachedBlocks) {\n      if (block.name === name) {\n        if (!result) {\n          result = block;\n        } else {\n          Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\n          return result;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   * Get a block by its name\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required block or null if not found\n   */\n  getBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Get an input block by its name\n   * @param predicate defines the predicate used to find the good candidate\n   * @returns the required input block or null if not found\n   */\n  getInputBlockByPredicate(predicate) {\n    for (const block of this.attachedBlocks) {\n      if (block.isInput && predicate(block)) {\n        return block;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the list of input blocks attached to this material\n   * @returns an array of InputBlocks\n   */\n  getInputBlocks() {\n    const blocks = [];\n    for (const block of this.attachedBlocks) {\n      if (block.isInput) {\n        blocks.push(block);\n      }\n    }\n    return blocks;\n  }\n  /**\n   * Adds a new optimizer to the list of optimizers\n   * @param optimizer defines the optimizers to add\n   * @returns the current material\n   */\n  registerOptimizer(optimizer) {\n    const index = this._optimizers.indexOf(optimizer);\n    if (index > -1) {\n      return;\n    }\n    this._optimizers.push(optimizer);\n    return this;\n  }\n  /**\n   * Remove an optimizer from the list of optimizers\n   * @param optimizer defines the optimizers to remove\n   * @returns the current material\n   */\n  unregisterOptimizer(optimizer) {\n    const index = this._optimizers.indexOf(optimizer);\n    if (index === -1) {\n      return;\n    }\n    this._optimizers.splice(index, 1);\n    return this;\n  }\n  /**\n   * Add a new block to the list of output nodes\n   * @param node defines the node to add\n   * @returns the current material\n   */\n  addOutputNode(node) {\n    if (node.target === null) {\n      throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\n    }\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._addVertexOutputNode(node);\n    }\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._addFragmentOutputNode(node);\n    }\n    return this;\n  }\n  /**\n   * Remove a block from the list of root nodes\n   * @param node defines the node to remove\n   * @returns the current material\n   */\n  removeOutputNode(node) {\n    if (node.target === null) {\n      return this;\n    }\n    if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\n      this._removeVertexOutputNode(node);\n    }\n    if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\n      this._removeFragmentOutputNode(node);\n    }\n    return this;\n  }\n  _addVertexOutputNode(node) {\n    if (this._vertexOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n    node.target = NodeMaterialBlockTargets.Vertex;\n    this._vertexOutputNodes.push(node);\n    return this;\n  }\n  _removeVertexOutputNode(node) {\n    const index = this._vertexOutputNodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    this._vertexOutputNodes.splice(index, 1);\n    return this;\n  }\n  _addFragmentOutputNode(node) {\n    if (this._fragmentOutputNodes.indexOf(node) !== -1) {\n      return;\n    }\n    node.target = NodeMaterialBlockTargets.Fragment;\n    this._fragmentOutputNodes.push(node);\n    return this;\n  }\n  _removeFragmentOutputNode(node) {\n    const index = this._fragmentOutputNodes.indexOf(node);\n    if (index === -1) {\n      return;\n    }\n    this._fragmentOutputNodes.splice(index, 1);\n    return this;\n  }\n  /**\n   * Specifies if the material will require alpha blending\n   * @returns a boolean specifying if alpha blending is needed\n   */\n  needAlphaBlending() {\n    if (this.ignoreAlpha) {\n      return false;\n    }\n    return this.forceAlphaBlending || this.alpha < 1.0 || this._sharedData && this._sharedData.hints.needAlphaBlending;\n  }\n  /**\n   * Specifies if this material should be rendered in alpha test mode\n   * @returns a boolean specifying if an alpha test is needed.\n   */\n  needAlphaTesting() {\n    return this._sharedData && this._sharedData.hints.needAlphaTesting;\n  }\n  _initializeBlock(node, state, nodesToProcessForOtherBuildState, autoConfigure = true) {\n    node.initialize(state);\n    if (autoConfigure) {\n      node.autoConfigure(this);\n    }\n    node._preparationId = this._buildId;\n    if (this.attachedBlocks.indexOf(node) === -1) {\n      if (node.isUnique) {\n        const className = node.getClassName();\n        for (const other of this.attachedBlocks) {\n          if (other.getClassName() === className) {\n            throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\n          }\n        }\n      }\n      this.attachedBlocks.push(node);\n    }\n    for (const input of node.inputs) {\n      input.associatedVariableName = \"\";\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\n            nodesToProcessForOtherBuildState.push(block);\n          } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\n            nodesToProcessForOtherBuildState.push(block);\n          }\n          this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\n        }\n      }\n    }\n    for (const output of node.outputs) {\n      output.associatedVariableName = \"\";\n    }\n  }\n  _resetDualBlocks(node, id) {\n    if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\n      node.buildId = id;\n    }\n    for (const inputs of node.inputs) {\n      const connectedPoint = inputs.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== node) {\n          this._resetDualBlocks(block, id);\n        }\n      }\n    }\n  }\n  /**\n   * Remove a block from the current node material\n   * @param block defines the block to remove\n   */\n  removeBlock(block) {\n    const attachedBlockIndex = this.attachedBlocks.indexOf(block);\n    if (attachedBlockIndex > -1) {\n      this.attachedBlocks.splice(attachedBlockIndex, 1);\n    }\n    if (block.isFinalMerger) {\n      this.removeOutputNode(block);\n    }\n  }\n  /**\n   * Build the material and generates the inner effect\n   * @param verbose defines if the build should log activity\n   * @param updateBuildId defines if the internal build Id should be updated (default is true)\n   * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is true)\n   */\n  build(verbose = false, updateBuildId = true, autoConfigure = true) {\n    this._buildWasSuccessful = false;\n    const engine = this.getScene().getEngine();\n    const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\n    if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\n      throw \"You must define at least one vertexOutputNode\";\n    }\n    if (this._fragmentOutputNodes.length === 0) {\n      throw \"You must define at least one fragmentOutputNode\";\n    }\n    // Compilation state\n    this._vertexCompilationState = new NodeMaterialBuildState();\n    this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\n    this._fragmentCompilationState = new NodeMaterialBuildState();\n    this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\n    this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\n    // Shared data\n    this._sharedData = new NodeMaterialBuildStateSharedData();\n    this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\n    this._vertexCompilationState.sharedData = this._sharedData;\n    this._fragmentCompilationState.sharedData = this._sharedData;\n    this._sharedData.buildId = this._buildId;\n    this._sharedData.emitComments = this._options.emitComments;\n    this._sharedData.verbose = verbose;\n    this._sharedData.scene = this.getScene();\n    this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\n    // Initialize blocks\n    const vertexNodes = [];\n    const fragmentNodes = [];\n    for (const vertexOutputNode of this._vertexOutputNodes) {\n      vertexNodes.push(vertexOutputNode);\n      this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\n    }\n    for (const fragmentOutputNode of this._fragmentOutputNodes) {\n      fragmentNodes.push(fragmentOutputNode);\n      this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\n    }\n    // Optimize\n    this.optimize();\n    // Vertex\n    for (const vertexOutputNode of vertexNodes) {\n      vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\n    }\n    // Fragment\n    this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\n    this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\n    this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\n    this._fragmentCompilationState._vertexState = this._vertexCompilationState;\n    for (const fragmentOutputNode of fragmentNodes) {\n      this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\n    }\n    for (const fragmentOutputNode of fragmentNodes) {\n      fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\n    }\n    // Finalize\n    this._vertexCompilationState.finalize(this._vertexCompilationState);\n    this._fragmentCompilationState.finalize(this._fragmentCompilationState);\n    if (updateBuildId) {\n      this._buildId = NodeMaterial._BuildIdGenerator++;\n    }\n    // Errors\n    this._sharedData.emitErrors();\n    if (verbose) {\n      console.log(\"Vertex shader:\");\n      console.log(this._vertexCompilationState.compilationString);\n      console.log(\"Fragment shader:\");\n      console.log(this._fragmentCompilationState.compilationString);\n    }\n    this._buildWasSuccessful = true;\n    this.onBuildObservable.notifyObservers(this);\n    // Wipe defines\n    const meshes = this.getScene().meshes;\n    for (const mesh of meshes) {\n      if (!mesh.subMeshes) {\n        continue;\n      }\n      for (const subMesh of mesh.subMeshes) {\n        if (subMesh.getMaterial() !== this) {\n          continue;\n        }\n        if (!subMesh.materialDefines) {\n          continue;\n        }\n        const defines = subMesh.materialDefines;\n        defines.markAllAsDirty();\n        defines.reset();\n      }\n    }\n  }\n  /**\n   * Runs an otpimization phase to try to improve the shader code\n   */\n  optimize() {\n    for (const optimizer of this._optimizers) {\n      optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\n    }\n  }\n  _prepareDefinesForAttributes(mesh, defines) {\n    const oldNormal = defines[\"NORMAL\"];\n    const oldTangent = defines[\"TANGENT\"];\n    defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\n    defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\n    let uvChanged = false;\n    for (let i = 1; i <= 6; ++i) {\n      const oldUV = defines[\"UV\" + i];\n      defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\n      uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\n    }\n    if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || uvChanged) {\n      defines.markAsAttributesDirty();\n    }\n  }\n  /**\n   * Create a post process from the material\n   * @param camera The camera to apply the render pass to.\n   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\n   * @returns the post process created\n   */\n  createPostProcess(camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {\n    if (this.mode !== NodeMaterialModes.PostProcess) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n    return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\n  }\n  /**\n   * Create the post process effect from the material\n   * @param postProcess The post process to create the effect for\n   */\n  createEffectForPostProcess(postProcess) {\n    this._createEffectForPostProcess(postProcess);\n  }\n  _createEffectForPostProcess(postProcess, camera, options = 1, samplingMode = 1, engine, reusable, textureType = 0, textureFormat = 5) {\n    let tempName = this.name + this._buildId;\n    const defines = new NodeMaterialDefines();\n    const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\n    let buildId = this._buildId;\n    this._processDefines(dummyMesh, defines);\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    if (!postProcess) {\n      postProcess = new PostProcess(this.name + \"PostProcess\", tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, options, camera, samplingMode, engine, reusable, defines.toString(), textureType, tempName, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, false, textureFormat);\n    } else {\n      postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n        maxSimultaneousLights: this.maxSimultaneousLights\n      }, undefined, undefined, tempName, tempName);\n    }\n    postProcess.nodeMaterialSource = this;\n    postProcess.onApplyObservable.add(effect => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(() => postProcess.updateEffect(defines.toString(), this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, {\n          maxSimultaneousLights: this.maxSimultaneousLights\n        }, undefined, undefined, tempName, tempName));\n      }\n      this._checkInternals(effect);\n    });\n    return postProcess;\n  }\n  /**\n   * Create a new procedural texture based on this node material\n   * @param size defines the size of the texture\n   * @param scene defines the hosting scene\n   * @returns the new procedural texture attached to this node material\n   */\n  createProceduralTexture(size, scene) {\n    if (this.mode !== NodeMaterialModes.ProceduralTexture) {\n      console.log(\"Incompatible material mode\");\n      return null;\n    }\n    let tempName = this.name + this._buildId;\n    const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\n    const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\n    dummyMesh.reservedDataStore = {\n      hidden: true\n    };\n    const defines = new NodeMaterialDefines();\n    const result = this._processDefines(dummyMesh, defines);\n    Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n    let effect = this.getScene().getEngine().createEffect({\n      vertexElement: tempName,\n      fragmentElement: tempName\n    }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n    proceduralTexture.nodeMaterialSource = this;\n    proceduralTexture._setEffect(effect);\n    let buildId = this._buildId;\n    proceduralTexture.onBeforeGenerationObservable.add(() => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"VertexShader\"];\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\n        TimingTools.SetImmediate(() => {\n          effect = this.getScene().getEngine().createEffect({\n            vertexElement: tempName,\n            fragmentElement: tempName\n          }, [VertexBuffer.PositionKind], this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString(), result === null || result === void 0 ? void 0 : result.fallbacks, undefined);\n          proceduralTexture._setEffect(effect);\n        });\n      }\n      this._checkInternals(effect);\n    });\n    return proceduralTexture;\n  }\n  _createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined = \"\") {\n    let tempName = this.name + this._buildId + \"_\" + blendMode;\n    if (!defines) {\n      defines = new NodeMaterialDefines();\n    }\n    if (!dummyMesh) {\n      dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\n      if (!dummyMesh) {\n        dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\n        dummyMesh.reservedDataStore = {\n          hidden: true\n        };\n      }\n    }\n    let buildId = this._buildId;\n    const particleSystemDefines = [];\n    let join = particleSystemDefinesJoined;\n    if (!effect) {\n      const result = this._processDefines(dummyMesh, defines);\n      Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      join = particleSystemDefines.join(\"\\n\");\n      effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n      particleSystem.setCustomEffect(effect, blendMode);\n    }\n    effect.onBindObservable.add(effect => {\n      if (buildId !== this._buildId) {\n        delete Effect.ShadersStore[tempName + \"PixelShader\"];\n        tempName = this.name + this._buildId + \"_\" + blendMode;\n        defines.markAllAsDirty();\n        buildId = this._buildId;\n      }\n      particleSystemDefines.length = 0;\n      particleSystem.fillDefines(particleSystemDefines, blendMode);\n      const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\n      if (particleSystemDefinesJoinedCurrent !== join) {\n        defines.markAllAsDirty();\n        join = particleSystemDefinesJoinedCurrent;\n      }\n      const result = this._processDefines(dummyMesh, defines);\n      if (result) {\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\n        effect = this.getScene().getEngine().createEffectForParticles(tempName, this._fragmentCompilationState.uniforms, this._fragmentCompilationState.samplers, defines.toString() + \"\\n\" + join, result === null || result === void 0 ? void 0 : result.fallbacks, onCompiled, onError, particleSystem);\n        particleSystem.setCustomEffect(effect, blendMode);\n        this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\n        return;\n      }\n      this._checkInternals(effect);\n    });\n  }\n  _checkInternals(effect) {\n    // Animated blocks\n    if (this._sharedData.animatedInputs) {\n      const scene = this.getScene();\n      const frameId = scene.getFrameId();\n      if (this._animationFrame !== frameId) {\n        for (const input of this._sharedData.animatedInputs) {\n          input.animate(scene);\n        }\n        this._animationFrame = frameId;\n      }\n    }\n    // Bindable blocks\n    for (const block of this._sharedData.bindableBlocks) {\n      block.bind(effect, this);\n    }\n    // Connection points\n    for (const inputBlock of this._sharedData.inputBlocks) {\n      inputBlock._transmit(effect, this.getScene(), this);\n    }\n  }\n  /**\n   * Create the effect to be used as the custom effect for a particle system\n   * @param particleSystem Particle system to create the effect for\n   * @param onCompiled defines a function to call when the effect creation is successful\n   * @param onError defines a function to call when the effect creation has failed\n   */\n  createEffectForParticles(particleSystem, onCompiled, onError) {\n    if (this.mode !== NodeMaterialModes.Particle) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\n    this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\n  }\n  /**\n   * Use this material as the shadow depth wrapper of a target material\n   * @param targetMaterial defines the target material\n   */\n  createAsShadowDepthWrapper(targetMaterial) {\n    if (this.mode !== NodeMaterialModes.Material) {\n      console.log(\"Incompatible material mode\");\n      return;\n    }\n    targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\n  }\n  _processDefines(mesh, defines, useInstances = false, subMesh) {\n    let result = null;\n    // Global defines\n    const scene = this.getScene();\n    if (MaterialHelper.PrepareDefinesForCamera(scene, defines)) {\n      defines.markAsMiscDirty();\n    }\n    // Shared defines\n    this._sharedData.blocksWithDefines.forEach(b => {\n      b.initializeDefines(mesh, this, defines, useInstances);\n    });\n    this._sharedData.blocksWithDefines.forEach(b => {\n      b.prepareDefines(mesh, this, defines, useInstances, subMesh);\n    });\n    // Need to recompile?\n    if (defines.isDirty) {\n      const lightDisposed = defines._areLightsDisposed;\n      defines.markAsProcessed();\n      // Repeatable content generators\n      this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\n      this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\n      this._sharedData.repeatableContentBlocks.forEach(b => {\n        b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\n      });\n      // Uniforms\n      const uniformBuffers = [];\n      this._sharedData.dynamicUniformBlocks.forEach(b => {\n        b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\n      });\n      const mergedUniforms = this._vertexCompilationState.uniforms;\n      this._fragmentCompilationState.uniforms.forEach(u => {\n        const index = mergedUniforms.indexOf(u);\n        if (index === -1) {\n          mergedUniforms.push(u);\n        }\n      });\n      // Samplers\n      const mergedSamplers = this._vertexCompilationState.samplers;\n      this._fragmentCompilationState.samplers.forEach(s => {\n        const index = mergedSamplers.indexOf(s);\n        if (index === -1) {\n          mergedSamplers.push(s);\n        }\n      });\n      const fallbacks = new EffectFallbacks();\n      this._sharedData.blocksWithFallbacks.forEach(b => {\n        b.provideFallbacks(mesh, fallbacks);\n      });\n      result = {\n        lightDisposed,\n        uniformBuffers,\n        mergedUniforms,\n        mergedSamplers,\n        fallbacks\n      };\n    }\n    return result;\n  }\n  /**\n   * Get if the submesh is ready to be used and all its information available.\n   * Child classes can use it to update shaders\n   * @param mesh defines the mesh to check\n   * @param subMesh defines which submesh to check\n   * @param useInstances specifies that instances should be used\n   * @returns a boolean indicating that the submesh is ready or not\n   */\n  isReadyForSubMesh(mesh, subMesh, useInstances = false) {\n    if (!this._buildWasSuccessful) {\n      return false;\n    }\n    const scene = this.getScene();\n    if (this._sharedData.animatedInputs) {\n      const frameId = scene.getFrameId();\n      if (this._animationFrame !== frameId) {\n        for (const input of this._sharedData.animatedInputs) {\n          input.animate(scene);\n        }\n        this._animationFrame = frameId;\n      }\n    }\n    if (subMesh.effect && this.isFrozen) {\n      if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\n        return true;\n      }\n    }\n    if (!subMesh.materialDefines) {\n      subMesh.materialDefines = new NodeMaterialDefines();\n    }\n    const defines = subMesh.materialDefines;\n    if (this._isReadyForSubMesh(subMesh)) {\n      return true;\n    }\n    const engine = scene.getEngine();\n    this._prepareDefinesForAttributes(mesh, defines);\n    // Check if blocks are ready\n    if (this._sharedData.blockingBlocks.some(b => !b.isReady(mesh, this, defines, useInstances))) {\n      return false;\n    }\n    const result = this._processDefines(mesh, defines, useInstances, subMesh);\n    if (result) {\n      const previousEffect = subMesh.effect;\n      // Compilation\n      const join = defines.toString();\n      let effect = engine.createEffect({\n        vertex: \"nodeMaterial\" + this._buildId,\n        fragment: \"nodeMaterial\" + this._buildId,\n        vertexSource: this._vertexCompilationState.compilationString,\n        fragmentSource: this._fragmentCompilationState.compilationString\n      }, {\n        attributes: this._vertexCompilationState.attributes,\n        uniformsNames: result.mergedUniforms,\n        uniformBuffersNames: result.uniformBuffers,\n        samplers: result.mergedSamplers,\n        defines: join,\n        fallbacks: result.fallbacks,\n        onCompiled: this.onCompiled,\n        onError: this.onError,\n        indexParameters: {\n          maxSimultaneousLights: this.maxSimultaneousLights,\n          maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS\n        }\n      }, engine);\n      if (effect) {\n        if (this._onEffectCreatedObservable) {\n          onCreatedEffectParameters.effect = effect;\n          onCreatedEffectParameters.subMesh = subMesh;\n          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\n        }\n        // Use previous effect while new one is compiling\n        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\n          effect = previousEffect;\n          defines.markAsUnprocessed();\n          if (result.lightDisposed) {\n            // re register in case it takes more than one frame.\n            defines._areLightsDisposed = true;\n            return false;\n          }\n        } else {\n          scene.resetCachedMaterial();\n          subMesh.setEffect(effect, defines, this._materialContext);\n        }\n      }\n    }\n    if (!subMesh.effect || !subMesh.effect.isReady()) {\n      return false;\n    }\n    defines._renderId = scene.getRenderId();\n    subMesh.effect._wasPreviouslyReady = true;\n    subMesh.effect._wasPreviouslyUsingInstances = useInstances;\n    if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\n      this.checkReadyOnlyOnce = true;\n    }\n    return true;\n  }\n  /**\n   * Get a string representing the shaders built by the current node graph\n   */\n  get compiledShaders() {\n    return `// Vertex shader\\r\\n${this._vertexCompilationState.compilationString}\\r\\n\\r\\n// Fragment shader\\r\\n${this._fragmentCompilationState.compilationString}`;\n  }\n  /**\n   * Binds the world matrix to the material\n   * @param world defines the world transformation matrix\n   */\n  bindOnlyWorldMatrix(world) {\n    const scene = this.getScene();\n    if (!this._activeEffect) {\n      return;\n    }\n    const hints = this._sharedData.hints;\n    if (hints.needWorldViewMatrix) {\n      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n    }\n    if (hints.needWorldViewProjectionMatrix) {\n      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n    }\n    // Connection points\n    for (const inputBlock of this._sharedData.inputBlocks) {\n      inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\n    }\n  }\n  /**\n   * Binds the submesh to this material by preparing the effect and shader to draw\n   * @param world defines the world transformation matrix\n   * @param mesh defines the mesh containing the submesh\n   * @param subMesh defines the submesh to bind the material to\n   */\n  bindForSubMesh(world, mesh, subMesh) {\n    const scene = this.getScene();\n    const effect = subMesh.effect;\n    if (!effect) {\n      return;\n    }\n    this._activeEffect = effect;\n    // Matrices\n    this.bindOnlyWorldMatrix(world);\n    const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\n    const sharedData = this._sharedData;\n    if (mustRebind) {\n      // Bindable blocks\n      for (const block of sharedData.bindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n      for (const block of sharedData.forcedBindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n      // Connection points\n      for (const inputBlock of sharedData.inputBlocks) {\n        inputBlock._transmit(effect, scene, this);\n      }\n    } else if (!this.isFrozen) {\n      for (const block of sharedData.forcedBindableBlocks) {\n        block.bind(effect, this, mesh, subMesh);\n      }\n    }\n    this._afterBind(mesh, this._activeEffect);\n  }\n  /**\n   * Gets the active textures from the material\n   * @returns an array of textures\n   */\n  getActiveTextures() {\n    const activeTextures = super.getActiveTextures();\n    if (this._sharedData) {\n      activeTextures.push(...this._sharedData.textureBlocks.filter(tb => tb.texture).map(tb => tb.texture));\n    }\n    return activeTextures;\n  }\n  /**\n   * Gets the list of texture blocks\n   * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\n   * @returns an array of texture blocks\n   */\n  getTextureBlocks() {\n    if (!this._sharedData) {\n      return [];\n    }\n    return this._sharedData.textureBlocks;\n  }\n  /**\n   * Gets the list of all texture blocks\n   * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\n   * @returns\n   */\n  getAllTextureBlocks() {\n    const textureBlocks = [];\n    for (const block of this.attachedBlocks) {\n      if (NodeMaterial._BlockIsTextureBlock(block)) {\n        textureBlocks.push(block);\n      }\n    }\n    return textureBlocks;\n  }\n  /**\n   * Specifies if the material uses a texture\n   * @param texture defines the texture to check against the material\n   * @returns a boolean specifying if the material uses the texture\n   */\n  hasTexture(texture) {\n    if (super.hasTexture(texture)) {\n      return true;\n    }\n    if (!this._sharedData) {\n      return false;\n    }\n    for (const t of this._sharedData.textureBlocks) {\n      if (t.texture === texture) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Disposes the material\n   * @param forceDisposeEffect specifies if effects should be forcefully disposed\n   * @param forceDisposeTextures specifies if textures should be forcefully disposed\n   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n   */\n  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n    if (forceDisposeTextures) {\n      for (const texture of this.getTextureBlocks().filter(tb => tb.texture).map(tb => tb.texture)) {\n        texture.dispose();\n      }\n    }\n    for (const block of this.attachedBlocks) {\n      block.dispose();\n    }\n    this.attachedBlocks.length = 0;\n    this._sharedData = null;\n    this._vertexCompilationState = null;\n    this._fragmentCompilationState = null;\n    this.onBuildObservable.clear();\n    if (this._imageProcessingObserver) {\n      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n      this._imageProcessingObserver = null;\n    }\n    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n  }\n  /** Creates the node editor window. */\n  _createNodeEditor() {\n    this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\n      nodeMaterial: this\n    });\n  }\n  /**\n   * Launch the node material editor\n   * @param config Define the configuration of the editor\n   * @returns a promise fulfilled when the node editor is visible\n   */\n  edit(config) {\n    return new Promise(resolve => {\n      this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n      if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\n        const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\n        // Load editor and add it to the DOM\n        Tools.LoadScript(editorUrl, () => {\n          this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\n          this._createNodeEditor();\n          resolve();\n        });\n      } else {\n        // Otherwise creates the editor\n        this._createNodeEditor();\n        resolve();\n      }\n    });\n  }\n  /**\n   * Clear the current material\n   */\n  clear() {\n    this._vertexOutputNodes.length = 0;\n    this._fragmentOutputNodes.length = 0;\n    this.attachedBlocks.length = 0;\n  }\n  /**\n   * Clear the current material and set it to a default state\n   */\n  setToDefault() {\n    this.clear();\n    this.editorData = null;\n    const positionInput = new InputBlock(\"Position\");\n    positionInput.setAsAttribute(\"position\");\n    const worldInput = new InputBlock(\"World\");\n    worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n    const worldPos = new TransformBlock(\"WorldPos\");\n    positionInput.connectTo(worldPos);\n    worldInput.connectTo(worldPos);\n    const viewProjectionInput = new InputBlock(\"ViewProjection\");\n    viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\n    const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\n    worldPos.connectTo(worldPosdMultipliedByViewProjection);\n    viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\n    // Pixel\n    const pixelColor = new InputBlock(\"color\");\n    pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    pixelColor.connectTo(fragmentOutput);\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Material;\n  }\n  /**\n   * Clear the current material and set it to a default state for post process\n   */\n  setToDefaultPostProcess() {\n    this.clear();\n    this.editorData = null;\n    const position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    const const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    const vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput);\n    // Pixel\n    const scale = new InputBlock(\"Scale\");\n    scale.visibleInInspector = true;\n    scale.value = new Vector2(1, 1);\n    const uv0 = new RemapBlock(\"uv0\");\n    position.connectTo(uv0);\n    const uv = new MultiplyBlock(\"UV scale\");\n    uv0.connectTo(uv);\n    scale.connectTo(uv);\n    const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\n    uv.connectTo(currentScreen);\n    currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    currentScreen.connectTo(fragmentOutput, {\n      output: \"rgba\"\n    });\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.PostProcess;\n  }\n  /**\n   * Clear the current material and set it to a default state for procedural texture\n   */\n  setToDefaultProceduralTexture() {\n    this.clear();\n    this.editorData = null;\n    const position = new InputBlock(\"Position\");\n    position.setAsAttribute(\"position2d\");\n    const const1 = new InputBlock(\"Constant1\");\n    const1.isConstant = true;\n    const1.value = 1;\n    const vmerger = new VectorMergerBlock(\"Position3D\");\n    position.connectTo(vmerger);\n    const1.connectTo(vmerger, {\n      input: \"w\"\n    });\n    const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\n    vmerger.connectTo(vertexOutput);\n    // Pixel\n    const time = new InputBlock(\"Time\");\n    time.value = 0;\n    time.min = 0;\n    time.max = 0;\n    time.isBoolean = false;\n    time.matrixMode = 0;\n    time.animationType = AnimatedInputBlockTypes.Time;\n    time.isConstant = false;\n    const color = new InputBlock(\"Color3\");\n    color.value = new Color3(1, 1, 1);\n    color.isConstant = false;\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\n    vectorMerger.visibleInInspector = false;\n    const cos = new TrigonometryBlock(\"Cos\");\n    cos.operation = TrigonometryBlockOperations.Cos;\n    position.connectTo(vectorMerger);\n    time.output.connectTo(cos.input);\n    cos.output.connectTo(vectorMerger.z);\n    vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\n    // Add to nodes\n    this.addOutputNode(vertexOutput);\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.ProceduralTexture;\n  }\n  /**\n   * Clear the current material and set it to a default state for particle\n   */\n  setToDefaultParticle() {\n    this.clear();\n    this.editorData = null;\n    // Pixel\n    const uv = new InputBlock(\"uv\");\n    uv.setAsAttribute(\"particle_uv\");\n    const texture = new ParticleTextureBlock(\"ParticleTexture\");\n    uv.connectTo(texture);\n    const color = new InputBlock(\"Color\");\n    color.setAsAttribute(\"particle_color\");\n    const multiply = new MultiplyBlock(\"Texture * Color\");\n    texture.connectTo(multiply);\n    color.connectTo(multiply);\n    const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\n    multiply.connectTo(rampGradient);\n    const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\n    color.connectTo(cSplitter);\n    const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\n    rampGradient.connectTo(blendMultiply);\n    texture.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    cSplitter.connectTo(blendMultiply, {\n      output: \"a\"\n    });\n    const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\n    blendMultiply.connectTo(fragmentOutput);\n    // Add to nodes\n    this.addOutputNode(fragmentOutput);\n    this._mode = NodeMaterialModes.Particle;\n  }\n  /**\n   * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\n   * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\n   * @param url defines the url to load from\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @returns a promise that will fulfil when the material is fully loaded\n   */\n  async loadAsync(url, rootUrl = \"\") {\n    return NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\n  }\n  _gatherBlocks(rootNode, list) {\n    if (list.indexOf(rootNode) !== -1) {\n      return;\n    }\n    list.push(rootNode);\n    for (const input of rootNode.inputs) {\n      const connectedPoint = input.connectedPoint;\n      if (connectedPoint) {\n        const block = connectedPoint.ownerBlock;\n        if (block !== rootNode) {\n          this._gatherBlocks(block, list);\n        }\n      }\n    }\n  }\n  /**\n   * Generate a string containing the code declaration required to create an equivalent of this material\n   * @returns a string\n   */\n  generateCode() {\n    let alreadyDumped = [];\n    const vertexBlocks = [];\n    const uniqueNames = [\"const\", \"var\", \"let\"];\n    // Gets active blocks\n    for (const outputNode of this._vertexOutputNodes) {\n      this._gatherBlocks(outputNode, vertexBlocks);\n    }\n    const fragmentBlocks = [];\n    for (const outputNode of this._fragmentOutputNodes) {\n      this._gatherBlocks(outputNode, fragmentBlocks);\n    }\n    // Generate vertex shader\n    let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\r\\n`;\n    for (const node of vertexBlocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Generate fragment shader\n    for (const node of fragmentBlocks) {\n      if (node.isInput && alreadyDumped.indexOf(node) === -1) {\n        codeString += node._dumpCode(uniqueNames, alreadyDumped);\n      }\n    }\n    // Connections\n    alreadyDumped = [];\n    codeString += \"\\r\\n// Connections\\r\\n\";\n    for (const node of this._vertexOutputNodes) {\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n    for (const node of this._fragmentOutputNodes) {\n      codeString += node._dumpCodeForOutputConnections(alreadyDumped);\n    }\n    // Output nodes\n    codeString += \"\\r\\n// Output nodes\\r\\n\";\n    for (const node of this._vertexOutputNodes) {\n      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\n    }\n    for (const node of this._fragmentOutputNodes) {\n      codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\n    }\n    codeString += `nodeMaterial.build();\\r\\n`;\n    return codeString;\n  }\n  /**\n   * Serializes this material in a JSON representation\n   * @param selectedBlocks\n   * @returns the serialized material object\n   */\n  serialize(selectedBlocks) {\n    const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\n    serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\n    let blocks = [];\n    if (selectedBlocks) {\n      blocks = selectedBlocks;\n    } else {\n      serializationObject.customType = \"BABYLON.NodeMaterial\";\n      serializationObject.outputNodes = [];\n      // Outputs\n      for (const outputNode of this._vertexOutputNodes) {\n        this._gatherBlocks(outputNode, blocks);\n        serializationObject.outputNodes.push(outputNode.uniqueId);\n      }\n      for (const outputNode of this._fragmentOutputNodes) {\n        this._gatherBlocks(outputNode, blocks);\n        if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\n          serializationObject.outputNodes.push(outputNode.uniqueId);\n        }\n      }\n    }\n    // Blocks\n    serializationObject.blocks = [];\n    for (const block of blocks) {\n      serializationObject.blocks.push(block.serialize());\n    }\n    if (!selectedBlocks) {\n      for (const block of this.attachedBlocks) {\n        if (blocks.indexOf(block) !== -1) {\n          continue;\n        }\n        serializationObject.blocks.push(block.serialize());\n      }\n    }\n    return serializationObject;\n  }\n  _restoreConnections(block, source, map) {\n    for (const outputPoint of block.outputs) {\n      for (const candidate of source.blocks) {\n        const target = map[candidate.id];\n        if (!target) {\n          continue;\n        }\n        for (const input of candidate.inputs) {\n          if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\n            const inputPoint = target.getInputByName(input.inputName);\n            if (!inputPoint || inputPoint.isConnected) {\n              continue;\n            }\n            outputPoint.connectTo(inputPoint, true);\n            this._restoreConnections(target, source, map);\n            continue;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   */\n  parseSerializedObject(source, rootUrl = \"\", merge = false) {\n    var _a;\n    if (!merge) {\n      this.clear();\n    }\n    const map = {};\n    // Create blocks\n    for (const parsedBlock of source.blocks) {\n      const blockType = GetClass(parsedBlock.customType);\n      if (blockType) {\n        const block = new blockType();\n        block._deserialize(parsedBlock, this.getScene(), rootUrl);\n        map[parsedBlock.id] = block;\n        this.attachedBlocks.push(block);\n      }\n    }\n    // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\n    for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\n      const parsedBlock = source.blocks[blockIndex];\n      const block = map[parsedBlock.id];\n      if (!block) {\n        continue;\n      }\n      if (block.inputs.length && !merge) {\n        continue;\n      }\n      this._restoreConnections(block, source, map);\n    }\n    // Outputs\n    if (source.outputNodes) {\n      for (const outputNodeId of source.outputNodes) {\n        this.addOutputNode(map[outputNodeId]);\n      }\n    }\n    // UI related info\n    if (source.locations || source.editorData && source.editorData.locations) {\n      const locations = source.locations || source.editorData.locations;\n      for (const location of locations) {\n        if (map[location.blockId]) {\n          location.blockId = map[location.blockId].uniqueId;\n        }\n      }\n      if (merge && this.editorData && this.editorData.locations) {\n        locations.concat(this.editorData.locations);\n      }\n      if (source.locations) {\n        this.editorData = {\n          locations: locations\n        };\n      } else {\n        this.editorData = source.editorData;\n        this.editorData.locations = locations;\n      }\n      const blockMap = [];\n      for (const key in map) {\n        blockMap[key] = map[key].uniqueId;\n      }\n      this.editorData.map = blockMap;\n    }\n    this.comment = source.comment;\n    if (source.forceAlphaBlending !== undefined) {\n      this.forceAlphaBlending = source.forceAlphaBlending;\n    }\n    if (!merge) {\n      this._mode = (_a = source.mode) !== null && _a !== void 0 ? _a : NodeMaterialModes.Material;\n    }\n  }\n  /**\n   * Clear the current graph and load a new one from a serialization object\n   * @param source defines the JSON representation of the material\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param merge defines whether or not the source must be merged or replace the current content\n   * @deprecated Please use the parseSerializedObject method instead\n   */\n  loadFromSerialization(source, rootUrl = \"\", merge = false) {\n    this.parseSerializedObject(source, rootUrl, merge);\n  }\n  /**\n   * Makes a duplicate of the current material.\n   * @param name defines the name to use for the new material\n   * @param shareEffect defines if the clone material should share the same effect (default is false)\n   */\n  clone(name, shareEffect = false) {\n    const serializationObject = this.serialize();\n    const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\n    clone.id = name;\n    clone.name = name;\n    clone.parseSerializedObject(serializationObject);\n    clone._buildId = this._buildId;\n    clone.build(false, !shareEffect);\n    return clone;\n  }\n  /**\n   * Creates a node material from parsed material data\n   * @param source defines the JSON representation of the material\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @returns a new node material\n   */\n  static Parse(source, scene, rootUrl = \"\") {\n    const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\n    nodeMaterial.parseSerializedObject(source, rootUrl);\n    nodeMaterial.build();\n    return nodeMaterial;\n  }\n  /**\n   * Creates a node material from a snippet saved in a remote file\n   * @param name defines the name of the material to create\n   * @param url defines the url to load from\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL for nested url in the node material\n   * @param skipBuild defines whether to build the node material\n   * @param targetMaterial defines a material to use instead of creating a new one\n   * @returns a promise that will resolve to the new node material\n   */\n  static async ParseFromFileAsync(name, url, scene, rootUrl = \"\", skipBuild = false, targetMaterial) {\n    const material = targetMaterial !== null && targetMaterial !== void 0 ? targetMaterial : new NodeMaterial(name, scene);\n    const data = await scene._loadFileAsync(url);\n    const serializationObject = JSON.parse(data);\n    material.parseSerializedObject(serializationObject, rootUrl);\n    if (!skipBuild) {\n      material.build();\n    }\n    return material;\n  }\n  /**\n   * Creates a node material from a snippet saved by the node material editor\n   * @param snippetId defines the snippet to load\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root URL to use to load textures and relative dependencies\n   * @param nodeMaterial defines a node material to update (instead of creating a new one)\n   * @param skipBuild defines whether to build the node material\n   * @returns a promise that will resolve to the new node material\n   */\n  static ParseFromSnippetAsync(snippetId, scene = EngineStore.LastCreatedScene, rootUrl = \"\", nodeMaterial, skipBuild = false) {\n    if (snippetId === \"_BLANK\") {\n      return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\n    }\n    return new Promise((resolve, reject) => {\n      const request = new WebRequest();\n      request.addEventListener(\"readystatechange\", () => {\n        if (request.readyState == 4) {\n          if (request.status == 200) {\n            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n            const serializationObject = JSON.parse(snippet.nodeMaterial);\n            if (!nodeMaterial) {\n              nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\n              nodeMaterial.uniqueId = scene.getUniqueId();\n            }\n            nodeMaterial.parseSerializedObject(serializationObject);\n            nodeMaterial.snippetId = snippetId;\n            try {\n              if (!skipBuild) {\n                nodeMaterial.build();\n              }\n              resolve(nodeMaterial);\n            } catch (err) {\n              reject(err);\n            }\n          } else {\n            reject(\"Unable to load the snippet \" + snippetId);\n          }\n        }\n      });\n      request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n      request.send();\n    });\n  }\n  /**\n   * Creates a new node material set to default basic configuration\n   * @param name defines the name of the material\n   * @param scene defines the hosting scene\n   * @returns a new NodeMaterial\n   */\n  static CreateDefault(name, scene) {\n    const newMaterial = new NodeMaterial(name, scene);\n    newMaterial.setToDefault();\n    newMaterial.build();\n    return newMaterial;\n  }\n}\nNodeMaterial._BuildIdGenerator = 0;\n/** Define the Url to load node editor script */\nNodeMaterial.EditorURL = `https://unpkg.com/babylonjs-node-editor@${Engine.Version}/babylon.nodeEditor.js`;\n/** Define the Url to load snippets */\nNodeMaterial.SnippetUrl = `https://snippet.babylonjs.com`;\n/** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\nNodeMaterial.IgnoreTexturesAtLoadTime = false;\n__decorate([serialize()], NodeMaterial.prototype, \"ignoreAlpha\", void 0);\n__decorate([serialize()], NodeMaterial.prototype, \"maxSimultaneousLights\", void 0);\n__decorate([serialize(\"mode\")], NodeMaterial.prototype, \"_mode\", void 0);\n__decorate([serialize(\"comment\")], NodeMaterial.prototype, \"comment\", void 0);\n__decorate([serialize()], NodeMaterial.prototype, \"forceAlphaBlending\", void 0);\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);","map":{"version":3,"mappings":"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","names":["PushMaterial","ScenePerformancePriority","AbstractMesh","Matrix","Vector2","Color3","Color4","Engine","NodeMaterialBuildState","Effect","Observable","NodeMaterialBlockTargets","NodeMaterialBuildStateSharedData","MaterialDefines","VertexBuffer","Tools","TransformBlock","VertexOutputBlock","FragmentOutputBlock","InputBlock","GetClass","RegisterClass","serialize","SerializationHelper","CurrentScreenBlock","ParticleTextureBlock","ParticleRampGradientBlock","ParticleBlendMultiplyBlock","EffectFallbacks","WebRequest","PostProcess","VectorMergerBlock","RemapBlock","MultiplyBlock","NodeMaterialModes","Texture","BaseParticleSystem","ColorSplitterBlock","TimingTools","ProceduralTexture","AnimatedInputBlockTypes","TrigonometryBlock","TrigonometryBlockOperations","NodeMaterialSystemValues","EngineStore","MaterialHelper","onCreatedEffectParameters","effect","subMesh","NodeMaterialDefines","constructor","rebuild","setValue","name","value","markAsUnprocessedIfDirty","undefined","_keys","push","markAsUnprocessed","NodeMaterial","scene","options","LastCreatedScene","_BuildIdGenerator","Array","_getGlobalNodeMaterialEditor","Material","_options","emitComments","_attachImageProcessingConfiguration","_BlockIsTextureBlock","block","getClassName","NODEEDITOR","BABYLON","NodeEditor","imageProcessingConfiguration","_imageProcessingConfiguration","_markAllSubMeshesAsTexturesDirty","mode","_mode","buildId","_buildId","configuration","_imageProcessingObserver","onUpdateParameters","remove","getScene","add","_markAllSubMeshesAsImageProcessingDirty","getBlockByName","result","attachedBlocks","Warn","getBlockByPredicate","predicate","getInputBlockByPredicate","isInput","getInputBlocks","blocks","registerOptimizer","optimizer","index","_optimizers","indexOf","unregisterOptimizer","splice","addOutputNode","node","target","Vertex","_addVertexOutputNode","Fragment","_addFragmentOutputNode","removeOutputNode","_removeVertexOutputNode","_removeFragmentOutputNode","_vertexOutputNodes","_fragmentOutputNodes","needAlphaBlending","ignoreAlpha","forceAlphaBlending","alpha","_sharedData","hints","needAlphaTesting","_initializeBlock","state","nodesToProcessForOtherBuildState","autoConfigure","initialize","_preparationId","isUnique","className","other","input","inputs","associatedVariableName","connectedPoint","ownerBlock","VertexAndFragment","output","outputs","_resetDualBlocks","id","removeBlock","attachedBlockIndex","isFinalMerger","build","verbose","updateBuildId","_buildWasSuccessful","engine","getEngine","allowEmptyVertexProgram","Particle","length","_vertexCompilationState","supportUniformBuffers","supportsUniformBuffers","_fragmentCompilationState","fragmentOutputNodes","sharedData","vertexNodes","fragmentNodes","vertexOutputNode","fragmentOutputNode","optimize","uniforms","slice","_uniformDeclaration","_constantDeclaration","_vertexState","finalize","emitErrors","console","log","compilationString","onBuildObservable","notifyObservers","meshes","mesh","subMeshes","getMaterial","materialDefines","defines","markAllAsDirty","reset","_prepareDefinesForAttributes","oldNormal","oldTangent","isVerticesDataPresent","NormalKind","TangentKind","uvChanged","i","oldUV","markAsAttributesDirty","createPostProcess","camera","samplingMode","reusable","textureFormat","_createEffectForPostProcess","textureType","createEffectForPostProcess","postProcess","tempName","dummyMesh","_processDefines","RegisterShader","_builtCompilationString","samplers","toString","maxSimultaneousLights","updateEffect","nodeMaterialSource","onApplyObservable","ShadersStore","SetImmediate","_checkInternals","createProceduralTexture","size","proceduralTexture","reservedDataStore","hidden","createEffect","vertexElement","fragmentElement","PositionKind","fallbacks","_setEffect","onBeforeGenerationObservable","_createEffectForParticles","particleSystem","blendMode","onCompiled","onError","particleSystemDefinesJoined","getMeshByName","particleSystemDefines","join","fillDefines","createEffectForParticles","setCustomEffect","onBindObservable","particleSystemDefinesJoinedCurrent","animatedInputs","frameId","getFrameId","_animationFrame","animate","bindableBlocks","bind","inputBlock","inputBlocks","_transmit","BLENDMODE_ONEONE","BLENDMODE_MULTIPLY","createAsShadowDepthWrapper","targetMaterial","shadowDepthWrapper","ShadowDepthWrapper","useInstances","PrepareDefinesForCamera","markAsMiscDirty","blocksWithDefines","forEach","b","initializeDefines","prepareDefines","isDirty","lightDisposed","_areLightsDisposed","markAsProcessed","repeatableContentBlocks","replaceRepeatableContent","uniformBuffers","dynamicUniformBlocks","updateUniformsAndSamples","mergedUniforms","u","mergedSamplers","s","blocksWithFallbacks","provideFallbacks","isReadyForSubMesh","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","_isReadyForSubMesh","blockingBlocks","some","isReady","previousEffect","vertex","fragment","vertexSource","fragmentSource","attributes","uniformsNames","uniformBuffersNames","indexParameters","maxSimultaneousMorphTargets","NUM_MORPH_INFLUENCERS","_onEffectCreatedObservable","allowShaderHotSwapping","resetCachedMaterial","setEffect","_materialContext","_renderId","getRenderId","performancePriority","BackwardCompatible","checkReadyOnlyOnce","compiledShaders","bindOnlyWorldMatrix","world","_activeEffect","needWorldViewMatrix","multiplyToRef","getViewMatrix","_cachedWorldViewMatrix","needWorldViewProjectionMatrix","getTransformMatrix","_cachedWorldViewProjectionMatrix","_transmitWorld","bindForSubMesh","mustRebind","_mustRebind","visibility","forcedBindableBlocks","_afterBind","getActiveTextures","activeTextures","textureBlocks","filter","tb","texture","map","getTextureBlocks","getAllTextureBlocks","hasTexture","t","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","clear","_createNodeEditor","BJSNODEMATERIALEDITOR","Show","nodeMaterial","edit","config","Promise","resolve","editorUrl","editorURL","EditorURL","LoadScript","setToDefault","editorData","positionInput","setAsAttribute","worldInput","setAsSystemValue","World","worldPos","connectTo","viewProjectionInput","ViewProjection","worldPosdMultipliedByViewProjection","vertexOutput","pixelColor","fragmentOutput","setToDefaultPostProcess","position","const1","isConstant","vmerger","scale","visibleInInspector","uv0","uv","currentScreen","setToDefaultProceduralTexture","time","min","max","isBoolean","matrixMode","animationType","Time","color","vectorMerger","cos","operation","Cos","z","xyzOut","rgb","setToDefaultParticle","multiply","rampGradient","cSplitter","blendMultiply","loadAsync","url","rootUrl","ParseFromFileAsync","_gatherBlocks","rootNode","list","generateCode","alreadyDumped","vertexBlocks","uniqueNames","outputNode","fragmentBlocks","codeString","_dumpCode","_dumpCodeForOutputConnections","_codeVariableName","selectedBlocks","serializationObject","Serialize","JSON","parse","stringify","customType","outputNodes","uniqueId","_restoreConnections","source","outputPoint","candidate","targetBlockId","targetConnectionName","inputPoint","getInputByName","inputName","isConnected","parseSerializedObject","merge","parsedBlock","blockType","_deserialize","blockIndex","outputNodeId","locations","location","blockId","concat","blockMap","key","comment","loadFromSerialization","clone","shareEffect","Clone","Parse","skipBuild","material","data","_loadFileAsync","ParseFromSnippetAsync","snippetId","CreateDefault","reject","request","addEventListener","readyState","status","snippet","responseText","jsonPayload","getUniqueId","err","open","SnippetUrl","replace","send","newMaterial","Version","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Node/nodeMaterial.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { ScenePerformancePriority } from \"../../scene\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../Maths/math.color\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { Engine } from \"../../Engines/engine\";\r\nimport { NodeMaterialBuildState } from \"./nodeMaterialBuildState\";\r\nimport type { IEffectCreationOptions } from \"../effect\";\r\nimport { Effect } from \"../effect\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { NodeMaterialBlockTargets } from \"./Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBuildStateSharedData } from \"./nodeMaterialBuildStateSharedData\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport type { NodeMaterialOptimizer } from \"./Optimizers/nodeMaterialOptimizer\";\r\nimport type { ImageProcessingConfiguration, IImageProcessingConfigurationDefines } from \"../imageProcessingConfiguration\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { TransformBlock } from \"./Blocks/transformBlock\";\r\nimport { VertexOutputBlock } from \"./Blocks/Vertex/vertexOutputBlock\";\r\nimport { FragmentOutputBlock } from \"./Blocks/Fragment/fragmentOutputBlock\";\r\nimport { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { serialize, SerializationHelper } from \"../../Misc/decorators\";\r\nimport type { TextureBlock } from \"./Blocks/Dual/textureBlock\";\r\nimport type { ReflectionTextureBaseBlock } from \"./Blocks/Dual/reflectionTextureBaseBlock\";\r\nimport type { RefractionBlock } from \"./Blocks/PBR/refractionBlock\";\r\nimport { CurrentScreenBlock } from \"./Blocks/Dual/currentScreenBlock\";\r\nimport { ParticleTextureBlock } from \"./Blocks/Particle/particleTextureBlock\";\r\nimport { ParticleRampGradientBlock } from \"./Blocks/Particle/particleRampGradientBlock\";\r\nimport { ParticleBlendMultiplyBlock } from \"./Blocks/Particle/particleBlendMultiplyBlock\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { WebRequest } from \"../../Misc/webRequest\";\r\n\r\nimport type { PostProcessOptions } from \"../../PostProcesses/postProcess\";\r\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { VectorMergerBlock } from \"./Blocks/vectorMergerBlock\";\r\nimport { RemapBlock } from \"./Blocks/remapBlock\";\r\nimport { MultiplyBlock } from \"./Blocks/multiplyBlock\";\r\nimport { NodeMaterialModes } from \"./Enums/nodeMaterialModes\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport type { IParticleSystem } from \"../../Particles/IParticleSystem\";\r\nimport { BaseParticleSystem } from \"../../Particles/baseParticleSystem\";\r\nimport { ColorSplitterBlock } from \"./Blocks/colorSplitterBlock\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { ProceduralTexture } from \"../Textures/Procedurals/proceduralTexture\";\r\nimport { AnimatedInputBlockTypes } from \"./Blocks/Input/animatedInputBlockTypes\";\r\nimport { TrigonometryBlock, TrigonometryBlockOperations } from \"./Blocks/trigonometryBlock\";\r\nimport { NodeMaterialSystemValues } from \"./Enums/nodeMaterialSystemValues\";\r\nimport type { ImageSourceBlock } from \"./Blocks/Dual/imageSourceBlock\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { Material } from \"../material\";\r\nimport { MaterialHelper } from \"../materialHelper\";\r\nimport type { TriPlanarBlock } from \"./Blocks/triPlanarBlock\";\r\nimport type { BiPlanarBlock } from \"./Blocks/biPlanarBlock\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n// declare NODEEDITOR namespace for compilation issue\r\ndeclare let NODEEDITOR: any;\r\ndeclare let BABYLON: any;\r\n\r\n/**\r\n * Interface used to configure the node material editor\r\n */\r\nexport interface INodeMaterialEditorOptions {\r\n    /** Define the URl to load node editor script */\r\n    editorURL?: string;\r\n}\r\n\r\n/** @internal */\r\nexport class NodeMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n\r\n    /** BONES */\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n\r\n    /** MORPH TARGETS */\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    /** IMAGE PROCESSING */\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public EXPOSURE = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n\r\n    /** MISC. */\r\n    public BUMPDIRECTUV = 0;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n\r\n    public setValue(name: string, value: any, markAsUnprocessedIfDirty = false) {\r\n        if (this[name] === undefined) {\r\n            this._keys.push(name);\r\n        }\r\n\r\n        if (markAsUnprocessedIfDirty && this[name] !== value) {\r\n            this.markAsUnprocessed();\r\n        }\r\n\r\n        this[name] = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to configure NodeMaterial\r\n */\r\nexport interface INodeMaterialOptions {\r\n    /**\r\n     * Defines if blocks should emit comments\r\n     */\r\n    emitComments: boolean;\r\n}\r\n\r\n/**\r\n * Blocks that manage a texture\r\n */\r\nexport type NodeMaterialTextureBlocks =\r\n    | TextureBlock\r\n    | ReflectionTextureBaseBlock\r\n    | RefractionBlock\r\n    | CurrentScreenBlock\r\n    | ParticleTextureBlock\r\n    | ImageSourceBlock\r\n    | TriPlanarBlock\r\n    | BiPlanarBlock;\r\n\r\n/**\r\n * Class used to create a node based material built by assembling shader blocks\r\n */\r\nexport class NodeMaterial extends PushMaterial {\r\n    private static _BuildIdGenerator: number = 0;\r\n    private _options: INodeMaterialOptions;\r\n    private _vertexCompilationState: NodeMaterialBuildState;\r\n    private _fragmentCompilationState: NodeMaterialBuildState;\r\n    private _sharedData: NodeMaterialBuildStateSharedData;\r\n    private _buildId: number = NodeMaterial._BuildIdGenerator++;\r\n    private _buildWasSuccessful = false;\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _optimizers = new Array<NodeMaterialOptimizer>();\r\n    private _animationFrame = -1;\r\n\r\n    /** Define the Url to load node editor script */\r\n    public static EditorURL = `https://unpkg.com/babylonjs-node-editor@${Engine.Version}/babylon.nodeEditor.js`;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Gets or sets a boolean indicating that node materials should not deserialize textures from json / snippet content */\r\n    public static IgnoreTexturesAtLoadTime = false;\r\n\r\n    /**\r\n     * Checks if a block is a texture block\r\n     * @param block The block to check\r\n     * @returns True if the block is a texture block\r\n     */\r\n    public static _BlockIsTextureBlock(block: NodeMaterialBlock): block is NodeMaterialTextureBlocks {\r\n        return (\r\n            block.getClassName() === \"TextureBlock\" ||\r\n            block.getClassName() === \"ReflectionTextureBaseBlock\" ||\r\n            block.getClassName() === \"RefractionBlock\" ||\r\n            block.getClassName() === \"CurrentScreenBlock\" ||\r\n            block.getClassName() === \"ParticleTextureBlock\" ||\r\n            block.getClassName() === \"ImageSourceBlock\" ||\r\n            block.getClassName() === \"TriPlanarBlock\" ||\r\n            block.getClassName() === \"BiPlanarBlock\"\r\n        );\r\n    }\r\n\r\n    private BJSNODEMATERIALEDITOR = this._getGlobalNodeMaterialEditor();\r\n\r\n    /** Get the inspector from bundle or global */\r\n    private _getGlobalNodeMaterialEditor(): any {\r\n        // UMD Global name detection from Webpack Bundle UMD Name.\r\n        if (typeof NODEEDITOR !== \"undefined\") {\r\n            return NODEEDITOR;\r\n        }\r\n\r\n        // In case of module let's check the global emitted from the editor entry point.\r\n        if (typeof BABYLON !== \"undefined\" && typeof BABYLON.NodeEditor !== \"undefined\") {\r\n            return BABYLON;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Snippet ID if the material was created from the snippet server\r\n     */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Gets or sets data used by visual editor\r\n     * @see https://nme.babylonjs.com\r\n     */\r\n    public editorData: any = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha value must be ignored (This will turn alpha blending off even if an alpha value is produced by the material)\r\n     */\r\n    @serialize()\r\n    public ignoreAlpha = false;\r\n\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @serialize()\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * Observable raised when the material is built\r\n     */\r\n    public onBuildObservable = new Observable<NodeMaterial>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material vertex shader\r\n     */\r\n    public _vertexOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets or sets the root nodes of the material fragment (pixel) shader\r\n     */\r\n    public _fragmentOutputNodes = new Array<NodeMaterialBlock>();\r\n\r\n    /** Gets or sets options to control the node material overall behavior */\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public set options(options: INodeMaterialOptions) {\r\n        this._options = options;\r\n    }\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets an array of blocks that needs to be serialized even if they are not yet connected\r\n     */\r\n    public attachedBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Specifies the mode of the node material\r\n     * @internal\r\n     */\r\n    @serialize(\"mode\")\r\n    public _mode: NodeMaterialModes = NodeMaterialModes.Material;\r\n\r\n    /**\r\n     * Gets or sets the mode property\r\n     */\r\n    public get mode(): NodeMaterialModes {\r\n        return this._mode;\r\n    }\r\n\r\n    public set mode(value: NodeMaterialModes) {\r\n        this._mode = value;\r\n    }\r\n\r\n    /** Gets or sets the unique identifier used to identified the effect associated with the material */\r\n    public get buildId() {\r\n        return this._buildId;\r\n    }\r\n\r\n    public set buildId(value: number) {\r\n        this._buildId = value;\r\n    }\r\n\r\n    /**\r\n     * A free comment about the material\r\n     */\r\n    @serialize(\"comment\")\r\n    public comment: string;\r\n\r\n    /**\r\n     * Create a new node based material\r\n     * @param name defines the material name\r\n     * @param scene defines the hosting scene\r\n     * @param options defines creation option\r\n     */\r\n    constructor(name: string, scene?: Scene, options: Partial<INodeMaterialOptions> = {}) {\r\n        super(name, scene || EngineStore.LastCreatedScene!);\r\n\r\n        this._options = {\r\n            emitComments: false,\r\n            ...options,\r\n        };\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"NodeMaterial\"\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"NodeMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer.\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed.\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer.\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param name defines the name of the block to retrieve\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByName(name: string) {\r\n        let result = null;\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.name === name) {\r\n                if (!result) {\r\n                    result = block;\r\n                } else {\r\n                    Tools.Warn(\"More than one block was found with the name `\" + name + \"`\");\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required block or null if not found\r\n     */\r\n    public getBlockByPredicate(predicate: (block: NodeMaterialBlock) => boolean) {\r\n        for (const block of this.attachedBlocks) {\r\n            if (predicate(block)) {\r\n                return block;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get an input block by its name\r\n     * @param predicate defines the predicate used to find the good candidate\r\n     * @returns the required input block or null if not found\r\n     */\r\n    public getInputBlockByPredicate(predicate: (block: InputBlock) => boolean): Nullable<InputBlock> {\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput && predicate(block as InputBlock)) {\r\n                return block as InputBlock;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of input blocks attached to this material\r\n     * @returns an array of InputBlocks\r\n     */\r\n    public getInputBlocks() {\r\n        const blocks: InputBlock[] = [];\r\n        for (const block of this.attachedBlocks) {\r\n            if (block.isInput) {\r\n                blocks.push(block as InputBlock);\r\n            }\r\n        }\r\n\r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Adds a new optimizer to the list of optimizers\r\n     * @param optimizer defines the optimizers to add\r\n     * @returns the current material\r\n     */\r\n    public registerOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index > -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.push(optimizer);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove an optimizer from the list of optimizers\r\n     * @param optimizer defines the optimizers to remove\r\n     * @returns the current material\r\n     */\r\n    public unregisterOptimizer(optimizer: NodeMaterialOptimizer) {\r\n        const index = this._optimizers.indexOf(optimizer);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._optimizers.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add a new block to the list of output nodes\r\n     * @param node defines the node to add\r\n     * @returns the current material\r\n     */\r\n    public addOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            throw \"This node is not meant to be an output node. You may want to explicitly set its target value.\";\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._addVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._addFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of root nodes\r\n     * @param node defines the node to remove\r\n     * @returns the current material\r\n     */\r\n    public removeOutputNode(node: NodeMaterialBlock) {\r\n        if (node.target === null) {\r\n            return this;\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Vertex) !== 0) {\r\n            this._removeVertexOutputNode(node);\r\n        }\r\n\r\n        if ((node.target & NodeMaterialBlockTargets.Fragment) !== 0) {\r\n            this._removeFragmentOutputNode(node);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addVertexOutputNode(node: NodeMaterialBlock) {\r\n        if (this._vertexOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Vertex;\r\n        this._vertexOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeVertexOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._vertexOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._vertexOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _addFragmentOutputNode(node: NodeMaterialBlock) {\r\n        if (this._fragmentOutputNodes.indexOf(node) !== -1) {\r\n            return;\r\n        }\r\n\r\n        node.target = NodeMaterialBlockTargets.Fragment;\r\n        this._fragmentOutputNodes.push(node);\r\n\r\n        return this;\r\n    }\r\n\r\n    private _removeFragmentOutputNode(node: NodeMaterialBlock) {\r\n        const index = this._fragmentOutputNodes.indexOf(node);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        this._fragmentOutputNodes.splice(index, 1);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that alpha blending must be enabled no matter what alpha value or alpha channel of the FragmentBlock are\r\n     */\r\n    @serialize()\r\n    public forceAlphaBlending = false;\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this.ignoreAlpha) {\r\n            return false;\r\n        }\r\n        return this.forceAlphaBlending || this.alpha < 1.0 || (this._sharedData && this._sharedData.hints.needAlphaBlending);\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._sharedData && this._sharedData.hints.needAlphaTesting;\r\n    }\r\n\r\n    private _initializeBlock(node: NodeMaterialBlock, state: NodeMaterialBuildState, nodesToProcessForOtherBuildState: NodeMaterialBlock[], autoConfigure = true) {\r\n        node.initialize(state);\r\n        if (autoConfigure) {\r\n            node.autoConfigure(this);\r\n        }\r\n        node._preparationId = this._buildId;\r\n\r\n        if (this.attachedBlocks.indexOf(node) === -1) {\r\n            if (node.isUnique) {\r\n                const className = node.getClassName();\r\n\r\n                for (const other of this.attachedBlocks) {\r\n                    if (other.getClassName() === className) {\r\n                        throw `Cannot have multiple blocks of type ${className} in the same NodeMaterial`;\r\n                    }\r\n                }\r\n            }\r\n            this.attachedBlocks.push(node);\r\n        }\r\n\r\n        for (const input of node.inputs) {\r\n            input.associatedVariableName = \"\";\r\n\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    if (block.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    } else if (state.target === NodeMaterialBlockTargets.Fragment && block.target === NodeMaterialBlockTargets.Vertex && block._preparationId !== this._buildId) {\r\n                        nodesToProcessForOtherBuildState.push(block);\r\n                    }\r\n                    this._initializeBlock(block, state, nodesToProcessForOtherBuildState, autoConfigure);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const output of node.outputs) {\r\n            output.associatedVariableName = \"\";\r\n        }\r\n    }\r\n\r\n    private _resetDualBlocks(node: NodeMaterialBlock, id: number) {\r\n        if (node.target === NodeMaterialBlockTargets.VertexAndFragment) {\r\n            node.buildId = id;\r\n        }\r\n\r\n        for (const inputs of node.inputs) {\r\n            const connectedPoint = inputs.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== node) {\r\n                    this._resetDualBlocks(block, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the current node material\r\n     * @param block defines the block to remove\r\n     */\r\n    public removeBlock(block: NodeMaterialBlock) {\r\n        const attachedBlockIndex = this.attachedBlocks.indexOf(block);\r\n        if (attachedBlockIndex > -1) {\r\n            this.attachedBlocks.splice(attachedBlockIndex, 1);\r\n        }\r\n\r\n        if (block.isFinalMerger) {\r\n            this.removeOutputNode(block);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build the material and generates the inner effect\r\n     * @param verbose defines if the build should log activity\r\n     * @param updateBuildId defines if the internal build Id should be updated (default is true)\r\n     * @param autoConfigure defines if the autoConfigure method should be called when initializing blocks (default is true)\r\n     */\r\n    public build(verbose: boolean = false, updateBuildId = true, autoConfigure = true) {\r\n        this._buildWasSuccessful = false;\r\n        const engine = this.getScene().getEngine();\r\n\r\n        const allowEmptyVertexProgram = this._mode === NodeMaterialModes.Particle;\r\n\r\n        if (this._vertexOutputNodes.length === 0 && !allowEmptyVertexProgram) {\r\n            throw \"You must define at least one vertexOutputNode\";\r\n        }\r\n\r\n        if (this._fragmentOutputNodes.length === 0) {\r\n            throw \"You must define at least one fragmentOutputNode\";\r\n        }\r\n\r\n        // Compilation state\r\n        this._vertexCompilationState = new NodeMaterialBuildState();\r\n        this._vertexCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._vertexCompilationState.target = NodeMaterialBlockTargets.Vertex;\r\n        this._fragmentCompilationState = new NodeMaterialBuildState();\r\n        this._fragmentCompilationState.supportUniformBuffers = engine.supportsUniformBuffers;\r\n        this._fragmentCompilationState.target = NodeMaterialBlockTargets.Fragment;\r\n\r\n        // Shared data\r\n        this._sharedData = new NodeMaterialBuildStateSharedData();\r\n        this._sharedData.fragmentOutputNodes = this._fragmentOutputNodes;\r\n        this._vertexCompilationState.sharedData = this._sharedData;\r\n        this._fragmentCompilationState.sharedData = this._sharedData;\r\n        this._sharedData.buildId = this._buildId;\r\n        this._sharedData.emitComments = this._options.emitComments;\r\n        this._sharedData.verbose = verbose;\r\n        this._sharedData.scene = this.getScene();\r\n        this._sharedData.allowEmptyVertexProgram = allowEmptyVertexProgram;\r\n\r\n        // Initialize blocks\r\n        const vertexNodes: NodeMaterialBlock[] = [];\r\n        const fragmentNodes: NodeMaterialBlock[] = [];\r\n\r\n        for (const vertexOutputNode of this._vertexOutputNodes) {\r\n            vertexNodes.push(vertexOutputNode);\r\n            this._initializeBlock(vertexOutputNode, this._vertexCompilationState, fragmentNodes, autoConfigure);\r\n        }\r\n\r\n        for (const fragmentOutputNode of this._fragmentOutputNodes) {\r\n            fragmentNodes.push(fragmentOutputNode);\r\n            this._initializeBlock(fragmentOutputNode, this._fragmentCompilationState, vertexNodes, autoConfigure);\r\n        }\r\n\r\n        // Optimize\r\n        this.optimize();\r\n\r\n        // Vertex\r\n        for (const vertexOutputNode of vertexNodes) {\r\n            vertexOutputNode.build(this._vertexCompilationState, vertexNodes);\r\n        }\r\n\r\n        // Fragment\r\n        this._fragmentCompilationState.uniforms = this._vertexCompilationState.uniforms.slice(0);\r\n        this._fragmentCompilationState._uniformDeclaration = this._vertexCompilationState._uniformDeclaration;\r\n        this._fragmentCompilationState._constantDeclaration = this._vertexCompilationState._constantDeclaration;\r\n        this._fragmentCompilationState._vertexState = this._vertexCompilationState;\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            this._resetDualBlocks(fragmentOutputNode, this._buildId - 1);\r\n        }\r\n\r\n        for (const fragmentOutputNode of fragmentNodes) {\r\n            fragmentOutputNode.build(this._fragmentCompilationState, fragmentNodes);\r\n        }\r\n\r\n        // Finalize\r\n        this._vertexCompilationState.finalize(this._vertexCompilationState);\r\n        this._fragmentCompilationState.finalize(this._fragmentCompilationState);\r\n\r\n        if (updateBuildId) {\r\n            this._buildId = NodeMaterial._BuildIdGenerator++;\r\n        }\r\n\r\n        // Errors\r\n        this._sharedData.emitErrors();\r\n\r\n        if (verbose) {\r\n            console.log(\"Vertex shader:\");\r\n            console.log(this._vertexCompilationState.compilationString);\r\n            console.log(\"Fragment shader:\");\r\n            console.log(this._fragmentCompilationState.compilationString);\r\n        }\r\n\r\n        this._buildWasSuccessful = true;\r\n        this.onBuildObservable.notifyObservers(this);\r\n\r\n        // Wipe defines\r\n        const meshes = this.getScene().meshes;\r\n        for (const mesh of meshes) {\r\n            if (!mesh.subMeshes) {\r\n                continue;\r\n            }\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (subMesh.getMaterial() !== this) {\r\n                    continue;\r\n                }\r\n\r\n                if (!subMesh.materialDefines) {\r\n                    continue;\r\n                }\r\n\r\n                const defines = subMesh.materialDefines;\r\n                defines.markAllAsDirty();\r\n                defines.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs an otpimization phase to try to improve the shader code\r\n     */\r\n    public optimize() {\r\n        for (const optimizer of this._optimizers) {\r\n            optimizer.optimize(this._vertexOutputNodes, this._fragmentOutputNodes);\r\n        }\r\n    }\r\n\r\n    private _prepareDefinesForAttributes(mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const oldNormal = defines[\"NORMAL\"];\r\n        const oldTangent = defines[\"TANGENT\"];\r\n\r\n        defines[\"NORMAL\"] = mesh.isVerticesDataPresent(VertexBuffer.NormalKind);\r\n\r\n        defines[\"TANGENT\"] = mesh.isVerticesDataPresent(VertexBuffer.TangentKind);\r\n\r\n        let uvChanged = false;\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            const oldUV = defines[\"UV\" + i];\r\n            defines[\"UV\" + i] = mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`);\r\n            uvChanged = uvChanged || defines[\"UV\" + i] !== oldUV;\r\n        }\r\n\r\n        if (oldNormal !== defines[\"NORMAL\"] || oldTangent !== defines[\"TANGENT\"] || uvChanged) {\r\n            defines.markAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a post process from the material\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)\r\n     * @returns the post process created\r\n     */\r\n    public createPostProcess(\r\n        camera: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): Nullable<PostProcess> {\r\n        if (this.mode !== NodeMaterialModes.PostProcess) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n        return this._createEffectForPostProcess(null, camera, options, samplingMode, engine, reusable, textureType, textureFormat);\r\n    }\r\n\r\n    /**\r\n     * Create the post process effect from the material\r\n     * @param postProcess The post process to create the effect for\r\n     */\r\n    public createEffectForPostProcess(postProcess: PostProcess) {\r\n        this._createEffectForPostProcess(postProcess);\r\n    }\r\n\r\n    private _createEffectForPostProcess(\r\n        postProcess: Nullable<PostProcess>,\r\n        camera?: Nullable<Camera>,\r\n        options: number | PostProcessOptions = 1,\r\n        samplingMode: number = Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        textureFormat = Constants.TEXTUREFORMAT_RGBA\r\n    ): PostProcess {\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const defines = new NodeMaterialDefines();\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"PostProcess\", this.getScene());\r\n\r\n        let buildId = this._buildId;\r\n\r\n        this._processDefines(dummyMesh, defines);\r\n\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        if (!postProcess) {\r\n            postProcess = new PostProcess(\r\n                this.name + \"PostProcess\",\r\n                tempName,\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                options,\r\n                camera!,\r\n                samplingMode,\r\n                engine,\r\n                reusable,\r\n                defines.toString(),\r\n                textureType,\r\n                tempName,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                false,\r\n                textureFormat\r\n            );\r\n        } else {\r\n            postProcess.updateEffect(\r\n                defines.toString(),\r\n                this._fragmentCompilationState.uniforms,\r\n                this._fragmentCompilationState.samplers,\r\n                { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                undefined,\r\n                undefined,\r\n                tempName,\r\n                tempName\r\n            );\r\n        }\r\n\r\n        postProcess.nodeMaterialSource = this;\r\n\r\n        postProcess.onApplyObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() =>\r\n                    postProcess!.updateEffect(\r\n                        defines.toString(),\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        { maxSimultaneousLights: this.maxSimultaneousLights },\r\n                        undefined,\r\n                        undefined,\r\n                        tempName,\r\n                        tempName\r\n                    )\r\n                );\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return postProcess;\r\n    }\r\n\r\n    /**\r\n     * Create a new procedural texture based on this node material\r\n     * @param size defines the size of the texture\r\n     * @param scene defines the hosting scene\r\n     * @returns the new procedural texture attached to this node material\r\n     */\r\n    public createProceduralTexture(size: number | { width: number; height: number; layers?: number }, scene: Scene): Nullable<ProceduralTexture> {\r\n        if (this.mode !== NodeMaterialModes.ProceduralTexture) {\r\n            console.log(\"Incompatible material mode\");\r\n            return null;\r\n        }\r\n\r\n        let tempName = this.name + this._buildId;\r\n\r\n        const proceduralTexture = new ProceduralTexture(tempName, size, null, scene);\r\n\r\n        const dummyMesh = new AbstractMesh(tempName + \"Procedural\", this.getScene());\r\n        dummyMesh.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const defines = new NodeMaterialDefines();\r\n        const result = this._processDefines(dummyMesh, defines);\r\n        Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n        let effect = this.getScene().getEngine().createEffect(\r\n            {\r\n                vertexElement: tempName,\r\n                fragmentElement: tempName,\r\n            },\r\n            [VertexBuffer.PositionKind],\r\n            this._fragmentCompilationState.uniforms,\r\n            this._fragmentCompilationState.samplers,\r\n            defines.toString(),\r\n            result?.fallbacks,\r\n            undefined\r\n        );\r\n\r\n        proceduralTexture.nodeMaterialSource = this;\r\n        proceduralTexture._setEffect(effect);\r\n\r\n        let buildId = this._buildId;\r\n        proceduralTexture.onBeforeGenerationObservable.add(() => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"VertexShader\"];\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId;\r\n\r\n                defines.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString, this._vertexCompilationState._builtCompilationString);\r\n\r\n                TimingTools.SetImmediate(() => {\r\n                    effect = this.getScene().getEngine().createEffect(\r\n                        {\r\n                            vertexElement: tempName,\r\n                            fragmentElement: tempName,\r\n                        },\r\n                        [VertexBuffer.PositionKind],\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines.toString(),\r\n                        result?.fallbacks,\r\n                        undefined\r\n                    );\r\n\r\n                    proceduralTexture._setEffect(effect);\r\n                });\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n\r\n        return proceduralTexture;\r\n    }\r\n\r\n    private _createEffectForParticles(\r\n        particleSystem: IParticleSystem,\r\n        blendMode: number,\r\n        onCompiled?: (effect: Effect) => void,\r\n        onError?: (effect: Effect, errors: string) => void,\r\n        effect?: Effect,\r\n        defines?: NodeMaterialDefines,\r\n        dummyMesh?: Nullable<AbstractMesh>,\r\n        particleSystemDefinesJoined = \"\"\r\n    ) {\r\n        let tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n        if (!defines) {\r\n            defines = new NodeMaterialDefines();\r\n        }\r\n\r\n        if (!dummyMesh) {\r\n            dummyMesh = this.getScene().getMeshByName(this.name + \"Particle\");\r\n            if (!dummyMesh) {\r\n                dummyMesh = new AbstractMesh(this.name + \"Particle\", this.getScene());\r\n                dummyMesh.reservedDataStore = {\r\n                    hidden: true,\r\n                };\r\n            }\r\n        }\r\n\r\n        let buildId = this._buildId;\r\n\r\n        const particleSystemDefines: Array<string> = [];\r\n        let join = particleSystemDefinesJoined;\r\n\r\n        if (!effect) {\r\n            const result = this._processDefines(dummyMesh, defines);\r\n\r\n            Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            join = particleSystemDefines.join(\"\\n\");\r\n\r\n            effect = this.getScene()\r\n                .getEngine()\r\n                .createEffectForParticles(\r\n                    tempName,\r\n                    this._fragmentCompilationState.uniforms,\r\n                    this._fragmentCompilationState.samplers,\r\n                    defines.toString() + \"\\n\" + join,\r\n                    result?.fallbacks,\r\n                    onCompiled,\r\n                    onError,\r\n                    particleSystem\r\n                );\r\n\r\n            particleSystem.setCustomEffect(effect, blendMode);\r\n        }\r\n\r\n        effect.onBindObservable.add((effect) => {\r\n            if (buildId !== this._buildId) {\r\n                delete Effect.ShadersStore[tempName + \"PixelShader\"];\r\n\r\n                tempName = this.name + this._buildId + \"_\" + blendMode;\r\n\r\n                defines!.markAllAsDirty();\r\n\r\n                buildId = this._buildId;\r\n            }\r\n\r\n            particleSystemDefines.length = 0;\r\n\r\n            particleSystem.fillDefines(particleSystemDefines, blendMode);\r\n\r\n            const particleSystemDefinesJoinedCurrent = particleSystemDefines.join(\"\\n\");\r\n\r\n            if (particleSystemDefinesJoinedCurrent !== join) {\r\n                defines!.markAllAsDirty();\r\n                join = particleSystemDefinesJoinedCurrent;\r\n            }\r\n\r\n            const result = this._processDefines(dummyMesh!, defines!);\r\n\r\n            if (result) {\r\n                Effect.RegisterShader(tempName, this._fragmentCompilationState._builtCompilationString);\r\n\r\n                effect = this.getScene()\r\n                    .getEngine()\r\n                    .createEffectForParticles(\r\n                        tempName,\r\n                        this._fragmentCompilationState.uniforms,\r\n                        this._fragmentCompilationState.samplers,\r\n                        defines!.toString() + \"\\n\" + join,\r\n                        result?.fallbacks,\r\n                        onCompiled,\r\n                        onError,\r\n                        particleSystem\r\n                    );\r\n                particleSystem.setCustomEffect(effect, blendMode);\r\n                this._createEffectForParticles(particleSystem, blendMode, onCompiled, onError, effect, defines, dummyMesh, particleSystemDefinesJoined); // add the effect.onBindObservable observer\r\n                return;\r\n            }\r\n\r\n            this._checkInternals(effect);\r\n        });\r\n    }\r\n\r\n    private _checkInternals(effect: Effect) {\r\n        // Animated blocks\r\n        if (this._sharedData.animatedInputs) {\r\n            const scene = this.getScene();\r\n\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        // Bindable blocks\r\n        for (const block of this._sharedData.bindableBlocks) {\r\n            block.bind(effect, this);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmit(effect, this.getScene(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the effect to be used as the custom effect for a particle system\r\n     * @param particleSystem Particle system to create the effect for\r\n     * @param onCompiled defines a function to call when the effect creation is successful\r\n     * @param onError defines a function to call when the effect creation has failed\r\n     */\r\n    public createEffectForParticles(particleSystem: IParticleSystem, onCompiled?: (effect: Effect) => void, onError?: (effect: Effect, errors: string) => void) {\r\n        if (this.mode !== NodeMaterialModes.Particle) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_ONEONE, onCompiled, onError);\r\n        this._createEffectForParticles(particleSystem, BaseParticleSystem.BLENDMODE_MULTIPLY, onCompiled, onError);\r\n    }\r\n\r\n    /**\r\n     * Use this material as the shadow depth wrapper of a target material\r\n     * @param targetMaterial defines the target material\r\n     */\r\n    public createAsShadowDepthWrapper(targetMaterial: Material) {\r\n        if (this.mode !== NodeMaterialModes.Material) {\r\n            console.log(\"Incompatible material mode\");\r\n            return;\r\n        }\r\n\r\n        targetMaterial.shadowDepthWrapper = new BABYLON.ShadowDepthWrapper(this, this.getScene());\r\n    }\r\n\r\n    private _processDefines(\r\n        mesh: AbstractMesh,\r\n        defines: NodeMaterialDefines,\r\n        useInstances = false,\r\n        subMesh?: SubMesh\r\n    ): Nullable<{\r\n        lightDisposed: boolean;\r\n        uniformBuffers: string[];\r\n        mergedUniforms: string[];\r\n        mergedSamplers: string[];\r\n        fallbacks: EffectFallbacks;\r\n    }> {\r\n        let result = null;\r\n\r\n        // Global defines\r\n        const scene = this.getScene();\r\n        if (MaterialHelper.PrepareDefinesForCamera(scene, defines)) {\r\n            defines.markAsMiscDirty();\r\n        }\r\n\r\n        // Shared defines\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.initializeDefines(mesh, this, defines, useInstances);\r\n        });\r\n\r\n        this._sharedData.blocksWithDefines.forEach((b) => {\r\n            b.prepareDefines(mesh, this, defines, useInstances, subMesh);\r\n        });\r\n\r\n        // Need to recompile?\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Repeatable content generators\r\n            this._vertexCompilationState.compilationString = this._vertexCompilationState._builtCompilationString;\r\n            this._fragmentCompilationState.compilationString = this._fragmentCompilationState._builtCompilationString;\r\n\r\n            this._sharedData.repeatableContentBlocks.forEach((b) => {\r\n                b.replaceRepeatableContent(this._vertexCompilationState, this._fragmentCompilationState, mesh, defines);\r\n            });\r\n\r\n            // Uniforms\r\n            const uniformBuffers: string[] = [];\r\n            this._sharedData.dynamicUniformBlocks.forEach((b) => {\r\n                b.updateUniformsAndSamples(this._vertexCompilationState, this, defines, uniformBuffers);\r\n            });\r\n\r\n            const mergedUniforms = this._vertexCompilationState.uniforms;\r\n\r\n            this._fragmentCompilationState.uniforms.forEach((u) => {\r\n                const index = mergedUniforms.indexOf(u);\r\n\r\n                if (index === -1) {\r\n                    mergedUniforms.push(u);\r\n                }\r\n            });\r\n\r\n            // Samplers\r\n            const mergedSamplers = this._vertexCompilationState.samplers;\r\n\r\n            this._fragmentCompilationState.samplers.forEach((s) => {\r\n                const index = mergedSamplers.indexOf(s);\r\n\r\n                if (index === -1) {\r\n                    mergedSamplers.push(s);\r\n                }\r\n            });\r\n\r\n            const fallbacks = new EffectFallbacks();\r\n\r\n            this._sharedData.blocksWithFallbacks.forEach((b) => {\r\n                b.provideFallbacks(mesh, fallbacks);\r\n            });\r\n\r\n            result = {\r\n                lightDisposed,\r\n                uniformBuffers,\r\n                mergedUniforms,\r\n                mergedSamplers,\r\n                fallbacks,\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._buildWasSuccessful) {\r\n            return false;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (this._sharedData.animatedInputs) {\r\n            const frameId = scene.getFrameId();\r\n\r\n            if (this._animationFrame !== frameId) {\r\n                for (const input of this._sharedData.animatedInputs) {\r\n                    input.animate(scene);\r\n                }\r\n\r\n                this._animationFrame = frameId;\r\n            }\r\n        }\r\n\r\n        if (subMesh.effect && this.isFrozen) {\r\n            if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            subMesh.materialDefines = new NodeMaterialDefines();\r\n        }\r\n\r\n        const defines = <NodeMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        this._prepareDefinesForAttributes(mesh, defines);\r\n\r\n        // Check if blocks are ready\r\n        if (this._sharedData.blockingBlocks.some((b) => !b.isReady(mesh, this, defines, useInstances))) {\r\n            return false;\r\n        }\r\n\r\n        const result = this._processDefines(mesh, defines, useInstances, subMesh);\r\n\r\n        if (result) {\r\n            const previousEffect = subMesh.effect;\r\n            // Compilation\r\n            const join = defines.toString();\r\n            let effect = engine.createEffect(\r\n                {\r\n                    vertex: \"nodeMaterial\" + this._buildId,\r\n                    fragment: \"nodeMaterial\" + this._buildId,\r\n                    vertexSource: this._vertexCompilationState.compilationString,\r\n                    fragmentSource: this._fragmentCompilationState.compilationString,\r\n                },\r\n                <IEffectCreationOptions>{\r\n                    attributes: this._vertexCompilationState.attributes,\r\n                    uniformsNames: result.mergedUniforms,\r\n                    uniformBuffersNames: result.uniformBuffers,\r\n                    samplers: result.mergedSamplers,\r\n                    defines: join,\r\n                    fallbacks: result.fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousLights: this.maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS },\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    if (result.lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        subMesh.effect._wasPreviouslyReady = true;\r\n        subMesh.effect._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        if (scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {\r\n            this.checkReadyOnlyOnce = true;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get a string representing the shaders built by the current node graph\r\n     */\r\n    public get compiledShaders() {\r\n        return `// Vertex shader\\r\\n${this._vertexCompilationState.compilationString}\\r\\n\\r\\n// Fragment shader\\r\\n${this._fragmentCompilationState.compilationString}`;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!this._activeEffect) {\r\n            return;\r\n        }\r\n\r\n        const hints = this._sharedData.hints;\r\n\r\n        if (hints.needWorldViewMatrix) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (hints.needWorldViewProjectionMatrix) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        // Connection points\r\n        for (const inputBlock of this._sharedData.inputBlocks) {\r\n            inputBlock._transmitWorld(this._activeEffect, world, this._cachedWorldViewMatrix, this._cachedWorldViewProjectionMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, mesh.visibility);\r\n        const sharedData = this._sharedData;\r\n\r\n        if (mustRebind) {\r\n            // Bindable blocks\r\n            for (const block of sharedData.bindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n\r\n            // Connection points\r\n            for (const inputBlock of sharedData.inputBlocks) {\r\n                inputBlock._transmit(effect, scene, this);\r\n            }\r\n        } else if (!this.isFrozen) {\r\n            for (const block of sharedData.forcedBindableBlocks) {\r\n                block.bind(effect, this, mesh, subMesh);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._sharedData) {\r\n            activeTextures.push(...this._sharedData.textureBlocks.filter((tb) => tb.texture).map((tb) => tb.texture!));\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of texture blocks\r\n     * Note that this method will only return blocks that are reachable from the final block(s) and only after the material has been built!\r\n     * @returns an array of texture blocks\r\n     */\r\n    public getTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        if (!this._sharedData) {\r\n            return [];\r\n        }\r\n\r\n        return this._sharedData.textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all texture blocks\r\n     * Note that this method will scan all attachedBlocks and return blocks that are texture blocks\r\n     * @returns\r\n     */\r\n    public getAllTextureBlocks(): NodeMaterialTextureBlocks[] {\r\n        const textureBlocks: NodeMaterialTextureBlocks[] = [];\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            if (NodeMaterial._BlockIsTextureBlock(block)) {\r\n                textureBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        return textureBlocks;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._sharedData) {\r\n            return false;\r\n        }\r\n\r\n        for (const t of this._sharedData.textureBlocks) {\r\n            if (t.texture === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            for (const texture of this.getTextureBlocks()\r\n                .filter((tb) => tb.texture)\r\n                .map((tb) => tb.texture!)) {\r\n                texture.dispose();\r\n            }\r\n        }\r\n\r\n        for (const block of this.attachedBlocks) {\r\n            block.dispose();\r\n        }\r\n\r\n        this.attachedBlocks.length = 0;\r\n        (this._sharedData as any) = null;\r\n        (this._vertexCompilationState as any) = null;\r\n        (this._fragmentCompilationState as any) = null;\r\n\r\n        this.onBuildObservable.clear();\r\n\r\n        if (this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n            this._imageProcessingObserver = null;\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /** Creates the node editor window. */\r\n    private _createNodeEditor() {\r\n        this.BJSNODEMATERIALEDITOR.NodeEditor.Show({\r\n            nodeMaterial: this,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Launch the node material editor\r\n     * @param config Define the configuration of the editor\r\n     * @returns a promise fulfilled when the node editor is visible\r\n     */\r\n    public edit(config?: INodeMaterialEditorOptions): Promise<void> {\r\n        return new Promise((resolve) => {\r\n            this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n            if (typeof this.BJSNODEMATERIALEDITOR == \"undefined\") {\r\n                const editorUrl = config && config.editorURL ? config.editorURL : NodeMaterial.EditorURL;\r\n\r\n                // Load editor and add it to the DOM\r\n                Tools.LoadScript(editorUrl, () => {\r\n                    this.BJSNODEMATERIALEDITOR = this.BJSNODEMATERIALEDITOR || this._getGlobalNodeMaterialEditor();\r\n                    this._createNodeEditor();\r\n                    resolve();\r\n                });\r\n            } else {\r\n                // Otherwise creates the editor\r\n                this._createNodeEditor();\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear the current material\r\n     */\r\n    public clear() {\r\n        this._vertexOutputNodes.length = 0;\r\n        this._fragmentOutputNodes.length = 0;\r\n        this.attachedBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state\r\n     */\r\n    public setToDefault() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const positionInput = new InputBlock(\"Position\");\r\n        positionInput.setAsAttribute(\"position\");\r\n\r\n        const worldInput = new InputBlock(\"World\");\r\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n\r\n        const worldPos = new TransformBlock(\"WorldPos\");\r\n        positionInput.connectTo(worldPos);\r\n        worldInput.connectTo(worldPos);\r\n\r\n        const viewProjectionInput = new InputBlock(\"ViewProjection\");\r\n        viewProjectionInput.setAsSystemValue(NodeMaterialSystemValues.ViewProjection);\r\n\r\n        const worldPosdMultipliedByViewProjection = new TransformBlock(\"WorldPos * ViewProjectionTransform\");\r\n        worldPos.connectTo(worldPosdMultipliedByViewProjection);\r\n        viewProjectionInput.connectTo(worldPosdMultipliedByViewProjection);\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        worldPosdMultipliedByViewProjection.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const pixelColor = new InputBlock(\"color\");\r\n        pixelColor.value = new Color4(0.8, 0.8, 0.8, 1);\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        pixelColor.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Material;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for post process\r\n     */\r\n    public setToDefaultPostProcess() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const scale = new InputBlock(\"Scale\");\r\n        scale.visibleInInspector = true;\r\n        scale.value = new Vector2(1, 1);\r\n\r\n        const uv0 = new RemapBlock(\"uv0\");\r\n        position.connectTo(uv0);\r\n\r\n        const uv = new MultiplyBlock(\"UV scale\");\r\n        uv0.connectTo(uv);\r\n        scale.connectTo(uv);\r\n\r\n        const currentScreen = new CurrentScreenBlock(\"CurrentScreen\");\r\n        uv.connectTo(currentScreen);\r\n\r\n        currentScreen.texture = new Texture(\"https://assets.babylonjs.com/nme/currentScreenPostProcess.png\", this.getScene());\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        currentScreen.connectTo(fragmentOutput, { output: \"rgba\" });\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.PostProcess;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for procedural texture\r\n     */\r\n    public setToDefaultProceduralTexture() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        const position = new InputBlock(\"Position\");\r\n        position.setAsAttribute(\"position2d\");\r\n\r\n        const const1 = new InputBlock(\"Constant1\");\r\n        const1.isConstant = true;\r\n        const1.value = 1;\r\n\r\n        const vmerger = new VectorMergerBlock(\"Position3D\");\r\n\r\n        position.connectTo(vmerger);\r\n        const1.connectTo(vmerger, { input: \"w\" });\r\n\r\n        const vertexOutput = new VertexOutputBlock(\"VertexOutput\");\r\n        vmerger.connectTo(vertexOutput);\r\n\r\n        // Pixel\r\n        const time = new InputBlock(\"Time\");\r\n        time.value = 0;\r\n        time.min = 0;\r\n        time.max = 0;\r\n        time.isBoolean = false;\r\n        time.matrixMode = 0;\r\n        time.animationType = AnimatedInputBlockTypes.Time;\r\n        time.isConstant = false;\r\n\r\n        const color = new InputBlock(\"Color3\");\r\n        color.value = new Color3(1, 1, 1);\r\n        color.isConstant = false;\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n\r\n        const vectorMerger = new VectorMergerBlock(\"VectorMerger\");\r\n        vectorMerger.visibleInInspector = false;\r\n\r\n        const cos = new TrigonometryBlock(\"Cos\");\r\n        cos.operation = TrigonometryBlockOperations.Cos;\r\n\r\n        position.connectTo(vectorMerger);\r\n        time.output.connectTo(cos.input);\r\n        cos.output.connectTo(vectorMerger.z);\r\n        vectorMerger.xyzOut.connectTo(fragmentOutput.rgb);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(vertexOutput);\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.ProceduralTexture;\r\n    }\r\n\r\n    /**\r\n     * Clear the current material and set it to a default state for particle\r\n     */\r\n    public setToDefaultParticle() {\r\n        this.clear();\r\n\r\n        this.editorData = null;\r\n\r\n        // Pixel\r\n        const uv = new InputBlock(\"uv\");\r\n        uv.setAsAttribute(\"particle_uv\");\r\n\r\n        const texture = new ParticleTextureBlock(\"ParticleTexture\");\r\n        uv.connectTo(texture);\r\n\r\n        const color = new InputBlock(\"Color\");\r\n        color.setAsAttribute(\"particle_color\");\r\n\r\n        const multiply = new MultiplyBlock(\"Texture * Color\");\r\n        texture.connectTo(multiply);\r\n        color.connectTo(multiply);\r\n\r\n        const rampGradient = new ParticleRampGradientBlock(\"ParticleRampGradient\");\r\n        multiply.connectTo(rampGradient);\r\n\r\n        const cSplitter = new ColorSplitterBlock(\"ColorSplitter\");\r\n        color.connectTo(cSplitter);\r\n\r\n        const blendMultiply = new ParticleBlendMultiplyBlock(\"ParticleBlendMultiply\");\r\n        rampGradient.connectTo(blendMultiply);\r\n        texture.connectTo(blendMultiply, { output: \"a\" });\r\n        cSplitter.connectTo(blendMultiply, { output: \"a\" });\r\n\r\n        const fragmentOutput = new FragmentOutputBlock(\"FragmentOutput\");\r\n        blendMultiply.connectTo(fragmentOutput);\r\n\r\n        // Add to nodes\r\n        this.addOutputNode(fragmentOutput);\r\n\r\n        this._mode = NodeMaterialModes.Particle;\r\n    }\r\n\r\n    /**\r\n     * Loads the current Node Material from a url pointing to a file save by the Node Material Editor\r\n     * @deprecated Please use NodeMaterial.ParseFromFileAsync instead\r\n     * @param url defines the url to load from\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @returns a promise that will fulfil when the material is fully loaded\r\n     */\r\n    public async loadAsync(url: string, rootUrl: string = \"\") {\r\n        return NodeMaterial.ParseFromFileAsync(\"\", url, this.getScene(), rootUrl, true, this);\r\n    }\r\n\r\n    private _gatherBlocks(rootNode: NodeMaterialBlock, list: NodeMaterialBlock[]) {\r\n        if (list.indexOf(rootNode) !== -1) {\r\n            return;\r\n        }\r\n        list.push(rootNode);\r\n\r\n        for (const input of rootNode.inputs) {\r\n            const connectedPoint = input.connectedPoint;\r\n            if (connectedPoint) {\r\n                const block = connectedPoint.ownerBlock;\r\n                if (block !== rootNode) {\r\n                    this._gatherBlocks(block, list);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generate a string containing the code declaration required to create an equivalent of this material\r\n     * @returns a string\r\n     */\r\n    public generateCode() {\r\n        let alreadyDumped: NodeMaterialBlock[] = [];\r\n        const vertexBlocks: NodeMaterialBlock[] = [];\r\n        const uniqueNames: string[] = [\"const\", \"var\", \"let\"];\r\n        // Gets active blocks\r\n        for (const outputNode of this._vertexOutputNodes) {\r\n            this._gatherBlocks(outputNode, vertexBlocks);\r\n        }\r\n\r\n        const fragmentBlocks: NodeMaterialBlock[] = [];\r\n        for (const outputNode of this._fragmentOutputNodes) {\r\n            this._gatherBlocks(outputNode, fragmentBlocks);\r\n        }\r\n\r\n        // Generate vertex shader\r\n        let codeString = `var nodeMaterial = new BABYLON.NodeMaterial(\"${this.name || \"node material\"}\");\\r\\n`;\r\n        for (const node of vertexBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Generate fragment shader\r\n        for (const node of fragmentBlocks) {\r\n            if (node.isInput && alreadyDumped.indexOf(node) === -1) {\r\n                codeString += node._dumpCode(uniqueNames, alreadyDumped);\r\n            }\r\n        }\r\n\r\n        // Connections\r\n        alreadyDumped = [];\r\n        codeString += \"\\r\\n// Connections\\r\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += node._dumpCodeForOutputConnections(alreadyDumped);\r\n        }\r\n\r\n        // Output nodes\r\n        codeString += \"\\r\\n// Output nodes\\r\\n\";\r\n        for (const node of this._vertexOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        for (const node of this._fragmentOutputNodes) {\r\n            codeString += `nodeMaterial.addOutputNode(${node._codeVariableName});\\r\\n`;\r\n        }\r\n\r\n        codeString += `nodeMaterial.build();\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @param selectedBlocks\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(selectedBlocks?: NodeMaterialBlock[]): any {\r\n        const serializationObject = selectedBlocks ? {} : SerializationHelper.Serialize(this);\r\n        serializationObject.editorData = JSON.parse(JSON.stringify(this.editorData)); // Copy\r\n\r\n        let blocks: NodeMaterialBlock[] = [];\r\n\r\n        if (selectedBlocks) {\r\n            blocks = selectedBlocks;\r\n        } else {\r\n            serializationObject.customType = \"BABYLON.NodeMaterial\";\r\n            serializationObject.outputNodes = [];\r\n\r\n            // Outputs\r\n            for (const outputNode of this._vertexOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n                serializationObject.outputNodes.push(outputNode.uniqueId);\r\n            }\r\n\r\n            for (const outputNode of this._fragmentOutputNodes) {\r\n                this._gatherBlocks(outputNode, blocks);\r\n\r\n                if (serializationObject.outputNodes.indexOf(outputNode.uniqueId) === -1) {\r\n                    serializationObject.outputNodes.push(outputNode.uniqueId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Blocks\r\n        serializationObject.blocks = [];\r\n\r\n        for (const block of blocks) {\r\n            serializationObject.blocks.push(block.serialize());\r\n        }\r\n\r\n        if (!selectedBlocks) {\r\n            for (const block of this.attachedBlocks) {\r\n                if (blocks.indexOf(block) !== -1) {\r\n                    continue;\r\n                }\r\n                serializationObject.blocks.push(block.serialize());\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _restoreConnections(block: NodeMaterialBlock, source: any, map: { [key: number]: NodeMaterialBlock }) {\r\n        for (const outputPoint of block.outputs) {\r\n            for (const candidate of source.blocks) {\r\n                const target = map[candidate.id];\r\n\r\n                if (!target) {\r\n                    continue;\r\n                }\r\n\r\n                for (const input of candidate.inputs) {\r\n                    if (map[input.targetBlockId] === block && input.targetConnectionName === outputPoint.name) {\r\n                        const inputPoint = target.getInputByName(input.inputName);\r\n                        if (!inputPoint || inputPoint.isConnected) {\r\n                            continue;\r\n                        }\r\n\r\n                        outputPoint.connectTo(inputPoint, true);\r\n                        this._restoreConnections(target, source, map);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     */\r\n    public parseSerializedObject(source: any, rootUrl: string = \"\", merge = false) {\r\n        if (!merge) {\r\n            this.clear();\r\n        }\r\n\r\n        const map: { [key: number]: NodeMaterialBlock } = {};\r\n\r\n        // Create blocks\r\n        for (const parsedBlock of source.blocks) {\r\n            const blockType = GetClass(parsedBlock.customType);\r\n            if (blockType) {\r\n                const block: NodeMaterialBlock = new blockType();\r\n                block._deserialize(parsedBlock, this.getScene(), rootUrl);\r\n                map[parsedBlock.id] = block;\r\n\r\n                this.attachedBlocks.push(block);\r\n            }\r\n        }\r\n\r\n        // Connections - Starts with input blocks only (except if in \"merge\" mode where we scan all blocks)\r\n        for (let blockIndex = 0; blockIndex < source.blocks.length; blockIndex++) {\r\n            const parsedBlock = source.blocks[blockIndex];\r\n            const block = map[parsedBlock.id];\r\n\r\n            if (!block) {\r\n                continue;\r\n            }\r\n\r\n            if (block.inputs.length && !merge) {\r\n                continue;\r\n            }\r\n            this._restoreConnections(block, source, map);\r\n        }\r\n\r\n        // Outputs\r\n        if (source.outputNodes) {\r\n            for (const outputNodeId of source.outputNodes) {\r\n                this.addOutputNode(map[outputNodeId]);\r\n            }\r\n        }\r\n\r\n        // UI related info\r\n        if (source.locations || (source.editorData && source.editorData.locations)) {\r\n            const locations: {\r\n                blockId: number;\r\n                x: number;\r\n                y: number;\r\n            }[] = source.locations || source.editorData.locations;\r\n\r\n            for (const location of locations) {\r\n                if (map[location.blockId]) {\r\n                    location.blockId = map[location.blockId].uniqueId;\r\n                }\r\n            }\r\n\r\n            if (merge && this.editorData && this.editorData.locations) {\r\n                locations.concat(this.editorData.locations);\r\n            }\r\n\r\n            if (source.locations) {\r\n                this.editorData = {\r\n                    locations: locations,\r\n                };\r\n            } else {\r\n                this.editorData = source.editorData;\r\n                this.editorData.locations = locations;\r\n            }\r\n\r\n            const blockMap: number[] = [];\r\n\r\n            for (const key in map) {\r\n                blockMap[key] = map[key].uniqueId;\r\n            }\r\n\r\n            this.editorData.map = blockMap;\r\n        }\r\n\r\n        this.comment = source.comment;\r\n\r\n        if (source.forceAlphaBlending !== undefined) {\r\n            this.forceAlphaBlending = source.forceAlphaBlending;\r\n        }\r\n\r\n        if (!merge) {\r\n            this._mode = source.mode ?? NodeMaterialModes.Material;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear the current graph and load a new one from a serialization object\r\n     * @param source defines the JSON representation of the material\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param merge defines whether or not the source must be merged or replace the current content\r\n     * @deprecated Please use the parseSerializedObject method instead\r\n     */\r\n    public loadFromSerialization(source: any, rootUrl: string = \"\", merge = false) {\r\n        this.parseSerializedObject(source, rootUrl, merge);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name defines the name to use for the new material\r\n     * @param shareEffect defines if the clone material should share the same effect (default is false)\r\n     */\r\n    public clone(name: string, shareEffect: boolean = false): NodeMaterial {\r\n        const serializationObject = this.serialize();\r\n\r\n        const clone = SerializationHelper.Clone(() => new NodeMaterial(name, this.getScene(), this.options), this);\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        clone.parseSerializedObject(serializationObject);\r\n        clone._buildId = this._buildId;\r\n        clone.build(false, !shareEffect);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new node material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string = \"\"): NodeMaterial {\r\n        const nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        nodeMaterial.parseSerializedObject(source, rootUrl);\r\n        nodeMaterial.build();\r\n\r\n        return nodeMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved in a remote file\r\n     * @param name defines the name of the material to create\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL for nested url in the node material\r\n     * @param skipBuild defines whether to build the node material\r\n     * @param targetMaterial defines a material to use instead of creating a new one\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        name: string,\r\n        url: string,\r\n        scene: Scene,\r\n        rootUrl: string = \"\",\r\n        skipBuild: boolean = false,\r\n        targetMaterial?: NodeMaterial\r\n    ): Promise<NodeMaterial> {\r\n        const material = targetMaterial ?? new NodeMaterial(name, scene);\r\n\r\n        const data = await scene._loadFileAsync(url);\r\n        const serializationObject = JSON.parse(data as string);\r\n        material.parseSerializedObject(serializationObject, rootUrl);\r\n        if (!skipBuild) {\r\n            material.build();\r\n        }\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a node material from a snippet saved by the node material editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @param nodeMaterial defines a node material to update (instead of creating a new one)\r\n     * @param skipBuild defines whether to build the node material\r\n     * @returns a promise that will resolve to the new node material\r\n     */\r\n    public static ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scene: Scene = EngineStore.LastCreatedScene!,\r\n        rootUrl: string = \"\",\r\n        nodeMaterial?: NodeMaterial,\r\n        skipBuild: boolean = false\r\n    ): Promise<NodeMaterial> {\r\n        if (snippetId === \"_BLANK\") {\r\n            return Promise.resolve(NodeMaterial.CreateDefault(\"blank\", scene));\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.nodeMaterial);\r\n\r\n                        if (!nodeMaterial) {\r\n                            nodeMaterial = SerializationHelper.Parse(() => new NodeMaterial(snippetId, scene), serializationObject, scene, rootUrl);\r\n                            nodeMaterial.uniqueId = scene.getUniqueId();\r\n                        }\r\n\r\n                        nodeMaterial.parseSerializedObject(serializationObject);\r\n                        nodeMaterial.snippetId = snippetId;\r\n\r\n                        try {\r\n                            if (!skipBuild) {\r\n                                nodeMaterial.build();\r\n                            }\r\n                            resolve(nodeMaterial);\r\n                        } catch (err) {\r\n                            reject(err);\r\n                        }\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new node material set to default basic configuration\r\n     * @param name defines the name of the material\r\n     * @param scene defines the hosting scene\r\n     * @returns a new NodeMaterial\r\n     */\r\n    public static CreateDefault(name: string, scene?: Scene) {\r\n        const newMaterial = new NodeMaterial(name, scene);\r\n\r\n        newMaterial.setToDefault();\r\n        newMaterial.build();\r\n\r\n        return newMaterial;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NodeMaterial\", NodeMaterial);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}