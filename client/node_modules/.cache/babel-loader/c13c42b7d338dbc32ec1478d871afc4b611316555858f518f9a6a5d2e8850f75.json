{"ast":null,"code":"import { EngineInstrumentation } from \"../../Instrumentation/engineInstrumentation.js\";\nimport { PrecisionDate } from \"../precisionDate.js\";\nimport { SceneInstrumentation } from \"../../Instrumentation/sceneInstrumentation.js\";\nimport { PressureObserverWrapper } from \"../pressureObserverWrapper.js\";\n// Dispose which does nothing.\nconst defaultDisposeImpl = () => {};\n/**\n * Defines the predefined strategies used in the performance viewer.\n */\nexport class PerfCollectionStrategy {\n  /**\n   * Gets the initializer for the strategy used for collection of fps metrics\n   * @returns the initializer for the fps strategy\n   */\n  static FpsStrategy() {\n    return scene => {\n      const engine = scene.getEngine();\n      return {\n        id: \"FPS\",\n        getData: () => engine.getFps(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of thermal utilization metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the thermal utilization strategy\n   */\n  static ThermalStrategy() {\n    return this._PressureStrategy(\"Thermal utilization\", \"thermal\");\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of power supply utilization metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the power supply utilization strategy\n   */\n  static PowerSupplyStrategy() {\n    return this._PressureStrategy(\"Power supply utilization\", \"power-supply\");\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of pressure metrics.\n   * Needs the experimental pressure API.\n   * @returns the initializer for the pressure strategy\n   */\n  static PressureStrategy() {\n    return this._PressureStrategy(\"Pressure\");\n  }\n  static _PressureStrategy(name, factor = null) {\n    return () => {\n      let value = 0;\n      const wrapper = new PressureObserverWrapper();\n      wrapper.observe(\"cpu\");\n      wrapper.onPressureChanged.add(update => {\n        for (const record of update) {\n          if (factor && record.factors.includes(factor) || !factor && record.factors.length === 0) {\n            // Let s consider each step being 25% of the total pressure.\n            switch (record.state) {\n              case \"nominal\":\n                value = 0;\n                break;\n              case \"fair\":\n                value = 0.25;\n                break;\n              case \"serious\":\n                value = 0.5;\n                break;\n              case \"critical\":\n                value = 1;\n                break;\n            }\n          }\n        }\n      });\n      return {\n        id: name,\n        getData: () => value,\n        dispose: () => wrapper.dispose()\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total meshes metrics.\n   * @returns the initializer for the total meshes strategy\n   */\n  static TotalMeshesStrategy() {\n    return scene => {\n      return {\n        id: \"Total meshes\",\n        getData: () => scene.meshes.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active meshes metrics.\n   * @returns the initializer for the active meshes strategy\n   */\n  static ActiveMeshesStrategy() {\n    return scene => {\n      return {\n        id: \"Active meshes\",\n        getData: () => scene.getActiveMeshes().length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active indices metrics.\n   * @returns the initializer for the active indices strategy\n   */\n  static ActiveIndicesStrategy() {\n    return scene => {\n      return {\n        id: \"Active indices\",\n        getData: () => scene.getActiveIndices(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active faces metrics.\n   * @returns the initializer for the active faces strategy\n   */\n  static ActiveFacesStrategy() {\n    return scene => {\n      return {\n        id: \"Active faces\",\n        getData: () => scene.getActiveIndices() / 3,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active bones metrics.\n   * @returns the initializer for the active bones strategy\n   */\n  static ActiveBonesStrategy() {\n    return scene => {\n      return {\n        id: \"Active bones\",\n        getData: () => scene.getActiveBones(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of active particles metrics.\n   * @returns the initializer for the active particles strategy\n   */\n  static ActiveParticlesStrategy() {\n    return scene => {\n      return {\n        id: \"Active particles\",\n        getData: () => scene.getActiveParticles(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of draw calls metrics.\n   * @returns the initializer for the draw calls strategy\n   */\n  static DrawCallsStrategy() {\n    return scene => {\n      let drawCalls = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        scene.getEngine()._drawCalls.fetchNewFrame();\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        drawCalls = scene.getEngine()._drawCalls.current;\n      });\n      return {\n        id: \"Draw calls\",\n        getData: () => drawCalls,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total lights metrics.\n   * @returns the initializer for the total lights strategy\n   */\n  static TotalLightsStrategy() {\n    return scene => {\n      return {\n        id: \"Total lights\",\n        getData: () => scene.lights.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total vertices metrics.\n   * @returns the initializer for the total vertices strategy\n   */\n  static TotalVerticesStrategy() {\n    return scene => {\n      return {\n        id: \"Total vertices\",\n        getData: () => scene.getTotalVertices(),\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total materials metrics.\n   * @returns the initializer for the total materials strategy\n   */\n  static TotalMaterialsStrategy() {\n    return scene => {\n      return {\n        id: \"Total materials\",\n        getData: () => scene.materials.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total textures metrics.\n   * @returns the initializer for the total textures strategy\n   */\n  static TotalTexturesStrategy() {\n    return scene => {\n      return {\n        id: \"Total textures\",\n        getData: () => scene.textures.length,\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of absolute fps metrics.\n   * @returns the initializer for the absolute fps strategy\n   */\n  static AbsoluteFpsStrategy() {\n    return scene => {\n      const sceneInstrumentation = new SceneInstrumentation(scene);\n      sceneInstrumentation.captureFrameTime = true;\n      return {\n        id: \"Absolute FPS\",\n        getData: () => {\n          return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;\n        },\n        dispose: defaultDisposeImpl\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of meshes selection time metrics.\n   * @returns the initializer for the meshes selection time strategy\n   */\n  static MeshesSelectionStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Meshes Selection\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);\n          scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of render targets time metrics.\n   * @returns the initializer for the render targets time strategy\n   */\n  static RenderTargetsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Render Targets\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);\n          scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of particles time metrics.\n   * @returns the initializer for the particles time strategy\n   */\n  static ParticlesStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Particles\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);\n          scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of sprites time metrics.\n   * @returns the initializer for the sprites time strategy\n   */\n  static SpritesStrategy() {\n    return scene => {\n      var _a, _b;\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeSpritesObserver = (_a = scene.onBeforeSpritesRenderingObservable) === null || _a === void 0 ? void 0 : _a.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterSpritesObserver = (_b = scene.onAfterSpritesRenderingObservable) === null || _b === void 0 ? void 0 : _b.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Sprites\",\n        getData: () => timeTaken,\n        dispose: () => {\n          var _a, _b;\n          (_a = scene.onBeforeSpritesRenderingObservable) === null || _a === void 0 ? void 0 : _a.remove(onBeforeSpritesObserver);\n          (_b = scene.onAfterSpritesRenderingObservable) === null || _b === void 0 ? void 0 : _b.remove(onAfterSpritesObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of animations time metrics.\n   * @returns the initializer for the animations time strategy\n   */\n  static AnimationsStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Animations\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of physics time metrics.\n   * @returns the initializer for the physics time strategy\n   */\n  static PhysicsStrategy() {\n    return scene => {\n      var _a, _b;\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforePhysicsObserver = (_a = scene.onBeforePhysicsObservable) === null || _a === void 0 ? void 0 : _a.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterPhysicsObserver = (_b = scene.onAfterPhysicsObservable) === null || _b === void 0 ? void 0 : _b.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Physics\",\n        getData: () => timeTaken,\n        dispose: () => {\n          var _a, _b;\n          (_a = scene.onBeforePhysicsObservable) === null || _a === void 0 ? void 0 : _a.remove(onBeforePhysicsObserver);\n          (_b = scene.onAfterPhysicsObservable) === null || _b === void 0 ? void 0 : _b.remove(onAfterPhysicsObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of render time metrics.\n   * @returns the initializer for the render time strategy\n   */\n  static RenderStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Render\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);\n          scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of total frame time metrics.\n   * @returns the initializer for the total frame time strategy\n   */\n  static FrameTotalStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      return {\n        id: \"Frame Total\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of inter-frame time metrics.\n   * @returns the initializer for the inter-frame time strategy\n   */\n  static InterFrameStrategy() {\n    return scene => {\n      let startTime = PrecisionDate.Now;\n      let timeTaken = 0;\n      const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n        timeTaken = PrecisionDate.Now - startTime;\n      });\n      const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\n        startTime = PrecisionDate.Now;\n      });\n      return {\n        id: \"Inter-frame\",\n        getData: () => timeTaken,\n        dispose: () => {\n          scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\n          scene.onAfterRenderObservable.remove(onAfterRenderObserver);\n        }\n      };\n    };\n  }\n  /**\n   * Gets the initializer for the strategy used for collection of gpu frame time metrics.\n   * @returns the initializer for the gpu frame time strategy\n   */\n  static GpuFrameTimeStrategy() {\n    return scene => {\n      const engineInstrumentation = new EngineInstrumentation(scene.getEngine());\n      engineInstrumentation.captureGPUFrameTime = true;\n      return {\n        id: \"GPU frame time\",\n        getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),\n        dispose: () => {\n          engineInstrumentation.dispose();\n        }\n      };\n    };\n  }\n}","map":{"version":3,"mappings":"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","names":["EngineInstrumentation","PrecisionDate","SceneInstrumentation","PressureObserverWrapper","defaultDisposeImpl","PerfCollectionStrategy","FpsStrategy","scene","engine","getEngine","id","getData","getFps","dispose","ThermalStrategy","_PressureStrategy","PowerSupplyStrategy","PressureStrategy","name","factor","value","wrapper","observe","onPressureChanged","add","update","record","factors","includes","length","state","TotalMeshesStrategy","meshes","ActiveMeshesStrategy","getActiveMeshes","ActiveIndicesStrategy","getActiveIndices","ActiveFacesStrategy","ActiveBonesStrategy","getActiveBones","ActiveParticlesStrategy","getActiveParticles","DrawCallsStrategy","drawCalls","onBeforeAnimationsObserver","onBeforeAnimationsObservable","_drawCalls","fetchNewFrame","onAfterRenderObserver","onAfterRenderObservable","current","remove","TotalLightsStrategy","lights","TotalVerticesStrategy","getTotalVertices","TotalMaterialsStrategy","materials","TotalTexturesStrategy","textures","AbsoluteFpsStrategy","sceneInstrumentation","captureFrameTime","frameTimeCounter","lastSecAverage","MeshesSelectionStrategy","startTime","Now","timeTaken","onBeforeActiveMeshesObserver","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesObserver","onAfterActiveMeshesEvaluationObservable","RenderTargetsStrategy","onBeforeRenderTargetsObserver","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsObserver","onAfterRenderTargetsRenderObservable","ParticlesStrategy","onBeforeParticlesObserver","onBeforeParticlesRenderingObservable","onAfterParticlesObserver","onAfterParticlesRenderingObservable","SpritesStrategy","onBeforeSpritesObserver","onBeforeSpritesRenderingObservable","onAfterSpritesObserver","onAfterSpritesRenderingObservable","AnimationsStrategy","onAfterAnimationsObserver","onAfterAnimationsObservable","PhysicsStrategy","onBeforePhysicsObserver","onBeforePhysicsObservable","onAfterPhysicsObserver","onAfterPhysicsObservable","RenderStrategy","onBeforeDrawPhaseObserver","onBeforeDrawPhaseObservable","onAfterDrawPhaseObserver","onAfterDrawPhaseObservable","FrameTotalStrategy","InterFrameStrategy","GpuFrameTimeStrategy","engineInstrumentation","captureGPUFrameTime","Math","max","gpuFrameTimeCounter"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/PerformanceViewer/performanceViewerCollectionStrategies.ts"],"sourcesContent":["import { EngineInstrumentation } from \"../../Instrumentation/engineInstrumentation\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { PrecisionDate } from \"../precisionDate\";\r\nimport { SceneInstrumentation } from \"../../Instrumentation/sceneInstrumentation\";\r\nimport { PressureObserverWrapper } from \"../pressureObserverWrapper\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Defines the general structure of what is necessary for a collection strategy.\r\n */\r\nexport interface IPerfViewerCollectionStrategy {\r\n    /**\r\n     * The id of the strategy.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Function which gets the data for the strategy.\r\n     */\r\n    getData: () => number;\r\n    /**\r\n     * Function which does any necessary cleanup. Called when performanceViewerCollector.dispose() is called.\r\n     */\r\n    dispose: () => void;\r\n}\r\n// Dispose which does nothing.\r\nconst defaultDisposeImpl = () => {};\r\n\r\n/**\r\n * Initializer callback for a strategy\r\n */\r\nexport type PerfStrategyInitialization = (scene: Scene) => IPerfViewerCollectionStrategy;\r\n/**\r\n * Defines the predefined strategies used in the performance viewer.\r\n */\r\nexport class PerfCollectionStrategy {\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of fps metrics\r\n     * @returns the initializer for the fps strategy\r\n     */\r\n    public static FpsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            const engine = scene.getEngine();\r\n            return {\r\n                id: \"FPS\",\r\n                getData: () => engine.getFps(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of thermal utilization metrics.\r\n     * Needs the experimental pressure API.\r\n     * @returns the initializer for the thermal utilization strategy\r\n     */\r\n    public static ThermalStrategy(): PerfStrategyInitialization {\r\n        return this._PressureStrategy(\"Thermal utilization\", \"thermal\");\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of power supply utilization metrics.\r\n     * Needs the experimental pressure API.\r\n     * @returns the initializer for the power supply utilization strategy\r\n     */\r\n    public static PowerSupplyStrategy(): PerfStrategyInitialization {\r\n        return this._PressureStrategy(\"Power supply utilization\", \"power-supply\");\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of pressure metrics.\r\n     * Needs the experimental pressure API.\r\n     * @returns the initializer for the pressure strategy\r\n     */\r\n    public static PressureStrategy(): PerfStrategyInitialization {\r\n        return this._PressureStrategy(\"Pressure\");\r\n    }\r\n\r\n    private static _PressureStrategy(name: string, factor: Nullable<PressureFactor> = null): PerfStrategyInitialization {\r\n        return () => {\r\n            let value = 0;\r\n\r\n            const wrapper = new PressureObserverWrapper();\r\n            wrapper.observe(\"cpu\");\r\n\r\n            wrapper.onPressureChanged.add((update) => {\r\n                for (const record of update) {\r\n                    if ((factor && record.factors.includes(factor)) || (!factor && record.factors.length === 0)) {\r\n                        // Let s consider each step being 25% of the total pressure.\r\n                        switch (record.state) {\r\n                            case \"nominal\":\r\n                                value = 0;\r\n                                break;\r\n                            case \"fair\":\r\n                                value = 0.25;\r\n                                break;\r\n                            case \"serious\":\r\n                                value = 0.5;\r\n                                break;\r\n                            case \"critical\":\r\n                                value = 1;\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            return {\r\n                id: name,\r\n                getData: () => value,\r\n                dispose: () => wrapper.dispose(),\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total meshes metrics.\r\n     * @returns the initializer for the total meshes strategy\r\n     */\r\n    public static TotalMeshesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total meshes\",\r\n                getData: () => scene.meshes.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active meshes metrics.\r\n     * @returns the initializer for the active meshes strategy\r\n     */\r\n    public static ActiveMeshesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active meshes\",\r\n                getData: () => scene.getActiveMeshes().length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active indices metrics.\r\n     * @returns the initializer for the active indices strategy\r\n     */\r\n    public static ActiveIndicesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active indices\",\r\n                getData: () => scene.getActiveIndices(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active faces metrics.\r\n     * @returns the initializer for the active faces strategy\r\n     */\r\n    public static ActiveFacesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active faces\",\r\n                getData: () => scene.getActiveIndices() / 3,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active bones metrics.\r\n     * @returns the initializer for the active bones strategy\r\n     */\r\n    public static ActiveBonesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active bones\",\r\n                getData: () => scene.getActiveBones(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of active particles metrics.\r\n     * @returns the initializer for the active particles strategy\r\n     */\r\n    public static ActiveParticlesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Active particles\",\r\n                getData: () => scene.getActiveParticles(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of draw calls metrics.\r\n     * @returns the initializer for the draw calls strategy\r\n     */\r\n    public static DrawCallsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let drawCalls = 0;\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                scene.getEngine()._drawCalls.fetchNewFrame();\r\n            });\r\n\r\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                drawCalls = scene.getEngine()._drawCalls.current;\r\n            });\r\n\r\n            return {\r\n                id: \"Draw calls\",\r\n                getData: () => drawCalls,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total lights metrics.\r\n     * @returns the initializer for the total lights strategy\r\n     */\r\n    public static TotalLightsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total lights\",\r\n                getData: () => scene.lights.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total vertices metrics.\r\n     * @returns the initializer for the total vertices strategy\r\n     */\r\n    public static TotalVerticesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total vertices\",\r\n                getData: () => scene.getTotalVertices(),\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total materials metrics.\r\n     * @returns the initializer for the total materials strategy\r\n     */\r\n    public static TotalMaterialsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total materials\",\r\n                getData: () => scene.materials.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total textures metrics.\r\n     * @returns the initializer for the total textures strategy\r\n     */\r\n    public static TotalTexturesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            return {\r\n                id: \"Total textures\",\r\n                getData: () => scene.textures.length,\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of absolute fps metrics.\r\n     * @returns the initializer for the absolute fps strategy\r\n     */\r\n    public static AbsoluteFpsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            const sceneInstrumentation = new SceneInstrumentation(scene);\r\n            sceneInstrumentation.captureFrameTime = true;\r\n\r\n            return {\r\n                id: \"Absolute FPS\",\r\n                getData: () => {\r\n                    return 1000.0 / sceneInstrumentation.frameTimeCounter.lastSecAverage;\r\n                },\r\n                dispose: defaultDisposeImpl,\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of meshes selection time metrics.\r\n     * @returns the initializer for the meshes selection time strategy\r\n     */\r\n    public static MeshesSelectionStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeActiveMeshesObserver = scene.onBeforeActiveMeshesEvaluationObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterActiveMeshesObserver = scene.onAfterActiveMeshesEvaluationObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Meshes Selection\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeActiveMeshesEvaluationObservable.remove(onBeforeActiveMeshesObserver);\r\n                    scene.onAfterActiveMeshesEvaluationObservable.remove(onAfterActiveMeshesObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of render targets time metrics.\r\n     * @returns the initializer for the render targets time strategy\r\n     */\r\n    public static RenderTargetsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeRenderTargetsObserver = scene.onBeforeRenderTargetsRenderObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterRenderTargetsObserver = scene.onAfterRenderTargetsRenderObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Render Targets\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeRenderTargetsRenderObservable.remove(onBeforeRenderTargetsObserver);\r\n                    scene.onAfterRenderTargetsRenderObservable.remove(onAfterRenderTargetsObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of particles time metrics.\r\n     * @returns the initializer for the particles time strategy\r\n     */\r\n    public static ParticlesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeParticlesObserver = scene.onBeforeParticlesRenderingObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterParticlesObserver = scene.onAfterParticlesRenderingObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Particles\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeParticlesRenderingObservable.remove(onBeforeParticlesObserver);\r\n                    scene.onAfterParticlesRenderingObservable.remove(onAfterParticlesObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of sprites time metrics.\r\n     * @returns the initializer for the sprites time strategy\r\n     */\r\n    public static SpritesStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeSpritesObserver = scene.onBeforeSpritesRenderingObservable?.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterSpritesObserver = scene.onAfterSpritesRenderingObservable?.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Sprites\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeSpritesRenderingObservable?.remove(onBeforeSpritesObserver);\r\n                    scene.onAfterSpritesRenderingObservable?.remove(onAfterSpritesObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of animations time metrics.\r\n     * @returns the initializer for the animations time strategy\r\n     */\r\n    public static AnimationsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterAnimationsObserver = scene.onAfterAnimationsObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Animations\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterAnimationsObservable.remove(onAfterAnimationsObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of physics time metrics.\r\n     * @returns the initializer for the physics time strategy\r\n     */\r\n    public static PhysicsStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforePhysicsObserver = scene.onBeforePhysicsObservable?.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterPhysicsObserver = scene.onAfterPhysicsObservable?.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Physics\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforePhysicsObservable?.remove(onBeforePhysicsObserver);\r\n                    scene.onAfterPhysicsObservable?.remove(onAfterPhysicsObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of render time metrics.\r\n     * @returns the initializer for the render time strategy\r\n     */\r\n    public static RenderStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterDrawPhaseObserver = scene.onAfterDrawPhaseObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Render\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeDrawPhaseObservable.remove(onBeforeDrawPhaseObserver);\r\n                    scene.onAfterDrawPhaseObservable.remove(onAfterDrawPhaseObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of total frame time metrics.\r\n     * @returns the initializer for the total frame time strategy\r\n     */\r\n    public static FrameTotalStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            return {\r\n                id: \"Frame Total\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of inter-frame time metrics.\r\n     * @returns the initializer for the inter-frame time strategy\r\n     */\r\n    public static InterFrameStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            let startTime = PrecisionDate.Now;\r\n            let timeTaken = 0;\r\n\r\n            const onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n                timeTaken = PrecisionDate.Now - startTime;\r\n            });\r\n\r\n            const onAfterRenderObserver = scene.onAfterRenderObservable.add(() => {\r\n                startTime = PrecisionDate.Now;\r\n            });\r\n\r\n            return {\r\n                id: \"Inter-frame\",\r\n                getData: () => timeTaken,\r\n                dispose: () => {\r\n                    scene.onBeforeAnimationsObservable.remove(onBeforeAnimationsObserver);\r\n                    scene.onAfterRenderObservable.remove(onAfterRenderObserver);\r\n                },\r\n            };\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the initializer for the strategy used for collection of gpu frame time metrics.\r\n     * @returns the initializer for the gpu frame time strategy\r\n     */\r\n    public static GpuFrameTimeStrategy(): PerfStrategyInitialization {\r\n        return (scene) => {\r\n            const engineInstrumentation = new EngineInstrumentation(scene.getEngine());\r\n            engineInstrumentation.captureGPUFrameTime = true;\r\n            return {\r\n                id: \"GPU frame time\",\r\n                getData: () => Math.max(engineInstrumentation.gpuFrameTimeCounter.current * 0.000001, 0),\r\n                dispose: () => {\r\n                    engineInstrumentation.dispose();\r\n                },\r\n            };\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}