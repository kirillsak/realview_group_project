{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\n/**\n * Creates the VertexData for a tiled plane\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @returns the VertexData of the tiled plane\n */\nexport function CreateTiledPlaneVertexData(options) {\n  const flipTile = options.pattern || Mesh.NO_FLIP;\n  const tileWidth = options.tileWidth || options.tileSize || 1;\n  const tileHeight = options.tileHeight || options.tileSize || 1;\n  const alignH = options.alignHorizontal || 0;\n  const alignV = options.alignVertical || 0;\n  const width = options.width || options.size || 1;\n  const tilesX = Math.floor(width / tileWidth);\n  let offsetX = width - tilesX * tileWidth;\n  const height = options.height || options.size || 1;\n  const tilesY = Math.floor(height / tileHeight);\n  let offsetY = height - tilesY * tileHeight;\n  const halfWidth = tileWidth * tilesX / 2;\n  const halfHeight = tileHeight * tilesY / 2;\n  let adjustX = 0;\n  let adjustY = 0;\n  let startX = 0;\n  let startY = 0;\n  let endX = 0;\n  let endY = 0;\n  //Part Tiles\n  if (offsetX > 0 || offsetY > 0) {\n    startX = -halfWidth;\n    startY = -halfHeight;\n    endX = halfWidth;\n    endY = halfHeight;\n    switch (alignH) {\n      case Mesh.CENTER:\n        offsetX /= 2;\n        startX -= offsetX;\n        endX += offsetX;\n        break;\n      case Mesh.LEFT:\n        endX += offsetX;\n        adjustX = -offsetX / 2;\n        break;\n      case Mesh.RIGHT:\n        startX -= offsetX;\n        adjustX = offsetX / 2;\n        break;\n    }\n    switch (alignV) {\n      case Mesh.CENTER:\n        offsetY /= 2;\n        startY -= offsetY;\n        endY += offsetY;\n        break;\n      case Mesh.BOTTOM:\n        endY += offsetY;\n        adjustY = -offsetY / 2;\n        break;\n      case Mesh.TOP:\n        startY -= offsetY;\n        adjustY = offsetY / 2;\n        break;\n    }\n  }\n  const positions = [];\n  const normals = [];\n  const uvBase = [];\n  uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\n  uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\n  if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n    uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\n  }\n  if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n    uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\n  }\n  if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n    uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\n  }\n  let uvs = [];\n  const colors = [];\n  const indices = [];\n  let index = 0;\n  for (let y = 0; y < tilesY; y++) {\n    for (let x = 0; x < tilesX; x++) {\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n        uvs = uvs.concat(uvBase[(x % 2 + y % 2) % 2]);\n      } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvs = uvs.concat(uvBase[y % 2]);\n      } else {\n        uvs = uvs.concat(uvBase[0]);\n      }\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      index += 4;\n    }\n  }\n  //Part Tiles\n  if (offsetX > 0 || offsetY > 0) {\n    const partialBottomRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\n    const partialTopRow = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\n    const partialLeftCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\n    const partialRightCol = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\n    let uvPart = [];\n    let a, b, c, d;\n    //corners\n    if (partialBottomRow && partialLeftCol) {\n      //bottom left corner\n      positions.push(startX + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    if (partialBottomRow && partialRightCol) {\n      //bottom right corner\n      positions.push(halfWidth + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + adjustY, 0);\n      positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\n      positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = offsetX / tileWidth;\n      d = 1;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    if (partialTopRow && partialLeftCol) {\n      //top left corner\n      positions.push(startX + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(-halfWidth + adjustX, endY + adjustY, 0);\n      positions.push(startX + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    if (partialTopRow && partialRightCol) {\n      //top right corner\n      positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, halfHeight + adjustY, 0);\n      positions.push(endX + adjustX, endY + adjustY, 0);\n      positions.push(halfWidth + adjustX, endY + adjustY, 0);\n      indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n      index += 4;\n      a = 0;\n      b = 0;\n      c = offsetX / tileWidth;\n      d = offsetY / tileHeight;\n      uvPart = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1 || flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1) {\n        uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      uvs = uvs.concat(uvPart);\n      colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n      normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n    }\n    //part rows\n    if (partialBottomRow) {\n      const uvBaseBR = [];\n      a = 0;\n      b = 1 - offsetY / tileHeight;\n      c = 1;\n      d = 1;\n      uvBaseBR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseBR[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseBR[1]);\n        } else {\n          uvs = uvs.concat(uvBaseBR[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n    if (partialTopRow) {\n      const uvBaseTR = [];\n      a = 0;\n      b = 0;\n      c = 1;\n      d = offsetY / tileHeight;\n      uvBaseTR[0] = [a, b, c, b, c, d, a, d];\n      uvBaseTR[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let x = 0; x < tilesX; x++) {\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\n        positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\n        positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseTR[tilesY % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseTR[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n    if (partialLeftCol) {\n      const uvBaseLC = [];\n      a = 1 - offsetX / tileWidth;\n      b = 0;\n      c = 1;\n      d = 1;\n      uvBaseLC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseLC[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let y = 0; y < tilesY; y++) {\n        positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseLC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseLC[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n    if (partialRightCol) {\n      const uvBaseRC = [];\n      a = 0;\n      b = 0;\n      c = offsetX / tileHeight;\n      d = 1;\n      uvBaseRC[0] = [a, b, c, b, c, d, a, d];\n      uvBaseRC[1] = [a, b, c, b, c, d, a, d];\n      if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\n        uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\n      }\n      if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\n        uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\n      }\n      if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n        uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\n      }\n      for (let y = 0; y < tilesY; y++) {\n        positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\n        positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\n        indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\n        index += 4;\n        if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\n          uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\n        } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\n          uvs = uvs.concat(uvBaseRC[y % 2]);\n        } else {\n          uvs = uvs.concat(uvBaseRC[0]);\n        }\n        colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\n        normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\n      }\n    }\n  }\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n  vertexData.colors = totalColors;\n  return vertexData;\n}\n/**\n * Creates a tiled plane mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\n * @param name defines the name of the mesh\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\n * * pattern a limited pattern arrangement depending on the number\n * * size of the box\n * * width of the box, overwrites size\n * * height of the box, overwrites size\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\n * * alignVertical places whole tiles aligned to the center, left or right of a column\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.pattern\n * @param options.tileSize\n * @param options.tileWidth\n * @param options.tileHeight\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.alignHorizontal\n * @param options.alignVertical\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateTiledPlane(name, options, scene = null) {\n  const plane = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  plane._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateTiledPlaneVertexData(options);\n  vertexData.applyToMesh(plane, options.updatable);\n  return plane;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTiledPlane instead\n */\nexport const TiledPlaneBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTiledPlane\n};\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;","map":{"version":3,"mappings":"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","names":["Mesh","VertexData","CreateTiledPlaneVertexData","options","flipTile","pattern","NO_FLIP","tileWidth","tileSize","tileHeight","alignH","alignHorizontal","alignV","alignVertical","width","size","tilesX","Math","floor","offsetX","height","tilesY","offsetY","halfWidth","halfHeight","adjustX","adjustY","startX","startY","endX","endY","CENTER","LEFT","RIGHT","BOTTOM","TOP","positions","normals","uvBase","ROTATE_TILE","ROTATE_ROW","FLIP_TILE","FLIP_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","uvs","colors","indices","index","y","x","push","concat","partialBottomRow","partialTopRow","partialLeftCol","partialRightCol","uvPart","a","b","c","d","uvBaseBR","uvBaseTR","uvBaseLC","uvBaseRC","sideOrientation","DEFAULTSIDE","_ComputeSides","frontUVs","backUVs","vertexData","totalColors","DOUBLESIDE","CreateTiledPlane","name","scene","plane","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","TiledPlaneBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/tiledPlaneBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\n\r\n/**\r\n * Creates the VertexData for a tiled plane\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the tiled plane\r\n */\r\nexport function CreateTiledPlaneVertexData(options: {\r\n    pattern?: number;\r\n    tileSize?: number;\r\n    tileWidth?: number;\r\n    tileHeight?: number;\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    alignHorizontal?: number;\r\n    alignVertical?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const flipTile = options.pattern || Mesh.NO_FLIP;\r\n    const tileWidth = options.tileWidth || options.tileSize || 1;\r\n    const tileHeight = options.tileHeight || options.tileSize || 1;\r\n    const alignH = options.alignHorizontal || 0;\r\n    const alignV = options.alignVertical || 0;\r\n\r\n    const width = options.width || options.size || 1;\r\n    const tilesX = Math.floor(width / tileWidth);\r\n    let offsetX = width - tilesX * tileWidth;\r\n\r\n    const height = options.height || options.size || 1;\r\n    const tilesY = Math.floor(height / tileHeight);\r\n    let offsetY = height - tilesY * tileHeight;\r\n\r\n    const halfWidth = (tileWidth * tilesX) / 2;\r\n    const halfHeight = (tileHeight * tilesY) / 2;\r\n\r\n    let adjustX = 0;\r\n    let adjustY = 0;\r\n    let startX = 0;\r\n    let startY = 0;\r\n    let endX = 0;\r\n    let endY = 0;\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        startX = -halfWidth;\r\n        startY = -halfHeight;\r\n        endX = halfWidth;\r\n        endY = halfHeight;\r\n\r\n        switch (alignH) {\r\n            case Mesh.CENTER:\r\n                offsetX /= 2;\r\n                startX -= offsetX;\r\n                endX += offsetX;\r\n                break;\r\n            case Mesh.LEFT:\r\n                endX += offsetX;\r\n                adjustX = -offsetX / 2;\r\n                break;\r\n            case Mesh.RIGHT:\r\n                startX -= offsetX;\r\n                adjustX = offsetX / 2;\r\n                break;\r\n        }\r\n\r\n        switch (alignV) {\r\n            case Mesh.CENTER:\r\n                offsetY /= 2;\r\n                startY -= offsetY;\r\n                endY += offsetY;\r\n                break;\r\n            case Mesh.BOTTOM:\r\n                endY += offsetY;\r\n                adjustY = -offsetY / 2;\r\n                break;\r\n            case Mesh.TOP:\r\n                startY -= offsetY;\r\n                adjustY = offsetY / 2;\r\n                break;\r\n        }\r\n    }\r\n\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvBase = [];\r\n    uvBase[0] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    uvBase[1] = [0, 0, 1, 0, 1, 1, 0, 1];\r\n    if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n        uvBase[1] = [1, 1, 0, 1, 0, 0, 1, 0];\r\n    }\r\n    if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n        uvBase[1] = [1, 0, 0, 0, 0, 1, 1, 1];\r\n    }\r\n    if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n        uvBase[1] = [0, 1, 1, 1, 1, 0, 0, 0];\r\n    }\r\n    let uvs: Array<number> = [];\r\n    const colors = [];\r\n    const indices = [];\r\n    let index = 0;\r\n    for (let y = 0; y < tilesY; y++) {\r\n        for (let x = 0; x < tilesX; x++) {\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            positions.push(-halfWidth + x * tileWidth + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                uvs = uvs.concat(uvBase[((x % 2) + (y % 2)) % 2]);\r\n            } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvs = uvs.concat(uvBase[y % 2]);\r\n            } else {\r\n                uvs = uvs.concat(uvBase[0]);\r\n            }\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            index += 4;\r\n        }\r\n    }\r\n\r\n    //Part Tiles\r\n    if (offsetX > 0 || offsetY > 0) {\r\n        const partialBottomRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.TOP);\r\n        const partialTopRow: boolean = offsetY > 0 && (alignV === Mesh.CENTER || alignV === Mesh.BOTTOM);\r\n        const partialLeftCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.RIGHT);\r\n        const partialRightCol: boolean = offsetX > 0 && (alignH === Mesh.CENTER || alignH === Mesh.LEFT);\r\n        let uvPart: Array<number> = [];\r\n        let a, b, c, d: number;\r\n\r\n        //corners\r\n        if (partialBottomRow && partialLeftCol) {\r\n            //bottom left corner\r\n            positions.push(startX + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(startX + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialBottomRow && partialRightCol) {\r\n            //bottom right corner\r\n            positions.push(halfWidth + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + adjustY, 0);\r\n            positions.push(endX + adjustX, startY + offsetY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, startY + offsetY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = offsetX / tileWidth;\r\n            d = 1;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_ROW || (flipTile === Mesh.ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_ROW || (flipTile === Mesh.FLIP_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_ROW || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesX % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialLeftCol) {\r\n            //top left corner\r\n            positions.push(startX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(-halfWidth + adjustX, endY + adjustY, 0);\r\n            positions.push(startX + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && tilesY % 1 === 0)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && tilesY % 2 === 0)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        if (partialTopRow && partialRightCol) {\r\n            //top right corner\r\n            positions.push(halfWidth + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, halfHeight + adjustY, 0);\r\n            positions.push(endX + adjustX, endY + adjustY, 0);\r\n            positions.push(halfWidth + adjustX, endY + adjustY, 0);\r\n            indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n            index += 4;\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileWidth;\r\n            d = offsetY / tileHeight;\r\n            uvPart = [a, b, c, b, c, d, a, d];\r\n            if ((flipTile === Mesh.ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if ((flipTile === Mesh.FLIP_N_ROTATE_ROW && tilesY % 2 === 1) || (flipTile === Mesh.FLIP_N_ROTATE_TILE && (tilesY + tilesX) % 2 === 1)) {\r\n                uvPart = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            uvs = uvs.concat(uvPart);\r\n            colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n            normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n        }\r\n\r\n        //part rows\r\n        if (partialBottomRow) {\r\n            const uvBaseBR = [];\r\n            a = 0;\r\n            b = 1 - offsetY / tileHeight;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseBR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseBR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseBR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseBR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseBR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, startY + offsetY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseBR[(x + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseBR[1]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseBR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialTopRow) {\r\n            const uvBaseTR = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = 1;\r\n            d = offsetY / tileHeight;\r\n            uvBaseTR[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseTR[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseTR[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseTR[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseTR[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let x = 0; x < tilesX; x++) {\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY - offsetY + adjustY, 0);\r\n                positions.push(-halfWidth + (x + 1) * tileWidth + adjustX, endY + adjustY, 0);\r\n                positions.push(-halfWidth + x * tileWidth + adjustX, endY + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseTR[(x + tilesY) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseTR[tilesY % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseTR[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialLeftCol) {\r\n            const uvBaseLC = [];\r\n            a = 1 - offsetX / tileWidth;\r\n            b = 0;\r\n            c = 1;\r\n            d = 1;\r\n            uvBaseLC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseLC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseLC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseLC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseLC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(startX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(startX + offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(startX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseLC[(y + 1) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseLC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseLC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n\r\n        if (partialRightCol) {\r\n            const uvBaseRC = [];\r\n            a = 0;\r\n            b = 0;\r\n            c = offsetX / tileHeight;\r\n            d = 1;\r\n            uvBaseRC[0] = [a, b, c, b, c, d, a, d];\r\n            uvBaseRC[1] = [a, b, c, b, c, d, a, d];\r\n            if (flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.ROTATE_ROW) {\r\n                uvBaseRC[1] = [1 - a, 1 - b, 1 - c, 1 - b, 1 - c, 1 - d, 1 - a, 1 - d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.FLIP_ROW) {\r\n                uvBaseRC[1] = [1 - a, b, 1 - c, b, 1 - c, d, 1 - a, d];\r\n            }\r\n            if (flipTile === Mesh.FLIP_N_ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                uvBaseRC[1] = [a, 1 - b, c, 1 - b, c, 1 - d, a, 1 - d];\r\n            }\r\n            for (let y = 0; y < tilesY; y++) {\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + y * tileHeight + adjustY, 0);\r\n                positions.push(endX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                positions.push(endX - offsetX + adjustX, -halfHeight + (y + 1) * tileHeight + adjustY, 0);\r\n                indices.push(index, index + 1, index + 3, index + 1, index + 2, index + 3);\r\n                index += 4;\r\n                if (flipTile === Mesh.FLIP_TILE || flipTile === Mesh.ROTATE_TILE || flipTile === Mesh.FLIP_N_ROTATE_TILE) {\r\n                    uvs = uvs.concat(uvBaseRC[(y + tilesX) % 2]);\r\n                } else if (flipTile === Mesh.FLIP_ROW || flipTile === Mesh.ROTATE_ROW || flipTile === Mesh.FLIP_N_ROTATE_ROW) {\r\n                    uvs = uvs.concat(uvBaseRC[y % 2]);\r\n                } else {\r\n                    uvs = uvs.concat(uvBaseRC[0]);\r\n                }\r\n                colors.push(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);\r\n                normals.push(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1);\r\n            }\r\n        }\r\n    }\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n    vertexData.colors = totalColors;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a tiled plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/tiled_plane\r\n * @param name defines the name of the mesh\r\n * @param options an object used to set the following optional parameters for the tiled plane, required but can be empty\r\n * * pattern a limited pattern arrangement depending on the number\r\n * * size of the box\r\n * * width of the box, overwrites size\r\n * * height of the box, overwrites size\r\n * * tileSize sets the width, height and depth of the tile to the value of size, optional default 1\r\n * * tileWidth sets the width (x direction) of the tile, overwrites the width set by size, optional, default size\r\n * * tileHeight sets the height (y direction) of the tile, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * alignHorizontal places whole tiles aligned to the center, left or right of a row\r\n * * alignVertical places whole tiles aligned to the center, left or right of a column\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.pattern\r\n * @param options.tileSize\r\n * @param options.tileWidth\r\n * @param options.tileHeight\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.alignHorizontal\r\n * @param options.alignVertical\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateTiledPlane(\r\n    name: string,\r\n    options: {\r\n        pattern?: number;\r\n        tileSize?: number;\r\n        tileWidth?: number;\r\n        tileHeight?: number;\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        alignHorizontal?: number;\r\n        alignVertical?: number;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        updatable?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateTiledPlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTiledPlane instead\r\n */\r\nexport const TiledPlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledPlane,\r\n};\r\n\r\nVertexData.CreateTiledPlane = CreateTiledPlaneVertexData;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}