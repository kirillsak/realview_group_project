{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\nimport { AnimationEvent } from \"@babylonjs/core/Animations/animationEvent.js\";\nimport { Sound } from \"@babylonjs/core/Audio/sound.js\";\nimport { WeightedSound } from \"@babylonjs/core/Audio/weightedsound.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"MSFT_audio_emitter\";\n/**\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_audio_emitter {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n    this._clips = null;\n    this._emitters = null;\n  }\n  /** @internal */\n  onLoading() {\n    const extensions = this._loader.gltf.extensions;\n    if (extensions && extensions[this.name]) {\n      const extension = extensions[this.name];\n      this._clips = extension.clips;\n      this._emitters = extension.emitters;\n      ArrayItem.Assign(this._clips);\n      ArrayItem.Assign(this._emitters);\n    }\n  }\n  /**\n   * @internal\n   */\n  loadSceneAsync(context, scene) {\n    return GLTFLoader.LoadExtensionAsync(context, scene, this.name, (extensionContext, extension) => {\n      const promises = new Array();\n      promises.push(this._loader.loadSceneAsync(context, scene));\n      for (const emitterIndex of extension.emitters) {\n        const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n        if (emitter.refDistance != undefined || emitter.maxDistance != undefined || emitter.rolloffFactor != undefined || emitter.distanceModel != undefined || emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n          throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n        }\n        promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n      }\n      return Promise.all(promises).then(() => {});\n    });\n  }\n  /**\n   * @internal\n   */\n  loadNodeAsync(context, node, assign) {\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n      const promises = new Array();\n      return this._loader.loadNodeAsync(extensionContext, node, babylonMesh => {\n        for (const emitterIndex of extension.emitters) {\n          const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n          promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n            for (const sound of emitter._babylonSounds) {\n              sound.attachToMesh(babylonMesh);\n              if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                sound.setLocalDirectionToMesh(Vector3.Forward());\n                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n              }\n            }\n          }));\n        }\n        assign(babylonMesh);\n      }).then(babylonMesh => {\n        return Promise.all(promises).then(() => {\n          return babylonMesh;\n        });\n      });\n    });\n  }\n  /**\n   * @internal\n   */\n  loadAnimationAsync(context, animation) {\n    return GLTFLoader.LoadExtensionAsync(context, animation, this.name, (extensionContext, extension) => {\n      return this._loader.loadAnimationAsync(context, animation).then(babylonAnimationGroup => {\n        const promises = new Array();\n        ArrayItem.Assign(extension.events);\n        for (const event of extension.events) {\n          promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n        }\n        return Promise.all(promises).then(() => {\n          return babylonAnimationGroup;\n        });\n      });\n    });\n  }\n  _loadClipAsync(context, clip) {\n    if (clip._objectURL) {\n      return clip._objectURL;\n    }\n    let promise;\n    if (clip.uri) {\n      promise = this._loader.loadUriAsync(context, clip, clip.uri);\n    } else {\n      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n      promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n    }\n    clip._objectURL = promise.then(data => {\n      return URL.createObjectURL(new Blob([data], {\n        type: clip.mimeType\n      }));\n    });\n    return clip._objectURL;\n  }\n  _loadEmitterAsync(context, emitter) {\n    emitter._babylonSounds = emitter._babylonSounds || [];\n    if (!emitter._babylonData) {\n      const clipPromises = new Array();\n      const name = emitter.name || `emitter${emitter.index}`;\n      const options = {\n        loop: false,\n        autoplay: false,\n        volume: emitter.volume == undefined ? 1 : emitter.volume\n      };\n      for (let i = 0; i < emitter.clips.length; i++) {\n        const clipContext = `/extensions/${this.name}/clips`;\n        const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n        clipPromises.push(this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then(objectURL => {\n          const sound = emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options);\n          sound.refDistance = emitter.refDistance || 1;\n          sound.maxDistance = emitter.maxDistance || 256;\n          sound.rolloffFactor = emitter.rolloffFactor || 1;\n          sound.distanceModel = emitter.distanceModel || \"exponential\";\n        }));\n      }\n      const promise = Promise.all(clipPromises).then(() => {\n        const weights = emitter.clips.map(clip => {\n          return clip.weight || 1;\n        });\n        const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n        if (emitter.innerAngle) {\n          weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n        }\n        if (emitter.outerAngle) {\n          weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n        }\n        if (emitter.volume) {\n          weightedSound.volume = emitter.volume;\n        }\n        emitter._babylonData.sound = weightedSound;\n      });\n      emitter._babylonData = {\n        loaded: promise\n      };\n    }\n    return emitter._babylonData.loaded;\n  }\n  _getEventAction(context, sound, action, time, startOffset) {\n    switch (action) {\n      case \"play\" /* play */:\n        {\n          return currentFrame => {\n            const frameOffset = (startOffset || 0) + (currentFrame - time);\n            sound.play(frameOffset);\n          };\n        }\n      case \"stop\" /* stop */:\n        {\n          return () => {\n            sound.stop();\n          };\n        }\n      case \"pause\" /* pause */:\n        {\n          return () => {\n            sound.pause();\n          };\n        }\n      default:\n        {\n          throw new Error(`${context}: Unsupported action ${action}`);\n        }\n    }\n  }\n  _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {\n    if (babylonAnimationGroup.targetedAnimations.length == 0) {\n      return Promise.resolve();\n    }\n    const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n    const emitterIndex = event.emitter;\n    const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n    return this._loadEmitterAsync(context, emitter).then(() => {\n      const sound = emitter._babylonData.sound;\n      if (sound) {\n        const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n        babylonAnimation.animation.addEvent(babylonAnimationEvent);\n        // Make sure all started audio stops when this animation is terminated.\n        babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n          sound.stop();\n        });\n        babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n          sound.pause();\n        });\n      }\n    });\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new MSFT_audio_emitter(loader));","map":{"version":3,"mappings":"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","names":["Vector3","Tools","AnimationEvent","Sound","WeightedSound","GLTFLoader","ArrayItem","NAME","MSFT_audio_emitter","constructor","loader","_loader","enabled","isExtensionUsed","dispose","_clips","_emitters","onLoading","extensions","gltf","name","extension","clips","emitters","Assign","loadSceneAsync","context","scene","LoadExtensionAsync","extensionContext","promises","Array","push","emitterIndex","emitter","Get","refDistance","undefined","maxDistance","rolloffFactor","distanceModel","innerAngle","outerAngle","Error","_loadEmitterAsync","index","Promise","all","then","loadNodeAsync","node","assign","babylonMesh","sound","_babylonSounds","attachToMesh","setLocalDirectionToMesh","Forward","setDirectionalCone","ToDegrees","Math","PI","loadAnimationAsync","animation","babylonAnimationGroup","events","event","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","promise","uri","loadUriAsync","bufferView","bufferViews","loadBufferViewAsync","data","URL","createObjectURL","Blob","type","mimeType","_babylonData","clipPromises","options","loop","autoplay","volume","i","length","clipContext","objectURL","babylonScene","weights","map","weight","weightedSound","directionalConeInnerAngle","directionalConeOuterAngle","loaded","_getEventAction","action","time","startOffset","currentFrame","frameOffset","play","stop","pause","animationContext","targetedAnimations","resolve","babylonAnimation","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","add","onAnimationGroupPauseObservable","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/MSFT_audio_emitter.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            return this._loader\r\n                .loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                    for (const emitterIndex of extension.emitters) {\r\n                        const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                        promises.push(\r\n                            this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                                for (const sound of emitter._babylonSounds) {\r\n                                    sound.attachToMesh(babylonMesh);\r\n                                    if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                        sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                        sound.setDirectionalCone(\r\n                                            2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                            2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                            0\r\n                                        );\r\n                                    }\r\n                                }\r\n                            })\r\n                        );\r\n                    }\r\n\r\n                    assign(babylonMesh);\r\n                })\r\n                .then((babylonMesh) => {\r\n                    return Promise.all(promises).then(() => {\r\n                        return babylonMesh;\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, (extensionContext, extension) => {\r\n            return this._loader.loadAnimationAsync(context, animation).then((babylonAnimationGroup) => {\r\n                const promises = new Array<Promise<any>>();\r\n\r\n                ArrayItem.Assign(extension.events);\r\n                for (const event of extension.events) {\r\n                    promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n                }\r\n\r\n                return Promise.all(promises).then(() => {\r\n                    return babylonAnimationGroup;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_audio_emitter(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}