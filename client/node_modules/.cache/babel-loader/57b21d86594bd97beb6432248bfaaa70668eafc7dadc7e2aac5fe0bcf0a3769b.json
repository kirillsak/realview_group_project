{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\nimport { VertexBuffer } from \"../../../../Buffers/buffer.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\n/**\n * Block used to add morph targets support to vertex shader\n */\nexport class MorphTargetsBlock extends NodeMaterialBlock {\n  /**\n   * Create a new MorphTargetsBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\n    this.tangent.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector4);\n    this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"MorphTargetsBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the tangent input component\n   */\n  get tangent() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the tangent input component\n   */\n  get uv() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the position output component\n   */\n  get positionOutput() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the normal output component\n   */\n  get normalOutput() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the tangent output component\n   */\n  get tangentOutput() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the tangent output component\n   */\n  get uvOutput() {\n    return this._outputs[3];\n  }\n  initialize(state) {\n    state._excludeVariableName(\"morphTargetInfluences\");\n  }\n  autoConfigure(material) {\n    if (!this.position.isConnected) {\n      let positionInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"position\");\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n      positionInput.output.connectTo(this.position);\n    }\n    if (!this.normal.isConnected) {\n      let normalInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"normal\");\n      if (!normalInput) {\n        normalInput = new InputBlock(\"normal\");\n        normalInput.setAsAttribute(\"normal\");\n      }\n      normalInput.output.connectTo(this.normal);\n    }\n    if (!this.tangent.isConnected) {\n      let tangentInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"tangent\");\n      if (!tangentInput) {\n        tangentInput = new InputBlock(\"tangent\");\n        tangentInput.setAsAttribute(\"tangent\");\n      }\n      tangentInput.output.connectTo(this.tangent);\n    }\n    if (!this.uv.isConnected) {\n      let uvInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"uv\");\n      if (!uvInput) {\n        uvInput = new InputBlock(\"uv\");\n        uvInput.setAsAttribute(\"uv\");\n      }\n      uvInput.output.connectTo(this.uv);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (mesh.morphTargetManager) {\n      const morphTargetManager = mesh.morphTargetManager;\n      if ((morphTargetManager === null || morphTargetManager === void 0 ? void 0 : morphTargetManager.isUsingTextureForTargets) && morphTargetManager.numInfluencers !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\n        defines.markAsAttributesDirty();\n      }\n    }\n    if (!defines._areAttributesDirty) {\n      return;\n    }\n    MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\n      MaterialHelper.BindMorphTargetParameters(mesh, effect);\n      if (mesh.morphTargetManager.isUsingTextureForTargets) {\n        mesh.morphTargetManager._bind(effect);\n      }\n    }\n  }\n  replaceRepeatableContent(vertexShaderState, fragmentShaderState, mesh, defines) {\n    const position = this.position;\n    const normal = this.normal;\n    const tangent = this.tangent;\n    const uv = this.uv;\n    const positionOutput = this.positionOutput;\n    const normalOutput = this.normalOutput;\n    const tangentOutput = this.tangentOutput;\n    const uvOutput = this.uvOutput;\n    const state = vertexShaderState;\n    const repeatCount = defines.NUM_MORPH_INFLUENCERS;\n    const manager = mesh.morphTargetManager;\n    const hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    const hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    const hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\n    let injectionCode = \"\";\n    if ((manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) && repeatCount > 0) {\n      injectionCode += `float vertexID;\\r\\n`;\n    }\n    for (let index = 0; index < repeatCount; index++) {\n      injectionCode += `#ifdef MORPHTARGETS\\r\\n`;\n      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n        injectionCode += `vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\\r\\n`;\n        injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\n        injectionCode += `vertexID += 1.0;\\r\\n`;\n      } else {\n        injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\n      }\n      if (hasNormals) {\n        injectionCode += `#ifdef MORPHTARGETS_NORMAL\\r\\n`;\n        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n          injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\n          injectionCode += `vertexID += 1.0;\\r\\n`;\n        } else {\n          injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\n        }\n        injectionCode += `#endif\\r\\n`;\n      }\n      if (hasUVs) {\n        injectionCode += `#ifdef MORPHTARGETS_UV\\r\\n`;\n        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n          injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID).xy - ${uv.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\n          injectionCode += `vertexID += 1.0;\\r\\n`;\n        } else {\n          injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\r\\n`;\n        }\n        injectionCode += `#endif\\r\\n`;\n      }\n      if (hasTangents) {\n        injectionCode += `#ifdef MORPHTARGETS_TANGENT\\r\\n`;\n        if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n          injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(${index}, vertexID) - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\r\\n`;\n        } else {\n          injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\r\\n`;\n        }\n        if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\n          injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\r\\n`;\n        } else {\n          injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\r\\n`;\n        }\n        injectionCode += `#endif\\r\\n`;\n      }\n      injectionCode += `#endif\\r\\n`;\n    }\n    state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\n    if (repeatCount > 0) {\n      for (let index = 0; index < repeatCount; index++) {\n        state.attributes.push(VertexBuffer.PositionKind + index);\n        if (hasNormals) {\n          state.attributes.push(VertexBuffer.NormalKind + index);\n        }\n        if (hasTangents) {\n          state.attributes.push(VertexBuffer.TangentKind + index);\n        }\n        if (hasUVs) {\n          state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\n        }\n      }\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    // Register for defines\n    state.sharedData.blocksWithDefines.push(this);\n    // Register for binding\n    state.sharedData.bindableBlocks.push(this);\n    // Register for repeatable content generation\n    state.sharedData.repeatableContentBlocks.push(this);\n    // Emit code\n    const position = this.position;\n    const normal = this.normal;\n    const tangent = this.tangent;\n    const uv = this.uv;\n    const positionOutput = this.positionOutput;\n    const normalOutput = this.normalOutput;\n    const tangentOutput = this.tangentOutput;\n    const uvOutput = this.uvOutput;\n    const comments = `//${this.name}`;\n    state.uniforms.push(\"morphTargetInfluences\");\n    state.uniforms.push(\"morphTargetTextureInfo\");\n    state.uniforms.push(\"morphTargetTextureIndices\");\n    state.samplers.push(\"morphTargets\");\n    state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\n    state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\n      repeatKey: \"maxSimultaneousMorphTargets\"\n    });\n    state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\\r\\n`;\n    state.compilationString += `#ifdef NORMAL\\r\\n`;\n    state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\\r\\n`;\n    state.compilationString += `#else\\r\\n`;\n    state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    state.compilationString += `#ifdef TANGENT\\r\\n`;\n    state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\\r\\n`;\n    state.compilationString += `#else\\r\\n`;\n    state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec4(0., 0., 0., 0.);\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    state.compilationString += `#ifdef UV1\\r\\n`;\n    state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\\r\\n`;\n    state.compilationString += `#else\\r\\n`;\n    state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    // Repeatable content\n    this._repeatableContentAnchor = state._repeatableContentAnchor;\n    state.compilationString += this._repeatableContentAnchor;\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","MaterialHelper","VertexBuffer","InputBlock","RegisterClass","MorphTargetsBlock","constructor","name","Vertex","registerInput","Vector3","AutoDetect","tangent","addExcludedConnectionPointFromAllowedTypes","Color4","Vector4","Vector2","registerOutput","getClassName","position","_inputs","normal","uv","positionOutput","_outputs","normalOutput","tangentOutput","uvOutput","initialize","state","_excludeVariableName","autoConfigure","material","isConnected","positionInput","getInputBlockByPredicate","b","isAttribute","setAsAttribute","output","connectTo","normalInput","tangentInput","uvInput","prepareDefines","mesh","nodeMaterial","defines","morphTargetManager","isUsingTextureForTargets","numInfluencers","markAsAttributesDirty","_areAttributesDirty","PrepareDefinesForMorphTargets","bind","effect","BindMorphTargetParameters","_bind","replaceRepeatableContent","vertexShaderState","fragmentShaderState","repeatCount","NUM_MORPH_INFLUENCERS","manager","hasNormals","supportsNormals","hasTangents","supportsTangents","hasUVs","supportsUVs","injectionCode","index","associatedVariableName","type","compilationString","replace","_repeatableContentAnchor","attributes","push","PositionKind","NormalKind","TangentKind","UVKind","_buildBlock","sharedData","blocksWithDefines","bindableBlocks","repeatableContentBlocks","comments","uniforms","samplers","_emitFunctionFromInclude","repeatKey","_declareOutput"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Vertex/morphTargetsBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport { VertexBuffer } from \"../../../../Buffers/buffer\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration\";\r\n\r\n/**\r\n * Block used to add morph targets support to vertex shader\r\n */\r\nexport class MorphTargetsBlock extends NodeMaterialBlock {\r\n    private _repeatableContentAnchor: string;\r\n\r\n    /**\r\n     * Create a new MorphTargetsBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerInput(\"tangent\", NodeMaterialBlockConnectionPointTypes.AutoDetect);\r\n        this.tangent.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color4 | NodeMaterialBlockConnectionPointTypes.Vector4 | NodeMaterialBlockConnectionPointTypes.Vector3\r\n        );\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerOutput(\"positionOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"normalOutput\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"tangentOutput\", NodeMaterialBlockConnectionPointTypes.Vector4);\r\n        this.registerOutput(\"uvOutput\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"MorphTargetsBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get tangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the position output component\r\n     */\r\n    public get positionOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal output component\r\n     */\r\n    public get normalOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get tangentOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent output component\r\n     */\r\n    public get uvOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"morphTargetInfluences\");\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n        if (!this.normal.isConnected) {\r\n            let normalInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"normal\");\r\n\r\n            if (!normalInput) {\r\n                normalInput = new InputBlock(\"normal\");\r\n                normalInput.setAsAttribute(\"normal\");\r\n            }\r\n            normalInput.output.connectTo(this.normal);\r\n        }\r\n        if (!this.tangent.isConnected) {\r\n            let tangentInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"tangent\");\r\n\r\n            if (!tangentInput) {\r\n                tangentInput = new InputBlock(\"tangent\");\r\n                tangentInput.setAsAttribute(\"tangent\");\r\n            }\r\n            tangentInput.output.connectTo(this.tangent);\r\n        }\r\n        if (!this.uv.isConnected) {\r\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"uv\");\r\n\r\n            if (!uvInput) {\r\n                uvInput = new InputBlock(\"uv\");\r\n                uvInput.setAsAttribute(\"uv\");\r\n            }\r\n            uvInput.output.connectTo(this.uv);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if ((<Mesh>mesh).morphTargetManager) {\r\n            const morphTargetManager = (<Mesh>mesh).morphTargetManager;\r\n\r\n            if (morphTargetManager?.isUsingTextureForTargets && morphTargetManager.numInfluencers !== defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n                defines.markAsAttributesDirty();\r\n            }\r\n        }\r\n\r\n        if (!defines._areAttributesDirty) {\r\n            return;\r\n        }\r\n\r\n        MaterialHelper.PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (mesh && mesh.morphTargetManager && mesh.morphTargetManager.numInfluencers > 0) {\r\n            MaterialHelper.BindMorphTargetParameters(mesh, effect);\r\n\r\n            if (mesh.morphTargetManager.isUsingTextureForTargets) {\r\n                mesh.morphTargetManager._bind(effect);\r\n            }\r\n        }\r\n    }\r\n\r\n    public replaceRepeatableContent(vertexShaderState: NodeMaterialBuildState, fragmentShaderState: NodeMaterialBuildState, mesh: AbstractMesh, defines: NodeMaterialDefines) {\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const state = vertexShaderState;\r\n        const repeatCount = defines.NUM_MORPH_INFLUENCERS as number;\r\n\r\n        const manager = (<Mesh>mesh).morphTargetManager;\r\n        const hasNormals = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const hasTangents = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const hasUVs = manager && manager.supportsUVs && defines[\"UV1\"];\r\n\r\n        let injectionCode = \"\";\r\n\r\n        if (manager?.isUsingTextureForTargets && repeatCount > 0) {\r\n            injectionCode += `float vertexID;\\r\\n`;\r\n        }\r\n\r\n        for (let index = 0; index < repeatCount; index++) {\r\n            injectionCode += `#ifdef MORPHTARGETS\\r\\n`;\r\n            if (manager?.isUsingTextureForTargets) {\r\n                injectionCode += `vertexID = float(gl_VertexID) * morphTargetTextureInfo.x;\\r\\n`;\r\n                injectionCode += `${positionOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                injectionCode += `vertexID += 1.0;\\r\\n`;\r\n            } else {\r\n                injectionCode += `${positionOutput.associatedVariableName} += (position${index} - ${position.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n            }\r\n\r\n            if (hasNormals) {\r\n                injectionCode += `#ifdef MORPHTARGETS_NORMAL\\r\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID) - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                    injectionCode += `vertexID += 1.0;\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${normalOutput.associatedVariableName} += (normal${index} - ${normal.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                }\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            if (hasUVs) {\r\n                injectionCode += `#ifdef MORPHTARGETS_UV\\r\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${uvOutput.associatedVariableName} += (readVector3FromRawSampler(${index}, vertexID).xy - ${uv.associatedVariableName}) * morphTargetInfluences[${index}];\\r\\n`;\r\n                    injectionCode += `vertexID += 1.0;\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${uvOutput.associatedVariableName}.xy += (uv_${index} - ${uv.associatedVariableName}.xy) * morphTargetInfluences[${index}];\\r\\n`;\r\n                }\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            if (hasTangents) {\r\n                injectionCode += `#ifdef MORPHTARGETS_TANGENT\\r\\n`;\r\n                if (manager?.isUsingTextureForTargets) {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.xyz += (readVector3FromRawSampler(${index}, vertexID) - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.xyz += (tangent${index} - ${tangent.associatedVariableName}.xyz) * morphTargetInfluences[${index}];\\r\\n`;\r\n                }\r\n\r\n                if (tangent.type === NodeMaterialBlockConnectionPointTypes.Vector4) {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.w = ${tangent.associatedVariableName}.w;\\r\\n`;\r\n                } else {\r\n                    injectionCode += `${tangentOutput.associatedVariableName}.w = 1.;\\r\\n`;\r\n                }\r\n                injectionCode += `#endif\\r\\n`;\r\n            }\r\n\r\n            injectionCode += `#endif\\r\\n`;\r\n        }\r\n\r\n        state.compilationString = state.compilationString.replace(this._repeatableContentAnchor, injectionCode);\r\n\r\n        if (repeatCount > 0) {\r\n            for (let index = 0; index < repeatCount; index++) {\r\n                state.attributes.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (hasNormals) {\r\n                    state.attributes.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (hasTangents) {\r\n                    state.attributes.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (hasUVs) {\r\n                    state.attributes.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        // Register for defines\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        // Register for binding\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        // Register for repeatable content generation\r\n        state.sharedData.repeatableContentBlocks.push(this);\r\n\r\n        // Emit code\r\n        const position = this.position;\r\n        const normal = this.normal;\r\n        const tangent = this.tangent;\r\n        const uv = this.uv;\r\n        const positionOutput = this.positionOutput;\r\n        const normalOutput = this.normalOutput;\r\n        const tangentOutput = this.tangentOutput;\r\n        const uvOutput = this.uvOutput;\r\n        const comments = `//${this.name}`;\r\n\r\n        state.uniforms.push(\"morphTargetInfluences\");\r\n        state.uniforms.push(\"morphTargetTextureInfo\");\r\n        state.uniforms.push(\"morphTargetTextureIndices\");\r\n        state.samplers.push(\"morphTargets\");\r\n\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexGlobalDeclaration\", comments);\r\n        state._emitFunctionFromInclude(\"morphTargetsVertexDeclaration\", comments, {\r\n            repeatKey: \"maxSimultaneousMorphTargets\",\r\n        });\r\n\r\n        state.compilationString += `${this._declareOutput(positionOutput, state)} = ${position.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#ifdef NORMAL\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = ${normal.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(normalOutput, state)} = vec3(0., 0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef TANGENT\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = ${tangent.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(tangentOutput, state)} = vec4(0., 0., 0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n        state.compilationString += `#ifdef UV1\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = ${uv.associatedVariableName};\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += `${this._declareOutput(uvOutput, state)} = vec2(0., 0.);\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        // Repeatable content\r\n        this._repeatableContentAnchor = state._repeatableContentAnchor;\r\n        state.compilationString += this._repeatableContentAnchor;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.MorphTargetsBlock\", MorphTargetsBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}