{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"./logger.js\";\nconst CloneValue = (source, destinationObject) => {\n  if (!source) {\n    return null;\n  }\n  if (source.getClassName && source.getClassName() === \"Mesh\") {\n    return null;\n  }\n  if (source.getClassName && source.getClassName() === \"SubMesh\") {\n    return source.clone(destinationObject);\n  } else if (source.clone) {\n    return source.clone();\n  }\n  return null;\n};\nfunction GetAllPropertyNames(obj) {\n  const props = [];\n  do {\n    Object.getOwnPropertyNames(obj).forEach(function (prop) {\n      if (props.indexOf(prop) === -1) {\n        props.push(prop);\n      }\n    });\n  } while (obj = Object.getPrototypeOf(obj));\n  return props;\n}\n/**\n * Class containing a set of static utilities functions for deep copy.\n */\nexport class DeepCopier {\n  /**\n   * Tries to copy an object by duplicating every property\n   * @param source defines the source object\n   * @param destination defines the target object\n   * @param doNotCopyList defines a list of properties to avoid\n   * @param mustCopyList defines a list of properties to copy (even if they start with _)\n   */\n  static DeepCopy(source, destination, doNotCopyList, mustCopyList) {\n    const properties = GetAllPropertyNames(source);\n    for (const prop of properties) {\n      if (prop[0] === \"_\" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {\n        continue;\n      }\n      if (prop.endsWith(\"Observable\")) {\n        continue;\n      }\n      if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {\n        continue;\n      }\n      const sourceValue = source[prop];\n      const typeOfSourceValue = typeof sourceValue;\n      if (typeOfSourceValue === \"function\") {\n        continue;\n      }\n      try {\n        if (typeOfSourceValue === \"object\") {\n          if (sourceValue instanceof Array) {\n            destination[prop] = [];\n            if (sourceValue.length > 0) {\n              if (typeof sourceValue[0] == \"object\") {\n                for (let index = 0; index < sourceValue.length; index++) {\n                  const clonedValue = CloneValue(sourceValue[index], destination);\n                  if (destination[prop].indexOf(clonedValue) === -1) {\n                    // Test if auto inject was not done\n                    destination[prop].push(clonedValue);\n                  }\n                }\n              } else {\n                destination[prop] = sourceValue.slice(0);\n              }\n            }\n          } else {\n            destination[prop] = CloneValue(sourceValue, destination);\n          }\n        } else {\n          destination[prop] = sourceValue;\n        }\n      } catch (e) {\n        // Log a warning (it could be because of a read-only property)\n        Logger.Warn(e.message);\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","CloneValue","source","destinationObject","getClassName","clone","GetAllPropertyNames","obj","props","Object","getOwnPropertyNames","forEach","prop","indexOf","push","getPrototypeOf","DeepCopier","DeepCopy","destination","doNotCopyList","mustCopyList","properties","endsWith","sourceValue","typeOfSourceValue","Array","length","index","clonedValue","slice","e","Warn","message"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/deepCopier.ts"],"sourcesContent":["import { Logger } from \"./logger\";\r\n\r\nconst CloneValue = (source: any, destinationObject: any) => {\r\n    if (!source) {\r\n        return null;\r\n    }\r\n\r\n    if (source.getClassName && source.getClassName() === \"Mesh\") {\r\n        return null;\r\n    }\r\n\r\n    if (source.getClassName && source.getClassName() === \"SubMesh\") {\r\n        return source.clone(destinationObject);\r\n    } else if (source.clone) {\r\n        return source.clone();\r\n    }\r\n    return null;\r\n};\r\n\r\nfunction GetAllPropertyNames(obj: any): string[] {\r\n    const props: string[] = [];\r\n\r\n    do {\r\n        Object.getOwnPropertyNames(obj).forEach(function (prop) {\r\n            if (props.indexOf(prop) === -1) {\r\n                props.push(prop);\r\n            }\r\n        });\r\n    } while ((obj = Object.getPrototypeOf(obj)));\r\n\r\n    return props;\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for deep copy.\r\n */\r\nexport class DeepCopier {\r\n    /**\r\n     * Tries to copy an object by duplicating every property\r\n     * @param source defines the source object\r\n     * @param destination defines the target object\r\n     * @param doNotCopyList defines a list of properties to avoid\r\n     * @param mustCopyList defines a list of properties to copy (even if they start with _)\r\n     */\r\n    public static DeepCopy(source: any, destination: any, doNotCopyList?: string[], mustCopyList?: string[]): void {\r\n        const properties = GetAllPropertyNames(source);\r\n        for (const prop of properties) {\r\n            if (prop[0] === \"_\" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {\r\n                continue;\r\n            }\r\n\r\n            if (prop.endsWith(\"Observable\")) {\r\n                continue;\r\n            }\r\n\r\n            if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {\r\n                continue;\r\n            }\r\n\r\n            const sourceValue = source[prop];\r\n            const typeOfSourceValue = typeof sourceValue;\r\n\r\n            if (typeOfSourceValue === \"function\") {\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                if (typeOfSourceValue === \"object\") {\r\n                    if (sourceValue instanceof Array) {\r\n                        destination[prop] = [];\r\n\r\n                        if (sourceValue.length > 0) {\r\n                            if (typeof sourceValue[0] == \"object\") {\r\n                                for (let index = 0; index < sourceValue.length; index++) {\r\n                                    const clonedValue = CloneValue(sourceValue[index], destination);\r\n\r\n                                    if (destination[prop].indexOf(clonedValue) === -1) {\r\n                                        // Test if auto inject was not done\r\n                                        destination[prop].push(clonedValue);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                destination[prop] = sourceValue.slice(0);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        destination[prop] = CloneValue(sourceValue, destination);\r\n                    }\r\n                } else {\r\n                    destination[prop] = sourceValue;\r\n                }\r\n            } catch (e) {\r\n                // Log a warning (it could be because of a read-only property)\r\n                Logger.Warn(e.message);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}