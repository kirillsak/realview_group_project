{"ast":null,"code":"import { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces.js\";\nimport { Vector2, Vector3, Vector4, Matrix } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Effect } from \"@babylonjs/core/Materials/effect.js\";\nimport { ShaderMaterial } from \"@babylonjs/core/Materials/shaderMaterial.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\n/**\n * Utils functions for GLTF\n * @internal\n * @deprecated\n */\nexport class GLTFUtils {\n  /**\n   * Sets the given \"parameter\" matrix\n   * @param scene the Scene object\n   * @param source the source node where to pick the matrix\n   * @param parameter the GLTF technique parameter\n   * @param uniformName the name of the shader's uniform\n   * @param shaderMaterial the shader material\n   */\n  static SetMatrix(scene, source, parameter, uniformName, shaderMaterial) {\n    let mat = null;\n    if (parameter.semantic === \"MODEL\") {\n      mat = source.getWorldMatrix();\n    } else if (parameter.semantic === \"PROJECTION\") {\n      mat = scene.getProjectionMatrix();\n    } else if (parameter.semantic === \"VIEW\") {\n      mat = scene.getViewMatrix();\n    } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\n      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\n    } else if (parameter.semantic === \"MODELVIEW\") {\n      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\n    } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\n      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\n    } else if (parameter.semantic === \"MODELINVERSE\") {\n      mat = source.getWorldMatrix().invert();\n    } else if (parameter.semantic === \"VIEWINVERSE\") {\n      mat = scene.getViewMatrix().invert();\n    } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\n      mat = scene.getProjectionMatrix().invert();\n    } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\n      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\n    } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\n      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\n    } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\n      mat = Matrix.Transpose(source.getWorldMatrix().invert());\n    }\n    if (mat) {\n      switch (parameter.type) {\n        case EParameterType.FLOAT_MAT2:\n          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\n          break;\n        case EParameterType.FLOAT_MAT3:\n          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\n          break;\n        case EParameterType.FLOAT_MAT4:\n          shaderMaterial.setMatrix(uniformName, mat);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  /**\n   * Sets the given \"parameter\" matrix\n   * @param shaderMaterial the shader material\n   * @param uniform the name of the shader's uniform\n   * @param value the value of the uniform\n   * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\n   */\n  static SetUniform(shaderMaterial, uniform, value, type) {\n    switch (type) {\n      case EParameterType.FLOAT:\n        shaderMaterial.setFloat(uniform, value);\n        return true;\n      case EParameterType.FLOAT_VEC2:\n        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\n        return true;\n      case EParameterType.FLOAT_VEC3:\n        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\n        return true;\n      case EParameterType.FLOAT_VEC4:\n        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\n        return true;\n      default:\n        return false;\n    }\n  }\n  /**\n   * Returns the wrap mode of the texture\n   * @param mode the mode value\n   */\n  static GetWrapMode(mode) {\n    switch (mode) {\n      case ETextureWrapMode.CLAMP_TO_EDGE:\n        return Texture.CLAMP_ADDRESSMODE;\n      case ETextureWrapMode.MIRRORED_REPEAT:\n        return Texture.MIRROR_ADDRESSMODE;\n      case ETextureWrapMode.REPEAT:\n        return Texture.WRAP_ADDRESSMODE;\n      default:\n        return Texture.WRAP_ADDRESSMODE;\n    }\n  }\n  /**\n   * Returns the byte stride giving an accessor\n   * @param accessor the GLTF accessor objet\n   */\n  static GetByteStrideFromType(accessor) {\n    // Needs this function since \"byteStride\" isn't requiered in glTF format\n    const type = accessor.type;\n    switch (type) {\n      case \"VEC2\":\n        return 2;\n      case \"VEC3\":\n        return 3;\n      case \"VEC4\":\n        return 4;\n      case \"MAT2\":\n        return 4;\n      case \"MAT3\":\n        return 9;\n      case \"MAT4\":\n        return 16;\n      default:\n        return 1;\n    }\n  }\n  /**\n   * Returns the texture filter mode giving a mode value\n   * @param mode the filter mode value\n   */\n  static GetTextureFilterMode(mode) {\n    switch (mode) {\n      case ETextureFilterType.LINEAR:\n      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\n      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\n        return Texture.TRILINEAR_SAMPLINGMODE;\n      case ETextureFilterType.NEAREST:\n      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\n        return Texture.NEAREST_SAMPLINGMODE;\n      default:\n        return Texture.BILINEAR_SAMPLINGMODE;\n    }\n  }\n  static GetBufferFromBufferView(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {\n    byteOffset = bufferView.byteOffset + byteOffset;\n    const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\n    if (byteOffset + byteLength > loadedBufferView.byteLength) {\n      throw new Error(\"Buffer access is out of range\");\n    }\n    const buffer = loadedBufferView.buffer;\n    byteOffset += loadedBufferView.byteOffset;\n    switch (componentType) {\n      case EComponentType.BYTE:\n        return new Int8Array(buffer, byteOffset, byteLength);\n      case EComponentType.UNSIGNED_BYTE:\n        return new Uint8Array(buffer, byteOffset, byteLength);\n      case EComponentType.SHORT:\n        return new Int16Array(buffer, byteOffset, byteLength);\n      case EComponentType.UNSIGNED_SHORT:\n        return new Uint16Array(buffer, byteOffset, byteLength);\n      default:\n        return new Float32Array(buffer, byteOffset, byteLength);\n    }\n  }\n  /**\n   * Returns a buffer from its accessor\n   * @param gltfRuntime the GLTF runtime\n   * @param accessor the GLTF accessor\n   */\n  static GetBufferFromAccessor(gltfRuntime, accessor) {\n    const bufferView = gltfRuntime.bufferViews[accessor.bufferView];\n    const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\n    return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\n  }\n  /**\n   * Decodes a buffer view into a string\n   * @param view the buffer view\n   */\n  static DecodeBufferToText(view) {\n    let result = \"\";\n    const length = view.byteLength;\n    for (let i = 0; i < length; ++i) {\n      result += String.fromCharCode(view[i]);\n    }\n    return result;\n  }\n  /**\n   * Returns the default material of gltf. Related to\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\n   * @param scene the Babylon.js scene\n   */\n  static GetDefaultMaterial(scene) {\n    if (!GLTFUtils._DefaultMaterial) {\n      Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\"precision highp float;\", \"\", \"uniform mat4 worldView;\", \"uniform mat4 projection;\", \"\", \"attribute vec3 position;\", \"\", \"void main(void)\", \"{\", \"    gl_Position = projection * worldView * vec4(position, 1.0);\", \"}\"].join(\"\\n\");\n      Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\"precision highp float;\", \"\", \"uniform vec4 u_emission;\", \"\", \"void main(void)\", \"{\", \"    gl_FragColor = u_emission;\", \"}\"].join(\"\\n\");\n      const shaderPath = {\n        vertex: \"GLTFDefaultMaterial\",\n        fragment: \"GLTFDefaultMaterial\"\n      };\n      const options = {\n        attributes: [\"position\"],\n        uniforms: [\"worldView\", \"projection\", \"u_emission\"],\n        samplers: new Array(),\n        needAlphaBlending: false\n      };\n      GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\n      GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\n    }\n    return GLTFUtils._DefaultMaterial;\n  }\n}\n// The GLTF default material\nGLTFUtils._DefaultMaterial = null;","map":{"version":3,"mappings":"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","names":["EParameterType","ETextureWrapMode","ETextureFilterType","EComponentType","Vector2","Vector3","Vector4","Matrix","Color4","Effect","ShaderMaterial","Texture","GLTFUtils","SetMatrix","scene","source","parameter","uniformName","shaderMaterial","mat","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","Transpose","multiply","invert","getTransformMatrix","type","FLOAT_MAT2","setMatrix2x2","GetAsMatrix2x2","FLOAT_MAT3","setMatrix3x3","GetAsMatrix3x3","FLOAT_MAT4","setMatrix","SetUniform","uniform","value","FLOAT","setFloat","FLOAT_VEC2","setVector2","FromArray","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","GetWrapMode","mode","CLAMP_TO_EDGE","CLAMP_ADDRESSMODE","MIRRORED_REPEAT","MIRROR_ADDRESSMODE","REPEAT","WRAP_ADDRESSMODE","GetByteStrideFromType","accessor","GetTextureFilterMode","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_SAMPLINGMODE","BILINEAR_SAMPLINGMODE","GetBufferFromBufferView","gltfRuntime","bufferView","byteOffset","byteLength","componentType","loadedBufferView","loadedBufferViews","buffer","Error","BYTE","Int8Array","UNSIGNED_BYTE","Uint8Array","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","Float32Array","GetBufferFromAccessor","bufferViews","count","DecodeBufferToText","view","result","length","i","String","fromCharCode","GetDefaultMaterial","_DefaultMaterial","ShadersStore","join","shaderPath","vertex","fragment","options","attributes","uniforms","samplers","Array","needAlphaBlending","setColor4"],"sourceRoot":"","sources":["../../../../../lts/loaders/generated/glTF/1.0/glTFLoaderUtils.ts"],"sourcesContent":["import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     */\r\n    public static GetTextureFilterMode(mode: number): ETextureFilterType {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}