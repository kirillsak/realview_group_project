{"ast":null,"code":"import { AbstractMesh } from \"../../Meshes/abstractMesh.js\";\nimport { PhysicsJoint } from \"./physicsJoint.js\";\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\n  get: function () {\n    return this._physicsImpostor;\n  },\n  set: function (value) {\n    if (this._physicsImpostor === value) {\n      return;\n    }\n    if (this._disposePhysicsObserver) {\n      this.onDisposeObservable.remove(this._disposePhysicsObserver);\n    }\n    this._physicsImpostor = value;\n    if (value) {\n      this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\n        // Physics\n        if (this.physicsImpostor) {\n          this.physicsImpostor.dispose( /*!doNotRecurse*/);\n          this.physicsImpostor = null;\n        }\n      });\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Gets the current physics impostor\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\n * @returns a physics impostor or null\n */\nAbstractMesh.prototype.getPhysicsImpostor = function () {\n  return this.physicsImpostor;\n};\n/**\n * Apply a physic impulse to the mesh\n * @param force defines the force to apply\n * @param contactPoint defines where to apply the force\n * @returns the current mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\n */\nAbstractMesh.prototype.applyImpulse = function (force, contactPoint) {\n  if (!this.physicsImpostor) {\n    return this;\n  }\n  this.physicsImpostor.applyImpulse(force, contactPoint);\n  return this;\n};\n/**\n * Creates a physic joint between two meshes\n * @param otherMesh defines the other mesh to use\n * @param pivot1 defines the pivot to use on this mesh\n * @param pivot2 defines the pivot to use on the other mesh\n * @param options defines additional options (can be plugin dependent)\n * @returns the current mesh\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\n */\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh, pivot1, pivot2, options) {\n  if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\n    return this;\n  }\n  this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\n    mainPivot: pivot1,\n    connectedPivot: pivot2,\n    nativeParams: options\n  });\n  return this;\n};","map":{"version":3,"mappings":"AAIA,SAASA,YAAY,QAAQ,8BAA4B;AAGzD,SAASC,YAAY,QAAQ,mBAAiB;AA+C9CC,MAAM,CAACC,cAAc,CAACH,YAAY,CAACI,SAAS,EAAE,iBAAiB,EAAE;EAC7DC,GAAG,EAAE;IACD,OAAO,IAAI,CAACC,gBAAgB;EAChC,CAAC;EACDC,GAAG,EAAE,UAA8BC,KAAgC;IAC/D,IAAI,IAAI,CAACF,gBAAgB,KAAKE,KAAK,EAAE;MACjC;;IAEJ,IAAI,IAAI,CAACC,uBAAuB,EAAE;MAC9B,IAAI,CAACC,mBAAmB,CAACC,MAAM,CAAC,IAAI,CAACF,uBAAuB,CAAC;;IAGjE,IAAI,CAACH,gBAAgB,GAAGE,KAAK;IAE7B,IAAIA,KAAK,EAAE;MACP,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACC,mBAAmB,CAACE,GAAG,CAAC,MAAK;QAC7D;QACA,IAAI,IAAI,CAACC,eAAe,EAAE;UACtB,IAAI,CAACA,eAAe,CAACC,OAAO,EAAC,kBAAkB;UAC/C,IAAI,CAACD,eAAe,GAAG,IAAI;;MAEnC,CAAC,CAAC;;EAEV,CAAC;EACDE,UAAU,EAAE,IAAI;EAChBC,YAAY,EAAE;CACjB,CAAC;AAEF;;;;;AAKAhB,YAAY,CAACI,SAAS,CAACa,kBAAkB,GAAG;EACxC,OAAO,IAAI,CAACJ,eAAe;AAC/B,CAAC;AAED;;;;;;;AAOAb,YAAY,CAACI,SAAS,CAACc,YAAY,GAAG,UAAUC,KAAc,EAAEC,YAAqB;EACjF,IAAI,CAAC,IAAI,CAACP,eAAe,EAAE;IACvB,OAAO,IAAI;;EAEf,IAAI,CAACA,eAAe,CAACK,YAAY,CAACC,KAAK,EAAEC,YAAY,CAAC;EACtD,OAAO,IAAI;AACf,CAAC;AAED;;;;;;;;;AASApB,YAAY,CAACI,SAAS,CAACiB,kBAAkB,GAAG,UAAUC,SAAe,EAAEC,MAAe,EAAEC,MAAe,EAAEC,OAAa;EAClH,IAAI,CAAC,IAAI,CAACZ,eAAe,IAAI,CAACS,SAAS,CAACT,eAAe,EAAE;IACrD,OAAO,IAAI;;EAEf,IAAI,CAACA,eAAe,CAACa,WAAW,CAACJ,SAAS,CAACT,eAAe,EAAEZ,YAAY,CAAC0B,UAAU,EAAE;IACjFC,SAAS,EAAEL,MAAM;IACjBM,cAAc,EAAEL,MAAM;IACtBM,YAAY,EAAEL;GACjB,CAAC;EACF,OAAO,IAAI;AACf,CAAC","names":["AbstractMesh","PhysicsJoint","Object","defineProperty","prototype","get","_physicsImpostor","set","value","_disposePhysicsObserver","onDisposeObservable","remove","add","physicsImpostor","dispose","enumerable","configurable","getPhysicsImpostor","applyImpulse","force","contactPoint","setPhysicsLinkWith","otherMesh","pivot1","pivot2","options","createJoint","HingeJoint","mainPivot","connectedPivot","nativeParams"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Physics/v1/physicsEngineComponent.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Node } from \"../../node\";\r\nimport type { PhysicsImpostor } from \"./physicsImpostor\";\r\nimport { PhysicsJoint } from \"./physicsJoint\";\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    /**\r\n     *\r\n     */\r\n    export interface AbstractMesh {\r\n        /** @internal */\r\n        _physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets or sets impostor used for physic simulation\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n         */\r\n        physicsImpostor: Nullable<PhysicsImpostor>;\r\n\r\n        /**\r\n         * Gets the current physics impostor\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n         * @returns a physics impostor or null\r\n         */\r\n        getPhysicsImpostor(): Nullable<PhysicsImpostor>;\r\n\r\n        /** Apply a physic impulse to the mesh\r\n         * @param force defines the force to apply\r\n         * @param contactPoint defines where to apply the force\r\n         * @returns the current mesh\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n         */\r\n        applyImpulse(force: Vector3, contactPoint: Vector3): AbstractMesh;\r\n\r\n        /**\r\n         * Creates a physic joint between two meshes\r\n         * @param otherMesh defines the other mesh to use\r\n         * @param pivot1 defines the pivot to use on this mesh\r\n         * @param pivot2 defines the pivot to use on the other mesh\r\n         * @param options defines additional options (can be plugin dependent)\r\n         * @returns the current mesh\r\n         * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n         */\r\n        setPhysicsLinkWith(otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh;\r\n\r\n        /** @internal */\r\n        _disposePhysicsObserver: Nullable<Observer<Node>>;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"physicsImpostor\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._physicsImpostor;\r\n    },\r\n    set: function (this: AbstractMesh, value: Nullable<PhysicsImpostor>) {\r\n        if (this._physicsImpostor === value) {\r\n            return;\r\n        }\r\n        if (this._disposePhysicsObserver) {\r\n            this.onDisposeObservable.remove(this._disposePhysicsObserver);\r\n        }\r\n\r\n        this._physicsImpostor = value;\r\n\r\n        if (value) {\r\n            this._disposePhysicsObserver = this.onDisposeObservable.add(() => {\r\n                // Physics\r\n                if (this.physicsImpostor) {\r\n                    this.physicsImpostor.dispose(/*!doNotRecurse*/);\r\n                    this.physicsImpostor = null;\r\n                }\r\n            });\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Gets the current physics impostor\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics\r\n * @returns a physics impostor or null\r\n */\r\nAbstractMesh.prototype.getPhysicsImpostor = function (): Nullable<PhysicsImpostor> {\r\n    return this.physicsImpostor;\r\n};\r\n\r\n/**\r\n * Apply a physic impulse to the mesh\r\n * @param force defines the force to apply\r\n * @param contactPoint defines where to apply the force\r\n * @returns the current mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/physics/usingPhysicsEngine\r\n */\r\nAbstractMesh.prototype.applyImpulse = function (force: Vector3, contactPoint: Vector3): AbstractMesh {\r\n    if (!this.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.applyImpulse(force, contactPoint);\r\n    return this;\r\n};\r\n\r\n/**\r\n * Creates a physic joint between two meshes\r\n * @param otherMesh defines the other mesh to use\r\n * @param pivot1 defines the pivot to use on this mesh\r\n * @param pivot2 defines the pivot to use on the other mesh\r\n * @param options defines additional options (can be plugin dependent)\r\n * @returns the current mesh\r\n * @see https://www.babylonjs-playground.com/#0BS5U0#0\r\n */\r\nAbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh: Mesh, pivot1: Vector3, pivot2: Vector3, options?: any): AbstractMesh {\r\n    if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\r\n        return this;\r\n    }\r\n    this.physicsImpostor.createJoint(otherMesh.physicsImpostor, PhysicsJoint.HingeJoint, {\r\n        mainPivot: pivot1,\r\n        connectedPivot: pivot2,\r\n        nativeParams: options,\r\n    });\r\n    return this;\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}