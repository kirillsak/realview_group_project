{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { FreeCamera } from \"../../Cameras/freeCamera.js\";\nimport { Camera } from \"../../Cameras/camera.js\";\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Gamepad } from \"../../Gamepads/gamepad.js\";\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController.js\";\nimport { Node } from \"../../node.js\";\nimport { HemisphericLight } from \"../../Lights/hemisphericLight.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport { setWebVRRigMode } from \"../RigModes/webVRRigMode.js\";\n// Side effect import to add webvr support to engine\nimport \"../../Engines/Extensions/engine.webVR.js\";\nNode.AddNodeConstructor(\"WebVRFreeCamera\", (name, scene) => {\n  return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\n});\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", (name, scene) => {\n  return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\n});\n/**\n * This represents a WebVR camera.\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\n * @deprecated Use WebXR instead - https://doc.babylonjs.com/features/featuresDeepDive/webXR\n * @example https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRCamera\n */\nexport class WebVRFreeCamera extends FreeCamera {\n  /**\n   * Instantiates a WebVRFreeCamera.\n   * @param name The name of the WebVRFreeCamera\n   * @param position The starting anchor position for the camera\n   * @param scene The scene the camera belongs to\n   * @param _webVROptions a set of customizable options for the webVRCamera\n   */\n  constructor(name, position, scene, _webVROptions = {}) {\n    super(name, position, scene);\n    this._webVROptions = _webVROptions;\n    /**\n     * @internal\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\n     */\n    this._vrDevice = null;\n    /**\n     * The rawPose of the vrDevice.\n     */\n    this.rawPose = null;\n    this._specsVersion = \"1.1\";\n    this._attached = false;\n    this._descendants = [];\n    // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\n    this._deviceRoomPosition = Vector3.Zero();\n    /** @internal */\n    this._deviceRoomRotationQuaternion = Quaternion.Identity();\n    this._standingMatrix = null;\n    /**\n     * Represents device position in babylon space.\n     */\n    this.devicePosition = Vector3.Zero();\n    /**\n     * Represents device rotation in babylon space.\n     */\n    this.deviceRotationQuaternion = Quaternion.Identity();\n    /**\n     * The scale of the device to be used when translating from device space to babylon space.\n     */\n    this.deviceScaleFactor = 1;\n    this._deviceToWorld = Matrix.Identity();\n    this._worldToDevice = Matrix.Identity();\n    /**\n     * References to the webVR controllers for the vrDevice.\n     */\n    this.controllers = [];\n    /**\n     * Emits an event when a controller is attached.\n     */\n    this.onControllersAttachedObservable = new Observable();\n    /**\n     * Emits an event when a controller's mesh has been loaded;\n     */\n    this.onControllerMeshLoadedObservable = new Observable();\n    /**\n     * Emits an event when the HMD's pose has been updated.\n     */\n    this.onPoseUpdatedFromDeviceObservable = new Observable();\n    this._poseSet = false;\n    /**\n     * If the rig cameras be used as parent instead of this camera.\n     */\n    this.rigParenting = true;\n    this._defaultHeight = undefined;\n    this._setRigMode = setWebVRRigMode.bind(null, this);\n    this._detachIfAttached = () => {\n      const vrDisplay = this.getEngine().getVRDevice();\n      if (vrDisplay && !vrDisplay.isPresenting) {\n        this.detachControl();\n      }\n    };\n    this._workingVector = Vector3.Zero();\n    this._oneVector = Vector3.One();\n    this._workingMatrix = Matrix.Identity();\n    this._tmpMatrix = new Matrix();\n    this._cache.position = Vector3.Zero();\n    if (_webVROptions.defaultHeight) {\n      this._defaultHeight = _webVROptions.defaultHeight;\n      this.position.y = this._defaultHeight;\n    }\n    this.minZ = 0.1;\n    //legacy support - the compensation boolean was removed.\n    if (arguments.length === 5) {\n      // eslint-disable-next-line prefer-rest-params\n      this._webVROptions = arguments[4];\n    }\n    // default webVR options\n    if (this._webVROptions.trackPosition == undefined) {\n      this._webVROptions.trackPosition = true;\n    }\n    if (this._webVROptions.controllerMeshes == undefined) {\n      this._webVROptions.controllerMeshes = true;\n    }\n    if (this._webVROptions.defaultLightingOnControllers == undefined) {\n      this._webVROptions.defaultLightingOnControllers = true;\n    }\n    this.rotationQuaternion = new Quaternion();\n    if (this._webVROptions && this._webVROptions.positionScale) {\n      this.deviceScaleFactor = this._webVROptions.positionScale;\n    }\n    //enable VR\n    const engine = this.getEngine();\n    this._onVREnabled = success => {\n      if (success) {\n        this.initControllers();\n      }\n    };\n    engine.onVRRequestPresentComplete.add(this._onVREnabled);\n    engine.initWebVR().add(event => {\n      if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {\n        return;\n      }\n      this._vrDevice = event.vrDisplay;\n      //reset the rig parameters.\n      this.setCameraRigMode(Camera.RIG_MODE_WEBVR, {\n        parentCamera: this,\n        vrDisplay: this._vrDevice,\n        frameData: this._frameData,\n        specs: this._specsVersion\n      });\n      if (this._attached) {\n        this.getEngine().enableVR(this._webVROptions);\n      }\n    });\n    if (typeof VRFrameData !== \"undefined\") {\n      this._frameData = new VRFrameData();\n    }\n    if (_webVROptions.useMultiview) {\n      if (!this.getScene().getEngine().getCaps().multiview) {\n        Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\n        this._useMultiviewToSingleView = false;\n      } else {\n        this._useMultiviewToSingleView = true;\n        this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", this, 1.0);\n      }\n    }\n    /**\n     * The idea behind the following lines:\n     * objects that have the camera as parent should actually have the rig cameras as a parent.\n     * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\n     * the second will not show it correctly.\n     *\n     * To solve this - each object that has the camera as parent will be added to a protected array.\n     * When the rig camera renders, it will take this array and set all of those to be its children.\n     * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\n     * Amazing!\n     */\n    this.getScene().onBeforeCameraRenderObservable.add(camera => {\n      if (camera.parent === this && this.rigParenting) {\n        this._descendants = this.getDescendants(true, n => {\n          // don't take the cameras or the controllers!\n          const isController = this.controllers.some(controller => {\n            return controller._mesh === n;\n          });\n          const isRigCamera = this._rigCameras.indexOf(n) !== -1;\n          return !isController && !isRigCamera;\n        });\n        this._descendants.forEach(node => {\n          node.parent = camera;\n        });\n      }\n    });\n    this.getScene().onAfterCameraRenderObservable.add(camera => {\n      if (camera.parent === this && this.rigParenting) {\n        this._descendants.forEach(node => {\n          node.parent = this;\n        });\n      }\n    });\n  }\n  /**\n   * Gets the device distance from the ground in meters.\n   * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\n   */\n  deviceDistanceToRoomGround() {\n    if (this._standingMatrix) {\n      // Add standing matrix offset to get real offset from ground in room\n      this._standingMatrix.getTranslationToRef(this._workingVector);\n      return this._deviceRoomPosition.y + this._workingVector.y;\n    }\n    //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\n    return this._defaultHeight || 0;\n  }\n  /**\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\n   * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  useStandingMatrix(callback = bool => {}) {\n    // Use standing matrix if available\n    this.getEngine().initWebVRAsync().then(result => {\n      if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this._webVROptions.trackPosition) {\n        callback(false);\n      } else {\n        this._standingMatrix = new Matrix();\n        Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);\n        if (!this.getScene().useRightHandedSystem) {\n          if (this._standingMatrix) {\n            this._standingMatrix.toggleModelMatrixHandInPlace();\n          }\n        }\n        callback(true);\n      }\n    });\n  }\n  /**\n   * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\n   * @returns A promise with a boolean set to if the standing matrix is supported.\n   */\n  useStandingMatrixAsync() {\n    return new Promise(res => {\n      this.useStandingMatrix(supported => {\n        res(supported);\n      });\n    });\n  }\n  /**\n   * Disposes the camera\n   */\n  dispose() {\n    this._detachIfAttached();\n    this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\n    if (this._updateCacheWhenTrackingDisabledObserver) {\n      this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\n    }\n    super.dispose();\n  }\n  /**\n   * Gets a vrController by name.\n   * @param name The name of the controller to retrieve\n   * @returns the controller matching the name specified or null if not found\n   */\n  getControllerByName(name) {\n    for (const gp of this.controllers) {\n      if (gp.hand === name) {\n        return gp;\n      }\n    }\n    return null;\n  }\n  /**\n   * The controller corresponding to the users left hand.\n   */\n  get leftController() {\n    if (!this._leftController) {\n      this._leftController = this.getControllerByName(\"left\");\n    }\n    return this._leftController;\n  }\n  /**\n   * The controller corresponding to the users right hand.\n   */\n  get rightController() {\n    if (!this._rightController) {\n      this._rightController = this.getControllerByName(\"right\");\n    }\n    return this._rightController;\n  }\n  /**\n   * Casts a ray forward from the vrCamera's gaze.\n   * @param length Length of the ray (default: 100)\n   * @returns the ray corresponding to the gaze\n   */\n  getForwardRay(length = 100) {\n    if (this.leftCamera) {\n      // Use left eye to avoid computation to compute center on every call\n      return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\n    } else {\n      return super.getForwardRay(length);\n    }\n  }\n  /**\n   * @internal\n   * Updates the camera based on device's frame data\n   */\n  _checkInputs() {\n    if (this._vrDevice && this._vrDevice.isPresenting) {\n      this._vrDevice.getFrameData(this._frameData);\n      this.updateFromDevice(this._frameData.pose);\n    }\n    super._checkInputs();\n  }\n  /**\n   * Updates the poseControlled values based on the input device pose.\n   * @param poseData Pose coming from the device\n   */\n  updateFromDevice(poseData) {\n    if (poseData && poseData.orientation && poseData.orientation.length === 4) {\n      this.rawPose = poseData;\n      this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\n      if (this.getScene().useRightHandedSystem) {\n        this._deviceRoomRotationQuaternion.z *= -1;\n        this._deviceRoomRotationQuaternion.w *= -1;\n      }\n      if (this._webVROptions.trackPosition && this.rawPose.position) {\n        this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\n        if (this.getScene().useRightHandedSystem) {\n          this._deviceRoomPosition.z *= -1;\n        }\n      }\n      this._poseSet = true;\n    }\n  }\n  /**\n   * WebVR's attach control will start broadcasting frames to the device.\n   * Note that in certain browsers (chrome for example) this function must be called\n   * within a user-interaction callback. Example:\n   * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\n   *\n   * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    super.attachControl(noPreventDefault);\n    this._attached = true;\n    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n    if (this._vrDevice) {\n      this.getEngine().enableVR(this._webVROptions);\n    }\n    const hostWindow = this._scene.getEngine().getHostWindow();\n    if (hostWindow) {\n      hostWindow.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n    }\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\n    this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\n    super.detachControl();\n    this._attached = false;\n    this.getEngine().disableVR();\n    window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\n  }\n  /**\n   * @returns the name of this class\n   */\n  getClassName() {\n    return \"WebVRFreeCamera\";\n  }\n  /**\n   * Calls resetPose on the vrDisplay\n   * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\n   */\n  resetToCurrentRotation() {\n    //uses the vrDisplay's \"resetPose()\".\n    //pitch and roll won't be affected.\n    this._vrDevice.resetPose();\n  }\n  /**\n   * @internal\n   * Updates the rig cameras (left and right eye)\n   */\n  _updateRigCameras() {\n    const camLeft = this._rigCameras[0];\n    const camRight = this._rigCameras[1];\n    camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\n    camLeft.position.copyFrom(this._deviceRoomPosition);\n    camRight.position.copyFrom(this._deviceRoomPosition);\n  }\n  // Remove translation from 6dof headset if trackposition is set to false\n  _correctPositionIfNotTrackPosition(matrix, isViewMatrix = false) {\n    if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {\n      Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\n      if (!isViewMatrix) {\n        this._tmpMatrix.invert();\n      }\n      this._tmpMatrix.multiplyToRef(matrix, matrix);\n    }\n  }\n  /**\n   * @internal\n   * Updates the cached values of the camera\n   * @param ignoreParentClass ignores updating the parent class's cache (default: false)\n   */\n  _updateCache(ignoreParentClass) {\n    if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\n      // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\n      if (!this._updateCacheCalled) {\n        // make sure it is only called once per loop. this.update() might cause an infinite loop.\n        this._updateCacheCalled = true;\n        this.update();\n      }\n      // Set working vector to the device position in room space rotated by the new rotation\n      this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\n      Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);\n      // Subtract this vector from the current device position in world to get the translation for the device world matrix\n      this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\n      Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);\n      // Add translation from anchor position\n      this._deviceToWorld.getTranslationToRef(this._workingVector);\n      this._workingVector.addInPlace(this.position);\n      this._workingVector.subtractInPlace(this._cache.position);\n      this._deviceToWorld.setTranslation(this._workingVector);\n      // Set an inverted matrix to be used when updating the camera\n      this._deviceToWorld.invertToRef(this._worldToDevice);\n      // Update the gamepad to ensure the mesh is updated on the same frame as camera\n      this.controllers.forEach(controller => {\n        controller._deviceToWorld.copyFrom(this._deviceToWorld);\n        this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\n        controller.update();\n      });\n    }\n    if (!ignoreParentClass) {\n      super._updateCache();\n    }\n    this._updateCacheCalled = false;\n  }\n  /**\n   * @internal\n   * Get current device position in babylon world\n   */\n  _computeDevicePosition() {\n    Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\n  }\n  /**\n   * Updates the current device position and rotation in the babylon world\n   */\n  update() {\n    this._computeDevicePosition();\n    // Get current device rotation in babylon world\n    Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\n    this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\n    Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\n    if (this._poseSet) {\n      this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\n    }\n    super.update();\n  }\n  /**\n   * @internal\n   * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\n   * @returns an identity matrix\n   */\n  _getViewMatrix() {\n    return Matrix.Identity();\n  }\n  /**\n   * This function is called by the two RIG cameras.\n   * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\n   * @internal\n   */\n  _getWebVRViewMatrix() {\n    // Update the parent camera prior to using a child camera to avoid desynchronization\n    const parentCamera = this._cameraRigParams[\"parentCamera\"];\n    parentCamera._updateCache();\n    //WebVR 1.1\n    const viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\n    Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\n    if (!this.getScene().useRightHandedSystem) {\n      this._webvrViewMatrix.toggleModelMatrixHandInPlace();\n    }\n    // update the camera rotation matrix\n    this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n    // Computing target and final matrix\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n    // should the view matrix be updated with scale and position offset?\n    if (parentCamera.deviceScaleFactor !== 1) {\n      this._webvrViewMatrix.invert();\n      // scale the position, if set\n      if (parentCamera.deviceScaleFactor) {\n        this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\n        this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\n        this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\n      }\n      this._webvrViewMatrix.invert();\n    }\n    // Remove translation from 6dof headset if trackposition is set to false\n    parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\n    parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);\n    // Compute global position\n    this._workingMatrix = this._workingMatrix || Matrix.Identity();\n    this._webvrViewMatrix.invertToRef(this._workingMatrix);\n    this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\n    this._workingMatrix.getTranslationToRef(this._globalPosition);\n    this._markSyncedWithParent();\n    return this._webvrViewMatrix;\n  }\n  /** @internal */\n  _getWebVRProjectionMatrix() {\n    const parentCamera = this.parent;\n    parentCamera._vrDevice.depthNear = parentCamera.minZ;\n    parentCamera._vrDevice.depthFar = parentCamera.maxZ;\n    const projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\n    Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\n    //babylon compatible matrix\n    if (!this.getScene().useRightHandedSystem) {\n      this._projectionMatrix.toggleProjectionMatrixHandInPlace();\n    }\n    return this._projectionMatrix;\n  }\n  /**\n   * Initializes the controllers and their meshes\n   */\n  initControllers() {\n    this.controllers.length = 0;\n    const manager = this.getScene().gamepadManager;\n    this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add(gamepad => {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        const webVrController = gamepad;\n        if (webVrController.defaultModel) {\n          webVrController.defaultModel.setEnabled(false);\n        }\n        if (webVrController.hand === \"right\") {\n          this._rightController = null;\n        }\n        if (webVrController.hand === \"left\") {\n          this._leftController = null;\n        }\n        const controllerIndex = this.controllers.indexOf(webVrController);\n        if (controllerIndex !== -1) {\n          this.controllers.splice(controllerIndex, 1);\n        }\n      }\n    });\n    this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add(gamepad => {\n      if (gamepad.type === Gamepad.POSE_ENABLED) {\n        const webVrController = gamepad;\n        if (!this._webVROptions.trackPosition) {\n          webVrController._disableTrackPosition(new Vector3(webVrController.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25));\n          // Cache must be updated before rendering controllers to avoid them being one frame behind\n          if (!this._updateCacheWhenTrackingDisabledObserver) {\n            this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {\n              this._updateCache();\n            });\n          }\n        }\n        webVrController.deviceScaleFactor = this.deviceScaleFactor;\n        webVrController._deviceToWorld.copyFrom(this._deviceToWorld);\n        this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);\n        if (this._webVROptions.controllerMeshes) {\n          if (webVrController.defaultModel) {\n            webVrController.defaultModel.setEnabled(true);\n          } else {\n            // Load the meshes\n            webVrController.initControllerMesh(this.getScene(), loadedMesh => {\n              loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);\n              this.onControllerMeshLoadedObservable.notifyObservers(webVrController);\n              if (this._webVROptions.defaultLightingOnControllers) {\n                if (!this._lightOnControllers) {\n                  this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), this.getScene());\n                }\n                const activateLightOnSubMeshes = function (mesh, light) {\n                  const children = mesh.getChildren();\n                  if (children && children.length !== 0) {\n                    children.forEach(mesh => {\n                      light.includedOnlyMeshes.push(mesh);\n                      activateLightOnSubMeshes(mesh, light);\n                    });\n                  }\n                };\n                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\n                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);\n              }\n            });\n          }\n        }\n        webVrController.attachToPoseControlledCamera(this);\n        // since this is async - sanity check. Is the controller already stored?\n        if (this.controllers.indexOf(webVrController) === -1) {\n          //add to the controllers array\n          this.controllers.push(webVrController);\n          // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\n          // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\n          // So we're overriding setting left & right manually to be sure\n          let firstViveWandDetected = false;\n          for (let i = 0; i < this.controllers.length; i++) {\n            if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\n              if (!firstViveWandDetected) {\n                firstViveWandDetected = true;\n                this.controllers[i].hand = \"left\";\n              } else {\n                this.controllers[i].hand = \"right\";\n              }\n            }\n          }\n          //did we find enough controllers? Great! let the developer know.\n          if (this.controllers.length >= 2) {\n            this.onControllersAttachedObservable.notifyObservers(this.controllers);\n          }\n        }\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["Observable","FreeCamera","Camera","Quaternion","Matrix","Vector3","Gamepad","PoseEnabledControllerType","Node","HemisphericLight","Logger","VRMultiviewToSingleviewPostProcess","Tools","setWebVRRigMode","AddNodeConstructor","name","scene","WebVRFreeCamera","Zero","constructor","position","_webVROptions","Identity","undefined","bind","vrDisplay","getEngine","getVRDevice","isPresenting","detachControl","One","_cache","defaultHeight","_defaultHeight","y","minZ","arguments","length","trackPosition","controllerMeshes","defaultLightingOnControllers","rotationQuaternion","positionScale","deviceScaleFactor","engine","_onVREnabled","success","initControllers","onVRRequestPresentComplete","add","initWebVR","event","_vrDevice","setCameraRigMode","RIG_MODE_WEBVR","parentCamera","frameData","_frameData","specs","_specsVersion","_attached","enableVR","VRFrameData","useMultiview","getScene","getCaps","multiview","Warn","_useMultiviewToSingleView","_rigPostProcess","onBeforeCameraRenderObservable","camera","parent","rigParenting","_descendants","getDescendants","n","isController","controllers","some","controller","_mesh","isRigCamera","_rigCameras","indexOf","forEach","node","onAfterCameraRenderObservable","deviceDistanceToRoomGround","_standingMatrix","getTranslationToRef","_workingVector","_deviceRoomPosition","useStandingMatrix","callback","bool","initWebVRAsync","then","result","stageParameters","sittingToStandingTransform","FromFloat32ArrayToRefScaled","useRightHandedSystem","toggleModelMatrixHandInPlace","useStandingMatrixAsync","Promise","res","supported","dispose","_detachIfAttached","removeCallback","_updateCacheWhenTrackingDisabledObserver","_scene","onBeforeRenderObservable","remove","getControllerByName","gp","hand","leftController","_leftController","rightController","_rightController","getForwardRay","leftCamera","getWorldMatrix","globalPosition","_checkInputs","getFrameData","updateFromDevice","pose","poseData","orientation","rawPose","_deviceRoomRotationQuaternion","copyFromFloats","z","w","_poseSet","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","ForceAttachControlToAlwaysPreventDefault","hostWindow","getHostWindow","addEventListener","gamepadManager","onGamepadConnectedObservable","_onGamepadConnectedObserver","onGamepadDisconnectedObservable","_onGamepadDisconnectedObserver","disableVR","window","removeEventListener","getClassName","resetToCurrentRotation","resetPose","_updateRigCameras","camLeft","camRight","copyFrom","_correctPositionIfNotTrackPosition","matrix","isViewMatrix","TranslationToRef","_tmpMatrix","invert","multiplyToRef","_updateCache","ignoreParentClass","equals","_updateCacheCalled","update","toRotationMatrix","_workingMatrix","TransformCoordinatesToRef","devicePosition","subtractToRef","ComposeToRef","_oneVector","_deviceToWorld","addInPlace","subtractInPlace","setTranslation","invertToRef","_worldToDevice","_computeDevicePosition","FromQuaternionToRef","FromRotationMatrixToRef","deviceRotationQuaternion","onPoseUpdatedFromDeviceObservable","notifyObservers","_getViewMatrix","_getWebVRViewMatrix","_cameraRigParams","viewArray","leftViewMatrix","rightViewMatrix","FromArrayToRef","_webvrViewMatrix","getRotationMatrixToRef","_cameraRotationMatrix","_referencePoint","_transformedReferencePoint","addToRef","_currentTarget","multiplyAtIndex","_globalPosition","_markSyncedWithParent","_getWebVRProjectionMatrix","depthNear","depthFar","maxZ","projectionArray","leftProjectionMatrix","rightProjectionMatrix","_projectionMatrix","toggleProjectionMatrixHandInPlace","manager","gamepad","type","POSE_ENABLED","webVrController","defaultModel","setEnabled","controllerIndex","splice","_disableTrackPosition","initControllerMesh","loadedMesh","scaling","scaleInPlace","onControllerMeshLoadedObservable","_lightOnControllers","activateLightOnSubMeshes","mesh","light","children","getChildren","includedOnlyMeshes","push","attachToPoseControlledCamera","firstViveWandDetected","i","controllerType","VIVE","onControllersAttachedObservable"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/VR/webVRCamera.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { TargetCamera } from \"../../Cameras/targetCamera\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Quaternion, Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Gamepad } from \"../../Gamepads/gamepad\";\r\nimport { PoseEnabledControllerType } from \"../../Gamepads/Controllers/poseEnabledController\";\r\nimport type { WebVRController } from \"../../Gamepads/Controllers/webVRController\";\r\nimport type { IDisplayChangedEventArgs } from \"../../Engines/engine\";\r\nimport { Node } from \"../../node\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { HemisphericLight } from \"../../Lights/hemisphericLight\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VRMultiviewToSingleviewPostProcess } from \"../../PostProcesses/vrMultiviewToSingleviewPostProcess\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { setWebVRRigMode } from \"../RigModes/webVRRigMode\";\r\n\r\n// Side effect import to add webvr support to engine\r\nimport \"../../Engines/Extensions/engine.webVR\";\r\n\r\nNode.AddNodeConstructor(\"WebVRFreeCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"WebVRGamepadCamera\", (name, scene) => {\r\n    return () => new WebVRFreeCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose\r\n * IMPORTANT!! The data is right-hand data.\r\n * @export\r\n * @interface DevicePose\r\n */\r\nexport interface DevicePose {\r\n    /**\r\n     * The position of the device, values in array are [x,y,z].\r\n     */\r\n    readonly position: Nullable<Float32Array>;\r\n    /**\r\n     * The linearVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The linearAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly linearAcceleration: Nullable<Float32Array>;\r\n\r\n    /**\r\n     * The orientation of the device in a quaternion array, values in array are [x,y,z,w].\r\n     */\r\n    readonly orientation: Nullable<Float32Array>;\r\n    /**\r\n     * The angularVelocity of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularVelocity: Nullable<Float32Array>;\r\n    /**\r\n     * The angularAcceleration of the device, values in array are [x,y,z].\r\n     */\r\n    readonly angularAcceleration: Nullable<Float32Array>;\r\n}\r\n\r\n/**\r\n * Interface representing a pose controlled object in Babylon.\r\n * A pose controlled object has both regular pose values as well as pose values\r\n * from an external device such as a VR head mounted display\r\n */\r\nexport interface PoseControlled {\r\n    /**\r\n     * The position of the object in babylon space.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * The rotation quaternion of the object in babylon space.\r\n     */\r\n    rotationQuaternion: Quaternion;\r\n    /**\r\n     * The position of the device in babylon space.\r\n     */\r\n    devicePosition?: Vector3;\r\n    /**\r\n     * The rotation quaternion of the device in babylon space.\r\n     */\r\n    deviceRotationQuaternion: Quaternion;\r\n    /**\r\n     * The raw pose coming from the device.\r\n     */\r\n    rawPose: Nullable<DevicePose>;\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    deviceScaleFactor: number;\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData the pose data to update the object with\r\n     */\r\n    updateFromDevice(poseData: DevicePose): void;\r\n}\r\n\r\n/**\r\n * Set of options to customize the webVRCamera\r\n */\r\nexport interface WebVROptions {\r\n    /**\r\n     * Sets if the webVR camera should be tracked to the vrDevice. (default: true)\r\n     */\r\n    trackPosition?: boolean;\r\n    /**\r\n     * Sets the scale of the vrDevice in babylon space. (default: 1)\r\n     */\r\n    positionScale?: number;\r\n    /**\r\n     * If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)\r\n     */\r\n    displayName?: string;\r\n    /**\r\n     * Should the native controller meshes be initialized. (default: true)\r\n     */\r\n    controllerMeshes?: boolean;\r\n    /**\r\n     * Creating a default HemiLight only on controllers. (default: true)\r\n     */\r\n    defaultLightingOnControllers?: boolean;\r\n    /**\r\n     * If you don't want to use the default VR button of the helper. (default: false)\r\n     */\r\n    useCustomVRButton?: boolean;\r\n\r\n    /**\r\n     * If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)\r\n     */\r\n    customVRButton?: HTMLButtonElement;\r\n\r\n    /**\r\n     * To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)\r\n     */\r\n    rayLength?: number;\r\n\r\n    /**\r\n     * To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)\r\n     */\r\n    defaultHeight?: number;\r\n\r\n    /**\r\n     * If multiview should be used if available (default: false)\r\n     */\r\n    useMultiview?: boolean;\r\n}\r\n\r\n/**\r\n * This represents a WebVR camera.\r\n * The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.\r\n * @deprecated Use WebXR instead - https://doc.babylonjs.com/features/featuresDeepDive/webXR\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/cameras/webVRCamera\r\n */\r\nexport class WebVRFreeCamera extends FreeCamera implements PoseControlled {\r\n    /**\r\n     * @internal\r\n     * The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay\r\n     */\r\n    public _vrDevice: any = null;\r\n    /**\r\n     * The rawPose of the vrDevice.\r\n     */\r\n    public rawPose: Nullable<DevicePose> = null;\r\n    private _onVREnabled: (success: boolean) => void;\r\n    private _specsVersion: string = \"1.1\";\r\n    private _attached: boolean = false;\r\n\r\n    private _frameData: any;\r\n\r\n    protected _descendants: Array<Node> = [];\r\n\r\n    // Represents device position and rotation in room space. Should only be used to help calculate babylon space values\r\n    private _deviceRoomPosition = Vector3.Zero();\r\n    /** @internal */\r\n    public _deviceRoomRotationQuaternion = Quaternion.Identity();\r\n\r\n    private _standingMatrix: Nullable<Matrix> = null;\r\n\r\n    /**\r\n     * Represents device position in babylon space.\r\n     */\r\n    public devicePosition = Vector3.Zero();\r\n    /**\r\n     * Represents device rotation in babylon space.\r\n     */\r\n    public deviceRotationQuaternion = Quaternion.Identity();\r\n\r\n    /**\r\n     * The scale of the device to be used when translating from device space to babylon space.\r\n     */\r\n    public deviceScaleFactor: number = 1;\r\n\r\n    private _deviceToWorld = Matrix.Identity();\r\n    private _worldToDevice = Matrix.Identity();\r\n\r\n    /**\r\n     * References to the webVR controllers for the vrDevice.\r\n     */\r\n    public controllers: Array<WebVRController> = [];\r\n    /**\r\n     * Emits an event when a controller is attached.\r\n     */\r\n    public onControllersAttachedObservable = new Observable<Array<WebVRController>>();\r\n    /**\r\n     * Emits an event when a controller's mesh has been loaded;\r\n     */\r\n    public onControllerMeshLoadedObservable = new Observable<WebVRController>();\r\n    /**\r\n     * Emits an event when the HMD's pose has been updated.\r\n     */\r\n    public onPoseUpdatedFromDeviceObservable = new Observable<any>();\r\n    private _poseSet = false;\r\n    /**\r\n     * If the rig cameras be used as parent instead of this camera.\r\n     */\r\n    public rigParenting: boolean = true;\r\n\r\n    private _lightOnControllers: HemisphericLight;\r\n\r\n    private _defaultHeight?: number = undefined;\r\n\r\n    /**\r\n     * Instantiates a WebVRFreeCamera.\r\n     * @param name The name of the WebVRFreeCamera\r\n     * @param position The starting anchor position for the camera\r\n     * @param scene The scene the camera belongs to\r\n     * @param _webVROptions a set of customizable options for the webVRCamera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, private _webVROptions: WebVROptions = {}) {\r\n        super(name, position, scene);\r\n        this._cache.position = Vector3.Zero();\r\n        if (_webVROptions.defaultHeight) {\r\n            this._defaultHeight = _webVROptions.defaultHeight;\r\n            this.position.y = this._defaultHeight;\r\n        }\r\n\r\n        this.minZ = 0.1;\r\n\r\n        //legacy support - the compensation boolean was removed.\r\n        if (arguments.length === 5) {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            this._webVROptions = arguments[4];\r\n        }\r\n\r\n        // default webVR options\r\n        if (this._webVROptions.trackPosition == undefined) {\r\n            this._webVROptions.trackPosition = true;\r\n        }\r\n        if (this._webVROptions.controllerMeshes == undefined) {\r\n            this._webVROptions.controllerMeshes = true;\r\n        }\r\n        if (this._webVROptions.defaultLightingOnControllers == undefined) {\r\n            this._webVROptions.defaultLightingOnControllers = true;\r\n        }\r\n\r\n        this.rotationQuaternion = new Quaternion();\r\n\r\n        if (this._webVROptions && this._webVROptions.positionScale) {\r\n            this.deviceScaleFactor = this._webVROptions.positionScale;\r\n        }\r\n\r\n        //enable VR\r\n        const engine = this.getEngine();\r\n        this._onVREnabled = (success: boolean) => {\r\n            if (success) {\r\n                this.initControllers();\r\n            }\r\n        };\r\n        engine.onVRRequestPresentComplete.add(this._onVREnabled);\r\n        engine.initWebVR().add((event: IDisplayChangedEventArgs) => {\r\n            if (!event.vrDisplay || this._vrDevice === event.vrDisplay) {\r\n                return;\r\n            }\r\n\r\n            this._vrDevice = event.vrDisplay;\r\n\r\n            //reset the rig parameters.\r\n            this.setCameraRigMode(Camera.RIG_MODE_WEBVR, { parentCamera: this, vrDisplay: this._vrDevice, frameData: this._frameData, specs: this._specsVersion });\r\n\r\n            if (this._attached) {\r\n                this.getEngine().enableVR(this._webVROptions);\r\n            }\r\n        });\r\n\r\n        if (typeof VRFrameData !== \"undefined\") {\r\n            this._frameData = new VRFrameData();\r\n        }\r\n\r\n        if (_webVROptions.useMultiview) {\r\n            if (!this.getScene().getEngine().getCaps().multiview) {\r\n                Logger.Warn(\"Multiview is not supported, falling back to standard rendering\");\r\n                this._useMultiviewToSingleView = false;\r\n            } else {\r\n                this._useMultiviewToSingleView = true;\r\n                this._rigPostProcess = new VRMultiviewToSingleviewPostProcess(\"VRMultiviewToSingleview\", this, 1.0);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The idea behind the following lines:\r\n         * objects that have the camera as parent should actually have the rig cameras as a parent.\r\n         * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\r\n         * the second will not show it correctly.\r\n         *\r\n         * To solve this - each object that has the camera as parent will be added to a protected array.\r\n         * When the rig camera renders, it will take this array and set all of those to be its children.\r\n         * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\r\n         * Amazing!\r\n         */\r\n        this.getScene().onBeforeCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants = this.getDescendants(true, (n) => {\r\n                    // don't take the cameras or the controllers!\r\n                    const isController = this.controllers.some((controller) => {\r\n                        return controller._mesh === n;\r\n                    });\r\n                    const isRigCamera = this._rigCameras.indexOf(<Camera>n) !== -1;\r\n                    return !isController && !isRigCamera;\r\n                });\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = camera;\r\n                });\r\n            }\r\n        });\r\n\r\n        this.getScene().onAfterCameraRenderObservable.add((camera) => {\r\n            if (camera.parent === this && this.rigParenting) {\r\n                this._descendants.forEach((node) => {\r\n                    node.parent = this;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    protected _setRigMode = setWebVRRigMode.bind(null, this);\r\n\r\n    /**\r\n     * Gets the device distance from the ground in meters.\r\n     * @returns the distance in meters from the vrDevice to ground in device space. If standing matrix is not supported for the vrDevice 0 is returned.\r\n     */\r\n    public deviceDistanceToRoomGround(): number {\r\n        if (this._standingMatrix) {\r\n            // Add standing matrix offset to get real offset from ground in room\r\n            this._standingMatrix.getTranslationToRef(this._workingVector);\r\n            return this._deviceRoomPosition.y + this._workingVector.y;\r\n        }\r\n        //If VRDisplay does not inform stage parameters and no default height is set we fallback to zero.\r\n        return this._defaultHeight || 0;\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @param callback will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public useStandingMatrix(callback = (bool: boolean) => {}) {\r\n        // Use standing matrix if available\r\n        this.getEngine()\r\n            .initWebVRAsync()\r\n            .then((result) => {\r\n                if (!result.vrDisplay || !result.vrDisplay.stageParameters || !result.vrDisplay.stageParameters.sittingToStandingTransform || !this._webVROptions.trackPosition) {\r\n                    callback(false);\r\n                } else {\r\n                    this._standingMatrix = new Matrix();\r\n                    Matrix.FromFloat32ArrayToRefScaled(result.vrDisplay.stageParameters.sittingToStandingTransform, 0, 1, this._standingMatrix);\r\n                    if (!this.getScene().useRightHandedSystem) {\r\n                        if (this._standingMatrix) {\r\n                            this._standingMatrix.toggleModelMatrixHandInPlace();\r\n                        }\r\n                    }\r\n                    callback(true);\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.\r\n     * @returns A promise with a boolean set to if the standing matrix is supported.\r\n     */\r\n    public useStandingMatrixAsync(): Promise<boolean> {\r\n        return new Promise((res) => {\r\n            this.useStandingMatrix((supported) => {\r\n                res(supported);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the camera\r\n     */\r\n    public dispose(): void {\r\n        this._detachIfAttached();\r\n        this.getEngine().onVRRequestPresentComplete.removeCallback(this._onVREnabled);\r\n        if (this._updateCacheWhenTrackingDisabledObserver) {\r\n            this._scene.onBeforeRenderObservable.remove(this._updateCacheWhenTrackingDisabledObserver);\r\n        }\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets a vrController by name.\r\n     * @param name The name of the controller to retrieve\r\n     * @returns the controller matching the name specified or null if not found\r\n     */\r\n    public getControllerByName(name: string): Nullable<WebVRController> {\r\n        for (const gp of this.controllers) {\r\n            if (gp.hand === name) {\r\n                return gp;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _leftController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users left hand.\r\n     */\r\n    public get leftController(): Nullable<WebVRController> {\r\n        if (!this._leftController) {\r\n            this._leftController = this.getControllerByName(\"left\");\r\n        }\r\n\r\n        return this._leftController;\r\n    }\r\n\r\n    private _rightController: Nullable<WebVRController>;\r\n    /**\r\n     * The controller corresponding to the users right hand.\r\n     */\r\n    public get rightController(): Nullable<WebVRController> {\r\n        if (!this._rightController) {\r\n            this._rightController = this.getControllerByName(\"right\");\r\n        }\r\n\r\n        return this._rightController;\r\n    }\r\n\r\n    /**\r\n     * Casts a ray forward from the vrCamera's gaze.\r\n     * @param length Length of the ray (default: 100)\r\n     * @returns the ray corresponding to the gaze\r\n     */\r\n    public getForwardRay(length = 100): Ray {\r\n        if (this.leftCamera) {\r\n            // Use left eye to avoid computation to compute center on every call\r\n            return super.getForwardRay(length, this.leftCamera.getWorldMatrix(), this.leftCamera.globalPosition); // Need the actual rendered camera\r\n        } else {\r\n            return super.getForwardRay(length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the camera based on device's frame data\r\n     */\r\n    public _checkInputs(): void {\r\n        if (this._vrDevice && this._vrDevice.isPresenting) {\r\n            this._vrDevice.getFrameData(this._frameData);\r\n\r\n            this.updateFromDevice(this._frameData.pose);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Updates the poseControlled values based on the input device pose.\r\n     * @param poseData Pose coming from the device\r\n     */\r\n    updateFromDevice(poseData: DevicePose) {\r\n        if (poseData && poseData.orientation && poseData.orientation.length === 4) {\r\n            this.rawPose = poseData;\r\n            this._deviceRoomRotationQuaternion.copyFromFloats(poseData.orientation[0], poseData.orientation[1], -poseData.orientation[2], -poseData.orientation[3]);\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                this._deviceRoomRotationQuaternion.z *= -1;\r\n                this._deviceRoomRotationQuaternion.w *= -1;\r\n            }\r\n            if (this._webVROptions.trackPosition && this.rawPose.position) {\r\n                this._deviceRoomPosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\r\n                if (this.getScene().useRightHandedSystem) {\r\n                    this._deviceRoomPosition.z *= -1;\r\n                }\r\n            }\r\n            this._poseSet = true;\r\n        }\r\n    }\r\n\r\n    private _detachIfAttached = () => {\r\n        const vrDisplay = this.getEngine().getVRDevice();\r\n        if (vrDisplay && !vrDisplay.isPresenting) {\r\n            this.detachControl();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * WebVR's attach control will start broadcasting frames to the device.\r\n     * Note that in certain browsers (chrome for example) this function must be called\r\n     * within a user-interaction callback. Example:\r\n     * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\r\n     *\r\n     * @param noPreventDefault prevent the default html element operation when attaching the vrDevice\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        super.attachControl(noPreventDefault);\r\n        this._attached = true;\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n\r\n        if (this._vrDevice) {\r\n            this.getEngine().enableVR(this._webVROptions);\r\n        }\r\n\r\n        const hostWindow = this._scene.getEngine().getHostWindow();\r\n\r\n        if (hostWindow) {\r\n            hostWindow.addEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver);\r\n        this.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver);\r\n\r\n        super.detachControl();\r\n        this._attached = false;\r\n        this.getEngine().disableVR();\r\n        window.removeEventListener(\"vrdisplaypresentchange\", this._detachIfAttached);\r\n    }\r\n\r\n    /**\r\n     * @returns the name of this class\r\n     */\r\n    public getClassName(): string {\r\n        return \"WebVRFreeCamera\";\r\n    }\r\n\r\n    /**\r\n     * Calls resetPose on the vrDisplay\r\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose\r\n     */\r\n    public resetToCurrentRotation() {\r\n        //uses the vrDisplay's \"resetPose()\".\r\n        //pitch and roll won't be affected.\r\n        this._vrDevice.resetPose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the rig cameras (left and right eye)\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n        camLeft.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n        camRight.rotationQuaternion.copyFrom(this._deviceRoomRotationQuaternion);\r\n\r\n        camLeft.position.copyFrom(this._deviceRoomPosition);\r\n        camRight.position.copyFrom(this._deviceRoomPosition);\r\n    }\r\n\r\n    private _workingVector = Vector3.Zero();\r\n    private _oneVector = Vector3.One();\r\n    private _workingMatrix = Matrix.Identity();\r\n\r\n    private _updateCacheCalled: boolean;\r\n\r\n    // Remove translation from 6dof headset if trackposition is set to false\r\n    private _correctPositionIfNotTrackPosition(matrix: Matrix, isViewMatrix = false) {\r\n        if (this.rawPose && this.rawPose.position && !this._webVROptions.trackPosition) {\r\n            Matrix.TranslationToRef(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2], this._tmpMatrix);\r\n            if (!isViewMatrix) {\r\n                this._tmpMatrix.invert();\r\n            }\r\n            this._tmpMatrix.multiplyToRef(matrix, matrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Updates the cached values of the camera\r\n     * @param ignoreParentClass ignores updating the parent class's cache (default: false)\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!this.rotationQuaternion.equals(this._cache.rotationQuaternion) || !this.position.equals(this._cache.position)) {\r\n            // Update to ensure devicePosition is up to date with most recent _deviceRoomPosition\r\n            if (!this._updateCacheCalled) {\r\n                // make sure it is only called once per loop. this.update() might cause an infinite loop.\r\n                this._updateCacheCalled = true;\r\n                this.update();\r\n            }\r\n\r\n            // Set working vector to the device position in room space rotated by the new rotation\r\n            this.rotationQuaternion.toRotationMatrix(this._workingMatrix);\r\n            Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._workingMatrix, this._workingVector);\r\n\r\n            // Subtract this vector from the current device position in world to get the translation for the device world matrix\r\n            this.devicePosition.subtractToRef(this._workingVector, this._workingVector);\r\n            Matrix.ComposeToRef(this._oneVector, this.rotationQuaternion, this._workingVector, this._deviceToWorld);\r\n\r\n            // Add translation from anchor position\r\n            this._deviceToWorld.getTranslationToRef(this._workingVector);\r\n            this._workingVector.addInPlace(this.position);\r\n            this._workingVector.subtractInPlace(this._cache.position);\r\n            this._deviceToWorld.setTranslation(this._workingVector);\r\n\r\n            // Set an inverted matrix to be used when updating the camera\r\n            this._deviceToWorld.invertToRef(this._worldToDevice);\r\n\r\n            // Update the gamepad to ensure the mesh is updated on the same frame as camera\r\n            this.controllers.forEach((controller) => {\r\n                controller._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(controller._deviceToWorld);\r\n                controller.update();\r\n            });\r\n        }\r\n\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n        this._updateCacheCalled = false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Get current device position in babylon world\r\n     */\r\n    public _computeDevicePosition() {\r\n        Vector3.TransformCoordinatesToRef(this._deviceRoomPosition, this._deviceToWorld, this.devicePosition);\r\n    }\r\n\r\n    /**\r\n     * Updates the current device position and rotation in the babylon world\r\n     */\r\n    public update() {\r\n        this._computeDevicePosition();\r\n\r\n        // Get current device rotation in babylon world\r\n        Matrix.FromQuaternionToRef(this._deviceRoomRotationQuaternion, this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(this._deviceToWorld, this._workingMatrix);\r\n        Quaternion.FromRotationMatrixToRef(this._workingMatrix, this.deviceRotationQuaternion);\r\n\r\n        if (this._poseSet) {\r\n            this.onPoseUpdatedFromDeviceObservable.notifyObservers(null);\r\n        }\r\n        super.update();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)\r\n     * @returns an identity matrix\r\n     */\r\n    public _getViewMatrix(): Matrix {\r\n        return Matrix.Identity();\r\n    }\r\n\r\n    private _tmpMatrix = new Matrix();\r\n    /**\r\n     * This function is called by the two RIG cameras.\r\n     * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\r\n     * @internal\r\n     */\r\n    public _getWebVRViewMatrix(): Matrix {\r\n        // Update the parent camera prior to using a child camera to avoid desynchronization\r\n        const parentCamera: WebVRFreeCamera = this._cameraRigParams[\"parentCamera\"];\r\n        parentCamera._updateCache();\r\n\r\n        //WebVR 1.1\r\n        const viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\r\n\r\n        Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\r\n\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._webvrViewMatrix.toggleModelMatrixHandInPlace();\r\n        }\r\n\r\n        // update the camera rotation matrix\r\n        this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n\r\n        // should the view matrix be updated with scale and position offset?\r\n        if (parentCamera.deviceScaleFactor !== 1) {\r\n            this._webvrViewMatrix.invert();\r\n            // scale the position, if set\r\n            if (parentCamera.deviceScaleFactor) {\r\n                this._webvrViewMatrix.multiplyAtIndex(12, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(13, parentCamera.deviceScaleFactor);\r\n                this._webvrViewMatrix.multiplyAtIndex(14, parentCamera.deviceScaleFactor);\r\n            }\r\n\r\n            this._webvrViewMatrix.invert();\r\n        }\r\n\r\n        // Remove translation from 6dof headset if trackposition is set to false\r\n        parentCamera._correctPositionIfNotTrackPosition(this._webvrViewMatrix, true);\r\n\r\n        parentCamera._worldToDevice.multiplyToRef(this._webvrViewMatrix, this._webvrViewMatrix);\r\n\r\n        // Compute global position\r\n        this._workingMatrix = this._workingMatrix || Matrix.Identity();\r\n        this._webvrViewMatrix.invertToRef(this._workingMatrix);\r\n        this._workingMatrix.multiplyToRef(parentCamera.getWorldMatrix(), this._workingMatrix);\r\n        this._workingMatrix.getTranslationToRef(this._globalPosition);\r\n        this._markSyncedWithParent();\r\n\r\n        return this._webvrViewMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getWebVRProjectionMatrix(): Matrix {\r\n        const parentCamera = <WebVRFreeCamera>this.parent;\r\n\r\n        parentCamera._vrDevice.depthNear = parentCamera.minZ;\r\n        parentCamera._vrDevice.depthFar = parentCamera.maxZ;\r\n\r\n        const projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\r\n        Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\r\n\r\n        //babylon compatible matrix\r\n        if (!this.getScene().useRightHandedSystem) {\r\n            this._projectionMatrix.toggleProjectionMatrixHandInPlace();\r\n        }\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n\r\n    private _onGamepadConnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _onGamepadDisconnectedObserver: Nullable<Observer<Gamepad>>;\r\n    private _updateCacheWhenTrackingDisabledObserver: Nullable<Observer<Scene>>;\r\n    /**\r\n     * Initializes the controllers and their meshes\r\n     */\r\n    public initControllers() {\r\n        this.controllers.length = 0;\r\n\r\n        const manager = this.getScene().gamepadManager;\r\n        this._onGamepadDisconnectedObserver = manager.onGamepadDisconnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                const webVrController: WebVRController = <WebVRController>gamepad;\r\n\r\n                if (webVrController.defaultModel) {\r\n                    webVrController.defaultModel.setEnabled(false);\r\n                }\r\n\r\n                if (webVrController.hand === \"right\") {\r\n                    this._rightController = null;\r\n                }\r\n                if (webVrController.hand === \"left\") {\r\n                    this._leftController = null;\r\n                }\r\n                const controllerIndex = this.controllers.indexOf(webVrController);\r\n                if (controllerIndex !== -1) {\r\n                    this.controllers.splice(controllerIndex, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this._onGamepadConnectedObserver = manager.onGamepadConnectedObservable.add((gamepad) => {\r\n            if (gamepad.type === Gamepad.POSE_ENABLED) {\r\n                const webVrController: WebVRController = <WebVRController>gamepad;\r\n                if (!this._webVROptions.trackPosition) {\r\n                    webVrController._disableTrackPosition(new Vector3(webVrController.hand == \"left\" ? -0.15 : 0.15, -0.5, 0.25));\r\n                    // Cache must be updated before rendering controllers to avoid them being one frame behind\r\n                    if (!this._updateCacheWhenTrackingDisabledObserver) {\r\n                        this._updateCacheWhenTrackingDisabledObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n                            this._updateCache();\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.deviceScaleFactor = this.deviceScaleFactor;\r\n                webVrController._deviceToWorld.copyFrom(this._deviceToWorld);\r\n                this._correctPositionIfNotTrackPosition(webVrController._deviceToWorld);\r\n\r\n                if (this._webVROptions.controllerMeshes) {\r\n                    if (webVrController.defaultModel) {\r\n                        webVrController.defaultModel.setEnabled(true);\r\n                    } else {\r\n                        // Load the meshes\r\n                        webVrController.initControllerMesh(this.getScene(), (loadedMesh) => {\r\n                            loadedMesh.scaling.scaleInPlace(this.deviceScaleFactor);\r\n                            this.onControllerMeshLoadedObservable.notifyObservers(webVrController);\r\n                            if (this._webVROptions.defaultLightingOnControllers) {\r\n                                if (!this._lightOnControllers) {\r\n                                    this._lightOnControllers = new HemisphericLight(\"vrControllersLight\", new Vector3(0, 1, 0), this.getScene());\r\n                                }\r\n                                const activateLightOnSubMeshes = function (mesh: AbstractMesh, light: HemisphericLight) {\r\n                                    const children = mesh.getChildren();\r\n                                    if (children && children.length !== 0) {\r\n                                        children.forEach((mesh) => {\r\n                                            light.includedOnlyMeshes.push(<AbstractMesh>mesh);\r\n                                            activateLightOnSubMeshes(<AbstractMesh>mesh, light);\r\n                                        });\r\n                                    }\r\n                                };\r\n                                this._lightOnControllers.includedOnlyMeshes.push(loadedMesh);\r\n                                activateLightOnSubMeshes(loadedMesh, this._lightOnControllers);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                webVrController.attachToPoseControlledCamera(this);\r\n\r\n                // since this is async - sanity check. Is the controller already stored?\r\n                if (this.controllers.indexOf(webVrController) === -1) {\r\n                    //add to the controllers array\r\n                    this.controllers.push(webVrController);\r\n\r\n                    // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\r\n                    // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\r\n                    // So we're overriding setting left & right manually to be sure\r\n                    let firstViveWandDetected = false;\r\n\r\n                    for (let i = 0; i < this.controllers.length; i++) {\r\n                        if (this.controllers[i].controllerType === PoseEnabledControllerType.VIVE) {\r\n                            if (!firstViveWandDetected) {\r\n                                firstViveWandDetected = true;\r\n                                this.controllers[i].hand = \"left\";\r\n                            } else {\r\n                                this.controllers[i].hand = \"right\";\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //did we find enough controllers? Great! let the developer know.\r\n                    if (this.controllers.length >= 2) {\r\n                        this.onControllersAttachedObservable.notifyObservers(this.controllers);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}