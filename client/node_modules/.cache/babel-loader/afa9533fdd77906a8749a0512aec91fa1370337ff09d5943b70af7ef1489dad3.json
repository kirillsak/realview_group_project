{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\n\n/**\n * Unique ID when we import meshes from Babylon to CSG\n */\nlet currentCSGMeshId = 0;\n/**\n * Represents a vertex of a polygon. Use your own vertex class instead of this\n * one to provide additional features like texture coordinates and vertex\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\n * is not used anywhere else.\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\n */\nclass Vertex {\n  /**\n   * Initializes the vertex\n   * @param pos The position of the vertex\n   * @param normal The normal of the vertex\n   * @param uv The texture coordinate of the vertex\n   * @param vertColor The RGBA color of the vertex\n   */\n  constructor(\n  /**\n   * The position of the vertex\n   */\n  pos,\n  /**\n   * The normal of the vertex\n   */\n  normal,\n  /**\n   * The texture coordinate of the vertex\n   */\n  uv,\n  /**\n   * The texture coordinate of the vertex\n   */\n  vertColor) {\n    this.pos = pos;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertColor = vertColor;\n  }\n  /**\n   * Make a clone, or deep copy, of the vertex\n   * @returns A new Vertex\n   */\n  clone() {\n    var _a, _b;\n    return new Vertex(this.pos.clone(), this.normal.clone(), (_a = this.uv) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this.vertColor) === null || _b === void 0 ? void 0 : _b.clone());\n  }\n  /**\n   * Invert all orientation-specific data (e.g. vertex normal). Called when the\n   * orientation of a polygon is flipped.\n   */\n  flip() {\n    this.normal = this.normal.scale(-1);\n  }\n  /**\n   * Create a new vertex between this vertex and `other` by linearly\n   * interpolating all properties using a parameter of `t`. Subclasses should\n   * override this to interpolate additional properties.\n   * @param other the vertex to interpolate against\n   * @param t The factor used to linearly interpolate between the vertices\n   */\n  interpolate(other, t) {\n    return new Vertex(Vector3.Lerp(this.pos, other.pos, t), Vector3.Lerp(this.normal, other.normal, t), this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined, this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined);\n  }\n}\n/**\n * Represents a plane in 3D space.\n */\nclass Plane {\n  /**\n   * Initializes the plane\n   * @param normal The normal for the plane\n   * @param w\n   */\n  constructor(normal, w) {\n    this.normal = normal;\n    this.w = w;\n  }\n  /**\n   * Construct a plane from three points\n   * @param a Point a\n   * @param b Point b\n   * @param c Point c\n   */\n  static FromPoints(a, b, c) {\n    const v0 = c.subtract(a);\n    const v1 = b.subtract(a);\n    if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n      return null;\n    }\n    const n = Vector3.Normalize(Vector3.Cross(v0, v1));\n    return new Plane(n, Vector3.Dot(n, a));\n  }\n  /**\n   * Clone, or make a deep copy of the plane\n   * @returns a new Plane\n   */\n  clone() {\n    return new Plane(this.normal.clone(), this.w);\n  }\n  /**\n   * Flip the face of the plane\n   */\n  flip() {\n    this.normal.scaleInPlace(-1);\n    this.w = -this.w;\n  }\n  /**\n   * Split `polygon` by this plane if needed, then put the polygon or polygon\n   * fragments in the appropriate lists. Coplanar polygons go into either\n  `* coplanarFront` or `coplanarBack` depending on their orientation with\n   * respect to this plane. Polygons in front or in back of this plane go into\n   * either `front` or `back`\n   * @param polygon The polygon to be split\n   * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\n   * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\n   * @param front Will contain the polygons in front of the plane\n   * @param back Will contain the polygons begind the plane\n   */\n  splitPolygon(polygon, coplanarFront, coplanarBack, front, back) {\n    const COPLANAR = 0;\n    const FRONT = 1;\n    const BACK = 2;\n    const SPANNING = 3;\n    // Classify each point as well as the entire polygon into one of the above\n    // four classes.\n    let polygonType = 0;\n    const types = [];\n    let i;\n    let t;\n    for (i = 0; i < polygon.vertices.length; i++) {\n      t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n      const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\n      polygonType |= type;\n      types.push(type);\n    }\n    // Put the polygon in the correct list, splitting it when necessary\n    switch (polygonType) {\n      case COPLANAR:\n        (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n        break;\n      case FRONT:\n        front.push(polygon);\n        break;\n      case BACK:\n        back.push(polygon);\n        break;\n      case SPANNING:\n        {\n          const f = [],\n            b = [];\n          for (i = 0; i < polygon.vertices.length; i++) {\n            const j = (i + 1) % polygon.vertices.length;\n            const ti = types[i],\n              tj = types[j];\n            const vi = polygon.vertices[i],\n              vj = polygon.vertices[j];\n            if (ti !== BACK) {\n              f.push(vi);\n            }\n            if (ti !== FRONT) {\n              b.push(ti !== BACK ? vi.clone() : vi);\n            }\n            if ((ti | tj) === SPANNING) {\n              t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n              const v = vi.interpolate(vj, t);\n              f.push(v);\n              b.push(v.clone());\n            }\n          }\n          let poly;\n          if (f.length >= 3) {\n            poly = new Polygon(f, polygon.shared);\n            if (poly.plane) {\n              front.push(poly);\n            }\n          }\n          if (b.length >= 3) {\n            poly = new Polygon(b, polygon.shared);\n            if (poly.plane) {\n              back.push(poly);\n            }\n          }\n          break;\n        }\n    }\n  }\n}\n/**\n * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n * point is on the plane\n */\nPlane.EPSILON = 1e-5;\n/**\n * Represents a convex polygon. The vertices used to initialize a polygon must\n * be coplanar and form a convex loop.\n *\n * Each convex polygon has a `shared` property, which is shared between all\n * polygons that are clones of each other or were split from the same polygon.\n * This can be used to define per-polygon properties (such as surface color)\n */\nclass Polygon {\n  /**\n   * Initializes the polygon\n   * @param vertices The vertices of the polygon\n   * @param shared The properties shared across all polygons\n   */\n  constructor(vertices, shared) {\n    this.vertices = vertices;\n    this.shared = shared;\n    this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n  }\n  /**\n   * Clones, or makes a deep copy, or the polygon\n   */\n  clone() {\n    const vertices = this.vertices.map(v => v.clone());\n    return new Polygon(vertices, this.shared);\n  }\n  /**\n   * Flips the faces of the polygon\n   */\n  flip() {\n    this.vertices.reverse().map(v => {\n      v.flip();\n    });\n    this.plane.flip();\n  }\n}\n/**\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n * by picking a polygon to split along. That polygon (and all other coplanar\n * polygons) are added directly to that node and the other polygons are added to\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\n * no distinction between internal and leaf nodes\n */\nclass Node {\n  /**\n   * Initializes the node\n   * @param polygons A collection of polygons held in the node\n   */\n  constructor(polygons) {\n    this._plane = null;\n    this._front = null;\n    this._back = null;\n    this._polygons = new Array();\n    if (polygons) {\n      this.build(polygons);\n    }\n  }\n  /**\n   * Clones, or makes a deep copy, of the node\n   * @returns The cloned node\n   */\n  clone() {\n    const node = new Node();\n    node._plane = this._plane && this._plane.clone();\n    node._front = this._front && this._front.clone();\n    node._back = this._back && this._back.clone();\n    node._polygons = this._polygons.map(p => p.clone());\n    return node;\n  }\n  /**\n   * Convert solid space to empty space and empty space to solid space\n   */\n  invert() {\n    for (let i = 0; i < this._polygons.length; i++) {\n      this._polygons[i].flip();\n    }\n    if (this._plane) {\n      this._plane.flip();\n    }\n    if (this._front) {\n      this._front.invert();\n    }\n    if (this._back) {\n      this._back.invert();\n    }\n    const temp = this._front;\n    this._front = this._back;\n    this._back = temp;\n  }\n  /**\n   * Recursively remove all polygons in `polygons` that are inside this BSP\n   * tree.\n   * @param polygons Polygons to remove from the BSP\n   * @returns Polygons clipped from the BSP\n   */\n  clipPolygons(polygons) {\n    if (!this._plane) {\n      return polygons.slice();\n    }\n    let front = new Array(),\n      back = new Array();\n    for (let i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], front, back, front, back);\n    }\n    if (this._front) {\n      front = this._front.clipPolygons(front);\n    }\n    if (this._back) {\n      back = this._back.clipPolygons(back);\n    } else {\n      back = [];\n    }\n    return front.concat(back);\n  }\n  /**\n   * Remove all polygons in this BSP tree that are inside the other BSP tree\n   * `bsp`.\n   * @param bsp BSP containing polygons to remove from this BSP\n   */\n  clipTo(bsp) {\n    this._polygons = bsp.clipPolygons(this._polygons);\n    if (this._front) {\n      this._front.clipTo(bsp);\n    }\n    if (this._back) {\n      this._back.clipTo(bsp);\n    }\n  }\n  /**\n   * Return a list of all polygons in this BSP tree\n   * @returns List of all polygons in this BSP tree\n   */\n  allPolygons() {\n    let polygons = this._polygons.slice();\n    if (this._front) {\n      polygons = polygons.concat(this._front.allPolygons());\n    }\n    if (this._back) {\n      polygons = polygons.concat(this._back.allPolygons());\n    }\n    return polygons;\n  }\n  /**\n   * Build a BSP tree out of `polygons`. When called on an existing tree, the\n   * new polygons are filtered down to the bottom of the tree and become new\n   * nodes there. Each set of polygons is partitioned using the first polygon\n   * (no heuristic is used to pick a good split)\n   * @param polygons Polygons used to construct the BSP tree\n   */\n  build(polygons) {\n    if (!polygons.length) {\n      return;\n    }\n    if (!this._plane) {\n      this._plane = polygons[0].plane.clone();\n    }\n    const front = new Array(),\n      back = new Array();\n    for (let i = 0; i < polygons.length; i++) {\n      this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\n    }\n    if (front.length) {\n      if (!this._front) {\n        this._front = new Node();\n      }\n      this._front.build(front);\n    }\n    if (back.length) {\n      if (!this._back) {\n        this._back = new Node();\n      }\n      this._back.build(back);\n    }\n  }\n}\n/**\n * Class for building Constructive Solid Geometry\n */\nexport class CSG {\n  constructor() {\n    this._polygons = new Array();\n  }\n  /**\n   * Convert the Mesh to CSG\n   * @param mesh The Mesh to convert to CSG\n   * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\n   * @returns A new CSG from the Mesh\n   */\n  static FromMesh(mesh, absolute = false) {\n    let vertex,\n      normal,\n      uv = undefined,\n      position,\n      vertColor = undefined,\n      polygon,\n      vertices;\n    const polygons = new Array();\n    let matrix,\n      meshPosition,\n      meshRotation,\n      meshRotationQuaternion = null,\n      meshScaling;\n    let invertWinding = false;\n    if (mesh instanceof Mesh) {\n      mesh.computeWorldMatrix(true);\n      matrix = mesh.getWorldMatrix();\n      meshPosition = mesh.position.clone();\n      meshRotation = mesh.rotation.clone();\n      if (mesh.rotationQuaternion) {\n        meshRotationQuaternion = mesh.rotationQuaternion.clone();\n      }\n      meshScaling = mesh.scaling.clone();\n      if (mesh.material && absolute) {\n        invertWinding = mesh.material.sideOrientation === 0;\n      }\n    } else {\n      throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\n    }\n    const indices = mesh.getIndices(),\n      positions = mesh.getVerticesData(VertexBuffer.PositionKind),\n      normals = mesh.getVerticesData(VertexBuffer.NormalKind),\n      uvs = mesh.getVerticesData(VertexBuffer.UVKind),\n      vertColors = mesh.getVerticesData(VertexBuffer.ColorKind);\n    const subMeshes = mesh.subMeshes;\n    for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n      for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n        vertices = [];\n        for (let j = 0; j < 3; j++) {\n          const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\n          const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\n          if (uvs) {\n            uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\n          }\n          if (vertColors) {\n            vertColor = new Color4(vertColors[indices[indexIndices] * 4], vertColors[indices[indexIndices] * 4 + 1], vertColors[indices[indexIndices] * 4 + 2], vertColors[indices[indexIndices] * 4 + 3]);\n          }\n          const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\n          position = Vector3.TransformCoordinates(sourcePosition, matrix);\n          normal = Vector3.TransformNormal(sourceNormal, matrix);\n          vertex = new Vertex(position, normal, uv, vertColor);\n          vertices.push(vertex);\n        }\n        polygon = new Polygon(vertices, {\n          subMeshId: sm,\n          meshId: currentCSGMeshId,\n          materialIndex: subMeshes[sm].materialIndex\n        });\n        // To handle the case of degenerated triangle\n        // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n        if (polygon.plane) {\n          polygons.push(polygon);\n        }\n      }\n    }\n    const csg = CSG._FromPolygons(polygons);\n    csg.matrix = absolute ? Matrix.Identity() : matrix;\n    csg.position = absolute ? Vector3.Zero() : meshPosition;\n    csg.rotation = absolute ? Vector3.Zero() : meshRotation;\n    csg.scaling = absolute ? Vector3.One() : meshScaling;\n    csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\n    currentCSGMeshId++;\n    return csg;\n  }\n  /**\n   * Construct a CSG solid from a list of `CSG.Polygon` instances.\n   * @param polygons Polygons used to construct a CSG solid\n   */\n  static _FromPolygons(polygons) {\n    const csg = new CSG();\n    csg._polygons = polygons;\n    return csg;\n  }\n  /**\n   * Clones, or makes a deep copy, of the CSG\n   * @returns A new CSG\n   */\n  clone() {\n    const csg = new CSG();\n    csg._polygons = this._polygons.map(p => p.clone());\n    csg.copyTransformAttributes(this);\n    return csg;\n  }\n  /**\n   * Unions this CSG with another CSG\n   * @param csg The CSG to union against this CSG\n   * @returns The unioned CSG\n   */\n  union(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Unions this CSG with another CSG in place\n   * @param csg The CSG to union against this CSG\n   */\n  unionInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Subtracts this CSG with another CSG\n   * @param csg The CSG to subtract against this CSG\n   * @returns A new CSG\n   */\n  subtract(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Subtracts this CSG with another CSG in place\n   * @param csg The CSG to subtract against this CSG\n   */\n  subtractInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    b.invert();\n    b.clipTo(a);\n    b.invert();\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Intersect this CSG with another CSG\n   * @param csg The CSG to intersect against this CSG\n   * @returns A new CSG\n   */\n  intersect(csg) {\n    const a = new Node(this.clone()._polygons);\n    const b = new Node(csg.clone()._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n  }\n  /**\n   * Intersects this CSG with another CSG in place\n   * @param csg The CSG to intersect against this CSG\n   */\n  intersectInPlace(csg) {\n    const a = new Node(this._polygons);\n    const b = new Node(csg._polygons);\n    a.invert();\n    b.clipTo(a);\n    b.invert();\n    a.clipTo(b);\n    b.clipTo(a);\n    a.build(b.allPolygons());\n    a.invert();\n    this._polygons = a.allPolygons();\n  }\n  /**\n   * Return a new CSG solid with solid and empty space switched. This solid is\n   * not modified.\n   * @returns A new CSG solid with solid and empty space switched\n   */\n  inverse() {\n    const csg = this.clone();\n    csg.inverseInPlace();\n    return csg;\n  }\n  /**\n   * Inverses the CSG in place\n   */\n  inverseInPlace() {\n    this._polygons.map(p => {\n      p.flip();\n    });\n  }\n  /**\n   * This is used to keep meshes transformations so they can be restored\n   * when we build back a Babylon Mesh\n   * NB : All CSG operations are performed in world coordinates\n   * @param csg The CSG to copy the transform attributes from\n   * @returns This CSG\n   */\n  copyTransformAttributes(csg) {\n    this.matrix = csg.matrix;\n    this.position = csg.position;\n    this.rotation = csg.rotation;\n    this.scaling = csg.scaling;\n    this.rotationQuaternion = csg.rotationQuaternion;\n    return this;\n  }\n  /**\n   * Build Raw mesh from CSG\n   * Coordinates here are in world space\n   * @param name The name of the mesh geometry\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if the submeshes should be kept\n   * @returns A new Mesh\n   */\n  buildMeshGeometry(name, scene, keepSubMeshes) {\n    const matrix = this.matrix.clone();\n    matrix.invert();\n    const mesh = new Mesh(name, scene);\n    const vertices = [];\n    const indices = [];\n    const normals = [];\n    let uvs = null;\n    let vertColors = null;\n    const vertex = Vector3.Zero();\n    const normal = Vector3.Zero();\n    const uv = Vector2.Zero();\n    const vertColor = new Color4(0, 0, 0, 0);\n    const polygons = this._polygons;\n    const polygonIndices = [0, 0, 0];\n    let polygon;\n    const vertice_dict = {};\n    let vertex_idx;\n    let currentIndex = 0;\n    const subMeshDict = {};\n    let subMeshObj;\n    if (keepSubMeshes) {\n      // Sort Polygons, since subMeshes are indices range\n      polygons.sort((a, b) => {\n        if (a.shared.meshId === b.shared.meshId) {\n          return a.shared.subMeshId - b.shared.subMeshId;\n        } else {\n          return a.shared.meshId - b.shared.meshId;\n        }\n      });\n    }\n    for (let i = 0, il = polygons.length; i < il; i++) {\n      polygon = polygons[i];\n      // Building SubMeshes\n      if (!subMeshDict[polygon.shared.meshId]) {\n        subMeshDict[polygon.shared.meshId] = {};\n      }\n      if (!subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n        subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n          indexStart: +Infinity,\n          indexEnd: -Infinity,\n          materialIndex: polygon.shared.materialIndex\n        };\n      }\n      subMeshObj = subMeshDict[polygon.shared.meshId][polygon.shared.subMeshId];\n      for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\n        polygonIndices[0] = 0;\n        polygonIndices[1] = j - 1;\n        polygonIndices[2] = j;\n        for (let k = 0; k < 3; k++) {\n          vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n          normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n          if (polygon.vertices[polygonIndices[k]].uv) {\n            if (!uvs) {\n              uvs = [];\n            }\n            uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n          }\n          if (polygon.vertices[polygonIndices[k]].vertColor) {\n            if (!vertColors) {\n              vertColors = [];\n            }\n            vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor);\n          }\n          const localVertex = Vector3.TransformCoordinates(vertex, matrix);\n          const localNormal = Vector3.TransformNormal(normal, matrix);\n          vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\n          let areUvsDifferent = false;\n          if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\n            areUvsDifferent = true;\n          }\n          let areColorsDifferent = false;\n          if (vertColors && !(vertColors[vertex_idx * 4] === vertColor.r || vertColors[vertex_idx * 4 + 1] === vertColor.g || vertColors[vertex_idx * 4 + 2] === vertColor.b || vertColors[vertex_idx * 4 + 3] === vertColor.a)) {\n            areColorsDifferent = true;\n          }\n          // Check if 2 points can be merged\n          if (!(typeof vertex_idx !== \"undefined\" && normals[vertex_idx * 3] === localNormal.x && normals[vertex_idx * 3 + 1] === localNormal.y && normals[vertex_idx * 3 + 2] === localNormal.z) || areUvsDifferent || areColorsDifferent) {\n            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n            if (uvs) {\n              uvs.push(uv.x, uv.y);\n            }\n            normals.push(normal.x, normal.y, normal.z);\n            if (vertColors) {\n              vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\n            }\n            vertex_idx = vertice_dict[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\n          }\n          indices.push(vertex_idx);\n          subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\n          subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\n          currentIndex++;\n        }\n      }\n    }\n    mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\n    mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n    if (uvs) {\n      mesh.setVerticesData(VertexBuffer.UVKind, uvs);\n    }\n    if (vertColors) {\n      mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\n    }\n    mesh.setIndices(indices, null);\n    if (keepSubMeshes) {\n      // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n      let materialIndexOffset = 0,\n        materialMaxIndex;\n      mesh.subMeshes = new Array();\n      for (const m in subMeshDict) {\n        materialMaxIndex = -1;\n        for (const sm in subMeshDict[m]) {\n          subMeshObj = subMeshDict[m][sm];\n          SubMesh.CreateFromIndices(subMeshObj.materialIndex + materialIndexOffset, subMeshObj.indexStart, subMeshObj.indexEnd - subMeshObj.indexStart + 1, mesh);\n          materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\n        }\n        materialIndexOffset += ++materialMaxIndex;\n      }\n    }\n    return mesh;\n  }\n  /**\n   * Build Mesh from CSG taking material and transforms into account\n   * @param name The name of the Mesh\n   * @param material The material of the Mesh\n   * @param scene The Scene\n   * @param keepSubMeshes Specifies if submeshes should be kept\n   * @returns The new Mesh\n   */\n  toMesh(name, material = null, scene, keepSubMeshes) {\n    const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n    mesh.material = material;\n    mesh.position.copyFrom(this.position);\n    mesh.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      mesh.rotationQuaternion = this.rotationQuaternion.clone();\n    }\n    mesh.scaling.copyFrom(this.scaling);\n    mesh.computeWorldMatrix(true);\n    return mesh;\n  }\n}","map":{"version":3,"mappings":"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","names":["Quaternion","Matrix","Vector3","Vector2","VertexBuffer","SubMesh","Mesh","Color4","currentCSGMeshId","Vertex","constructor","pos","normal","uv","vertColor","clone","flip","scale","interpolate","other","t","Lerp","undefined","Plane","w","FromPoints","a","b","c","v0","subtract","v1","lengthSquared","n","Normalize","Cross","Dot","scaleInPlace","splitPolygon","polygon","coplanarFront","coplanarBack","front","back","COPLANAR","FRONT","BACK","SPANNING","polygonType","types","i","vertices","length","type","EPSILON","push","plane","f","j","ti","tj","vi","vj","v","poly","Polygon","shared","map","reverse","Node","polygons","Array","build","node","_plane","_front","_back","_polygons","p","invert","temp","clipPolygons","slice","concat","clipTo","bsp","allPolygons","CSG","FromMesh","mesh","absolute","vertex","position","matrix","meshPosition","meshRotation","meshRotationQuaternion","meshScaling","invertWinding","computeWorldMatrix","getWorldMatrix","rotation","rotationQuaternion","scaling","material","sideOrientation","indices","getIndices","positions","getVerticesData","PositionKind","normals","NormalKind","uvs","UVKind","vertColors","ColorKind","subMeshes","sm","sml","indexStart","il","indexCount","indexIndices","sourceNormal","sourcePosition","TransformCoordinates","TransformNormal","subMeshId","meshId","materialIndex","csg","_FromPolygons","Identity","Zero","One","copyTransformAttributes","union","unionInPlace","subtractInPlace","intersect","intersectInPlace","inverse","inverseInPlace","buildMeshGeometry","name","scene","keepSubMeshes","polygonIndices","vertice_dict","vertex_idx","currentIndex","subMeshDict","subMeshObj","sort","Infinity","indexEnd","jl","k","copyFrom","localVertex","localNormal","x","y","z","areUvsDifferent","areColorsDifferent","r","g","Math","min","max","setVerticesData","setIndices","materialIndexOffset","materialMaxIndex","m","CreateFromIndices","toMesh"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/csg.ts"],"sourcesContent":["import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport { Constants } from \"../Engines/constants\";\r\n/**\r\n * Unique ID when we import meshes from Babylon to CSG\r\n */\r\nlet currentCSGMeshId = 0;\r\n\r\n/**\r\n * Represents a vertex of a polygon. Use your own vertex class instead of this\r\n * one to provide additional features like texture coordinates and vertex\r\n * colors. Custom vertex classes need to provide a `pos` property and `clone()`,\r\n * `flip()`, and `interpolate()` methods that behave analogous to the ones\r\n * defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\r\n * functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\r\n * is not used anywhere else.\r\n * Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\r\n */\r\nclass Vertex {\r\n    /**\r\n     * Initializes the vertex\r\n     * @param pos The position of the vertex\r\n     * @param normal The normal of the vertex\r\n     * @param uv The texture coordinate of the vertex\r\n     * @param vertColor The RGBA color of the vertex\r\n     */\r\n    constructor(\r\n        /**\r\n         * The position of the vertex\r\n         */\r\n        public pos: Vector3,\r\n        /**\r\n         * The normal of the vertex\r\n         */\r\n        public normal: Vector3,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public uv?: Vector2,\r\n        /**\r\n         * The texture coordinate of the vertex\r\n         */\r\n        public vertColor?: Color4\r\n    ) {}\r\n\r\n    /**\r\n     * Make a clone, or deep copy, of the vertex\r\n     * @returns A new Vertex\r\n     */\r\n    public clone(): Vertex {\r\n        return new Vertex(this.pos.clone(), this.normal.clone(), this.uv?.clone(), this.vertColor?.clone());\r\n    }\r\n\r\n    /**\r\n     * Invert all orientation-specific data (e.g. vertex normal). Called when the\r\n     * orientation of a polygon is flipped.\r\n     */\r\n    public flip(): void {\r\n        this.normal = this.normal.scale(-1);\r\n    }\r\n\r\n    /**\r\n     * Create a new vertex between this vertex and `other` by linearly\r\n     * interpolating all properties using a parameter of `t`. Subclasses should\r\n     * override this to interpolate additional properties.\r\n     * @param other the vertex to interpolate against\r\n     * @param t The factor used to linearly interpolate between the vertices\r\n     */\r\n    public interpolate(other: Vertex, t: number): Vertex {\r\n        return new Vertex(\r\n            Vector3.Lerp(this.pos, other.pos, t),\r\n            Vector3.Lerp(this.normal, other.normal, t),\r\n            this.uv && other.uv ? Vector2.Lerp(this.uv, other.uv, t) : undefined,\r\n            this.vertColor && other.vertColor ? Color4.Lerp(this.vertColor, other.vertColor, t) : undefined\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a plane in 3D space.\r\n */\r\nclass Plane {\r\n    /**\r\n     * Initializes the plane\r\n     * @param normal The normal for the plane\r\n     * @param w\r\n     */\r\n    constructor(public normal: Vector3, public w: number) {}\r\n\r\n    /**\r\n     * `CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\r\n     * point is on the plane\r\n     */\r\n    static EPSILON = 1e-5;\r\n\r\n    /**\r\n     * Construct a plane from three points\r\n     * @param a Point a\r\n     * @param b Point b\r\n     * @param c Point c\r\n     */\r\n    public static FromPoints(a: Vector3, b: Vector3, c: Vector3): Nullable<Plane> {\r\n        const v0 = c.subtract(a);\r\n        const v1 = b.subtract(a);\r\n\r\n        if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\r\n            return null;\r\n        }\r\n\r\n        const n = Vector3.Normalize(Vector3.Cross(v0, v1));\r\n        return new Plane(n, Vector3.Dot(n, a));\r\n    }\r\n\r\n    /**\r\n     * Clone, or make a deep copy of the plane\r\n     * @returns a new Plane\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.clone(), this.w);\r\n    }\r\n\r\n    /**\r\n     * Flip the face of the plane\r\n     */\r\n    public flip() {\r\n        this.normal.scaleInPlace(-1);\r\n        this.w = -this.w;\r\n    }\r\n\r\n    /**\r\n     * Split `polygon` by this plane if needed, then put the polygon or polygon\r\n     * fragments in the appropriate lists. Coplanar polygons go into either\r\n    `* coplanarFront` or `coplanarBack` depending on their orientation with\r\n     * respect to this plane. Polygons in front or in back of this plane go into\r\n     * either `front` or `back`\r\n     * @param polygon The polygon to be split\r\n     * @param coplanarFront Will contain polygons coplanar with the plane that are oriented to the front of the plane\r\n     * @param coplanarBack Will contain polygons coplanar with the plane that are oriented to the back of the plane\r\n     * @param front Will contain the polygons in front of the plane\r\n     * @param back Will contain the polygons begind the plane\r\n     */\r\n    public splitPolygon(polygon: Polygon, coplanarFront: Polygon[], coplanarBack: Polygon[], front: Polygon[], back: Polygon[]): void {\r\n        const COPLANAR = 0;\r\n        const FRONT = 1;\r\n        const BACK = 2;\r\n        const SPANNING = 3;\r\n\r\n        // Classify each point as well as the entire polygon into one of the above\r\n        // four classes.\r\n        let polygonType = 0;\r\n        const types = [];\r\n        let i: number;\r\n        let t: number;\r\n        for (i = 0; i < polygon.vertices.length; i++) {\r\n            t = Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\r\n            const type = t < -Plane.EPSILON ? BACK : t > Plane.EPSILON ? FRONT : COPLANAR;\r\n            polygonType |= type;\r\n            types.push(type);\r\n        }\r\n\r\n        // Put the polygon in the correct list, splitting it when necessary\r\n        switch (polygonType) {\r\n            case COPLANAR:\r\n                (Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\r\n                break;\r\n            case FRONT:\r\n                front.push(polygon);\r\n                break;\r\n            case BACK:\r\n                back.push(polygon);\r\n                break;\r\n            case SPANNING: {\r\n                const f = [],\r\n                    b = [];\r\n                for (i = 0; i < polygon.vertices.length; i++) {\r\n                    const j = (i + 1) % polygon.vertices.length;\r\n                    const ti = types[i],\r\n                        tj = types[j];\r\n                    const vi = polygon.vertices[i],\r\n                        vj = polygon.vertices[j];\r\n                    if (ti !== BACK) {\r\n                        f.push(vi);\r\n                    }\r\n                    if (ti !== FRONT) {\r\n                        b.push(ti !== BACK ? vi.clone() : vi);\r\n                    }\r\n                    if ((ti | tj) === SPANNING) {\r\n                        t = (this.w - Vector3.Dot(this.normal, vi.pos)) / Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\r\n                        const v = vi.interpolate(vj, t);\r\n                        f.push(v);\r\n                        b.push(v.clone());\r\n                    }\r\n                }\r\n                let poly: Polygon;\r\n                if (f.length >= 3) {\r\n                    poly = new Polygon(f, polygon.shared);\r\n                    if (poly.plane) {\r\n                        front.push(poly);\r\n                    }\r\n                }\r\n\r\n                if (b.length >= 3) {\r\n                    poly = new Polygon(b, polygon.shared);\r\n\r\n                    if (poly.plane) {\r\n                        back.push(poly);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a convex polygon. The vertices used to initialize a polygon must\r\n * be coplanar and form a convex loop.\r\n *\r\n * Each convex polygon has a `shared` property, which is shared between all\r\n * polygons that are clones of each other or were split from the same polygon.\r\n * This can be used to define per-polygon properties (such as surface color)\r\n */\r\nclass Polygon {\r\n    /**\r\n     * Vertices of the polygon\r\n     */\r\n    public vertices: Vertex[];\r\n    /**\r\n     * Properties that are shared across all polygons\r\n     */\r\n    public shared: any;\r\n    /**\r\n     * A plane formed from the vertices of the polygon\r\n     */\r\n    public plane: Plane;\r\n\r\n    /**\r\n     * Initializes the polygon\r\n     * @param vertices The vertices of the polygon\r\n     * @param shared The properties shared across all polygons\r\n     */\r\n    constructor(vertices: Vertex[], shared: any) {\r\n        this.vertices = vertices;\r\n        this.shared = shared;\r\n        this.plane = <Plane>Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, or the polygon\r\n     */\r\n    public clone(): Polygon {\r\n        const vertices = this.vertices.map((v) => v.clone());\r\n        return new Polygon(vertices, this.shared);\r\n    }\r\n\r\n    /**\r\n     * Flips the faces of the polygon\r\n     */\r\n    public flip() {\r\n        this.vertices.reverse().map((v) => {\r\n            v.flip();\r\n        });\r\n        this.plane.flip();\r\n    }\r\n}\r\n\r\n/**\r\n * Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\r\n * by picking a polygon to split along. That polygon (and all other coplanar\r\n * polygons) are added directly to that node and the other polygons are added to\r\n * the front and/or back subtrees. This is not a leafy BSP tree since there is\r\n * no distinction between internal and leaf nodes\r\n */\r\nclass Node {\r\n    private _plane: Nullable<Plane> = null;\r\n    private _front: Nullable<Node> = null;\r\n    private _back: Nullable<Node> = null;\r\n    private _polygons = new Array<Polygon>();\r\n\r\n    /**\r\n     * Initializes the node\r\n     * @param polygons A collection of polygons held in the node\r\n     */\r\n    constructor(polygons?: Array<Polygon>) {\r\n        if (polygons) {\r\n            this.build(polygons);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the node\r\n     * @returns The cloned node\r\n     */\r\n    public clone(): Node {\r\n        const node = new Node();\r\n        node._plane = this._plane && this._plane.clone();\r\n        node._front = this._front && this._front.clone();\r\n        node._back = this._back && this._back.clone();\r\n        node._polygons = this._polygons.map((p) => p.clone());\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Convert solid space to empty space and empty space to solid space\r\n     */\r\n    public invert(): void {\r\n        for (let i = 0; i < this._polygons.length; i++) {\r\n            this._polygons[i].flip();\r\n        }\r\n        if (this._plane) {\r\n            this._plane.flip();\r\n        }\r\n        if (this._front) {\r\n            this._front.invert();\r\n        }\r\n        if (this._back) {\r\n            this._back.invert();\r\n        }\r\n        const temp = this._front;\r\n        this._front = this._back;\r\n        this._back = temp;\r\n    }\r\n\r\n    /**\r\n     * Recursively remove all polygons in `polygons` that are inside this BSP\r\n     * tree.\r\n     * @param polygons Polygons to remove from the BSP\r\n     * @returns Polygons clipped from the BSP\r\n     */\r\n    clipPolygons(polygons: Polygon[]): Polygon[] {\r\n        if (!this._plane) {\r\n            return polygons.slice();\r\n        }\r\n        let front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], front, back, front, back);\r\n        }\r\n        if (this._front) {\r\n            front = this._front.clipPolygons(front);\r\n        }\r\n        if (this._back) {\r\n            back = this._back.clipPolygons(back);\r\n        } else {\r\n            back = [];\r\n        }\r\n        return front.concat(back);\r\n    }\r\n\r\n    /**\r\n     * Remove all polygons in this BSP tree that are inside the other BSP tree\r\n     * `bsp`.\r\n     * @param bsp BSP containing polygons to remove from this BSP\r\n     */\r\n    clipTo(bsp: Node): void {\r\n        this._polygons = bsp.clipPolygons(this._polygons);\r\n        if (this._front) {\r\n            this._front.clipTo(bsp);\r\n        }\r\n        if (this._back) {\r\n            this._back.clipTo(bsp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a list of all polygons in this BSP tree\r\n     * @returns List of all polygons in this BSP tree\r\n     */\r\n    allPolygons(): Polygon[] {\r\n        let polygons = this._polygons.slice();\r\n        if (this._front) {\r\n            polygons = polygons.concat(this._front.allPolygons());\r\n        }\r\n        if (this._back) {\r\n            polygons = polygons.concat(this._back.allPolygons());\r\n        }\r\n        return polygons;\r\n    }\r\n\r\n    /**\r\n     * Build a BSP tree out of `polygons`. When called on an existing tree, the\r\n     * new polygons are filtered down to the bottom of the tree and become new\r\n     * nodes there. Each set of polygons is partitioned using the first polygon\r\n     * (no heuristic is used to pick a good split)\r\n     * @param polygons Polygons used to construct the BSP tree\r\n     */\r\n    build(polygons: Polygon[]): void {\r\n        if (!polygons.length) {\r\n            return;\r\n        }\r\n        if (!this._plane) {\r\n            this._plane = polygons[0].plane.clone();\r\n        }\r\n        const front = new Array<Polygon>(),\r\n            back = new Array<Polygon>();\r\n        for (let i = 0; i < polygons.length; i++) {\r\n            this._plane.splitPolygon(polygons[i], this._polygons, this._polygons, front, back);\r\n        }\r\n        if (front.length) {\r\n            if (!this._front) {\r\n                this._front = new Node();\r\n            }\r\n            this._front.build(front);\r\n        }\r\n        if (back.length) {\r\n            if (!this._back) {\r\n                this._back = new Node();\r\n            }\r\n            this._back.build(back);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Class for building Constructive Solid Geometry\r\n */\r\nexport class CSG {\r\n    private _polygons = new Array<Polygon>();\r\n    /**\r\n     * The world matrix\r\n     */\r\n    public matrix: Matrix;\r\n    /**\r\n     * Stores the position\r\n     */\r\n    public position: Vector3;\r\n    /**\r\n     * Stores the rotation\r\n     */\r\n    public rotation: Vector3;\r\n    /**\r\n     * Stores the rotation quaternion\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * Stores the scaling vector\r\n     */\r\n    public scaling: Vector3;\r\n\r\n    /**\r\n     * Convert the Mesh to CSG\r\n     * @param mesh The Mesh to convert to CSG\r\n     * @param absolute If true, the final (local) matrix transformation is set to the identity and not to that of `mesh`. It can help when dealing with right-handed meshes (default: false)\r\n     * @returns A new CSG from the Mesh\r\n     */\r\n    public static FromMesh(mesh: Mesh, absolute = false): CSG {\r\n        let vertex: Vertex,\r\n            normal: Vector3,\r\n            uv: Vector2 | undefined = undefined,\r\n            position: Vector3,\r\n            vertColor: Color4 | undefined = undefined,\r\n            polygon: Polygon,\r\n            vertices;\r\n        const polygons = new Array<Polygon>();\r\n        let matrix: Matrix,\r\n            meshPosition: Vector3,\r\n            meshRotation: Vector3,\r\n            meshRotationQuaternion: Nullable<Quaternion> = null,\r\n            meshScaling: Vector3;\r\n\r\n        let invertWinding = false;\r\n        if (mesh instanceof Mesh) {\r\n            mesh.computeWorldMatrix(true);\r\n            matrix = mesh.getWorldMatrix();\r\n            meshPosition = mesh.position.clone();\r\n            meshRotation = mesh.rotation.clone();\r\n            if (mesh.rotationQuaternion) {\r\n                meshRotationQuaternion = mesh.rotationQuaternion.clone();\r\n            }\r\n            meshScaling = mesh.scaling.clone();\r\n            if (mesh.material && absolute) {\r\n                invertWinding = mesh.material.sideOrientation === Constants.MATERIAL_ClockWiseSideOrientation;\r\n            }\r\n        } else {\r\n            throw \"BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh\";\r\n        }\r\n\r\n        const indices = <IndicesArray>mesh.getIndices(),\r\n            positions = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind),\r\n            normals = <FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind),\r\n            uvs = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind),\r\n            vertColors = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const subMeshes = mesh.subMeshes;\r\n\r\n        for (let sm = 0, sml = subMeshes.length; sm < sml; sm++) {\r\n            for (let i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\r\n                vertices = [];\r\n                for (let j = 0; j < 3; j++) {\r\n                    const indexIndices = j === 0 ? i + j : invertWinding ? i + 3 - j : i + j;\r\n                    const sourceNormal = new Vector3(normals[indices[indexIndices] * 3], normals[indices[indexIndices] * 3 + 1], normals[indices[indexIndices] * 3 + 2]);\r\n                    if (uvs) {\r\n                        uv = new Vector2(uvs[indices[indexIndices] * 2], uvs[indices[indexIndices] * 2 + 1]);\r\n                    }\r\n                    if (vertColors) {\r\n                        vertColor = new Color4(\r\n                            vertColors[indices[indexIndices] * 4],\r\n                            vertColors[indices[indexIndices] * 4 + 1],\r\n                            vertColors[indices[indexIndices] * 4 + 2],\r\n                            vertColors[indices[indexIndices] * 4 + 3]\r\n                        );\r\n                    }\r\n                    const sourcePosition = new Vector3(positions[indices[indexIndices] * 3], positions[indices[indexIndices] * 3 + 1], positions[indices[indexIndices] * 3 + 2]);\r\n                    position = Vector3.TransformCoordinates(sourcePosition, matrix);\r\n                    normal = Vector3.TransformNormal(sourceNormal, matrix);\r\n\r\n                    vertex = new Vertex(position, normal, uv, vertColor);\r\n                    vertices.push(vertex);\r\n                }\r\n\r\n                polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\r\n\r\n                // To handle the case of degenerated triangle\r\n                // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\r\n                if (polygon.plane) {\r\n                    polygons.push(polygon);\r\n                }\r\n            }\r\n        }\r\n\r\n        const csg = CSG._FromPolygons(polygons);\r\n        csg.matrix = absolute ? Matrix.Identity() : matrix;\r\n        csg.position = absolute ? Vector3.Zero() : meshPosition;\r\n        csg.rotation = absolute ? Vector3.Zero() : meshRotation;\r\n        csg.scaling = absolute ? Vector3.One() : meshScaling;\r\n        csg.rotationQuaternion = absolute && meshRotationQuaternion ? Quaternion.Identity() : meshRotationQuaternion;\r\n        currentCSGMeshId++;\r\n\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Construct a CSG solid from a list of `CSG.Polygon` instances.\r\n     * @param polygons Polygons used to construct a CSG solid\r\n     */\r\n    private static _FromPolygons(polygons: Polygon[]): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = polygons;\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Clones, or makes a deep copy, of the CSG\r\n     * @returns A new CSG\r\n     */\r\n    public clone(): CSG {\r\n        const csg = new CSG();\r\n        csg._polygons = this._polygons.map((p) => p.clone());\r\n        csg.copyTransformAttributes(this);\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG\r\n     * @param csg The CSG to union against this CSG\r\n     * @returns The unioned CSG\r\n     */\r\n    public union(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Unions this CSG with another CSG in place\r\n     * @param csg The CSG to union against this CSG\r\n     */\r\n    public unionInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG\r\n     * @param csg The CSG to subtract against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public subtract(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Subtracts this CSG with another CSG in place\r\n     * @param csg The CSG to subtract against this CSG\r\n     */\r\n    public subtractInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        b.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Intersect this CSG with another CSG\r\n     * @param csg The CSG to intersect against this CSG\r\n     * @returns A new CSG\r\n     */\r\n    public intersect(csg: CSG): CSG {\r\n        const a = new Node(this.clone()._polygons);\r\n        const b = new Node(csg.clone()._polygons);\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n        return CSG._FromPolygons(a.allPolygons()).copyTransformAttributes(this);\r\n    }\r\n\r\n    /**\r\n     * Intersects this CSG with another CSG in place\r\n     * @param csg The CSG to intersect against this CSG\r\n     */\r\n    public intersectInPlace(csg: CSG): void {\r\n        const a = new Node(this._polygons);\r\n        const b = new Node(csg._polygons);\r\n\r\n        a.invert();\r\n        b.clipTo(a);\r\n        b.invert();\r\n        a.clipTo(b);\r\n        b.clipTo(a);\r\n        a.build(b.allPolygons());\r\n        a.invert();\r\n\r\n        this._polygons = a.allPolygons();\r\n    }\r\n\r\n    /**\r\n     * Return a new CSG solid with solid and empty space switched. This solid is\r\n     * not modified.\r\n     * @returns A new CSG solid with solid and empty space switched\r\n     */\r\n    public inverse(): CSG {\r\n        const csg = this.clone();\r\n        csg.inverseInPlace();\r\n        return csg;\r\n    }\r\n\r\n    /**\r\n     * Inverses the CSG in place\r\n     */\r\n    public inverseInPlace(): void {\r\n        this._polygons.map((p) => {\r\n            p.flip();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This is used to keep meshes transformations so they can be restored\r\n     * when we build back a Babylon Mesh\r\n     * NB : All CSG operations are performed in world coordinates\r\n     * @param csg The CSG to copy the transform attributes from\r\n     * @returns This CSG\r\n     */\r\n    public copyTransformAttributes(csg: CSG): CSG {\r\n        this.matrix = csg.matrix;\r\n        this.position = csg.position;\r\n        this.rotation = csg.rotation;\r\n        this.scaling = csg.scaling;\r\n        this.rotationQuaternion = csg.rotationQuaternion;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Build Raw mesh from CSG\r\n     * Coordinates here are in world space\r\n     * @param name The name of the mesh geometry\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if the submeshes should be kept\r\n     * @returns A new Mesh\r\n     */\r\n    public buildMeshGeometry(name: string, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const matrix = this.matrix.clone();\r\n        matrix.invert();\r\n\r\n        const mesh = new Mesh(name, scene);\r\n        const vertices = [];\r\n        const indices = [];\r\n        const normals = [];\r\n        let uvs: Nullable<number[]> = null;\r\n        let vertColors: Nullable<number[]> = null;\r\n        const vertex = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n        const uv = Vector2.Zero();\r\n        const vertColor = new Color4(0, 0, 0, 0);\r\n        const polygons = this._polygons;\r\n        const polygonIndices = [0, 0, 0];\r\n        let polygon;\r\n        const vertice_dict = {};\r\n        let vertex_idx;\r\n        let currentIndex = 0;\r\n        const subMeshDict = {};\r\n        let subMeshObj;\r\n\r\n        if (keepSubMeshes) {\r\n            // Sort Polygons, since subMeshes are indices range\r\n            polygons.sort((a, b) => {\r\n                if (a.shared.meshId === b.shared.meshId) {\r\n                    return a.shared.subMeshId - b.shared.subMeshId;\r\n                } else {\r\n                    return a.shared.meshId - b.shared.meshId;\r\n                }\r\n            });\r\n        }\r\n\r\n        for (let i = 0, il = polygons.length; i < il; i++) {\r\n            polygon = polygons[i];\r\n\r\n            // Building SubMeshes\r\n            if (!(<any>subMeshDict)[polygon.shared.meshId]) {\r\n                (<any>subMeshDict)[polygon.shared.meshId] = {};\r\n            }\r\n            if (!(<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId]) {\r\n                (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId] = {\r\n                    indexStart: +Infinity,\r\n                    indexEnd: -Infinity,\r\n                    materialIndex: polygon.shared.materialIndex,\r\n                };\r\n            }\r\n            subMeshObj = (<any>subMeshDict)[polygon.shared.meshId][polygon.shared.subMeshId];\r\n\r\n            for (let j = 2, jl = polygon.vertices.length; j < jl; j++) {\r\n                polygonIndices[0] = 0;\r\n                polygonIndices[1] = j - 1;\r\n                polygonIndices[2] = j;\r\n\r\n                for (let k = 0; k < 3; k++) {\r\n                    vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\r\n                    normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\r\n                    if (polygon.vertices[polygonIndices[k]].uv) {\r\n                        if (!uvs) {\r\n                            uvs = [];\r\n                        }\r\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv!);\r\n                    }\r\n\r\n                    if (polygon.vertices[polygonIndices[k]].vertColor) {\r\n                        if (!vertColors) {\r\n                            vertColors = [];\r\n                        }\r\n                        vertColor.copyFrom(polygon.vertices[polygonIndices[k]].vertColor!);\r\n                    }\r\n                    const localVertex = Vector3.TransformCoordinates(vertex, matrix);\r\n                    const localNormal = Vector3.TransformNormal(normal, matrix);\r\n\r\n                    vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z];\r\n\r\n                    let areUvsDifferent = false;\r\n\r\n                    if (uvs && !(uvs[vertex_idx * 2] === uv.x || uvs[vertex_idx * 2 + 1] === uv.y)) {\r\n                        areUvsDifferent = true;\r\n                    }\r\n\r\n                    let areColorsDifferent = false;\r\n\r\n                    if (\r\n                        vertColors &&\r\n                        !(\r\n                            vertColors[vertex_idx * 4] === vertColor.r ||\r\n                            vertColors[vertex_idx * 4 + 1] === vertColor.g ||\r\n                            vertColors[vertex_idx * 4 + 2] === vertColor.b ||\r\n                            vertColors[vertex_idx * 4 + 3] === vertColor.a\r\n                        )\r\n                    ) {\r\n                        areColorsDifferent = true;\r\n                    }\r\n\r\n                    // Check if 2 points can be merged\r\n                    if (\r\n                        !(\r\n                            typeof vertex_idx !== \"undefined\" &&\r\n                            normals[vertex_idx * 3] === localNormal.x &&\r\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\r\n                            normals[vertex_idx * 3 + 2] === localNormal.z\r\n                        ) ||\r\n                        areUvsDifferent ||\r\n                        areColorsDifferent\r\n                    ) {\r\n                        vertices.push(localVertex.x, localVertex.y, localVertex.z);\r\n                        if (uvs) {\r\n                            uvs.push(uv.x, uv.y);\r\n                        }\r\n                        normals.push(normal.x, normal.y, normal.z);\r\n                        if (vertColors) {\r\n                            vertColors.push(vertColor.r, vertColor.g, vertColor.b, vertColor.a);\r\n                        }\r\n                        vertex_idx = (<any>vertice_dict)[localVertex.x + \",\" + localVertex.y + \",\" + localVertex.z] = vertices.length / 3 - 1;\r\n                    }\r\n\r\n                    indices.push(vertex_idx);\r\n\r\n                    subMeshObj.indexStart = Math.min(currentIndex, subMeshObj.indexStart);\r\n                    subMeshObj.indexEnd = Math.max(currentIndex, subMeshObj.indexEnd);\r\n                    currentIndex++;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, vertices);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        if (uvs) {\r\n            mesh.setVerticesData(VertexBuffer.UVKind, uvs);\r\n        }\r\n        if (vertColors) {\r\n            mesh.setVerticesData(VertexBuffer.ColorKind, vertColors);\r\n        }\r\n        mesh.setIndices(indices, null);\r\n\r\n        if (keepSubMeshes) {\r\n            // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\r\n            let materialIndexOffset = 0,\r\n                materialMaxIndex;\r\n\r\n            mesh.subMeshes = new Array<SubMesh>();\r\n\r\n            for (const m in subMeshDict) {\r\n                materialMaxIndex = -1;\r\n                for (const sm in (<any>subMeshDict)[m]) {\r\n                    subMeshObj = (<any>subMeshDict)[m][sm];\r\n                    SubMesh.CreateFromIndices(\r\n                        subMeshObj.materialIndex + materialIndexOffset,\r\n                        subMeshObj.indexStart,\r\n                        subMeshObj.indexEnd - subMeshObj.indexStart + 1,\r\n                        <AbstractMesh>mesh\r\n                    );\r\n                    materialMaxIndex = Math.max(subMeshObj.materialIndex, materialMaxIndex);\r\n                }\r\n                materialIndexOffset += ++materialMaxIndex;\r\n            }\r\n        }\r\n\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Build Mesh from CSG taking material and transforms into account\r\n     * @param name The name of the Mesh\r\n     * @param material The material of the Mesh\r\n     * @param scene The Scene\r\n     * @param keepSubMeshes Specifies if submeshes should be kept\r\n     * @returns The new Mesh\r\n     */\r\n    public toMesh(name: string, material: Nullable<Material> = null, scene?: Scene, keepSubMeshes?: boolean): Mesh {\r\n        const mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\r\n\r\n        mesh.material = material;\r\n\r\n        mesh.position.copyFrom(this.position);\r\n        mesh.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            mesh.rotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n        mesh.scaling.copyFrom(this.scaling);\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        return mesh;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}