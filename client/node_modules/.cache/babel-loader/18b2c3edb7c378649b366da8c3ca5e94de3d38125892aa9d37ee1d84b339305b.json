{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Epsilon } from \"../Maths/math.constants.js\";\nimport { Axis } from \"../Maths/math.axis.js\";\n/**\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\n * This is the base of the follow, arc rotate cameras and Free camera\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n */\nexport class TargetCamera extends Camera {\n  /**\n   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\n   * This is the base of the follow, arc rotate cameras and Free camera\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\n   * @param name Defines the name of the camera in the scene\n   * @param position Defines the start position of the camera in the scene\n   * @param scene Defines the scene the camera belongs to\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    this._tmpUpVector = Vector3.Zero();\n    this._tmpTargetVector = Vector3.Zero();\n    /**\n     * Define the current direction the camera is moving to\n     */\n    this.cameraDirection = new Vector3(0, 0, 0);\n    /**\n     * Define the current rotation the camera is rotating to\n     */\n    this.cameraRotation = new Vector2(0, 0);\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\n    this.ignoreParentScaling = false;\n    /**\n     * When set, the up vector of the camera will be updated by the rotation of the camera\n     */\n    this.updateUpVectorFromRotation = false;\n    this._tmpQuaternion = new Quaternion();\n    /**\n     * Define the current rotation of the camera\n     */\n    this.rotation = new Vector3(0, 0, 0);\n    /**\n     * Define the current speed of the camera\n     */\n    this.speed = 2.0;\n    /**\n     * Add constraint to the camera to prevent it to move freely in all directions and\n     * around all axis.\n     */\n    this.noRotationConstraint = false;\n    /**\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\n     * panning\n     */\n    this.invertRotation = false;\n    /**\n     * Speed multiplier for inverse camera panning\n     */\n    this.inverseRotationSpeed = 0.2;\n    /**\n     * Define the current target of the camera as an object or a position.\n     * Please note that locking a target will disable panning.\n     */\n    this.lockedTarget = null;\n    /** @internal */\n    this._currentTarget = Vector3.Zero();\n    /** @internal */\n    this._initialFocalDistance = 1;\n    /** @internal */\n    this._viewMatrix = Matrix.Zero();\n    /** @internal */\n    this._camMatrix = Matrix.Zero();\n    /** @internal */\n    this._cameraTransformMatrix = Matrix.Zero();\n    /** @internal */\n    this._cameraRotationMatrix = Matrix.Zero();\n    /** @internal */\n    this._referencePoint = new Vector3(0, 0, 1);\n    /** @internal */\n    this._transformedReferencePoint = Vector3.Zero();\n    this._defaultUp = Vector3.Up();\n    this._cachedRotationZ = 0;\n    this._cachedQuaternionRotationZ = 0;\n  }\n  /**\n   * Gets the position in front of the camera at a given distance.\n   * @param distance The distance from the camera we want the position to be\n   * @returns the position\n   */\n  getFrontPosition(distance) {\n    this.getWorldMatrix();\n    const direction = this.getTarget().subtract(this.position);\n    direction.normalize();\n    direction.scaleInPlace(distance);\n    return this.globalPosition.add(direction);\n  }\n  /** @internal */\n  _getLockedTargetPosition() {\n    if (!this.lockedTarget) {\n      return null;\n    }\n    if (this.lockedTarget.absolutePosition) {\n      this.lockedTarget.computeWorldMatrix();\n    }\n    return this.lockedTarget.absolutePosition || this.lockedTarget;\n  }\n  /**\n   * Store current camera state of the camera (fov, position, rotation, etc..)\n   * @returns the camera\n   */\n  storeState() {\n    this._storedPosition = this.position.clone();\n    this._storedRotation = this.rotation.clone();\n    if (this.rotationQuaternion) {\n      this._storedRotationQuaternion = this.rotationQuaternion.clone();\n    }\n    return super.storeState();\n  }\n  /**\n   * Restored camera state. You must call storeState() first\n   * @returns whether it was successful or not\n   * @internal\n   */\n  _restoreStateValues() {\n    if (!super._restoreStateValues()) {\n      return false;\n    }\n    this.position = this._storedPosition.clone();\n    this.rotation = this._storedRotation.clone();\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion = this._storedRotationQuaternion.clone();\n    }\n    this.cameraDirection.copyFromFloats(0, 0, 0);\n    this.cameraRotation.copyFromFloats(0, 0);\n    return true;\n  }\n  /** @internal */\n  _initCache() {\n    super._initCache();\n    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  }\n  /**\n   * @internal\n   */\n  _updateCache(ignoreParentClass) {\n    if (!ignoreParentClass) {\n      super._updateCache();\n    }\n    const lockedTargetPosition = this._getLockedTargetPosition();\n    if (!lockedTargetPosition) {\n      this._cache.lockedTarget = null;\n    } else {\n      if (!this._cache.lockedTarget) {\n        this._cache.lockedTarget = lockedTargetPosition.clone();\n      } else {\n        this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n      }\n    }\n    this._cache.rotation.copyFrom(this.rotation);\n    if (this.rotationQuaternion) {\n      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n    }\n  }\n  // Synchronized\n  /** @internal */\n  _isSynchronizedViewMatrix() {\n    if (!super._isSynchronizedViewMatrix()) {\n      return false;\n    }\n    const lockedTargetPosition = this._getLockedTargetPosition();\n    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n  }\n  // Methods\n  /** @internal */\n  _computeLocalCameraSpeed() {\n    const engine = this.getEngine();\n    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\n  }\n  // Target\n  /**\n   * Defines the target the camera should look at.\n   * @param target Defines the new target as a Vector\n   */\n  setTarget(target) {\n    this.upVector.normalize();\n    this._initialFocalDistance = target.subtract(this.position).length();\n    if (this.position.z === target.z) {\n      this.position.z += Epsilon;\n    }\n    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\n    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\n    this._camMatrix.invert();\n    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n    const vDir = target.subtract(this.position);\n    if (vDir.x >= 0.0) {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\n    } else {\n      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\n    }\n    this.rotation.z = 0;\n    if (isNaN(this.rotation.x)) {\n      this.rotation.x = 0;\n    }\n    if (isNaN(this.rotation.y)) {\n      this.rotation.y = 0;\n    }\n    if (isNaN(this.rotation.z)) {\n      this.rotation.z = 0;\n    }\n    if (this.rotationQuaternion) {\n      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n    }\n  }\n  /**\n   * Defines the target point of the camera.\n   * The camera looks towards it form the radius distance.\n   */\n  get target() {\n    return this.getTarget();\n  }\n  set target(value) {\n    this.setTarget(value);\n  }\n  /**\n   * Return the current target position of the camera. This value is expressed in local space.\n   * @returns the target position\n   */\n  getTarget() {\n    return this._currentTarget;\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.parent) {\n      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\n      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\n      this.position.addInPlace(TmpVectors.Vector3[0]);\n      return;\n    }\n    this.position.addInPlace(this.cameraDirection);\n  }\n  /** @internal */\n  _checkInputs() {\n    const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\n    const needToMove = this._decideIfNeedsToMove();\n    const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\n    // Move\n    if (needToMove) {\n      this._updatePosition();\n    }\n    // Rotate\n    if (needToRotate) {\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\n      }\n      this.rotation.x += this.cameraRotation.x * directionMultiplier;\n      this.rotation.y += this.cameraRotation.y * directionMultiplier;\n      // Apply constraints\n      if (!this.noRotationConstraint) {\n        const limit = 1.570796;\n        if (this.rotation.x > limit) {\n          this.rotation.x = limit;\n        }\n        if (this.rotation.x < -limit) {\n          this.rotation.x = -limit;\n        }\n      }\n      //rotate, if quaternion is set and rotation was used\n      if (this.rotationQuaternion) {\n        const len = this.rotation.lengthSquared();\n        if (len) {\n          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n        }\n      }\n    }\n    // Inertia\n    if (needToMove) {\n      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\n        this.cameraDirection.x = 0;\n      }\n      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\n        this.cameraDirection.y = 0;\n      }\n      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\n        this.cameraDirection.z = 0;\n      }\n      this.cameraDirection.scaleInPlace(this.inertia);\n    }\n    if (needToRotate) {\n      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\n        this.cameraRotation.x = 0;\n      }\n      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\n        this.cameraRotation.y = 0;\n      }\n      this.cameraRotation.scaleInPlace(this.inertia);\n    }\n    super._checkInputs();\n  }\n  _updateCameraRotationMatrix() {\n    if (this.rotationQuaternion) {\n      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n    } else {\n      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n    }\n  }\n  /**\n   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\n   * @returns the current camera\n   */\n  _rotateUpVectorWithCameraRotationMatrix() {\n    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\n    return this;\n  }\n  /** @internal */\n  _getViewMatrix() {\n    if (this.lockedTarget) {\n      this.setTarget(this._getLockedTargetPosition());\n    }\n    // Compute\n    this._updateCameraRotationMatrix();\n    // Apply the changed rotation to the upVector\n    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\n    } else if (this._cachedRotationZ !== this.rotation.z) {\n      this._rotateUpVectorWithCameraRotationMatrix();\n      this._cachedRotationZ = this.rotation.z;\n    }\n    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n    // Computing target and final matrix\n    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n    if (this.updateUpVectorFromRotation) {\n      if (this.rotationQuaternion) {\n        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\n      } else {\n        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\n        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\n      }\n    }\n    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\n    return this._viewMatrix;\n  }\n  _computeViewMatrix(position, target, up) {\n    if (this.ignoreParentScaling) {\n      if (this.parent) {\n        const parentWorldMatrix = this.parent.getWorldMatrix();\n        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\n        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\n        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\n        this._markSyncedWithParent();\n      } else {\n        this._globalPosition.copyFrom(position);\n        this._tmpTargetVector.copyFrom(target);\n        this._tmpUpVector.copyFrom(up);\n      }\n      if (this.getScene().useRightHandedSystem) {\n        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      } else {\n        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\n      }\n      return;\n    }\n    if (this.getScene().useRightHandedSystem) {\n      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\n    } else {\n      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\n    }\n    if (this.parent) {\n      const parentWorldMatrix = this.parent.getWorldMatrix();\n      this._viewMatrix.invert();\n      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\n      this._viewMatrix.getTranslationToRef(this._globalPosition);\n      this._viewMatrix.invert();\n      this._markSyncedWithParent();\n    } else {\n      this._globalPosition.copyFrom(position);\n    }\n  }\n  /**\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  createRigCamera(name, cameraIndex) {\n    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n      const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n      rigCamera.isRigCamera = true;\n      rigCamera.rigParent = this;\n      if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\n        if (!this.rotationQuaternion) {\n          this.rotationQuaternion = new Quaternion();\n        }\n        rigCamera._cameraRigParams = {};\n        rigCamera.rotationQuaternion = new Quaternion();\n      }\n      rigCamera.mode = this.mode;\n      rigCamera.orthoLeft = this.orthoLeft;\n      rigCamera.orthoRight = this.orthoRight;\n      rigCamera.orthoTop = this.orthoTop;\n      rigCamera.orthoBottom = this.orthoBottom;\n      return rigCamera;\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  _updateRigCameras() {\n    const camLeft = this._rigCameras[0];\n    const camRight = this._rigCameras[1];\n    this.computeWorldMatrix();\n    switch (this.cameraRigMode) {\n      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED:\n        {\n          //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n          const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\n          const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\n          this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\n          break;\n        }\n      case Camera.RIG_MODE_VR:\n        if (camLeft.rotationQuaternion) {\n          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else {\n          camLeft.rotation.copyFrom(this.rotation);\n          camRight.rotation.copyFrom(this.rotation);\n        }\n        camLeft.position.copyFrom(this.position);\n        camRight.position.copyFrom(this.position);\n        break;\n    }\n    super._updateRigCameras();\n  }\n  _getRigCamPositionAndTarget(halfSpace, rigCamera) {\n    const target = this.getTarget();\n    target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\n    TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\n    const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\n    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n    TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\n    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\n    TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\n    Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\n    rigCamera.setTarget(newFocalTarget);\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TargetCamera\";\n  }\n}\nTargetCamera._RigCamTransformMatrix = new Matrix();\nTargetCamera._TargetTransformMatrix = new Matrix();\nTargetCamera._TargetFocalPoint = new Vector3();\n__decorate([serializeAsVector3()], TargetCamera.prototype, \"rotation\", void 0);\n__decorate([serialize()], TargetCamera.prototype, \"speed\", void 0);\n__decorate([serializeAsMeshReference(\"lockedTargetId\")], TargetCamera.prototype, \"lockedTarget\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsVector3","serializeAsMeshReference","Camera","Quaternion","Matrix","Vector3","Vector2","TmpVectors","Epsilon","Axis","TargetCamera","constructor","name","position","scene","setActiveOnSceneIfNoneActive","Zero","Up","getFrontPosition","distance","getWorldMatrix","direction","getTarget","subtract","normalize","scaleInPlace","globalPosition","add","_getLockedTargetPosition","lockedTarget","absolutePosition","computeWorldMatrix","storeState","_storedPosition","clone","_storedRotation","rotation","rotationQuaternion","_storedRotationQuaternion","_restoreStateValues","cameraDirection","copyFromFloats","cameraRotation","_initCache","_cache","Number","MAX_VALUE","_updateCache","ignoreParentClass","lockedTargetPosition","copyFrom","_isSynchronizedViewMatrix","equals","_computeLocalCameraSpeed","engine","getEngine","speed","Math","sqrt","getDeltaTime","getFps","setTarget","target","upVector","_initialFocalDistance","length","z","_referencePoint","LookAtLHToRef","_defaultUp","_camMatrix","invert","x","atan","m","vDir","y","PI","isNaN","RotationYawPitchRollToRef","value","_currentTarget","_decideIfNeedsToMove","abs","_updatePosition","parent","invertToRef","TransformNormalToRef","addInPlace","_checkInputs","directionMultiplier","invertRotation","inverseRotationSpeed","needToMove","needToRotate","toEulerAnglesToRef","noRotationConstraint","limit","len","lengthSquared","inertia","_updateCameraRotationMatrix","toRotationMatrix","_cameraRotationMatrix","_rotateUpVectorWithCameraRotationMatrix","_getViewMatrix","_cachedQuaternionRotationZ","_cachedRotationZ","TransformCoordinatesToRef","_transformedReferencePoint","addToRef","updateUpVectorFromRotation","Y","rotateByQuaternionToRef","FromEulerVectorToRef","_tmpQuaternion","_computeViewMatrix","_viewMatrix","up","ignoreParentScaling","parentWorldMatrix","_globalPosition","_tmpTargetVector","_tmpUpVector","_markSyncedWithParent","getScene","useRightHandedSystem","LookAtRHToRef","multiplyToRef","getTranslationToRef","createRigCamera","cameraIndex","cameraRigMode","RIG_MODE_NONE","rigCamera","isRigCamera","rigParent","RIG_MODE_VR","RIG_MODE_WEBVR","_cameraRigParams","mode","orthoLeft","orthoRight","orthoTop","orthoBottom","_updateRigCameras","camLeft","_rigCameras","camRight","RIG_MODE_STEREOSCOPIC_ANAGLYPH","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL","RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED","RIG_MODE_STEREOSCOPIC_OVERUNDER","RIG_MODE_STEREOSCOPIC_INTERLACED","leftSign","rightSign","_getRigCamPositionAndTarget","stereoHalfAngle","halfSpace","subtractToRef","_TargetFocalPoint","newFocalTarget","TranslationToRef","_TargetTransformMatrix","RotationAxis","_RigCamTransformMatrix","getClassName","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Cameras/targetCamera.ts"],"sourcesContent":["import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            this.lockedTarget.computeWorldMatrix();\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this.position.addInPlace(TmpVectors.Vector3[0]);\r\n            return;\r\n        }\r\n        this.position.addInPlace(this.cameraDirection);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n            }\r\n\r\n            this.rotation.x += this.cameraRotation.x * directionMultiplier;\r\n            this.rotation.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this.rotation.x > limit) {\r\n                    this.rotation.x = limit;\r\n                }\r\n                if (this.rotation.x < -limit) {\r\n                    this.rotation.x = -limit;\r\n                }\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this.rotation.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}