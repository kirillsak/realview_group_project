{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/fibonacci.js\";\nimport \"./ShadersInclude/helperFunctions.js\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions.js\";\nimport \"./ShadersInclude/diffusionProfile.js\";\nconst name = \"subSurfaceScatteringPixelShader\";\nconst shader = `#include<fibonacci>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<diffusionProfile>\nvarying vec2 vUV;\nuniform vec2 texelSize;\nuniform sampler2D textureSampler;\nuniform sampler2D irradianceSampler;\nuniform sampler2D depthSampler;\nuniform sampler2D albedoSampler;\nuniform vec2 viewportSize;\nuniform float metersPerUnit;\nconst float LOG2_E=1.4426950408889634;\nconst float SSS_PIXELS_PER_SAMPLE=4.;\nconst int _SssSampleBudget=40;\n#define rcp(x) 1./x\n#define Sq(x) x*x\n#define SSS_BILATERAL_FILTER true\nvec3 EvalBurleyDiffusionProfile(float r,vec3 S)\n{\nvec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); \nvec3 expSum=exp_13*(1.+exp_13*exp_13); \nreturn (S*rcp(8.*PI))*expSum; \n}\nvec2 SampleBurleyDiffusionProfile(float u,float rcpS)\n{\nu=1.-u; \nfloat g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));\nfloat n=exp2(log2(g)*(-1.0/3.0)); \nfloat p=(g*n)*n; \nfloat c=1.+p+n; \nfloat d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); \nfloat x=(3./LOG2_E)*log2(c)-d; \nfloat rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));\nfloat r=x*rcpS;\nfloat rcpPdf=(8.*PI*rcpS)*rcpExp; \nreturn vec2(r,rcpPdf);\n}\nvec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)\n{\n#ifndef SSS_BILATERAL_FILTER\nz=0.;\n#endif\nfloat r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));\nfloat area=rcpPdf;\n#if SSS_CLAMP_ARTIFACT\nreturn clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);\n#else\nreturn EvalBurleyDiffusionProfile(r,S)*area;\n#endif\n}\nvoid EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,\nfloat phase,inout vec3 totalIrradiance,inout vec3 totalWeight)\n{\nfloat scale =rcp(float(n));\nfloat offset=rcp(float(n))*0.5;\nfloat sinPhase,cosPhase;\nsinPhase=sin(phase);\ncosPhase=cos(phase);\nvec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);\nfloat r=bdp.x;\nfloat rcpPdf=bdp.y;\nfloat phi=SampleDiskGolden(i,n).y;\nfloat sinPhi,cosPhi;\nsinPhi=sin(phi);\ncosPhi=cos(phi);\nfloat sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; \nfloat cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; \nvec2 vec=r*vec2(cosPsi,sinPsi);\nvec2 position; \nfloat xy2;\nposition=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;\nxy2 =r*r;\nvec4 textureSample=texture2D(irradianceSampler,position);\nfloat viewZ=texture2D(depthSampler,position).r;\nvec3 irradiance =textureSample.rgb;\nif (testLightingForSSS(textureSample.a))\n{\nfloat relZ=viewZ-centerPosVS.z;\nvec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);\ntotalIrradiance+=weight*irradiance;\ntotalWeight +=weight;\n}\nelse\n{\n}\n}\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \n{\nvec4 irradianceAndDiffusionProfile =texture2D(irradianceSampler,vUV);\nvec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;\nint diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));\nfloat centerDepth =0.;\nvec4 inputColor=texture2D(textureSampler,vUV);\nbool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);\nif (passedStencilTest)\n{\ncenterDepth=texture2D(depthSampler,vUV).r;\n}\nif (!passedStencilTest) { \ngl_FragColor=inputColor;\nreturn;\n}\nfloat distScale =1.;\nvec3 S =diffusionS[diffusionProfileIndex];\nfloat d =diffusionD[diffusionProfileIndex];\nfloat filterRadius=filterRadii[diffusionProfileIndex];\nvec2 centerPosNDC=vUV;\nvec2 cornerPosNDC=vUV+0.5*texelSize;\nvec3 centerPosVS =vec3(centerPosNDC*viewportSize,1.0)*centerDepth; \nvec3 cornerPosVS =vec3(cornerPosNDC*viewportSize,1.0)*centerDepth; \nfloat mmPerUnit =1000.*(metersPerUnit*rcp(distScale));\nfloat unitsPerMm=rcp(mmPerUnit);\nfloat unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);\nfloat pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;\nfloat filterArea =PI*Sq(filterRadius*pixelsPerMm);\nint sampleCount =int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));\nint sampleBudget=_SssSampleBudget;\nint texturingMode=0;\nvec3 albedo =texture2D(albedoSampler,vUV).rgb;\nif (distScale==0. || sampleCount<1)\n{\n#ifdef DEBUG_SSS_SAMPLES\nvec3 green=vec3(0.,1.,0.);\ngl_FragColor=vec4(green,1.0);\nreturn;\n#endif\ngl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);\nreturn;\n}\n#ifdef DEBUG_SSS_SAMPLES\nvec3 red =vec3(1.,0.,0.);\nvec3 blue=vec3(0.,0.,1.);\ngl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);\nreturn;\n#endif\nfloat phase=0.;\nint n=min(sampleCount,sampleBudget);\nvec3 centerWeight =vec3(0.); \nvec3 totalIrradiance=vec3(0.);\nvec3 totalWeight =vec3(0.);\nfor (int i=0; i<n; i++)\n{\nEvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,\nphase,totalIrradiance,totalWeight);\n}\ntotalWeight=max(totalWeight,HALF_MIN);\ngl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const subSurfaceScatteringPixelShader = {\n  name,\n  shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,2BAAyB;AACrD,OAAO,+BAA6B;AACpC,OAAO,qCAAmC;AAC1C,OAAO,mDAAiD;AACxD,OAAO,sCAAoC;AAE3C,MAAMC,IAAI,GAAG,iCAAiC;AAC9C,MAAMC,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqJb;AACF;AACAF,WAAW,CAACG,YAAY,CAACF,IAAI,CAAC,GAAGC,MAAM;AACvC;AACA,OAAO,MAAME,+BAA+B,GAAG;EAAEH,IAAI;EAAEC;AAAM,CAAE","names":["ShaderStore","name","shader","ShadersStore","subSurfaceScatteringPixelShader"],"sourceRoot":"","sources":["../../../../lts/core/generated/Shaders/subSurfaceScattering.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/fibonacci\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/subSurfaceScatteringFunctions\";\nimport \"./ShadersInclude/diffusionProfile\";\n\nconst name = \"subSurfaceScatteringPixelShader\";\nconst shader = `#include<fibonacci>\n#include<helperFunctions>\n#include<subSurfaceScatteringFunctions>\n#include<diffusionProfile>\nvarying vec2 vUV;\runiform vec2 texelSize;\runiform sampler2D textureSampler;\runiform sampler2D irradianceSampler;\runiform sampler2D depthSampler;\runiform sampler2D albedoSampler;\runiform vec2 viewportSize;\runiform float metersPerUnit;\rconst float LOG2_E=1.4426950408889634;\rconst float SSS_PIXELS_PER_SAMPLE=4.;\rconst int _SssSampleBudget=40;\r#define rcp(x) 1./x\n#define Sq(x) x*x\n#define SSS_BILATERAL_FILTER true\nvec3 EvalBurleyDiffusionProfile(float r,vec3 S)\r{\rvec3 exp_13=exp2(((LOG2_E*(-1.0/3.0))*r)*S); \rvec3 expSum=exp_13*(1.+exp_13*exp_13); \rreturn (S*rcp(8.*PI))*expSum; \r}\rvec2 SampleBurleyDiffusionProfile(float u,float rcpS)\r{\ru=1.-u; \rfloat g=1.+(4.*u)*(2.*u+sqrt(1.+(4.*u)*u));\rfloat n=exp2(log2(g)*(-1.0/3.0)); \rfloat p=(g*n)*n; \rfloat c=1.+p+n; \rfloat d=(3./LOG2_E*2.)+(3./LOG2_E)*log2(u); \rfloat x=(3./LOG2_E)*log2(c)-d; \rfloat rcpExp=((c*c)*c)*rcp((4.*u)*((c*c)+(4.*u)*(4.*u)));\rfloat r=x*rcpS;\rfloat rcpPdf=(8.*PI*rcpS)*rcpExp; \rreturn vec2(r,rcpPdf);\r}\rvec3 ComputeBilateralWeight(float xy2,float z,float mmPerUnit,vec3 S,float rcpPdf)\r{\r#ifndef SSS_BILATERAL_FILTER\nz=0.;\r#endif\nfloat r=sqrt(xy2+(z*mmPerUnit)*(z*mmPerUnit));\rfloat area=rcpPdf;\r#if SSS_CLAMP_ARTIFACT\nreturn clamp(EvalBurleyDiffusionProfile(r,S)*area,0.0,1.0);\r#else\nreturn EvalBurleyDiffusionProfile(r,S)*area;\r#endif\n}\rvoid EvaluateSample(int i,int n,vec3 S,float d,vec3 centerPosVS,float mmPerUnit,float pixelsPerMm,\rfloat phase,inout vec3 totalIrradiance,inout vec3 totalWeight)\r{\rfloat scale =rcp(float(n));\rfloat offset=rcp(float(n))*0.5;\rfloat sinPhase,cosPhase;\rsinPhase=sin(phase);\rcosPhase=cos(phase);\rvec2 bdp=SampleBurleyDiffusionProfile(float(i)*scale+offset,d);\rfloat r=bdp.x;\rfloat rcpPdf=bdp.y;\rfloat phi=SampleDiskGolden(i,n).y;\rfloat sinPhi,cosPhi;\rsinPhi=sin(phi);\rcosPhi=cos(phi);\rfloat sinPsi=cosPhase*sinPhi+sinPhase*cosPhi; \rfloat cosPsi=cosPhase*cosPhi-sinPhase*sinPhi; \rvec2 vec=r*vec2(cosPsi,sinPsi);\rvec2 position; \rfloat xy2;\rposition=vUV+round((pixelsPerMm*r)*vec2(cosPsi,sinPsi))*texelSize;\rxy2 =r*r;\rvec4 textureSample=texture2D(irradianceSampler,position);\rfloat viewZ=texture2D(depthSampler,position).r;\rvec3 irradiance =textureSample.rgb;\rif (testLightingForSSS(textureSample.a))\r{\rfloat relZ=viewZ-centerPosVS.z;\rvec3 weight=ComputeBilateralWeight(xy2,relZ,mmPerUnit,S,rcpPdf);\rtotalIrradiance+=weight*irradiance;\rtotalWeight +=weight;\r}\relse\r{\r}\r}\r#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) \r{\rvec4 irradianceAndDiffusionProfile =texture2D(irradianceSampler,vUV);\rvec3 centerIrradiance=irradianceAndDiffusionProfile.rgb;\rint diffusionProfileIndex=int(round(irradianceAndDiffusionProfile.a*255.));\rfloat centerDepth =0.;\rvec4 inputColor=texture2D(textureSampler,vUV);\rbool passedStencilTest=testLightingForSSS(irradianceAndDiffusionProfile.a);\rif (passedStencilTest)\r{\rcenterDepth=texture2D(depthSampler,vUV).r;\r}\rif (!passedStencilTest) { \rgl_FragColor=inputColor;\rreturn;\r}\rfloat distScale =1.;\rvec3 S =diffusionS[diffusionProfileIndex];\rfloat d =diffusionD[diffusionProfileIndex];\rfloat filterRadius=filterRadii[diffusionProfileIndex];\rvec2 centerPosNDC=vUV;\rvec2 cornerPosNDC=vUV+0.5*texelSize;\rvec3 centerPosVS =vec3(centerPosNDC*viewportSize,1.0)*centerDepth; \rvec3 cornerPosVS =vec3(cornerPosNDC*viewportSize,1.0)*centerDepth; \rfloat mmPerUnit =1000.*(metersPerUnit*rcp(distScale));\rfloat unitsPerMm=rcp(mmPerUnit);\rfloat unitsPerPixel=2.*abs(cornerPosVS.x-centerPosVS.x);\rfloat pixelsPerMm =rcp(unitsPerPixel)*unitsPerMm;\rfloat filterArea =PI*Sq(filterRadius*pixelsPerMm);\rint sampleCount =int(filterArea*rcp(SSS_PIXELS_PER_SAMPLE));\rint sampleBudget=_SssSampleBudget;\rint texturingMode=0;\rvec3 albedo =texture2D(albedoSampler,vUV).rgb;\rif (distScale==0. || sampleCount<1)\r{\r#ifdef DEBUG_SSS_SAMPLES\nvec3 green=vec3(0.,1.,0.);\rgl_FragColor=vec4(green,1.0);\rreturn;\r#endif\ngl_FragColor=vec4(inputColor.rgb+albedo*centerIrradiance,1.0);\rreturn;\r}\r#ifdef DEBUG_SSS_SAMPLES\nvec3 red =vec3(1.,0.,0.);\rvec3 blue=vec3(0.,0.,1.);\rgl_FragColor=vec4(mix(blue,red,clamp(float(sampleCount)/float(sampleBudget),0.0,1.0)),1.0);\rreturn;\r#endif\nfloat phase=0.;\rint n=min(sampleCount,sampleBudget);\rvec3 centerWeight =vec3(0.); \rvec3 totalIrradiance=vec3(0.);\rvec3 totalWeight =vec3(0.);\rfor (int i=0; i<n; i++)\r{\rEvaluateSample(i,n,S,d,centerPosVS,mmPerUnit,pixelsPerMm,\rphase,totalIrradiance,totalWeight);\r}\rtotalWeight=max(totalWeight,HALF_MIN);\rgl_FragColor=vec4(inputColor.rgb+albedo*max(totalIrradiance/totalWeight,vec3(0.0)),1.);\r}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const subSurfaceScatteringPixelShader = { name, shader };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}