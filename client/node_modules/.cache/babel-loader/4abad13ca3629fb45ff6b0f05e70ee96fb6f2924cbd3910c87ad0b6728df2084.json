{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as WebGPUConstants from \"./webgpuConstants.js\";\nimport { WebGPUQuerySet } from \"./webgpuQuerySet.js\";\n/** @internal */\nexport class WebGPUOcclusionQuery {\n  constructor(engine, device, bufferManager, startCount = 50, incrementCount = 100) {\n    this._availableIndices = [];\n    this._engine = engine;\n    this._device = device;\n    this._bufferManager = bufferManager;\n    this._frameLastBuffer = -1;\n    this._currentTotalIndices = 0;\n    this._countIncrement = incrementCount;\n    this._allocateNewIndices(startCount);\n  }\n  get querySet() {\n    return this._querySet.querySet;\n  }\n  get hasQueries() {\n    return this._currentTotalIndices !== this._availableIndices.length;\n  }\n  get canBeginQuery() {\n    const passIndex = this._engine._getCurrentRenderPassIndex();\n    switch (passIndex) {\n      case 0:\n        {\n          return this._engine._mainRenderPassWrapper.renderPassDescriptor.occlusionQuerySet !== undefined;\n        }\n      case 1:\n        {\n          return this._engine._rttRenderPassWrapper.renderPassDescriptor.occlusionQuerySet !== undefined;\n        }\n    }\n    return false;\n  }\n  createQuery() {\n    if (this._availableIndices.length === 0) {\n      this._allocateNewIndices();\n    }\n    const index = this._availableIndices[this._availableIndices.length - 1];\n    this._availableIndices.length--;\n    return index;\n  }\n  deleteQuery(index) {\n    this._availableIndices[this._availableIndices.length - 1] = index;\n  }\n  isQueryResultAvailable(index) {\n    this._retrieveQueryBuffer();\n    return !!this._lastBuffer && index < this._lastBuffer.length;\n  }\n  getQueryResult(index) {\n    var _a, _b;\n    return Number((_b = (_a = this._lastBuffer) === null || _a === void 0 ? void 0 : _a[index]) !== null && _b !== void 0 ? _b : -1);\n  }\n  _retrieveQueryBuffer() {\n    if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {\n      return;\n    }\n    if (this._frameLastBuffer !== this._engine.frameId) {\n      this._frameLastBuffer = this._engine.frameId;\n      this._querySet.readValues(0, this._currentTotalIndices).then(arrayBuffer => {\n        this._lastBuffer = arrayBuffer;\n      });\n    }\n  }\n  _allocateNewIndices(numIndices) {\n    numIndices = numIndices !== null && numIndices !== void 0 ? numIndices : this._countIncrement;\n    this._delayQuerySetDispose();\n    for (let i = 0; i < numIndices; ++i) {\n      this._availableIndices.push(this._currentTotalIndices + i);\n    }\n    this._currentTotalIndices += numIndices;\n    this._querySet = new WebGPUQuerySet(this._currentTotalIndices, WebGPUConstants.QueryType.Occlusion, this._device, this._bufferManager, false);\n  }\n  _delayQuerySetDispose() {\n    const querySet = this._querySet;\n    if (querySet) {\n      // Wait a bit before disposing of the queryset, in case some queries are still running for it\n      setTimeout(() => querySet.dispose, 1000);\n    }\n  }\n  dispose() {\n    var _a;\n    (_a = this._querySet) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._availableIndices.length = 0;\n  }\n}","map":{"version":3,"mappings":"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","names":["WebGPUConstants","WebGPUQuerySet","WebGPUOcclusionQuery","constructor","engine","device","bufferManager","startCount","incrementCount","_engine","_device","_bufferManager","_frameLastBuffer","_currentTotalIndices","_countIncrement","_allocateNewIndices","querySet","_querySet","hasQueries","_availableIndices","length","canBeginQuery","passIndex","_getCurrentRenderPassIndex","_mainRenderPassWrapper","renderPassDescriptor","occlusionQuerySet","undefined","_rttRenderPassWrapper","createQuery","index","deleteQuery","isQueryResultAvailable","_retrieveQueryBuffer","_lastBuffer","getQueryResult","Number","frameId","readValues","then","arrayBuffer","numIndices","_delayQuerySetDispose","i","push","QueryType","Occlusion","setTimeout","dispose"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuOcclusionQuery.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { WebGPUEngine } from \"../webgpuEngine\";\r\nimport type { WebGPUBufferManager } from \"./webgpuBufferManager\";\r\nimport * as WebGPUConstants from \"./webgpuConstants\";\r\nimport { WebGPUQuerySet } from \"./webgpuQuerySet\";\r\n\r\n/** @internal */\r\nexport class WebGPUOcclusionQuery {\r\n    private _engine: WebGPUEngine;\r\n    private _device: GPUDevice;\r\n    private _bufferManager: WebGPUBufferManager;\r\n\r\n    private _currentTotalIndices: number;\r\n    private _countIncrement: number;\r\n    private _querySet: WebGPUQuerySet;\r\n    private _availableIndices: number[] = [];\r\n    private _lastBuffer: Nullable<BigUint64Array>;\r\n    private _frameLastBuffer: number;\r\n\r\n    public get querySet(): GPUQuerySet {\r\n        return this._querySet.querySet;\r\n    }\r\n\r\n    public get hasQueries(): boolean {\r\n        return this._currentTotalIndices !== this._availableIndices.length;\r\n    }\r\n\r\n    public get canBeginQuery(): boolean {\r\n        const passIndex = this._engine._getCurrentRenderPassIndex();\r\n        switch (passIndex) {\r\n            case 0: {\r\n                return this._engine._mainRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet !== undefined;\r\n            }\r\n            case 1: {\r\n                return this._engine._rttRenderPassWrapper.renderPassDescriptor!.occlusionQuerySet !== undefined;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    constructor(engine: WebGPUEngine, device: GPUDevice, bufferManager: WebGPUBufferManager, startCount = 50, incrementCount = 100) {\r\n        this._engine = engine;\r\n        this._device = device;\r\n        this._bufferManager = bufferManager;\r\n\r\n        this._frameLastBuffer = -1;\r\n        this._currentTotalIndices = 0;\r\n        this._countIncrement = incrementCount;\r\n\r\n        this._allocateNewIndices(startCount);\r\n    }\r\n\r\n    public createQuery(): number {\r\n        if (this._availableIndices.length === 0) {\r\n            this._allocateNewIndices();\r\n        }\r\n\r\n        const index = this._availableIndices[this._availableIndices.length - 1];\r\n        this._availableIndices.length--;\r\n\r\n        return index;\r\n    }\r\n\r\n    public deleteQuery(index: number): void {\r\n        this._availableIndices[this._availableIndices.length - 1] = index;\r\n    }\r\n\r\n    public isQueryResultAvailable(index: number): boolean {\r\n        this._retrieveQueryBuffer();\r\n\r\n        return !!this._lastBuffer && index < this._lastBuffer.length;\r\n    }\r\n\r\n    public getQueryResult(index: number): number {\r\n        return Number(this._lastBuffer?.[index] ?? -1);\r\n    }\r\n\r\n    private _retrieveQueryBuffer(): void {\r\n        if (this._lastBuffer && this._frameLastBuffer === this._engine.frameId) {\r\n            return;\r\n        }\r\n\r\n        if (this._frameLastBuffer !== this._engine.frameId) {\r\n            this._frameLastBuffer = this._engine.frameId;\r\n            this._querySet.readValues(0, this._currentTotalIndices).then((arrayBuffer) => {\r\n                this._lastBuffer = arrayBuffer;\r\n            });\r\n        }\r\n    }\r\n\r\n    private _allocateNewIndices(numIndices?: number): void {\r\n        numIndices = numIndices ?? this._countIncrement;\r\n\r\n        this._delayQuerySetDispose();\r\n\r\n        for (let i = 0; i < numIndices; ++i) {\r\n            this._availableIndices.push(this._currentTotalIndices + i);\r\n        }\r\n\r\n        this._currentTotalIndices += numIndices;\r\n        this._querySet = new WebGPUQuerySet(this._currentTotalIndices, WebGPUConstants.QueryType.Occlusion, this._device, this._bufferManager, false);\r\n    }\r\n\r\n    private _delayQuerySetDispose(): void {\r\n        const querySet = this._querySet;\r\n        if (querySet) {\r\n            // Wait a bit before disposing of the queryset, in case some queries are still running for it\r\n            setTimeout(() => querySet.dispose, 1000);\r\n        }\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._querySet?.dispose();\r\n        this._availableIndices.length = 0;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}