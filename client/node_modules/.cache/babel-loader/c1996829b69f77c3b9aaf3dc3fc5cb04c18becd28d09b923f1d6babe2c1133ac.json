{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { Vector2 } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport \"../Shaders/glowMapMerge.fragment.js\";\nimport \"../Shaders/glowMapMerge.vertex.js\";\nimport \"../Layers/effectLayerSceneComponent.js\";\nAbstractScene.prototype.getGlowLayerByName = function (name) {\n  var _a;\n  for (let index = 0; index < ((_a = this.effectLayers) === null || _a === void 0 ? void 0 : _a.length); index++) {\n    if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\n      return this.effectLayers[index];\n    }\n  }\n  return null;\n};\n/**\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\n *\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\n *\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\n */\nexport class GlowLayer extends EffectLayer {\n  /**\n   * Instantiates a new glow Layer and references it to the scene.\n   * @param name The name of the layer\n   * @param scene The scene to use the layer in\n   * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\n   */\n  constructor(name, scene, options) {\n    super(name, scene);\n    this._intensity = 1.0;\n    this._includedOnlyMeshes = [];\n    this._excludedMeshes = [];\n    this._meshesUsingTheirOwnMaterials = [];\n    this.neutralColor = new Color4(0, 0, 0, 1);\n    // Adapt options\n    this._options = {\n      mainTextureRatio: GlowLayer.DefaultTextureRatio,\n      blurKernelSize: 32,\n      mainTextureFixedSize: undefined,\n      camera: null,\n      mainTextureSamples: 1,\n      renderingGroupId: -1,\n      ldrMerge: false,\n      alphaBlendingMode: 1,\n      mainTextureType: 0,\n      ...options\n    };\n    // Initialize the layer\n    this._init({\n      alphaBlendingMode: this._options.alphaBlendingMode,\n      camera: this._options.camera,\n      mainTextureFixedSize: this._options.mainTextureFixedSize,\n      mainTextureRatio: this._options.mainTextureRatio,\n      renderingGroupId: this._options.renderingGroupId,\n      mainTextureType: this._options.mainTextureType\n    });\n  }\n  /**\n   * Sets the kernel size of the blur.\n   */\n  set blurKernelSize(value) {\n    if (value === this._options.blurKernelSize) {\n      return;\n    }\n    this._options.blurKernelSize = value;\n    const effectiveKernel = this._getEffectiveBlurKernelSize();\n    this._horizontalBlurPostprocess1.kernel = effectiveKernel;\n    this._verticalBlurPostprocess1.kernel = effectiveKernel;\n    this._horizontalBlurPostprocess2.kernel = effectiveKernel;\n    this._verticalBlurPostprocess2.kernel = effectiveKernel;\n  }\n  /**\n   * Gets the kernel size of the blur.\n   */\n  get blurKernelSize() {\n    return this._options.blurKernelSize;\n  }\n  /**\n   * Sets the glow intensity.\n   */\n  set intensity(value) {\n    this._intensity = value;\n  }\n  /**\n   * Gets the glow intensity.\n   */\n  get intensity() {\n    return this._intensity;\n  }\n  /**\n   * Get the effect name of the layer.\n   * @returns The effect name\n   */\n  getEffectName() {\n    return GlowLayer.EffectName;\n  }\n  /**\n   * Create the merge effect. This is the shader use to blit the information back\n   * to the main canvas at the end of the scene rendering.\n   */\n  _createMergeEffect() {\n    let defines = \"#define EMISSIVE \\n\";\n    if (this._options.ldrMerge) {\n      defines += \"#define LDR \\n\";\n    }\n    // Effect\n    return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], defines);\n  }\n  /**\n   * Creates the render target textures and post processes used in the glow layer.\n   */\n  _createTextureAndPostProcesses() {\n    let blurTextureWidth = this._mainTextureDesiredSize.width;\n    let blurTextureHeight = this._mainTextureDesiredSize.height;\n    blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\n    blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\n    let textureType = 0;\n    if (this._engine.getCaps().textureHalfFloatRender) {\n      textureType = 2;\n    } else {\n      textureType = 0;\n    }\n    this._blurTexture1 = new RenderTargetTexture(\"GlowLayerBlurRTT\", {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, this._scene, false, true, textureType);\n    this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._blurTexture1.renderParticles = false;\n    this._blurTexture1.ignoreCameraViewport = true;\n    const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\n    const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\n    this._blurTexture2 = new RenderTargetTexture(\"GlowLayerBlurRTT2\", {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, this._scene, false, true, textureType);\n    this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\n    this._blurTexture2.renderParticles = false;\n    this._blurTexture2.ignoreCameraViewport = true;\n    this._textures = [this._blurTexture1, this._blurTexture2];\n    const effectiveKernel = this._getEffectiveBlurKernelSize();\n    this._horizontalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerHBP1\", new Vector2(1.0, 0), effectiveKernel, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess1.width = blurTextureWidth;\n    this._horizontalBlurPostprocess1.height = blurTextureHeight;\n    this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\n    this._horizontalBlurPostprocess1.onApplyObservable.add(effect => {\n      effect.setTexture(\"textureSampler\", this._mainTexture);\n    });\n    this._verticalBlurPostprocess1 = new BlurPostProcess(\"GlowLayerVBP1\", new Vector2(0, 1.0), effectiveKernel, {\n      width: blurTextureWidth,\n      height: blurTextureHeight\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerHBP2\", new Vector2(1.0, 0), effectiveKernel, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._horizontalBlurPostprocess2.width = blurTextureWidth2;\n    this._horizontalBlurPostprocess2.height = blurTextureHeight2;\n    this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\n    this._horizontalBlurPostprocess2.onApplyObservable.add(effect => {\n      effect.setTexture(\"textureSampler\", this._blurTexture1);\n    });\n    this._verticalBlurPostprocess2 = new BlurPostProcess(\"GlowLayerVBP2\", new Vector2(0, 1.0), effectiveKernel, {\n      width: blurTextureWidth2,\n      height: blurTextureHeight2\n    }, null, Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, textureType);\n    this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\n    this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\n    this._mainTexture.samples = this._options.mainTextureSamples;\n    this._mainTexture.onAfterUnbindObservable.add(() => {\n      const internalTexture = this._blurTexture1.renderTarget;\n      if (internalTexture) {\n        this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\n        const internalTexture2 = this._blurTexture2.renderTarget;\n        if (internalTexture2) {\n          this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\n        }\n        this._engine.unBindFramebuffer(internalTexture2 !== null && internalTexture2 !== void 0 ? internalTexture2 : internalTexture, true);\n      }\n    });\n    // Prevent autoClear.\n    this._postProcesses.map(pp => {\n      pp.autoClear = false;\n    });\n  }\n  /**\n   * @returns The blur kernel size used by the glow.\n   * Note: The value passed in the options is divided by 2 for back compatibility.\n   */\n  _getEffectiveBlurKernelSize() {\n    return this._options.blurKernelSize / 2;\n  }\n  /**\n   * Checks for the readiness of the element composing the layer.\n   * @param subMesh the mesh to check for\n   * @param useInstances specify whether or not to use instances to render the mesh\n   * @returns true if ready otherwise, false\n   */\n  isReady(subMesh, useInstances) {\n    const material = subMesh.getMaterial();\n    const mesh = subMesh.getRenderingMesh();\n    if (!material || !mesh) {\n      return false;\n    }\n    const emissiveTexture = material.emissiveTexture;\n    return super._isReady(subMesh, useInstances, emissiveTexture);\n  }\n  /**\n   * Returns whether or not the layer needs stencil enabled during the mesh rendering.\n   */\n  needStencil() {\n    return false;\n  }\n  /**\n   * Returns true if the mesh can be rendered, otherwise false.\n   * @param mesh The mesh to render\n   * @param material The material used on the mesh\n   * @returns true if it can be rendered otherwise false\n   */\n  _canRenderMesh(mesh, material) {\n    return true;\n  }\n  /**\n   * Implementation specific of rendering the generating effect on the main canvas.\n   * @param effect The effect used to render through\n   */\n  _internalRender(effect) {\n    // Texture\n    effect.setTexture(\"textureSampler\", this._blurTexture1);\n    effect.setTexture(\"textureSampler2\", this._blurTexture2);\n    effect.setFloat(\"offset\", this._intensity);\n    // Cache\n    const engine = this._engine;\n    const previousStencilBuffer = engine.getStencilBuffer();\n    // Draw order\n    engine.setStencilBuffer(false);\n    engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n    // Draw order\n    engine.setStencilBuffer(previousStencilBuffer);\n  }\n  /**\n   * Sets the required values for both the emissive texture and and the main color.\n   * @param mesh\n   * @param subMesh\n   * @param material\n   */\n  _setEmissiveTextureAndColor(mesh, subMesh, material) {\n    var _a;\n    let textureLevel = 1.0;\n    if (this.customEmissiveTextureSelector) {\n      this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\n    } else {\n      if (material) {\n        this._emissiveTextureAndColor.texture = material.emissiveTexture;\n        if (this._emissiveTextureAndColor.texture) {\n          textureLevel = this._emissiveTextureAndColor.texture.level;\n        }\n      } else {\n        this._emissiveTextureAndColor.texture = null;\n      }\n    }\n    if (this.customEmissiveColorSelector) {\n      this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\n    } else {\n      if (material.emissiveColor) {\n        const emissiveIntensity = (_a = material.emissiveIntensity) !== null && _a !== void 0 ? _a : 1;\n        textureLevel *= emissiveIntensity;\n        this._emissiveTextureAndColor.color.set(material.emissiveColor.r * textureLevel, material.emissiveColor.g * textureLevel, material.emissiveColor.b * textureLevel, material.alpha);\n      } else {\n        this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\n      }\n    }\n  }\n  /**\n   * Returns true if the mesh should render, otherwise false.\n   * @param mesh The mesh to render\n   * @returns true if it should render otherwise false\n   */\n  _shouldRenderMesh(mesh) {\n    return this.hasMesh(mesh);\n  }\n  /**\n   * Adds specific effects defines.\n   * @param defines The defines to add specifics to.\n   */\n  _addCustomEffectDefines(defines) {\n    defines.push(\"#define GLOW\");\n  }\n  /**\n   * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\n   * @param mesh The mesh to exclude from the glow layer\n   */\n  addExcludedMesh(mesh) {\n    if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._excludedMeshes.push(mesh.uniqueId);\n    }\n  }\n  /**\n   * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\n   * @param mesh The mesh to remove\n   */\n  removeExcludedMesh(mesh) {\n    const index = this._excludedMeshes.indexOf(mesh.uniqueId);\n    if (index !== -1) {\n      this._excludedMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\n   * @param mesh The mesh to include in the glow layer\n   */\n  addIncludedOnlyMesh(mesh) {\n    if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\n      this._includedOnlyMeshes.push(mesh.uniqueId);\n    }\n  }\n  /**\n   * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\n   * @param mesh The mesh to remove\n   */\n  removeIncludedOnlyMesh(mesh) {\n    const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\n    if (index !== -1) {\n      this._includedOnlyMeshes.splice(index, 1);\n    }\n  }\n  /**\n   * Determine if a given mesh will be used in the glow layer\n   * @param mesh The mesh to test\n   * @returns true if the mesh will be highlighted by the current glow layer\n   */\n  hasMesh(mesh) {\n    if (!super.hasMesh(mesh)) {\n      return false;\n    }\n    // Included Mesh\n    if (this._includedOnlyMeshes.length) {\n      return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\n    }\n    // Excluded Mesh\n    if (this._excludedMeshes.length) {\n      return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\n    }\n    return true;\n  }\n  /**\n   * Defines whether the current material of the mesh should be use to render the effect.\n   * @param mesh defines the current mesh to render\n   */\n  _useMeshMaterial(mesh) {\n    if (this._meshesUsingTheirOwnMaterials.length == 0) {\n      return false;\n    }\n    return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\n  }\n  /**\n   * Add a mesh to be rendered through its own material and not with emissive only.\n   * @param mesh The mesh for which we need to use its material\n   */\n  referenceMeshToUseItsOwnMaterial(mesh) {\n    mesh.resetDrawCache(this._mainTexture.renderPassId);\n    this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\n    mesh.onDisposeObservable.add(() => {\n      this._disposeMesh(mesh);\n    });\n  }\n  /**\n   * Remove a mesh from being rendered through its own material and not with emissive only.\n   * @param mesh The mesh for which we need to not use its material\n   */\n  unReferenceMeshFromUsingItsOwnMaterial(mesh) {\n    let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    while (index >= 0) {\n      this._meshesUsingTheirOwnMaterials.splice(index, 1);\n      index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\n    }\n    mesh.resetDrawCache(this._mainTexture.renderPassId);\n  }\n  /**\n   * Free any resources and references associated to a mesh.\n   * Internal use\n   * @param mesh The mesh to free.\n   * @internal\n   */\n  _disposeMesh(mesh) {\n    this.removeIncludedOnlyMesh(mesh);\n    this.removeExcludedMesh(mesh);\n  }\n  /**\n   * Gets the class name of the effect layer\n   * @returns the string with the class name of the effect layer\n   */\n  getClassName() {\n    return \"GlowLayer\";\n  }\n  /**\n   * Serializes this glow layer\n   * @returns a serialized glow layer object\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.customType = \"BABYLON.GlowLayer\";\n    let index;\n    // Included meshes\n    serializationObject.includedMeshes = [];\n    if (this._includedOnlyMeshes.length) {\n      for (index = 0; index < this._includedOnlyMeshes.length; index++) {\n        const mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);\n        if (mesh) {\n          serializationObject.includedMeshes.push(mesh.id);\n        }\n      }\n    }\n    // Excluded meshes\n    serializationObject.excludedMeshes = [];\n    if (this._excludedMeshes.length) {\n      for (index = 0; index < this._excludedMeshes.length; index++) {\n        const mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);\n        if (mesh) {\n          serializationObject.excludedMeshes.push(mesh.id);\n        }\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a Glow Layer from parsed glow layer data\n   * @param parsedGlowLayer defines glow layer data\n   * @param scene defines the current scene\n   * @param rootUrl defines the root URL containing the glow layer information\n   * @returns a parsed Glow Layer\n   */\n  static Parse(parsedGlowLayer, scene, rootUrl) {\n    const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\n    let index;\n    // Excluded meshes\n    for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\n      const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\n      if (mesh) {\n        gl.addExcludedMesh(mesh);\n      }\n    }\n    // Included meshes\n    for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\n      const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\n      if (mesh) {\n        gl.addIncludedOnlyMesh(mesh);\n      }\n    }\n    return gl;\n  }\n}\n/**\n * Effect Name of the layer.\n */\nGlowLayer.EffectName = \"GlowLayer\";\n/**\n * The default blur kernel size used for the glow.\n */\nGlowLayer.DefaultBlurKernelSize = 32;\n/**\n * The default texture size ratio used for the glow.\n */\nGlowLayer.DefaultTextureRatio = 0.5;\n__decorate([serialize()], GlowLayer.prototype, \"blurKernelSize\", null);\n__decorate([serialize()], GlowLayer.prototype, \"intensity\", null);\n__decorate([serialize(\"options\")], GlowLayer.prototype, \"_options\", void 0);\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);","map":{"version":3,"mappings":"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","names":["serialize","SerializationHelper","Vector2","VertexBuffer","Texture","RenderTargetTexture","Material","BlurPostProcess","EffectLayer","AbstractScene","RegisterClass","Engine","Color4","prototype","getGlowLayerByName","name","index","effectLayers","length","getEffectName","GlowLayer","EffectName","constructor","scene","options","neutralColor","_options","mainTextureRatio","DefaultTextureRatio","blurKernelSize","mainTextureFixedSize","undefined","camera","mainTextureSamples","renderingGroupId","ldrMerge","alphaBlendingMode","mainTextureType","_init","value","effectiveKernel","_getEffectiveBlurKernelSize","_horizontalBlurPostprocess1","kernel","_verticalBlurPostprocess1","_horizontalBlurPostprocess2","_verticalBlurPostprocess2","intensity","_intensity","_createMergeEffect","defines","_engine","createEffect","PositionKind","_createTextureAndPostProcesses","blurTextureWidth","_mainTextureDesiredSize","width","blurTextureHeight","height","needPOTTextures","GetExponentOfTwo","_maxSize","textureType","getCaps","textureHalfFloatRender","_blurTexture1","_scene","wrapU","CLAMP_ADDRESSMODE","wrapV","updateSamplingMode","BILINEAR_SAMPLINGMODE","renderParticles","ignoreCameraViewport","blurTextureWidth2","Math","floor","blurTextureHeight2","_blurTexture2","_textures","getEngine","externalTextureSamplerBinding","onApplyObservable","add","effect","setTexture","_mainTexture","_postProcesses","_postProcesses1","_postProcesses2","samples","onAfterUnbindObservable","internalTexture","renderTarget","postProcessManager","directRender","internalTexture2","unBindFramebuffer","map","pp","autoClear","isReady","subMesh","useInstances","material","getMaterial","mesh","getRenderingMesh","emissiveTexture","_isReady","needStencil","_canRenderMesh","_internalRender","setFloat","engine","previousStencilBuffer","getStencilBuffer","setStencilBuffer","drawElementsType","TriangleFillMode","_setEmissiveTextureAndColor","textureLevel","customEmissiveTextureSelector","_emissiveTextureAndColor","texture","level","customEmissiveColorSelector","color","emissiveColor","emissiveIntensity","set","r","g","b","alpha","a","_shouldRenderMesh","hasMesh","_addCustomEffectDefines","push","addExcludedMesh","_excludedMeshes","indexOf","uniqueId","removeExcludedMesh","splice","addIncludedOnlyMesh","_includedOnlyMeshes","removeIncludedOnlyMesh","_useMeshMaterial","_meshesUsingTheirOwnMaterials","referenceMeshToUseItsOwnMaterial","resetDrawCache","renderPassId","onDisposeObservable","_disposeMesh","unReferenceMeshFromUsingItsOwnMaterial","getClassName","serializationObject","Serialize","customType","includedMeshes","getMeshByUniqueId","id","excludedMeshes","Parse","parsedGlowLayer","rootUrl","gl","getMeshById","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Layers/glowLayer.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { BlurPostProcess } from \"../PostProcesses/blurPostProcess\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { PBRMaterial } from \"../Materials/PBR/pbrMaterial\";\r\n\r\nimport \"../Shaders/glowMapMerge.fragment\";\r\nimport \"../Shaders/glowMapMerge.vertex\";\r\nimport \"../Layers/effectLayerSceneComponent\";\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * Return the first glow layer of the scene with a given name.\r\n         * @param name The name of the glow layer to look for.\r\n         * @returns The glow layer if found otherwise null.\r\n         */\r\n        getGlowLayerByName(name: string): Nullable<GlowLayer>;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.getGlowLayerByName = function (name: string): Nullable<GlowLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === GlowLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as GlowLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Glow layer options. This helps customizing the behaviour\r\n * of the glow layer.\r\n */\r\nexport interface IGlowLayerOptions {\r\n    /**\r\n     * Multiplication factor apply to the canvas size to compute the render target size\r\n     * used to generated the glowing objects (the smaller the faster). Default: 0.5\r\n     */\r\n    mainTextureRatio: number;\r\n\r\n    /**\r\n     * Enforces a fixed size texture to ensure resize independent blur. Default: undefined\r\n     */\r\n    mainTextureFixedSize?: number;\r\n\r\n    /**\r\n     * How big is the kernel of the blur texture. Default: 32\r\n     */\r\n    blurKernelSize: number;\r\n\r\n    /**\r\n     * The camera attached to the layer. Default: null\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * Enable MSAA by choosing the number of samples. Default: 1\r\n     */\r\n    mainTextureSamples?: number;\r\n\r\n    /**\r\n     * The rendering group to draw the layer in. Default: -1\r\n     */\r\n    renderingGroupId: number;\r\n\r\n    /**\r\n     * Forces the merge step to be done in ldr (clamp values > 1). Default: false\r\n     */\r\n    ldrMerge?: boolean;\r\n\r\n    /**\r\n     * Defines the blend mode used by the merge. Default: ALPHA_ADD\r\n     */\r\n    alphaBlendingMode?: number;\r\n\r\n    /**\r\n     * The type of the main texture. Default: TEXTURETYPE_UNSIGNED_INT\r\n     */\r\n    mainTextureType: number;\r\n}\r\n\r\n/**\r\n * The glow layer Helps adding a glow effect around the emissive parts of a mesh.\r\n *\r\n * Once instantiated in a scene, by default, all the emissive meshes will glow.\r\n *\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n */\r\nexport class GlowLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the layer.\r\n     */\r\n    public static readonly EffectName = \"GlowLayer\";\r\n\r\n    /**\r\n     * The default blur kernel size used for the glow.\r\n     */\r\n    public static DefaultBlurKernelSize = 32;\r\n\r\n    /**\r\n     * The default texture size ratio used for the glow.\r\n     */\r\n    public static DefaultTextureRatio = 0.5;\r\n\r\n    /**\r\n     * Sets the kernel size of the blur.\r\n     */\r\n    public set blurKernelSize(value: number) {\r\n        if (value === this._options.blurKernelSize) {\r\n            return;\r\n        }\r\n\r\n        this._options.blurKernelSize = value;\r\n\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess1.kernel = effectiveKernel;\r\n        this._horizontalBlurPostprocess2.kernel = effectiveKernel;\r\n        this._verticalBlurPostprocess2.kernel = effectiveKernel;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size of the blur.\r\n     */\r\n    @serialize()\r\n    public get blurKernelSize(): number {\r\n        return this._options.blurKernelSize;\r\n    }\r\n\r\n    /**\r\n     * Sets the glow intensity.\r\n     */\r\n    public set intensity(value: number) {\r\n        this._intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the glow intensity.\r\n     */\r\n    @serialize()\r\n    public get intensity(): number {\r\n        return this._intensity;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    private _options: IGlowLayerOptions;\r\n\r\n    private _intensity: number = 1.0;\r\n    private _horizontalBlurPostprocess1: BlurPostProcess;\r\n    private _verticalBlurPostprocess1: BlurPostProcess;\r\n    private _horizontalBlurPostprocess2: BlurPostProcess;\r\n    private _verticalBlurPostprocess2: BlurPostProcess;\r\n    private _blurTexture1: RenderTargetTexture;\r\n    private _blurTexture2: RenderTargetTexture;\r\n    private _postProcesses1: PostProcess[];\r\n    private _postProcesses2: PostProcess[];\r\n\r\n    private _includedOnlyMeshes: number[] = [];\r\n    private _excludedMeshes: number[] = [];\r\n    private _meshesUsingTheirOwnMaterials: number[] = [];\r\n\r\n    /**\r\n     * Callback used to let the user override the color selection on a per mesh basis\r\n     */\r\n    public customEmissiveColorSelector: (mesh: Mesh, subMesh: SubMesh, material: Material, result: Color4) => void;\r\n    /**\r\n     * Callback used to let the user override the texture selection on a per mesh basis\r\n     */\r\n    public customEmissiveTextureSelector: (mesh: Mesh, subMesh: SubMesh, material: Material) => Texture;\r\n\r\n    /**\r\n     * Instantiates a new glow Layer and references it to the scene.\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)\r\n     */\r\n    constructor(name: string, scene?: Scene, options?: Partial<IGlowLayerOptions>) {\r\n        super(name, scene);\r\n        this.neutralColor = new Color4(0, 0, 0, 1);\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: GlowLayer.DefaultTextureRatio,\r\n            blurKernelSize: 32,\r\n            mainTextureFixedSize: undefined,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            ldrMerge: false,\r\n            alphaBlendingMode: Constants.ALPHA_ADD,\r\n            mainTextureType: Constants.TEXTURETYPE_UNSIGNED_INT,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init({\r\n            alphaBlendingMode: this._options.alphaBlendingMode,\r\n            camera: this._options.camera,\r\n            mainTextureFixedSize: this._options.mainTextureFixedSize,\r\n            mainTextureRatio: this._options.mainTextureRatio,\r\n            renderingGroupId: this._options.renderingGroupId,\r\n            mainTextureType: this._options.mainTextureType,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return GlowLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        let defines = \"#define EMISSIVE \\n\";\r\n        if (this._options.ldrMerge) {\r\n            defines += \"#define LDR \\n\";\r\n        }\r\n\r\n        // Effect\r\n        return this._engine.createEffect(\"glowMapMerge\", [VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\", \"textureSampler2\"], defines);\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the glow layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        let blurTextureWidth = this._mainTextureDesiredSize.width;\r\n        let blurTextureHeight = this._mainTextureDesiredSize.height;\r\n        blurTextureWidth = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureWidth, this._maxSize) : blurTextureWidth;\r\n        blurTextureHeight = this._engine.needPOTTextures ? Engine.GetExponentOfTwo(blurTextureHeight, this._maxSize) : blurTextureHeight;\r\n\r\n        let textureType = 0;\r\n        if (this._engine.getCaps().textureHalfFloatRender) {\r\n            textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        } else {\r\n            textureType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        this._blurTexture1 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT\",\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture1.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture1.renderParticles = false;\r\n        this._blurTexture1.ignoreCameraViewport = true;\r\n\r\n        const blurTextureWidth2 = Math.floor(blurTextureWidth / 2);\r\n        const blurTextureHeight2 = Math.floor(blurTextureHeight / 2);\r\n\r\n        this._blurTexture2 = new RenderTargetTexture(\r\n            \"GlowLayerBlurRTT2\",\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            this._scene,\r\n            false,\r\n            true,\r\n            textureType\r\n        );\r\n        this._blurTexture2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._blurTexture2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);\r\n        this._blurTexture2.renderParticles = false;\r\n        this._blurTexture2.ignoreCameraViewport = true;\r\n\r\n        this._textures = [this._blurTexture1, this._blurTexture2];\r\n\r\n        const effectiveKernel = this._getEffectiveBlurKernelSize();\r\n        this._horizontalBlurPostprocess1 = new BlurPostProcess(\r\n            \"GlowLayerHBP1\",\r\n            new Vector2(1.0, 0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n        this._horizontalBlurPostprocess1.width = blurTextureWidth;\r\n        this._horizontalBlurPostprocess1.height = blurTextureHeight;\r\n        this._horizontalBlurPostprocess1.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess1.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._mainTexture);\r\n        });\r\n\r\n        this._verticalBlurPostprocess1 = new BlurPostProcess(\r\n            \"GlowLayerVBP1\",\r\n            new Vector2(0, 1.0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth,\r\n                height: blurTextureHeight,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n\r\n        this._horizontalBlurPostprocess2 = new BlurPostProcess(\r\n            \"GlowLayerHBP2\",\r\n            new Vector2(1.0, 0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n        this._horizontalBlurPostprocess2.width = blurTextureWidth2;\r\n        this._horizontalBlurPostprocess2.height = blurTextureHeight2;\r\n        this._horizontalBlurPostprocess2.externalTextureSamplerBinding = true;\r\n        this._horizontalBlurPostprocess2.onApplyObservable.add((effect) => {\r\n            effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        });\r\n\r\n        this._verticalBlurPostprocess2 = new BlurPostProcess(\r\n            \"GlowLayerVBP2\",\r\n            new Vector2(0, 1.0),\r\n            effectiveKernel,\r\n            {\r\n                width: blurTextureWidth2,\r\n                height: blurTextureHeight2,\r\n            },\r\n            null,\r\n            Texture.BILINEAR_SAMPLINGMODE,\r\n            this._scene.getEngine(),\r\n            false,\r\n            textureType\r\n        );\r\n\r\n        this._postProcesses = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1, this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n        this._postProcesses1 = [this._horizontalBlurPostprocess1, this._verticalBlurPostprocess1];\r\n        this._postProcesses2 = [this._horizontalBlurPostprocess2, this._verticalBlurPostprocess2];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples!;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            const internalTexture = this._blurTexture1.renderTarget;\r\n            if (internalTexture) {\r\n                this._scene.postProcessManager.directRender(this._postProcesses1, internalTexture, true);\r\n\r\n                const internalTexture2 = this._blurTexture2.renderTarget;\r\n                if (internalTexture2) {\r\n                    this._scene.postProcessManager.directRender(this._postProcesses2, internalTexture2, true);\r\n                }\r\n                this._engine.unBindFramebuffer(internalTexture2 ?? internalTexture, true);\r\n            }\r\n        });\r\n\r\n        // Prevent autoClear.\r\n        this._postProcesses.map((pp) => {\r\n            pp.autoClear = false;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @returns The blur kernel size used by the glow.\r\n     * Note: The value passed in the options is divided by 2 for back compatibility.\r\n     */\r\n    private _getEffectiveBlurKernelSize() {\r\n        return this._options.blurKernelSize / 2;\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const material = subMesh.getMaterial();\r\n        const mesh = subMesh.getRenderingMesh();\r\n\r\n        if (!material || !mesh) {\r\n            return false;\r\n        }\r\n\r\n        const emissiveTexture = (<any>material).emissiveTexture;\r\n        return super._isReady(subMesh, useInstances, emissiveTexture);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     */\r\n    protected _internalRender(effect: Effect): void {\r\n        // Texture\r\n        effect.setTexture(\"textureSampler\", this._blurTexture1);\r\n        effect.setTexture(\"textureSampler2\", this._blurTexture2);\r\n        effect.setFloat(\"offset\", this._intensity);\r\n\r\n        // Cache\r\n        const engine = this._engine;\r\n        const previousStencilBuffer = engine.getStencilBuffer();\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(false);\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n\r\n        // Draw order\r\n        engine.setStencilBuffer(previousStencilBuffer);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        let textureLevel = 1.0;\r\n\r\n        if (this.customEmissiveTextureSelector) {\r\n            this._emissiveTextureAndColor.texture = this.customEmissiveTextureSelector(mesh, subMesh, material);\r\n        } else {\r\n            if (material) {\r\n                this._emissiveTextureAndColor.texture = (<any>material).emissiveTexture;\r\n                if (this._emissiveTextureAndColor.texture) {\r\n                    textureLevel = this._emissiveTextureAndColor.texture.level;\r\n                }\r\n            } else {\r\n                this._emissiveTextureAndColor.texture = null;\r\n            }\r\n        }\r\n\r\n        if (this.customEmissiveColorSelector) {\r\n            this.customEmissiveColorSelector(mesh, subMesh, material, this._emissiveTextureAndColor.color);\r\n        } else {\r\n            if ((<any>material).emissiveColor) {\r\n                const emissiveIntensity = (<PBRMaterial>material).emissiveIntensity ?? 1;\r\n                textureLevel *= emissiveIntensity;\r\n                this._emissiveTextureAndColor.color.set(\r\n                    (<any>material).emissiveColor.r * textureLevel,\r\n                    (<any>material).emissiveColor.g * textureLevel,\r\n                    (<any>material).emissiveColor.b * textureLevel,\r\n                    material.alpha\r\n                );\r\n            } else {\r\n                this._emissiveTextureAndColor.color.set(this.neutralColor.r, this.neutralColor.g, this.neutralColor.b, this.neutralColor.a);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected _addCustomEffectDefines(defines: string[]): void {\r\n        defines.push(\"#define GLOW\");\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to exclude from the glow layer\r\n     */\r\n    public addExcludedMesh(mesh: Mesh): void {\r\n        if (this._excludedMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._excludedMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeExcludedMesh(mesh: Mesh): void {\r\n        const index = this._excludedMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._excludedMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a mesh in the inclusion list to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to include in the glow layer\r\n     */\r\n    public addIncludedOnlyMesh(mesh: Mesh): void {\r\n        if (this._includedOnlyMeshes.indexOf(mesh.uniqueId) === -1) {\r\n            this._includedOnlyMeshes.push(mesh.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.\r\n     * @param mesh The mesh to remove\r\n     */\r\n    public removeIncludedOnlyMesh(mesh: Mesh): void {\r\n        const index = this._includedOnlyMeshes.indexOf(mesh.uniqueId);\r\n        if (index !== -1) {\r\n            this._includedOnlyMeshes.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be used in the glow layer\r\n     * @param mesh The mesh to test\r\n     * @returns true if the mesh will be highlighted by the current glow layer\r\n     */\r\n    public hasMesh(mesh: AbstractMesh): boolean {\r\n        if (!super.hasMesh(mesh)) {\r\n            return false;\r\n        }\r\n\r\n        // Included Mesh\r\n        if (this._includedOnlyMeshes.length) {\r\n            return this._includedOnlyMeshes.indexOf(mesh.uniqueId) !== -1;\r\n        }\r\n\r\n        // Excluded Mesh\r\n        if (this._excludedMeshes.length) {\r\n            return this._excludedMeshes.indexOf(mesh.uniqueId) === -1;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines whether the current material of the mesh should be use to render the effect.\r\n     * @param mesh defines the current mesh to render\r\n     */\r\n    protected _useMeshMaterial(mesh: AbstractMesh): boolean {\r\n        if (this._meshesUsingTheirOwnMaterials.length == 0) {\r\n            return false;\r\n        }\r\n        return this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId) > -1;\r\n    }\r\n\r\n    /**\r\n     * Add a mesh to be rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to use its material\r\n     */\r\n    public referenceMeshToUseItsOwnMaterial(mesh: AbstractMesh): void {\r\n        mesh.resetDrawCache(this._mainTexture.renderPassId);\r\n\r\n        this._meshesUsingTheirOwnMaterials.push(mesh.uniqueId);\r\n\r\n        mesh.onDisposeObservable.add(() => {\r\n            this._disposeMesh(mesh as Mesh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Remove a mesh from being rendered through its own material and not with emissive only.\r\n     * @param mesh The mesh for which we need to not use its material\r\n     */\r\n    public unReferenceMeshFromUsingItsOwnMaterial(mesh: AbstractMesh): void {\r\n        let index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        while (index >= 0) {\r\n            this._meshesUsingTheirOwnMaterials.splice(index, 1);\r\n            index = this._meshesUsingTheirOwnMaterials.indexOf(mesh.uniqueId);\r\n        }\r\n        mesh.resetDrawCache(this._mainTexture.renderPassId);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this.removeIncludedOnlyMesh(mesh);\r\n        this.removeExcludedMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public getClassName(): string {\r\n        return \"GlowLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this glow layer\r\n     * @returns a serialized glow layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GlowLayer\";\r\n\r\n        let index;\r\n\r\n        // Included meshes\r\n        serializationObject.includedMeshes = [];\r\n\r\n        if (this._includedOnlyMeshes.length) {\r\n            for (index = 0; index < this._includedOnlyMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(this._includedOnlyMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.includedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Excluded meshes\r\n        serializationObject.excludedMeshes = [];\r\n\r\n        if (this._excludedMeshes.length) {\r\n            for (index = 0; index < this._excludedMeshes.length; index++) {\r\n                const mesh = this._scene.getMeshByUniqueId(this._excludedMeshes[index]);\r\n                if (mesh) {\r\n                    serializationObject.excludedMeshes.push(mesh.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a Glow Layer from parsed glow layer data\r\n     * @param parsedGlowLayer defines glow layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the glow layer information\r\n     * @returns a parsed Glow Layer\r\n     */\r\n    public static Parse(parsedGlowLayer: any, scene: Scene, rootUrl: string): GlowLayer {\r\n        const gl = SerializationHelper.Parse(() => new GlowLayer(parsedGlowLayer.name, scene, parsedGlowLayer.options), parsedGlowLayer, scene, rootUrl);\r\n        let index;\r\n\r\n        // Excluded meshes\r\n        for (index = 0; index < parsedGlowLayer.excludedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.excludedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addExcludedMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        // Included meshes\r\n        for (index = 0; index < parsedGlowLayer.includedMeshes.length; index++) {\r\n            const mesh = scene.getMeshById(parsedGlowLayer.includedMeshes[index]);\r\n            if (mesh) {\r\n                gl.addIncludedOnlyMesh(<Mesh>mesh);\r\n            }\r\n        }\r\n\r\n        return gl;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GlowLayer\", GlowLayer);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}