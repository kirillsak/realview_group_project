{"ast":null,"code":"/**\n * Transform some pixel data to a base64 string\n * @param pixels defines the pixel data to transform to base64\n * @param size defines the width and height of the (texture) data\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n * @returns The base64 encoded string or null\n */\nexport function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {\n  const width = size.width;\n  const height = size.height;\n  if (pixels instanceof Float32Array) {\n    let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\n    const npixels = new Uint8Array(len);\n    while (--len >= 0) {\n      let val = pixels[len];\n      if (val < 0) {\n        val = 0;\n      } else if (val > 1) {\n        val = 1;\n      }\n      npixels[len] = val * 255;\n    }\n    pixels = npixels;\n  }\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    return null;\n  }\n  const imageData = ctx.createImageData(width, height);\n  const castData = imageData.data;\n  castData.set(pixels);\n  ctx.putImageData(imageData, 0, 0);\n  if (invertY) {\n    const canvas2 = document.createElement(\"canvas\");\n    canvas2.width = width;\n    canvas2.height = height;\n    const ctx2 = canvas2.getContext(\"2d\");\n    if (!ctx2) {\n      return null;\n    }\n    ctx2.translate(0, height);\n    ctx2.scale(1, -1);\n    ctx2.drawImage(canvas, 0, 0);\n    return canvas2.toDataURL(\"image/png\");\n  }\n  return canvas.toDataURL(\"image/png\");\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null\n */\nexport function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {\n  const internalTexture = texture.getInternalTexture();\n  if (!internalTexture) {\n    return null;\n  }\n  const pixels = texture._readPixelsSync(faceIndex, level);\n  if (!pixels) {\n    return null;\n  }\n  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\n * @param texture defines the texture to read pixels from\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n * @returns The base64 encoded string or null wrapped in a promise\n */\nexport async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {\n  const internalTexture = texture.getInternalTexture();\n  if (!internalTexture) {\n    return null;\n  }\n  const pixels = await texture.readPixels(faceIndex, level);\n  if (!pixels) {\n    return null;\n  }\n  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\n}\n/**\n * Class used to host copy specific utilities\n * (Back-compat)\n */\nexport const CopyTools = {\n  /**\n   * Transform some pixel data to a base64 string\n   * @param pixels defines the pixel data to transform to base64\n   * @param size defines the width and height of the (texture) data\n   * @param invertY true if the data must be inverted for the Y coordinate during the conversion\n   * @returns The base64 encoded string or null\n   */\n  GenerateBase64StringFromPixelData,\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as a base64 string\n   * @param texture defines the texture to read pixels from\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @returns The base64 encoded string or null\n   */\n  GenerateBase64StringFromTexture,\n  /**\n   * Reads the pixels stored in the webgl texture and returns them as a base64 string\n   * @param texture defines the texture to read pixels from\n   * @param faceIndex defines the face of the texture to read (in case of cube texture)\n   * @param level defines the LOD level of the texture to read (in case of Mip Maps)\n   * @returns The base64 encoded string or null wrapped in a promise\n   */\n  GenerateBase64StringFromTextureAsync\n};","map":{"version":3,"mappings":"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","names":["GenerateBase64StringFromPixelData","pixels","size","invertY","width","height","Float32Array","len","byteLength","BYTES_PER_ELEMENT","npixels","Uint8Array","val","canvas","document","createElement","ctx","getContext","imageData","createImageData","castData","data","set","putImageData","canvas2","ctx2","translate","scale","drawImage","toDataURL","GenerateBase64StringFromTexture","texture","faceIndex","level","internalTexture","getInternalTexture","_readPixelsSync","getSize","GenerateBase64StringFromTextureAsync","readPixels","CopyTools"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/copyTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Nullable } from \"../types\";\r\n\r\ndeclare type BaseTexture = import(\"../Materials/Textures/baseTexture\").BaseTexture;\r\n\r\n/**\r\n * Transform some pixel data to a base64 string\r\n * @param pixels defines the pixel data to transform to base64\r\n * @param size defines the width and height of the (texture) data\r\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromPixelData(pixels: ArrayBufferView, size: ISize, invertY = false): Nullable<string> {\r\n    const width = size.width;\r\n    const height = size.height;\r\n\r\n    if (pixels instanceof Float32Array) {\r\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n        const npixels = new Uint8Array(len);\r\n\r\n        while (--len >= 0) {\r\n            let val = pixels[len];\r\n            if (val < 0) {\r\n                val = 0;\r\n            } else if (val > 1) {\r\n                val = 1;\r\n            }\r\n            npixels[len] = val * 255;\r\n        }\r\n\r\n        pixels = npixels;\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n        return null;\r\n    }\r\n\r\n    const imageData = ctx.createImageData(width, height);\r\n    const castData = <any>imageData.data;\r\n    castData.set(pixels);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    if (invertY) {\r\n        const canvas2 = document.createElement(\"canvas\");\r\n        canvas2.width = width;\r\n        canvas2.height = height;\r\n\r\n        const ctx2 = canvas2.getContext(\"2d\");\r\n        if (!ctx2) {\r\n            return null;\r\n        }\r\n\r\n        ctx2.translate(0, height);\r\n        ctx2.scale(1, -1);\r\n        ctx2.drawImage(canvas, 0, 0);\r\n\r\n        return canvas2.toDataURL(\"image/png\");\r\n    }\r\n\r\n    return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromTexture(texture: BaseTexture, faceIndex = 0, level = 0): Nullable<string> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = texture._readPixelsSync(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null wrapped in a promise\r\n */\r\nexport async function GenerateBase64StringFromTextureAsync(texture: BaseTexture, faceIndex = 0, level = 0): Promise<Nullable<string>> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = await texture.readPixels(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Class used to host copy specific utilities\r\n * (Back-compat)\r\n */\r\nexport const CopyTools = {\r\n    /**\r\n     * Transform some pixel data to a base64 string\r\n     * @param pixels defines the pixel data to transform to base64\r\n     * @param size defines the width and height of the (texture) data\r\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromPixelData,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromTexture,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null wrapped in a promise\r\n     */\r\n    GenerateBase64StringFromTextureAsync,\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}