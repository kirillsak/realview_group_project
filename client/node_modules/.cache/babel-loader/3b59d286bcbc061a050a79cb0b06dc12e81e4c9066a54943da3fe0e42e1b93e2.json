{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Deferred } from \"@babylonjs/core/Misc/deferred.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nconst NAME = \"MSFT_lod\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_lod {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    this.order = 100;\n    /**\n     * Maximum number of LODs to load, starting from the lowest LOD.\n     */\n    this.maxLODsToLoad = 10;\n    /**\n     * Observable raised when all node LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    this.onNodeLODsLoadedObservable = new Observable();\n    /**\n     * Observable raised when all material LODs of one level are loaded.\n     * The event data is the index of the loaded LOD starting from zero.\n     * Dispose the loader to cancel the loading of the next level of LODs.\n     */\n    this.onMaterialLODsLoadedObservable = new Observable();\n    this._bufferLODs = new Array();\n    this._nodeIndexLOD = null;\n    this._nodeSignalLODs = new Array();\n    this._nodePromiseLODs = new Array();\n    this._nodeBufferLODs = new Array();\n    this._materialIndexLOD = null;\n    this._materialSignalLODs = new Array();\n    this._materialPromiseLODs = new Array();\n    this._materialBufferLODs = new Array();\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n    this._nodeIndexLOD = null;\n    this._nodeSignalLODs.length = 0;\n    this._nodePromiseLODs.length = 0;\n    this._nodeBufferLODs.length = 0;\n    this._materialIndexLOD = null;\n    this._materialSignalLODs.length = 0;\n    this._materialPromiseLODs.length = 0;\n    this._materialBufferLODs.length = 0;\n    this.onMaterialLODsLoadedObservable.clear();\n    this.onNodeLODsLoadedObservable.clear();\n  }\n  /** @internal */\n  onReady() {\n    for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n      const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n        if (indexLOD !== 0) {\n          this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n          this._loader.log(`Loaded node LOD ${indexLOD}`);\n        }\n        this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n        if (indexLOD !== this._nodePromiseLODs.length - 1) {\n          this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n          this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\n          if (this._nodeSignalLODs[indexLOD]) {\n            this._nodeSignalLODs[indexLOD].resolve();\n          }\n        }\n      });\n      this._loader._completePromises.push(promise);\n    }\n    for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n      const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n        if (indexLOD !== 0) {\n          this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n          this._loader.log(`Loaded material LOD ${indexLOD}`);\n        }\n        this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n        if (indexLOD !== this._materialPromiseLODs.length - 1) {\n          this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n          this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\n          if (this._materialSignalLODs[indexLOD]) {\n            this._materialSignalLODs[indexLOD].resolve();\n          }\n        }\n      });\n      this._loader._completePromises.push(promise);\n    }\n  }\n  /**\n   * @internal\n   */\n  loadSceneAsync(context, scene) {\n    const promise = this._loader.loadSceneAsync(context, scene);\n    this._loadBufferLOD(this._bufferLODs, 0);\n    return promise;\n  }\n  /**\n   * @internal\n   */\n  loadNodeAsync(context, node, assign) {\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n      let firstPromise;\n      const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n      this._loader.logOpen(`${extensionContext}`);\n      for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n        const nodeLOD = nodeLODs[indexLOD];\n        if (indexLOD !== 0) {\n          this._nodeIndexLOD = indexLOD;\n          this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n        }\n        const assignWrap = babylonTransformNode => {\n          assign(babylonTransformNode);\n          babylonTransformNode.setEnabled(false);\n        };\n        const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then(babylonMesh => {\n          if (indexLOD !== 0) {\n            // TODO: should not rely on _babylonTransformNode\n            const previousNodeLOD = nodeLODs[indexLOD - 1];\n            if (previousNodeLOD._babylonTransformNode) {\n              this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n              delete previousNodeLOD._babylonTransformNode;\n            }\n          }\n          babylonMesh.setEnabled(true);\n          return babylonMesh;\n        });\n        this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n        if (indexLOD === 0) {\n          firstPromise = promise;\n        } else {\n          this._nodeIndexLOD = null;\n          this._nodePromiseLODs[indexLOD].push(promise);\n        }\n      }\n      this._loader.logClose();\n      return firstPromise;\n    });\n  }\n  /**\n   * @internal\n   */\n  _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {\n    // Don't load material LODs if already loading a node LOD.\n    if (this._nodeIndexLOD) {\n      return null;\n    }\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n      let firstPromise;\n      const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n      this._loader.logOpen(`${extensionContext}`);\n      for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n        const materialLOD = materialLODs[indexLOD];\n        if (indexLOD !== 0) {\n          this._materialIndexLOD = indexLOD;\n        }\n        const promise = this._loader._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, babylonMaterial => {\n          if (indexLOD === 0) {\n            assign(babylonMaterial);\n          }\n        }).then(babylonMaterial => {\n          if (indexLOD !== 0) {\n            assign(babylonMaterial);\n            // TODO: should not rely on _data\n            const previousDataLOD = materialLODs[indexLOD - 1]._data;\n            if (previousDataLOD[babylonDrawMode]) {\n              this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n              delete previousDataLOD[babylonDrawMode];\n            }\n          }\n          return babylonMaterial;\n        });\n        this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n        if (indexLOD === 0) {\n          firstPromise = promise;\n        } else {\n          this._materialIndexLOD = null;\n          this._materialPromiseLODs[indexLOD].push(promise);\n        }\n      }\n      this._loader.logClose();\n      return firstPromise;\n    });\n  }\n  /**\n   * @internal\n   */\n  _loadUriAsync(context, property, uri) {\n    // Defer the loading of uris if loading a node or material LOD.\n    if (this._nodeIndexLOD !== null) {\n      this._loader.log(`deferred`);\n      const previousIndexLOD = this._nodeIndexLOD - 1;\n      this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();\n      return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\n        return this._loader.loadUriAsync(context, property, uri);\n      });\n    } else if (this._materialIndexLOD !== null) {\n      this._loader.log(`deferred`);\n      const previousIndexLOD = this._materialIndexLOD - 1;\n      this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();\n      return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\n        return this._loader.loadUriAsync(context, property, uri);\n      });\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  loadBufferAsync(context, buffer, byteOffset, byteLength) {\n    if (this._loader.parent.useRangeRequests && !buffer.uri) {\n      if (!this._loader.bin) {\n        throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n      }\n      const loadAsync = (bufferLODs, indexLOD) => {\n        const start = byteOffset;\n        const end = start + byteLength - 1;\n        let bufferLOD = bufferLODs[indexLOD];\n        if (bufferLOD) {\n          bufferLOD.start = Math.min(bufferLOD.start, start);\n          bufferLOD.end = Math.max(bufferLOD.end, end);\n        } else {\n          bufferLOD = {\n            start: start,\n            end: end,\n            loaded: new Deferred()\n          };\n          bufferLODs[indexLOD] = bufferLOD;\n        }\n        return bufferLOD.loaded.promise.then(data => {\n          return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n        });\n      };\n      this._loader.log(`deferred`);\n      if (this._nodeIndexLOD !== null) {\n        return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n      } else if (this._materialIndexLOD !== null) {\n        return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n      } else {\n        return loadAsync(this._bufferLODs, 0);\n      }\n    }\n    return null;\n  }\n  _loadBufferLOD(bufferLODs, indexLOD) {\n    const bufferLOD = bufferLODs[indexLOD];\n    if (bufferLOD) {\n      this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\n      this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(data => {\n        bufferLOD.loaded.resolve(data);\n      }, error => {\n        bufferLOD.loaded.reject(error);\n      });\n    }\n  }\n  /**\n   * Gets an array of LOD properties from lowest to highest.\n   * @param context\n   * @param property\n   * @param array\n   * @param ids\n   */\n  _getLODs(context, property, array, ids) {\n    if (this.maxLODsToLoad <= 0) {\n      throw new Error(\"maxLODsToLoad must be greater than zero\");\n    }\n    const properties = new Array();\n    for (let i = ids.length - 1; i >= 0; i--) {\n      properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n      if (properties.length === this.maxLODsToLoad) {\n        return properties;\n      }\n    }\n    properties.push(property);\n    return properties;\n  }\n  _disposeTransformNode(babylonTransformNode) {\n    const babylonMaterials = new Array();\n    const babylonMaterial = babylonTransformNode.material;\n    if (babylonMaterial) {\n      babylonMaterials.push(babylonMaterial);\n    }\n    for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\n      if (babylonMesh.material) {\n        babylonMaterials.push(babylonMesh.material);\n      }\n    }\n    babylonTransformNode.dispose();\n    const babylonMaterialsToDispose = babylonMaterials.filter(babylonMaterial => this._loader.babylonScene.meshes.every(mesh => mesh.material != babylonMaterial));\n    this._disposeMaterials(babylonMaterialsToDispose);\n  }\n  _disposeMaterials(babylonMaterials) {\n    const babylonTextures = {};\n    for (const babylonMaterial of babylonMaterials) {\n      for (const babylonTexture of babylonMaterial.getActiveTextures()) {\n        babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n      }\n      babylonMaterial.dispose();\n    }\n    for (const uniqueId in babylonTextures) {\n      for (const babylonMaterial of this._loader.babylonScene.materials) {\n        if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n          delete babylonTextures[uniqueId];\n        }\n      }\n    }\n    for (const uniqueId in babylonTextures) {\n      babylonTextures[uniqueId].dispose();\n    }\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new MSFT_lod(loader));","map":{"version":3,"mappings":"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","names":["Observable","Deferred","GLTFLoader","ArrayItem","NAME","MSFT_lod","constructor","loader","Array","_loader","enabled","isExtensionUsed","dispose","_nodeIndexLOD","_nodeSignalLODs","length","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","onMaterialLODsLoadedObservable","clear","onNodeLODsLoadedObservable","onReady","indexLOD","promise","Promise","all","then","endPerformanceCounter","log","notifyObservers","startPerformanceCounter","_loadBufferLOD","resolve","_completePromises","push","loadSceneAsync","context","scene","_bufferLODs","loadNodeAsync","node","assign","LoadExtensionAsync","name","extensionContext","extension","firstPromise","nodeLODs","_getLODs","gltf","nodes","ids","logOpen","nodeLOD","assignWrap","babylonTransformNode","setEnabled","index","babylonMesh","previousNodeLOD","_babylonTransformNode","_disposeTransformNode","logClose","_loadMaterialAsync","material","babylonDrawMode","materialLODs","materials","materialLOD","babylonMaterial","previousDataLOD","_data","_disposeMaterials","_loadUriAsync","property","uri","previousIndexLOD","loadUriAsync","loadBufferAsync","buffer","byteOffset","byteLength","parent","useRangeRequests","bin","Error","loadAsync","bufferLODs","start","end","bufferLOD","Math","min","max","loaded","data","Uint8Array","readAsync","error","reject","array","maxLODsToLoad","properties","i","Get","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","filter","babylonScene","meshes","every","mesh","babylonTextures","babylonTexture","getActiveTextures","uniqueId","hasTexture","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/MSFT_lod.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IProperty, IMSFTLOD } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"MSFT_lod\";\r\n\r\ninterface IBufferInfo {\r\n    start: number;\r\n    end: number;\r\n    loaded: Deferred<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_lod implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\r\n    public maxLODsToLoad = 10;\r\n\r\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onNodeLODsLoadedObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onMaterialLODsLoadedObservable = new Observable<number>();\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _bufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _nodeIndexLOD: Nullable<number> = null;\r\n    private _nodeSignalLODs = new Array<Deferred<void>>();\r\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _nodeBufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _materialIndexLOD: Nullable<number> = null;\r\n    private _materialSignalLODs = new Array<Deferred<void>>();\r\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _materialBufferLODs = new Array<IBufferInfo>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n\r\n        this._nodeIndexLOD = null;\r\n        this._nodeSignalLODs.length = 0;\r\n        this._nodePromiseLODs.length = 0;\r\n        this._nodeBufferLODs.length = 0;\r\n\r\n        this._materialIndexLOD = null;\r\n        this._materialSignalLODs.length = 0;\r\n        this._materialPromiseLODs.length = 0;\r\n        this._materialBufferLODs.length = 0;\r\n\r\n        this.onMaterialLODsLoadedObservable.clear();\r\n        this.onNodeLODsLoadedObservable.clear();\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\r\n                    if (this._nodeSignalLODs[indexLOD]) {\r\n                        this._nodeSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n\r\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\r\n                    if (this._materialSignalLODs[indexLOD]) {\r\n                        this._materialSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        const promise = this._loader.loadSceneAsync(context, scene);\r\n        this._loadBufferLOD(this._bufferLODs, 0);\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            let firstPromise: Promise<TransformNode>;\r\n\r\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\r\n                const nodeLOD = nodeLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._nodeIndexLOD = indexLOD;\r\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\r\n                }\r\n\r\n                const assignWrap = (babylonTransformNode: TransformNode) => {\r\n                    assign(babylonTransformNode);\r\n                    babylonTransformNode.setEnabled(false);\r\n                };\r\n\r\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\r\n                    if (indexLOD !== 0) {\r\n                        // TODO: should not rely on _babylonTransformNode\r\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\r\n                        if (previousNodeLOD._babylonTransformNode) {\r\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\r\n                            delete previousNodeLOD._babylonTransformNode;\r\n                        }\r\n                    }\r\n\r\n                    babylonMesh.setEnabled(true);\r\n                    return babylonMesh;\r\n                });\r\n\r\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._nodeIndexLOD = null;\r\n                    this._nodePromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        // Don't load material LODs if already loading a node LOD.\r\n        if (this._nodeIndexLOD) {\r\n            return null;\r\n        }\r\n\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, (extensionContext, extension) => {\r\n            let firstPromise: Promise<Material>;\r\n\r\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\r\n                const materialLOD = materialLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._materialIndexLOD = indexLOD;\r\n                }\r\n\r\n                const promise = this._loader\r\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        if (indexLOD === 0) {\r\n                            assign(babylonMaterial);\r\n                        }\r\n                    })\r\n                    .then((babylonMaterial) => {\r\n                        if (indexLOD !== 0) {\r\n                            assign(babylonMaterial);\r\n\r\n                            // TODO: should not rely on _data\r\n                            const previousDataLOD = materialLODs[indexLOD - 1]._data!;\r\n                            if (previousDataLOD[babylonDrawMode]) {\r\n                                this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\r\n                                delete previousDataLOD[babylonDrawMode];\r\n                            }\r\n                        }\r\n\r\n                        return babylonMaterial;\r\n                    });\r\n\r\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._materialIndexLOD = null;\r\n                    this._materialPromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        // Defer the loading of uris if loading a node or material LOD.\r\n        if (this._nodeIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._nodeIndexLOD - 1;\r\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(() => {\r\n                return this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        } else if (this._materialIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._materialIndexLOD - 1;\r\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._materialSignalLODs[previousIndexLOD].promise.then(() => {\r\n                return this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\r\n            if (!this._loader.bin) {\r\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n            }\r\n\r\n            const loadAsync = (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\r\n                const start = byteOffset;\r\n                const end = start + byteLength - 1;\r\n                let bufferLOD = bufferLODs[indexLOD];\r\n                if (bufferLOD) {\r\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\r\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\r\n                } else {\r\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\r\n                    bufferLODs[indexLOD] = bufferLOD;\r\n                }\r\n\r\n                return bufferLOD.loaded.promise.then((data) => {\r\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\r\n                });\r\n            };\r\n\r\n            this._loader.log(`deferred`);\r\n\r\n            if (this._nodeIndexLOD !== null) {\r\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\r\n            } else if (this._materialIndexLOD !== null) {\r\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\r\n            } else {\r\n                return loadAsync(this._bufferLODs, 0);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\r\n        const bufferLOD = bufferLODs[indexLOD];\r\n        if (bufferLOD) {\r\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\r\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(\r\n                (data) => {\r\n                    bufferLOD.loaded.resolve(data);\r\n                },\r\n                (error) => {\r\n                    bufferLOD.loaded.reject(error);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets an array of LOD properties from lowest to highest.\r\n     * @param context\r\n     * @param property\r\n     * @param array\r\n     * @param ids\r\n     */\r\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\r\n        if (this.maxLODsToLoad <= 0) {\r\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\r\n        }\r\n\r\n        const properties = new Array<T>();\r\n\r\n        for (let i = ids.length - 1; i >= 0; i--) {\r\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\r\n            if (properties.length === this.maxLODsToLoad) {\r\n                return properties;\r\n            }\r\n        }\r\n\r\n        properties.push(property);\r\n        return properties;\r\n    }\r\n\r\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\r\n        const babylonMaterials = new Array<Material>();\r\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\r\n            if (babylonMesh.material) {\r\n                babylonMaterials.push(babylonMesh.material);\r\n            }\r\n        }\r\n\r\n        babylonTransformNode.dispose();\r\n\r\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\r\n        this._disposeMaterials(babylonMaterialsToDispose);\r\n    }\r\n\r\n    private _disposeMaterials(babylonMaterials: Material[]): void {\r\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\r\n\r\n        for (const babylonMaterial of babylonMaterials) {\r\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\r\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\r\n            }\r\n\r\n            babylonMaterial.dispose();\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\r\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\r\n                    delete babylonTextures[uniqueId];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            babylonTextures[uniqueId].dispose();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new MSFT_lod(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}