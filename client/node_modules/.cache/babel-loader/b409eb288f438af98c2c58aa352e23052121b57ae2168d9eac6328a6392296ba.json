{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { MaterialHelper } from \"../../../materialHelper.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightVxUboDeclaration.js\";\nimport \"../../../../Shaders/ShadersInclude/lightFragment.js\";\nimport \"../../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions.js\";\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex.js\";\n/**\n * Block used to add light in the fragment shader\n */\nexport class LightBlock extends NodeMaterialBlock {\n  /**\n   * Create a new LightBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    this._lightId = 0;\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n    this._isUnique = true;\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\n    this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\n  }\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    if (that.worldPosition.isConnected) {\n      that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\n      console.error(\"The worldPosition input must not be connected to be able to switch!\");\n      return false;\n    }\n    that._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n    this.getInputByName(\"worldPosition\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"LightBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the glossiness component\n   */\n  get glossiness() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the glossiness power component\n   */\n  get glossPower() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the diffuse color component\n   */\n  get diffuseColor() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the specular color component\n   */\n  get specularColor() {\n    return this._inputs[6];\n  }\n  /**\n   * Gets the view matrix component\n   */\n  get view() {\n    return this._inputs[7];\n  }\n  /**\n   * Gets the diffuse output component\n   */\n  get diffuseOutput() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the specular output component\n   */\n  get specularOutput() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the shadow output component\n   */\n  get shadow() {\n    return this._outputs[2];\n  }\n  autoConfigure(material) {\n    if (!this.cameraPosition.isConnected) {\n      let cameraPositionInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.CameraPosition);\n      if (!cameraPositionInput) {\n        cameraPositionInput = new InputBlock(\"cameraPosition\");\n        cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\n      }\n      cameraPositionInput.output.connectTo(this.cameraPosition);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      const state = {\n        needNormals: false,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false\n      };\n      MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\n      if (state.needRebuild) {\n        defines.rebuild();\n      }\n    }\n  }\n  updateUniformsAndSamples(state, nodeMaterial, defines, uniformBuffers) {\n    for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n      const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\n      MaterialHelper.PrepareUniformsAndSamplersForLight(lightIndex, state.uniforms, state.samplers, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffers, onlyUpdateBuffersList);\n    }\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    const scene = mesh.getScene();\n    if (!this.light) {\n      MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\n    } else {\n      MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\n    }\n  }\n  _injectVertexCode(state) {\n    const worldPos = this.worldPosition;\n    const comments = `//${this.name}`;\n    // Declaration\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n      this._lightId = 0;\n      state.sharedData.dynamicUniformBlocks.push(this);\n    } else {\n      this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\n      state.counters[\"lightCounter\"] = this._lightId;\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Inject code in vertex\n    const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\n    if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\r\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }, {\n          search: /worldPos/g,\n          replace: worldPos.associatedVariableName\n        }]\n      });\n    } else {\n      state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\r\\n`;\n      if (this.view.isConnected) {\n        state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\r\\n`;\n      }\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      // Vertex\n      this._injectVertexCode(state);\n      return;\n    }\n    if (this.generateOnlyFragmentCode) {\n      state.sharedData.dynamicUniformBlocks.push(this);\n    }\n    // Fragment\n    state.sharedData.forcedBindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    const comments = `//${this.name}`;\n    const worldPos = this.worldPosition;\n    let worldPosVariableName = worldPos.associatedVariableName;\n    if (this.generateOnlyFragmentCode) {\n      worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\n      state._emitFunction(\"light_globalworldpos\", `vec3 ${worldPosVariableName};\\r\\n`, comments);\n      state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\r\\n`;\n      state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : undefined\n      });\n    } else {\n      worldPosVariableName = \"v_\" + worldPosVariableName + \".xyz\";\n    }\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVariableName\n      }]\n    });\n    state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\n      replaceStrings: [{\n        search: /vPositionW/g,\n        replace: worldPosVariableName\n      }]\n    });\n    if (!this.light) {\n      // Emit for all lights\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        repeatKey: \"maxSimultaneousLights\",\n        substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined\n      });\n    } else {\n      state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      }, this._lightId.toString());\n    }\n    // Code\n    if (this._lightId === 0) {\n      if (state._registerTempVariable(\"viewDirectionW\")) {\n        state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\r\\n`;\n      }\n      state.compilationString += `lightingInfo info;\\r\\n`;\n      state.compilationString += `float shadow = 1.;\\r\\n`;\n      state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"};\\r\\n`;\n      state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\r\\n`;\n      state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\r\\n`;\n      state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\r\\n`;\n    }\n    if (this.light) {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        replaceStrings: [{\n          search: /{X}/g,\n          replace: this._lightId.toString()\n        }]\n      });\n    } else {\n      state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\n        repeatKey: \"maxSimultaneousLights\"\n      });\n    }\n    const diffuseOutput = this.diffuseOutput;\n    const specularOutput = this.specularOutput;\n    state.compilationString += this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\r\\n`;\n    if (specularOutput.hasEndpoints) {\n      state.compilationString += this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\r\\n`;\n    }\n    if (this.shadow.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.shadow, state) + ` = shadow;\\r\\n`;\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.lightId) {\n      this.light = scene.getLightById(serializationObject.lightId);\n    }\n    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], LightBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockTargets","NodeMaterialBlockConnectionPointTypes","MaterialHelper","NodeMaterialSystemValues","InputBlock","RegisterClass","editableInPropertyPage","PropertyTypeForEdition","LightBlock","constructor","name","VertexAndFragment","_isUnique","registerInput","Vector4","Vertex","Fragment","Vector3","Float","Color3","Matrix","registerOutput","_OnGenerateOnlyFragmentCodeChanged","block","_propertyName","that","worldPosition","isConnected","generateOnlyFragmentCode","console","error","_setTarget","_setInitialTarget","getInputByName","target","getClassName","_inputs","worldNormal","cameraPosition","glossiness","glossPower","diffuseColor","specularColor","view","diffuseOutput","_outputs","specularOutput","shadow","autoConfigure","material","cameraPositionInput","getInputBlockByPredicate","b","systemValue","CameraPosition","setAsSystemValue","output","connectTo","prepareDefines","mesh","nodeMaterial","defines","_areLightsDirty","scene","getScene","light","PrepareDefinesForLights","maxSimultaneousLights","state","needNormals","needRebuild","lightmapMode","shadowEnabled","specularEnabled","PrepareDefinesForLight","_lightId","rebuild","updateUniformsAndSamples","uniformBuffers","lightIndex","onlyUpdateBuffersList","uniforms","indexOf","PrepareUniformsAndSamplersForLight","samplers","bind","effect","BindLights","BindLight","_injectVertexCode","worldPos","comments","_emitFunctionFromInclude","supportUniformBuffers","repeatKey","sharedData","dynamicUniformBlocks","push","counters","undefined","replaceStrings","search","replace","toString","worldPosVaryingName","associatedVariableName","_emitVaryingFromString","compilationString","_emitCodeFromInclude","_buildBlock","forcedBindableBlocks","blocksWithDefines","worldPosVariableName","_getFreeVariableName","_emitFunction","substitutionVars","_registerTempVariable","_declareOutput","hasEndpoints","serialize","serializationObject","lightId","id","_deserialize","rootUrl","getLightById","__decorate","Boolean","notifiers","update","onValidation"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/lightBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { MaterialHelper } from \"../../../materialHelper\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport type { Light } from \"../../../../Lights/light\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/lightFragmentDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightVxFragmentDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightUboDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightVxUboDeclaration\";\r\nimport \"../../../../Shaders/ShadersInclude/lightFragment\";\r\nimport \"../../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/lightsFragmentFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/shadowsFragmentFunctions\";\r\nimport \"../../../../Shaders/ShadersInclude/shadowsVertex\";\r\n\r\n/**\r\n * Block used to add light in the fragment shader\r\n */\r\nexport class LightBlock extends NodeMaterialBlock {\r\n    private _lightId: number = 0;\r\n\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: LightBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    private static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as LightBlock;\r\n\r\n        if (that.worldPosition.isConnected) {\r\n            that.generateOnlyFragmentCode = !that.generateOnlyFragmentCode;\r\n            console.error(\"The worldPosition input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        that._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    private _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n        this.getInputByName(\"worldPosition\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n    }\r\n\r\n    /**\r\n     * Create a new LightBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"worldNormal\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"cameraPosition\", NodeMaterialBlockConnectionPointTypes.Vector3, false, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossiness\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"glossPower\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"diffuseColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"specularColor\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"view\", NodeMaterialBlockConnectionPointTypes.Matrix, true);\r\n\r\n        this.registerOutput(\"diffuseOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"specularOutput\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Fragment);\r\n        this.registerOutput(\"shadow\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Fragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"LightBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the glossiness component\r\n     */\r\n    public get glossiness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the glossiness power component\r\n     */\r\n    public get glossPower(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse color component\r\n     */\r\n    public get diffuseColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color component\r\n     */\r\n    public get specularColor(): NodeMaterialConnectionPoint {\r\n        return this._inputs[6];\r\n    }\r\n\r\n    /**\r\n     * Gets the view matrix component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this._inputs[7];\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse output component\r\n     */\r\n    public get diffuseOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the specular output component\r\n     */\r\n    public get specularOutput(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow output component\r\n     */\r\n    public get shadow(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.cameraPosition.isConnected) {\r\n            let cameraPositionInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.CameraPosition);\r\n\r\n            if (!cameraPositionInput) {\r\n                cameraPositionInput = new InputBlock(\"cameraPosition\");\r\n                cameraPositionInput.setAsSystemValue(NodeMaterialSystemValues.CameraPosition);\r\n            }\r\n            cameraPositionInput.output.connectTo(this.cameraPosition);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areLightsDirty) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            const state = {\r\n                needNormals: false,\r\n                needRebuild: false,\r\n                lightmapMode: false,\r\n                shadowEnabled: false,\r\n                specularEnabled: false,\r\n            };\r\n\r\n            MaterialHelper.PrepareDefinesForLight(scene, mesh, this.light, this._lightId, defines, true, state);\r\n\r\n            if (state.needRebuild) {\r\n                defines.rebuild();\r\n            }\r\n        }\r\n    }\r\n\r\n    public updateUniformsAndSamples(state: NodeMaterialBuildState, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines, uniformBuffers: string[]) {\r\n        for (let lightIndex = 0; lightIndex < nodeMaterial.maxSimultaneousLights; lightIndex++) {\r\n            if (!defines[\"LIGHT\" + lightIndex]) {\r\n                break;\r\n            }\r\n            const onlyUpdateBuffersList = state.uniforms.indexOf(\"vLightData\" + lightIndex) >= 0;\r\n            MaterialHelper.PrepareUniformsAndSamplersForLight(\r\n                lightIndex,\r\n                state.uniforms,\r\n                state.samplers,\r\n                defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n                uniformBuffers,\r\n                onlyUpdateBuffersList\r\n            );\r\n        }\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        const scene = mesh.getScene();\r\n\r\n        if (!this.light) {\r\n            MaterialHelper.BindLights(scene, mesh, effect, true, nodeMaterial.maxSimultaneousLights);\r\n        } else {\r\n            MaterialHelper.BindLight(this.light, this._lightId, scene, effect, true);\r\n        }\r\n    }\r\n\r\n    private _injectVertexCode(state: NodeMaterialBuildState) {\r\n        const worldPos = this.worldPosition;\r\n        const comments = `//${this.name}`;\r\n\r\n        // Declaration\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n            this._lightId = 0;\r\n\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        } else {\r\n            this._lightId = (state.counters[\"lightCounter\"] !== undefined ? state.counters[\"lightCounter\"] : -1) + 1;\r\n            state.counters[\"lightCounter\"] = this._lightId;\r\n\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightVxUboDeclaration\" : \"lightVxFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        // Inject code in vertex\r\n        const worldPosVaryingName = \"v_\" + worldPos.associatedVariableName;\r\n        if (state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            state.compilationString += `${worldPosVaryingName} = ${worldPos.associatedVariableName};\\r\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                replaceStrings: [\r\n                    { search: /{X}/g, replace: this._lightId.toString() },\r\n                    { search: /worldPos/g, replace: worldPos.associatedVariableName },\r\n                ],\r\n            });\r\n        } else {\r\n            state.compilationString += `vec4 worldPos = ${worldPos.associatedVariableName};\\r\\n`;\r\n            if (this.view.isConnected) {\r\n                state.compilationString += `mat4 view = ${this.view.associatedVariableName};\\r\\n`;\r\n            }\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            // Vertex\r\n            this._injectVertexCode(state);\r\n\r\n            return;\r\n        }\r\n\r\n        if (this.generateOnlyFragmentCode) {\r\n            state.sharedData.dynamicUniformBlocks.push(this);\r\n        }\r\n\r\n        // Fragment\r\n        state.sharedData.forcedBindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        const worldPos = this.worldPosition;\r\n\r\n        let worldPosVariableName = worldPos.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode) {\r\n            worldPosVariableName = state._getFreeVariableName(\"globalWorldPos\");\r\n            state._emitFunction(\"light_globalworldpos\", `vec3 ${worldPosVariableName};\\r\\n`, comments);\r\n            state.compilationString += `${worldPosVariableName} = ${worldPos.associatedVariableName}.xyz;\\r\\n`;\r\n\r\n            state.compilationString += state._emitCodeFromInclude(\"shadowsVertex\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: this.generateOnlyFragmentCode ? `worldPos,${worldPos.associatedVariableName}` : undefined,\r\n            });\r\n        } else {\r\n            worldPosVariableName = \"v_\" + worldPosVariableName + \".xyz\";\r\n        }\r\n\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitFunctionFromInclude(\"lightsFragmentFunctions\", comments, {\r\n            replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }],\r\n        });\r\n\r\n        state._emitFunctionFromInclude(\"shadowsFragmentFunctions\", comments, {\r\n            replaceStrings: [{ search: /vPositionW/g, replace: worldPosVariableName }],\r\n        });\r\n\r\n        if (!this.light) {\r\n            // Emit for all lights\r\n            state._emitFunctionFromInclude(state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n                substitutionVars: this.generateOnlyFragmentCode ? \"varying,\" : undefined,\r\n            });\r\n        } else {\r\n            state._emitFunctionFromInclude(\r\n                state.supportUniformBuffers ? \"lightUboDeclaration\" : \"lightFragmentDeclaration\",\r\n                comments,\r\n                {\r\n                    replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n                },\r\n                this._lightId.toString()\r\n            );\r\n        }\r\n\r\n        // Code\r\n        if (this._lightId === 0) {\r\n            if (state._registerTempVariable(\"viewDirectionW\")) {\r\n                state.compilationString += `vec3 viewDirectionW = normalize(${this.cameraPosition.associatedVariableName} - ${worldPosVariableName});\\r\\n`;\r\n            }\r\n            state.compilationString += `lightingInfo info;\\r\\n`;\r\n            state.compilationString += `float shadow = 1.;\\r\\n`;\r\n            state.compilationString += `float glossiness = ${this.glossiness.isConnected ? this.glossiness.associatedVariableName : \"1.0\"} * ${\r\n                this.glossPower.isConnected ? this.glossPower.associatedVariableName : \"1024.0\"\r\n            };\\r\\n`;\r\n            state.compilationString += `vec3 diffuseBase = vec3(0., 0., 0.);\\r\\n`;\r\n            state.compilationString += `vec3 specularBase = vec3(0., 0., 0.);\\r\\n`;\r\n            state.compilationString += `vec3 normalW = ${this.worldNormal.associatedVariableName}.xyz;\\r\\n`;\r\n        }\r\n\r\n        if (this.light) {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                replaceStrings: [{ search: /{X}/g, replace: this._lightId.toString() }],\r\n            });\r\n        } else {\r\n            state.compilationString += state._emitCodeFromInclude(\"lightFragment\", comments, {\r\n                repeatKey: \"maxSimultaneousLights\",\r\n            });\r\n        }\r\n\r\n        const diffuseOutput = this.diffuseOutput;\r\n        const specularOutput = this.specularOutput;\r\n\r\n        state.compilationString +=\r\n            this._declareOutput(diffuseOutput, state) + ` = diffuseBase${this.diffuseColor.isConnected ? \" * \" + this.diffuseColor.associatedVariableName : \"\"};\\r\\n`;\r\n        if (specularOutput.hasEndpoints) {\r\n            state.compilationString +=\r\n                this._declareOutput(specularOutput, state) + ` = specularBase${this.specularColor.isConnected ? \" * \" + this.specularColor.associatedVariableName : \"\"};\\r\\n`;\r\n        }\r\n\r\n        if (this.shadow.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(this.shadow, state) + ` = shadow;\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightById(serializationObject.lightId);\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LightBlock\", LightBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}