{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\n/**\n * Defines a target to use with MorphTargetManager\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\n */\nexport class MorphTarget {\n  /**\n   * Creates a new MorphTarget\n   * @param name defines the name of the target\n   * @param influence defines the influence to use\n   * @param scene defines the scene the morphtarget belongs to\n   */\n  constructor( /** defines the name of the target */\n  name, influence = 0, scene = null) {\n    this.name = name;\n    /**\n     * Gets or sets the list of animations\n     */\n    this.animations = new Array();\n    this._positions = null;\n    this._normals = null;\n    this._tangents = null;\n    this._uvs = null;\n    this._uniqueId = 0;\n    /**\n     * Observable raised when the influence changes\n     */\n    this.onInfluenceChanged = new Observable();\n    /** @internal */\n    this._onDataLayoutChanged = new Observable();\n    this._animationPropertiesOverride = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this.influence = influence;\n    if (this._scene) {\n      this._uniqueId = this._scene.getUniqueId();\n    }\n  }\n  /**\n   * Gets or sets the influence of this target (ie. its weight in the overall morphing)\n   */\n  get influence() {\n    return this._influence;\n  }\n  set influence(influence) {\n    if (this._influence === influence) {\n      return;\n    }\n    const previous = this._influence;\n    this._influence = influence;\n    if (this.onInfluenceChanged.hasObservers()) {\n      this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n    }\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    if (!this._animationPropertiesOverride && this._scene) {\n      return this._scene.animationPropertiesOverride;\n    }\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /**\n   * Gets the unique ID of this manager\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Gets a boolean defining if the target contains position data\n   */\n  get hasPositions() {\n    return !!this._positions;\n  }\n  /**\n   * Gets a boolean defining if the target contains normal data\n   */\n  get hasNormals() {\n    return !!this._normals;\n  }\n  /**\n   * Gets a boolean defining if the target contains tangent data\n   */\n  get hasTangents() {\n    return !!this._tangents;\n  }\n  /**\n   * Gets a boolean defining if the target contains texture coordinates data\n   */\n  get hasUVs() {\n    return !!this._uvs;\n  }\n  /**\n   * Affects position data to this target\n   * @param data defines the position data to use\n   */\n  setPositions(data) {\n    const hadPositions = this.hasPositions;\n    this._positions = data;\n    if (hadPositions !== this.hasPositions) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the position data stored in this target\n   * @returns a FloatArray containing the position data (or null if not present)\n   */\n  getPositions() {\n    return this._positions;\n  }\n  /**\n   * Affects normal data to this target\n   * @param data defines the normal data to use\n   */\n  setNormals(data) {\n    const hadNormals = this.hasNormals;\n    this._normals = data;\n    if (hadNormals !== this.hasNormals) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the normal data stored in this target\n   * @returns a FloatArray containing the normal data (or null if not present)\n   */\n  getNormals() {\n    return this._normals;\n  }\n  /**\n   * Affects tangent data to this target\n   * @param data defines the tangent data to use\n   */\n  setTangents(data) {\n    const hadTangents = this.hasTangents;\n    this._tangents = data;\n    if (hadTangents !== this.hasTangents) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the tangent data stored in this target\n   * @returns a FloatArray containing the tangent data (or null if not present)\n   */\n  getTangents() {\n    return this._tangents;\n  }\n  /**\n   * Affects texture coordinates data to this target\n   * @param data defines the texture coordinates data to use\n   */\n  setUVs(data) {\n    const hadUVs = this.hasUVs;\n    this._uvs = data;\n    if (hadUVs !== this.hasUVs) {\n      this._onDataLayoutChanged.notifyObservers(undefined);\n    }\n  }\n  /**\n   * Gets the texture coordinates data stored in this target\n   * @returns a FloatArray containing the texture coordinates data (or null if not present)\n   */\n  getUVs() {\n    return this._uvs;\n  }\n  /**\n   * Clone the current target\n   * @returns a new MorphTarget\n   */\n  clone() {\n    const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\n    newOne._positions = this._positions;\n    newOne._normals = this._normals;\n    newOne._tangents = this._tangents;\n    newOne._uvs = this._uvs;\n    return newOne;\n  }\n  /**\n   * Serializes the current target into a Serialization object\n   * @returns the serialized object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.influence = this.influence;\n    serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n    if (this.id != null) {\n      serializationObject.id = this.id;\n    }\n    if (this.hasNormals) {\n      serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n    }\n    if (this.hasTangents) {\n      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n    }\n    if (this.hasUVs) {\n      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    return serializationObject;\n  }\n  /**\n   * Returns the string \"MorphTarget\"\n   * @returns \"MorphTarget\"\n   */\n  getClassName() {\n    return \"MorphTarget\";\n  }\n  // Statics\n  /**\n   * Creates a new target from serialized data\n   * @param serializationObject defines the serialized data to use\n   * @param scene defines the hosting scene\n   * @returns a new MorphTarget\n   */\n  static Parse(serializationObject, scene) {\n    const result = new MorphTarget(serializationObject.name, serializationObject.influence);\n    result.setPositions(serializationObject.positions);\n    if (serializationObject.id != null) {\n      result.id = serializationObject.id;\n    }\n    if (serializationObject.normals) {\n      result.setNormals(serializationObject.normals);\n    }\n    if (serializationObject.tangents) {\n      result.setTangents(serializationObject.tangents);\n    }\n    if (serializationObject.uvs) {\n      result.setUVs(serializationObject.uvs);\n    }\n    // Animations\n    if (serializationObject.animations) {\n      for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\n        const parsedAnimation = serializationObject.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          result.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      if (serializationObject.autoAnimate && scene) {\n        scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1.0);\n      }\n    }\n    return result;\n  }\n  /**\n   * Creates a MorphTarget from mesh data\n   * @param mesh defines the source mesh\n   * @param name defines the name to use for the new target\n   * @param influence defines the influence to attach to the target\n   * @returns a new MorphTarget\n   */\n  static FromMesh(mesh, name, influence) {\n    if (!name) {\n      name = mesh.name;\n    }\n    const result = new MorphTarget(name, influence, mesh.getScene());\n    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));\n    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));\n    }\n    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));\n    }\n    return result;\n  }\n}\n__decorate([serialize()], MorphTarget.prototype, \"id\", void 0);","map":{"version":3,"mappings":"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","names":["Observable","EngineStore","VertexBuffer","serialize","SerializationHelper","GetClass","MorphTarget","constructor","name","influence","scene","Array","_scene","LastCreatedScene","_uniqueId","getUniqueId","_influence","previous","onInfluenceChanged","hasObservers","notifyObservers","animationPropertiesOverride","_animationPropertiesOverride","value","uniqueId","hasPositions","_positions","hasNormals","_normals","hasTangents","_tangents","hasUVs","_uvs","setPositions","data","hadPositions","_onDataLayoutChanged","undefined","getPositions","setNormals","hadNormals","getNormals","setTangents","hadTangents","getTangents","setUVs","hadUVs","getUVs","clone","newOne","Clone","serializationObject","positions","prototype","slice","call","id","normals","tangents","uvs","AppendSerializedAnimations","getClassName","Parse","result","animations","animationIndex","length","parsedAnimation","internalClass","push","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","FromMesh","mesh","getScene","getVerticesData","PositionKind","isVerticesDataPresent","NormalKind","TangentKind","UVKind","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Morph/morphTarget.ts"],"sourcesContent":["import type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Animation = import(\"../Animations/animation\").Animation;\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations = new Array<Animation>();\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @internal */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        const previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string,\r\n        influence = 0,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any, scene?: Scene): MorphTarget {\r\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializationObject.autoAnimate && scene) {\r\n                scene.beginAnimation(\r\n                    result,\r\n                    serializationObject.autoAnimateFrom,\r\n                    serializationObject.autoAnimateTo,\r\n                    serializationObject.autoAnimateLoop,\r\n                    serializationObject.autoAnimateSpeed || 1.0\r\n                );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        const result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}