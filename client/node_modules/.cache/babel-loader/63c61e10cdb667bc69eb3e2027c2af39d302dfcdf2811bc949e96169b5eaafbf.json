{"ast":null,"code":"const defaultAttributeKeywordName = \"attribute\";\nconst defaultVaryingKeywordName = \"varying\";\n/** @internal */\nexport class ShaderCodeNode {\n  constructor() {\n    this.children = [];\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  isValid(preprocessors) {\n    return true;\n  }\n  process(preprocessors, options) {\n    var _a, _b, _c, _d, _e, _f;\n    let result = \"\";\n    if (this.line) {\n      let value = this.line;\n      const processor = options.processor;\n      if (processor) {\n        // This must be done before other replacements to avoid mistakenly changing something that was already changed.\n        if (processor.lineProcessor) {\n          value = processor.lineProcessor(value, options.isFragment, options.processingContext);\n        }\n        const attributeKeyword = (_b = (_a = options.processor) === null || _a === void 0 ? void 0 : _a.attributeKeywordName) !== null && _b !== void 0 ? _b : defaultAttributeKeywordName;\n        const varyingKeyword = options.isFragment && ((_c = options.processor) === null || _c === void 0 ? void 0 : _c.varyingFragmentKeywordName) ? (_d = options.processor) === null || _d === void 0 ? void 0 : _d.varyingFragmentKeywordName : !options.isFragment && ((_e = options.processor) === null || _e === void 0 ? void 0 : _e.varyingVertexKeywordName) ? (_f = options.processor) === null || _f === void 0 ? void 0 : _f.varyingVertexKeywordName : defaultVaryingKeywordName;\n        if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\n          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\n        } else if (processor.varyingProcessor && this.line.startsWith(varyingKeyword)) {\n          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n          }\n        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\n          if (!options.lookForClosingBracketForUniformBuffer) {\n            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n            options.lookForClosingBracketForUniformBuffer = true;\n          }\n        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\n          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\n          const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\n          if (regex.test(this.line)) {\n            // uniform\n            if (processor.uniformProcessor) {\n              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\n            }\n          } else {\n            // Uniform buffer\n            if (processor.uniformBufferProcessor) {\n              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n              options.lookForClosingBracketForUniformBuffer = true;\n            }\n          }\n        }\n        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\n          options.lookForClosingBracketForUniformBuffer = false;\n          if (processor.endOfUniformBufferProcessor) {\n            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\n          }\n        }\n      }\n      result += value + \"\\r\\n\";\n    }\n    this.children.forEach(child => {\n      result += child.process(preprocessors, options);\n    });\n    if (this.additionalDefineKey) {\n      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\n    }\n    return result;\n  }\n}","map":{"version":3,"mappings":"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","names":["defaultAttributeKeywordName","defaultVaryingKeywordName","ShaderCodeNode","constructor","isValid","preprocessors","process","options","result","line","value","processor","lineProcessor","isFragment","processingContext","attributeKeyword","attributeKeywordName","varyingKeyword","varyingFragmentKeywordName","varyingVertexKeywordName","attributeProcessor","startsWith","varyingProcessor","uniformProcessor","uniformRegexp","test","lookForClosingBracketForUniformBuffer","uniformBufferProcessor","uniformBufferRegexp","textureProcessor","textureRegexp","regex","indexOf","endOfUniformBufferProcessor","children","forEach","child","additionalDefineKey","additionalDefineValue"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Processors/shaderCodeNode.ts"],"sourcesContent":["import type { ProcessingOptions } from \"./shaderProcessingOptions\";\r\n\r\nconst defaultAttributeKeywordName = \"attribute\";\r\nconst defaultVaryingKeywordName = \"varying\";\r\n\r\n/** @internal */\r\nexport class ShaderCodeNode {\r\n    line: string;\r\n    children: ShaderCodeNode[] = [];\r\n    additionalDefineKey?: string;\r\n    additionalDefineValue?: string;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    isValid(preprocessors: { [key: string]: string }): boolean {\r\n        return true;\r\n    }\r\n\r\n    process(preprocessors: { [key: string]: string }, options: ProcessingOptions): string {\r\n        let result = \"\";\r\n        if (this.line) {\r\n            let value: string = this.line;\r\n            const processor = options.processor;\r\n            if (processor) {\r\n                // This must be done before other replacements to avoid mistakenly changing something that was already changed.\r\n                if (processor.lineProcessor) {\r\n                    value = processor.lineProcessor(value, options.isFragment, options.processingContext);\r\n                }\r\n\r\n                const attributeKeyword = options.processor?.attributeKeywordName ?? defaultAttributeKeywordName;\r\n                const varyingKeyword =\r\n                    options.isFragment && options.processor?.varyingFragmentKeywordName\r\n                        ? options.processor?.varyingFragmentKeywordName\r\n                        : !options.isFragment && options.processor?.varyingVertexKeywordName\r\n                        ? options.processor?.varyingVertexKeywordName\r\n                        : defaultVaryingKeywordName;\r\n\r\n                if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {\r\n                    value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);\r\n                } else if (processor.varyingProcessor && this.line.startsWith(varyingKeyword)) {\r\n                    value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                    }\r\n                } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {\r\n                    if (!options.lookForClosingBracketForUniformBuffer) {\r\n                        value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                        options.lookForClosingBracketForUniformBuffer = true;\r\n                    }\r\n                } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {\r\n                    value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith(\"uniform\") && !options.lookForClosingBracketForUniformBuffer) {\r\n                    const regex = /uniform\\s+(?:(?:highp)?|(?:lowp)?)\\s*(\\S+)\\s+(\\S+)\\s*;/;\r\n\r\n                    if (regex.test(this.line)) {\r\n                        // uniform\r\n                        if (processor.uniformProcessor) {\r\n                            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);\r\n                        }\r\n                    } else {\r\n                        // Uniform buffer\r\n                        if (processor.uniformBufferProcessor) {\r\n                            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                            options.lookForClosingBracketForUniformBuffer = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf(\"}\") !== -1) {\r\n                    options.lookForClosingBracketForUniformBuffer = false;\r\n                    if (processor.endOfUniformBufferProcessor) {\r\n                        value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);\r\n                    }\r\n                }\r\n            }\r\n\r\n            result += value + \"\\r\\n\";\r\n        }\r\n\r\n        this.children.forEach((child) => {\r\n            result += child.process(preprocessors, options);\r\n        });\r\n\r\n        if (this.additionalDefineKey) {\r\n            preprocessors[this.additionalDefineKey] = this.additionalDefineValue || \"true\";\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}