{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { Collider } from \"./collider.js\";\n/** @internal */\nexport class DefaultCollisionCoordinator {\n  constructor() {\n    this._scaledPosition = Vector3.Zero();\n    this._scaledVelocity = Vector3.Zero();\n    this._finalPosition = Vector3.Zero();\n  }\n  getNewPosition(position, displacement, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n    position.divideToRef(collider._radius, this._scaledPosition);\n    displacement.divideToRef(collider._radius, this._scaledVelocity);\n    collider.collidedMesh = null;\n    collider._retry = 0;\n    collider._initialVelocity = this._scaledVelocity;\n    collider._initialPosition = this._scaledPosition;\n    this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n    this._finalPosition.multiplyInPlace(collider._radius);\n    //run the callback\n    onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n  }\n  createCollider() {\n    return new Collider();\n  }\n  init(scene) {\n    this._scene = scene;\n  }\n  _collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh = null) {\n    const closeDistance = Engine.CollisionsEpsilon * 10.0;\n    if (collider._retry >= maximumRetry) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n    // Check if this is a mesh else camera or -1\n    const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\n    collider._initialize(position, velocity, closeDistance);\n    // Check if collision detection should happen against specified list of meshes or,\n    // if not specified, against all meshes in the scene\n    const meshes = excludedMesh && excludedMesh.surroundingMeshes || this._scene.meshes;\n    for (let index = 0; index < meshes.length; index++) {\n      const mesh = meshes[index];\n      if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\n        mesh._checkCollision(collider);\n      }\n    }\n    if (!collider.collisionFound) {\n      position.addToRef(velocity, finalPosition);\n      return;\n    }\n    if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n      collider._getResponse(position, velocity);\n    }\n    if (velocity.length() <= closeDistance) {\n      finalPosition.copyFrom(position);\n      return;\n    }\n    collider._retry++;\n    this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n  }\n}\nScene.CollisionCoordinatorFactory = () => {\n  return new DefaultCollisionCoordinator();\n};","map":{"version":3,"mappings":"AACA,SAASA,KAAK,QAAQ,aAAW;AACjC,SAASC,OAAO,QAAQ,yBAAuB;AAC/C,SAASC,MAAM,QAAQ,sBAAoB;AAC3C,SAASC,QAAQ,QAAQ,eAAa;AAkBtC;AACA,OAAM,MAAOC,2BAA2B;EAAxCC;IAGY,oBAAe,GAAGJ,OAAO,CAACK,IAAI,EAAE;IAChC,oBAAe,GAAGL,OAAO,CAACK,IAAI,EAAE;IAEhC,mBAAc,GAAGL,OAAO,CAACK,IAAI,EAAE;EAgF3C;EA9EWC,cAAc,CACjBC,QAAiB,EACjBC,YAAqB,EACrBC,QAAkB,EAClBC,YAAoB,EACpBC,YAA0B,EAC1BC,aAA2G,EAC3GC,cAAsB;IAEtBN,QAAQ,CAACO,WAAW,CAACL,QAAQ,CAACM,OAAO,EAAE,IAAI,CAACC,eAAe,CAAC;IAC5DR,YAAY,CAACM,WAAW,CAACL,QAAQ,CAACM,OAAO,EAAE,IAAI,CAACE,eAAe,CAAC;IAChER,QAAQ,CAACS,YAAY,GAAG,IAAI;IAC5BT,QAAQ,CAACU,MAAM,GAAG,CAAC;IACnBV,QAAQ,CAACW,gBAAgB,GAAG,IAAI,CAACH,eAAe;IAChDR,QAAQ,CAACY,gBAAgB,GAAG,IAAI,CAACL,eAAe;IAChD,IAAI,CAACM,iBAAiB,CAAC,IAAI,CAACN,eAAe,EAAE,IAAI,CAACC,eAAe,EAAER,QAAQ,EAAEC,YAAY,EAAE,IAAI,CAACa,cAAc,EAAEZ,YAAY,CAAC;IAE7H,IAAI,CAACY,cAAc,CAACC,eAAe,CAACf,QAAQ,CAACM,OAAO,CAAC;IACrD;IACAH,aAAa,CAACC,cAAc,EAAE,IAAI,CAACU,cAAc,EAAEd,QAAQ,CAACS,YAAY,CAAC;EAC7E;EAEOO,cAAc;IACjB,OAAO,IAAIvB,QAAQ,EAAE;EACzB;EAEOwB,IAAI,CAACC,KAAY;IACpB,IAAI,CAACC,MAAM,GAAGD,KAAK;EACvB;EAEQL,iBAAiB,CACrBf,QAAiB,EACjBsB,QAAiB,EACjBpB,QAAkB,EAClBC,YAAoB,EACpBoB,aAAsB,EACtBnB,eAAuC,IAAI;IAE3C,MAAMoB,aAAa,GAAG9B,MAAM,CAAC+B,iBAAiB,GAAG,IAAI;IAErD,IAAIvB,QAAQ,CAACU,MAAM,IAAIT,YAAY,EAAE;MACjCoB,aAAa,CAACG,QAAQ,CAAC1B,QAAQ,CAAC;MAChC;;IAGJ;IACA,MAAM2B,aAAa,GAAGvB,YAAY,GAAGA,YAAY,CAACuB,aAAa,GAAGzB,QAAQ,CAACyB,aAAa;IAExFzB,QAAQ,CAAC0B,WAAW,CAAC5B,QAAQ,EAAEsB,QAAQ,EAAEE,aAAa,CAAC;IAEvD;IACA;IACA,MAAMK,MAAM,GAAIzB,YAAY,IAAIA,YAAY,CAAC0B,iBAAiB,IAAK,IAAI,CAACT,MAAM,CAACQ,MAAM;IAErF,KAAK,IAAIE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,MAAM,CAACG,MAAM,EAAED,KAAK,EAAE,EAAE;MAChD,MAAME,IAAI,GAAGJ,MAAM,CAACE,KAAK,CAAC;MAC1B,IAAIE,IAAI,CAACC,SAAS,EAAE,IAAID,IAAI,CAACE,eAAe,IAAIF,IAAI,CAACG,SAAS,IAAIH,IAAI,KAAK7B,YAAY,IAAI,CAACuB,aAAa,GAAGM,IAAI,CAACI,cAAc,MAAM,CAAC,EAAE;QACpIJ,IAAI,CAACK,eAAe,CAACpC,QAAQ,CAAC;;;IAItC,IAAI,CAACA,QAAQ,CAACqC,cAAc,EAAE;MAC1BvC,QAAQ,CAACwC,QAAQ,CAAClB,QAAQ,EAAEC,aAAa,CAAC;MAC1C;;IAGJ,IAAID,QAAQ,CAACmB,CAAC,KAAK,CAAC,IAAInB,QAAQ,CAACoB,CAAC,KAAK,CAAC,IAAIpB,QAAQ,CAACqB,CAAC,KAAK,CAAC,EAAE;MAC1DzC,QAAQ,CAAC0C,YAAY,CAAC5C,QAAQ,EAAEsB,QAAQ,CAAC;;IAG7C,IAAIA,QAAQ,CAACU,MAAM,EAAE,IAAIR,aAAa,EAAE;MACpCD,aAAa,CAACG,QAAQ,CAAC1B,QAAQ,CAAC;MAChC;;IAGJE,QAAQ,CAACU,MAAM,EAAE;IACjB,IAAI,CAACG,iBAAiB,CAACf,QAAQ,EAAEsB,QAAQ,EAAEpB,QAAQ,EAAEC,YAAY,EAAEoB,aAAa,EAAEnB,YAAY,CAAC;EACnG;;AAGJZ,KAAK,CAACqD,2BAA2B,GAAG,MAAK;EACrC,OAAO,IAAIjD,2BAA2B,EAAE;AAC5C,CAAC","names":["Scene","Vector3","Engine","Collider","DefaultCollisionCoordinator","constructor","Zero","getNewPosition","position","displacement","collider","maximumRetry","excludedMesh","onNewPosition","collisionIndex","divideToRef","_radius","_scaledPosition","_scaledVelocity","collidedMesh","_retry","_initialVelocity","_initialPosition","_collideWithWorld","_finalPosition","multiplyInPlace","createCollider","init","scene","_scene","velocity","finalPosition","closeDistance","CollisionsEpsilon","copyFrom","collisionMask","_initialize","meshes","surroundingMeshes","index","length","mesh","isEnabled","checkCollisions","subMeshes","collisionGroup","_checkCollision","collisionFound","addToRef","x","y","z","_getResponse","CollisionCoordinatorFactory"],"sourceRoot":"","sources":["../../../../lts/core/generated/Collisions/collisionCoordinator.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { Collider } from \"./collider\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/** @internal */\r\nexport interface ICollisionCoordinator {\r\n    createCollider(): Collider;\r\n    getNewPosition(\r\n        position: Vector3,\r\n        displacement: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        excludedMesh: Nullable<AbstractMesh>,\r\n        onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void,\r\n        collisionIndex: number\r\n    ): void;\r\n    init(scene: Scene): void;\r\n}\r\n\r\n/** @internal */\r\nexport class DefaultCollisionCoordinator implements ICollisionCoordinator {\r\n    private _scene: Scene;\r\n\r\n    private _scaledPosition = Vector3.Zero();\r\n    private _scaledVelocity = Vector3.Zero();\r\n\r\n    private _finalPosition = Vector3.Zero();\r\n\r\n    public getNewPosition(\r\n        position: Vector3,\r\n        displacement: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        excludedMesh: AbstractMesh,\r\n        onNewPosition: (collisionIndex: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh>) => void,\r\n        collisionIndex: number\r\n    ): void {\r\n        position.divideToRef(collider._radius, this._scaledPosition);\r\n        displacement.divideToRef(collider._radius, this._scaledVelocity);\r\n        collider.collidedMesh = null;\r\n        collider._retry = 0;\r\n        collider._initialVelocity = this._scaledVelocity;\r\n        collider._initialPosition = this._scaledPosition;\r\n        this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\r\n\r\n        this._finalPosition.multiplyInPlace(collider._radius);\r\n        //run the callback\r\n        onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\r\n    }\r\n\r\n    public createCollider(): Collider {\r\n        return new Collider();\r\n    }\r\n\r\n    public init(scene: Scene): void {\r\n        this._scene = scene;\r\n    }\r\n\r\n    private _collideWithWorld(\r\n        position: Vector3,\r\n        velocity: Vector3,\r\n        collider: Collider,\r\n        maximumRetry: number,\r\n        finalPosition: Vector3,\r\n        excludedMesh: Nullable<AbstractMesh> = null\r\n    ): void {\r\n        const closeDistance = Engine.CollisionsEpsilon * 10.0;\r\n\r\n        if (collider._retry >= maximumRetry) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        // Check if this is a mesh else camera or -1\r\n        const collisionMask = excludedMesh ? excludedMesh.collisionMask : collider.collisionMask;\r\n\r\n        collider._initialize(position, velocity, closeDistance);\r\n\r\n        // Check if collision detection should happen against specified list of meshes or,\r\n        // if not specified, against all meshes in the scene\r\n        const meshes = (excludedMesh && excludedMesh.surroundingMeshes) || this._scene.meshes;\r\n\r\n        for (let index = 0; index < meshes.length; index++) {\r\n            const mesh = meshes[index];\r\n            if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && (collisionMask & mesh.collisionGroup) !== 0) {\r\n                mesh._checkCollision(collider);\r\n            }\r\n        }\r\n\r\n        if (!collider.collisionFound) {\r\n            position.addToRef(velocity, finalPosition);\r\n            return;\r\n        }\r\n\r\n        if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\r\n            collider._getResponse(position, velocity);\r\n        }\r\n\r\n        if (velocity.length() <= closeDistance) {\r\n            finalPosition.copyFrom(position);\r\n            return;\r\n        }\r\n\r\n        collider._retry++;\r\n        this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\r\n    }\r\n}\r\n\r\nScene.CollisionCoordinatorFactory = () => {\r\n    return new DefaultCollisionCoordinator();\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}