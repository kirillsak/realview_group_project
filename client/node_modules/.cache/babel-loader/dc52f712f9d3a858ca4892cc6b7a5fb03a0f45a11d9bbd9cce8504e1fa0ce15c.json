{"ast":null,"code":"import { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer.js\";\nimport { PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { Light } from \"../Lights/light.js\";\n/**\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\n */\nexport class Gizmo {\n  /**\n   * Creates a gizmo\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   */\n  constructor( /** The utility layer the gizmo will be added to */\n  gizmoLayer = UtilityLayerRenderer.DefaultUtilityLayer) {\n    this.gizmoLayer = gizmoLayer;\n    this._attachedMesh = null;\n    this._attachedNode = null;\n    this._customRotationQuaternion = null;\n    /**\n     * Ratio for the scale of the gizmo (Default: 1)\n     */\n    this._scaleRatio = 1;\n    /**\n     * boolean updated by pointermove when a gizmo mesh is hovered\n     */\n    this._isHovered = false;\n    /**\n     * If a custom mesh has been set (Default: false)\n     */\n    this._customMeshSet = false;\n    this._updateGizmoRotationToMatchAttachedMesh = true;\n    this._updateGizmoPositionToMatchAttachedMesh = true;\n    this._updateScale = true;\n    this._interactionsEnabled = true;\n    this._rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\n    this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\n    this._rootMesh.rotationQuaternion = Quaternion.Identity();\n    this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\n      this._update();\n    });\n  }\n  /**\n   * Ratio for the scale of the gizmo (Default: 1)\n   */\n  set scaleRatio(value) {\n    this._scaleRatio = value;\n  }\n  get scaleRatio() {\n    return this._scaleRatio;\n  }\n  /**\n   * True when the mouse pointer is hovered a gizmo mesh\n   */\n  get isHovered() {\n    return this._isHovered;\n  }\n  /**\n   * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\n   * * When set, interactions will be enabled\n   */\n  get attachedMesh() {\n    return this._attachedMesh;\n  }\n  set attachedMesh(value) {\n    this._attachedMesh = value;\n    if (value) {\n      this._attachedNode = value;\n    }\n    this._rootMesh.setEnabled(value ? true : false);\n    this._attachedNodeChanged(value);\n  }\n  /**\n   * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\n   * * When set, interactions will be enabled\n   */\n  get attachedNode() {\n    return this._attachedNode;\n  }\n  set attachedNode(value) {\n    this._attachedNode = value;\n    this._attachedMesh = null;\n    this._rootMesh.setEnabled(value ? true : false);\n    this._attachedNodeChanged(value);\n  }\n  /**\n   * Disposes and replaces the current meshes in the gizmo with the specified mesh\n   * @param mesh The mesh to replace the default mesh of the gizmo\n   */\n  setCustomMesh(mesh) {\n    if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\n      throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\n    }\n    this._rootMesh.getChildMeshes().forEach(c => {\n      c.dispose();\n    });\n    mesh.parent = this._rootMesh;\n    this._customMeshSet = true;\n  }\n  /**\n   * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\n   * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\n   */\n  set updateGizmoRotationToMatchAttachedMesh(value) {\n    this._updateGizmoRotationToMatchAttachedMesh = value;\n  }\n  get updateGizmoRotationToMatchAttachedMesh() {\n    return this._updateGizmoRotationToMatchAttachedMesh;\n  }\n  /**\n   * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\n   */\n  set updateGizmoPositionToMatchAttachedMesh(value) {\n    this._updateGizmoPositionToMatchAttachedMesh = value;\n  }\n  get updateGizmoPositionToMatchAttachedMesh() {\n    return this._updateGizmoPositionToMatchAttachedMesh;\n  }\n  /**\n   * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\n   */\n  set updateScale(value) {\n    this._updateScale = value;\n  }\n  get updateScale() {\n    return this._updateScale;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _attachedNodeChanged(value) {}\n  /**\n   * posture that the gizmo will be display\n   * When set null, default value will be used (Quaternion(0, 0, 0, 1))\n   */\n  get customRotationQuaternion() {\n    return this._customRotationQuaternion;\n  }\n  set customRotationQuaternion(customRotationQuaternion) {\n    this._customRotationQuaternion = customRotationQuaternion;\n  }\n  /**\n   * Updates the gizmo to match the attached mesh's position/rotation\n   */\n  _update() {\n    if (this.attachedNode) {\n      let effectiveNode = this.attachedNode;\n      if (this.attachedMesh) {\n        effectiveNode = this.attachedMesh || this.attachedNode;\n      }\n      // Position\n      if (this.updateGizmoPositionToMatchAttachedMesh) {\n        const row = effectiveNode.getWorldMatrix().getRow(3);\n        const position = row ? row.toVector3() : new Vector3(0, 0, 0);\n        this._rootMesh.position.copyFrom(position);\n      }\n      // Rotation\n      if (this.updateGizmoRotationToMatchAttachedMesh) {\n        const supportedNode = effectiveNode._isMesh || effectiveNode.getClassName() === \"AbstractMesh\" || effectiveNode.getClassName() === \"TransformNode\" || effectiveNode.getClassName() === \"InstancedMesh\";\n        const transformNode = supportedNode ? effectiveNode : undefined;\n        effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\n      } else {\n        if (this._customRotationQuaternion) {\n          this._rootMesh.rotationQuaternion.copyFrom(this._customRotationQuaternion);\n        } else {\n          this._rootMesh.rotationQuaternion.set(0, 0, 0, 1);\n        }\n      }\n      // Scale\n      if (this.updateScale) {\n        const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera;\n        let cameraPosition = activeCamera.globalPosition;\n        if (activeCamera.devicePosition) {\n          cameraPosition = activeCamera.devicePosition;\n        }\n        this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\n        let scale = this.scaleRatio;\n        if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\n          if (activeCamera.orthoTop && activeCamera.orthoBottom) {\n            const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\n            scale *= orthoHeight;\n          }\n        } else {\n          const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\n          const direction = activeCamera.getDirection(camForward);\n          scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\n        }\n        this._rootMesh.scaling.setAll(scale);\n        // Account for handedness, similar to Matrix.decompose\n        if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\n          this._rootMesh.scaling.y *= -1;\n        }\n      } else {\n        this._rootMesh.scaling.setAll(this.scaleRatio);\n      }\n    }\n  }\n  /**\n   * Handle position/translation when using an attached node using pivot\n   */\n  _handlePivot() {\n    const attachedNodeTransform = this._attachedNode;\n    // check there is an active pivot for the TransformNode attached\n    if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {\n      // When a TransformNode has an active pivot, even without parenting,\n      // translation from the world matrix is different from TransformNode.position.\n      // Pivot works like a virtual parent that's using the node orientation.\n      // As the world matrix is transformed by the gizmo and then decomposed to TRS\n      // its translation part must be set to the Node's position.\n      attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);\n    }\n  }\n  /**\n   * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\n   */\n  _matrixChanged() {\n    if (!this._attachedNode) {\n      return;\n    }\n    if (this._attachedNode._isCamera) {\n      const camera = this._attachedNode;\n      let worldMatrix;\n      let worldMatrixUC;\n      if (camera.parent) {\n        const parentInv = TmpVectors.Matrix[1];\n        camera.parent._worldMatrix.invertToRef(parentInv);\n        this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\n        worldMatrix = TmpVectors.Matrix[0];\n      } else {\n        worldMatrix = this._attachedNode._worldMatrix;\n      }\n      if (camera.getScene().useRightHandedSystem) {\n        // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\n        this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\n        worldMatrixUC = TmpVectors.Matrix[1];\n      } else {\n        worldMatrixUC = worldMatrix;\n      }\n      worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n      const inheritsTargetCamera = this._attachedNode.getClassName() === \"FreeCamera\" || this._attachedNode.getClassName() === \"FlyCamera\" || this._attachedNode.getClassName() === \"ArcFollowCamera\" || this._attachedNode.getClassName() === \"TargetCamera\" || this._attachedNode.getClassName() === \"TouchCamera\" || this._attachedNode.getClassName() === \"UniversalCamera\";\n      if (inheritsTargetCamera) {\n        const targetCamera = this._attachedNode;\n        targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\n        if (targetCamera.rotationQuaternion) {\n          targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\n          targetCamera.rotationQuaternion.normalize();\n        }\n      }\n      camera.position.copyFrom(TmpVectors.Vector3[0]);\n    } else if (this._attachedNode._isMesh || this._attachedNode.getClassName() === \"AbstractMesh\" || this._attachedNode.getClassName() === \"TransformNode\" || this._attachedNode.getClassName() === \"InstancedMesh\") {\n      const transform = this._attachedNode;\n      if (transform.parent) {\n        const parentInv = TmpVectors.Matrix[0];\n        const localMat = TmpVectors.Matrix[1];\n        transform.parent.getWorldMatrix().invertToRef(parentInv);\n        this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\n        localMat.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined);\n      } else {\n        this._attachedNode._worldMatrix.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined);\n      }\n      transform.scaling.copyFrom(TmpVectors.Vector3[0]);\n      if (!transform.billboardMode) {\n        if (transform.rotationQuaternion) {\n          transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\n          transform.rotationQuaternion.normalize();\n        } else {\n          transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\n        }\n      }\n    } else if (this._attachedNode.getClassName() === \"Bone\") {\n      const bone = this._attachedNode;\n      const parent = bone.getParent();\n      if (parent) {\n        const invParent = TmpVectors.Matrix[0];\n        const boneLocalMatrix = TmpVectors.Matrix[1];\n        parent.getWorldMatrix().invertToRef(invParent);\n        bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\n        const lmat = bone.getLocalMatrix();\n        lmat.copyFrom(boneLocalMatrix);\n      } else {\n        const lmat = bone.getLocalMatrix();\n        lmat.copyFrom(bone.getWorldMatrix());\n      }\n      bone.markAsDirty();\n    } else {\n      const light = this._attachedNode;\n      if (light.getTypeID) {\n        const type = light.getTypeID();\n        if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\n          const parent = light.parent;\n          if (parent) {\n            const invParent = TmpVectors.Matrix[0];\n            const nodeLocalMatrix = TmpVectors.Matrix[1];\n            parent.getWorldMatrix().invertToRef(invParent);\n            light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\n            nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n          } else {\n            this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\n          }\n          // setter doesn't copy values. Need a new Vector3\n          light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\n          if (light.direction) {\n            light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * refresh gizmo mesh material\n   * @param gizmoMeshes\n   * @param material material to apply\n   */\n  _setGizmoMeshMaterial(gizmoMeshes, material) {\n    if (gizmoMeshes) {\n      gizmoMeshes.forEach(m => {\n        m.material = material;\n        if (m.color) {\n          m.color = material.diffuseColor;\n        }\n      });\n    }\n  }\n  /**\n   * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\n   * @param gizmoLayer The utility layer the gizmo will be added to\n   * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\n   * @returns {Observer<PointerInfo>} pointerObserver\n   */\n  static GizmoAxisPointerObserver(gizmoLayer, gizmoAxisCache) {\n    let dragging = false;\n    const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add(pointerInfo => {\n      var _a, _b;\n      if (pointerInfo.pickInfo) {\n        // On Hover Logic\n        if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\n          if (dragging) {\n            return;\n          }\n          gizmoAxisCache.forEach(cache => {\n            var _a, _b;\n            if (cache.colliderMeshes && cache.gizmoMeshes) {\n              const isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              const material = cache.dragBehavior.enabled ? isHovered || cache.active ? cache.hoverMaterial : cache.material : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(m => {\n                m.material = material;\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            }\n          });\n        }\n        // On Mouse Down\n        if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\n          // If user Clicked Gizmo\n          if (gizmoAxisCache.has((_a = pointerInfo.pickInfo.pickedMesh) === null || _a === void 0 ? void 0 : _a.parent)) {\n            dragging = true;\n            const statusMap = gizmoAxisCache.get((_b = pointerInfo.pickInfo.pickedMesh) === null || _b === void 0 ? void 0 : _b.parent);\n            statusMap.active = true;\n            gizmoAxisCache.forEach(cache => {\n              var _a, _b;\n              const isHovered = ((_a = cache.colliderMeshes) === null || _a === void 0 ? void 0 : _a.indexOf((_b = pointerInfo === null || pointerInfo === void 0 ? void 0 : pointerInfo.pickInfo) === null || _b === void 0 ? void 0 : _b.pickedMesh)) != -1;\n              const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\n              cache.gizmoMeshes.forEach(m => {\n                m.material = material;\n                if (m.color) {\n                  m.color = material.diffuseColor;\n                }\n              });\n            });\n          }\n        }\n        // On Mouse Up\n        if (pointerInfo.type === PointerEventTypes.POINTERUP) {\n          gizmoAxisCache.forEach(cache => {\n            cache.active = false;\n            dragging = false;\n            cache.gizmoMeshes.forEach(m => {\n              m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\n              if (m.color) {\n                m.color = cache.material.diffuseColor;\n              }\n            });\n          });\n        }\n      }\n    });\n    return pointerObserver;\n  }\n  /**\n   * Disposes of the gizmo\n   */\n  dispose() {\n    this._rootMesh.dispose();\n    if (this._beforeRenderObserver) {\n      this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\n    }\n  }\n}\n/**\n * When enabled, any gizmo operation will perserve scaling sign. Default is off.\n * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\n */\nGizmo.PreserveScaling = false;","map":{"version":3,"mappings":"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","names":["Quaternion","Vector3","Matrix","TmpVectors","Mesh","Camera","UtilityLayerRenderer","PointerEventTypes","Light","Gizmo","constructor","gizmoLayer","DefaultUtilityLayer","RotationY","Math","PI","_rootMesh","utilityLayerScene","rotationQuaternion","Identity","_beforeRenderObserver","onBeforeRenderObservable","add","_update","scaleRatio","value","_scaleRatio","isHovered","_isHovered","attachedMesh","_attachedMesh","_attachedNode","setEnabled","_attachedNodeChanged","attachedNode","setCustomMesh","mesh","getScene","getChildMeshes","forEach","c","dispose","parent","_customMeshSet","updateGizmoRotationToMatchAttachedMesh","_updateGizmoRotationToMatchAttachedMesh","updateGizmoPositionToMatchAttachedMesh","_updateGizmoPositionToMatchAttachedMesh","updateScale","_updateScale","customRotationQuaternion","_customRotationQuaternion","effectiveNode","row","getWorldMatrix","getRow","position","toVector3","copyFrom","supportedNode","_isMesh","getClassName","transformNode","undefined","decompose","PreserveScaling","set","activeCamera","cameraPosition","globalPosition","devicePosition","subtractToRef","scale","mode","ORTHOGRAPHIC_CAMERA","orthoTop","orthoBottom","orthoHeight","camForward","useRightHandedSystem","RightHandedForwardReadOnly","LeftHandedForwardReadOnly","direction","getDirection","Dot","scaling","setAll","_getWorldMatrixDeterminant","y","_handlePivot","attachedNodeTransform","isUsingPivotMatrix","setTranslation","_matrixChanged","_isCamera","camera","worldMatrix","worldMatrixUC","parentInv","_worldMatrix","invertToRef","multiplyToRef","_rightHandtoLeftHandMatrix","inheritsTargetCamera","targetCamera","rotation","toEulerAngles","normalize","transform","localMat","billboardMode","bone","getParent","invParent","boneLocalMatrix","lmat","getLocalMatrix","markAsDirty","light","getTypeID","type","LIGHTTYPEID_DIRECTIONALLIGHT","LIGHTTYPEID_SPOTLIGHT","LIGHTTYPEID_POINTLIGHT","nodeLocalMatrix","x","z","_setGizmoMeshMaterial","gizmoMeshes","material","m","color","diffuseColor","GizmoAxisPointerObserver","gizmoAxisCache","dragging","pointerObserver","onPointerObservable","pointerInfo","pickInfo","POINTERMOVE","cache","colliderMeshes","indexOf","pickedMesh","dragBehavior","enabled","active","hoverMaterial","disableMaterial","POINTERDOWN","has","statusMap","get","POINTERUP","remove"],"sourceRoot":"","sources":["../../../../lts/core/generated/Gizmos/gizmo.ts"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { WebVRFreeCamera } from \"../Cameras/VR/webVRCamera\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { TargetCamera } from \"../Cameras/targetCamera\";\r\nimport type { Node } from \"../node\";\r\nimport type { Bone } from \"../Bones/bone\";\r\nimport { UtilityLayerRenderer } from \"../Rendering/utilityLayerRenderer\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport type { PointerInfo } from \"../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { LinesMesh } from \"../Meshes/linesMesh\";\r\nimport type { PointerDragBehavior } from \"../Behaviors/Meshes/pointerDragBehavior\";\r\nimport type { ShadowLight } from \"../Lights/shadowLight\";\r\nimport { Light } from \"../Lights/light\";\r\n\r\n/**\r\n * Cache built by each axis. Used for managing state between all elements of gizmo for enhanced UI\r\n */\r\nexport interface GizmoAxisCache {\r\n    /** Mesh used to render the Gizmo */\r\n    gizmoMeshes: Mesh[];\r\n    /** Mesh used to detect user interaction with Gizmo */\r\n    colliderMeshes: Mesh[];\r\n    /** Material used to indicate color of gizmo mesh */\r\n    material: StandardMaterial;\r\n    /** Material used to indicate hover state of the Gizmo */\r\n    hoverMaterial: StandardMaterial;\r\n    /** Material used to indicate disabled state of the Gizmo */\r\n    disableMaterial: StandardMaterial;\r\n    /** Used to indicate Active state of the Gizmo */\r\n    active: boolean;\r\n    /** DragBehavior */\r\n    dragBehavior: PointerDragBehavior;\r\n}\r\n\r\n/**\r\n * Interface for basic gizmo\r\n */\r\nexport interface IGizmo extends IDisposable {\r\n    /** True when the mouse pointer is hovered a gizmo mesh */\r\n    readonly isHovered: boolean;\r\n    /** The root mesh of the gizmo */\r\n    _rootMesh: Mesh;\r\n    /** Ratio for the scale of the gizmo */\r\n    scaleRatio: number;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedMesh: Nullable<AbstractMesh>;\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    attachedNode: Nullable<Node>;\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoRotationToMatchAttachedMesh: boolean;\r\n    /** The utility layer the gizmo will be added to */\r\n    gizmoLayer: UtilityLayerRenderer;\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    updateGizmoPositionToMatchAttachedMesh: boolean;\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n    updateScale: boolean;\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    customRotationQuaternion: Nullable<Quaternion>;\r\n    /** Disposes and replaces the current meshes in the gizmo with the specified mesh */\r\n    setCustomMesh(mesh: Mesh): void;\r\n}\r\n/**\r\n * Renders gizmos on top of an existing scene which provide controls for position, rotation, etc.\r\n */\r\nexport class Gizmo implements IGizmo {\r\n    /**\r\n     * The root mesh of the gizmo\r\n     */\r\n    public _rootMesh: Mesh;\r\n    protected _attachedMesh: Nullable<AbstractMesh> = null;\r\n    protected _attachedNode: Nullable<Node> = null;\r\n    protected _customRotationQuaternion: Nullable<Quaternion> = null;\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    protected _scaleRatio = 1;\r\n\r\n    /**\r\n     * boolean updated by pointermove when a gizmo mesh is hovered\r\n     */\r\n    protected _isHovered = false;\r\n\r\n    /**\r\n     * When enabled, any gizmo operation will perserve scaling sign. Default is off.\r\n     * Only valid for TransformNode derived classes (Mesh, AbstractMesh, ...)\r\n     */\r\n    public static PreserveScaling = false;\r\n\r\n    /**\r\n     * Ratio for the scale of the gizmo (Default: 1)\r\n     */\r\n    public set scaleRatio(value: number) {\r\n        this._scaleRatio = value;\r\n    }\r\n\r\n    public get scaleRatio() {\r\n        return this._scaleRatio;\r\n    }\r\n\r\n    /**\r\n     * True when the mouse pointer is hovered a gizmo mesh\r\n     */\r\n    public get isHovered() {\r\n        return this._isHovered;\r\n    }\r\n\r\n    /**\r\n     * If a custom mesh has been set (Default: false)\r\n     */\r\n    protected _customMeshSet = false;\r\n    /**\r\n     * Mesh that the gizmo will be attached to. (eg. on a drag gizmo the mesh that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n    public set attachedMesh(value) {\r\n        this._attachedMesh = value;\r\n        if (value) {\r\n            this._attachedNode = value;\r\n        }\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n    /**\r\n     * Node that the gizmo will be attached to. (eg. on a drag gizmo the mesh, bone or NodeTransform that will be dragged)\r\n     * * When set, interactions will be enabled\r\n     */\r\n    public get attachedNode() {\r\n        return this._attachedNode;\r\n    }\r\n    public set attachedNode(value) {\r\n        this._attachedNode = value;\r\n        this._attachedMesh = null;\r\n        this._rootMesh.setEnabled(value ? true : false);\r\n        this._attachedNodeChanged(value);\r\n    }\r\n\r\n    /**\r\n     * Disposes and replaces the current meshes in the gizmo with the specified mesh\r\n     * @param mesh The mesh to replace the default mesh of the gizmo\r\n     */\r\n    public setCustomMesh(mesh: Mesh) {\r\n        if (mesh.getScene() != this.gizmoLayer.utilityLayerScene) {\r\n            throw \"When setting a custom mesh on a gizmo, the custom meshes scene must be the same as the gizmos (eg. gizmo.gizmoLayer.utilityLayerScene)\";\r\n        }\r\n        this._rootMesh.getChildMeshes().forEach((c) => {\r\n            c.dispose();\r\n        });\r\n        mesh.parent = this._rootMesh;\r\n        this._customMeshSet = true;\r\n    }\r\n\r\n    protected _updateGizmoRotationToMatchAttachedMesh = true;\r\n    protected _updateGizmoPositionToMatchAttachedMesh = true;\r\n    protected _updateScale = true;\r\n\r\n    /**\r\n     * If set the gizmo's rotation will be updated to match the attached mesh each frame (Default: true)\r\n     * NOTE: This is only possible for meshes with uniform scaling, as otherwise it's not possible to decompose the rotation\r\n     */\r\n    public set updateGizmoRotationToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoRotationToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoRotationToMatchAttachedMesh() {\r\n        return this._updateGizmoRotationToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * If set the gizmo's position will be updated to match the attached mesh each frame (Default: true)\r\n     */\r\n    public set updateGizmoPositionToMatchAttachedMesh(value: boolean) {\r\n        this._updateGizmoPositionToMatchAttachedMesh = value;\r\n    }\r\n    public get updateGizmoPositionToMatchAttachedMesh() {\r\n        return this._updateGizmoPositionToMatchAttachedMesh;\r\n    }\r\n    /**\r\n     * When set, the gizmo will always appear the same size no matter where the camera is (default: true)\r\n     */\r\n\r\n    public set updateScale(value: boolean) {\r\n        this._updateScale = value;\r\n    }\r\n    public get updateScale() {\r\n        return this._updateScale;\r\n    }\r\n    protected _interactionsEnabled = true;\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _attachedNodeChanged(value: Nullable<Node>) {}\r\n\r\n    protected _beforeRenderObserver: Nullable<Observer<Scene>>;\r\n    private _rightHandtoLeftHandMatrix = Matrix.RotationY(Math.PI);\r\n\r\n    /**\r\n     * Creates a gizmo\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     */\r\n    constructor(\r\n        /** The utility layer the gizmo will be added to */\r\n        public gizmoLayer: UtilityLayerRenderer = UtilityLayerRenderer.DefaultUtilityLayer\r\n    ) {\r\n        this._rootMesh = new Mesh(\"gizmoRootNode\", gizmoLayer.utilityLayerScene);\r\n        this._rootMesh.rotationQuaternion = Quaternion.Identity();\r\n\r\n        this._beforeRenderObserver = this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.add(() => {\r\n            this._update();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * posture that the gizmo will be display\r\n     * When set null, default value will be used (Quaternion(0, 0, 0, 1))\r\n     */\r\n    public get customRotationQuaternion(): Nullable<Quaternion> {\r\n        return this._customRotationQuaternion;\r\n    }\r\n\r\n    public set customRotationQuaternion(customRotationQuaternion: Nullable<Quaternion>) {\r\n        this._customRotationQuaternion = customRotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Updates the gizmo to match the attached mesh's position/rotation\r\n     */\r\n    protected _update() {\r\n        if (this.attachedNode) {\r\n            let effectiveNode = this.attachedNode;\r\n            if (this.attachedMesh) {\r\n                effectiveNode = this.attachedMesh || this.attachedNode;\r\n            }\r\n\r\n            // Position\r\n            if (this.updateGizmoPositionToMatchAttachedMesh) {\r\n                const row = effectiveNode.getWorldMatrix().getRow(3);\r\n                const position = row ? row.toVector3() : new Vector3(0, 0, 0);\r\n                this._rootMesh.position.copyFrom(position);\r\n            }\r\n\r\n            // Rotation\r\n            if (this.updateGizmoRotationToMatchAttachedMesh) {\r\n                const supportedNode =\r\n                    (<Mesh>effectiveNode)._isMesh ||\r\n                    effectiveNode.getClassName() === \"AbstractMesh\" ||\r\n                    effectiveNode.getClassName() === \"TransformNode\" ||\r\n                    effectiveNode.getClassName() === \"InstancedMesh\";\r\n                const transformNode = supportedNode ? (effectiveNode as TransformNode) : undefined;\r\n                effectiveNode.getWorldMatrix().decompose(undefined, this._rootMesh.rotationQuaternion!, undefined, Gizmo.PreserveScaling ? transformNode : undefined);\r\n            } else {\r\n                if (this._customRotationQuaternion) {\r\n                    this._rootMesh.rotationQuaternion!.copyFrom(this._customRotationQuaternion);\r\n                } else {\r\n                    this._rootMesh.rotationQuaternion!.set(0, 0, 0, 1);\r\n                }\r\n            }\r\n\r\n            // Scale\r\n            if (this.updateScale) {\r\n                const activeCamera = this.gizmoLayer.utilityLayerScene.activeCamera!;\r\n                let cameraPosition = activeCamera.globalPosition;\r\n                if ((<WebVRFreeCamera>activeCamera).devicePosition) {\r\n                    cameraPosition = (<WebVRFreeCamera>activeCamera).devicePosition;\r\n                }\r\n                this._rootMesh.position.subtractToRef(cameraPosition, TmpVectors.Vector3[0]);\r\n                let scale = this.scaleRatio;\r\n                if (activeCamera.mode == Camera.ORTHOGRAPHIC_CAMERA) {\r\n                    if (activeCamera.orthoTop && activeCamera.orthoBottom) {\r\n                        const orthoHeight = activeCamera.orthoTop - activeCamera.orthoBottom;\r\n                        scale *= orthoHeight;\r\n                    }\r\n                } else {\r\n                    const camForward = activeCamera.getScene().useRightHandedSystem ? Vector3.RightHandedForwardReadOnly : Vector3.LeftHandedForwardReadOnly;\r\n                    const direction = activeCamera.getDirection(camForward);\r\n                    scale *= Vector3.Dot(TmpVectors.Vector3[0], direction);\r\n                }\r\n                this._rootMesh.scaling.setAll(scale);\r\n\r\n                // Account for handedness, similar to Matrix.decompose\r\n                if (effectiveNode._getWorldMatrixDeterminant() < 0 && !Gizmo.PreserveScaling) {\r\n                    this._rootMesh.scaling.y *= -1;\r\n                }\r\n            } else {\r\n                this._rootMesh.scaling.setAll(this.scaleRatio);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle position/translation when using an attached node using pivot\r\n     */\r\n    protected _handlePivot() {\r\n        const attachedNodeTransform = this._attachedNode as any;\r\n        // check there is an active pivot for the TransformNode attached\r\n        if (attachedNodeTransform.isUsingPivotMatrix && attachedNodeTransform.isUsingPivotMatrix() && attachedNodeTransform.position) {\r\n            // When a TransformNode has an active pivot, even without parenting,\r\n            // translation from the world matrix is different from TransformNode.position.\r\n            // Pivot works like a virtual parent that's using the node orientation.\r\n            // As the world matrix is transformed by the gizmo and then decomposed to TRS\r\n            // its translation part must be set to the Node's position.\r\n            attachedNodeTransform.getWorldMatrix().setTranslation(attachedNodeTransform.position);\r\n        }\r\n    }\r\n    /**\r\n     * computes the rotation/scaling/position of the transform once the Node world matrix has changed.\r\n     */\r\n    protected _matrixChanged() {\r\n        if (!this._attachedNode) {\r\n            return;\r\n        }\r\n\r\n        if ((<Camera>this._attachedNode)._isCamera) {\r\n            const camera = this._attachedNode as Camera;\r\n            let worldMatrix;\r\n            let worldMatrixUC;\r\n            if (camera.parent) {\r\n                const parentInv = TmpVectors.Matrix[1];\r\n                camera.parent._worldMatrix.invertToRef(parentInv);\r\n                this._attachedNode._worldMatrix.multiplyToRef(parentInv, TmpVectors.Matrix[0]);\r\n                worldMatrix = TmpVectors.Matrix[0];\r\n            } else {\r\n                worldMatrix = this._attachedNode._worldMatrix;\r\n            }\r\n\r\n            if (camera.getScene().useRightHandedSystem) {\r\n                // avoid desync with RH matrix computation. Otherwise, rotation of PI around Y axis happens each frame resulting in axis flipped because worldMatrix is computed as inverse of viewMatrix.\r\n                this._rightHandtoLeftHandMatrix.multiplyToRef(worldMatrix, TmpVectors.Matrix[1]);\r\n                worldMatrixUC = TmpVectors.Matrix[1];\r\n            } else {\r\n                worldMatrixUC = worldMatrix;\r\n            }\r\n\r\n            worldMatrixUC.decompose(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n\r\n            const inheritsTargetCamera =\r\n                this._attachedNode.getClassName() === \"FreeCamera\" ||\r\n                this._attachedNode.getClassName() === \"FlyCamera\" ||\r\n                this._attachedNode.getClassName() === \"ArcFollowCamera\" ||\r\n                this._attachedNode.getClassName() === \"TargetCamera\" ||\r\n                this._attachedNode.getClassName() === \"TouchCamera\" ||\r\n                this._attachedNode.getClassName() === \"UniversalCamera\";\r\n\r\n            if (inheritsTargetCamera) {\r\n                const targetCamera = this._attachedNode as TargetCamera;\r\n                targetCamera.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n\r\n                if (targetCamera.rotationQuaternion) {\r\n                    targetCamera.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    targetCamera.rotationQuaternion.normalize();\r\n                }\r\n            }\r\n\r\n            camera.position.copyFrom(TmpVectors.Vector3[0]);\r\n        } else if (\r\n            (<Mesh>this._attachedNode)._isMesh ||\r\n            this._attachedNode.getClassName() === \"AbstractMesh\" ||\r\n            this._attachedNode.getClassName() === \"TransformNode\" ||\r\n            this._attachedNode.getClassName() === \"InstancedMesh\"\r\n        ) {\r\n            const transform = this._attachedNode as TransformNode;\r\n            if (transform.parent) {\r\n                const parentInv = TmpVectors.Matrix[0];\r\n                const localMat = TmpVectors.Matrix[1];\r\n                transform.parent.getWorldMatrix().invertToRef(parentInv);\r\n                this._attachedNode.getWorldMatrix().multiplyToRef(parentInv, localMat);\r\n                localMat.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            } else {\r\n                this._attachedNode._worldMatrix.decompose(TmpVectors.Vector3[0], TmpVectors.Quaternion[0], transform.position, Gizmo.PreserveScaling ? transform : undefined);\r\n            }\r\n            transform.scaling.copyFrom(TmpVectors.Vector3[0]);\r\n            if (!transform.billboardMode) {\r\n                if (transform.rotationQuaternion) {\r\n                    transform.rotationQuaternion.copyFrom(TmpVectors.Quaternion[0]);\r\n                    transform.rotationQuaternion.normalize();\r\n                } else {\r\n                    transform.rotation = TmpVectors.Quaternion[0].toEulerAngles();\r\n                }\r\n            }\r\n        } else if (this._attachedNode.getClassName() === \"Bone\") {\r\n            const bone = this._attachedNode as Bone;\r\n            const parent = bone.getParent();\r\n\r\n            if (parent) {\r\n                const invParent = TmpVectors.Matrix[0];\r\n                const boneLocalMatrix = TmpVectors.Matrix[1];\r\n                parent.getWorldMatrix().invertToRef(invParent);\r\n                bone.getWorldMatrix().multiplyToRef(invParent, boneLocalMatrix);\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(boneLocalMatrix);\r\n            } else {\r\n                const lmat = bone.getLocalMatrix();\r\n                lmat.copyFrom(bone.getWorldMatrix());\r\n            }\r\n            bone.markAsDirty();\r\n        } else {\r\n            const light = this._attachedNode as ShadowLight;\r\n            if (light.getTypeID) {\r\n                const type = light.getTypeID();\r\n                if (type === Light.LIGHTTYPEID_DIRECTIONALLIGHT || type === Light.LIGHTTYPEID_SPOTLIGHT || type === Light.LIGHTTYPEID_POINTLIGHT) {\r\n                    const parent = light.parent;\r\n\r\n                    if (parent) {\r\n                        const invParent = TmpVectors.Matrix[0];\r\n                        const nodeLocalMatrix = TmpVectors.Matrix[1];\r\n                        parent.getWorldMatrix().invertToRef(invParent);\r\n                        light.getWorldMatrix().multiplyToRef(invParent, nodeLocalMatrix);\r\n                        nodeLocalMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    } else {\r\n                        this._attachedNode._worldMatrix.decompose(undefined, TmpVectors.Quaternion[0], TmpVectors.Vector3[0]);\r\n                    }\r\n                    // setter doesn't copy values. Need a new Vector3\r\n                    light.position = new Vector3(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z);\r\n                    if (light.direction) {\r\n                        light.direction = new Vector3(light.direction.x, light.direction.y, light.direction.z);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * refresh gizmo mesh material\r\n     * @param gizmoMeshes\r\n     * @param material material to apply\r\n     */\r\n    protected _setGizmoMeshMaterial(gizmoMeshes: Mesh[], material: StandardMaterial) {\r\n        if (gizmoMeshes) {\r\n            gizmoMeshes.forEach((m: Mesh) => {\r\n                m.material = material;\r\n                if ((<LinesMesh>m).color) {\r\n                    (<LinesMesh>m).color = material.diffuseColor;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subscribes to pointer up, down, and hover events. Used for responsive gizmos.\r\n     * @param gizmoLayer The utility layer the gizmo will be added to\r\n     * @param gizmoAxisCache Gizmo axis definition used for reactive gizmo UI\r\n     * @returns {Observer<PointerInfo>} pointerObserver\r\n     */\r\n    public static GizmoAxisPointerObserver(gizmoLayer: UtilityLayerRenderer, gizmoAxisCache: Map<Mesh, GizmoAxisCache>): Observer<PointerInfo> {\r\n        let dragging = false;\r\n\r\n        const pointerObserver = gizmoLayer.utilityLayerScene.onPointerObservable.add((pointerInfo) => {\r\n            if (pointerInfo.pickInfo) {\r\n                // On Hover Logic\r\n                if (pointerInfo.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (dragging) {\r\n                        return;\r\n                    }\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        if (cache.colliderMeshes && cache.gizmoMeshes) {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = cache.dragBehavior.enabled ? (isHovered || cache.active ? cache.hoverMaterial : cache.material) : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // On Mouse Down\r\n                if (pointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If user Clicked Gizmo\r\n                    if (gizmoAxisCache.has(pointerInfo.pickInfo.pickedMesh?.parent as Mesh)) {\r\n                        dragging = true;\r\n                        const statusMap = gizmoAxisCache.get(pointerInfo.pickInfo.pickedMesh?.parent as Mesh);\r\n                        statusMap!.active = true;\r\n                        gizmoAxisCache.forEach((cache) => {\r\n                            const isHovered = cache.colliderMeshes?.indexOf(pointerInfo?.pickInfo?.pickedMesh as Mesh) != -1;\r\n                            const material = (isHovered || cache.active) && cache.dragBehavior.enabled ? cache.hoverMaterial : cache.disableMaterial;\r\n                            cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                                m.material = material;\r\n                                if ((m as LinesMesh).color) {\r\n                                    (m as LinesMesh).color = material.diffuseColor;\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // On Mouse Up\r\n                if (pointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                    gizmoAxisCache.forEach((cache) => {\r\n                        cache.active = false;\r\n                        dragging = false;\r\n                        cache.gizmoMeshes.forEach((m: Mesh) => {\r\n                            m.material = cache.dragBehavior.enabled ? cache.material : cache.disableMaterial;\r\n                            if ((m as LinesMesh).color) {\r\n                                (m as LinesMesh).color = cache.material.diffuseColor;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return pointerObserver!;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the gizmo\r\n     */\r\n    public dispose() {\r\n        this._rootMesh.dispose();\r\n        if (this._beforeRenderObserver) {\r\n            this.gizmoLayer.utilityLayerScene.onBeforeRenderObservable.remove(this._beforeRenderObserver);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}