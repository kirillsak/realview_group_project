{"ast":null,"code":"// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\n#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\nuniform sampler2D normalSampler;\nuniform sampler2D positionSampler;\n#endif\nuniform mat4 view;\nuniform mat4 projection;\nuniform float stepSize;\nuniform float strength;\nuniform float threshold;\nuniform float roughnessFactor;\nuniform float reflectionSpecularFalloffExponent;\nvarying vec2 vUV;\n#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {\nvec3 color;\nvec4 coords;\n};\n/**\n* According to specular,see https:\n*/\nvec3 fresnelSchlick(float cosTheta,vec3 F0)\n{\nreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\n}\n/**\n* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\n* by sampling multiple reflection pixels.\n*/\nReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\n{\nReflectionInfo info;\ninfo.color=vec3(0.0);\nvec4 projectedCoord;\nfloat sampledDepth;\nfor(int i=0; i<SMOOTH_STEPS; i++)\n{\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\nfloat depth=sampledDepth-hitCoord.z;\ndir*=0.5;\nif(depth>0.0)\nhitCoord-=dir;\nelse\nhitCoord+=dir;\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\n}\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\ninfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.color/=float(SMOOTH_STEPS+1);\nreturn info;\n}\n/**\n* Tests the given world position (hitCoord) according to the given reflection vector (dir)\n* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\n*/\nReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\n{\nReflectionInfo info;\nvec4 projectedCoord;\nfloat sampledDepth;\ndir*=stepSize;\nfor(int i=0; i<REFLECTION_SAMPLES; i++)\n{\nhitCoord+=dir;\nprojectedCoord=projection*vec4(hitCoord,1.0);\nprojectedCoord.xy/=projectedCoord.w;\nprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\nsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\nfloat depth=sampledDepth-hitCoord.z;\n#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\n#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\n{\n#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\n#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\nreturn info;\n#endif\n}\n}\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\ninfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\nreturn info;\n}\nvec3 hash(vec3 a)\n{\na=fract(a*0.8);\na+=dot(a,a.yxz+19.19);\nreturn fract((a.xxy+a.yxx)*a.zyx);\n}\n#endif\nvoid main()\n{\n#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);\nvec3 albedo=albedoFull.rgb;\nfloat spec=texture2D(reflectivitySampler,vUV).r;\nif (spec==0.0) {\ngl_FragColor=albedoFull;\nreturn;\n}\nvec3 normal=(texture2D(normalSampler,vUV)).xyz;\nvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\nvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\nfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\nvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\nReflectionInfo info=getReflectionInfo(jitt+reflected,position);\nvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\nfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\nvec3 F0=vec3(0.04);\nF0 =mix(F0,albedo,spec);\nvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\n#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\n#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\nfloat albedoMultiplier=1.0-reflectionMultiplier;\nvec3 SSR=info.color*fresnel;\ngl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\n#else\ngl_FragColor=texture2D(textureSampler,vUV);\n#endif\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflectionPixelShader = {\n  name,\n  shader\n};","map":{"version":3,"mappings":"AAAA;AACA,SAASA,WAAW,QAAQ,2BAAyB;AAErD,MAAMC,IAAI,GAAG,kCAAkC;AAC/C,MAAMC,MAAM,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqId;AACD;AACAF,WAAW,CAACG,YAAY,CAACF,IAAI,CAAC,GAAGC,MAAM;AACvC;AACA,OAAO,MAAME,gCAAgC,GAAG;EAAEH,IAAI;EAAEC;AAAM,CAAE","names":["ShaderStore","name","shader","ShadersStore","screenSpaceReflectionPixelShader"],"sourceRoot":"","sources":["../../../../lts/core/generated/Shaders/screenSpaceReflection.fragment.ts"],"sourcesContent":["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"screenSpaceReflectionPixelShader\";\nconst shader = `uniform sampler2D textureSampler;\r#ifdef SSR_SUPPORTED\nuniform sampler2D reflectivitySampler;\runiform sampler2D normalSampler;\runiform sampler2D positionSampler;\r#endif\nuniform mat4 view;\runiform mat4 projection;\runiform float stepSize;\runiform float strength;\runiform float threshold;\runiform float roughnessFactor;\runiform float reflectionSpecularFalloffExponent;\rvarying vec2 vUV;\r#ifdef SSR_SUPPORTED\nstruct ReflectionInfo {\rvec3 color;\rvec4 coords;\r};\r/**\r* According to specular,see https:\r*/\rvec3 fresnelSchlick(float cosTheta,vec3 F0)\r{\rreturn F0+(1.0-F0)*pow(1.0-cosTheta,5.0);\r}\r/**\r* Once the pixel's coordinates has been found,let's adjust (smooth) a little bit\r* by sampling multiple reflection pixels.\r*/\rReflectionInfo smoothReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rinfo.color=vec3(0.0);\rvec4 projectedCoord;\rfloat sampledDepth;\rfor(int i=0; i<SMOOTH_STEPS; i++)\r{\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\rdir*=0.5;\rif(depth>0.0)\rhitCoord-=dir;\relse\rhitCoord+=dir;\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\r}\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,1.0);\rinfo.color+=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.color/=float(SMOOTH_STEPS+1);\rreturn info;\r}\r/**\r* Tests the given world position (hitCoord) according to the given reflection vector (dir)\r* until it finds a collision (means that depth is enough close to say \"it's the pixel to sample!\").\r*/\rReflectionInfo getReflectionInfo(vec3 dir,vec3 hitCoord)\r{\rReflectionInfo info;\rvec4 projectedCoord;\rfloat sampledDepth;\rdir*=stepSize;\rfor(int i=0; i<REFLECTION_SAMPLES; i++)\r{\rhitCoord+=dir;\rprojectedCoord=projection*vec4(hitCoord,1.0);\rprojectedCoord.xy/=projectedCoord.w;\rprojectedCoord.xy=0.5*projectedCoord.xy+vec2(0.5);\rsampledDepth=(view*texture2D(positionSampler,projectedCoord.xy)).z;\rfloat depth=sampledDepth-hitCoord.z;\r#ifdef RIGHT_HANDED_SCENE\ndepth*=-1.0;\r#endif\nif(((depth-dir.z)<threshold) && depth<=0.0)\r{\r#ifdef ENABLE_SMOOTH_REFLECTIONS\nreturn smoothReflectionInfo(dir,hitCoord);\r#else\ninfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r#endif\n}\r}\rinfo.color=texture2D(textureSampler,projectedCoord.xy).rgb;\rinfo.coords=vec4(projectedCoord.xy,sampledDepth,0.0);\rreturn info;\r}\rvec3 hash(vec3 a)\r{\ra=fract(a*0.8);\ra+=dot(a,a.yxz+19.19);\rreturn fract((a.xxy+a.yxx)*a.zyx);\r}\r#endif\nvoid main()\r{\r#ifdef SSR_SUPPORTED\nvec4 albedoFull=texture2D(textureSampler,vUV);\rvec3 albedo=albedoFull.rgb;\rfloat spec=texture2D(reflectivitySampler,vUV).r;\rif (spec==0.0) {\rgl_FragColor=albedoFull;\rreturn;\r}\rvec3 normal=(texture2D(normalSampler,vUV)).xyz;\rvec3 position=(view*texture2D(positionSampler,vUV)).xyz;\rvec3 reflected=normalize(reflect(normalize(position),normalize(normal)));\rfloat roughness=1.0-texture2D(reflectivitySampler,vUV).a;\rvec3 jitt=mix(vec3(0.0),hash(position),roughness)*roughnessFactor;\rReflectionInfo info=getReflectionInfo(jitt+reflected,position);\rvec2 dCoords=smoothstep(0.2,0.6,abs(vec2(0.5,0.5)-info.coords.xy));\rfloat screenEdgefactor=clamp(1.0-(dCoords.x+dCoords.y),0.0,1.0);\rvec3 F0=vec3(0.04);\rF0 =mix(F0,albedo,spec);\rvec3 fresnel=fresnelSchlick(max(dot(normalize(normal),normalize(position)),0.0),F0);\r#ifdef RIGHT_HANDED_SCENE\nreflected.z*=-1.0;\r#endif\nfloat reflectionMultiplier=clamp(pow(spec*strength,reflectionSpecularFalloffExponent)*screenEdgefactor*reflected.z,0.0,0.9);\rfloat albedoMultiplier=1.0-reflectionMultiplier;\rvec3 SSR=info.color*fresnel;\rgl_FragColor=vec4((albedo*albedoMultiplier)+(SSR*reflectionMultiplier),albedoFull.a);\r#else\ngl_FragColor=texture2D(textureSampler,vUV);\r#endif\n}\r`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const screenSpaceReflectionPixelShader = { name, shader };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}