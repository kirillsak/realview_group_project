{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools.js\";\n/**\n * Class used to inline functions in shader code\n */\nexport class ShaderCodeInliner {\n  /**\n   * Initializes the inliner\n   * @param sourceCode shader code source to inline\n   * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\n   */\n  constructor(sourceCode, numMaxIterations = 20) {\n    /** Gets or sets the debug mode */\n    this.debug = false;\n    this._sourceCode = sourceCode;\n    this._numMaxIterations = numMaxIterations;\n    this._functionDescr = [];\n    this.inlineToken = \"#define inline\";\n  }\n  /** Gets the code after the inlining process */\n  get code() {\n    return this._sourceCode;\n  }\n  /**\n   * Start the processing of the shader code\n   */\n  processCode() {\n    if (this.debug) {\n      console.log(`Start inlining process (code size=${this._sourceCode.length})...`);\n    }\n    this._collectFunctions();\n    this._processInlining(this._numMaxIterations);\n    if (this.debug) {\n      console.log(\"End of inlining process.\");\n    }\n  }\n  _collectFunctions() {\n    let startIndex = 0;\n    while (startIndex < this._sourceCode.length) {\n      // locate the function to inline and extract its name\n      const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\n      if (inlineTokenIndex < 0) {\n        break;\n      }\n      const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\n      if (funcParamsStartIndex < 0) {\n        if (this.debug) {\n          console.warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex));\n      if (!funcNameMatch) {\n        if (this.debug) {\n          console.warn(`Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\n      // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\n      const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\n      if (funcParamsEndIndex < 0) {\n        if (this.debug) {\n          console.warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\n      // extract the body of the function (with the curly brackets)\n      const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\n      if (funcBodyStartIndex === this._sourceCode.length) {\n        if (this.debug) {\n          console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\n      if (funcBodyEndIndex < 0) {\n        if (this.debug) {\n          console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\n        }\n        startIndex = inlineTokenIndex + this.inlineToken.length;\n        continue;\n      }\n      const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\n      // process the parameters: extract each names\n      const params = RemoveComments(funcParams).split(\",\");\n      const paramNames = [];\n      for (let p = 0; p < params.length; ++p) {\n        const param = params[p].trim();\n        const idx = param.lastIndexOf(\" \");\n        if (idx >= 0) {\n          paramNames.push(param.substring(idx + 1));\n        }\n      }\n      if (funcType !== \"void\") {\n        // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\n        paramNames.push(\"return\");\n      }\n      // collect the function\n      this._functionDescr.push({\n        name: funcName,\n        type: funcType,\n        parameters: paramNames,\n        body: funcBody,\n        callIndex: 0\n      });\n      startIndex = funcBodyEndIndex + 1;\n      // remove the function from the source code\n      const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\n      const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\n      this._sourceCode = partBefore + partAfter;\n      startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\n    }\n    if (this.debug) {\n      console.log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=`, this._functionDescr);\n    }\n  }\n  _processInlining(numMaxIterations = 20) {\n    while (numMaxIterations-- >= 0) {\n      if (!this._replaceFunctionCallsByCode()) {\n        break;\n      }\n    }\n    if (this.debug) {\n      console.log(`numMaxIterations is ${numMaxIterations} after inlining process`);\n    }\n    return numMaxIterations >= 0;\n  }\n  _replaceFunctionCallsByCode() {\n    let doAgain = false;\n    for (const func of this._functionDescr) {\n      const {\n        name,\n        type,\n        parameters,\n        body\n      } = func;\n      let startIndex = 0;\n      while (startIndex < this._sourceCode.length) {\n        // Look for the function name in the source code\n        const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\n        if (functionCallIndex < 0) {\n          break;\n        }\n        // Make sure \"name\" is not part of a bigger string\n        if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        // Find the opening parenthesis\n        const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\n        if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\n        const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\n        if (callParamsEndIndex < 0) {\n          if (this.debug) {\n            console.warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\n          }\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\n        // process the parameter call: extract each names\n        // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\n        //      myfunc(a, vec2(1., 0.), 4.)\n        const splitParameterCall = s => {\n          const parameters = [];\n          let curIdx = 0,\n            startParamIdx = 0;\n          while (curIdx < s.length) {\n            if (s.charAt(curIdx) === \"(\") {\n              const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\n              if (idx2 < 0) {\n                return null;\n              }\n              curIdx = idx2;\n            } else if (s.charAt(curIdx) === \",\") {\n              parameters.push(s.substring(startParamIdx, curIdx));\n              startParamIdx = curIdx + 1;\n            }\n            curIdx++;\n          }\n          if (startParamIdx < curIdx) {\n            parameters.push(s.substring(startParamIdx, curIdx));\n          }\n          return parameters;\n        };\n        const params = splitParameterCall(RemoveComments(callParams));\n        if (params === null) {\n          if (this.debug) {\n            console.warn(`Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` + callParams);\n          }\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        const paramNames = [];\n        for (let p = 0; p < params.length; ++p) {\n          const param = params[p].trim();\n          paramNames.push(param);\n        }\n        const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\n        if (retParamName) {\n          paramNames.push(retParamName + \" =\");\n        }\n        if (paramNames.length !== parameters.length) {\n          if (this.debug) {\n            console.warn(`Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`);\n          }\n          startIndex = functionCallIndex + name.length;\n          continue;\n        }\n        startIndex = callParamsEndIndex + 1;\n        // replace the function call by the body function\n        const funcBody = this._replaceNames(body, parameters, paramNames);\n        let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\n        const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\n        if (retParamName) {\n          // case where the function returns a value. We generate:\n          // FUNCTYPE retParamName;\n          // {function body}\n          // and replace the function call by retParamName\n          const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\");\n          partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\n          const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\n          this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\n          if (this.debug) {\n            console.log(`Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`);\n          }\n        } else {\n          // simple case where the return value of the function is \"void\"\n          this._sourceCode = partBefore + funcBody + partAfter;\n          startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\n          if (this.debug) {\n            console.log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\n          }\n        }\n        doAgain = true;\n      }\n    }\n    return doAgain;\n  }\n  _replaceNames(code, sources, destinations) {\n    for (let i = 0; i < sources.length; ++i) {\n      const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\n        sourceLen = sources[i].length,\n        destination = destinations[i];\n      code = code.replace(source, (match, ...args) => {\n        const offset = args[0];\n        // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\n        if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\n          return sources[i];\n        }\n        return destination;\n      });\n    }\n    return code;\n  }\n}\nShaderCodeInliner._RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;","map":{"version":3,"mappings":"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","names":["EscapeRegExp","ExtractBetweenMarkers","FindBackward","IsIdentifierChar","RemoveComments","SkipWhitespaces","ShaderCodeInliner","constructor","sourceCode","numMaxIterations","_sourceCode","_numMaxIterations","_functionDescr","inlineToken","code","processCode","debug","console","log","length","_collectFunctions","_processInlining","startIndex","inlineTokenIndex","indexOf","funcParamsStartIndex","warn","funcNameMatch","_RegexpFindFunctionNameAndType","exec","substring","funcType","funcName","funcParamsEndIndex","funcParams","funcBodyStartIndex","funcBodyEndIndex","funcBody","params","split","paramNames","p","param","trim","idx","lastIndexOf","push","name","type","parameters","body","callIndex","partBefore","partAfter","_replaceFunctionCallsByCode","doAgain","func","functionCallIndex","charAt","callParamsStartIndex","callParamsEndIndex","callParams","splitParameterCall","s","curIdx","startParamIdx","idx2","retParamName","_replaceNames","injectDeclarationIndex","partBetween","sources","destinations","i","source","RegExp","sourceLen","destination","replace","match","args","offset"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/Processors/shaderCodeInliner.ts"],"sourcesContent":["import { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            console.log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            console.log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    console.warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    console.warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=`, this._functionDescr);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            console.log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        console.warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        console.warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        console.warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        console.log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        console.log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}