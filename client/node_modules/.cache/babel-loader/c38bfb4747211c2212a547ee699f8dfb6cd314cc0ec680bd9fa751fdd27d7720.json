{"ast":null,"code":"import { ExternalTexture } from \"../../Materials/Textures/externalTexture.js\";\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler.js\";\n/** @internal */\nexport class WebGPUMaterialContext {\n  constructor() {\n    this.uniqueId = WebGPUMaterialContext._Counter++;\n    this.updateId = 0;\n    this.reset();\n  }\n  get forceBindGroupCreation() {\n    // If there is at least one external texture to bind, we must recreate the bind groups each time\n    // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\n    return this._numExternalTextures > 0;\n  }\n  get hasFloatTextures() {\n    return this._numFloatTextures > 0;\n  }\n  reset() {\n    this.samplers = {};\n    this.textures = {};\n    this.isDirty = true;\n    this._numFloatTextures = 0;\n    this._numExternalTextures = 0;\n  }\n  setSampler(name, sampler) {\n    let samplerCache = this.samplers[name];\n    let currentHashCode = -1;\n    if (!samplerCache) {\n      this.samplers[name] = samplerCache = {\n        sampler,\n        hashCode: 0\n      };\n    } else {\n      currentHashCode = samplerCache.hashCode;\n    }\n    samplerCache.sampler = sampler;\n    samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\n    const isDirty = currentHashCode !== samplerCache.hashCode;\n    if (isDirty) {\n      this.updateId++;\n    }\n    this.isDirty || (this.isDirty = isDirty);\n  }\n  setTexture(name, texture) {\n    var _a, _b, _c;\n    let textureCache = this.textures[name];\n    let currentTextureId = -1;\n    if (!textureCache) {\n      this.textures[name] = textureCache = {\n        texture,\n        isFloatTexture: false,\n        isExternalTexture: false\n      };\n    } else {\n      currentTextureId = (_b = (_a = textureCache.texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : -1;\n    }\n    if (textureCache.isExternalTexture) {\n      this._numExternalTextures--;\n    }\n    if (textureCache.isFloatTexture) {\n      this._numFloatTextures--;\n    }\n    if (texture) {\n      textureCache.isFloatTexture = texture.type === 1;\n      textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\n      if (textureCache.isFloatTexture) {\n        this._numFloatTextures++;\n      }\n      if (textureCache.isExternalTexture) {\n        this._numExternalTextures++;\n      }\n    } else {\n      textureCache.isFloatTexture = false;\n      textureCache.isExternalTexture = false;\n    }\n    textureCache.texture = texture;\n    const isDirty = currentTextureId !== ((_c = texture === null || texture === void 0 ? void 0 : texture.uniqueId) !== null && _c !== void 0 ? _c : -1);\n    if (isDirty) {\n      this.updateId++;\n    }\n    this.isDirty || (this.isDirty = isDirty);\n  }\n}\nWebGPUMaterialContext._Counter = 0;","map":{"version":3,"mappings":"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","names":["ExternalTexture","WebGPUCacheSampler","WebGPUMaterialContext","constructor","uniqueId","_Counter","updateId","reset","forceBindGroupCreation","_numExternalTextures","hasFloatTextures","_numFloatTextures","samplers","textures","isDirty","setSampler","name","sampler","samplerCache","currentHashCode","hashCode","GetSamplerHashCode","setTexture","texture","textureCache","currentTextureId","isFloatTexture","isExternalTexture","type","IsExternalTexture"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Engines/WebGPU/webgpuMaterialContext.ts"],"sourcesContent":["import { ExternalTexture } from \"../../Materials/Textures/externalTexture\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport type { TextureSampler } from \"../../Materials/Textures/textureSampler\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../constants\";\r\nimport type { IMaterialContext } from \"../IMaterialContext\";\r\nimport { WebGPUCacheSampler } from \"./webgpuCacheSampler\";\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextSamplerCache {\r\n    sampler: Nullable<TextureSampler>;\r\n    hashCode: number;\r\n}\r\n\r\n/** @internal */\r\ninterface IWebGPUMaterialContextTextureCache {\r\n    texture: Nullable<InternalTexture | ExternalTexture>;\r\n    isFloatTexture: boolean;\r\n    isExternalTexture: boolean;\r\n}\r\n\r\n/** @internal */\r\nexport class WebGPUMaterialContext implements IMaterialContext {\r\n    private static _Counter = 0;\r\n\r\n    public uniqueId: number;\r\n    public updateId: number;\r\n    public isDirty: boolean;\r\n    public samplers: { [name: string]: Nullable<IWebGPUMaterialContextSamplerCache> };\r\n    public textures: { [name: string]: Nullable<IWebGPUMaterialContextTextureCache> };\r\n\r\n    public get forceBindGroupCreation() {\r\n        // If there is at least one external texture to bind, we must recreate the bind groups each time\r\n        // because we need to retrieve a new texture each frame (by calling device.importExternalTexture)\r\n        return this._numExternalTextures > 0;\r\n    }\r\n\r\n    public get hasFloatTextures() {\r\n        return this._numFloatTextures > 0;\r\n    }\r\n\r\n    protected _numFloatTextures: number;\r\n    protected _numExternalTextures: number;\r\n\r\n    constructor() {\r\n        this.uniqueId = WebGPUMaterialContext._Counter++;\r\n        this.updateId = 0;\r\n        this.reset();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.samplers = {};\r\n        this.textures = {};\r\n        this.isDirty = true;\r\n        this._numFloatTextures = 0;\r\n        this._numExternalTextures = 0;\r\n    }\r\n\r\n    public setSampler(name: string, sampler: Nullable<TextureSampler>): void {\r\n        let samplerCache = this.samplers[name];\r\n        let currentHashCode = -1;\r\n        if (!samplerCache) {\r\n            this.samplers[name] = samplerCache = { sampler, hashCode: 0 };\r\n        } else {\r\n            currentHashCode = samplerCache.hashCode;\r\n        }\r\n\r\n        samplerCache.sampler = sampler;\r\n        samplerCache.hashCode = sampler ? WebGPUCacheSampler.GetSamplerHashCode(sampler) : 0;\r\n\r\n        const isDirty = currentHashCode !== samplerCache.hashCode;\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n\r\n    public setTexture(name: string, texture: Nullable<InternalTexture | ExternalTexture>): void {\r\n        let textureCache = this.textures[name];\r\n        let currentTextureId = -1;\r\n        if (!textureCache) {\r\n            this.textures[name] = textureCache = { texture, isFloatTexture: false, isExternalTexture: false };\r\n        } else {\r\n            currentTextureId = textureCache.texture?.uniqueId ?? -1;\r\n        }\r\n\r\n        if (textureCache.isExternalTexture) {\r\n            this._numExternalTextures--;\r\n        }\r\n        if (textureCache.isFloatTexture) {\r\n            this._numFloatTextures--;\r\n        }\r\n\r\n        if (texture) {\r\n            textureCache.isFloatTexture = texture.type === Constants.TEXTURETYPE_FLOAT;\r\n            textureCache.isExternalTexture = ExternalTexture.IsExternalTexture(texture);\r\n            if (textureCache.isFloatTexture) {\r\n                this._numFloatTextures++;\r\n            }\r\n            if (textureCache.isExternalTexture) {\r\n                this._numExternalTextures++;\r\n            }\r\n        } else {\r\n            textureCache.isFloatTexture = false;\r\n            textureCache.isExternalTexture = false;\r\n        }\r\n\r\n        textureCache.texture = texture;\r\n\r\n        const isDirty = currentTextureId !== (texture?.uniqueId ?? -1);\r\n        if (isDirty) {\r\n            this.updateId++;\r\n        }\r\n\r\n        this.isDirty ||= isDirty;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}