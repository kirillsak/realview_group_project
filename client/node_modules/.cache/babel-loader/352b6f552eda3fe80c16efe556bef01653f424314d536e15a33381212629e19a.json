{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Logger } from \"../../Misc/logger.js\";\nimport { VertexData } from \"../../Meshes/mesh.vertexData.js\";\nimport { Mesh } from \"../../Meshes/mesh.js\";\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\n/**\n * RecastJS navigation plugin\n */\nexport class RecastJSPlugin {\n  /**\n   * Initializes the recastJS plugin\n   * @param recastInjection can be used to inject your own recast reference\n   */\n  constructor(recastInjection = Recast) {\n    /**\n     * Reference to the Recast library\n     */\n    this.bjsRECAST = {};\n    /**\n     * plugin name\n     */\n    this.name = \"RecastJSPlugin\";\n    this._maximumSubStepCount = 10;\n    this._timeStep = 1 / 60;\n    this._timeFactor = 1;\n    this._worker = null;\n    if (typeof recastInjection === \"function\") {\n      Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\n    } else {\n      this.bjsRECAST = recastInjection;\n    }\n    if (!this.isSupported()) {\n      Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n      return;\n    }\n    this.setTimeStep();\n    this._tempVec1 = new this.bjsRECAST.Vec3();\n    this._tempVec2 = new this.bjsRECAST.Vec3();\n  }\n  /**\n   * Set worker URL to be used when generating a new navmesh\n   * @param workerURL url string\n   * @returns boolean indicating if worker is created\n   */\n  setWorkerURL(workerURL) {\n    if (window && window.Worker) {\n      this._worker = new Worker(workerURL);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Set the time step of the navigation tick update.\n   * Default is 1/60.\n   * A value of 0 will disable fixed time update\n   * @param newTimeStep the new timestep to apply to this world.\n   */\n  setTimeStep(newTimeStep = 1 / 60) {\n    this._timeStep = newTimeStep;\n  }\n  /**\n   * Get the time step of the navigation tick update.\n   * @returns the current time step\n   */\n  getTimeStep() {\n    return this._timeStep;\n  }\n  /**\n   * If delta time in navigation tick update is greater than the time step\n   * a number of sub iterations are done. If more iterations are need to reach deltatime\n   * they will be discarded.\n   * A value of 0 will set to no maximum and update will use as many substeps as needed\n   * @param newStepCount the maximum number of iterations\n   */\n  setMaximumSubStepCount(newStepCount = 10) {\n    this._maximumSubStepCount = newStepCount;\n  }\n  /**\n   * Get the maximum number of iterations per navigation tick update\n   * @returns the maximum number of iterations\n   */\n  getMaximumSubStepCount() {\n    return this._maximumSubStepCount;\n  }\n  /**\n   * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\n   * @param value the time factor applied at update\n   */\n  set timeFactor(value) {\n    this._timeFactor = Math.max(value, 0);\n  }\n  /**\n   * Get the time factor used for crowd agent update\n   * @returns the time factor\n   */\n  get timeFactor() {\n    return this._timeFactor;\n  }\n  /**\n   * Creates a navigation mesh\n   * @param meshes array of all the geometry used to compute the navigation mesh\n   * @param parameters bunch of parameters used to filter geometry\n   * @param completion callback when data is available from the worker. Not used without a worker\n   */\n  createNavMesh(meshes, parameters, completion) {\n    if (this._worker && !completion) {\n      console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\n    } else if (!this._worker && completion) {\n      console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\n    }\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    let index;\n    let tri;\n    let pt;\n    const indices = [];\n    const positions = [];\n    let offset = 0;\n    for (index = 0; index < meshes.length; index++) {\n      if (meshes[index]) {\n        const mesh = meshes[index];\n        const meshIndices = mesh.getIndices();\n        if (!meshIndices) {\n          continue;\n        }\n        const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n        if (!meshPositions) {\n          continue;\n        }\n        const worldMatrices = [];\n        const worldMatrix = mesh.computeWorldMatrix(true);\n        if (mesh.hasThinInstances) {\n          const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n          for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n            const tmpMatrix = new Matrix();\n            const thinMatrix = thinMatrices[instanceIndex];\n            thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n            worldMatrices.push(tmpMatrix);\n          }\n        } else {\n          worldMatrices.push(worldMatrix);\n        }\n        for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n          const wm = worldMatrices[matrixIndex];\n          for (tri = 0; tri < meshIndices.length; tri++) {\n            indices.push(meshIndices[tri] + offset);\n          }\n          const transformed = Vector3.Zero();\n          const position = Vector3.Zero();\n          for (pt = 0; pt < meshPositions.length; pt += 3) {\n            Vector3.FromArrayToRef(meshPositions, pt, position);\n            Vector3.TransformCoordinatesToRef(position, wm, transformed);\n            positions.push(transformed.x, transformed.y, transformed.z);\n          }\n          offset += meshPositions.length / 3;\n        }\n      }\n    }\n    if (this._worker && completion) {\n      // spawn worker and send message\n      this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\n      this._worker.onmessage = function (e) {\n        completion(e.data);\n      };\n    } else {\n      // blocking calls\n      const rc = new this.bjsRECAST.rcConfig();\n      rc.cs = parameters.cs;\n      rc.ch = parameters.ch;\n      rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\n      rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\n      rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\n      rc.walkableHeight = parameters.walkableHeight;\n      rc.walkableClimb = parameters.walkableClimb;\n      rc.walkableRadius = parameters.walkableRadius;\n      rc.maxEdgeLen = parameters.maxEdgeLen;\n      rc.maxSimplificationError = parameters.maxSimplificationError;\n      rc.minRegionArea = parameters.minRegionArea;\n      rc.mergeRegionArea = parameters.mergeRegionArea;\n      rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\n      rc.detailSampleDist = parameters.detailSampleDist;\n      rc.detailSampleMaxError = parameters.detailSampleMaxError;\n      this.navMesh.build(positions, offset, indices, indices.length, rc);\n    }\n  }\n  /**\n   * Create a navigation mesh debug mesh\n   * @param scene is where the mesh will be added\n   * @returns debug display mesh\n   */\n  createDebugNavMesh(scene) {\n    let tri;\n    let pt;\n    const debugNavMesh = this.navMesh.getDebugNavMesh();\n    const triangleCount = debugNavMesh.getTriangleCount();\n    const indices = [];\n    const positions = [];\n    for (tri = 0; tri < triangleCount * 3; tri++) {\n      indices.push(tri);\n    }\n    for (tri = 0; tri < triangleCount; tri++) {\n      for (pt = 0; pt < 3; pt++) {\n        const point = debugNavMesh.getTriangle(tri).getPoint(pt);\n        positions.push(point.x, point.y, point.z);\n      }\n    }\n    const mesh = new Mesh(\"NavMeshDebug\", scene);\n    const vertexData = new VertexData();\n    vertexData.indices = indices;\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n    return mesh;\n  }\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n  getClosestPoint(position) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getClosestPoint(this._tempVec1);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Get a navigation mesh constrained position, closest to the parameter position\n   * @param position world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n  getClosestPointToRef(position, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getClosestPoint(this._tempVec1);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @returns the closest point to position constrained by the navigation mesh\n   */\n  getRandomPointAround(position, maxRadius) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Get a navigation mesh constrained position, within a particular radius\n   * @param position world position\n   * @param maxRadius the maximum distance to the constrained world position\n   * @param result output the closest point to position constrained by the navigation mesh\n   */\n  getRandomPointAroundToRef(position, maxRadius, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @returns the resulting point along the navmesh\n   */\n  moveAlong(position, destination) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    const pr = new Vector3(ret.x, ret.y, ret.z);\n    return pr;\n  }\n  /**\n   * Compute the final position from a segment made of destination-position\n   * @param position world position\n   * @param destination world position\n   * @param result output the resulting point along the navmesh\n   */\n  moveAlongToRef(position, destination, result) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = destination.x;\n    this._tempVec2.y = destination.y;\n    this._tempVec2.z = destination.z;\n    const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\n    result.set(ret.x, ret.y, ret.z);\n  }\n  /**\n   * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n   * @param start world position\n   * @param end world position\n   * @returns array containing world position composing the path\n   */\n  computePath(start, end) {\n    let pt;\n    this._tempVec1.x = start.x;\n    this._tempVec1.y = start.y;\n    this._tempVec1.z = start.z;\n    this._tempVec2.x = end.x;\n    this._tempVec2.y = end.y;\n    this._tempVec2.z = end.z;\n    const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\n    const pointCount = navPath.getPointCount();\n    const positions = [];\n    for (pt = 0; pt < pointCount; pt++) {\n      const p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n    return positions;\n  }\n  /**\n   * Create a new Crowd so you can add agents\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  createCrowd(maxAgents, maxAgentRadius, scene) {\n    const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n    return crowd;\n  }\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n  setDefaultQueryExtent(extent) {\n    this._tempVec1.x = extent.x;\n    this._tempVec1.y = extent.y;\n    this._tempVec1.z = extent.z;\n    this.navMesh.setDefaultQueryExtent(this._tempVec1);\n  }\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n  getDefaultQueryExtent() {\n    const p = this.navMesh.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  }\n  /**\n   * build the navmesh from a previously saved state using getNavmeshData\n   * @param data the Uint8Array returned by getNavmeshData\n   */\n  buildFromNavmeshData(data) {\n    const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\n    const dataPtr = this.bjsRECAST._malloc(nDataBytes);\n    const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\n    dataHeap.set(data);\n    const buf = new this.bjsRECAST.NavmeshData();\n    buf.dataPointer = dataHeap.byteOffset;\n    buf.size = data.length;\n    this.navMesh = new this.bjsRECAST.NavMesh();\n    this.navMesh.buildFromNavmeshData(buf);\n    // Free memory\n    this.bjsRECAST._free(dataHeap.byteOffset);\n  }\n  /**\n   * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n   * @returns data the Uint8Array that can be saved and reused\n   */\n  getNavmeshData() {\n    const navmeshData = this.navMesh.getNavmeshData();\n    const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\n    const ret = new Uint8Array(navmeshData.size);\n    ret.set(arrView);\n    this.navMesh.freeNavmeshData(navmeshData);\n    return ret;\n  }\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n  getDefaultQueryExtentToRef(result) {\n    const p = this.navMesh.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  }\n  /**\n   * Disposes\n   */\n  dispose() {}\n  /**\n   * Creates a cylinder obstacle and add it to the navigation\n   * @param position world position\n   * @param radius cylinder radius\n   * @param height cylinder height\n   * @returns the obstacle freshly created\n   */\n  addCylinderObstacle(position, radius, height) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\n  }\n  /**\n   * Creates an oriented box obstacle and add it to the navigation\n   * @param position world position\n   * @param extent box size\n   * @param angle angle in radians of the box orientation on Y axis\n   * @returns the obstacle freshly created\n   */\n  addBoxObstacle(position, extent, angle) {\n    this._tempVec1.x = position.x;\n    this._tempVec1.y = position.y;\n    this._tempVec1.z = position.z;\n    this._tempVec2.x = extent.x;\n    this._tempVec2.y = extent.y;\n    this._tempVec2.z = extent.z;\n    return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\n  }\n  /**\n   * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n   * @param obstacle obstacle to remove from the navigation\n   */\n  removeObstacle(obstacle) {\n    this.navMesh.removeObstacle(obstacle);\n  }\n  /**\n   * If this plugin is supported\n   * @returns true if plugin is supported\n   */\n  isSupported() {\n    return this.bjsRECAST !== undefined;\n  }\n}\n/**\n * Recast detour crowd implementation\n */\nexport class RecastJSCrowd {\n  /**\n   * Constructor\n   * @param plugin recastJS plugin\n   * @param maxAgents the maximum agent count in the crowd\n   * @param maxAgentRadius the maximum radius an agent can have\n   * @param scene to attach the crowd to\n   * @returns the crowd you can add agents to\n   */\n  constructor(plugin, maxAgents, maxAgentRadius, scene) {\n    /**\n     * Link to the detour crowd\n     */\n    this.recastCrowd = {};\n    /**\n     * One transform per agent\n     */\n    this.transforms = new Array();\n    /**\n     * All agents created\n     */\n    this.agents = new Array();\n    /**\n     * agents reach radius\n     */\n    this.reachRadii = new Array();\n    /**\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\n     */\n    this._agentDestinationArmed = new Array();\n    /**\n     * agent current target\n     */\n    this._agentDestination = new Array();\n    /**\n     * Observer for crowd updates\n     */\n    this._onBeforeAnimationsObserver = null;\n    /**\n     * Fires each time an agent is in reach radius of its destination\n     */\n    this.onReachTargetObservable = new Observable();\n    this.bjsRECASTPlugin = plugin;\n    this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\n    this._scene = scene;\n    this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n      this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\n    });\n  }\n  /**\n   * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\n   * You can attach anything to that node. The node position is updated in the scene update tick.\n   * @param pos world position that will be constrained by the navigation mesh\n   * @param parameters agent parameters\n   * @param transform hooked to the agent that will be update by the scene\n   * @returns agent index\n   */\n  addAgent(pos, parameters, transform) {\n    const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\n    agentParams.radius = parameters.radius;\n    agentParams.height = parameters.height;\n    agentParams.maxAcceleration = parameters.maxAcceleration;\n    agentParams.maxSpeed = parameters.maxSpeed;\n    agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    agentParams.separationWeight = parameters.separationWeight;\n    agentParams.updateFlags = 7;\n    agentParams.obstacleAvoidanceType = 0;\n    agentParams.queryFilterType = 0;\n    agentParams.userData = 0;\n    const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\n    this.transforms.push(transform);\n    this.agents.push(agentIndex);\n    this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\n    this._agentDestinationArmed.push(false);\n    this._agentDestination.push(new Vector3(0, 0, 0));\n    return agentIndex;\n  }\n  /**\n   * Returns the agent position in world space\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n  getAgentPosition(index) {\n    const agentPos = this.recastCrowd.getAgentPosition(index);\n    return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n  }\n  /**\n   * Returns the agent position result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n  getAgentPositionToRef(index, result) {\n    const agentPos = this.recastCrowd.getAgentPosition(index);\n    result.set(agentPos.x, agentPos.y, agentPos.z);\n  }\n  /**\n   * Returns the agent velocity in world space\n   * @param index agent index returned by addAgent\n   * @returns world space velocity\n   */\n  getAgentVelocity(index) {\n    const agentVel = this.recastCrowd.getAgentVelocity(index);\n    return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n  }\n  /**\n   * Returns the agent velocity result in world space\n   * @param index agent index returned by addAgent\n   * @param result output world space velocity\n   */\n  getAgentVelocityToRef(index, result) {\n    const agentVel = this.recastCrowd.getAgentVelocity(index);\n    result.set(agentVel.x, agentVel.y, agentVel.z);\n  }\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @returns world space position\n   */\n  getAgentNextTargetPath(index) {\n    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  }\n  /**\n   * Returns the agent next target point on the path\n   * @param index agent index returned by addAgent\n   * @param result output world space position\n   */\n  getAgentNextTargetPathToRef(index, result) {\n    const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\n    result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n  }\n  /**\n   * Gets the agent state\n   * @param index agent index returned by addAgent\n   * @returns agent state\n   */\n  getAgentState(index) {\n    return this.recastCrowd.getAgentState(index);\n  }\n  /**\n   * returns true if the agent in over an off mesh link connection\n   * @param index agent index returned by addAgent\n   * @returns true if over an off mesh link connection\n   */\n  overOffmeshConnection(index) {\n    return this.recastCrowd.overOffmeshConnection(index);\n  }\n  /**\n   * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n  agentGoto(index, destination) {\n    this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n    // arm observer\n    const item = this.agents.indexOf(index);\n    if (item > -1) {\n      this._agentDestinationArmed[item] = true;\n      this._agentDestination[item].set(destination.x, destination.y, destination.z);\n    }\n  }\n  /**\n   * Teleport the agent to a new position\n   * @param index agent index returned by addAgent\n   * @param destination targeted world position\n   */\n  agentTeleport(index, destination) {\n    this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\n  }\n  /**\n   * Update agent parameters\n   * @param index agent index returned by addAgent\n   * @param parameters agent parameters\n   */\n  updateAgentParameters(index, parameters) {\n    const agentParams = this.recastCrowd.getAgentParameters(index);\n    if (parameters.radius !== undefined) {\n      agentParams.radius = parameters.radius;\n    }\n    if (parameters.height !== undefined) {\n      agentParams.height = parameters.height;\n    }\n    if (parameters.maxAcceleration !== undefined) {\n      agentParams.maxAcceleration = parameters.maxAcceleration;\n    }\n    if (parameters.maxSpeed !== undefined) {\n      agentParams.maxSpeed = parameters.maxSpeed;\n    }\n    if (parameters.collisionQueryRange !== undefined) {\n      agentParams.collisionQueryRange = parameters.collisionQueryRange;\n    }\n    if (parameters.pathOptimizationRange !== undefined) {\n      agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n    }\n    if (parameters.separationWeight !== undefined) {\n      agentParams.separationWeight = parameters.separationWeight;\n    }\n    this.recastCrowd.setAgentParameters(index, agentParams);\n  }\n  /**\n   * remove a particular agent previously created\n   * @param index agent index returned by addAgent\n   */\n  removeAgent(index) {\n    this.recastCrowd.removeAgent(index);\n    const item = this.agents.indexOf(index);\n    if (item > -1) {\n      this.agents.splice(item, 1);\n      this.transforms.splice(item, 1);\n      this.reachRadii.splice(item, 1);\n      this._agentDestinationArmed.splice(item, 1);\n      this._agentDestination.splice(item, 1);\n    }\n  }\n  /**\n   * get the list of all agents attached to this crowd\n   * @returns list of agent indices\n   */\n  getAgents() {\n    return this.agents;\n  }\n  /**\n   * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\n   * @param deltaTime in seconds\n   */\n  update(deltaTime) {\n    // update obstacles\n    this.bjsRECASTPlugin.navMesh.update();\n    if (deltaTime <= Epsilon) {\n      return;\n    }\n    // update crowd\n    const timeStep = this.bjsRECASTPlugin.getTimeStep();\n    const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\n    if (timeStep <= Epsilon) {\n      this.recastCrowd.update(deltaTime);\n    } else {\n      let iterationCount = Math.floor(deltaTime / timeStep);\n      if (maxStepCount && iterationCount > maxStepCount) {\n        iterationCount = maxStepCount;\n      }\n      if (iterationCount < 1) {\n        iterationCount = 1;\n      }\n      const step = deltaTime / iterationCount;\n      for (let i = 0; i < iterationCount; i++) {\n        this.recastCrowd.update(step);\n      }\n    }\n    // update transforms\n    for (let index = 0; index < this.agents.length; index++) {\n      // update transform position\n      const agentIndex = this.agents[index];\n      const agentPosition = this.getAgentPosition(agentIndex);\n      this.transforms[index].position = agentPosition;\n      // check agent reach destination\n      if (this._agentDestinationArmed[index]) {\n        const dx = agentPosition.x - this._agentDestination[index].x;\n        const dz = agentPosition.z - this._agentDestination[index].z;\n        const radius = this.reachRadii[index];\n        const groundY = this._agentDestination[index].y - this.reachRadii[index];\n        const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\n        const distanceXZSquared = dx * dx + dz * dz;\n        if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\n          this.onReachTargetObservable.notifyObservers({\n            agentIndex: agentIndex,\n            destination: this._agentDestination[index]\n          });\n          this._agentDestinationArmed[index] = false;\n        }\n      }\n    }\n  }\n  /**\n   * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n   * The queries will try to find a solution within those bounds\n   * default is (1,1,1)\n   * @param extent x,y,z value that define the extent around the queries point of reference\n   */\n  setDefaultQueryExtent(extent) {\n    const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\n    this.recastCrowd.setDefaultQueryExtent(ext);\n  }\n  /**\n   * Get the Bounding box extent specified by setDefaultQueryExtent\n   * @returns the box extent values\n   */\n  getDefaultQueryExtent() {\n    const p = this.recastCrowd.getDefaultQueryExtent();\n    return new Vector3(p.x, p.y, p.z);\n  }\n  /**\n   * Get the Bounding box extent result specified by setDefaultQueryExtent\n   * @param result output the box extent values\n   */\n  getDefaultQueryExtentToRef(result) {\n    const p = this.recastCrowd.getDefaultQueryExtent();\n    result.set(p.x, p.y, p.z);\n  }\n  /**\n   * Get the next corner points composing the path (max 4 points)\n   * @param index agent index returned by addAgent\n   * @returns array containing world position composing the path\n   */\n  getCorners(index) {\n    let pt;\n    const navPath = this.recastCrowd.getCorners(index);\n    const pointCount = navPath.getPointCount();\n    const positions = [];\n    for (pt = 0; pt < pointCount; pt++) {\n      const p = navPath.getPoint(pt);\n      positions.push(new Vector3(p.x, p.y, p.z));\n    }\n    return positions;\n  }\n  /**\n   * Release all resources\n   */\n  dispose() {\n    this.recastCrowd.destroy();\n    this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n    this._onBeforeAnimationsObserver = null;\n    this.onReachTargetObservable.clear();\n  }\n}","map":{"version":3,"mappings":"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","names":["Logger","VertexData","Mesh","Epsilon","Vector3","Matrix","Observable","VertexBuffer","RecastJSPlugin","constructor","recastInjection","Recast","Error","bjsRECAST","isSupported","setTimeStep","_tempVec1","Vec3","_tempVec2","setWorkerURL","workerURL","window","Worker","_worker","newTimeStep","_timeStep","getTimeStep","setMaximumSubStepCount","newStepCount","_maximumSubStepCount","getMaximumSubStepCount","timeFactor","value","_timeFactor","Math","max","createNavMesh","meshes","parameters","completion","console","warn","navMesh","NavMesh","index","tri","pt","indices","positions","offset","length","mesh","meshIndices","getIndices","meshPositions","getVerticesData","PositionKind","worldMatrices","worldMatrix","computeWorldMatrix","hasThinInstances","thinMatrices","thinInstanceGetWorldMatrices","instanceIndex","tmpMatrix","thinMatrix","multiplyToRef","push","matrixIndex","wm","transformed","Zero","position","FromArrayToRef","TransformCoordinatesToRef","x","y","z","postMessage","onmessage","e","data","rc","rcConfig","cs","ch","borderSize","tileSize","walkableSlopeAngle","walkableHeight","walkableClimb","walkableRadius","maxEdgeLen","maxSimplificationError","minRegionArea","mergeRegionArea","maxVertsPerPoly","detailSampleDist","detailSampleMaxError","build","createDebugNavMesh","scene","debugNavMesh","getDebugNavMesh","triangleCount","getTriangleCount","point","getTriangle","getPoint","vertexData","applyToMesh","getClosestPoint","ret","pr","getClosestPointToRef","result","set","getRandomPointAround","maxRadius","getRandomPointAroundToRef","moveAlong","destination","moveAlongToRef","computePath","start","end","navPath","pointCount","getPointCount","p","createCrowd","maxAgents","maxAgentRadius","crowd","RecastJSCrowd","setDefaultQueryExtent","extent","getDefaultQueryExtent","buildFromNavmeshData","nDataBytes","BYTES_PER_ELEMENT","dataPtr","_malloc","dataHeap","Uint8Array","HEAPU8","buffer","buf","NavmeshData","dataPointer","byteOffset","size","_free","getNavmeshData","navmeshData","arrView","freeNavmeshData","getDefaultQueryExtentToRef","dispose","addCylinderObstacle","radius","height","addBoxObstacle","angle","removeObstacle","obstacle","undefined","plugin","Array","bjsRECASTPlugin","recastCrowd","Crowd","getNavMesh","_scene","_onBeforeAnimationsObserver","onBeforeAnimationsObservable","add","update","getEngine","getDeltaTime","addAgent","pos","transform","agentParams","dtCrowdAgentParams","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","updateFlags","obstacleAvoidanceType","queryFilterType","userData","agentIndex","transforms","agents","reachRadii","reachRadius","_agentDestinationArmed","_agentDestination","getAgentPosition","agentPos","getAgentPositionToRef","getAgentVelocity","agentVel","getAgentVelocityToRef","getAgentNextTargetPath","pathTargetPos","getAgentNextTargetPathToRef","getAgentState","overOffmeshConnection","agentGoto","item","indexOf","agentTeleport","updateAgentParameters","getAgentParameters","setAgentParameters","removeAgent","splice","getAgents","deltaTime","timeStep","maxStepCount","iterationCount","floor","step","i","agentPosition","dx","dz","groundY","ceilingY","distanceXZSquared","onReachTargetObservable","notifyObservers","ext","getCorners","destroy","remove","clear"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Navigation/Plugins/recastJSPlugin.ts"],"sourcesContent":["import type { INavigationEnginePlugin, ICrowd, IAgentParameters, INavMeshParameters, IObstacle } from \"../../Navigation/INavigationEngine\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { VertexData } from \"../../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Epsilon, Vector3, Matrix } from \"../../Maths/math\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let Recast: any;\r\n\r\n/**\r\n * RecastJS navigation plugin\r\n */\r\nexport class RecastJSPlugin implements INavigationEnginePlugin {\r\n    /**\r\n     * Reference to the Recast library\r\n     */\r\n    public bjsRECAST: any = {};\r\n\r\n    /**\r\n     * plugin name\r\n     */\r\n    public name: string = \"RecastJSPlugin\";\r\n\r\n    /**\r\n     * the first navmesh created. We might extend this to support multiple navmeshes\r\n     */\r\n    public navMesh: any;\r\n\r\n    private _maximumSubStepCount: number = 10;\r\n    private _timeStep: number = 1 / 60;\r\n    private _timeFactor: number = 1;\r\n\r\n    private _tempVec1: any;\r\n    private _tempVec2: any;\r\n\r\n    private _worker: Nullable<Worker> = null;\r\n\r\n    /**\r\n     * Initializes the recastJS plugin\r\n     * @param recastInjection can be used to inject your own recast reference\r\n     */\r\n    public constructor(recastInjection: any = Recast) {\r\n        if (typeof recastInjection === \"function\") {\r\n            Logger.Error(\"RecastJS is not ready. Please make sure you await Recast() before using the plugin.\");\r\n        } else {\r\n            this.bjsRECAST = recastInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.setTimeStep();\r\n\r\n        this._tempVec1 = new this.bjsRECAST.Vec3();\r\n        this._tempVec2 = new this.bjsRECAST.Vec3();\r\n    }\r\n\r\n    /**\r\n     * Set worker URL to be used when generating a new navmesh\r\n     * @param workerURL url string\r\n     * @returns boolean indicating if worker is created\r\n     */\r\n    public setWorkerURL(workerURL: string): boolean {\r\n        if (window && window.Worker) {\r\n            this._worker = new Worker(workerURL);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set the time step of the navigation tick update.\r\n     * Default is 1/60.\r\n     * A value of 0 will disable fixed time update\r\n     * @param newTimeStep the new timestep to apply to this world.\r\n     */\r\n    setTimeStep(newTimeStep: number = 1 / 60): void {\r\n        this._timeStep = newTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Get the time step of the navigation tick update.\r\n     * @returns the current time step\r\n     */\r\n    getTimeStep(): number {\r\n        return this._timeStep;\r\n    }\r\n\r\n    /**\r\n     * If delta time in navigation tick update is greater than the time step\r\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\r\n     * they will be discarded.\r\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\r\n     * @param newStepCount the maximum number of iterations\r\n     */\r\n    setMaximumSubStepCount(newStepCount: number = 10): void {\r\n        this._maximumSubStepCount = newStepCount;\r\n    }\r\n\r\n    /**\r\n     * Get the maximum number of iterations per navigation tick update\r\n     * @returns the maximum number of iterations\r\n     */\r\n    getMaximumSubStepCount(): number {\r\n        return this._maximumSubStepCount;\r\n    }\r\n\r\n    /**\r\n     * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\r\n     * @param value the time factor applied at update\r\n     */\r\n    public set timeFactor(value: number) {\r\n        this._timeFactor = Math.max(value, 0);\r\n    }\r\n\r\n    /**\r\n     * Get the time factor used for crowd agent update\r\n     * @returns the time factor\r\n     */\r\n    public get timeFactor(): number {\r\n        return this._timeFactor;\r\n    }\r\n\r\n    /**\r\n     * Creates a navigation mesh\r\n     * @param meshes array of all the geometry used to compute the navigation mesh\r\n     * @param parameters bunch of parameters used to filter geometry\r\n     * @param completion callback when data is available from the worker. Not used without a worker\r\n     */\r\n    createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParameters, completion?: (navmeshData: Uint8Array) => void): void {\r\n        if (this._worker && !completion) {\r\n            console.warn(\"A worker is avaible but no completion callback. Defaulting to blocking navmesh creation\");\r\n        } else if (!this._worker && completion) {\r\n            console.warn(\"A completion callback is avaible but no worker. Defaulting to blocking navmesh creation\");\r\n        }\r\n\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n\r\n        let index: number;\r\n        let tri: number;\r\n        let pt: number;\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        let offset = 0;\r\n        for (index = 0; index < meshes.length; index++) {\r\n            if (meshes[index]) {\r\n                const mesh = meshes[index];\r\n\r\n                const meshIndices = mesh.getIndices();\r\n                if (!meshIndices) {\r\n                    continue;\r\n                }\r\n                const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\r\n                if (!meshPositions) {\r\n                    continue;\r\n                }\r\n\r\n                const worldMatrices = [];\r\n                const worldMatrix = mesh.computeWorldMatrix(true);\r\n\r\n                if (mesh.hasThinInstances) {\r\n                    const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                    for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\r\n                        const tmpMatrix = new Matrix();\r\n                        const thinMatrix = thinMatrices[instanceIndex];\r\n                        thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\r\n                        worldMatrices.push(tmpMatrix);\r\n                    }\r\n                } else {\r\n                    worldMatrices.push(worldMatrix);\r\n                }\r\n\r\n                for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\r\n                    const wm = worldMatrices[matrixIndex];\r\n                    for (tri = 0; tri < meshIndices.length; tri++) {\r\n                        indices.push(meshIndices[tri] + offset);\r\n                    }\r\n\r\n                    const transformed = Vector3.Zero();\r\n                    const position = Vector3.Zero();\r\n                    for (pt = 0; pt < meshPositions.length; pt += 3) {\r\n                        Vector3.FromArrayToRef(meshPositions, pt, position);\r\n                        Vector3.TransformCoordinatesToRef(position, wm, transformed);\r\n                        positions.push(transformed.x, transformed.y, transformed.z);\r\n                    }\r\n\r\n                    offset += meshPositions.length / 3;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._worker && completion) {\r\n            // spawn worker and send message\r\n            this._worker.postMessage([positions, offset, indices, indices.length, parameters]);\r\n            this._worker.onmessage = function (e) {\r\n                completion(e.data);\r\n            };\r\n        } else {\r\n            // blocking calls\r\n            const rc = new this.bjsRECAST.rcConfig();\r\n            rc.cs = parameters.cs;\r\n            rc.ch = parameters.ch;\r\n            rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;\r\n            rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;\r\n            rc.walkableSlopeAngle = parameters.walkableSlopeAngle;\r\n            rc.walkableHeight = parameters.walkableHeight;\r\n            rc.walkableClimb = parameters.walkableClimb;\r\n            rc.walkableRadius = parameters.walkableRadius;\r\n            rc.maxEdgeLen = parameters.maxEdgeLen;\r\n            rc.maxSimplificationError = parameters.maxSimplificationError;\r\n            rc.minRegionArea = parameters.minRegionArea;\r\n            rc.mergeRegionArea = parameters.mergeRegionArea;\r\n            rc.maxVertsPerPoly = parameters.maxVertsPerPoly;\r\n            rc.detailSampleDist = parameters.detailSampleDist;\r\n            rc.detailSampleMaxError = parameters.detailSampleMaxError;\r\n\r\n            this.navMesh.build(positions, offset, indices, indices.length, rc);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a navigation mesh debug mesh\r\n     * @param scene is where the mesh will be added\r\n     * @returns debug display mesh\r\n     */\r\n    createDebugNavMesh(scene: Scene): Mesh {\r\n        let tri: number;\r\n        let pt: number;\r\n        const debugNavMesh = this.navMesh.getDebugNavMesh();\r\n        const triangleCount = debugNavMesh.getTriangleCount();\r\n\r\n        const indices = [];\r\n        const positions = [];\r\n        for (tri = 0; tri < triangleCount * 3; tri++) {\r\n            indices.push(tri);\r\n        }\r\n        for (tri = 0; tri < triangleCount; tri++) {\r\n            for (pt = 0; pt < 3; pt++) {\r\n                const point = debugNavMesh.getTriangle(tri).getPoint(pt);\r\n                positions.push(point.x, point.y, point.z);\r\n            }\r\n        }\r\n\r\n        const mesh = new Mesh(\"NavMeshDebug\", scene);\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = indices;\r\n        vertexData.positions = positions;\r\n        vertexData.applyToMesh(mesh, false);\r\n        return mesh;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPoint(position: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, closest to the parameter position\r\n     * @param position world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getClosestPointToRef(position: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getClosestPoint(this._tempVec1);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @returns the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAround(position: Vector3, maxRadius: number): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Get a navigation mesh constrained position, within a particular radius\r\n     * @param position world position\r\n     * @param maxRadius the maximum distance to the constrained world position\r\n     * @param result output the closest point to position constrained by the navigation mesh\r\n     */\r\n    getRandomPointAroundToRef(position: Vector3, maxRadius: number, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        const ret = this.navMesh.getRandomPointAround(this._tempVec1, maxRadius);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @returns the resulting point along the navmesh\r\n     */\r\n    moveAlong(position: Vector3, destination: Vector3): Vector3 {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        const pr = new Vector3(ret.x, ret.y, ret.z);\r\n        return pr;\r\n    }\r\n\r\n    /**\r\n     * Compute the final position from a segment made of destination-position\r\n     * @param position world position\r\n     * @param destination world position\r\n     * @param result output the resulting point along the navmesh\r\n     */\r\n    moveAlongToRef(position: Vector3, destination: Vector3, result: Vector3): void {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = destination.x;\r\n        this._tempVec2.y = destination.y;\r\n        this._tempVec2.z = destination.z;\r\n        const ret = this.navMesh.moveAlong(this._tempVec1, this._tempVec2);\r\n        result.set(ret.x, ret.y, ret.z);\r\n    }\r\n\r\n    /**\r\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\r\n     * @param start world position\r\n     * @param end world position\r\n     * @returns array containing world position composing the path\r\n     */\r\n    computePath(start: Vector3, end: Vector3): Vector3[] {\r\n        let pt: number;\r\n        this._tempVec1.x = start.x;\r\n        this._tempVec1.y = start.y;\r\n        this._tempVec1.z = start.z;\r\n        this._tempVec2.x = end.x;\r\n        this._tempVec2.y = end.y;\r\n        this._tempVec2.z = end.z;\r\n        const navPath = this.navMesh.computePath(this._tempVec1, this._tempVec2);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Create a new Crowd so you can add agents\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd {\r\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\r\n        return crowd;\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        this._tempVec1.x = extent.x;\r\n        this._tempVec1.y = extent.y;\r\n        this._tempVec1.z = extent.z;\r\n        this.navMesh.setDefaultQueryExtent(this._tempVec1);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * build the navmesh from a previously saved state using getNavmeshData\r\n     * @param data the Uint8Array returned by getNavmeshData\r\n     */\r\n    buildFromNavmeshData(data: Uint8Array): void {\r\n        const nDataBytes = data.length * data.BYTES_PER_ELEMENT;\r\n        const dataPtr = this.bjsRECAST._malloc(nDataBytes);\r\n\r\n        const dataHeap = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, dataPtr, nDataBytes);\r\n        dataHeap.set(data);\r\n\r\n        const buf = new this.bjsRECAST.NavmeshData();\r\n        buf.dataPointer = dataHeap.byteOffset;\r\n        buf.size = data.length;\r\n        this.navMesh = new this.bjsRECAST.NavMesh();\r\n        this.navMesh.buildFromNavmeshData(buf);\r\n\r\n        // Free memory\r\n        this.bjsRECAST._free(dataHeap.byteOffset);\r\n    }\r\n\r\n    /**\r\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\r\n     * @returns data the Uint8Array that can be saved and reused\r\n     */\r\n    getNavmeshData(): Uint8Array {\r\n        const navmeshData = this.navMesh.getNavmeshData();\r\n        const arrView = new Uint8Array(this.bjsRECAST.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);\r\n        const ret = new Uint8Array(navmeshData.size);\r\n        ret.set(arrView);\r\n        this.navMesh.freeNavmeshData(navmeshData);\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.navMesh.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Disposes\r\n     */\r\n    public dispose() {}\r\n\r\n    /**\r\n     * Creates a cylinder obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param radius cylinder radius\r\n     * @param height cylinder height\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addCylinderObstacle(position: Vector3, radius: number, height: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        return this.navMesh.addCylinderObstacle(this._tempVec1, radius, height);\r\n    }\r\n\r\n    /**\r\n     * Creates an oriented box obstacle and add it to the navigation\r\n     * @param position world position\r\n     * @param extent box size\r\n     * @param angle angle in radians of the box orientation on Y axis\r\n     * @returns the obstacle freshly created\r\n     */\r\n    addBoxObstacle(position: Vector3, extent: Vector3, angle: number): IObstacle {\r\n        this._tempVec1.x = position.x;\r\n        this._tempVec1.y = position.y;\r\n        this._tempVec1.z = position.z;\r\n        this._tempVec2.x = extent.x;\r\n        this._tempVec2.y = extent.y;\r\n        this._tempVec2.z = extent.z;\r\n        return this.navMesh.addBoxObstacle(this._tempVec1, this._tempVec2, angle);\r\n    }\r\n\r\n    /**\r\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\r\n     * @param obstacle obstacle to remove from the navigation\r\n     */\r\n    removeObstacle(obstacle: IObstacle): void {\r\n        this.navMesh.removeObstacle(obstacle);\r\n    }\r\n\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if plugin is supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this.bjsRECAST !== undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Recast detour crowd implementation\r\n */\r\nexport class RecastJSCrowd implements ICrowd {\r\n    /**\r\n     * Recast/detour plugin\r\n     */\r\n    public bjsRECASTPlugin: RecastJSPlugin;\r\n    /**\r\n     * Link to the detour crowd\r\n     */\r\n    public recastCrowd: any = {};\r\n    /**\r\n     * One transform per agent\r\n     */\r\n    public transforms: TransformNode[] = new Array<TransformNode>();\r\n    /**\r\n     * All agents created\r\n     */\r\n    public agents: number[] = new Array<number>();\r\n    /**\r\n     * agents reach radius\r\n     */\r\n    public reachRadii: number[] = new Array<number>();\r\n    /**\r\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\r\n     */\r\n    private _agentDestinationArmed: boolean[] = new Array<boolean>();\r\n    /**\r\n     * agent current target\r\n     */\r\n    private _agentDestination: Vector3[] = new Array<Vector3>();\r\n    /**\r\n     * Link to the scene is kept to unregister the crowd from the scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Observer for crowd updates\r\n     */\r\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\r\n\r\n    /**\r\n     * Fires each time an agent is in reach radius of its destination\r\n     */\r\n    public onReachTargetObservable = new Observable<{ agentIndex: number; destination: Vector3 }>();\r\n\r\n    /**\r\n     * Constructor\r\n     * @param plugin recastJS plugin\r\n     * @param maxAgents the maximum agent count in the crowd\r\n     * @param maxAgentRadius the maximum radius an agent can have\r\n     * @param scene to attach the crowd to\r\n     * @returns the crowd you can add agents to\r\n     */\r\n    public constructor(plugin: RecastJSPlugin, maxAgents: number, maxAgentRadius: number, scene: Scene) {\r\n        this.bjsRECASTPlugin = plugin;\r\n        this.recastCrowd = new this.bjsRECASTPlugin.bjsRECAST.Crowd(maxAgents, maxAgentRadius, this.bjsRECASTPlugin.navMesh.getNavMesh());\r\n        this._scene = scene;\r\n\r\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\r\n            this.update(scene.getEngine().getDeltaTime() * 0.001 * plugin.timeFactor);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\r\n     * You can attach anything to that node. The node position is updated in the scene update tick.\r\n     * @param pos world position that will be constrained by the navigation mesh\r\n     * @param parameters agent parameters\r\n     * @param transform hooked to the agent that will be update by the scene\r\n     * @returns agent index\r\n     */\r\n    addAgent(pos: Vector3, parameters: IAgentParameters, transform: TransformNode): number {\r\n        const agentParams = new this.bjsRECASTPlugin.bjsRECAST.dtCrowdAgentParams();\r\n        agentParams.radius = parameters.radius;\r\n        agentParams.height = parameters.height;\r\n        agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        agentParams.maxSpeed = parameters.maxSpeed;\r\n        agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        agentParams.separationWeight = parameters.separationWeight;\r\n        agentParams.updateFlags = 7;\r\n        agentParams.obstacleAvoidanceType = 0;\r\n        agentParams.queryFilterType = 0;\r\n        agentParams.userData = 0;\r\n\r\n        const agentIndex = this.recastCrowd.addAgent(new this.bjsRECASTPlugin.bjsRECAST.Vec3(pos.x, pos.y, pos.z), agentParams);\r\n        this.transforms.push(transform);\r\n        this.agents.push(agentIndex);\r\n        this.reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\r\n        this._agentDestinationArmed.push(false);\r\n        this._agentDestination.push(new Vector3(0, 0, 0));\r\n        return agentIndex;\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentPosition(index: number): Vector3 {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent position result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentPositionToRef(index: number, result: Vector3): void {\r\n        const agentPos = this.recastCrowd.getAgentPosition(index);\r\n        result.set(agentPos.x, agentPos.y, agentPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity in world space\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space velocity\r\n     */\r\n    getAgentVelocity(index: number): Vector3 {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent velocity result in world space\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space velocity\r\n     */\r\n    getAgentVelocityToRef(index: number, result: Vector3): void {\r\n        const agentVel = this.recastCrowd.getAgentVelocity(index);\r\n        result.set(agentVel.x, agentVel.y, agentVel.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @returns world space position\r\n     */\r\n    getAgentNextTargetPath(index: number): Vector3 {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Returns the agent next target point on the path\r\n     * @param index agent index returned by addAgent\r\n     * @param result output world space position\r\n     */\r\n    getAgentNextTargetPathToRef(index: number, result: Vector3): void {\r\n        const pathTargetPos = this.recastCrowd.getAgentNextTargetPath(index);\r\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\r\n    }\r\n\r\n    /**\r\n     * Gets the agent state\r\n     * @param index agent index returned by addAgent\r\n     * @returns agent state\r\n     */\r\n    getAgentState(index: number): number {\r\n        return this.recastCrowd.getAgentState(index);\r\n    }\r\n\r\n    /**\r\n     * returns true if the agent in over an off mesh link connection\r\n     * @param index agent index returned by addAgent\r\n     * @returns true if over an off mesh link connection\r\n     */\r\n    overOffmeshConnection(index: number): boolean {\r\n        return this.recastCrowd.overOffmeshConnection(index);\r\n    }\r\n\r\n    /**\r\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentGoto(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentGoto(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n\r\n        // arm observer\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this._agentDestinationArmed[item] = true;\r\n            this._agentDestination[item].set(destination.x, destination.y, destination.z);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Teleport the agent to a new position\r\n     * @param index agent index returned by addAgent\r\n     * @param destination targeted world position\r\n     */\r\n    agentTeleport(index: number, destination: Vector3): void {\r\n        this.recastCrowd.agentTeleport(index, new this.bjsRECASTPlugin.bjsRECAST.Vec3(destination.x, destination.y, destination.z));\r\n    }\r\n\r\n    /**\r\n     * Update agent parameters\r\n     * @param index agent index returned by addAgent\r\n     * @param parameters agent parameters\r\n     */\r\n    updateAgentParameters(index: number, parameters: IAgentParameters): void {\r\n        const agentParams = this.recastCrowd.getAgentParameters(index);\r\n\r\n        if (parameters.radius !== undefined) {\r\n            agentParams.radius = parameters.radius;\r\n        }\r\n        if (parameters.height !== undefined) {\r\n            agentParams.height = parameters.height;\r\n        }\r\n        if (parameters.maxAcceleration !== undefined) {\r\n            agentParams.maxAcceleration = parameters.maxAcceleration;\r\n        }\r\n        if (parameters.maxSpeed !== undefined) {\r\n            agentParams.maxSpeed = parameters.maxSpeed;\r\n        }\r\n        if (parameters.collisionQueryRange !== undefined) {\r\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\r\n        }\r\n        if (parameters.pathOptimizationRange !== undefined) {\r\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\r\n        }\r\n        if (parameters.separationWeight !== undefined) {\r\n            agentParams.separationWeight = parameters.separationWeight;\r\n        }\r\n\r\n        this.recastCrowd.setAgentParameters(index, agentParams);\r\n    }\r\n\r\n    /**\r\n     * remove a particular agent previously created\r\n     * @param index agent index returned by addAgent\r\n     */\r\n    removeAgent(index: number): void {\r\n        this.recastCrowd.removeAgent(index);\r\n\r\n        const item = this.agents.indexOf(index);\r\n        if (item > -1) {\r\n            this.agents.splice(item, 1);\r\n            this.transforms.splice(item, 1);\r\n            this.reachRadii.splice(item, 1);\r\n            this._agentDestinationArmed.splice(item, 1);\r\n            this._agentDestination.splice(item, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * get the list of all agents attached to this crowd\r\n     * @returns list of agent indices\r\n     */\r\n    getAgents(): number[] {\r\n        return this.agents;\r\n    }\r\n\r\n    /**\r\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\r\n     * @param deltaTime in seconds\r\n     */\r\n    update(deltaTime: number): void {\r\n        // update obstacles\r\n        this.bjsRECASTPlugin.navMesh.update();\r\n\r\n        if (deltaTime <= Epsilon) {\r\n            return;\r\n        }\r\n        // update crowd\r\n        const timeStep = this.bjsRECASTPlugin.getTimeStep();\r\n        const maxStepCount = this.bjsRECASTPlugin.getMaximumSubStepCount();\r\n        if (timeStep <= Epsilon) {\r\n            this.recastCrowd.update(deltaTime);\r\n        } else {\r\n            let iterationCount = Math.floor(deltaTime / timeStep);\r\n            if (maxStepCount && iterationCount > maxStepCount) {\r\n                iterationCount = maxStepCount;\r\n            }\r\n            if (iterationCount < 1) {\r\n                iterationCount = 1;\r\n            }\r\n\r\n            const step = deltaTime / iterationCount;\r\n            for (let i = 0; i < iterationCount; i++) {\r\n                this.recastCrowd.update(step);\r\n            }\r\n        }\r\n\r\n        // update transforms\r\n        for (let index = 0; index < this.agents.length; index++) {\r\n            // update transform position\r\n            const agentIndex = this.agents[index];\r\n            const agentPosition = this.getAgentPosition(agentIndex);\r\n            this.transforms[index].position = agentPosition;\r\n            // check agent reach destination\r\n            if (this._agentDestinationArmed[index]) {\r\n                const dx = agentPosition.x - this._agentDestination[index].x;\r\n                const dz = agentPosition.z - this._agentDestination[index].z;\r\n                const radius = this.reachRadii[index];\r\n                const groundY = this._agentDestination[index].y - this.reachRadii[index];\r\n                const ceilingY = this._agentDestination[index].y + this.reachRadii[index];\r\n                const distanceXZSquared = dx * dx + dz * dz;\r\n                if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\r\n                    this.onReachTargetObservable.notifyObservers({ agentIndex: agentIndex, destination: this._agentDestination[index] });\r\n                    this._agentDestinationArmed[index] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\r\n     * The queries will try to find a solution within those bounds\r\n     * default is (1,1,1)\r\n     * @param extent x,y,z value that define the extent around the queries point of reference\r\n     */\r\n    setDefaultQueryExtent(extent: Vector3): void {\r\n        const ext = new this.bjsRECASTPlugin.bjsRECAST.Vec3(extent.x, extent.y, extent.z);\r\n        this.recastCrowd.setDefaultQueryExtent(ext);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent specified by setDefaultQueryExtent\r\n     * @returns the box extent values\r\n     */\r\n    getDefaultQueryExtent(): Vector3 {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        return new Vector3(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\r\n     * @param result output the box extent values\r\n     */\r\n    getDefaultQueryExtentToRef(result: Vector3): void {\r\n        const p = this.recastCrowd.getDefaultQueryExtent();\r\n        result.set(p.x, p.y, p.z);\r\n    }\r\n\r\n    /**\r\n     * Get the next corner points composing the path (max 4 points)\r\n     * @param index agent index returned by addAgent\r\n     * @returns array containing world position composing the path\r\n     */\r\n    getCorners(index: number): Vector3[] {\r\n        let pt: number;\r\n        const navPath = this.recastCrowd.getCorners(index);\r\n        const pointCount = navPath.getPointCount();\r\n        const positions = [];\r\n        for (pt = 0; pt < pointCount; pt++) {\r\n            const p = navPath.getPoint(pt);\r\n            positions.push(new Vector3(p.x, p.y, p.z));\r\n        }\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    dispose(): void {\r\n        this.recastCrowd.destroy();\r\n        this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\r\n        this._onBeforeAnimationsObserver = null;\r\n        this.onReachTargetObservable.clear();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}