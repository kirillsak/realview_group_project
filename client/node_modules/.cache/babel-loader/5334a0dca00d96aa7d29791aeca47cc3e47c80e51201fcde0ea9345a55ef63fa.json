{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Engine } from \"../../../Engines/engine.js\";\nimport { VertexBuffer } from \"../../../Buffers/buffer.js\";\nimport { Texture } from \"../texture.js\";\nimport { DynamicTexture } from \"../dynamicTexture.js\";\nimport { Vector2 } from \"../../../Maths/math.vector.js\";\nimport { Color3, Color4 } from \"../../../Maths/math.color.js\";\nimport { TexturePackerFrame } from \"./frame.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { Tools } from \"../../../Misc/tools.js\";\n/**\n * This is a support class that generates a series of packed texture sets.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\n */\nexport class TexturePacker {\n  /**\n   * Initializes a texture package series from an array of meshes or a single mesh.\n   * @param name The name of the package\n   * @param meshes The target meshes to compose the package from\n   * @param options The arguments that texture packer should follow while building.\n   * @param scene The scene which the textures are scoped to.\n   * @returns TexturePacker\n   */\n  constructor(name, meshes, options, scene) {\n    var _b, _c, _d, _e, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n    this.name = name;\n    this.meshes = meshes;\n    this.scene = scene;\n    /**\n     * Run through the options and set what ever defaults are needed that where not declared.\n     */\n    this.options = options;\n    this.options.map = (_b = this.options.map) !== null && _b !== void 0 ? _b : [\"ambientTexture\", \"bumpTexture\", \"diffuseTexture\", \"emissiveTexture\", \"lightmapTexture\", \"opacityTexture\", \"reflectionTexture\", \"refractionTexture\", \"specularTexture\"];\n    this.options.uvsIn = (_c = this.options.uvsIn) !== null && _c !== void 0 ? _c : VertexBuffer.UVKind;\n    this.options.uvsOut = (_d = this.options.uvsOut) !== null && _d !== void 0 ? _d : VertexBuffer.UVKind;\n    this.options.layout = (_e = this.options.layout) !== null && _e !== void 0 ? _e : TexturePacker.LAYOUT_STRIP;\n    if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\n      this.options.colnum = (_g = this.options.colnum) !== null && _g !== void 0 ? _g : 8;\n    }\n    this.options.updateInputMeshes = (_h = this.options.updateInputMeshes) !== null && _h !== void 0 ? _h : true;\n    this.options.disposeSources = (_j = this.options.disposeSources) !== null && _j !== void 0 ? _j : true;\n    this._expecting = 0;\n    this.options.fillBlanks = (_k = this.options.fillBlanks) !== null && _k !== void 0 ? _k : true;\n    if (this.options.fillBlanks === true) {\n      this.options.customFillColor = (_l = this.options.customFillColor) !== null && _l !== void 0 ? _l : \"black\";\n    }\n    this.options.frameSize = (_m = this.options.frameSize) !== null && _m !== void 0 ? _m : 256;\n    this.options.paddingRatio = (_o = this.options.paddingRatio) !== null && _o !== void 0 ? _o : 0.0115;\n    this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\n    //Make it an even padding Number.\n    if (this._paddingValue % 2 !== 0) {\n      this._paddingValue++;\n    }\n    this.options.paddingMode = (_p = this.options.paddingMode) !== null && _p !== void 0 ? _p : TexturePacker.SUBUV_WRAP;\n    if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\n      this.options.paddingColor = (_q = this.options.paddingColor) !== null && _q !== void 0 ? _q : new Color4(0, 0, 0, 1.0);\n    }\n    this.sets = {};\n    this.frames = [];\n    return this;\n  }\n  /**\n   * Starts the package process\n   * @param resolve The promises resolution function\n   * @returns TexturePacker\n   */\n  _createFrames(resolve) {\n    const dtSize = this._calculateSize();\n    const dtUnits = new Vector2(1, 1).divide(dtSize);\n    let doneCount = 0;\n    const expecting = this._expecting;\n    const meshLength = this.meshes.length;\n    const sKeys = Object.keys(this.sets);\n    for (let i = 0; i < sKeys.length; i++) {\n      const setName = sKeys[i];\n      const dt = new DynamicTexture(this.name + \".TexturePack.\" + setName + \"Set\", {\n        width: dtSize.x,\n        height: dtSize.y\n      }, this.scene, true,\n      //Generate Mips\n      Texture.TRILINEAR_SAMPLINGMODE, Engine.TEXTUREFORMAT_RGBA);\n      const dtx = dt.getContext();\n      dtx.fillStyle = \"rgba(0,0,0,0)\";\n      dtx.fillRect(0, 0, dtSize.x, dtSize.y);\n      dt.update(false);\n      this.sets[setName] = dt;\n    }\n    const baseSize = this.options.frameSize || 256;\n    const padding = this._paddingValue;\n    const tcs = baseSize + 2 * padding;\n    const done = () => {\n      this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\n    };\n    //Update the Textures\n    for (let i = 0; i < meshLength; i++) {\n      const m = this.meshes[i];\n      const mat = m.material;\n      //Check if the material has the texture\n      //Create a temporary canvas the same size as 1 frame\n      //Then apply the texture to the center and the 8 offsets\n      //Copy the Context and place in the correct frame on the DT\n      for (let j = 0; j < sKeys.length; j++) {\n        const tempTexture = new DynamicTexture(\"temp\", tcs, this.scene, true);\n        const tcx = tempTexture.getContext();\n        const offset = this._getFrameOffset(i);\n        const updateDt = () => {\n          doneCount++;\n          tempTexture.update(false);\n          const iDat = tcx.getImageData(0, 0, tcs, tcs);\n          //Update Set\n          const dt = this.sets[setName];\n          const dtx = dt.getContext();\n          dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\n          tempTexture.dispose();\n          dt.update(false);\n          if (doneCount == expecting) {\n            done();\n            resolve();\n            return;\n          }\n        };\n        const setName = sKeys[j] || \"_blank\";\n        if (!mat || mat[setName] === null) {\n          tcx.fillStyle = \"rgba(0,0,0,0)\";\n          if (this.options.fillBlanks) {\n            tcx.fillStyle = this.options.customFillColor;\n          }\n          tcx.fillRect(0, 0, tcs, tcs);\n          updateDt();\n        } else {\n          const setTexture = mat[setName];\n          const img = new Image();\n          if (setTexture instanceof DynamicTexture) {\n            img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\n          } else {\n            img.src = setTexture.url;\n          }\n          Tools.SetCorsBehavior(img.src, img);\n          img.onload = () => {\n            tcx.fillStyle = \"rgba(0,0,0,0)\";\n            tcx.fillRect(0, 0, tcs, tcs);\n            tempTexture.update(false);\n            tcx.setTransform(1, 0, 0, -1, 0, 0);\n            const cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\n            switch (this.options.paddingMode) {\n              //Wrap Mode\n              case 0:\n                for (let i = 0; i < 9; i++) {\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[i], padding + baseSize * cellOffsets[i + 1] - tcs, baseSize, baseSize);\n                }\n                break;\n              //Extend Mode\n              case 1:\n                for (let i = 0; i < padding; i++) {\n                  tcx.drawImage(img, 0, 0, img.width, img.height, i + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding * 2 - i, padding - tcs, baseSize, baseSize);\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding, i - tcs, baseSize, baseSize);\n                  tcx.drawImage(img, 0, 0, img.width, img.height, padding, padding * 2 - i - tcs, baseSize, baseSize);\n                }\n                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n              //Color Mode\n              case 2:\n                tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\n                tcx.fillRect(0, 0, tcs, -tcs);\n                tcx.clearRect(padding, padding, baseSize, baseSize);\n                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\n                break;\n            }\n            tcx.setTransform(1, 0, 0, 1, 0, 0);\n            updateDt();\n          };\n        }\n      }\n    }\n  }\n  /**\n   * Calculates the Size of the Channel Sets\n   * @returns Vector2\n   */\n  _calculateSize() {\n    const meshLength = this.meshes.length || 0;\n    const baseSize = this.options.frameSize || 0;\n    const padding = this._paddingValue || 0;\n    switch (this.options.layout) {\n      case 0:\n        {\n          //STRIP_LAYOUT\n          return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\n        }\n      case 1:\n        {\n          //POWER2\n          const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n          const size = baseSize * sqrtCount + 2 * padding * sqrtCount;\n          return new Vector2(size, size);\n        }\n      case 2:\n        {\n          //COLNUM\n          const cols = this.options.colnum || 1;\n          const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n          return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\n        }\n    }\n    return Vector2.Zero();\n  }\n  /**\n   * Calculates the UV data for the frames.\n   * @param baseSize the base frameSize\n   * @param padding the base frame padding\n   * @param dtSize size of the Dynamic Texture for that channel\n   * @param dtUnits is 1/dtSize\n   * @param update flag to update the input meshes\n   */\n  _calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, update) {\n    const meshLength = this.meshes.length;\n    for (let i = 0; i < meshLength; i++) {\n      const m = this.meshes[i];\n      const scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\n      const pOffset = dtUnits.clone().scale(padding);\n      const frameOffset = this._getFrameOffset(i);\n      const offset = frameOffset.add(pOffset);\n      const frame = new TexturePackerFrame(i, scale, offset);\n      this.frames.push(frame);\n      //Update Output UVs\n      if (update) {\n        this._updateMeshUV(m, i);\n        this._updateTextureReferences(m);\n      }\n    }\n  }\n  /**\n   * Calculates the frames Offset.\n   * @param index of the frame\n   * @returns Vector2\n   */\n  _getFrameOffset(index) {\n    const meshLength = this.meshes.length;\n    let uvStep, yStep, xStep;\n    switch (this.options.layout) {\n      case 0:\n        {\n          //STRIP_LAYOUT\n          uvStep = 1 / meshLength;\n          return new Vector2(index * uvStep, 0);\n        }\n      case 1:\n        {\n          //POWER2\n          const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\n          yStep = Math.floor(index / sqrtCount);\n          xStep = index - yStep * sqrtCount;\n          uvStep = 1 / sqrtCount;\n          return new Vector2(xStep * uvStep, yStep * uvStep);\n        }\n      case 2:\n        {\n          //COLNUM\n          const cols = this.options.colnum || 1;\n          const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\n          xStep = Math.floor(index / rowCnt);\n          yStep = index - xStep * rowCnt;\n          uvStep = new Vector2(1 / cols, 1 / rowCnt);\n          return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\n        }\n    }\n    return Vector2.Zero();\n  }\n  /**\n   * Updates a Mesh to the frame data\n   * @param mesh that is the target\n   * @param frameID or the frame index\n   */\n  _updateMeshUV(mesh, frameID) {\n    const frame = this.frames[frameID];\n    const uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\n    const uvOut = [];\n    let toCount = 0;\n    if (uvIn.length) {\n      toCount = uvIn.length || 0;\n    }\n    for (let i = 0; i < toCount; i += 2) {\n      uvOut.push(uvIn[i] * frame.scale.x + frame.offset.x, uvIn[i + 1] * frame.scale.y + frame.offset.y);\n    }\n    mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\n  }\n  /**\n   * Updates a Meshes materials to use the texture packer channels\n   * @param m is the mesh to target\n   * @param force all channels on the packer to be set.\n   */\n  _updateTextureReferences(m, force = false) {\n    const mat = m.material;\n    const sKeys = Object.keys(this.sets);\n    const _dispose = _t => {\n      if (_t.dispose) {\n        _t.dispose();\n      }\n    };\n    for (let i = 0; i < sKeys.length; i++) {\n      const setName = sKeys[i];\n      if (!force) {\n        if (!mat) {\n          return;\n        }\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n          mat[setName] = this.sets[setName];\n        }\n      } else {\n        if (mat[setName] !== null) {\n          _dispose(mat[setName]);\n        }\n        mat[setName] = this.sets[setName];\n      }\n    }\n  }\n  /**\n   * Public method to set a Mesh to a frame\n   * @param m that is the target\n   * @param frameID or the frame index\n   * @param updateMaterial trigger for if the Meshes attached Material be updated?\n   */\n  setMeshToFrame(m, frameID, updateMaterial = false) {\n    this._updateMeshUV(m, frameID);\n    if (updateMaterial) {\n      this._updateTextureReferences(m, true);\n    }\n  }\n  /**\n   * Starts the async promise to compile the texture packer.\n   * @returns Promise<void>\n   */\n  processAsync() {\n    return new Promise((resolve, reject) => {\n      try {\n        if (this.meshes.length === 0) {\n          //Must be a JSON load!\n          resolve();\n          return;\n        }\n        let done = 0;\n        const doneCheck = mat => {\n          done++;\n          //Check Status of all Textures on all meshes, till they are ready.\n          if (this.options.map) {\n            for (let j = 0; j < this.options.map.length; j++) {\n              const index = this.options.map[j];\n              const t = mat[index];\n              if (t !== null) {\n                if (!this.sets[this.options.map[j]]) {\n                  this.sets[this.options.map[j]] = true;\n                }\n                this._expecting++;\n              }\n            }\n            if (done === this.meshes.length) {\n              this._createFrames(resolve);\n            }\n          }\n        };\n        for (let i = 0; i < this.meshes.length; i++) {\n          const mesh = this.meshes[i];\n          const material = mesh.material;\n          if (!material) {\n            done++;\n            if (done === this.meshes.length) {\n              return this._createFrames(resolve);\n            }\n            continue;\n          }\n          material.forceCompilationAsync(mesh).then(() => {\n            doneCheck(material);\n          });\n        }\n      } catch (e) {\n        return reject(e);\n      }\n    });\n  }\n  /**\n   * Disposes all textures associated with this packer\n   */\n  dispose() {\n    const sKeys = Object.keys(this.sets);\n    for (let i = 0; i < sKeys.length; i++) {\n      const channel = sKeys[i];\n      this.sets[channel].dispose();\n    }\n  }\n  /**\n   * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\n   * @param imageType is the image type to use.\n   * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\n   */\n  download(imageType = \"png\", quality = 1) {\n    setTimeout(() => {\n      const pack = {\n        name: this.name,\n        sets: {},\n        options: {},\n        frames: []\n      };\n      const sKeys = Object.keys(this.sets);\n      const oKeys = Object.keys(this.options);\n      try {\n        for (let i = 0; i < sKeys.length; i++) {\n          const channel = sKeys[i];\n          const dt = this.sets[channel];\n          pack.sets[channel] = dt.getContext().canvas.toDataURL(\"image/\" + imageType, quality);\n        }\n        for (let i = 0; i < oKeys.length; i++) {\n          const opt = oKeys[i];\n          pack.options[opt] = this.options[opt];\n        }\n        for (let i = 0; i < this.frames.length; i++) {\n          const _f = this.frames[i];\n          pack.frames.push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\n        }\n      } catch (err) {\n        Logger.Warn(\"Unable to download: \" + err);\n        return;\n      }\n      const data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\n      const _a = document.createElement(\"a\");\n      _a.setAttribute(\"href\", data);\n      _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\n      document.body.appendChild(_a);\n      _a.click();\n      _a.remove();\n    }, 0);\n  }\n  /**\n   * Public method to load a texturePacker JSON file.\n   * @param data of the JSON file in string format.\n   */\n  updateFromJSON(data) {\n    try {\n      const parsedData = JSON.parse(data);\n      this.name = parsedData.name;\n      const _options = Object.keys(parsedData.options);\n      for (let i = 0; i < _options.length; i++) {\n        this.options[_options[i]] = parsedData.options[_options[i]];\n      }\n      for (let i = 0; i < parsedData.frames.length; i += 4) {\n        const frame = new TexturePackerFrame(i / 4, new Vector2(parsedData.frames[i], parsedData.frames[i + 1]), new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3]));\n        this.frames.push(frame);\n      }\n      const channels = Object.keys(parsedData.sets);\n      for (let i = 0; i < channels.length; i++) {\n        const _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\n        this.sets[channels[i]] = _t;\n      }\n    } catch (err) {\n      Logger.Warn(\"Unable to update from JSON: \" + err);\n    }\n  }\n}\n/** Packer Layout Constant 0 */\nTexturePacker.LAYOUT_STRIP = 0;\n/** Packer Layout Constant 1 */\nTexturePacker.LAYOUT_POWER2 = 1;\n/** Packer Layout Constant 2 */\nTexturePacker.LAYOUT_COLNUM = 2;\n/** Packer Layout Constant 0 */\nTexturePacker.SUBUV_WRAP = 0;\n/** Packer Layout Constant 1 */\nTexturePacker.SUBUV_EXTEND = 1;\n/** Packer Layout Constant 2 */\nTexturePacker.SUBUV_COLOR = 2;","map":{"version":3,"mappings":"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","names":["Engine","VertexBuffer","Texture","DynamicTexture","Vector2","Color3","Color4","TexturePackerFrame","Logger","Tools","TexturePacker","constructor","name","meshes","options","scene","map","uvsIn","UVKind","uvsOut","layout","LAYOUT_STRIP","LAYOUT_COLNUM","colnum","updateInputMeshes","disposeSources","_expecting","fillBlanks","customFillColor","frameSize","paddingRatio","_paddingValue","Math","ceil","paddingMode","SUBUV_WRAP","SUBUV_COLOR","paddingColor","sets","frames","_createFrames","resolve","dtSize","_calculateSize","dtUnits","divide","doneCount","expecting","meshLength","length","sKeys","Object","keys","i","setName","dt","width","x","height","y","TRILINEAR_SAMPLINGMODE","TEXTUREFORMAT_RGBA","dtx","getContext","fillStyle","fillRect","update","baseSize","padding","tcs","done","_calculateMeshUVFrames","m","mat","material","j","tempTexture","tcx","offset","_getFrameOffset","updateDt","iDat","getImageData","putImageData","dispose","setTexture","img","Image","src","canvas","toDataURL","url","SetCorsBehavior","onload","setTransform","cellOffsets","drawImage","Black","toHexString","clearRect","sqrtCount","max","sqrt","size","cols","rowCnt","Zero","scale","pOffset","clone","frameOffset","add","frame","push","_updateMeshUV","_updateTextureReferences","index","uvStep","yStep","xStep","floor","mesh","frameID","uvIn","getVerticesData","uvOut","toCount","setVerticesData","force","_dispose","_t","setMeshToFrame","updateMaterial","processAsync","Promise","reject","doneCheck","t","forceCompilationAsync","then","e","channel","download","imageType","quality","setTimeout","pack","oKeys","opt","_f","err","Warn","data","encodeURIComponent","JSON","stringify","_a","document","createElement","setAttribute","body","appendChild","click","remove","updateFromJSON","parsedData","parse","_options","channels"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/Packer/packer.ts"],"sourcesContent":["import { Engine } from \"../../../Engines/engine\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Material } from \"../../material\";\r\nimport { Texture } from \"../texture\";\r\nimport { DynamicTexture } from \"../dynamicTexture\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Vector2 } from \"../../../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../../../Maths/math.color\";\r\nimport { TexturePackerFrame } from \"./frame\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\n\r\n/**\r\n * Defines the basic options interface of a TexturePacker\r\n */\r\nexport interface ITexturePackerOptions {\r\n    /**\r\n     * Custom targets for the channels of a texture packer.  Default is all the channels of the Standard Material\r\n     */\r\n    map?: string[];\r\n\r\n    /**\r\n     * the UV input targets, as a single value for all meshes. Defaults to VertexBuffer.UVKind\r\n     */\r\n    uvsIn?: string;\r\n\r\n    /**\r\n     * the UV output targets, as a single value for all meshes.  Defaults to VertexBuffer.UVKind\r\n     */\r\n    uvsOut?: string;\r\n\r\n    /**\r\n     * number representing the layout style. Defaults to LAYOUT_STRIP\r\n     */\r\n    layout?: number;\r\n\r\n    /**\r\n     * number of columns if using custom column count layout(2).  This defaults to 4.\r\n     */\r\n    colnum?: number;\r\n\r\n    /**\r\n     * flag to update the input meshes to the new packed texture after compilation. Defaults to true.\r\n     */\r\n    updateInputMeshes?: boolean;\r\n\r\n    /**\r\n     * boolean flag to dispose all the source textures.  Defaults to true.\r\n     */\r\n    disposeSources?: boolean;\r\n\r\n    /**\r\n     * Fills the blank cells in a set to the customFillColor.  Defaults to true.\r\n     */\r\n    fillBlanks?: boolean;\r\n\r\n    /**\r\n     * string value representing the context fill style color.  Defaults to 'black'.\r\n     */\r\n    customFillColor?: string;\r\n\r\n    /**\r\n     * Width and Height Value of each Frame in the TexturePacker Sets\r\n     */\r\n    frameSize?: number;\r\n\r\n    /**\r\n     * Ratio of the value to add padding wise to each cell.  Defaults to 0.0115\r\n     */\r\n    paddingRatio?: number;\r\n\r\n    /**\r\n     * Number that declares the fill method for the padding gutter.\r\n     */\r\n    paddingMode?: number;\r\n\r\n    /**\r\n     * If in SUBUV_COLOR padding mode what color to use.\r\n     */\r\n    paddingColor?: Color3 | Color4;\r\n}\r\n\r\n/**\r\n * Defines the basic interface of a TexturePacker JSON File\r\n */\r\nexport interface ITexturePackerJSON {\r\n    /**\r\n     * The frame ID\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * The base64 channel data\r\n     */\r\n    sets: any;\r\n\r\n    /**\r\n     * The options of the Packer\r\n     */\r\n    options: ITexturePackerOptions;\r\n\r\n    /**\r\n     * The frame data of the Packer\r\n     */\r\n    frames: Array<number>;\r\n}\r\n\r\n/**\r\n * This is a support class that generates a series of packed texture sets.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n */\r\nexport class TexturePacker {\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly LAYOUT_STRIP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly LAYOUT_POWER2 = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly LAYOUT_COLNUM = 2;\r\n\r\n    /** Packer Layout Constant 0 */\r\n    public static readonly SUBUV_WRAP = 0;\r\n    /** Packer Layout Constant 1 */\r\n    public static readonly SUBUV_EXTEND = 1;\r\n    /** Packer Layout Constant 2 */\r\n    public static readonly SUBUV_COLOR = 2;\r\n\r\n    /** The Name of the Texture Package */\r\n    public name: string;\r\n\r\n    /** The scene scope of the TexturePacker */\r\n    public scene: Scene;\r\n\r\n    /** The Meshes to target */\r\n    public meshes: AbstractMesh[];\r\n\r\n    /** Arguments passed with the Constructor */\r\n    public options: ITexturePackerOptions;\r\n\r\n    /** The promise that is started upon initialization */\r\n    public promise: Nullable<Promise<TexturePacker | string>>;\r\n\r\n    /** The Container object for the channel sets that are generated */\r\n    public sets: object;\r\n\r\n    /** The Container array for the frames that are generated */\r\n    public frames: TexturePackerFrame[];\r\n\r\n    /** The expected number of textures the system is parsing. */\r\n    private _expecting: number;\r\n\r\n    /** The padding value from Math.ceil(frameSize * paddingRatio) */\r\n    private _paddingValue: number;\r\n\r\n    /**\r\n     * Initializes a texture package series from an array of meshes or a single mesh.\r\n     * @param name The name of the package\r\n     * @param meshes The target meshes to compose the package from\r\n     * @param options The arguments that texture packer should follow while building.\r\n     * @param scene The scene which the textures are scoped to.\r\n     * @returns TexturePacker\r\n     */\r\n    constructor(name: string, meshes: AbstractMesh[], options: ITexturePackerOptions, scene: Scene) {\r\n        this.name = name;\r\n        this.meshes = meshes;\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * Run through the options and set what ever defaults are needed that where not declared.\r\n         */\r\n        this.options = options;\r\n        this.options.map = this.options.map ?? [\r\n            \"ambientTexture\",\r\n            \"bumpTexture\",\r\n            \"diffuseTexture\",\r\n            \"emissiveTexture\",\r\n            \"lightmapTexture\",\r\n            \"opacityTexture\",\r\n            \"reflectionTexture\",\r\n            \"refractionTexture\",\r\n            \"specularTexture\",\r\n        ];\r\n\r\n        this.options.uvsIn = this.options.uvsIn ?? VertexBuffer.UVKind;\r\n        this.options.uvsOut = this.options.uvsOut ?? VertexBuffer.UVKind;\r\n        this.options.layout = this.options.layout ?? TexturePacker.LAYOUT_STRIP;\r\n\r\n        if (this.options.layout === TexturePacker.LAYOUT_COLNUM) {\r\n            this.options.colnum = this.options.colnum ?? 8;\r\n        }\r\n\r\n        this.options.updateInputMeshes = this.options.updateInputMeshes ?? true;\r\n        this.options.disposeSources = this.options.disposeSources ?? true;\r\n        this._expecting = 0;\r\n\r\n        this.options.fillBlanks = this.options.fillBlanks ?? true;\r\n\r\n        if (this.options.fillBlanks === true) {\r\n            this.options.customFillColor = this.options.customFillColor ?? \"black\";\r\n        }\r\n\r\n        this.options.frameSize = this.options.frameSize ?? 256;\r\n        this.options.paddingRatio = this.options.paddingRatio ?? 0.0115;\r\n\r\n        this._paddingValue = Math.ceil(this.options.frameSize * this.options.paddingRatio);\r\n\r\n        //Make it an even padding Number.\r\n        if (this._paddingValue % 2 !== 0) {\r\n            this._paddingValue++;\r\n        }\r\n\r\n        this.options.paddingMode = this.options.paddingMode ?? TexturePacker.SUBUV_WRAP;\r\n\r\n        if (this.options.paddingMode === TexturePacker.SUBUV_COLOR) {\r\n            this.options.paddingColor = this.options.paddingColor ?? new Color4(0, 0, 0, 1.0);\r\n        }\r\n\r\n        this.sets = {};\r\n        this.frames = [];\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Starts the package process\r\n     * @param resolve The promises resolution function\r\n     * @returns TexturePacker\r\n     */\r\n    private _createFrames(resolve: () => void) {\r\n        const dtSize = this._calculateSize();\r\n        const dtUnits = new Vector2(1, 1).divide(dtSize);\r\n        let doneCount = 0;\r\n        const expecting = this._expecting;\r\n        const meshLength = this.meshes.length;\r\n\r\n        const sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            const setName = sKeys[i];\r\n\r\n            const dt = new DynamicTexture(\r\n                this.name + \".TexturePack.\" + setName + \"Set\",\r\n                { width: dtSize.x, height: dtSize.y },\r\n                this.scene,\r\n                true, //Generate Mips\r\n                Texture.TRILINEAR_SAMPLINGMODE,\r\n                Engine.TEXTUREFORMAT_RGBA\r\n            );\r\n\r\n            const dtx = dt.getContext();\r\n            dtx.fillStyle = \"rgba(0,0,0,0)\";\r\n            dtx.fillRect(0, 0, dtSize.x, dtSize.y);\r\n            dt.update(false);\r\n            (this.sets as any)[setName] = dt;\r\n        }\r\n\r\n        const baseSize = this.options.frameSize || 256;\r\n        const padding = this._paddingValue;\r\n        const tcs = baseSize + 2 * padding;\r\n\r\n        const done = () => {\r\n            this._calculateMeshUVFrames(baseSize, padding, dtSize, dtUnits, this.options.updateInputMeshes || false);\r\n        };\r\n\r\n        //Update the Textures\r\n        for (let i = 0; i < meshLength; i++) {\r\n            const m = this.meshes[i];\r\n            const mat = m.material;\r\n\r\n            //Check if the material has the texture\r\n            //Create a temporary canvas the same size as 1 frame\r\n            //Then apply the texture to the center and the 8 offsets\r\n            //Copy the Context and place in the correct frame on the DT\r\n\r\n            for (let j = 0; j < sKeys.length; j++) {\r\n                const tempTexture = new DynamicTexture(\"temp\", tcs, this.scene, true);\r\n                const tcx = tempTexture.getContext();\r\n                const offset = this._getFrameOffset(i);\r\n\r\n                const updateDt = () => {\r\n                    doneCount++;\r\n                    tempTexture.update(false);\r\n                    const iDat = tcx.getImageData(0, 0, tcs, tcs);\r\n\r\n                    //Update Set\r\n                    const dt = (this.sets as any)[setName];\r\n                    const dtx = dt.getContext();\r\n                    dtx.putImageData(iDat, dtSize.x * offset.x, dtSize.y * offset.y);\r\n                    tempTexture.dispose();\r\n                    dt.update(false);\r\n                    if (doneCount == expecting) {\r\n                        done();\r\n                        resolve();\r\n                        return;\r\n                    }\r\n                };\r\n\r\n                const setName = sKeys[j] || \"_blank\";\r\n                if (!mat || (mat as any)[setName] === null) {\r\n                    tcx.fillStyle = \"rgba(0,0,0,0)\";\r\n\r\n                    if (this.options.fillBlanks) {\r\n                        tcx.fillStyle = this.options.customFillColor as string;\r\n                    }\r\n\r\n                    tcx.fillRect(0, 0, tcs, tcs);\r\n\r\n                    updateDt();\r\n                } else {\r\n                    const setTexture = (mat as any)[setName];\r\n                    const img = new Image();\r\n\r\n                    if (setTexture instanceof DynamicTexture) {\r\n                        img.src = setTexture.getContext().canvas.toDataURL(\"image/png\");\r\n                    } else {\r\n                        img.src = setTexture!.url;\r\n                    }\r\n                    Tools.SetCorsBehavior(img.src, img);\r\n\r\n                    img.onload = () => {\r\n                        tcx.fillStyle = \"rgba(0,0,0,0)\";\r\n                        tcx.fillRect(0, 0, tcs, tcs);\r\n                        tempTexture.update(false);\r\n\r\n                        tcx.setTransform(1, 0, 0, -1, 0, 0);\r\n                        const cellOffsets = [0, 0, 1, 0, 1, 1, 0, 1, -1, 1, -1, 0, -1 - 1, 0, -1, 1, -1];\r\n\r\n                        switch (this.options.paddingMode) {\r\n                            //Wrap Mode\r\n                            case 0:\r\n                                for (let i = 0; i < 9; i++) {\r\n                                    tcx.drawImage(\r\n                                        img,\r\n                                        0,\r\n                                        0,\r\n                                        img.width,\r\n                                        img.height,\r\n                                        padding + baseSize * cellOffsets[i],\r\n                                        padding + baseSize * cellOffsets[i + 1] - tcs,\r\n                                        baseSize,\r\n                                        baseSize\r\n                                    );\r\n                                }\r\n                                break;\r\n                            //Extend Mode\r\n                            case 1:\r\n                                for (let i = 0; i < padding; i++) {\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, i + baseSize * cellOffsets[0], padding - tcs, baseSize, baseSize);\r\n\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding * 2 - i, padding - tcs, baseSize, baseSize);\r\n\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding, i - tcs, baseSize, baseSize);\r\n\r\n                                    tcx.drawImage(img, 0, 0, img.width, img.height, padding, padding * 2 - i - tcs, baseSize, baseSize);\r\n                                }\r\n\r\n                                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\r\n\r\n                                break;\r\n                            //Color Mode\r\n                            case 2:\r\n                                tcx.fillStyle = (this.options.paddingColor || Color3.Black()).toHexString();\r\n                                tcx.fillRect(0, 0, tcs, -tcs);\r\n                                tcx.clearRect(padding, padding, baseSize, baseSize);\r\n                                tcx.drawImage(img, 0, 0, img.width, img.height, padding + baseSize * cellOffsets[0], padding + baseSize * cellOffsets[1] - tcs, baseSize, baseSize);\r\n\r\n                                break;\r\n                        }\r\n\r\n                        tcx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n                        updateDt();\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the Size of the Channel Sets\r\n     * @returns Vector2\r\n     */\r\n    private _calculateSize(): Vector2 {\r\n        const meshLength: number = this.meshes.length || 0;\r\n        const baseSize: number = this.options.frameSize || 0;\r\n        const padding: number = this._paddingValue || 0;\r\n\r\n        switch (this.options.layout) {\r\n            case 0: {\r\n                //STRIP_LAYOUT\r\n                return new Vector2(baseSize * meshLength + 2 * padding * meshLength, baseSize + 2 * padding);\r\n            }\r\n            case 1: {\r\n                //POWER2\r\n                const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                const size = baseSize * sqrtCount + 2 * padding * sqrtCount;\r\n                return new Vector2(size, size);\r\n            }\r\n            case 2: {\r\n                //COLNUM\r\n                const cols = this.options.colnum || 1;\r\n                const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                return new Vector2(baseSize * cols + 2 * padding * cols, baseSize * rowCnt + 2 * padding * rowCnt);\r\n            }\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Calculates the UV data for the frames.\r\n     * @param baseSize the base frameSize\r\n     * @param padding the base frame padding\r\n     * @param dtSize size of the Dynamic Texture for that channel\r\n     * @param dtUnits is 1/dtSize\r\n     * @param update flag to update the input meshes\r\n     */\r\n    private _calculateMeshUVFrames(baseSize: number, padding: number, dtSize: Vector2, dtUnits: Vector2, update: boolean) {\r\n        const meshLength = this.meshes.length;\r\n\r\n        for (let i = 0; i < meshLength; i++) {\r\n            const m = this.meshes[i];\r\n\r\n            const scale = new Vector2(baseSize / dtSize.x, baseSize / dtSize.y);\r\n\r\n            const pOffset: Vector2 = dtUnits.clone().scale(padding);\r\n            const frameOffset: Vector2 = this._getFrameOffset(i);\r\n            const offset: Vector2 = frameOffset.add(pOffset);\r\n\r\n            const frame: TexturePackerFrame = new TexturePackerFrame(i, scale, offset);\r\n\r\n            this.frames.push(frame);\r\n\r\n            //Update Output UVs\r\n            if (update) {\r\n                this._updateMeshUV(m, i);\r\n                this._updateTextureReferences(m);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the frames Offset.\r\n     * @param index of the frame\r\n     * @returns Vector2\r\n     */\r\n    private _getFrameOffset(index: number): Vector2 {\r\n        const meshLength = this.meshes.length;\r\n        let uvStep, yStep, xStep;\r\n\r\n        switch (this.options.layout) {\r\n            case 0: {\r\n                //STRIP_LAYOUT\r\n                uvStep = 1 / meshLength;\r\n                return new Vector2(index * uvStep, 0);\r\n            }\r\n            case 1: {\r\n                //POWER2\r\n                const sqrtCount = Math.max(2, Math.ceil(Math.sqrt(meshLength)));\r\n                yStep = Math.floor(index / sqrtCount);\r\n                xStep = index - yStep * sqrtCount;\r\n                uvStep = 1 / sqrtCount;\r\n                return new Vector2(xStep * uvStep, yStep * uvStep);\r\n            }\r\n            case 2: {\r\n                //COLNUM\r\n                const cols = this.options.colnum || 1;\r\n                const rowCnt = Math.max(1, Math.ceil(meshLength / cols));\r\n                xStep = Math.floor(index / rowCnt);\r\n                yStep = index - xStep * rowCnt;\r\n                uvStep = new Vector2(1 / cols, 1 / rowCnt);\r\n                return new Vector2(xStep * uvStep.x, yStep * uvStep.y);\r\n            }\r\n        }\r\n\r\n        return Vector2.Zero();\r\n    }\r\n\r\n    /**\r\n     * Updates a Mesh to the frame data\r\n     * @param mesh that is the target\r\n     * @param frameID or the frame index\r\n     */\r\n    private _updateMeshUV(mesh: AbstractMesh, frameID: number): void {\r\n        const frame: TexturePackerFrame = (this.frames as any)[frameID];\r\n        const uvIn = mesh.getVerticesData(this.options.uvsIn || VertexBuffer.UVKind);\r\n        const uvOut = [];\r\n        let toCount = 0;\r\n\r\n        if (uvIn!.length) {\r\n            toCount = uvIn!.length || 0;\r\n        }\r\n\r\n        for (let i = 0; i < toCount; i += 2) {\r\n            uvOut.push((uvIn as any)[i] * frame.scale.x + frame.offset.x, (uvIn as any)[i + 1] * frame.scale.y + frame.offset.y);\r\n        }\r\n\r\n        mesh.setVerticesData(this.options.uvsOut || VertexBuffer.UVKind, uvOut);\r\n    }\r\n\r\n    /**\r\n     * Updates a Meshes materials to use the texture packer channels\r\n     * @param m is the mesh to target\r\n     * @param force all channels on the packer to be set.\r\n     */\r\n    private _updateTextureReferences(m: AbstractMesh, force: boolean = false): void {\r\n        const mat = m.material;\r\n        const sKeys = Object.keys(this.sets);\r\n\r\n        const _dispose = (_t: any) => {\r\n            if (_t.dispose) {\r\n                _t.dispose();\r\n            }\r\n        };\r\n\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            const setName = sKeys[i];\r\n            if (!force) {\r\n                if (!mat) {\r\n                    return;\r\n                }\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                    (mat as any)[setName] = (this.sets as any)[setName];\r\n                }\r\n            } else {\r\n                if ((mat as any)[setName] !== null) {\r\n                    _dispose((mat as any)[setName]);\r\n                }\r\n                (mat as any)[setName] = (this.sets as any)[setName];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Public method to set a Mesh to a frame\r\n     * @param m that is the target\r\n     * @param frameID or the frame index\r\n     * @param updateMaterial trigger for if the Meshes attached Material be updated?\r\n     */\r\n    public setMeshToFrame(m: AbstractMesh, frameID: number, updateMaterial: boolean = false): void {\r\n        this._updateMeshUV(m, frameID);\r\n        if (updateMaterial) {\r\n            this._updateTextureReferences(m, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the async promise to compile the texture packer.\r\n     * @returns Promise<void>\r\n     */\r\n    public processAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            try {\r\n                if (this.meshes.length === 0) {\r\n                    //Must be a JSON load!\r\n                    resolve();\r\n                    return;\r\n                }\r\n                let done = 0;\r\n                const doneCheck = (mat: Material) => {\r\n                    done++;\r\n                    //Check Status of all Textures on all meshes, till they are ready.\r\n                    if (this.options.map) {\r\n                        for (let j = 0; j < this.options.map.length; j++) {\r\n                            const index: string = this.options.map[j];\r\n                            const t: Texture | DynamicTexture = (mat as any)[index];\r\n\r\n                            if (t !== null) {\r\n                                if (!(this.sets as any)[this.options.map[j]]) {\r\n                                    (this.sets as any)[this.options.map[j]] = true;\r\n                                }\r\n\r\n                                this._expecting++;\r\n                            }\r\n                        }\r\n\r\n                        if (done === this.meshes.length) {\r\n                            this._createFrames(resolve);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                for (let i = 0; i < this.meshes.length; i++) {\r\n                    const mesh = this.meshes[i];\r\n                    const material: Nullable<Material> = mesh.material;\r\n\r\n                    if (!material) {\r\n                        done++;\r\n                        if (done === this.meshes.length) {\r\n                            return this._createFrames(resolve);\r\n                        }\r\n                        continue;\r\n                    }\r\n\r\n                    material.forceCompilationAsync(mesh).then(() => {\r\n                        doneCheck(material as Material);\r\n                    });\r\n                }\r\n            } catch (e) {\r\n                return reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes all textures associated with this packer\r\n     */\r\n    public dispose(): void {\r\n        const sKeys = Object.keys(this.sets);\r\n        for (let i = 0; i < sKeys.length; i++) {\r\n            const channel = sKeys[i];\r\n            (this.sets as any)[channel].dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the download process for all the channels converting them to base64 data and embedding it all in a JSON file.\r\n     * @param imageType is the image type to use.\r\n     * @param quality of the image if downloading as jpeg, Ranges from >0 to 1.\r\n     */\r\n    public download(imageType: string = \"png\", quality: number = 1): void {\r\n        setTimeout(() => {\r\n            const pack = {\r\n                name: this.name,\r\n                sets: {},\r\n                options: {},\r\n                frames: [],\r\n            };\r\n\r\n            const sKeys = Object.keys(this.sets);\r\n            const oKeys = Object.keys(this.options);\r\n            try {\r\n                for (let i = 0; i < sKeys.length; i++) {\r\n                    const channel: string = sKeys[i];\r\n                    const dt = (this.sets as any)[channel];\r\n                    (pack.sets as any)[channel] = dt.getContext().canvas.toDataURL(\"image/\" + imageType, quality);\r\n                }\r\n                for (let i = 0; i < oKeys.length; i++) {\r\n                    const opt: string = oKeys[i];\r\n                    (pack.options as any)[opt] = (this.options as any)[opt];\r\n                }\r\n                for (let i = 0; i < this.frames.length; i++) {\r\n                    const _f = this.frames[i];\r\n                    (pack.frames as Array<number>).push(_f.scale.x, _f.scale.y, _f.offset.x, _f.offset.y);\r\n                }\r\n            } catch (err) {\r\n                Logger.Warn(\"Unable to download: \" + err);\r\n                return;\r\n            }\r\n\r\n            const data = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(pack, null, 4));\r\n            const _a = document.createElement(\"a\");\r\n            _a.setAttribute(\"href\", data);\r\n            _a.setAttribute(\"download\", this.name + \"_texurePackage.json\");\r\n            document.body.appendChild(_a);\r\n            _a.click();\r\n            _a.remove();\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n     * Public method to load a texturePacker JSON file.\r\n     * @param data of the JSON file in string format.\r\n     */\r\n    public updateFromJSON(data: string): void {\r\n        try {\r\n            const parsedData: ITexturePackerJSON = JSON.parse(data);\r\n            this.name = parsedData.name;\r\n            const _options = Object.keys(parsedData.options);\r\n\r\n            for (let i = 0; i < _options.length; i++) {\r\n                (this.options as any)[_options[i]] = (parsedData.options as any)[_options[i]];\r\n            }\r\n\r\n            for (let i = 0; i < parsedData.frames.length; i += 4) {\r\n                const frame: TexturePackerFrame = new TexturePackerFrame(\r\n                    i / 4,\r\n                    new Vector2(parsedData.frames[i], parsedData.frames[i + 1]),\r\n                    new Vector2(parsedData.frames[i + 2], parsedData.frames[i + 3])\r\n                );\r\n                this.frames.push(frame);\r\n            }\r\n\r\n            const channels = Object.keys(parsedData.sets);\r\n\r\n            for (let i = 0; i < channels.length; i++) {\r\n                const _t = new Texture(parsedData.sets[channels[i]], this.scene, false, false);\r\n                (this.sets as any)[channels[i]] = _t;\r\n            }\r\n        } catch (err) {\r\n            Logger.Warn(\"Unable to update from JSON: \" + err);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}