{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexBuffer } from \"@babylonjs/core/Buffers/buffer.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\nimport { Color3, Color4 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Vector2, Vector3 } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { Geometry } from \"@babylonjs/core/Meshes/geometry.js\";\nimport { Mesh } from \"@babylonjs/core/Meshes/mesh.js\";\nimport { VertexData } from \"@babylonjs/core/Meshes/mesh.vertexData.js\";\n/**\n * Class used to load mesh data from OBJ content\n */\nexport class SolidParser {\n  /**\n   * Creates a new SolidParser\n   * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\n   * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\n   * @param loadingOptions defines the loading options to use\n   */\n  constructor(materialToUse, babylonMeshesArray, loadingOptions) {\n    this._positions = []; //values for the positions of vertices\n    this._normals = []; //Values for the normals\n    this._uvs = []; //Values for the textures\n    this._colors = [];\n    this._meshesFromObj = []; //[mesh] Contains all the obj meshes\n    this._indicesForBabylon = []; //The list of indices for VertexData\n    this._wrappedPositionForBabylon = []; //The list of position in vectors\n    this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n    this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n    this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n    this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n    this._curPositionInIndices = 0;\n    this._hasMeshes = false; //Meshes are defined in the file\n    this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n    this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n    this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n    this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n    this._triangles = []; //Indices from new triangles coming from polygons\n    this._materialNameFromObj = \"\"; //The name of the current material\n    this._objMeshName = \"\"; //The name of the current obj mesh\n    this._increment = 1; //Id for meshes created by the multimaterial\n    this._isFirstMaterial = true;\n    this._grayColor = new Color4(0.5, 0.5, 0.5, 1);\n    this._materialToUse = materialToUse;\n    this._babylonMeshesArray = babylonMeshesArray;\n    this._loadingOptions = loadingOptions;\n  }\n  /**\n   * Search for obj in the given array.\n   * This function is called to check if a couple of data already exists in an array.\n   *\n   * If found, returns the index of the founded tuple index. Returns -1 if not found\n   * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n   * @param obj Array<number>\n   * @returns {boolean}\n   */\n  _isInArray(arr, obj) {\n    if (!arr[obj[0]]) {\n      arr[obj[0]] = {\n        normals: [],\n        idx: []\n      };\n    }\n    const idx = arr[obj[0]].normals.indexOf(obj[1]);\n    return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n  }\n  _isInArrayUV(arr, obj) {\n    if (!arr[obj[0]]) {\n      arr[obj[0]] = {\n        normals: [],\n        idx: [],\n        uv: []\n      };\n    }\n    const idx = arr[obj[0]].normals.indexOf(obj[1]);\n    if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n      return arr[obj[0]].idx[idx];\n    }\n    return -1;\n  }\n  /**\n   * This function set the data for each triangle.\n   * Data are position, normals and uvs\n   * If a tuple of (position, normal) is not set, add the data into the corresponding array\n   * If the tuple already exist, add only their indice\n   *\n   * @param indicePositionFromObj Integer The index in positions array\n   * @param indiceUvsFromObj Integer The index in uvs array\n   * @param indiceNormalFromObj Integer The index in normals array\n   * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\n   * @param textureVectorFromOBJ Vector3 The value of uvs\n   * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\n   * @param positionColorsFromOBJ\n   */\n  _setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {\n    //Check if this tuple already exists in the list of tuples\n    let _index;\n    if (this._loadingOptions.optimizeWithUV) {\n      _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\n    } else {\n      _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\n    }\n    //If it not exists\n    if (_index === -1) {\n      //Add an new indice.\n      //The array of indices is only an array with his length equal to the number of triangles - 1.\n      //We add vertices data in this order\n      this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\n      //Push the position of vertice for Babylon\n      //Each element is a Vector3(x,y,z)\n      this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\n      //Push the uvs for Babylon\n      //Each element is a Vector3(u,v)\n      this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\n      //Push the normals for Babylon\n      //Each element is a Vector3(x,y,z)\n      this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\n      if (positionColorsFromOBJ !== undefined) {\n        //Push the colors for Babylon\n        //Each element is a BABYLON.Color4(r,g,b,a)\n        this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\n      }\n      //Add the tuple in the comparison list\n      this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\n      this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\n      if (this._loadingOptions.optimizeWithUV) {\n        this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\n      }\n    } else {\n      //The tuple already exists\n      //Add the index of the already existing tuple\n      //At this index we can get the value of position, normal, color and uvs of vertex\n      this._indicesForBabylon.push(_index);\n    }\n  }\n  /**\n   * Transform Vector() and BABYLON.Color() objects into numbers in an array\n   */\n  _unwrapData() {\n    //Every array has the same length\n    for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\n      //Push the x, y, z values of each element in the unwrapped array\n      this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\n      this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\n      this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n      if (this._loadingOptions.importVertexColors) {\n        //Push the r, g, b, a values of each element in the unwrapped array\n        this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\n      }\n    }\n    // Reset arrays for the next new meshes\n    this._wrappedPositionForBabylon.length = 0;\n    this._wrappedNormalsForBabylon.length = 0;\n    this._wrappedUvsForBabylon.length = 0;\n    this._wrappedColorsForBabylon.length = 0;\n    this._tuplePosNorm.length = 0;\n    this._curPositionInIndices = 0;\n  }\n  /**\n   * Create triangles from polygons\n   * It is important to notice that a triangle is a polygon\n   * We get 5 patterns of face defined in OBJ File :\n   * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n   * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n   * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n   * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n   * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n   * Each pattern is divided by the same method\n   * @param faces Array[String] The indices of elements\n   * @param v Integer The variable to increment\n   */\n  _getTriangles(faces, v) {\n    //Work for each element of the array\n    for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n      //Add on the triangle variable the indexes to obtain triangles\n      this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n    }\n    //Result obtained after 2 iterations:\n    //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n    //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n    //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n    //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n    //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n  }\n  /**\n   * Create triangles and push the data for each polygon for the pattern 1\n   * In this pattern we get vertice positions\n   * @param face\n   * @param v\n   */\n  _setDataForCurrentFaceWithPattern1(face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n    //For each element in the triangles array.\n    //This var could contains 1 to an infinity of triangles\n    for (let k = 0; k < this._triangles.length; k++) {\n      // Set position indice\n      const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\n      this._setData(indicePositionFromObj, 0, 0,\n      // In the pattern 1, normals and uvs are not defined\n      this._positions[indicePositionFromObj],\n      // Get the vectors data\n      Vector2.Zero(), Vector3.Up(),\n      // Create default vectors\n      this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    }\n    //Reset variable for the next line\n    this._triangles.length = 0;\n  }\n  /**\n   * Create triangles and push the data for each polygon for the pattern 2\n   * In this pattern we get vertice positions and uvsu\n   * @param face\n   * @param v\n   */\n  _setDataForCurrentFaceWithPattern2(face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n    for (let k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"1/1\"\n      //Split the data for getting position and uv\n      const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\n      //Set position indice\n      const indicePositionFromObj = parseInt(point[0]) - 1;\n      //Set uv indice\n      const indiceUvsFromObj = parseInt(point[1]) - 1;\n      this._setData(indicePositionFromObj, indiceUvsFromObj, 0,\n      //Default value for normals\n      this._positions[indicePositionFromObj],\n      //Get the values for each element\n      this._uvs[indiceUvsFromObj], Vector3.Up(),\n      //Default value for normals\n      this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    }\n    //Reset variable for the next line\n    this._triangles.length = 0;\n  }\n  /**\n   * Create triangles and push the data for each polygon for the pattern 3\n   * In this pattern we get vertice positions, uvs and normals\n   * @param face\n   * @param v\n   */\n  _setDataForCurrentFaceWithPattern3(face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n    for (let k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"1/1/1\"\n      //Split the data for getting position, uv, and normals\n      const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n      // Set position indice\n      const indicePositionFromObj = parseInt(point[0]) - 1;\n      // Set uv indice\n      const indiceUvsFromObj = parseInt(point[1]) - 1;\n      // Set normal indice\n      const indiceNormalFromObj = parseInt(point[2]) - 1;\n      this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj] //Set the vector for each component\n      );\n    }\n    //Reset variable for the next line\n    this._triangles.length = 0;\n  }\n  /**\n   * Create triangles and push the data for each polygon for the pattern 4\n   * In this pattern we get vertice positions and normals\n   * @param face\n   * @param v\n   */\n  _setDataForCurrentFaceWithPattern4(face, v) {\n    this._getTriangles(face, v);\n    for (let k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"1//1\"\n      //Split the data for getting position and normals\n      const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\n      // We check indices, and normals\n      const indicePositionFromObj = parseInt(point[0]) - 1;\n      const indiceNormalFromObj = parseInt(point[1]) - 1;\n      this._setData(indicePositionFromObj, 1,\n      //Default value for uv\n      indiceNormalFromObj, this._positions[indicePositionFromObj],\n      //Get each vector of data\n      Vector2.Zero(), this._normals[indiceNormalFromObj], this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    }\n    //Reset variable for the next line\n    this._triangles.length = 0;\n  }\n  /*\n   * Create triangles and push the data for each polygon for the pattern 3\n   * In this pattern we get vertice positions, uvs and normals\n   * @param face\n   * @param v\n   */\n  _setDataForCurrentFaceWithPattern5(face, v) {\n    //Get the indices of triangles for each polygon\n    this._getTriangles(face, v);\n    for (let k = 0; k < this._triangles.length; k++) {\n      //triangle[k] = \"-1/-1/-1\"\n      //Split the data for getting position, uv, and normals\n      const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n      // Set position indice\n      const indicePositionFromObj = this._positions.length + parseInt(point[0]);\n      // Set uv indice\n      const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\n      // Set normal indice\n      const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\n      this._setData(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, this._positions[indicePositionFromObj], this._uvs[indiceUvsFromObj], this._normals[indiceNormalFromObj],\n      //Set the vector for each component\n      this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined);\n    }\n    //Reset variable for the next line\n    this._triangles.length = 0;\n  }\n  _addPreviousObjMesh() {\n    //Check if it is not the first mesh. Otherwise we don't have data.\n    if (this._meshesFromObj.length > 0) {\n      //Get the previous mesh for applying the data about the faces\n      //=> in obj file, faces definition append after the name of the mesh\n      this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n      //Set the data into Array for the mesh\n      this._unwrapData();\n      // Reverse tab. Otherwise face are displayed in the wrong sens\n      this._indicesForBabylon.reverse();\n      //Set the information for the mesh\n      //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n      this._handledMesh.indices = this._indicesForBabylon.slice();\n      this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\n      this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\n      this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\n      if (this._loadingOptions.importVertexColors) {\n        this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\n      }\n      //Reset the array for the next mesh\n      this._indicesForBabylon.length = 0;\n      this._unwrappedPositionsForBabylon.length = 0;\n      this._unwrappedColorsForBabylon.length = 0;\n      this._unwrappedNormalsForBabylon.length = 0;\n      this._unwrappedUVForBabylon.length = 0;\n    }\n  }\n  _optimizeNormals(mesh) {\n    const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n    const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\n    const mapVertices = {};\n    if (!positions || !normals) {\n      return;\n    }\n    for (let i = 0; i < positions.length / 3; i++) {\n      const x = positions[i * 3 + 0];\n      const y = positions[i * 3 + 1];\n      const z = positions[i * 3 + 2];\n      const key = x + \"_\" + y + \"_\" + z;\n      let lst = mapVertices[key];\n      if (!lst) {\n        lst = [];\n        mapVertices[key] = lst;\n      }\n      lst.push(i);\n    }\n    const normal = new Vector3();\n    for (const key in mapVertices) {\n      const lst = mapVertices[key];\n      if (lst.length < 2) {\n        continue;\n      }\n      const v0Idx = lst[0];\n      for (let i = 1; i < lst.length; ++i) {\n        const vIdx = lst[i];\n        normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\n        normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\n        normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\n      }\n      normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\n      normal.normalize();\n      for (let i = 0; i < lst.length; ++i) {\n        const vIdx = lst[i];\n        normals[vIdx * 3 + 0] = normal.x;\n        normals[vIdx * 3 + 1] = normal.y;\n        normals[vIdx * 3 + 2] = normal.z;\n      }\n    }\n    mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n  }\n  /**\n   * Function used to parse an OBJ string\n   * @param meshesNames defines the list of meshes to load (all if not defined)\n   * @param data defines the OBJ string\n   * @param scene defines the hosting scene\n   * @param assetContainer defines the asset container to load data in\n   * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\n   */\n  parse(meshesNames, data, scene, assetContainer, onFileToLoadFound) {\n    var _a;\n    // Split the file into lines\n    const lines = data.split(\"\\n\");\n    // Look at each line\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim().replace(/\\s\\s/g, \" \");\n      let result;\n      // Comment or newLine\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n        //Get information about one position possible for the vertices\n      } else if (SolidParser.VertexPattern.test(line)) {\n        result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n        // Value of result with line: \"v 1.0 2.0 3.0\"\n        // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n        // Create a Vector3 with the position x, y, z\n        this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n        if (this._loadingOptions.importVertexColors) {\n          if (result.length >= 7) {\n            const r = parseFloat(result[4]);\n            const g = parseFloat(result[5]);\n            const b = parseFloat(result[6]);\n            this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n          } else {\n            // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n            this._colors.push(this._grayColor);\n          }\n        }\n      } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\n        //Create a Vector3 with the normals x, y, z\n        //Value of result\n        // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n        //Add the Vector in the list of normals\n        this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n      } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\n        //Create a Vector2 with the normals u, v\n        //Value of result\n        // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n        //Add the Vector in the list of uvs\n        this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\n        //Identify patterns of faces\n        //Face could be defined in different type of pattern\n      } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"),\n        // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"),\n        // [\"1//1\", \"2//2\", \"3//3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\n        //Value of result:\n        //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"),\n        // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\n        //Value of result:\n        //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"),\n        // [\"1/1\", \"2/2\", \"3/3\"]\n        1);\n      } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\n        //Value of result\n        //[\"f 1 2 3\", \"1 2 3\"...]\n        //Set the data for this face\n        this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"),\n        // [\"1\", \"2\", \"3\"]\n        1);\n        // Define a mesh or an object\n        // Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\n      } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\n        // Create a new mesh corresponding to the name of the group.\n        // Definition of the mesh\n        const objMesh = {\n          name: line.substring(2).trim(),\n          indices: undefined,\n          positions: undefined,\n          normals: undefined,\n          uvs: undefined,\n          colors: undefined,\n          materialName: this._materialNameFromObj\n        };\n        this._addPreviousObjMesh();\n        //Push the last mesh created with only the name\n        this._meshesFromObj.push(objMesh);\n        //Set this variable to indicate that now meshesFromObj has objects defined inside\n        this._hasMeshes = true;\n        this._isFirstMaterial = true;\n        this._increment = 1;\n        //Keyword for applying a material\n      } else if (SolidParser.UseMtlDescriptor.test(line)) {\n        //Get the name of the material\n        this._materialNameFromObj = line.substring(7).trim();\n        //If this new material is in the same mesh\n        if (!this._isFirstMaterial || !this._hasMeshes) {\n          //Set the data for the previous mesh\n          this._addPreviousObjMesh();\n          //Create a new mesh\n          const objMesh =\n          //Set the name of the current obj mesh\n          {\n            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(),\n            indices: undefined,\n            positions: undefined,\n            normals: undefined,\n            uvs: undefined,\n            colors: undefined,\n            materialName: this._materialNameFromObj\n          };\n          this._increment++;\n          //If meshes are already defined\n          this._meshesFromObj.push(objMesh);\n          this._hasMeshes = true;\n        }\n        //Set the material name if the previous line define a mesh\n        if (this._hasMeshes && this._isFirstMaterial) {\n          //Set the material name to the previous mesh (1 material per mesh)\n          this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\n          this._isFirstMaterial = false;\n        }\n        // Keyword for loading the mtl file\n      } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\n        // Get the name of mtl file\n        onFileToLoadFound(line.substring(7).trim());\n        // Apply smoothing\n      } else if (SolidParser.SmoothDescriptor.test(line)) {\n        // smooth shading => apply smoothing\n        // Today I don't know it work with babylon and with obj.\n        // With the obj file  an integer is set\n      } else {\n        //If there is another possibility\n        console.log(\"Unhandled expression at line : \" + line);\n      }\n    }\n    // At the end of the file, add the last mesh into the meshesFromObj array\n    if (this._hasMeshes) {\n      // Set the data for the last mesh\n      this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n      //Reverse indices for displaying faces in the good sense\n      this._indicesForBabylon.reverse();\n      //Get the good array\n      this._unwrapData();\n      //Set array\n      this._handledMesh.indices = this._indicesForBabylon;\n      this._handledMesh.positions = this._unwrappedPositionsForBabylon;\n      this._handledMesh.normals = this._unwrappedNormalsForBabylon;\n      this._handledMesh.uvs = this._unwrappedUVForBabylon;\n      if (this._loadingOptions.importVertexColors) {\n        this._handledMesh.colors = this._unwrappedColorsForBabylon;\n      }\n    }\n    // If any o or g keyword not found, create a mesh with a random id\n    if (!this._hasMeshes) {\n      let newMaterial = null;\n      if (this._indicesForBabylon.length) {\n        // reverse tab of indices\n        this._indicesForBabylon.reverse();\n        //Get positions normals uvs\n        this._unwrapData();\n      } else {\n        // There is no indices in the file. We will have to switch to point cloud rendering\n        for (const pos of this._positions) {\n          this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\n        }\n        if (this._normals.length) {\n          for (const normal of this._normals) {\n            this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\n          }\n        }\n        if (this._uvs.length) {\n          for (const uv of this._uvs) {\n            this._unwrappedUVForBabylon.push(uv.x, uv.y);\n          }\n        }\n        if (this._colors.length) {\n          for (const color of this._colors) {\n            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n          }\n        }\n        if (!this._materialNameFromObj) {\n          // Create a material with point cloud on\n          newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\n          newMaterial.pointsCloud = true;\n          this._materialNameFromObj = newMaterial.name;\n          if (!this._normals.length) {\n            newMaterial.disableLighting = true;\n            newMaterial.emissiveColor = Color3.White();\n          }\n        }\n      }\n      //Set data for one mesh\n      this._meshesFromObj.push({\n        name: Geometry.RandomId(),\n        indices: this._indicesForBabylon,\n        positions: this._unwrappedPositionsForBabylon,\n        colors: this._unwrappedColorsForBabylon,\n        normals: this._unwrappedNormalsForBabylon,\n        uvs: this._unwrappedUVForBabylon,\n        materialName: this._materialNameFromObj,\n        directMaterial: newMaterial\n      });\n    }\n    //Set data for each mesh\n    for (let j = 0; j < this._meshesFromObj.length; j++) {\n      //check meshesNames (stlFileLoader)\n      if (meshesNames && this._meshesFromObj[j].name) {\n        if (meshesNames instanceof Array) {\n          if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\n            continue;\n          }\n        } else {\n          if (this._meshesFromObj[j].name !== meshesNames) {\n            continue;\n          }\n        }\n      }\n      //Get the current mesh\n      //Set the data with VertexBuffer for each mesh\n      this._handledMesh = this._meshesFromObj[j];\n      //Create a Mesh with the name of the obj mesh\n      scene._blockEntityCollection = !!assetContainer;\n      const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\n      babylonMesh._parentContainer = assetContainer;\n      scene._blockEntityCollection = false;\n      //Push the name of the material to an array\n      //This is indispensable for the importMesh function\n      this._materialToUse.push(this._meshesFromObj[j].materialName);\n      if (((_a = this._handledMesh.positions) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n        //Push the mesh into an array\n        this._babylonMeshesArray.push(babylonMesh);\n        continue;\n      }\n      const vertexData = new VertexData(); //The container for the values\n      //Set the data for the babylonMesh\n      vertexData.uvs = this._handledMesh.uvs;\n      vertexData.indices = this._handledMesh.indices;\n      vertexData.positions = this._handledMesh.positions;\n      if (this._loadingOptions.computeNormals) {\n        const normals = new Array();\n        VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\n        vertexData.normals = normals;\n      } else {\n        vertexData.normals = this._handledMesh.normals;\n      }\n      if (this._loadingOptions.importVertexColors) {\n        vertexData.colors = this._handledMesh.colors;\n      }\n      //Set the data from the VertexBuffer to the current Mesh\n      vertexData.applyToMesh(babylonMesh);\n      if (this._loadingOptions.invertY) {\n        babylonMesh.scaling.y *= -1;\n      }\n      if (this._loadingOptions.optimizeNormals) {\n        this._optimizeNormals(babylonMesh);\n      }\n      //Push the mesh into an array\n      this._babylonMeshesArray.push(babylonMesh);\n      if (this._handledMesh.directMaterial) {\n        babylonMesh.material = this._handledMesh.directMaterial;\n      }\n    }\n  }\n}\n// Descriptor\n/** Object descriptor */\nSolidParser.ObjectDescriptor = /^o/;\n/** Group descriptor */\nSolidParser.GroupDescriptor = /^g/;\n/** Material lib descriptor */\nSolidParser.MtlLibGroupDescriptor = /^mtllib /;\n/** Use a material descriptor */\nSolidParser.UseMtlDescriptor = /^usemtl /;\n/** Smooth descriptor */\nSolidParser.SmoothDescriptor = /^s /;\n// Patterns\n/** Pattern used to detect a vertex */\nSolidParser.VertexPattern = /v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\n/** Pattern used to detect a normal */\nSolidParser.NormalPattern = /vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a UV set */\nSolidParser.UVPattern = /vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a first kind of face (f vertex vertex vertex) */\nSolidParser.FacePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n/** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\nSolidParser.FacePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.FacePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\nSolidParser.FacePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\nSolidParser.FacePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;","map":{"version":3,"mappings":";AACA,SAASA,YAAY,QAAE;AAEvB,SAASC,gBAAgB,QAAE;AAC3B,SAASC,MAAM,EAAEC,MAAM,QAAE;AACzB,SAASC,OAAO,EAAEC,OAAO,QAAE;AAE3B,SAASC,QAAQ,QAAE;AACnB,SAASC,IAAI,QAAE;AACf,SAASC,UAAU,QAAE;AAgBrB;;;AAGA,OAAM,MAAOC,WAAW;EA2DpB;;;;;;EAMAC,YAAmBC,aAAuB,EAAEC,kBAA+B,EAAEC,cAAiC;IAjCtG,eAAU,GAAmB,EAAE,CAAC,CAAC;IACjC,aAAQ,GAAmB,EAAE,CAAC,CAAC;IAC/B,SAAI,GAAmB,EAAE,CAAC,CAAC;IAC3B,YAAO,GAAkB,EAAE;IAC3B,mBAAc,GAAsB,EAAE,CAAC,CAAC;IAExC,uBAAkB,GAAkB,EAAE,CAAC,CAAC;IACxC,+BAA0B,GAAmB,EAAE,CAAC,CAAC;IACjD,0BAAqB,GAAmB,EAAE,CAAC,CAAC;IAC5C,6BAAwB,GAAkB,EAAE,CAAC,CAAC;IAC9C,8BAAyB,GAAmB,EAAE,CAAC,CAAC;IAChD,kBAAa,GAA6E,EAAE,CAAC,CAAC;IAC9F,0BAAqB,GAAG,CAAC;IACzB,eAAU,GAAY,KAAK,CAAC,CAAC;IAC7B,kCAA6B,GAAkB,EAAE,CAAC,CAAC;IACnD,+BAA0B,GAAkB,EAAE,CAAC,CAAC;IAChD,gCAA2B,GAAkB,EAAE,CAAC,CAAC;IACjD,2BAAsB,GAAkB,EAAE,CAAC,CAAC;IAC5C,eAAU,GAAkB,EAAE,CAAC,CAAC;IAChC,yBAAoB,GAAW,EAAE,CAAC,CAAC;IACnC,iBAAY,GAAW,EAAE,CAAC,CAAC;IAC3B,eAAU,GAAW,CAAC,CAAC,CAAC;IACxB,qBAAgB,GAAY,IAAI;IAChC,eAAU,GAAG,IAAIV,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;IAW7C,IAAI,CAACW,cAAc,GAAGH,aAAa;IACnC,IAAI,CAACI,mBAAmB,GAAGH,kBAAkB;IAC7C,IAAI,CAACI,eAAe,GAAGH,cAAc;EACzC;EAEA;;;;;;;;;EASQI,UAAU,CAACC,GAA0D,EAAEC,GAAkB;IAC7F,IAAI,CAACD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;MACdD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG;QAAEC,OAAO,EAAE,EAAE;QAAEC,GAAG,EAAE;MAAE,CAAE;;IAE1C,MAAMA,GAAG,GAAGH,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,OAAO,CAACE,OAAO,CAACH,GAAG,CAAC,CAAC,CAAC,CAAC;IAE/C,OAAOE,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGH,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACE,GAAG,CAACA,GAAG,CAAC;EACjD;EAEQE,YAAY,CAACL,GAA6E,EAAEC,GAAkB;IAClH,IAAI,CAACD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;MACdD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG;QAAEC,OAAO,EAAE,EAAE;QAAEC,GAAG,EAAE,EAAE;QAAEG,EAAE,EAAE;MAAE,CAAE;;IAElD,MAAMH,GAAG,GAAGH,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,OAAO,CAACE,OAAO,CAACH,GAAG,CAAC,CAAC,CAAC,CAAC;IAE/C,IAAIE,GAAG,IAAI,CAAC,IAAIF,GAAG,CAAC,CAAC,CAAC,KAAKD,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACK,EAAE,CAACH,GAAG,CAAC,EAAE;MAC5C,OAAOH,GAAG,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACE,GAAG,CAACA,GAAG,CAAC;;IAE/B,OAAO,CAAC,CAAC;EACb;EAEA;;;;;;;;;;;;;;EAcQI,QAAQ,CACZC,qBAA6B,EAC7BC,gBAAwB,EACxBC,mBAA2B,EAC3BC,qBAA8B,EAC9BC,oBAA6B,EAC7BC,oBAA6B,EAC7BC,qBAA8B;IAE9B;IACA,IAAIC,MAAc;IAClB,IAAI,IAAI,CAACjB,eAAe,CAACkB,cAAc,EAAE;MACrCD,MAAM,GAAG,IAAI,CAACV,YAAY,CAAC,IAAI,CAACY,aAAa,EAAE,CAACT,qBAAqB,EAAEE,mBAAmB,EAAED,gBAAgB,CAAC,CAAC;KACjH,MAAM;MACHM,MAAM,GAAG,IAAI,CAAChB,UAAU,CAAC,IAAI,CAACkB,aAAa,EAAE,CAACT,qBAAqB,EAAEE,mBAAmB,CAAC,CAAC;;IAG9F;IACA,IAAIK,MAAM,KAAK,CAAC,CAAC,EAAE;MACf;MACA;MACA;MACA,IAAI,CAACG,kBAAkB,CAACC,IAAI,CAAC,IAAI,CAACC,0BAA0B,CAACC,MAAM,CAAC;MACpE;MACA;MACA,IAAI,CAACD,0BAA0B,CAACD,IAAI,CAACR,qBAAqB,CAAC;MAC3D;MACA;MACA,IAAI,CAACW,qBAAqB,CAACH,IAAI,CAACP,oBAAoB,CAAC;MACrD;MACA;MACA,IAAI,CAACW,yBAAyB,CAACJ,IAAI,CAACN,oBAAoB,CAAC;MAEzD,IAAIC,qBAAqB,KAAKU,SAAS,EAAE;QACrC;QACA;QACA,IAAI,CAACC,wBAAwB,CAACN,IAAI,CAACL,qBAAqB,CAAC;;MAG7D;MACA,IAAI,CAACG,aAAa,CAACT,qBAAqB,CAAC,CAACN,OAAO,CAACiB,IAAI,CAACT,mBAAmB,CAAC;MAC3E,IAAI,CAACO,aAAa,CAACT,qBAAqB,CAAC,CAACL,GAAG,CAACgB,IAAI,CAAC,IAAI,CAACO,qBAAqB,EAAE,CAAC;MAChF,IAAI,IAAI,CAAC5B,eAAe,CAACkB,cAAc,EAAE;QACrC,IAAI,CAACC,aAAa,CAACT,qBAAqB,CAAC,CAACF,EAAE,CAACa,IAAI,CAACV,gBAAgB,CAAC;;KAE1E,MAAM;MACH;MACA;MACA;MACA,IAAI,CAACS,kBAAkB,CAACC,IAAI,CAACJ,MAAM,CAAC;;EAE5C;EAEA;;;EAGQY,WAAW;IACf;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACR,0BAA0B,CAACC,MAAM,EAAEO,CAAC,EAAE,EAAE;MAC7D;MACA,IAAI,CAACC,6BAA6B,CAACV,IAAI,CAAC,IAAI,CAACC,0BAA0B,CAACQ,CAAC,CAAC,CAACE,CAAC,EAAE,IAAI,CAACV,0BAA0B,CAACQ,CAAC,CAAC,CAACG,CAAC,EAAE,IAAI,CAACX,0BAA0B,CAACQ,CAAC,CAAC,CAACI,CAAC,CAAC;MACzJ,IAAI,CAACC,2BAA2B,CAACd,IAAI,CAAC,IAAI,CAACI,yBAAyB,CAACK,CAAC,CAAC,CAACE,CAAC,EAAE,IAAI,CAACP,yBAAyB,CAACK,CAAC,CAAC,CAACG,CAAC,EAAE,IAAI,CAACR,yBAAyB,CAACK,CAAC,CAAC,CAACI,CAAC,CAAC;MACpJ,IAAI,CAACE,sBAAsB,CAACf,IAAI,CAAC,IAAI,CAACG,qBAAqB,CAACM,CAAC,CAAC,CAACE,CAAC,EAAE,IAAI,CAACR,qBAAqB,CAACM,CAAC,CAAC,CAACG,CAAC,CAAC,CAAC,CAAC;MACpG,IAAI,IAAI,CAACjC,eAAe,CAACqC,kBAAkB,EAAE;QACzC;QACA,IAAI,CAACC,0BAA0B,CAACjB,IAAI,CAChC,IAAI,CAACM,wBAAwB,CAACG,CAAC,CAAC,CAACS,CAAC,EAClC,IAAI,CAACZ,wBAAwB,CAACG,CAAC,CAAC,CAACU,CAAC,EAClC,IAAI,CAACb,wBAAwB,CAACG,CAAC,CAAC,CAACW,CAAC,EAClC,IAAI,CAACd,wBAAwB,CAACG,CAAC,CAAC,CAACY,CAAC,CACrC;;;IAGT;IACA,IAAI,CAACpB,0BAA0B,CAACC,MAAM,GAAG,CAAC;IAC1C,IAAI,CAACE,yBAAyB,CAACF,MAAM,GAAG,CAAC;IACzC,IAAI,CAACC,qBAAqB,CAACD,MAAM,GAAG,CAAC;IACrC,IAAI,CAACI,wBAAwB,CAACJ,MAAM,GAAG,CAAC;IACxC,IAAI,CAACJ,aAAa,CAACI,MAAM,GAAG,CAAC;IAC7B,IAAI,CAACK,qBAAqB,GAAG,CAAC;EAClC;EAEA;;;;;;;;;;;;;EAaQe,aAAa,CAACC,KAAoB,EAAEC,CAAS;IACjD;IACA,KAAK,IAAIC,SAAS,GAAGD,CAAC,EAAEC,SAAS,GAAGF,KAAK,CAACrB,MAAM,GAAG,CAAC,EAAEuB,SAAS,EAAE,EAAE;MAC/D;MACA,IAAI,CAACC,UAAU,CAAC1B,IAAI,CAACuB,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAACE,SAAS,CAAC,EAAEF,KAAK,CAACE,SAAS,GAAG,CAAC,CAAC,CAAC;;IAG1E;IACA;IACA;IACA;IACA;IACA;EACJ;EAEA;;;;;;EAMQE,kCAAkC,CAACC,IAAmB,EAAEJ,CAAS;IACrE;IACA,IAAI,CAACF,aAAa,CAACM,IAAI,EAAEJ,CAAC,CAAC;IAC3B;IACA;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,UAAU,CAACxB,MAAM,EAAE2B,CAAC,EAAE,EAAE;MAC7C;MACA,MAAMxC,qBAAqB,GAAGyC,QAAQ,CAAC,IAAI,CAACJ,UAAU,CAACG,CAAC,CAAC,CAAC,GAAG,CAAC;MAE9D,IAAI,CAACzC,QAAQ,CACTC,qBAAqB,EACrB,CAAC,EACD,CAAC;MAAE;MACH,IAAI,CAAC0C,UAAU,CAAC1C,qBAAqB,CAAC;MAAE;MACxCtB,OAAO,CAACiE,IAAI,EAAE,EACdhE,OAAO,CAACiE,EAAE,EAAE;MAAE;MACd,IAAI,CAACtD,eAAe,CAACqC,kBAAkB,GAAG,IAAI,CAACkB,OAAO,CAAC7C,qBAAqB,CAAC,GAAGgB,SAAS,CAC5F;;IAEL;IACA,IAAI,CAACqB,UAAU,CAACxB,MAAM,GAAG,CAAC;EAC9B;EAEA;;;;;;EAMQiC,kCAAkC,CAACP,IAAmB,EAAEJ,CAAS;IACrE;IACA,IAAI,CAACF,aAAa,CAACM,IAAI,EAAEJ,CAAC,CAAC;IAC3B,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,UAAU,CAACxB,MAAM,EAAE2B,CAAC,EAAE,EAAE;MAC7C;MACA;MACA,MAAMO,KAAK,GAAG,IAAI,CAACV,UAAU,CAACG,CAAC,CAAC,CAACQ,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7C;MACA,MAAMhD,qBAAqB,GAAGyC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MACpD;MACA,MAAM9C,gBAAgB,GAAGwC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAE/C,IAAI,CAAChD,QAAQ,CACTC,qBAAqB,EACrBC,gBAAgB,EAChB,CAAC;MAAE;MACH,IAAI,CAACyC,UAAU,CAAC1C,qBAAqB,CAAC;MAAE;MACxC,IAAI,CAACiD,IAAI,CAAChD,gBAAgB,CAAC,EAC3BtB,OAAO,CAACiE,EAAE,EAAE;MAAE;MACd,IAAI,CAACtD,eAAe,CAACqC,kBAAkB,GAAG,IAAI,CAACkB,OAAO,CAAC7C,qBAAqB,CAAC,GAAGgB,SAAS,CAC5F;;IAGL;IACA,IAAI,CAACqB,UAAU,CAACxB,MAAM,GAAG,CAAC;EAC9B;EAEA;;;;;;EAMQqC,kCAAkC,CAACX,IAAmB,EAAEJ,CAAS;IACrE;IACA,IAAI,CAACF,aAAa,CAACM,IAAI,EAAEJ,CAAC,CAAC;IAE3B,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,UAAU,CAACxB,MAAM,EAAE2B,CAAC,EAAE,EAAE;MAC7C;MACA;MACA,MAAMO,KAAK,GAAG,IAAI,CAACV,UAAU,CAACG,CAAC,CAAC,CAACQ,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7C;MACA,MAAMhD,qBAAqB,GAAGyC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MACpD;MACA,MAAM9C,gBAAgB,GAAGwC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAC/C;MACA,MAAM7C,mBAAmB,GAAGuC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAElD,IAAI,CAAChD,QAAQ,CACTC,qBAAqB,EACrBC,gBAAgB,EAChBC,mBAAmB,EACnB,IAAI,CAACwC,UAAU,CAAC1C,qBAAqB,CAAC,EACtC,IAAI,CAACiD,IAAI,CAAChD,gBAAgB,CAAC,EAC3B,IAAI,CAACkD,QAAQ,CAACjD,mBAAmB,CAAC,CAAC;MAAA,CACtC;;IAEL;IACA,IAAI,CAACmC,UAAU,CAACxB,MAAM,GAAG,CAAC;EAC9B;EAEA;;;;;;EAMQuC,kCAAkC,CAACb,IAAmB,EAAEJ,CAAS;IACrE,IAAI,CAACF,aAAa,CAACM,IAAI,EAAEJ,CAAC,CAAC;IAE3B,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,UAAU,CAACxB,MAAM,EAAE2B,CAAC,EAAE,EAAE;MAC7C;MACA;MACA,MAAMO,KAAK,GAAG,IAAI,CAACV,UAAU,CAACG,CAAC,CAAC,CAACQ,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;MAC9C;MACA,MAAMhD,qBAAqB,GAAGyC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MACpD,MAAM7C,mBAAmB,GAAGuC,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;MAElD,IAAI,CAAChD,QAAQ,CACTC,qBAAqB,EACrB,CAAC;MAAE;MACHE,mBAAmB,EACnB,IAAI,CAACwC,UAAU,CAAC1C,qBAAqB,CAAC;MAAE;MACxCtB,OAAO,CAACiE,IAAI,EAAE,EACd,IAAI,CAACQ,QAAQ,CAACjD,mBAAmB,CAAC,EAClC,IAAI,CAACZ,eAAe,CAACqC,kBAAkB,GAAG,IAAI,CAACkB,OAAO,CAAC7C,qBAAqB,CAAC,GAAGgB,SAAS,CAC5F;;IAEL;IACA,IAAI,CAACqB,UAAU,CAACxB,MAAM,GAAG,CAAC;EAC9B;EAEA;;;;;;EAMQwC,kCAAkC,CAACd,IAAmB,EAAEJ,CAAS;IACrE;IACA,IAAI,CAACF,aAAa,CAACM,IAAI,EAAEJ,CAAC,CAAC;IAE3B,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACH,UAAU,CAACxB,MAAM,EAAE2B,CAAC,EAAE,EAAE;MAC7C;MACA;MACA,MAAMO,KAAK,GAAG,IAAI,CAACV,UAAU,CAACG,CAAC,CAAC,CAACQ,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7C;MACA,MAAMhD,qBAAqB,GAAG,IAAI,CAAC0C,UAAU,CAAC7B,MAAM,GAAG4B,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;MACzE;MACA,MAAM9C,gBAAgB,GAAG,IAAI,CAACgD,IAAI,CAACpC,MAAM,GAAG4B,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;MAC9D;MACA,MAAM7C,mBAAmB,GAAG,IAAI,CAACiD,QAAQ,CAACtC,MAAM,GAAG4B,QAAQ,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;MAErE,IAAI,CAAChD,QAAQ,CACTC,qBAAqB,EACrBC,gBAAgB,EAChBC,mBAAmB,EACnB,IAAI,CAACwC,UAAU,CAAC1C,qBAAqB,CAAC,EACtC,IAAI,CAACiD,IAAI,CAAChD,gBAAgB,CAAC,EAC3B,IAAI,CAACkD,QAAQ,CAACjD,mBAAmB,CAAC;MAAE;MACpC,IAAI,CAACZ,eAAe,CAACqC,kBAAkB,GAAG,IAAI,CAACkB,OAAO,CAAC7C,qBAAqB,CAAC,GAAGgB,SAAS,CAC5F;;IAEL;IACA,IAAI,CAACqB,UAAU,CAACxB,MAAM,GAAG,CAAC;EAC9B;EAEQyC,mBAAmB;IACvB;IACA,IAAI,IAAI,CAACC,cAAc,CAAC1C,MAAM,GAAG,CAAC,EAAE;MAChC;MACA;MACA,IAAI,CAAC2C,YAAY,GAAG,IAAI,CAACD,cAAc,CAAC,IAAI,CAACA,cAAc,CAAC1C,MAAM,GAAG,CAAC,CAAC;MAEvE;MACA,IAAI,CAACM,WAAW,EAAE;MAElB;MACA,IAAI,CAACT,kBAAkB,CAAC+C,OAAO,EAAE;MACjC;MACA;MACA,IAAI,CAACD,YAAY,CAACE,OAAO,GAAG,IAAI,CAAChD,kBAAkB,CAACiD,KAAK,EAAE;MAC3D,IAAI,CAACH,YAAY,CAACI,SAAS,GAAG,IAAI,CAACvC,6BAA6B,CAACsC,KAAK,EAAE;MACxE,IAAI,CAACH,YAAY,CAAC9D,OAAO,GAAG,IAAI,CAAC+B,2BAA2B,CAACkC,KAAK,EAAE;MACpE,IAAI,CAACH,YAAY,CAACK,GAAG,GAAG,IAAI,CAACnC,sBAAsB,CAACiC,KAAK,EAAE;MAE3D,IAAI,IAAI,CAACrE,eAAe,CAACqC,kBAAkB,EAAE;QACzC,IAAI,CAAC6B,YAAY,CAACM,MAAM,GAAG,IAAI,CAAClC,0BAA0B,CAAC+B,KAAK,EAAE;;MAGtE;MACA,IAAI,CAACjD,kBAAkB,CAACG,MAAM,GAAG,CAAC;MAClC,IAAI,CAACQ,6BAA6B,CAACR,MAAM,GAAG,CAAC;MAC7C,IAAI,CAACe,0BAA0B,CAACf,MAAM,GAAG,CAAC;MAC1C,IAAI,CAACY,2BAA2B,CAACZ,MAAM,GAAG,CAAC;MAC3C,IAAI,CAACa,sBAAsB,CAACb,MAAM,GAAG,CAAC;;EAE9C;EAEQkD,gBAAgB,CAACC,IAAkB;IACvC,MAAMJ,SAAS,GAAGI,IAAI,CAACC,eAAe,CAAC3F,YAAY,CAAC4F,YAAY,CAAC;IACjE,MAAMxE,OAAO,GAAGsE,IAAI,CAACC,eAAe,CAAC3F,YAAY,CAAC6F,UAAU,CAAC;IAC7D,MAAMC,WAAW,GAAgC,EAAE;IAEnD,IAAI,CAACR,SAAS,IAAI,CAAClE,OAAO,EAAE;MACxB;;IAGJ,KAAK,IAAI2E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,SAAS,CAAC/C,MAAM,GAAG,CAAC,EAAEwD,CAAC,EAAE,EAAE;MAC3C,MAAM/C,CAAC,GAAGsC,SAAS,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAC9B,MAAM9C,CAAC,GAAGqC,SAAS,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAC9B,MAAM7C,CAAC,GAAGoC,SAAS,CAACS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAC9B,MAAMC,GAAG,GAAGhD,CAAC,GAAG,GAAG,GAAGC,CAAC,GAAG,GAAG,GAAGC,CAAC;MAEjC,IAAI+C,GAAG,GAAGH,WAAW,CAACE,GAAG,CAAC;MAC1B,IAAI,CAACC,GAAG,EAAE;QACNA,GAAG,GAAG,EAAE;QACRH,WAAW,CAACE,GAAG,CAAC,GAAGC,GAAG;;MAE1BA,GAAG,CAAC5D,IAAI,CAAC0D,CAAC,CAAC;;IAGf,MAAMG,MAAM,GAAG,IAAI7F,OAAO,EAAE;IAC5B,KAAK,MAAM2F,GAAG,IAAIF,WAAW,EAAE;MAC3B,MAAMG,GAAG,GAAGH,WAAW,CAACE,GAAG,CAAC;MAC5B,IAAIC,GAAG,CAAC1D,MAAM,GAAG,CAAC,EAAE;QAChB;;MAGJ,MAAM4D,KAAK,GAAGF,GAAG,CAAC,CAAC,CAAC;MACpB,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,GAAG,CAAC1D,MAAM,EAAE,EAAEwD,CAAC,EAAE;QACjC,MAAMK,IAAI,GAAGH,GAAG,CAACF,CAAC,CAAC;QACnB3E,OAAO,CAAC+E,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI/E,OAAO,CAACgF,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/ChF,OAAO,CAAC+E,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI/E,OAAO,CAACgF,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;QAC/ChF,OAAO,CAAC+E,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI/E,OAAO,CAACgF,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;;MAGnDF,MAAM,CAACG,cAAc,CAACjF,OAAO,CAAC+E,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE/E,OAAO,CAAC+E,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE/E,OAAO,CAAC+E,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;MAC7FD,MAAM,CAACI,SAAS,EAAE;MAElB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGE,GAAG,CAAC1D,MAAM,EAAE,EAAEwD,CAAC,EAAE;QACjC,MAAMK,IAAI,GAAGH,GAAG,CAACF,CAAC,CAAC;QACnB3E,OAAO,CAACgF,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGF,MAAM,CAAClD,CAAC;QAChC5B,OAAO,CAACgF,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGF,MAAM,CAACjD,CAAC;QAChC7B,OAAO,CAACgF,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,GAAGF,MAAM,CAAChD,CAAC;;;IAGxCwC,IAAI,CAACa,eAAe,CAACvG,YAAY,CAAC6F,UAAU,EAAEzE,OAAO,CAAC;EAC1D;EAEA;;;;;;;;EAQOoF,KAAK,CAACC,WAAgB,EAAEC,IAAY,EAAEC,KAAY,EAAEC,cAAwC,EAAEC,iBAA+C;;IAChJ;IACA,MAAMC,KAAK,GAAGJ,IAAI,CAAChC,KAAK,CAAC,IAAI,CAAC;IAC9B;IACA,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,KAAK,CAACvE,MAAM,EAAEwD,CAAC,EAAE,EAAE;MACnC,MAAMgB,IAAI,GAAGD,KAAK,CAACf,CAAC,CAAC,CAACiB,IAAI,EAAE,CAACC,OAAO,CAAC,OAAO,EAAE,GAAG,CAAC;MAClD,IAAIC,MAAM;MAEV;MACA,IAAIH,IAAI,CAACxE,MAAM,KAAK,CAAC,IAAIwE,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7C;QAEA;OACH,MAAM,IAAI1G,WAAW,CAAC2G,aAAa,CAACC,IAAI,CAACN,IAAI,CAAC,EAAE;QAC7CG,MAAM,GAAGH,IAAI,CAACO,KAAK,CAAC,QAAQ,CAAE,CAAC,CAAC;QAEhC;QACA;QACA;QACA,IAAI,CAAClD,UAAU,CAAC/B,IAAI,CAAC,IAAIhC,OAAO,CAACkH,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEK,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEK,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEtG,IAAI,IAAI,CAAClG,eAAe,CAACqC,kBAAkB,EAAE;UACzC,IAAI6D,MAAM,CAAC3E,MAAM,IAAI,CAAC,EAAE;YACpB,MAAMgB,CAAC,GAAGgE,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC;YAC/B,MAAM1D,CAAC,GAAG+D,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC;YAC/B,MAAMzD,CAAC,GAAG8D,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC;YAE/B,IAAI,CAAC3C,OAAO,CAAClC,IAAI,CACb,IAAIlC,MAAM,CAACoD,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,GAAG,GAAGA,CAAC,EAAEC,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,GAAG,GAAGA,CAAC,EAAEC,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,GAAG,GAAGA,CAAC,EAAEyD,MAAM,CAAC3E,MAAM,KAAK,CAAC,IAAI2E,MAAM,CAAC,CAAC,CAAC,KAAKxE,SAAS,GAAG,CAAC,GAAG6E,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CACxJ;WACJ,MAAM;YACH;YACA,IAAI,CAAC3C,OAAO,CAAClC,IAAI,CAAC,IAAI,CAACmF,UAAU,CAAC;;;OAG7C,MAAM,IAAI,CAACN,MAAM,GAAGzG,WAAW,CAACgH,aAAa,CAACC,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QACjE;QACA;QACA;QACA;QACA,IAAI,CAAClC,QAAQ,CAACxC,IAAI,CAAC,IAAIhC,OAAO,CAACkH,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEK,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,EAAEK,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;OACvG,MAAM,IAAI,CAACA,MAAM,GAAGzG,WAAW,CAACkH,SAAS,CAACD,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QAC7D;QACA;QACA;QACA;QACA,IAAI,CAACpC,IAAI,CAACtC,IAAI,CAAC,IAAIjC,OAAO,CAACmH,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAClG,eAAe,CAAC4G,SAAS,CAAC5E,CAAC,EAAEuE,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,CAAClG,eAAe,CAAC4G,SAAS,CAAC3E,CAAC,CAAC,CAAC;QAE/I;QACA;OACH,MAAM,IAAI,CAACiE,MAAM,GAAGzG,WAAW,CAACoH,YAAY,CAACH,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QAChE;QACA;QAEA;QACA,IAAI,CAACnC,kCAAkC,CACnCsC,MAAM,CAAC,CAAC,CAAC,CAACF,IAAI,EAAE,CAACtC,KAAK,CAAC,GAAG,CAAC;QAAE;QAC7B,CAAC,CACJ;OACJ,MAAM,IAAI,CAACwC,MAAM,GAAGzG,WAAW,CAACqH,YAAY,CAACJ,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QAChE;QACA;QAEA;QACA,IAAI,CAACjC,kCAAkC,CACnCoC,MAAM,CAAC,CAAC,CAAC,CAACF,IAAI,EAAE,CAACtC,KAAK,CAAC,GAAG,CAAC;QAAE;QAC7B,CAAC,CACJ;OACJ,MAAM,IAAI,CAACwC,MAAM,GAAGzG,WAAW,CAACsH,YAAY,CAACL,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QAChE;QACA;QAEA;QACA,IAAI,CAAChC,kCAAkC,CACnCmC,MAAM,CAAC,CAAC,CAAC,CAACF,IAAI,EAAE,CAACtC,KAAK,CAAC,GAAG,CAAC;QAAE;QAC7B,CAAC,CACJ;OACJ,MAAM,IAAI,CAACwC,MAAM,GAAGzG,WAAW,CAACuH,YAAY,CAACN,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QAChE;QACA;QAEA;QACA,IAAI,CAACvC,kCAAkC,CACnC0C,MAAM,CAAC,CAAC,CAAC,CAACF,IAAI,EAAE,CAACtC,KAAK,CAAC,GAAG,CAAC;QAAE;QAC7B,CAAC,CACJ;OACJ,MAAM,IAAI,CAACwC,MAAM,GAAGzG,WAAW,CAACwH,YAAY,CAACP,IAAI,CAACX,IAAI,CAAC,MAAM,IAAI,EAAE;QAChE;QACA;QAEA;QACA,IAAI,CAAC/C,kCAAkC,CACnCkD,MAAM,CAAC,CAAC,CAAC,CAACF,IAAI,EAAE,CAACtC,KAAK,CAAC,GAAG,CAAC;QAAE;QAC7B,CAAC,CACJ;QAED;QACA;OACH,MAAM,IAAIjE,WAAW,CAACyH,eAAe,CAACb,IAAI,CAACN,IAAI,CAAC,IAAItG,WAAW,CAAC0H,gBAAgB,CAACd,IAAI,CAACN,IAAI,CAAC,EAAE;QAC1F;QACA;QACA,MAAMqB,OAAO,GAAe;UACxBC,IAAI,EAAEtB,IAAI,CAACuB,SAAS,CAAC,CAAC,CAAC,CAACtB,IAAI,EAAE;UAC9B5B,OAAO,EAAE1C,SAAS;UAClB4C,SAAS,EAAE5C,SAAS;UACpBtB,OAAO,EAAEsB,SAAS;UAClB6C,GAAG,EAAE7C,SAAS;UACd8C,MAAM,EAAE9C,SAAS;UACjB6F,YAAY,EAAE,IAAI,CAACC;SACtB;QACD,IAAI,CAACxD,mBAAmB,EAAE;QAE1B;QACA,IAAI,CAACC,cAAc,CAAC5C,IAAI,CAAC+F,OAAO,CAAC;QAEjC;QACA,IAAI,CAACK,UAAU,GAAG,IAAI;QACtB,IAAI,CAACC,gBAAgB,GAAG,IAAI;QAC5B,IAAI,CAACC,UAAU,GAAG,CAAC;QACnB;OACH,MAAM,IAAIlI,WAAW,CAACmI,gBAAgB,CAACvB,IAAI,CAACN,IAAI,CAAC,EAAE;QAChD;QACA,IAAI,CAACyB,oBAAoB,GAAGzB,IAAI,CAACuB,SAAS,CAAC,CAAC,CAAC,CAACtB,IAAI,EAAE;QAEpD;QAEA,IAAI,CAAC,IAAI,CAAC0B,gBAAgB,IAAI,CAAC,IAAI,CAACD,UAAU,EAAE;UAC5C;UACA,IAAI,CAACzD,mBAAmB,EAAE;UAC1B;UACA,MAAMoD,OAAO;UACT;UACA;YACIC,IAAI,EAAE,CAAC,IAAI,CAACQ,YAAY,IAAI,MAAM,IAAI,KAAK,GAAG,IAAI,CAACF,UAAU,CAACG,QAAQ,EAAE;YACxE1D,OAAO,EAAE1C,SAAS;YAClB4C,SAAS,EAAE5C,SAAS;YACpBtB,OAAO,EAAEsB,SAAS;YAClB6C,GAAG,EAAE7C,SAAS;YACd8C,MAAM,EAAE9C,SAAS;YACjB6F,YAAY,EAAE,IAAI,CAACC;WACtB;UACL,IAAI,CAACG,UAAU,EAAE;UACjB;UACA,IAAI,CAAC1D,cAAc,CAAC5C,IAAI,CAAC+F,OAAO,CAAC;UACjC,IAAI,CAACK,UAAU,GAAG,IAAI;;QAE1B;QAEA,IAAI,IAAI,CAACA,UAAU,IAAI,IAAI,CAACC,gBAAgB,EAAE;UAC1C;UACA,IAAI,CAACzD,cAAc,CAAC,IAAI,CAACA,cAAc,CAAC1C,MAAM,GAAG,CAAC,CAAC,CAACgG,YAAY,GAAG,IAAI,CAACC,oBAAoB;UAC5F,IAAI,CAACE,gBAAgB,GAAG,KAAK;;QAEjC;OACH,MAAM,IAAIjI,WAAW,CAACsI,qBAAqB,CAAC1B,IAAI,CAACN,IAAI,CAAC,EAAE;QACrD;QACAF,iBAAiB,CAACE,IAAI,CAACuB,SAAS,CAAC,CAAC,CAAC,CAACtB,IAAI,EAAE,CAAC;QAE3C;OACH,MAAM,IAAIvG,WAAW,CAACuI,gBAAgB,CAAC3B,IAAI,CAACN,IAAI,CAAC,EAAE;QAChD;QACA;QACA;MAAA,CACH,MAAM;QACH;QACAkC,OAAO,CAACC,GAAG,CAAC,iCAAiC,GAAGnC,IAAI,CAAC;;;IAI7D;IACA,IAAI,IAAI,CAAC0B,UAAU,EAAE;MACjB;MACA,IAAI,CAACvD,YAAY,GAAG,IAAI,CAACD,cAAc,CAAC,IAAI,CAACA,cAAc,CAAC1C,MAAM,GAAG,CAAC,CAAC;MAEvE;MACA,IAAI,CAACH,kBAAkB,CAAC+C,OAAO,EAAE;MACjC;MACA,IAAI,CAACtC,WAAW,EAAE;MAClB;MACA,IAAI,CAACqC,YAAY,CAACE,OAAO,GAAG,IAAI,CAAChD,kBAAkB;MACnD,IAAI,CAAC8C,YAAY,CAACI,SAAS,GAAG,IAAI,CAACvC,6BAA6B;MAChE,IAAI,CAACmC,YAAY,CAAC9D,OAAO,GAAG,IAAI,CAAC+B,2BAA2B;MAC5D,IAAI,CAAC+B,YAAY,CAACK,GAAG,GAAG,IAAI,CAACnC,sBAAsB;MAEnD,IAAI,IAAI,CAACpC,eAAe,CAACqC,kBAAkB,EAAE;QACzC,IAAI,CAAC6B,YAAY,CAACM,MAAM,GAAG,IAAI,CAAClC,0BAA0B;;;IAIlE;IACA,IAAI,CAAC,IAAI,CAACmF,UAAU,EAAE;MAClB,IAAIU,WAAW,GAA+B,IAAI;MAClD,IAAI,IAAI,CAAC/G,kBAAkB,CAACG,MAAM,EAAE;QAChC;QACA,IAAI,CAACH,kBAAkB,CAAC+C,OAAO,EAAE;QACjC;QACA,IAAI,CAACtC,WAAW,EAAE;OACrB,MAAM;QACH;QACA,KAAK,MAAMuG,GAAG,IAAI,IAAI,CAAChF,UAAU,EAAE;UAC/B,IAAI,CAACrB,6BAA6B,CAACV,IAAI,CAAC+G,GAAG,CAACpG,CAAC,EAAEoG,GAAG,CAACnG,CAAC,EAAEmG,GAAG,CAAClG,CAAC,CAAC;;QAGhE,IAAI,IAAI,CAAC2B,QAAQ,CAACtC,MAAM,EAAE;UACtB,KAAK,MAAM2D,MAAM,IAAI,IAAI,CAACrB,QAAQ,EAAE;YAChC,IAAI,CAAC1B,2BAA2B,CAACd,IAAI,CAAC6D,MAAM,CAAClD,CAAC,EAAEkD,MAAM,CAACjD,CAAC,EAAEiD,MAAM,CAAChD,CAAC,CAAC;;;QAI3E,IAAI,IAAI,CAACyB,IAAI,CAACpC,MAAM,EAAE;UAClB,KAAK,MAAMf,EAAE,IAAI,IAAI,CAACmD,IAAI,EAAE;YACxB,IAAI,CAACvB,sBAAsB,CAACf,IAAI,CAACb,EAAE,CAACwB,CAAC,EAAExB,EAAE,CAACyB,CAAC,CAAC;;;QAIpD,IAAI,IAAI,CAACsB,OAAO,CAAChC,MAAM,EAAE;UACrB,KAAK,MAAM8G,KAAK,IAAI,IAAI,CAAC9E,OAAO,EAAE;YAC9B,IAAI,CAACjB,0BAA0B,CAACjB,IAAI,CAACgH,KAAK,CAAC9F,CAAC,EAAE8F,KAAK,CAAC7F,CAAC,EAAE6F,KAAK,CAAC5F,CAAC,EAAE4F,KAAK,CAAC3F,CAAC,CAAC;;;QAIhF,IAAI,CAAC,IAAI,CAAC8E,oBAAoB,EAAE;UAC5B;UACAW,WAAW,GAAG,IAAIlJ,gBAAgB,CAACK,QAAQ,CAACgJ,QAAQ,EAAE,EAAE3C,KAAK,CAAC;UAE9DwC,WAAW,CAACI,WAAW,GAAG,IAAI;UAE9B,IAAI,CAACf,oBAAoB,GAAGW,WAAW,CAACd,IAAI;UAE5C,IAAI,CAAC,IAAI,CAACxD,QAAQ,CAACtC,MAAM,EAAE;YACvB4G,WAAW,CAACK,eAAe,GAAG,IAAI;YAClCL,WAAW,CAACM,aAAa,GAAGvJ,MAAM,CAACwJ,KAAK,EAAE;;;;MAKtD;MACA,IAAI,CAACzE,cAAc,CAAC5C,IAAI,CAAC;QACrBgG,IAAI,EAAE/H,QAAQ,CAACgJ,QAAQ,EAAE;QACzBlE,OAAO,EAAE,IAAI,CAAChD,kBAAkB;QAChCkD,SAAS,EAAE,IAAI,CAACvC,6BAA6B;QAC7CyC,MAAM,EAAE,IAAI,CAAClC,0BAA0B;QACvClC,OAAO,EAAE,IAAI,CAAC+B,2BAA2B;QACzCoC,GAAG,EAAE,IAAI,CAACnC,sBAAsB;QAChCmF,YAAY,EAAE,IAAI,CAACC,oBAAoB;QACvCmB,cAAc,EAAER;OACnB,CAAC;;IAGN;IACA,KAAK,IAAIS,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC3E,cAAc,CAAC1C,MAAM,EAAEqH,CAAC,EAAE,EAAE;MACjD;MACA,IAAInD,WAAW,IAAI,IAAI,CAACxB,cAAc,CAAC2E,CAAC,CAAC,CAACvB,IAAI,EAAE;QAC5C,IAAI5B,WAAW,YAAYoD,KAAK,EAAE;UAC9B,IAAIpD,WAAW,CAACnF,OAAO,CAAC,IAAI,CAAC2D,cAAc,CAAC2E,CAAC,CAAC,CAACvB,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACzD;;SAEP,MAAM;UACH,IAAI,IAAI,CAACpD,cAAc,CAAC2E,CAAC,CAAC,CAACvB,IAAI,KAAK5B,WAAW,EAAE;YAC7C;;;;MAKZ;MACA;MACA,IAAI,CAACvB,YAAY,GAAG,IAAI,CAACD,cAAc,CAAC2E,CAAC,CAAC;MAC1C;MAEAjD,KAAK,CAACmD,sBAAsB,GAAG,CAAC,CAAClD,cAAc;MAC/C,MAAMmD,WAAW,GAAG,IAAIxJ,IAAI,CAAC,IAAI,CAAC0E,cAAc,CAAC2E,CAAC,CAAC,CAACvB,IAAI,EAAE1B,KAAK,CAAC;MAChEoD,WAAW,CAACC,gBAAgB,GAAGpD,cAAc;MAC7CD,KAAK,CAACmD,sBAAsB,GAAG,KAAK;MAEpC;MACA;MACA,IAAI,CAAChJ,cAAc,CAACuB,IAAI,CAAC,IAAI,CAAC4C,cAAc,CAAC2E,CAAC,CAAC,CAACrB,YAAY,CAAC;MAE7D,IAAI,WAAI,CAACrD,YAAY,CAACI,SAAS,0CAAE/C,MAAM,MAAK,CAAC,EAAE;QAC3C;QACA,IAAI,CAACxB,mBAAmB,CAACsB,IAAI,CAAC0H,WAAW,CAAC;QAC1C;;MAGJ,MAAME,UAAU,GAAe,IAAIzJ,UAAU,EAAE,CAAC,CAAC;MACjD;MACAyJ,UAAU,CAAC1E,GAAG,GAAG,IAAI,CAACL,YAAY,CAACK,GAAiB;MACpD0E,UAAU,CAAC7E,OAAO,GAAG,IAAI,CAACF,YAAY,CAACE,OAAuB;MAC9D6E,UAAU,CAAC3E,SAAS,GAAG,IAAI,CAACJ,YAAY,CAACI,SAAuB;MAChE,IAAI,IAAI,CAACtE,eAAe,CAACkJ,cAAc,EAAE;QACrC,MAAM9I,OAAO,GAAkB,IAAIyI,KAAK,EAAU;QAClDrJ,UAAU,CAAC2J,cAAc,CAAC,IAAI,CAACjF,YAAY,CAACI,SAAS,EAAE,IAAI,CAACJ,YAAY,CAACE,OAAO,EAAEhE,OAAO,CAAC;QAC1F6I,UAAU,CAAC7I,OAAO,GAAGA,OAAO;OAC/B,MAAM;QACH6I,UAAU,CAAC7I,OAAO,GAAG,IAAI,CAAC8D,YAAY,CAAC9D,OAAqB;;MAEhE,IAAI,IAAI,CAACJ,eAAe,CAACqC,kBAAkB,EAAE;QACzC4G,UAAU,CAACzE,MAAM,GAAG,IAAI,CAACN,YAAY,CAACM,MAAoB;;MAE9D;MACAyE,UAAU,CAACG,WAAW,CAACL,WAAW,CAAC;MACnC,IAAI,IAAI,CAAC/I,eAAe,CAACqJ,OAAO,EAAE;QAC9BN,WAAW,CAACO,OAAO,CAACrH,CAAC,IAAI,CAAC,CAAC;;MAE/B,IAAI,IAAI,CAACjC,eAAe,CAACuJ,eAAe,EAAE;QACtC,IAAI,CAAC9E,gBAAgB,CAACsE,WAAW,CAAC;;MAGtC;MACA,IAAI,CAAChJ,mBAAmB,CAACsB,IAAI,CAAC0H,WAAW,CAAC;MAE1C,IAAI,IAAI,CAAC7E,YAAY,CAACyE,cAAc,EAAE;QAClCI,WAAW,CAACS,QAAQ,GAAG,IAAI,CAACtF,YAAY,CAACyE,cAAc;;;EAGnE;;AAxxBA;AACA;AACclJ,4BAAgB,GAAG,IAAI;AACrC;AACcA,2BAAe,GAAG,IAAI;AACpC;AACcA,iCAAqB,GAAG,UAAU;AAChD;AACcA,4BAAgB,GAAG,UAAU;AAC3C;AACcA,4BAAgB,GAAG,KAAK;AAEtC;AACA;AACcA,yBAAa,GAAG,6BAA6B;AAC3D;AACcA,yBAAa,GAAG,iEAAiE;AAC/F;AACcA,qBAAS,GAAG,6CAA6C;AACvE;AACcA,wBAAY,GAAG,4BAA4B;AACzD;AACcA,wBAAY,GAAG,wCAAwC;AACrE;AACcA,wBAAY,GAAG,kDAAkD;AAC/E;AACcA,wBAAY,GAAG,0CAA0C;AACvE;AACcA,wBAAY,GAAG,qDAAqD","names":["VertexBuffer","StandardMaterial","Color3","Color4","Vector2","Vector3","Geometry","Mesh","VertexData","SolidParser","constructor","materialToUse","babylonMeshesArray","loadingOptions","_materialToUse","_babylonMeshesArray","_loadingOptions","_isInArray","arr","obj","normals","idx","indexOf","_isInArrayUV","uv","_setData","indicePositionFromObj","indiceUvsFromObj","indiceNormalFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_index","optimizeWithUV","_tuplePosNorm","_indicesForBabylon","push","_wrappedPositionForBabylon","length","_wrappedUvsForBabylon","_wrappedNormalsForBabylon","undefined","_wrappedColorsForBabylon","_curPositionInIndices","_unwrapData","l","_unwrappedPositionsForBabylon","x","y","z","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","importVertexColors","_unwrappedColorsForBabylon","r","g","b","a","_getTriangles","faces","v","faceIndex","_triangles","_setDataForCurrentFaceWithPattern1","face","k","parseInt","_positions","Zero","Up","_colors","_setDataForCurrentFaceWithPattern2","point","split","_uvs","_setDataForCurrentFaceWithPattern3","_normals","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_meshesFromObj","_handledMesh","reverse","indices","slice","positions","uvs","colors","_optimizeNormals","mesh","getVerticesData","PositionKind","NormalKind","mapVertices","i","key","lst","normal","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","parse","meshesNames","data","scene","assetContainer","onFileToLoadFound","lines","line","trim","replace","result","charAt","VertexPattern","test","match","parseFloat","_grayColor","NormalPattern","exec","UVPattern","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","GroupDescriptor","ObjectDescriptor","objMesh","name","substring","materialName","_materialNameFromObj","_hasMeshes","_isFirstMaterial","_increment","UseMtlDescriptor","_objMeshName","toString","MtlLibGroupDescriptor","SmoothDescriptor","console","log","newMaterial","pos","color","RandomId","pointsCloud","disableLighting","emissiveColor","White","directMaterial","j","Array","_blockEntityCollection","babylonMesh","_parentContainer","vertexData","computeNormals","ComputeNormals","applyToMesh","invertY","scaling","optimizeNormals","material"],"sourceRoot":"","sources":["../../../../lts/loaders/generated/OBJ/solidParser.ts"],"sourcesContent":["import type { AssetContainer } from \"core/assetContainer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices?: Array<number>;\r\n    positions?: Array<number>;\r\n    normals?: Array<number>;\r\n    colors?: Array<number>;\r\n    uvs?: Array<number>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = []; //values for the positions of vertices\r\n    private _normals: Array<Vector3> = []; //Values for the normals\r\n    private _uvs: Array<Vector2> = []; //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _meshesFromObj: Array<MeshObject> = []; //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject; //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = []; //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = []; //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = []; //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = []; //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: Boolean = false; //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = []; //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\"; //The name of the current material\r\n    private _objMeshName: string = \"\"; //The name of the current obj mesh\r\n    private _increment: number = 1; //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param indicePositionFromObj Integer The index in positions array\r\n     * @param indiceUvsFromObj Integer The index in uvs array\r\n     * @param indiceNormalFromObj Integer The index in normals array\r\n     * @param positionVectorFromOBJ Vector3 The value of position at index objIndice\r\n     * @param textureVectorFromOBJ Vector3 The value of uvs\r\n     * @param normalsVectorFromOBJ Vector3 The value of normals at index objNormale\r\n     * @param positionColorsFromOBJ\r\n     */\r\n    private _setData(\r\n        indicePositionFromObj: number,\r\n        indiceUvsFromObj: number,\r\n        indiceNormalFromObj: number,\r\n        positionVectorFromOBJ: Vector3,\r\n        textureVectorFromOBJ: Vector2,\r\n        normalsVectorFromOBJ: Vector3,\r\n        positionColorsFromOBJ?: Color4\r\n    ) {\r\n        //Check if this tuple already exists in the list of tuples\r\n        let _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);\r\n        } else {\r\n            _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(positionVectorFromOBJ);\r\n            //Push the uvs for Babylon\r\n            //Each element is a Vector3(u,v)\r\n            this._wrappedUvsForBabylon.push(textureVectorFromOBJ);\r\n            //Push the normals for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);\r\n\r\n            if (positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);\r\n            this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) {\r\n                this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);\r\n            }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        //Every array has the same length\r\n        for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n            //Push the x, y, z values of each element in the unwrapped array\r\n            this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\r\n            this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\r\n            this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n            if (this._loadingOptions.importVertexColors) {\r\n                //Push the r, g, b, a values of each element in the unwrapped array\r\n                this._unwrappedColorsForBabylon.push(\r\n                    this._wrappedColorsForBabylon[l].r,\r\n                    this._wrappedColorsForBabylon[l].g,\r\n                    this._wrappedColorsForBabylon[l].b,\r\n                    this._wrappedColorsForBabylon[l].a\r\n                );\r\n            }\r\n        }\r\n        // Reset arrays for the next new meshes\r\n        this._wrappedPositionForBabylon.length = 0;\r\n        this._wrappedNormalsForBabylon.length = 0;\r\n        this._wrappedUvsForBabylon.length = 0;\r\n        this._wrappedColorsForBabylon.length = 0;\r\n        this._tuplePosNorm.length = 0;\r\n        this._curPositionInIndices = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param faces Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                0,\r\n                0, // In the pattern 1, normals and uvs are not defined\r\n                this._positions[indicePositionFromObj], // Get the vectors data\r\n                Vector2.Zero(),\r\n                Vector3.Up(), // Create default vectors\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvsu\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                0, //Default value for normals\r\n                this._positions[indicePositionFromObj], //Get the values for each element\r\n                this._uvs[indiceUvsFromObj],\r\n                Vector3.Up(), //Default value for normals\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj],\r\n                this._normals[indiceNormalFromObj] //Set the vector for each component\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                1, //Default value for uv\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj], //Get each vector of data\r\n                Vector2.Zero(),\r\n                this._normals[indiceNormalFromObj],\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData(\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                this._positions[indicePositionFromObj],\r\n                this._uvs[indiceUvsFromObj],\r\n                this._normals[indiceNormalFromObj], //Set the vector for each component\r\n                this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : undefined\r\n            );\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            // Reverse tab. Otherwise face are displayed in the wrong sens\r\n            this._indicesForBabylon.reverse();\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon.length = 0;\r\n            this._unwrappedPositionsForBabylon.length = 0;\r\n            this._unwrappedColorsForBabylon.length = 0;\r\n            this._unwrappedNormalsForBabylon.length = 0;\r\n            this._unwrappedUVForBabylon.length = 0;\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        // Split the file into lines\r\n        const lines = data.split(\"\\n\");\r\n        // Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            let result;\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n\r\n                //Get information about one position possible for the vertices\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                result = line.match(/[^ ]+/g)!; // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(\r\n                            new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7]))\r\n                        );\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analysed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                const objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: undefined,\r\n                    positions: undefined,\r\n                    normals: undefined,\r\n                    uvs: undefined,\r\n                    colors: undefined,\r\n                    materialName: this._materialNameFromObj,\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    const objMesh: MeshObject =\r\n                        //Set the name of the current obj mesh\r\n                        {\r\n                            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                            indices: undefined,\r\n                            positions: undefined,\r\n                            normals: undefined,\r\n                            uvs: undefined,\r\n                            colors: undefined,\r\n                            materialName: this._materialNameFromObj,\r\n                        };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                console.log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Reverse indices for displaying faces in the good sense\r\n            this._indicesForBabylon.reverse();\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n\r\n            if (this._loadingOptions.importVertexColors) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                // reverse tab of indices\r\n                this._indicesForBabylon.reverse();\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (const pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (const normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (const uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._colors.length) {\r\n                    for (const color of this._colors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial,\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            const vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.uvs = this._handledMesh.uvs as FloatArray;\r\n            vertexData.indices = this._handledMesh.indices as IndicesArray;\r\n            vertexData.positions = this._handledMesh.positions as FloatArray;\r\n            if (this._loadingOptions.computeNormals) {\r\n                const normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals as FloatArray;\r\n            }\r\n            if (this._loadingOptions.importVertexColors) {\r\n                vertexData.colors = this._handledMesh.colors as FloatArray;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}