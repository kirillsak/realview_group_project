{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer.js\";\nimport { serialize, SerializationHelper } from \"../Misc/decorators.js\";\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration.js\";\nimport \"../Shaders/screenSpaceReflection.fragment.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\n */\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\n  /**\n   * Creates a new instance of ScreenSpaceReflectionPostProcess.\n   * @param name The name of the effect.\n   * @param scene The scene containing the objects to calculate reflections.\n   * @param options The required width/height ratio to downsize to before computing the render pass.\n   * @param camera The camera to apply the render pass to.\n   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\n   * @param engine The engine which the post process will be applied. (default: current engine)\n   * @param reusable If the post process can be reused on the same frame. (default: false)\n   * @param textureType Type of textures used when performing the post process. (default: 0)\n   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\n   * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\n   */\n  constructor(name, scene, options, camera, samplingMode, engine, reusable, textureType = 0, blockCompilation = false, forceGeometryBuffer = false) {\n    super(name, \"screenSpaceReflection\", [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"], [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"], options, camera, samplingMode, engine, reusable, \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\", textureType, undefined, null, blockCompilation);\n    /**\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\n     */\n    this.threshold = 1.2;\n    /**\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\n     */\n    this.strength = 1;\n    /**\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\n     */\n    this.reflectionSpecularFalloffExponent = 3;\n    /**\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\n     */\n    this.step = 1.0;\n    /**\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\n     */\n    this.roughnessFactor = 0.2;\n    this._forceGeometryBuffer = false;\n    this._enableSmoothReflections = false;\n    this._reflectionSamples = 64;\n    this._smoothSteps = 5;\n    this._forceGeometryBuffer = forceGeometryBuffer;\n    if (this._forceGeometryBuffer) {\n      // Get geometry buffer renderer and update effect\n      const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\n      if (geometryBufferRenderer) {\n        if (geometryBufferRenderer.isSupported) {\n          geometryBufferRenderer.enablePosition = true;\n          geometryBufferRenderer.enableReflectivity = true;\n        }\n      }\n    } else {\n      const prePassRenderer = scene.enablePrePassRenderer();\n      prePassRenderer === null || prePassRenderer === void 0 ? void 0 : prePassRenderer.markAsDirty();\n      this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\n    }\n    this._updateEffectDefines();\n    // On apply, send uniforms\n    this.onApply = effect => {\n      const geometryBufferRenderer = this._geometryBufferRenderer;\n      const prePassRenderer = this._prePassRenderer;\n      if (!prePassRenderer && !geometryBufferRenderer) {\n        return;\n      }\n      if (geometryBufferRenderer) {\n        // Samplers\n        const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\n        effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\n        effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\n      } else if (prePassRenderer) {\n        // Samplers\n        const positionIndex = prePassRenderer.getIndex(1);\n        const roughnessIndex = prePassRenderer.getIndex(3);\n        const normalIndex = prePassRenderer.getIndex(6);\n        effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\n        effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\n        effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\n      }\n      // Uniforms\n      const camera = scene.activeCamera;\n      if (!camera) {\n        return;\n      }\n      const viewMatrix = camera.getViewMatrix(true);\n      const projectionMatrix = camera.getProjectionMatrix(true);\n      effect.setMatrix(\"projection\", projectionMatrix);\n      effect.setMatrix(\"view\", viewMatrix);\n      effect.setFloat(\"threshold\", this.threshold);\n      effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\n      effect.setFloat(\"strength\", this.strength);\n      effect.setFloat(\"stepSize\", this.step);\n      effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\n    };\n    this._isSceneRightHanded = scene.useRightHandedSystem;\n  }\n  get _geometryBufferRenderer() {\n    if (!this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.geometryBufferRenderer;\n  }\n  get _prePassRenderer() {\n    if (this._forceGeometryBuffer) {\n      return null;\n    }\n    return this._scene.prePassRenderer;\n  }\n  /**\n   * Gets a string identifying the name of the class\n   * @returns \"ScreenSpaceReflectionPostProcess\" string\n   */\n  getClassName() {\n    return \"ScreenSpaceReflectionPostProcess\";\n  }\n  /**\n   * Gets whether or not smoothing reflections is enabled.\n   * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n   */\n  get enableSmoothReflections() {\n    return this._enableSmoothReflections;\n  }\n  /**\n   * Sets whether or not smoothing reflections is enabled.\n   * Enabling smoothing will require more GPU power and can generate a drop in FPS.\n   */\n  set enableSmoothReflections(enabled) {\n    if (enabled === this._enableSmoothReflections) {\n      return;\n    }\n    this._enableSmoothReflections = enabled;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets the number of samples taken while computing reflections. More samples count is high,\n   * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n   */\n  get reflectionSamples() {\n    return this._reflectionSamples;\n  }\n  /**\n   * Sets the number of samples taken while computing reflections. More samples count is high,\n   * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\n   */\n  set reflectionSamples(samples) {\n    if (samples === this._reflectionSamples) {\n      return;\n    }\n    this._reflectionSamples = samples;\n    this._updateEffectDefines();\n  }\n  /**\n   * Gets the number of samples taken while smoothing reflections. More samples count is high,\n   * more the post-process will require GPU power and can generate a drop in FPS.\n   * Default value (5.0) work pretty well in all cases but can be adjusted.\n   */\n  get smoothSteps() {\n    return this._smoothSteps;\n  }\n  /*\n   * Sets the number of samples taken while smoothing reflections. More samples count is high,\n   * more the post-process will require GPU power and can generate a drop in FPS.\n   * Default value (5.0) work pretty well in all cases but can be adjusted.\n   */\n  set smoothSteps(steps) {\n    if (steps === this._smoothSteps) {\n      return;\n    }\n    this._smoothSteps = steps;\n    this._updateEffectDefines();\n  }\n  _updateEffectDefines() {\n    const defines = [];\n    if (this._geometryBufferRenderer || this._prePassRenderer) {\n      defines.push(\"#define SSR_SUPPORTED\");\n    }\n    if (this._enableSmoothReflections) {\n      defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\n    }\n    if (this._isSceneRightHanded) {\n      defines.push(\"#define RIGHT_HANDED_SCENE\");\n    }\n    defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\n    defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\n    this.updateEffect(defines.join(\"\\n\"));\n  }\n  /**\n   * @internal\n   */\n  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {\n    return SerializationHelper.Parse(() => {\n      return new ScreenSpaceReflectionPostProcess(parsedPostProcess.name, scene, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.textureType, parsedPostProcess.reusable);\n    }, parsedPostProcess, scene, rootUrl);\n  }\n}\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"threshold\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"strength\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSpecularFalloffExponent\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"step\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"roughnessFactor\", void 0);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"enableSmoothReflections\", null);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"reflectionSamples\", null);\n__decorate([serialize()], ScreenSpaceReflectionPostProcess.prototype, \"smoothSteps\", null);\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);","map":{"version":3,"mappings":"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","names":["PostProcess","GeometryBufferRenderer","serialize","SerializationHelper","ScreenSpaceReflectionsConfiguration","RegisterClass","ScreenSpaceReflectionPostProcess","constructor","name","scene","options","camera","samplingMode","engine","reusable","textureType","undefined","blockCompilation","_forceGeometryBuffer","forceGeometryBuffer","geometryBufferRenderer","enableGeometryBufferRenderer","isSupported","enablePosition","enableReflectivity","prePassRenderer","enablePrePassRenderer","markAsDirty","_prePassEffectConfiguration","_updateEffectDefines","onApply","effect","_geometryBufferRenderer","_prePassRenderer","positionIndex","getTextureIndex","POSITION_TEXTURE_TYPE","roughnessIndex","REFLECTIVITY_TEXTURE_TYPE","setTexture","getGBuffer","textures","getIndex","normalIndex","getRenderTarget","activeCamera","viewMatrix","getViewMatrix","projectionMatrix","getProjectionMatrix","setMatrix","setFloat","threshold","reflectionSpecularFalloffExponent","strength","step","roughnessFactor","_isSceneRightHanded","useRightHandedSystem","_scene","getClassName","enableSmoothReflections","_enableSmoothReflections","enabled","reflectionSamples","_reflectionSamples","samples","smoothSteps","_smoothSteps","steps","defines","push","updateEffect","join","_Parse","parsedPostProcess","targetCamera","rootUrl","Parse","renderTargetSamplingMode","getEngine","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/screenSpaceReflectionPostProcess.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\r\nimport { serialize, SerializationHelper } from \"../Misc/decorators\";\r\nimport type { PrePassRenderer } from \"../Rendering/prePassRenderer\";\r\nimport { ScreenSpaceReflectionsConfiguration } from \"../Rendering/screenSpaceReflectionsConfiguration\";\r\n\r\nimport \"../Shaders/screenSpaceReflection.fragment\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * The ScreenSpaceReflectionPostProcess performs realtime reflections using only and only the available informations on the screen (positions and normals).\r\n * Basically, the screen space reflection post-process will compute reflections according the material's reflectivity.\r\n */\r\nexport class ScreenSpaceReflectionPostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets a reflection threshold mainly used to adjust the reflection's height.\r\n     */\r\n    @serialize()\r\n    public threshold: number = 1.2;\r\n    /**\r\n     * Gets or sets the current reflection strength. 1.0 is an ideal value but can be increased/decreased for particular results.\r\n     */\r\n    @serialize()\r\n    public strength: number = 1;\r\n    /**\r\n     * Gets or sets the falloff exponent used while computing fresnel. More the exponent is high, more the reflections will be discrete.\r\n     */\r\n    @serialize()\r\n    public reflectionSpecularFalloffExponent: number = 3;\r\n    /**\r\n     * Gets or sets the step size used to iterate until the effect finds the color of the reflection's pixel. Typically in interval [0.1, 1.0]\r\n     */\r\n    @serialize()\r\n    public step: number = 1.0;\r\n    /**\r\n     * Gets or sets the factor applied when computing roughness. Default value is 0.2.\r\n     */\r\n    @serialize()\r\n    public roughnessFactor: number = 0.2;\r\n\r\n    private _forceGeometryBuffer: boolean = false;\r\n    private get _geometryBufferRenderer(): Nullable<GeometryBufferRenderer> {\r\n        if (!this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.geometryBufferRenderer;\r\n    }\r\n\r\n    private get _prePassRenderer(): Nullable<PrePassRenderer> {\r\n        if (this._forceGeometryBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.prePassRenderer;\r\n    }\r\n\r\n    private _enableSmoothReflections: boolean = false;\r\n    private _reflectionSamples: number = 64;\r\n    private _smoothSteps: number = 5;\r\n    private _isSceneRightHanded: boolean;\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"ScreenSpaceReflectionPostProcess\" string\r\n     */\r\n    public getClassName(): string {\r\n        return \"ScreenSpaceReflectionPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of ScreenSpaceReflectionPostProcess.\r\n     * @param name The name of the effect.\r\n     * @param scene The scene containing the objects to calculate reflections.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType Type of textures used when performing the post process. (default: 0)\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: true)\r\n     * @param forceGeometryBuffer If this post process should use geometry buffer instead of prepass (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera>,\r\n        samplingMode?: number,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        blockCompilation = false,\r\n        forceGeometryBuffer = false\r\n    ) {\r\n        super(\r\n            name,\r\n            \"screenSpaceReflection\",\r\n            [\"projection\", \"view\", \"threshold\", \"reflectionSpecularFalloffExponent\", \"strength\", \"stepSize\", \"roughnessFactor\"],\r\n            [\"textureSampler\", \"normalSampler\", \"positionSampler\", \"reflectivitySampler\"],\r\n            options,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define SSR_SUPPORTED\\n#define REFLECTION_SAMPLES 64\\n#define SMOOTH_STEPS 5\\n\",\r\n            textureType,\r\n            undefined,\r\n            null,\r\n            blockCompilation\r\n        );\r\n\r\n        this._forceGeometryBuffer = forceGeometryBuffer;\r\n\r\n        if (this._forceGeometryBuffer) {\r\n            // Get geometry buffer renderer and update effect\r\n            const geometryBufferRenderer = scene.enableGeometryBufferRenderer();\r\n            if (geometryBufferRenderer) {\r\n                if (geometryBufferRenderer.isSupported) {\r\n                    geometryBufferRenderer.enablePosition = true;\r\n                    geometryBufferRenderer.enableReflectivity = true;\r\n                }\r\n            }\r\n        } else {\r\n            const prePassRenderer = scene.enablePrePassRenderer();\r\n            prePassRenderer?.markAsDirty();\r\n            this._prePassEffectConfiguration = new ScreenSpaceReflectionsConfiguration();\r\n        }\r\n\r\n        this._updateEffectDefines();\r\n\r\n        // On apply, send uniforms\r\n        this.onApply = (effect: Effect) => {\r\n            const geometryBufferRenderer = this._geometryBufferRenderer;\r\n            const prePassRenderer = this._prePassRenderer;\r\n\r\n            if (!prePassRenderer && !geometryBufferRenderer) {\r\n                return;\r\n            }\r\n\r\n            if (geometryBufferRenderer) {\r\n                // Samplers\r\n                const positionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", geometryBufferRenderer.getGBuffer().textures[1]);\r\n                effect.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", geometryBufferRenderer.getGBuffer().textures[roughnessIndex]);\r\n            } else if (prePassRenderer) {\r\n                // Samplers\r\n                const positionIndex = prePassRenderer.getIndex(Constants.PREPASS_POSITION_TEXTURE_TYPE);\r\n                const roughnessIndex = prePassRenderer.getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE);\r\n                const normalIndex = prePassRenderer.getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE);\r\n\r\n                effect.setTexture(\"normalSampler\", prePassRenderer.getRenderTarget().textures[normalIndex]);\r\n                effect.setTexture(\"positionSampler\", prePassRenderer.getRenderTarget().textures[positionIndex]);\r\n                effect.setTexture(\"reflectivitySampler\", prePassRenderer.getRenderTarget().textures[roughnessIndex]);\r\n            }\r\n\r\n            // Uniforms\r\n            const camera = scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n\r\n            const viewMatrix = camera.getViewMatrix(true);\r\n            const projectionMatrix = camera.getProjectionMatrix(true);\r\n\r\n            effect.setMatrix(\"projection\", projectionMatrix);\r\n            effect.setMatrix(\"view\", viewMatrix);\r\n            effect.setFloat(\"threshold\", this.threshold);\r\n            effect.setFloat(\"reflectionSpecularFalloffExponent\", this.reflectionSpecularFalloffExponent);\r\n            effect.setFloat(\"strength\", this.strength);\r\n            effect.setFloat(\"stepSize\", this.step);\r\n            effect.setFloat(\"roughnessFactor\", this.roughnessFactor);\r\n        };\r\n\r\n        this._isSceneRightHanded = scene.useRightHandedSystem;\r\n    }\r\n\r\n    /**\r\n     * Gets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    @serialize()\r\n    public get enableSmoothReflections(): boolean {\r\n        return this._enableSmoothReflections;\r\n    }\r\n\r\n    /**\r\n     * Sets whether or not smoothing reflections is enabled.\r\n     * Enabling smoothing will require more GPU power and can generate a drop in FPS.\r\n     */\r\n    public set enableSmoothReflections(enabled: boolean) {\r\n        if (enabled === this._enableSmoothReflections) {\r\n            return;\r\n        }\r\n\r\n        this._enableSmoothReflections = enabled;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    @serialize()\r\n    public get reflectionSamples(): number {\r\n        return this._reflectionSamples;\r\n    }\r\n\r\n    /**\r\n     * Sets the number of samples taken while computing reflections. More samples count is high,\r\n     * more the post-process wil require GPU power and can generate a drop in FPS. Basically in interval [25, 100].\r\n     */\r\n    public set reflectionSamples(samples: number) {\r\n        if (samples === this._reflectionSamples) {\r\n            return;\r\n        }\r\n\r\n        this._reflectionSamples = samples;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    /**\r\n     * Gets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    @serialize()\r\n    public get smoothSteps(): number {\r\n        return this._smoothSteps;\r\n    }\r\n\r\n    /*\r\n     * Sets the number of samples taken while smoothing reflections. More samples count is high,\r\n     * more the post-process will require GPU power and can generate a drop in FPS.\r\n     * Default value (5.0) work pretty well in all cases but can be adjusted.\r\n     */\r\n    public set smoothSteps(steps: number) {\r\n        if (steps === this._smoothSteps) {\r\n            return;\r\n        }\r\n\r\n        this._smoothSteps = steps;\r\n        this._updateEffectDefines();\r\n    }\r\n\r\n    private _updateEffectDefines(): void {\r\n        const defines: string[] = [];\r\n        if (this._geometryBufferRenderer || this._prePassRenderer) {\r\n            defines.push(\"#define SSR_SUPPORTED\");\r\n        }\r\n        if (this._enableSmoothReflections) {\r\n            defines.push(\"#define ENABLE_SMOOTH_REFLECTIONS\");\r\n        }\r\n        if (this._isSceneRightHanded) {\r\n            defines.push(\"#define RIGHT_HANDED_SCENE\");\r\n        }\r\n\r\n        defines.push(\"#define REFLECTION_SAMPLES \" + (this._reflectionSamples >> 0));\r\n        defines.push(\"#define SMOOTH_STEPS \" + (this._smoothSteps >> 0));\r\n\r\n        this.updateEffect(defines.join(\"\\n\"));\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new ScreenSpaceReflectionPostProcess(\r\n                    parsedPostProcess.name,\r\n                    scene,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    scene.getEngine(),\r\n                    parsedPostProcess.textureType,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ScreenSpaceReflectionPostProcess\", ScreenSpaceReflectionPostProcess);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}