{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsVector3 } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager.js\";\nimport { Tools } from \"../Misc/tools.js\";\n/**\n * This is a flying camera, designed for 3D movement and rotation in all directions,\n * such as in a 3D Space Shooter or a Flight Simulator.\n */\nexport class FlyCamera extends TargetCamera {\n  /**\n   * Instantiates a FlyCamera.\n   * This is a flying camera, designed for 3D movement and rotation in all directions,\n   * such as in a 3D Space Shooter or a Flight Simulator.\n   * @param name Define the name of the camera in the scene.\n   * @param position Define the starting position of the camera in the scene.\n   * @param scene Define the scene the camera belongs to.\n   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active, if no other camera has been defined as active.\n   */\n  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {\n    super(name, position, scene, setActiveOnSceneIfNoneActive);\n    /**\n     * Define the collision ellipsoid of the camera.\n     * This is helpful for simulating a camera body, like a player's body.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\n     */\n    this.ellipsoid = new Vector3(1, 1, 1);\n    /**\n     * Define an offset for the position of the ellipsoid around the camera.\n     * This can be helpful if the camera is attached away from the player's body center,\n     * such as at its head.\n     */\n    this.ellipsoidOffset = new Vector3(0, 0, 0);\n    /**\n     * Enable or disable collisions of the camera with the rest of the scene objects.\n     */\n    this.checkCollisions = false;\n    /**\n     * Enable or disable gravity on the camera.\n     */\n    this.applyGravity = false;\n    /**\n     * Define the current direction the camera is moving to.\n     */\n    this.cameraDirection = Vector3.Zero();\n    /**\n     * Track Roll to maintain the wanted Rolling when looking around.\n     */\n    this._trackRoll = 0;\n    /**\n     * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\n     */\n    this.rollCorrect = 100;\n    /**\n     * Mimic a banked turn, Rolling the camera when Yawing.\n     * It's recommended to use rollCorrect = 10 for faster banking correction.\n     */\n    this.bankedTurn = false;\n    /**\n     * Limit in radians for how much Roll banking will add. (Default: 90Â°)\n     */\n    this.bankedTurnLimit = Math.PI / 2;\n    /**\n     * Value of 0 disables the banked Roll.\n     * Value of 1 is equal to the Yaw angle in radians.\n     */\n    this.bankedTurnMultiplier = 1;\n    this._needMoveForGravity = false;\n    this._oldPosition = Vector3.Zero();\n    this._diffPosition = Vector3.Zero();\n    this._newPosition = Vector3.Zero();\n    // Collisions.\n    this._collisionMask = -1;\n    /**\n     * @internal\n     */\n    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {\n      const updatePosition = newPos => {\n        this._newPosition.copyFrom(newPos);\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\n          this.position.addInPlace(this._diffPosition);\n          if (this.onCollide && collidedMesh) {\n            this.onCollide(collidedMesh);\n          }\n        }\n      };\n      updatePosition(newPosition);\n    };\n    this.inputs = new FlyCameraInputsManager(this);\n    this.inputs.addKeyboard().addMouse();\n  }\n  /**\n   * Gets the input sensibility for mouse input.\n   * Higher values reduce sensitivity.\n   */\n  get angularSensibility() {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      return mouse.angularSensibility;\n    }\n    return 0;\n  }\n  /**\n   * Sets the input sensibility for a mouse input.\n   * Higher values reduce sensitivity.\n   */\n  set angularSensibility(value) {\n    const mouse = this.inputs.attached[\"mouse\"];\n    if (mouse) {\n      mouse.angularSensibility = value;\n    }\n  }\n  /**\n   * Get the keys for camera movement forward.\n   */\n  get keysForward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysForward;\n    }\n    return [];\n  }\n  /**\n   * Set the keys for camera movement forward.\n   */\n  set keysForward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysForward = value;\n    }\n  }\n  /**\n   * Get the keys for camera movement backward.\n   */\n  get keysBackward() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysBackward;\n    }\n    return [];\n  }\n  set keysBackward(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysBackward = value;\n    }\n  }\n  /**\n   * Get the keys for camera movement up.\n   */\n  get keysUp() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysUp;\n    }\n    return [];\n  }\n  /**\n   * Set the keys for camera movement up.\n   */\n  set keysUp(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysUp = value;\n    }\n  }\n  /**\n   * Get the keys for camera movement down.\n   */\n  get keysDown() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysDown;\n    }\n    return [];\n  }\n  /**\n   * Set the keys for camera movement down.\n   */\n  set keysDown(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysDown = value;\n    }\n  }\n  /**\n   * Get the keys for camera movement left.\n   */\n  get keysLeft() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysLeft;\n    }\n    return [];\n  }\n  /**\n   * Set the keys for camera movement left.\n   */\n  set keysLeft(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysLeft = value;\n    }\n  }\n  /**\n   * Set the keys for camera movement right.\n   */\n  get keysRight() {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      return keyboard.keysRight;\n    }\n    return [];\n  }\n  /**\n   * Set the keys for camera movement right.\n   */\n  set keysRight(value) {\n    const keyboard = this.inputs.attached[\"keyboard\"];\n    if (keyboard) {\n      keyboard.keysRight = value;\n    }\n  }\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n  }\n  /**\n   * Detach a control from the HTML DOM element.\n   * The camera will stop reacting to that input.\n   */\n  detachControl() {\n    this.inputs.detachElement();\n    this.cameraDirection = new Vector3(0, 0, 0);\n  }\n  /**\n   * Get the mask that the camera ignores in collision events.\n   */\n  get collisionMask() {\n    return this._collisionMask;\n  }\n  /**\n   * Set the mask that the camera ignores in collision events.\n   */\n  set collisionMask(mask) {\n    this._collisionMask = !isNaN(mask) ? mask : -1;\n  }\n  /**\n   * @internal\n   */\n  _collideWithWorld(displacement) {\n    let globalPosition;\n    if (this.parent) {\n      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n    } else {\n      globalPosition = this.position;\n    }\n    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n    this._oldPosition.addInPlace(this.ellipsoidOffset);\n    const coordinator = this.getScene().collisionCoordinator;\n    if (!this._collider) {\n      this._collider = coordinator.createCollider();\n    }\n    this._collider._radius = this.ellipsoid;\n    this._collider.collisionMask = this._collisionMask;\n    // No need for clone, as long as gravity is not on.\n    let actualDisplacement = displacement;\n    // Add gravity to direction to prevent dual-collision checking.\n    if (this.applyGravity) {\n      // This prevents mending with cameraDirection, a global variable of the fly camera class.\n      actualDisplacement = displacement.add(this.getScene().gravity);\n    }\n    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n  }\n  /** @internal */\n  _checkInputs() {\n    if (!this._localDirection) {\n      this._localDirection = Vector3.Zero();\n      this._transformedDirection = Vector3.Zero();\n    }\n    this.inputs.checkInputs();\n    super._checkInputs();\n  }\n  /** @internal */\n  _decideIfNeedsToMove() {\n    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n  }\n  /** @internal */\n  _updatePosition() {\n    if (this.checkCollisions && this.getScene().collisionsEnabled) {\n      this._collideWithWorld(this.cameraDirection);\n    } else {\n      super._updatePosition();\n    }\n  }\n  /**\n   * Restore the Roll to its target value at the rate specified.\n   * @param rate - Higher means slower restoring.\n   * @internal\n   */\n  restoreRoll(rate) {\n    const limit = this._trackRoll; // Target Roll.\n    const z = this.rotation.z; // Current Roll.\n    const delta = limit - z; // Difference in Roll.\n    const minRad = 0.001; // Tenth of a radian is a barely noticable difference.\n    // If the difference is noticable, restore the Roll.\n    if (Math.abs(delta) >= minRad) {\n      // Change Z rotation towards the target Roll.\n      this.rotation.z += delta / rate;\n      // Match when near enough.\n      if (Math.abs(limit - this.rotation.z) <= minRad) {\n        this.rotation.z = limit;\n      }\n    }\n  }\n  /**\n   * Destroy the camera and release the current resources held by it.\n   */\n  dispose() {\n    this.inputs.clear();\n    super.dispose();\n  }\n  /**\n   * Get the current object class name.\n   * @returns the class name.\n   */\n  getClassName() {\n    return \"FlyCamera\";\n  }\n}\n__decorate([serializeAsVector3()], FlyCamera.prototype, \"ellipsoid\", void 0);\n__decorate([serializeAsVector3()], FlyCamera.prototype, \"ellipsoidOffset\", void 0);\n__decorate([serialize()], FlyCamera.prototype, \"checkCollisions\", void 0);\n__decorate([serialize()], FlyCamera.prototype, \"applyGravity\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","serializeAsVector3","Vector3","Engine","TargetCamera","FlyCameraInputsManager","Tools","FlyCamera","constructor","name","position","scene","setActiveOnSceneIfNoneActive","Zero","Math","PI","collisionId","newPosition","collidedMesh","updatePosition","newPos","_newPosition","copyFrom","subtractToRef","_oldPosition","_diffPosition","length","CollisionsEpsilon","addInPlace","onCollide","inputs","addKeyboard","addMouse","angularSensibility","mouse","attached","value","keysForward","keyboard","keysBackward","keysUp","keysDown","keysLeft","keysRight","attachControl","ignored","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","attachElement","detachControl","detachElement","cameraDirection","collisionMask","_collisionMask","mask","isNaN","_collideWithWorld","displacement","globalPosition","parent","TransformCoordinates","getWorldMatrix","subtractFromFloatsToRef","ellipsoid","y","ellipsoidOffset","coordinator","getScene","collisionCoordinator","_collider","createCollider","_radius","actualDisplacement","applyGravity","add","gravity","getNewPosition","_onCollisionPositionChange","uniqueId","_checkInputs","_localDirection","_transformedDirection","checkInputs","_decideIfNeedsToMove","_needMoveForGravity","abs","x","z","_updatePosition","checkCollisions","collisionsEnabled","restoreRoll","rate","limit","_trackRoll","rotation","delta","minRad","dispose","clear","getClassName","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Cameras/flyCamera.ts"],"sourcesContent":["import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Quaternion } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FlyCameraInputsManager } from \"./flyCameraInputsManager\";\r\nimport type { FlyCameraMouseInput } from \"../Cameras/Inputs/flyCameraMouseInput\";\r\nimport type { FlyCameraKeyboardInput } from \"../Cameras/Inputs/flyCameraKeyboardInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\n/**\r\n * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n * such as in a 3D Space Shooter or a Flight Simulator.\r\n */\r\nexport class FlyCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful for simulating a camera body, like a player's body.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful if the camera is attached away from the player's body center,\r\n     * such as at its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to.\r\n     */\r\n    public cameraDirection = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current local rotation of the camera as a quaternion to prevent Gimbal lock.\r\n     * This overrides and empties cameraRotation.\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Track Roll to maintain the wanted Rolling when looking around.\r\n     */\r\n    public _trackRoll: number = 0;\r\n\r\n    /**\r\n     * Slowly correct the Roll to its original value after a Pitch+Yaw rotation.\r\n     */\r\n    public rollCorrect: number = 100;\r\n\r\n    /**\r\n     * Mimic a banked turn, Rolling the camera when Yawing.\r\n     * It's recommended to use rollCorrect = 10 for faster banking correction.\r\n     */\r\n    public bankedTurn: boolean = false;\r\n\r\n    /**\r\n     * Limit in radians for how much Roll banking will add. (Default: 90Â°)\r\n     */\r\n    public bankedTurnLimit: number = Math.PI / 2;\r\n\r\n    /**\r\n     * Value of 0 disables the banked Roll.\r\n     * Value of 1 is equal to the Yaw angle in radians.\r\n     */\r\n    public bankedTurnMultiplier: number = 1;\r\n\r\n    /**\r\n     * The inputs manager loads all the input sources, such as keyboard and mouse.\r\n     */\r\n    public inputs: FlyCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FlyCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input.\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FlyCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement forward.\r\n     */\r\n    public get keysForward(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysForward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement forward.\r\n     */\r\n    public set keysForward(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysForward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement backward.\r\n     */\r\n    public get keysBackward(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysBackward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysBackward(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysBackward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement up.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement up.\r\n     */\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement down.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement down.\r\n     */\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the keys for camera movement left.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement left.\r\n     */\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Set the keys for camera movement right.\r\n     */\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FlyCameraKeyboardInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collides with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a FlyCamera.\r\n     * This is a flying camera, designed for 3D movement and rotation in all directions,\r\n     * such as in a 3D Space Shooter or a Flight Simulator.\r\n     * @param name Define the name of the camera in the scene.\r\n     * @param position Define the starting position of the camera in the scene.\r\n     * @param scene Define the scene the camera belongs to.\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active, if no other camera has been defined as active.\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FlyCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach a control from the HTML DOM element.\r\n     * The camera will stop reacting to that input.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n    }\r\n\r\n    // Collisions.\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Get the mask that the camera ignores in collision events.\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    /**\r\n     * Set the mask that the camera ignores in collision events.\r\n     */\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        // No need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        // Add gravity to direction to prevent dual-collision checking.\r\n        if (this.applyGravity) {\r\n            // This prevents mending with cameraDirection, a global variable of the fly camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        const updatePosition = (newPos: Vector3) => {\r\n            this._newPosition.copyFrom(newPos);\r\n\r\n            this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n            if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n                this.position.addInPlace(this._diffPosition);\r\n                if (this.onCollide && collidedMesh) {\r\n                    this.onCollide(collidedMesh);\r\n                }\r\n            }\r\n        };\r\n\r\n        updatePosition(newPosition);\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore the Roll to its target value at the rate specified.\r\n     * @param rate - Higher means slower restoring.\r\n     * @internal\r\n     */\r\n    public restoreRoll(rate: number): void {\r\n        const limit = this._trackRoll; // Target Roll.\r\n        const z = this.rotation.z; // Current Roll.\r\n        const delta = limit - z; // Difference in Roll.\r\n\r\n        const minRad = 0.001; // Tenth of a radian is a barely noticable difference.\r\n\r\n        // If the difference is noticable, restore the Roll.\r\n        if (Math.abs(delta) >= minRad) {\r\n            // Change Z rotation towards the target Roll.\r\n            this.rotation.z += delta / rate;\r\n\r\n            // Match when near enough.\r\n            if (Math.abs(limit - this.rotation.z) <= minRad) {\r\n                this.rotation.z = limit;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources held by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Get the current object class name.\r\n     * @returns the class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FlyCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}