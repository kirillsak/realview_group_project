{"ast":null,"code":"import \"core-js/modules/es.array.unshift.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { Vector4 } from \"../../Maths/math.vector.js\";\nimport { Color4 } from \"../../Maths/math.color.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\n/**\n * Creates the VertexData for a box\n * @param options an object used to set the following optional parameters for the box, required but can be empty\n * * size sets the width, height and depth of the box to the value of size, optional default 1\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @returns the VertexData of the box\n */\nexport function CreateBoxVertexData(options) {\n  const nbFaces = 6;\n  let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\n  const normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\n  const uvs = [];\n  let positions = [];\n  const width = options.width || options.size || 1;\n  const height = options.height || options.size || 1;\n  const depth = options.depth || options.size || 1;\n  const wrap = options.wrap || false;\n  let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\n  let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\n  topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\n  bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\n  const topOrder = [2, 0, 3, 1];\n  const bottomOrder = [2, 0, 1, 3];\n  let topIndex = topOrder[topBaseAt];\n  let bottomIndex = bottomOrder[bottomBaseAt];\n  let basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\n  if (wrap) {\n    indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\n    basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\n    let topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\n    let bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\n    const topFaceOrder = [17, 18, 19, 16];\n    const bottomFaceOrder = [22, 23, 20, 21];\n    while (topIndex > 0) {\n      topFaceBase.unshift(topFaceBase.pop());\n      topFaceOrder.unshift(topFaceOrder.pop());\n      topIndex--;\n    }\n    while (bottomIndex > 0) {\n      bottomFaceBase.unshift(bottomFaceBase.pop());\n      bottomFaceOrder.unshift(bottomFaceOrder.pop());\n      bottomIndex--;\n    }\n    topFaceBase = topFaceBase.flat();\n    bottomFaceBase = bottomFaceBase.flat();\n    basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\n    indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\n    indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\n  }\n  const scaleArray = [width / 2, height / 2, depth / 2];\n  positions = basePositions.reduce((accumulator, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\n  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\n  const faceUV = options.faceUV || new Array(6);\n  const faceColors = options.faceColors;\n  const colors = [];\n  // default face colors and UV if undefined\n  for (let f = 0; f < 6; f++) {\n    if (faceUV[f] === undefined) {\n      faceUV[f] = new Vector4(0, 0, 1, 1);\n    }\n    if (faceColors && faceColors[f] === undefined) {\n      faceColors[f] = new Color4(1, 1, 1, 1);\n    }\n  }\n  // Create each face in turn.\n  for (let index = 0; index < nbFaces; index++) {\n    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\n    uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n    uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\n    if (faceColors) {\n      for (let c = 0; c < 4; c++) {\n        colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n      }\n    }\n  }\n  // sides\n  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n  // Result\n  const vertexData = new VertexData();\n  vertexData.indices = indices;\n  vertexData.positions = positions;\n  vertexData.normals = normals;\n  vertexData.uvs = uvs;\n  if (faceColors) {\n    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\n    vertexData.colors = totalColors;\n  }\n  return vertexData;\n}\n/**\n * Creates a box mesh\n * * The parameter `size` sets the size (float) of each box side (default 1)\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.size\n * @param options.width\n * @param options.height\n * @param options.depth\n * @param options.faceUV\n * @param options.faceColors\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.wrap\n * @param options.topBaseAt\n * @param options.bottomBaseAt\n * @param options.updatable\n * @param scene defines the hosting scene\n * @returns the box mesh\n */\nexport function CreateBox(name, options = {}, scene = null) {\n  const box = new Mesh(name, scene);\n  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  box._originalBuilderSideOrientation = options.sideOrientation;\n  const vertexData = CreateBoxVertexData(options);\n  vertexData.applyToMesh(box, options.updatable);\n  return box;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated please use CreateBox directly\n */\nexport const BoxBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateBox\n};\n// Side effects\nVertexData.CreateBox = CreateBoxVertexData;\nMesh.CreateBox = (name, size, scene = null, updatable, sideOrientation) => {\n  const options = {\n    size,\n    sideOrientation,\n    updatable\n  };\n  return CreateBox(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector4","Color4","Mesh","VertexData","CompatibilityOptions","CreateBoxVertexData","options","nbFaces","indices","normals","uvs","positions","width","size","height","depth","wrap","topBaseAt","bottomBaseAt","topOrder","bottomOrder","topIndex","bottomIndex","basePositions","topFaceBase","bottomFaceBase","topFaceOrder","bottomFaceOrder","unshift","pop","flat","concat","push","scaleArray","reduce","accumulator","currentValue","currentIndex","sideOrientation","DEFAULTSIDE","faceUV","Array","faceColors","colors","f","undefined","index","z","UseOpenGLOrientationForUV","w","x","y","c","r","g","b","a","_ComputeSides","frontUVs","backUVs","vertexData","totalColors","DOUBLESIDE","CreateBox","name","scene","box","_GetDefaultSideOrientation","_originalBuilderSideOrientation","applyToMesh","updatable","BoxBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/boxBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.size\r\n * @param options.width\r\n * @param options.height\r\n * @param options.depth\r\n * @param options.faceUV\r\n * @param options.faceColors\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.wrap\r\n * @param options.topBaseAt\r\n * @param options.bottomBaseAt\r\n * @param options.updatable\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\n(Mesh as any).CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}