{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../tslib.es6.js\";\n/* eslint-disable @typescript-eslint/naming-convention */\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { MaterialFlags } from \"../../Materials/materialFlags.js\";\nimport { MaterialHelper } from \"../../Materials/materialHelper.js\";\nimport { MaterialPluginBase } from \"../materialPluginBase.js\";\nimport { MaterialDefines } from \"../materialDefines.js\";\n/**\n * @internal\n */\nexport class MaterialAnisotropicDefines extends MaterialDefines {\n  constructor() {\n    super(...arguments);\n    this.ANISOTROPIC = false;\n    this.ANISOTROPIC_TEXTURE = false;\n    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n    this.MAINUV1 = false;\n  }\n}\n/**\n * Plugin that implements the anisotropic component of the PBR material\n */\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\n  constructor(material, addToPluginList = true) {\n    super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\n    this._isEnabled = false;\n    /**\n     * Defines if the anisotropy is enabled in the material.\n     */\n    this.isEnabled = false;\n    /**\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\n     */\n    this.intensity = 1;\n    /**\n     * Defines if the effect is along the tangents, bitangents or in between.\n     * By default, the effect is \"stretching\" the highlights along the tangents.\n     */\n    this.direction = new Vector2(1, 0);\n    this._texture = null;\n    /**\n     * Stores the anisotropy values in a texture.\n     * rg is direction (like normal from -1 to 1)\n     * b is a intensity\n     */\n    this.texture = null;\n    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];\n  }\n  /** @internal */\n  _markAllSubMeshesAsTexturesDirty() {\n    this._enable(this._isEnabled);\n    this._internalMarkAllSubMeshesAsTexturesDirty();\n  }\n  isReadyForSubMesh(defines, scene) {\n    if (!this._isEnabled) {\n      return true;\n    }\n    if (defines._areTexturesDirty) {\n      if (scene.texturesEnabled) {\n        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n          if (!this._texture.isReadyOrNotBlocking()) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  prepareDefinesBeforeAttributes(defines, scene, mesh) {\n    if (this._isEnabled) {\n      defines.ANISOTROPIC = this._isEnabled;\n      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n        defines._needUVs = true;\n        defines.MAINUV1 = true;\n      }\n      if (defines._areTexturesDirty) {\n        if (scene.texturesEnabled) {\n          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n            MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\n          } else {\n            defines.ANISOTROPIC_TEXTURE = false;\n          }\n        }\n      }\n    } else {\n      defines.ANISOTROPIC = false;\n      defines.ANISOTROPIC_TEXTURE = false;\n      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\n      defines.MAINUV1 = false;\n    }\n  }\n  bindForSubMesh(uniformBuffer, scene) {\n    if (!this._isEnabled) {\n      return;\n    }\n    const isFrozen = this._material.isFrozen;\n    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\n        MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\n      }\n      // Anisotropy\n      uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\n    }\n    // Textures\n    if (scene.texturesEnabled) {\n      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\n        uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\n      }\n    }\n  }\n  hasTexture(texture) {\n    if (this._texture === texture) {\n      return true;\n    }\n    return false;\n  }\n  getActiveTextures(activeTextures) {\n    if (this._texture) {\n      activeTextures.push(this._texture);\n    }\n  }\n  getAnimatables(animatables) {\n    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\n      animatables.push(this._texture);\n    }\n  }\n  dispose(forceDisposeTextures) {\n    if (forceDisposeTextures) {\n      if (this._texture) {\n        this._texture.dispose();\n      }\n    }\n  }\n  getClassName() {\n    return \"PBRAnisotropicConfiguration\";\n  }\n  addFallbacks(defines, fallbacks, currentRank) {\n    if (defines.ANISOTROPIC) {\n      fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\n    }\n    return currentRank;\n  }\n  getSamplers(samplers) {\n    samplers.push(\"anisotropySampler\");\n  }\n  getUniforms() {\n    return {\n      ubo: [{\n        name: \"vAnisotropy\",\n        size: 3,\n        type: \"vec3\"\n      }, {\n        name: \"vAnisotropyInfos\",\n        size: 2,\n        type: \"vec2\"\n      }, {\n        name: \"anisotropyMatrix\",\n        size: 16,\n        type: \"mat4\"\n      }]\n    };\n  }\n}\n__decorate([serialize(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"isEnabled\", void 0);\n__decorate([serialize()], PBRAnisotropicConfiguration.prototype, \"intensity\", void 0);\n__decorate([serializeAsVector2()], PBRAnisotropicConfiguration.prototype, \"direction\", void 0);\n__decorate([serializeAsTexture(), expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")], PBRAnisotropicConfiguration.prototype, \"texture\", void 0);","map":{"version":3,"mappings":"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","names":["serialize","expandToProperty","serializeAsVector2","serializeAsTexture","VertexBuffer","Vector2","MaterialFlags","MaterialHelper","MaterialPluginBase","MaterialDefines","MaterialAnisotropicDefines","constructor","PBRAnisotropicConfiguration","material","addToPluginList","_internalMarkAllSubMeshesAsTexturesDirty","_dirtyCallbacks","_markAllSubMeshesAsTexturesDirty","_enable","_isEnabled","isReadyForSubMesh","defines","scene","_areTexturesDirty","texturesEnabled","_texture","AnisotropicTextureEnabled","isReadyOrNotBlocking","prepareDefinesBeforeAttributes","mesh","ANISOTROPIC","isVerticesDataPresent","TangentKind","_needUVs","MAINUV1","PrepareDefinesForMergedUV","ANISOTROPIC_TEXTURE","ANISOTROPIC_TEXTUREDIRECTUV","bindForSubMesh","uniformBuffer","isFrozen","_material","useUbo","isSync","updateFloat2","coordinatesIndex","level","BindTextureMatrix","updateFloat3","direction","x","y","intensity","setTexture","hasTexture","texture","getActiveTextures","activeTextures","push","getAnimatables","animatables","animations","length","dispose","forceDisposeTextures","getClassName","addFallbacks","fallbacks","currentRank","addFallback","getSamplers","samplers","getUniforms","ubo","name","size","type","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/PBR/pbrAnisotropicConfiguration.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, serializeAsVector2, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { MaterialFlags } from \"../../Materials/materialFlags\";\r\nimport { MaterialHelper } from \"../../Materials/materialHelper\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport type { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\n\r\ndeclare type Scene = import(\"../../scene\").Scene;\r\ndeclare type AbstractMesh = import(\"../../Meshes/abstractMesh\").AbstractMesh;\r\ndeclare type PBRBaseMaterial = import(\"./pbrBaseMaterial\").PBRBaseMaterial;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialAnisotropicDefines extends MaterialDefines {\r\n    public ANISOTROPIC = false;\r\n    public ANISOTROPIC_TEXTURE = false;\r\n    public ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n    public MAINUV1 = false;\r\n}\r\n\r\n/**\r\n * Plugin that implements the anisotropic component of the PBR material\r\n */\r\nexport class PBRAnisotropicConfiguration extends MaterialPluginBase {\r\n    private _isEnabled = false;\r\n    /**\r\n     * Defines if the anisotropy is enabled in the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /**\r\n     * Defines the anisotropy strength (between 0 and 1) it defaults to 1.\r\n     */\r\n    @serialize()\r\n    public intensity: number = 1;\r\n\r\n    /**\r\n     * Defines if the effect is along the tangents, bitangents or in between.\r\n     * By default, the effect is \"stretching\" the highlights along the tangents.\r\n     */\r\n    @serializeAsVector2()\r\n    public direction = new Vector2(1, 0);\r\n\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Stores the anisotropy values in a texture.\r\n     * rg is direction (like normal from -1 to 1)\r\n     * b is a intensity\r\n     */\r\n    @serializeAsTexture()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture> = null;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial, addToPluginList = true) {\r\n        super(material, \"PBRAnisotropic\", 110, new MaterialAnisotropicDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialAnisotropicDefines, scene: Scene): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty) {\r\n            if (scene.texturesEnabled) {\r\n                if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                    if (!this._texture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefinesBeforeAttributes(defines: MaterialAnisotropicDefines, scene: Scene, mesh: AbstractMesh): void {\r\n        if (this._isEnabled) {\r\n            defines.ANISOTROPIC = this._isEnabled;\r\n            if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (scene.texturesEnabled) {\r\n                    if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                        MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, \"ANISOTROPIC_TEXTURE\");\r\n                    } else {\r\n                        defines.ANISOTROPIC_TEXTURE = false;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.ANISOTROPIC_TEXTURE = false;\r\n            defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;\r\n            defines.MAINUV1 = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.updateFloat2(\"vAnisotropyInfos\", this._texture.coordinatesIndex, this._texture.level);\r\n                MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, \"anisotropy\");\r\n            }\r\n\r\n            // Anisotropy\r\n            uniformBuffer.updateFloat3(\"vAnisotropy\", this.direction.x, this.direction.y, this.intensity);\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {\r\n                uniformBuffer.setTexture(\"anisotropySampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            if (this._texture) {\r\n                this._texture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"PBRAnisotropicConfiguration\";\r\n    }\r\n\r\n    public addFallbacks(defines: MaterialAnisotropicDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        if (defines.ANISOTROPIC) {\r\n            fallbacks.addFallback(currentRank++, \"ANISOTROPIC\");\r\n        }\r\n        return currentRank;\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"anisotropySampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vAnisotropy\", size: 3, type: \"vec3\" },\r\n                { name: \"vAnisotropyInfos\", size: 2, type: \"vec2\" },\r\n                { name: \"anisotropyMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}