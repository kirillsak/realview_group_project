{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MaterialHelper } from \"../Materials/materialHelper.js\";\nimport { StandardMaterial } from \"../Materials/standardMaterial.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { PostProcess } from \"./postProcess.js\";\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder.js\";\nimport \"../Shaders/depth.vertex.js\";\nimport \"../Shaders/volumetricLightScattering.fragment.js\";\nimport \"../Shaders/volumetricLightScatteringPass.vertex.js\";\nimport \"../Shaders/volumetricLightScatteringPass.fragment.js\";\nimport { Color4, Color3 } from \"../Maths/math.color.js\";\nimport { Viewport } from \"../Maths/math.viewport.js\";\nimport { RegisterClass } from \"../Misc/typeStore.js\";\n/**\n *  Inspired by https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\n */\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\n  /**\n   * @constructor\n   * @param name The post-process name\n   * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n   * @param camera The camera that the post-process will be attached to\n   * @param mesh The mesh used to create the light scattering\n   * @param samples The post-process quality, default 100\n   * @param samplingMode The post-process filtering mode\n   * @param engine The babylon engine\n   * @param reusable If the post-process is reusable\n   * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\n   */\n  constructor(name, ratio, camera, mesh, samples = 100, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, scene) {\n    var _a, _b;\n    super(name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples);\n    this._screenCoordinates = Vector2.Zero();\n    /**\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\n     */\n    this.customMeshPosition = Vector3.Zero();\n    /**\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\n     */\n    this.useCustomMeshPosition = false;\n    /**\n     * If the post-process should inverse the light scattering direction\n     */\n    this.invert = true;\n    /**\n     * Array containing the excluded meshes not rendered in the internal pass\n     */\n    this.excludedMeshes = new Array();\n    /**\n     * Array containing the only meshes rendered in the internal pass.\n     * If this array is not empty, only the meshes from this array are rendered in the internal pass\n     */\n    this.includedMeshes = new Array();\n    /**\n     * Controls the overall intensity of the post-process\n     */\n    this.exposure = 0.3;\n    /**\n     * Dissipates each sample's contribution in range [0, 1]\n     */\n    this.decay = 0.96815;\n    /**\n     * Controls the overall intensity of each sample\n     */\n    this.weight = 0.58767;\n    /**\n     * Controls the density of each sample\n     */\n    this.density = 0.926;\n    scene = (_b = (_a = camera === null || camera === void 0 ? void 0 : camera.getScene()) !== null && _a !== void 0 ? _a : scene) !== null && _b !== void 0 ? _b : this._scene; // parameter \"scene\" can be null.\n    engine = scene.getEngine();\n    this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n    // Configure mesh\n    this.mesh = mesh !== null && mesh !== void 0 ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\n    // Configure\n    this._createPass(scene, ratio.passRatio || ratio);\n    this.onActivate = camera => {\n      if (!this.isSupported) {\n        this.dispose(camera);\n      }\n      this.onActivate = null;\n    };\n    this.onApplyObservable.add(effect => {\n      this._updateMeshScreenCoordinates(scene);\n      effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\n      effect.setFloat(\"exposure\", this.exposure);\n      effect.setFloat(\"decay\", this.decay);\n      effect.setFloat(\"weight\", this.weight);\n      effect.setFloat(\"density\", this.density);\n      effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\n    });\n  }\n  /**\n   * @internal\n   * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\n   */\n  get useDiffuseColor() {\n    Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n    return false;\n  }\n  set useDiffuseColor(useDiffuseColor) {\n    Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n  }\n  /**\n   * Returns the string \"VolumetricLightScatteringPostProcess\"\n   * @returns \"VolumetricLightScatteringPostProcess\"\n   */\n  getClassName() {\n    return \"VolumetricLightScatteringPostProcess\";\n  }\n  _isReady(subMesh, useInstances) {\n    var _a;\n    const mesh = subMesh.getMesh();\n    // Render this.mesh as default\n    if (mesh === this.mesh && mesh.material) {\n      return mesh.material.isReady(mesh);\n    }\n    const renderingMaterial = (_a = mesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[this._scene.getEngine().currentRenderPassId];\n    if (renderingMaterial) {\n      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n    }\n    const defines = [];\n    const attribs = [VertexBuffer.PositionKind];\n    const material = subMesh.getMaterial();\n    // Alpha test\n    if (material) {\n      if (material.needAlphaTesting()) {\n        defines.push(\"#define ALPHATEST\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        attribs.push(VertexBuffer.UVKind);\n        defines.push(\"#define UV1\");\n      }\n      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n        attribs.push(VertexBuffer.UV2Kind);\n        defines.push(\"#define UV2\");\n      }\n    }\n    // Bones\n    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n      attribs.push(VertexBuffer.MatricesIndicesKind);\n      attribs.push(VertexBuffer.MatricesWeightsKind);\n      defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n      defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\n    } else {\n      defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n    }\n    // Instances\n    if (useInstances) {\n      defines.push(\"#define INSTANCES\");\n      MaterialHelper.PushAttributesForInstances(attribs);\n      if (subMesh.getRenderingMesh().hasThinInstances) {\n        defines.push(\"#define THIN_INSTANCES\");\n      }\n    }\n    // Get correct effect\n    const drawWrapper = subMesh._getDrawWrapper(undefined, true);\n    const cachedDefines = drawWrapper.defines;\n    const join = defines.join(\"\\n\");\n    if (cachedDefines !== join) {\n      drawWrapper.setEffect(mesh.getScene().getEngine().createEffect(\"volumetricLightScatteringPass\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join, undefined, undefined, undefined, {\n        maxSimultaneousMorphTargets: mesh.numBoneInfluencers\n      }), join);\n    }\n    return drawWrapper.effect.isReady();\n  }\n  /**\n   * Sets the new light position for light scattering effect\n   * @param position The new custom light position\n   */\n  setCustomMeshPosition(position) {\n    this.customMeshPosition = position;\n  }\n  /**\n   * Returns the light position for light scattering effect\n   * @returns Vector3 The custom light position\n   */\n  getCustomMeshPosition() {\n    return this.customMeshPosition;\n  }\n  /**\n   * Disposes the internal assets and detaches the post-process from the camera\n   * @param camera\n   */\n  dispose(camera) {\n    const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n    if (rttIndex !== -1) {\n      camera.getScene().customRenderTargets.splice(rttIndex, 1);\n    }\n    this._volumetricLightScatteringRTT.dispose();\n    super.dispose(camera);\n  }\n  /**\n   * Returns the render target texture used by the post-process\n   * @returns the render target texture used by the post-process\n   */\n  getPass() {\n    return this._volumetricLightScatteringRTT;\n  }\n  // Private methods\n  _meshExcluded(mesh) {\n    if (this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1 || this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return true;\n    }\n    return false;\n  }\n  _createPass(scene, ratio) {\n    const engine = scene.getEngine();\n    this._volumetricLightScatteringRTT = new RenderTargetTexture(\"volumetricLightScatteringMap\", {\n      width: engine.getRenderWidth() * ratio,\n      height: engine.getRenderHeight() * ratio\n    }, scene, false, true, 0);\n    this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._volumetricLightScatteringRTT.renderList = null;\n    this._volumetricLightScatteringRTT.renderParticles = false;\n    this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\n    const camera = this.getCamera();\n    if (camera) {\n      camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    } else {\n      scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n    }\n    // Custom render function for submeshes\n    const renderSubMesh = subMesh => {\n      var _a;\n      const renderingMesh = subMesh.getRenderingMesh();\n      const effectiveMesh = subMesh.getEffectiveMesh();\n      if (this._meshExcluded(renderingMesh)) {\n        return;\n      }\n      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      const material = subMesh.getMaterial();\n      if (!material) {\n        return;\n      }\n      const scene = renderingMesh.getScene();\n      const engine = scene.getEngine();\n      // Culling\n      engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\n      // Managing instances\n      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n      if (batch.mustReturn) {\n        return;\n      }\n      const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n      if (this._isReady(subMesh, hardwareInstancedRendering)) {\n        const renderingMaterial = (_a = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[engine.currentRenderPassId];\n        let drawWrapper = subMesh._getDrawWrapper();\n        if (renderingMesh === this.mesh && !drawWrapper) {\n          drawWrapper = material._getDrawWrapper();\n        }\n        if (!drawWrapper) {\n          return;\n        }\n        const effect = drawWrapper.effect;\n        engine.enableEffect(drawWrapper);\n        if (!hardwareInstancedRendering) {\n          renderingMesh._bind(subMesh, effect, material.fillMode);\n        }\n        if (renderingMesh === this.mesh) {\n          material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\n        } else if (renderingMaterial) {\n          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);\n        } else {\n          effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n          // Alpha test\n          if (material && material.needAlphaTesting()) {\n            const alphaTexture = material.getAlphaTestTexture();\n            effect.setTexture(\"diffuseSampler\", alphaTexture);\n            if (alphaTexture) {\n              effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n          }\n          // Bones\n          if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\n            effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\n          }\n        }\n        if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\n          effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n        }\n        // Draw\n        renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\n          if (!isInstance) {\n            effect.setMatrix(\"world\", world);\n          }\n        });\n      }\n    };\n    // Render target texture callbacks\n    let savedSceneClearColor;\n    const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\n    this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(() => {\n      savedSceneClearColor = scene.clearColor;\n      scene.clearColor = sceneClearColor;\n    });\n    this._volumetricLightScatteringRTT.onAfterRenderObservable.add(() => {\n      scene.clearColor = savedSceneClearColor;\n    });\n    this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh, refreshRate, preWarm) => {\n      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\n        for (let i = 0; i < mesh.subMeshes.length; ++i) {\n          const subMesh = mesh.subMeshes[i];\n          const material = subMesh.getMaterial();\n          const renderingMesh = subMesh.getRenderingMesh();\n          if (!material) {\n            continue;\n          }\n          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\n          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\n          if (!this._isReady(subMesh, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    this._volumetricLightScatteringRTT.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {\n      const engine = scene.getEngine();\n      let index;\n      if (depthOnlySubMeshes.length) {\n        engine.setColorWrite(false);\n        for (index = 0; index < depthOnlySubMeshes.length; index++) {\n          renderSubMesh(depthOnlySubMeshes.data[index]);\n        }\n        engine.setColorWrite(true);\n      }\n      for (index = 0; index < opaqueSubMeshes.length; index++) {\n        renderSubMesh(opaqueSubMeshes.data[index]);\n      }\n      for (index = 0; index < alphaTestSubMeshes.length; index++) {\n        renderSubMesh(alphaTestSubMeshes.data[index]);\n      }\n      if (transparentSubMeshes.length) {\n        // Sort sub meshes\n        for (index = 0; index < transparentSubMeshes.length; index++) {\n          const submesh = transparentSubMeshes.data[index];\n          const boundingInfo = submesh.getBoundingInfo();\n          if (boundingInfo && scene.activeCamera) {\n            submesh._alphaIndex = submesh.getMesh().alphaIndex;\n            submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n          }\n        }\n        const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n        sortedArray.sort((a, b) => {\n          // Alpha index first\n          if (a._alphaIndex > b._alphaIndex) {\n            return 1;\n          }\n          if (a._alphaIndex < b._alphaIndex) {\n            return -1;\n          }\n          // Then distance to camera\n          if (a._distanceToCamera < b._distanceToCamera) {\n            return 1;\n          }\n          if (a._distanceToCamera > b._distanceToCamera) {\n            return -1;\n          }\n          return 0;\n        });\n        // Render sub meshes\n        engine.setAlphaMode(2);\n        for (index = 0; index < sortedArray.length; index++) {\n          renderSubMesh(sortedArray[index]);\n        }\n        engine.setAlphaMode(0);\n      }\n    };\n  }\n  _updateMeshScreenCoordinates(scene) {\n    const transform = scene.getTransformMatrix();\n    let meshPosition;\n    if (this.useCustomMeshPosition) {\n      meshPosition = this.customMeshPosition;\n    } else if (this.attachedNode) {\n      meshPosition = this.attachedNode.position;\n    } else {\n      meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n    }\n    const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\n    this._screenCoordinates.x = pos.x / this._viewPort.width;\n    this._screenCoordinates.y = pos.y / this._viewPort.height;\n    if (this.invert) {\n      this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n    }\n  }\n  // Static methods\n  /**\n   * Creates a default mesh for the Volumeric Light Scattering post-process\n   * @param name The mesh name\n   * @param scene The scene where to create the mesh\n   * @returns the default mesh\n   */\n  static CreateDefaultMesh(name, scene) {\n    const mesh = CreatePlane(name, {\n      size: 1\n    }, scene);\n    mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\n    const material = new StandardMaterial(name + \"Material\", scene);\n    material.emissiveColor = new Color3(1, 1, 1);\n    mesh.material = material;\n    return mesh;\n  }\n}\n__decorate([serializeAsVector3()], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n__decorate([serializeAsMeshReference()], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"includedMeshes\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n__decorate([serialize()], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);","map":{"version":3,"mappings":";;AAAA,SAASA,kBAAkB,EAAEC,SAAS,EAAEC,wBAAwB,QAAQ,uBAAqB;AAE7F,SAASC,MAAM,QAAQ,mBAAiB;AACxC,SAASC,OAAO,EAAEC,OAAO,EAAEC,MAAM,QAAQ,yBAAuB;AAChE,SAASC,YAAY,QAAQ,sBAAoB;AACjD,SAASC,YAAY,QAAQ,2BAAyB;AAKtD,SAASC,QAAQ,QAAQ,0BAAwB;AACjD,SAASC,cAAc,QAAQ,gCAA8B;AAC7D,SAASC,gBAAgB,QAAQ,kCAAgC;AACjE,SAASC,OAAO,QAAQ,kCAAgC;AACxD,SAASC,mBAAmB,QAAQ,8CAA4C;AAChF,SAASC,WAAW,QAAQ,kBAAgB;AAI5C,SAASC,WAAW,QAAQ,oCAAkC;AAE9D,OAAO,4BAA0B;AACjC,OAAO,kDAAgD;AACvD,OAAO,oDAAkD;AACzD,OAAO,sDAAoD;AAC3D,SAASC,MAAM,EAAEC,MAAM,QAAQ,wBAAsB;AACrD,SAASC,QAAQ,QAAQ,2BAAyB;AAClD,SAASC,aAAa,QAAQ,sBAAoB;AAKlD;;;AAGA,OAAM,MAAOC,oCAAqC,SAAQN,WAAW;EAqFjE;;;;;;;;;;;;EAYAO,YACIC,IAAY,EACZC,KAAU,EACVC,MAAwB,EACxBC,IAAW,EACXC,UAAkB,GAAG,EACrBC,eAAuBf,OAAO,CAACgB,qBAAqB,EACpDC,MAAe,EACfC,QAAkB,EAClBC,KAAa;;IAEb,KAAK,CACDT,IAAI,EACJ,2BAA2B,EAC3B,CAAC,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,sBAAsB,EAAE,SAAS,CAAC,EAClE,CAAC,wBAAwB,CAAC,EAC1BC,KAAK,CAACS,gBAAgB,IAAIT,KAAK,EAC/BC,MAAM,EACNG,YAAY,EACZE,MAAM,EACNC,QAAQ,EACR,sBAAsB,GAAGJ,OAAO,CACnC;IAnHG,uBAAkB,GAAYtB,OAAO,CAAC6B,IAAI,EAAE;IAOpD;;;IAIO,uBAAkB,GAAY5B,OAAO,CAAC4B,IAAI,EAAE;IAEnD;;;IAIO,0BAAqB,GAAY,KAAK;IAE7C;;;IAIO,WAAM,GAAY,IAAI;IAqB7B;;;IAIO,mBAAc,GAAG,IAAIC,KAAK,EAAgB;IAEjD;;;;IAKO,mBAAc,GAAG,IAAIA,KAAK,EAAgB;IAEjD;;;IAIO,aAAQ,GAAG,GAAG;IAErB;;;IAIO,UAAK,GAAG,OAAO;IAEtB;;;IAIO,WAAM,GAAG,OAAO;IAEvB;;;IAIO,YAAO,GAAG,KAAK;IAqClBH,KAAK,GAAG,kBAAM,aAANP,MAAM,uBAANA,MAAM,CAAEW,QAAQ,EAAE,mCAAIJ,KAAK,mCAAI,IAAI,CAACK,MAAM,CAAC,CAAC;IAEpDP,MAAM,GAAGE,KAAK,CAACM,SAAS,EAAE;IAC1B,IAAI,CAACC,SAAS,GAAG,IAAIpB,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACqB,QAAQ,CAACV,MAAM,CAACW,cAAc,EAAE,EAAEX,MAAM,CAACY,eAAe,EAAE,CAAC;IAErG;IACA,IAAI,CAAChB,IAAI,GAAGA,IAAI,aAAJA,IAAI,cAAJA,IAAI,GAAIL,oCAAoC,CAACsB,iBAAiB,CAAC,+BAA+B,EAAEX,KAAK,CAAC;IAElH;IACA,IAAI,CAACY,WAAW,CAACZ,KAAK,EAAER,KAAK,CAACqB,SAAS,IAAIrB,KAAK,CAAC;IAEjD,IAAI,CAACsB,UAAU,GAAIrB,MAAc,IAAI;MACjC,IAAI,CAAC,IAAI,CAACsB,WAAW,EAAE;QACnB,IAAI,CAACC,OAAO,CAACvB,MAAM,CAAC;;MAGxB,IAAI,CAACqB,UAAU,GAAG,IAAI;IAC1B,CAAC;IAED,IAAI,CAACG,iBAAiB,CAACC,GAAG,CAAEC,MAAc,IAAI;MAC1C,IAAI,CAACC,4BAA4B,CAAQpB,KAAK,CAAC;MAE/CmB,MAAM,CAACE,UAAU,CAAC,wBAAwB,EAAE,IAAI,CAACC,6BAA6B,CAAC;MAC/EH,MAAM,CAACI,QAAQ,CAAC,UAAU,EAAE,IAAI,CAACC,QAAQ,CAAC;MAC1CL,MAAM,CAACI,QAAQ,CAAC,OAAO,EAAE,IAAI,CAACE,KAAK,CAAC;MACpCN,MAAM,CAACI,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAACG,MAAM,CAAC;MACtCP,MAAM,CAACI,QAAQ,CAAC,SAAS,EAAE,IAAI,CAACI,OAAO,CAAC;MACxCR,MAAM,CAACS,UAAU,CAAC,sBAAsB,EAAE,IAAI,CAACC,kBAAkB,CAAC;IACtE,CAAC,CAAC;EACN;EAlHA;;;;EAIA,IAAWC,eAAe;IACtB1D,MAAM,CAAC2D,IAAI,CAAC,gHAAgH,CAAC;IAC7H,OAAO,KAAK;EAChB;EAEA,IAAWD,eAAe,CAACA,eAAwB;IAC/C1D,MAAM,CAAC2D,IAAI,CAAC,gHAAgH,CAAC;EACjI;EAyGA;;;;EAIOC,YAAY;IACf,OAAO,sCAAsC;EACjD;EAEQC,QAAQ,CAACC,OAAgB,EAAEC,YAAqB;;IACpD,MAAMzC,IAAI,GAAGwC,OAAO,CAACE,OAAO,EAAE;IAE9B;IACA,IAAI1C,IAAI,KAAK,IAAI,CAACA,IAAI,IAAIA,IAAI,CAAC2C,QAAQ,EAAE;MACrC,OAAO3C,IAAI,CAAC2C,QAAQ,CAACC,OAAO,CAAC5C,IAAI,CAAC;;IAGtC,MAAM6C,iBAAiB,GAAG,UAAI,CAACC,6BAA6B,CAACC,sBAAsB,0CAAG,IAAI,CAACpC,MAAM,CAACC,SAAS,EAAE,CAACoC,mBAAmB,CAAC;IAElI,IAAIH,iBAAiB,EAAE;MACnB,OAAOA,iBAAiB,CAACI,iBAAiB,CAACjD,IAAI,EAAEwC,OAAO,EAAEC,YAAY,CAAC;;IAG3E,MAAMS,OAAO,GAAG,EAAE;IAClB,MAAMC,OAAO,GAAG,CAACrE,YAAY,CAACsE,YAAY,CAAC;IAC3C,MAAMT,QAAQ,GAAQH,OAAO,CAACa,WAAW,EAAE;IAE3C;IACA,IAAIV,QAAQ,EAAE;MACV,IAAIA,QAAQ,CAACW,gBAAgB,EAAE,EAAE;QAC7BJ,OAAO,CAACK,IAAI,CAAC,mBAAmB,CAAC;;MAGrC,IAAIvD,IAAI,CAACwD,qBAAqB,CAAC1E,YAAY,CAAC2E,MAAM,CAAC,EAAE;QACjDN,OAAO,CAACI,IAAI,CAACzE,YAAY,CAAC2E,MAAM,CAAC;QACjCP,OAAO,CAACK,IAAI,CAAC,aAAa,CAAC;;MAE/B,IAAIvD,IAAI,CAACwD,qBAAqB,CAAC1E,YAAY,CAAC4E,OAAO,CAAC,EAAE;QAClDP,OAAO,CAACI,IAAI,CAACzE,YAAY,CAAC4E,OAAO,CAAC;QAClCR,OAAO,CAACK,IAAI,CAAC,aAAa,CAAC;;;IAInC;IACA,IAAIvD,IAAI,CAAC2D,QAAQ,IAAI3D,IAAI,CAAC4D,wBAAwB,EAAE;MAChDT,OAAO,CAACI,IAAI,CAACzE,YAAY,CAAC+E,mBAAmB,CAAC;MAC9CV,OAAO,CAACI,IAAI,CAACzE,YAAY,CAACgF,mBAAmB,CAAC;MAC9CZ,OAAO,CAACK,IAAI,CAAC,+BAA+B,GAAGvD,IAAI,CAAC+D,kBAAkB,CAAC;MACvEb,OAAO,CAACK,IAAI,CAAC,uBAAuB,IAAIvD,IAAI,CAACgE,QAAQ,GAAGhE,IAAI,CAACgE,QAAQ,CAACC,KAAK,CAACC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;KAC/F,MAAM;MACHhB,OAAO,CAACK,IAAI,CAAC,gCAAgC,CAAC;;IAGlD;IACA,IAAId,YAAY,EAAE;MACdS,OAAO,CAACK,IAAI,CAAC,mBAAmB,CAAC;MACjCtE,cAAc,CAACkF,0BAA0B,CAAChB,OAAO,CAAC;MAClD,IAAIX,OAAO,CAAC4B,gBAAgB,EAAE,CAACC,gBAAgB,EAAE;QAC7CnB,OAAO,CAACK,IAAI,CAAC,wBAAwB,CAAC;;;IAI9C;IACA,MAAMe,WAAW,GAAG9B,OAAO,CAAC+B,eAAe,CAACC,SAAS,EAAE,IAAI,CAAE;IAC7D,MAAMC,aAAa,GAAGH,WAAW,CAACpB,OAAO;IACzC,MAAMwB,IAAI,GAAGxB,OAAO,CAACwB,IAAI,CAAC,IAAI,CAAC;IAC/B,IAAID,aAAa,KAAKC,IAAI,EAAE;MACxBJ,WAAW,CAACK,SAAS,CACjB3E,IAAI,CACCU,QAAQ,EAAE,CACVE,SAAS,EAAE,CACXgE,YAAY,CACT,+BAA+B,EAC/BzB,OAAO,EACP,CAAC,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE,eAAe,CAAC,EACtD,CAAC,gBAAgB,CAAC,EAClBuB,IAAI,EACJF,SAAS,EACTA,SAAS,EACTA,SAAS,EACT;QAAEK,2BAA2B,EAAE7E,IAAI,CAAC+D;MAAkB,CAAE,CAC3D,EACLW,IAAI,CACP;;IAGL,OAAOJ,WAAW,CAAC7C,MAAO,CAACmB,OAAO,EAAE;EACxC;EAEA;;;;EAIOkC,qBAAqB,CAACC,QAAiB;IAC1C,IAAI,CAACC,kBAAkB,GAAGD,QAAQ;EACtC;EAEA;;;;EAIOE,qBAAqB;IACxB,OAAO,IAAI,CAACD,kBAAkB;EAClC;EAEA;;;;EAIO1D,OAAO,CAACvB,MAAc;IACzB,MAAMmF,QAAQ,GAAGnF,MAAM,CAACW,QAAQ,EAAE,CAACyE,mBAAmB,CAACC,OAAO,CAAC,IAAI,CAACxD,6BAA6B,CAAC;IAClG,IAAIsD,QAAQ,KAAK,CAAC,CAAC,EAAE;MACjBnF,MAAM,CAACW,QAAQ,EAAE,CAACyE,mBAAmB,CAACE,MAAM,CAACH,QAAQ,EAAE,CAAC,CAAC;;IAG7D,IAAI,CAACtD,6BAA6B,CAACN,OAAO,EAAE;IAC5C,KAAK,CAACA,OAAO,CAACvB,MAAM,CAAC;EACzB;EAEA;;;;EAIOuF,OAAO;IACV,OAAO,IAAI,CAAC1D,6BAA6B;EAC7C;EAEA;EACQ2D,aAAa,CAACvF,IAAkB;IACpC,IAAK,IAAI,CAACwF,cAAc,CAACtB,MAAM,GAAG,CAAC,IAAI,IAAI,CAACsB,cAAc,CAACJ,OAAO,CAACpF,IAAI,CAAC,KAAK,CAAC,CAAC,IAAM,IAAI,CAACyF,cAAc,CAACvB,MAAM,GAAG,CAAC,IAAI,IAAI,CAACuB,cAAc,CAACL,OAAO,CAACpF,IAAI,CAAC,KAAK,CAAC,CAAE,EAAE;MAC9J,OAAO,IAAI;;IAGf,OAAO,KAAK;EAChB;EAEQkB,WAAW,CAACZ,KAAY,EAAER,KAAa;IAC3C,MAAMM,MAAM,GAAGE,KAAK,CAACM,SAAS,EAAE;IAEhC,IAAI,CAACgB,6BAA6B,GAAG,IAAIxC,mBAAmB,CACxD,8BAA8B,EAC9B;MAAEsG,KAAK,EAAEtF,MAAM,CAACW,cAAc,EAAE,GAAGjB,KAAK;MAAE6F,MAAM,EAAEvF,MAAM,CAACY,eAAe,EAAE,GAAGlB;IAAK,CAAE,EACpFQ,KAAK,EACL,KAAK,EACL,IAAI,EACJ;IAEJ,IAAI,CAACsB,6BAA6B,CAACgE,KAAK,GAAGzG,OAAO,CAAC0G,iBAAiB;IACpE,IAAI,CAACjE,6BAA6B,CAACkE,KAAK,GAAG3G,OAAO,CAAC0G,iBAAiB;IACpE,IAAI,CAACjE,6BAA6B,CAACmE,UAAU,GAAG,IAAI;IACpD,IAAI,CAACnE,6BAA6B,CAACoE,eAAe,GAAG,KAAK;IAC1D,IAAI,CAACpE,6BAA6B,CAACqE,oBAAoB,GAAG,IAAI;IAE9D,MAAMlG,MAAM,GAAG,IAAI,CAACmG,SAAS,EAAE;IAC/B,IAAInG,MAAM,EAAE;MACRA,MAAM,CAACoF,mBAAmB,CAAC5B,IAAI,CAAC,IAAI,CAAC3B,6BAA6B,CAAC;KACtE,MAAM;MACHtB,KAAK,CAAC6E,mBAAmB,CAAC5B,IAAI,CAAC,IAAI,CAAC3B,6BAA6B,CAAC;;IAGtE;IACA,MAAMuE,aAAa,GAAI3D,OAAgB,IAAU;;MAC7C,MAAM4D,aAAa,GAAG5D,OAAO,CAAC4B,gBAAgB,EAAE;MAChD,MAAMiC,aAAa,GAAG7D,OAAO,CAAC8D,gBAAgB,EAAE;MAChD,IAAI,IAAI,CAACf,aAAa,CAACa,aAAa,CAAC,EAAE;QACnC;;MAGJC,aAAa,CAACvD,6BAA6B,CAACyD,qBAAqB,GAAG,KAAK;MAEzE,MAAM5D,QAAQ,GAAGH,OAAO,CAACa,WAAW,EAAE;MAEtC,IAAI,CAACV,QAAQ,EAAE;QACX;;MAGJ,MAAMrC,KAAK,GAAG8F,aAAa,CAAC1F,QAAQ,EAAE;MACtC,MAAMN,MAAM,GAAGE,KAAK,CAACM,SAAS,EAAE;MAEhC;MACAR,MAAM,CAACoG,QAAQ,CAAC7D,QAAQ,CAAC8D,eAAe,EAAEjC,SAAS,EAAEA,SAAS,EAAEA,SAAS,EAAE7B,QAAQ,CAAC+D,aAAa,CAAC;MAElG;MACA,MAAMC,KAAK,GAAGP,aAAa,CAACQ,uBAAuB,CAACpE,OAAO,CAACqE,GAAG,EAAE,CAAC,CAACrE,OAAO,CAACsE,kBAAkB,EAAE,CAAC;MAEhG,IAAIH,KAAK,CAACI,UAAU,EAAE;QAClB;;MAGJ,MAAMC,0BAA0B,GAAG5G,MAAM,CAAC6G,OAAO,EAAE,CAACC,eAAe,KAAKP,KAAK,CAACQ,gBAAgB,CAAC3E,OAAO,CAACqE,GAAG,CAAC,KAAK,IAAI,IAAIT,aAAa,CAAC/B,gBAAgB,CAAC;MAEvJ,IAAI,IAAI,CAAC9B,QAAQ,CAACC,OAAO,EAAEwE,0BAA0B,CAAC,EAAE;QACpD,MAAMnE,iBAAiB,GAAG,mBAAa,CAACC,6BAA6B,CAACC,sBAAsB,0CAAG3C,MAAM,CAAC4C,mBAAmB,CAAC;QAE1H,IAAIsB,WAAW,GAAG9B,OAAO,CAAC+B,eAAe,EAAE;QAC3C,IAAI6B,aAAa,KAAK,IAAI,CAACpG,IAAI,IAAI,CAACsE,WAAW,EAAE;UAC7CA,WAAW,GAAG3B,QAAQ,CAAC4B,eAAe,EAAE;;QAG5C,IAAI,CAACD,WAAW,EAAE;UACd;;QAGJ,MAAM7C,MAAM,GAAG6C,WAAW,CAAC7C,MAAO;QAElCrB,MAAM,CAACgH,YAAY,CAAC9C,WAAW,CAAC;QAChC,IAAI,CAAC0C,0BAA0B,EAAE;UAC7BZ,aAAa,CAACiB,KAAK,CAAC7E,OAAO,EAAEf,MAAM,EAAEkB,QAAQ,CAAC2E,QAAQ,CAAC;;QAG3D,IAAIlB,aAAa,KAAK,IAAI,CAACpG,IAAI,EAAE;UAC7B2C,QAAQ,CAAC4E,IAAI,CAAClB,aAAa,CAACmB,cAAc,EAAE,EAAEpB,aAAa,CAAC;SAC/D,MAAM,IAAIvD,iBAAiB,EAAE;UAC1BA,iBAAiB,CAAC4E,cAAc,CAACpB,aAAa,CAACmB,cAAc,EAAE,EAAEnB,aAAqB,EAAE7D,OAAO,CAAC;SACnG,MAAM;UACHf,MAAM,CAACiG,SAAS,CAAC,gBAAgB,EAAEpH,KAAK,CAACqH,kBAAkB,EAAE,CAAC;UAE9D;UACA,IAAIhF,QAAQ,IAAIA,QAAQ,CAACW,gBAAgB,EAAE,EAAE;YACzC,MAAMsE,YAAY,GAAGjF,QAAQ,CAACkF,mBAAmB,EAAE;YAEnDpG,MAAM,CAACE,UAAU,CAAC,gBAAgB,EAAEiG,YAAY,CAAC;YAEjD,IAAIA,YAAY,EAAE;cACdnG,MAAM,CAACiG,SAAS,CAAC,eAAe,EAAEE,YAAY,CAACE,gBAAgB,EAAE,CAAC;;;UAI1E;UACA,IAAI1B,aAAa,CAACzC,QAAQ,IAAIyC,aAAa,CAACxC,wBAAwB,IAAIwC,aAAa,CAACpC,QAAQ,EAAE;YAC5FvC,MAAM,CAACsG,WAAW,CAAC,QAAQ,EAAE3B,aAAa,CAACpC,QAAQ,CAACgE,oBAAoB,CAAC5B,aAAa,CAAC,CAAC;;;QAIhG,IAAIY,0BAA0B,IAAIZ,aAAa,CAAC/B,gBAAgB,EAAE;UAC9D5C,MAAM,CAACiG,SAAS,CAAC,OAAO,EAAErB,aAAa,CAACmB,cAAc,EAAE,CAAC;;QAG7D;QACApB,aAAa,CAAC6B,iBAAiB,CAAC5B,aAAa,EAAE7D,OAAO,EAAEf,MAAM,EAAEzC,QAAQ,CAACkJ,gBAAgB,EAAEvB,KAAK,EAAEK,0BAA0B,EAAE,CAACmB,UAAU,EAAEC,KAAK,KAAI;UAChJ,IAAI,CAACD,UAAU,EAAE;YACb1G,MAAM,CAACiG,SAAS,CAAC,OAAO,EAAEU,KAAK,CAAC;;QAExC,CAAC,CAAC;;IAEV,CAAC;IAED;IACA,IAAIC,oBAA4B;IAChC,MAAMC,eAAe,GAAG,IAAI/I,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAEtD,IAAI,CAACqC,6BAA6B,CAAC2G,wBAAwB,CAAC/G,GAAG,CAAC,MAAW;MACvE6G,oBAAoB,GAAG/H,KAAK,CAACkI,UAAU;MACvClI,KAAK,CAACkI,UAAU,GAAGF,eAAe;IACtC,CAAC,CAAC;IAEF,IAAI,CAAC1G,6BAA6B,CAAC6G,uBAAuB,CAACjH,GAAG,CAAC,MAAW;MACtElB,KAAK,CAACkI,UAAU,GAAGH,oBAAoB;IAC3C,CAAC,CAAC;IAEF,IAAI,CAACzG,6BAA6B,CAAC8G,qBAAqB,GAAG,CAAC1I,IAAkB,EAAE2I,WAAmB,EAAEC,OAAiB,KAAI;MACtH,IAAI,CAACA,OAAO,IAAID,WAAW,KAAK,CAAC,KAAK3I,IAAI,CAAC6I,SAAS,EAAE;QAClD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9I,IAAI,CAAC6I,SAAS,CAAC3E,MAAM,EAAE,EAAE4E,CAAC,EAAE;UAC5C,MAAMtG,OAAO,GAAGxC,IAAI,CAAC6I,SAAS,CAACC,CAAC,CAAC;UACjC,MAAMnG,QAAQ,GAAGH,OAAO,CAACa,WAAW,EAAE;UACtC,MAAM+C,aAAa,GAAG5D,OAAO,CAAC4B,gBAAgB,EAAE;UAEhD,IAAI,CAACzB,QAAQ,EAAE;YACX;;UAGJ,MAAMgE,KAAK,GAAGP,aAAa,CAACQ,uBAAuB,CAACpE,OAAO,CAACqE,GAAG,EAAE,CAAC,CAACrE,OAAO,CAACsE,kBAAkB,EAAE,CAAC;UAChG,MAAME,0BAA0B,GAAG5G,MAAM,CAAC6G,OAAO,EAAE,CAACC,eAAe,KAAKP,KAAK,CAACQ,gBAAgB,CAAC3E,OAAO,CAACqE,GAAG,CAAC,KAAK,IAAI,IAAIT,aAAa,CAAC/B,gBAAgB,CAAC;UAEvJ,IAAI,CAAC,IAAI,CAAC9B,QAAQ,CAACC,OAAO,EAAEwE,0BAA0B,CAAC,EAAE;YACrD,OAAO,KAAK;;;;MAKxB,OAAO,IAAI;IACf,CAAC;IAED,IAAI,CAACpF,6BAA6B,CAACmH,oBAAoB,GAAG,CACtDC,eAAoC,EACpCC,kBAAuC,EACvCC,oBAAyC,EACzCC,kBAAuC,KACjC;MACN,MAAM/I,MAAM,GAAGE,KAAK,CAACM,SAAS,EAAE;MAChC,IAAIwI,KAAa;MAEjB,IAAID,kBAAkB,CAACjF,MAAM,EAAE;QAC3B9D,MAAM,CAACiJ,aAAa,CAAC,KAAK,CAAC;QAC3B,KAAKD,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,kBAAkB,CAACjF,MAAM,EAAEkF,KAAK,EAAE,EAAE;UACxDjD,aAAa,CAACgD,kBAAkB,CAACG,IAAI,CAACF,KAAK,CAAC,CAAC;;QAEjDhJ,MAAM,CAACiJ,aAAa,CAAC,IAAI,CAAC;;MAG9B,KAAKD,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGJ,eAAe,CAAC9E,MAAM,EAAEkF,KAAK,EAAE,EAAE;QACrDjD,aAAa,CAAC6C,eAAe,CAACM,IAAI,CAACF,KAAK,CAAC,CAAC;;MAG9C,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,kBAAkB,CAAC/E,MAAM,EAAEkF,KAAK,EAAE,EAAE;QACxDjD,aAAa,CAAC8C,kBAAkB,CAACK,IAAI,CAACF,KAAK,CAAC,CAAC;;MAGjD,IAAIF,oBAAoB,CAAChF,MAAM,EAAE;QAC7B;QACA,KAAKkF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGF,oBAAoB,CAAChF,MAAM,EAAEkF,KAAK,EAAE,EAAE;UAC1D,MAAMG,OAAO,GAAGL,oBAAoB,CAACI,IAAI,CAACF,KAAK,CAAC;UAChD,MAAMI,YAAY,GAAGD,OAAO,CAACE,eAAe,EAAE;UAE9C,IAAID,YAAY,IAAIlJ,KAAK,CAACoJ,YAAY,EAAE;YACpCH,OAAO,CAACI,WAAW,GAAGJ,OAAO,CAAC7G,OAAO,EAAE,CAACkH,UAAU;YAClDL,OAAO,CAACM,iBAAiB,GAAGL,YAAY,CAACM,cAAc,CAACC,WAAW,CAACC,QAAQ,CAAC1J,KAAK,CAACoJ,YAAY,CAAC3E,QAAQ,CAAC,CAACb,MAAM,EAAE;;;QAI1H,MAAM+F,WAAW,GAAGf,oBAAoB,CAACI,IAAI,CAACY,KAAK,CAAC,CAAC,EAAEhB,oBAAoB,CAAChF,MAAM,CAAC;QACnF+F,WAAW,CAACE,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAI;UACtB;UACA,IAAID,CAAC,CAACT,WAAW,GAAGU,CAAC,CAACV,WAAW,EAAE;YAC/B,OAAO,CAAC;;UAEZ,IAAIS,CAAC,CAACT,WAAW,GAAGU,CAAC,CAACV,WAAW,EAAE;YAC/B,OAAO,CAAC,CAAC;;UAGb;UACA,IAAIS,CAAC,CAACP,iBAAiB,GAAGQ,CAAC,CAACR,iBAAiB,EAAE;YAC3C,OAAO,CAAC;;UAEZ,IAAIO,CAAC,CAACP,iBAAiB,GAAGQ,CAAC,CAACR,iBAAiB,EAAE;YAC3C,OAAO,CAAC,CAAC;;UAGb,OAAO,CAAC;QACZ,CAAC,CAAC;QAEF;QACAzJ,MAAM,CAACkK,YAAY,CAAC;QACpB,KAAKlB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGa,WAAW,CAAC/F,MAAM,EAAEkF,KAAK,EAAE,EAAE;UACjDjD,aAAa,CAAC8D,WAAW,CAACb,KAAK,CAAC,CAAC;;QAErChJ,MAAM,CAACkK,YAAY,CAAC;;IAE5B,CAAC;EACL;EAEQ5I,4BAA4B,CAACpB,KAAY;IAC7C,MAAMiK,SAAS,GAAGjK,KAAK,CAACqH,kBAAkB,EAAE;IAC5C,IAAI6C,YAAqB;IAEzB,IAAI,IAAI,CAACC,qBAAqB,EAAE;MAC5BD,YAAY,GAAG,IAAI,CAACxF,kBAAkB;KACzC,MAAM,IAAI,IAAI,CAAC0F,YAAY,EAAE;MAC1BF,YAAY,GAAG,IAAI,CAACE,YAAY,CAAC3F,QAAQ;KAC5C,MAAM;MACHyF,YAAY,GAAG,IAAI,CAACxK,IAAI,CAAC2K,MAAM,GAAG,IAAI,CAAC3K,IAAI,CAAC4K,mBAAmB,EAAE,GAAG,IAAI,CAAC5K,IAAI,CAAC+E,QAAQ;;IAG1F,MAAM8F,GAAG,GAAGjM,OAAO,CAACkM,OAAO,CAACN,YAAY,EAAE3L,MAAM,CAACkM,QAAQ,EAAE,EAAER,SAAS,EAAE,IAAI,CAAC1J,SAAS,CAAC;IAEvF,IAAI,CAACsB,kBAAkB,CAAC6I,CAAC,GAAGH,GAAG,CAACG,CAAC,GAAG,IAAI,CAACnK,SAAS,CAAC6E,KAAK;IACxD,IAAI,CAACvD,kBAAkB,CAAC8I,CAAC,GAAGJ,GAAG,CAACI,CAAC,GAAG,IAAI,CAACpK,SAAS,CAAC8E,MAAM;IAEzD,IAAI,IAAI,CAACuF,MAAM,EAAE;MACb,IAAI,CAAC/I,kBAAkB,CAAC8I,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC9I,kBAAkB,CAAC8I,CAAC;;EAEnE;EAEA;EACA;;;;;;EAMO,OAAOhK,iBAAiB,CAACpB,IAAY,EAAES,KAAY;IACtD,MAAMN,IAAI,GAAGV,WAAW,CAACO,IAAI,EAAE;MAAEsL,IAAI,EAAE;IAAC,CAAE,EAAE7K,KAAK,CAAC;IAClDN,IAAI,CAACoL,aAAa,GAAGrM,YAAY,CAACsM,iBAAiB;IAEnD,MAAM1I,QAAQ,GAAG,IAAIzD,gBAAgB,CAACW,IAAI,GAAG,UAAU,EAAES,KAAK,CAAC;IAC/DqC,QAAQ,CAAC2I,aAAa,GAAG,IAAI9L,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAE5CQ,IAAI,CAAC2C,QAAQ,GAAGA,QAAQ;IAExB,OAAO3C,IAAI;EACf;;AA7gBAuL,YADChN,kBAAkB,EAAE,gFAC+B;AAMpDgN,YADC/M,SAAS,EAAE,mFACkC;AAM9C+M,YADC/M,SAAS,EAAE,oEACkB;AAM9B+M,YADC9M,wBAAwB,EAAE,kEACT;AAmBlB8M,YADC/M,SAAS,EAAE,4EACsC;AAOlD+M,YADC/M,SAAS,EAAE,4EACsC;AAMlD+M,YADC/M,SAAS,EAAE,sEACU;AAMtB+M,YADC/M,SAAS,EAAE,mEACW;AAMvB+M,YADC/M,SAAS,EAAE,oEACY;AAMxB+M,YADC/M,SAAS,EAAE,qEACW;AA4c3BkB,aAAa,CAAC,8CAA8C,EAAEC,oCAAoC,CAAC","names":["serializeAsVector3","serialize","serializeAsMeshReference","Logger","Vector2","Vector3","Matrix","VertexBuffer","AbstractMesh","Material","MaterialHelper","StandardMaterial","Texture","RenderTargetTexture","PostProcess","CreatePlane","Color4","Color3","Viewport","RegisterClass","VolumetricLightScatteringPostProcess","constructor","name","ratio","camera","mesh","samples","samplingMode","BILINEAR_SAMPLINGMODE","engine","reusable","scene","postProcessRatio","Zero","Array","getScene","_scene","getEngine","_viewPort","toGlobal","getRenderWidth","getRenderHeight","CreateDefaultMesh","_createPass","passRatio","onActivate","isSupported","dispose","onApplyObservable","add","effect","_updateMeshScreenCoordinates","setTexture","_volumetricLightScatteringRTT","setFloat","exposure","decay","weight","density","setVector2","_screenCoordinates","useDiffuseColor","Warn","getClassName","_isReady","subMesh","useInstances","getMesh","material","isReady","renderingMaterial","_internalAbstractMeshDataInfo","_materialForRenderPass","currentRenderPassId","isReadyForSubMesh","defines","attribs","PositionKind","getMaterial","needAlphaTesting","push","isVerticesDataPresent","UVKind","UV2Kind","useBones","computeBonesUsingShaders","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","skeleton","bones","length","PushAttributesForInstances","getRenderingMesh","hasThinInstances","drawWrapper","_getDrawWrapper","undefined","cachedDefines","join","setEffect","createEffect","maxSimultaneousMorphTargets","setCustomMeshPosition","position","customMeshPosition","getCustomMeshPosition","rttIndex","customRenderTargets","indexOf","splice","getPass","_meshExcluded","includedMeshes","excludedMeshes","width","height","wrapU","CLAMP_ADDRESSMODE","wrapV","renderList","renderParticles","ignoreCameraViewport","getCamera","renderSubMesh","renderingMesh","effectiveMesh","getEffectiveMesh","_isActiveIntermediate","setState","backFaceCulling","cullBackFaces","batch","_getInstancesRenderList","_id","getReplacementMesh","mustReturn","hardwareInstancedRendering","getCaps","instancedArrays","visibleInstances","enableEffect","_bind","fillMode","bind","getWorldMatrix","bindForSubMesh","setMatrix","getTransformMatrix","alphaTexture","getAlphaTestTexture","getTextureMatrix","setMatrices","getTransformMatrices","_processRendering","TriangleFillMode","isInstance","world","savedSceneClearColor","sceneClearColor","onBeforeRenderObservable","clearColor","onAfterRenderObservable","customIsReadyFunction","refreshRate","preWarm","subMeshes","i","customRenderFunction","opaqueSubMeshes","alphaTestSubMeshes","transparentSubMeshes","depthOnlySubMeshes","index","setColorWrite","data","submesh","boundingInfo","getBoundingInfo","activeCamera","_alphaIndex","alphaIndex","_distanceToCamera","boundingSphere","centerWorld","subtract","sortedArray","slice","sort","a","b","setAlphaMode","transform","meshPosition","useCustomMeshPosition","attachedNode","parent","getAbsolutePosition","pos","Project","Identity","x","y","invert","size","billboardMode","BILLBOARDMODE_ALL","emissiveColor","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/PostProcesses/volumetricLightScatteringPostProcess.ts"],"sourcesContent":["import { serializeAsVector3, serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Vector2, Vector3, Matrix } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialHelper } from \"../Materials/materialHelper\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\n\r\nimport { CreatePlane } from \"../Meshes/Builders/planeBuilder\";\r\n\r\nimport \"../Shaders/depth.vertex\";\r\nimport \"../Shaders/volumetricLightScattering.fragment\";\r\nimport \"../Shaders/volumetricLightScatteringPass.vertex\";\r\nimport \"../Shaders/volumetricLightScatteringPass.fragment\";\r\nimport { Color4, Color3 } from \"../Maths/math.color\";\r\nimport { Viewport } from \"../Maths/math.viewport\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Nullable } from \"../types\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\n/**\r\n *  Inspired by https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-13-volumetric-light-scattering-post-process\r\n */\r\nexport class VolumetricLightScatteringPostProcess extends PostProcess {\r\n    // Members\r\n    private _volumetricLightScatteringRTT: RenderTargetTexture;\r\n    private _viewPort: Viewport;\r\n    private _screenCoordinates: Vector2 = Vector2.Zero();\r\n\r\n    /**\r\n     * If not undefined, the mesh position is computed from the attached node position\r\n     */\r\n    public attachedNode: { position: Vector3 };\r\n\r\n    /**\r\n     * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\r\n     */\r\n    @serializeAsVector3()\r\n    public customMeshPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\r\n     */\r\n    @serialize()\r\n    public useCustomMeshPosition: boolean = false;\r\n\r\n    /**\r\n     * If the post-process should inverse the light scattering direction\r\n     */\r\n    @serialize()\r\n    public invert: boolean = true;\r\n\r\n    /**\r\n     * The internal mesh used by the post-process\r\n     */\r\n    @serializeAsMeshReference()\r\n    public mesh: Mesh;\r\n\r\n    /**\r\n     * @internal\r\n     * VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\r\n     */\r\n    public get useDiffuseColor(): boolean {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n        return false;\r\n    }\r\n\r\n    public set useDiffuseColor(useDiffuseColor: boolean) {\r\n        Logger.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\r\n    }\r\n\r\n    /**\r\n     * Array containing the excluded meshes not rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public excludedMeshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * Array containing the only meshes rendered in the internal pass.\r\n     * If this array is not empty, only the meshes from this array are rendered in the internal pass\r\n     */\r\n    @serialize()\r\n    public includedMeshes = new Array<AbstractMesh>();\r\n\r\n    /**\r\n     * Controls the overall intensity of the post-process\r\n     */\r\n    @serialize()\r\n    public exposure = 0.3;\r\n\r\n    /**\r\n     * Dissipates each sample's contribution in range [0, 1]\r\n     */\r\n    @serialize()\r\n    public decay = 0.96815;\r\n\r\n    /**\r\n     * Controls the overall intensity of each sample\r\n     */\r\n    @serialize()\r\n    public weight = 0.58767;\r\n\r\n    /**\r\n     * Controls the density of each sample\r\n     */\r\n    @serialize()\r\n    public density = 0.926;\r\n\r\n    /**\r\n     * @constructor\r\n     * @param name The post-process name\r\n     * @param ratio The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\r\n     * @param camera The camera that the post-process will be attached to\r\n     * @param mesh The mesh used to create the light scattering\r\n     * @param samples The post-process quality, default 100\r\n     * @param samplingMode The post-process filtering mode\r\n     * @param engine The babylon engine\r\n     * @param reusable If the post-process is reusable\r\n     * @param scene The constructor needs a scene reference to initialize internal components. If \"camera\" is null a \"scene\" must be provided\r\n     */\r\n    constructor(\r\n        name: string,\r\n        ratio: any,\r\n        camera: Nullable<Camera>,\r\n        mesh?: Mesh,\r\n        samples: number = 100,\r\n        samplingMode: number = Texture.BILINEAR_SAMPLINGMODE,\r\n        engine?: Engine,\r\n        reusable?: boolean,\r\n        scene?: Scene\r\n    ) {\r\n        super(\r\n            name,\r\n            \"volumetricLightScattering\",\r\n            [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"],\r\n            [\"lightScatteringSampler\"],\r\n            ratio.postProcessRatio || ratio,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            \"#define NUM_SAMPLES \" + samples\r\n        );\r\n        scene = camera?.getScene() ?? scene ?? this._scene; // parameter \"scene\" can be null.\r\n\r\n        engine = scene.getEngine();\r\n        this._viewPort = new Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Configure mesh\r\n        this.mesh = mesh ?? VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\r\n\r\n        // Configure\r\n        this._createPass(scene, ratio.passRatio || ratio);\r\n\r\n        this.onActivate = (camera: Camera) => {\r\n            if (!this.isSupported) {\r\n                this.dispose(camera);\r\n            }\r\n\r\n            this.onActivate = null;\r\n        };\r\n\r\n        this.onApplyObservable.add((effect: Effect) => {\r\n            this._updateMeshScreenCoordinates(<Scene>scene);\r\n\r\n            effect.setTexture(\"lightScatteringSampler\", this._volumetricLightScatteringRTT);\r\n            effect.setFloat(\"exposure\", this.exposure);\r\n            effect.setFloat(\"decay\", this.decay);\r\n            effect.setFloat(\"weight\", this.weight);\r\n            effect.setFloat(\"density\", this.density);\r\n            effect.setVector2(\"meshPositionOnScreen\", this._screenCoordinates);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"VolumetricLightScatteringPostProcess\"\r\n     * @returns \"VolumetricLightScatteringPostProcess\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"VolumetricLightScatteringPostProcess\";\r\n    }\r\n\r\n    private _isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        const mesh = subMesh.getMesh();\r\n\r\n        // Render this.mesh as default\r\n        if (mesh === this.mesh && mesh.material) {\r\n            return mesh.material.isReady(mesh);\r\n        }\r\n\r\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[this._scene.getEngine().currentRenderPassId];\r\n\r\n        if (renderingMaterial) {\r\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\r\n        }\r\n\r\n        const defines = [];\r\n        const attribs = [VertexBuffer.PositionKind];\r\n        const material: any = subMesh.getMaterial();\r\n\r\n        // Alpha test\r\n        if (material) {\r\n            if (material.needAlphaTesting()) {\r\n                defines.push(\"#define ALPHATEST\");\r\n            }\r\n\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n                attribs.push(VertexBuffer.UVKind);\r\n                defines.push(\"#define UV1\");\r\n            }\r\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n                attribs.push(VertexBuffer.UV2Kind);\r\n                defines.push(\"#define UV2\");\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            defines.push(\"#define BonesPerMesh \" + (mesh.skeleton ? mesh.skeleton.bones.length + 1 : 0));\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Instances\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            MaterialHelper.PushAttributesForInstances(attribs);\r\n            if (subMesh.getRenderingMesh().hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n            }\r\n        }\r\n\r\n        // Get correct effect\r\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\r\n        const cachedDefines = drawWrapper.defines;\r\n        const join = defines.join(\"\\n\");\r\n        if (cachedDefines !== join) {\r\n            drawWrapper.setEffect(\r\n                mesh\r\n                    .getScene()\r\n                    .getEngine()\r\n                    .createEffect(\r\n                        \"volumetricLightScatteringPass\",\r\n                        attribs,\r\n                        [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"],\r\n                        [\"diffuseSampler\"],\r\n                        join,\r\n                        undefined,\r\n                        undefined,\r\n                        undefined,\r\n                        { maxSimultaneousMorphTargets: mesh.numBoneInfluencers }\r\n                    ),\r\n                join\r\n            );\r\n        }\r\n\r\n        return drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Sets the new light position for light scattering effect\r\n     * @param position The new custom light position\r\n     */\r\n    public setCustomMeshPosition(position: Vector3): void {\r\n        this.customMeshPosition = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the light position for light scattering effect\r\n     * @returns Vector3 The custom light position\r\n     */\r\n    public getCustomMeshPosition(): Vector3 {\r\n        return this.customMeshPosition;\r\n    }\r\n\r\n    /**\r\n     * Disposes the internal assets and detaches the post-process from the camera\r\n     * @param camera\r\n     */\r\n    public dispose(camera: Camera): void {\r\n        const rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\r\n        if (rttIndex !== -1) {\r\n            camera.getScene().customRenderTargets.splice(rttIndex, 1);\r\n        }\r\n\r\n        this._volumetricLightScatteringRTT.dispose();\r\n        super.dispose(camera);\r\n    }\r\n\r\n    /**\r\n     * Returns the render target texture used by the post-process\r\n     * @returns the render target texture used by the post-process\r\n     */\r\n    public getPass(): RenderTargetTexture {\r\n        return this._volumetricLightScatteringRTT;\r\n    }\r\n\r\n    // Private methods\r\n    private _meshExcluded(mesh: AbstractMesh) {\r\n        if ((this.includedMeshes.length > 0 && this.includedMeshes.indexOf(mesh) === -1) || (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _createPass(scene: Scene, ratio: number): void {\r\n        const engine = scene.getEngine();\r\n\r\n        this._volumetricLightScatteringRTT = new RenderTargetTexture(\r\n            \"volumetricLightScatteringMap\",\r\n            { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio },\r\n            scene,\r\n            false,\r\n            true,\r\n            Constants.TEXTURETYPE_UNSIGNED_INT\r\n        );\r\n        this._volumetricLightScatteringRTT.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._volumetricLightScatteringRTT.renderList = null;\r\n        this._volumetricLightScatteringRTT.renderParticles = false;\r\n        this._volumetricLightScatteringRTT.ignoreCameraViewport = true;\r\n\r\n        const camera = this.getCamera();\r\n        if (camera) {\r\n            camera.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        } else {\r\n            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\r\n        }\r\n\r\n        // Custom render function for submeshes\r\n        const renderSubMesh = (subMesh: SubMesh): void => {\r\n            const renderingMesh = subMesh.getRenderingMesh();\r\n            const effectiveMesh = subMesh.getEffectiveMesh();\r\n            if (this._meshExcluded(renderingMesh)) {\r\n                return;\r\n            }\r\n\r\n            effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\r\n\r\n            const material = subMesh.getMaterial();\r\n\r\n            if (!material) {\r\n                return;\r\n            }\r\n\r\n            const scene = renderingMesh.getScene();\r\n            const engine = scene.getEngine();\r\n\r\n            // Culling\r\n            engine.setState(material.backFaceCulling, undefined, undefined, undefined, material.cullBackFaces);\r\n\r\n            // Managing instances\r\n            const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n\r\n            if (batch.mustReturn) {\r\n                return;\r\n            }\r\n\r\n            const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n            if (this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\r\n\r\n                let drawWrapper = subMesh._getDrawWrapper();\r\n                if (renderingMesh === this.mesh && !drawWrapper) {\r\n                    drawWrapper = material._getDrawWrapper();\r\n                }\r\n\r\n                if (!drawWrapper) {\r\n                    return;\r\n                }\r\n\r\n                const effect = drawWrapper.effect!;\r\n\r\n                engine.enableEffect(drawWrapper);\r\n                if (!hardwareInstancedRendering) {\r\n                    renderingMesh._bind(subMesh, effect, material.fillMode);\r\n                }\r\n\r\n                if (renderingMesh === this.mesh) {\r\n                    material.bind(effectiveMesh.getWorldMatrix(), renderingMesh);\r\n                } else if (renderingMaterial) {\r\n                    renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\r\n                } else {\r\n                    effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n\r\n                    // Alpha test\r\n                    if (material && material.needAlphaTesting()) {\r\n                        const alphaTexture = material.getAlphaTestTexture();\r\n\r\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\r\n\r\n                        if (alphaTexture) {\r\n                            effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\r\n                        }\r\n                    }\r\n\r\n                    // Bones\r\n                    if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {\r\n                        effect.setMatrices(\"mBones\", renderingMesh.skeleton.getTransformMatrices(renderingMesh));\r\n                    }\r\n                }\r\n\r\n                if (hardwareInstancedRendering && renderingMesh.hasThinInstances) {\r\n                    effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\r\n                }\r\n\r\n                // Draw\r\n                renderingMesh._processRendering(effectiveMesh, subMesh, effect, Material.TriangleFillMode, batch, hardwareInstancedRendering, (isInstance, world) => {\r\n                    if (!isInstance) {\r\n                        effect.setMatrix(\"world\", world);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        // Render target texture callbacks\r\n        let savedSceneClearColor: Color4;\r\n        const sceneClearColor = new Color4(0.0, 0.0, 0.0, 1.0);\r\n\r\n        this._volumetricLightScatteringRTT.onBeforeRenderObservable.add((): void => {\r\n            savedSceneClearColor = scene.clearColor;\r\n            scene.clearColor = sceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.onAfterRenderObservable.add((): void => {\r\n            scene.clearColor = savedSceneClearColor;\r\n        });\r\n\r\n        this._volumetricLightScatteringRTT.customIsReadyFunction = (mesh: AbstractMesh, refreshRate: number, preWarm?: boolean) => {\r\n            if ((preWarm || refreshRate === 0) && mesh.subMeshes) {\r\n                for (let i = 0; i < mesh.subMeshes.length; ++i) {\r\n                    const subMesh = mesh.subMeshes[i];\r\n                    const material = subMesh.getMaterial();\r\n                    const renderingMesh = subMesh.getRenderingMesh();\r\n\r\n                    if (!material) {\r\n                        continue;\r\n                    }\r\n\r\n                    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());\r\n                    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null || renderingMesh.hasThinInstances);\r\n\r\n                    if (!this._isReady(subMesh, hardwareInstancedRendering)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        this._volumetricLightScatteringRTT.customRenderFunction = (\r\n            opaqueSubMeshes: SmartArray<SubMesh>,\r\n            alphaTestSubMeshes: SmartArray<SubMesh>,\r\n            transparentSubMeshes: SmartArray<SubMesh>,\r\n            depthOnlySubMeshes: SmartArray<SubMesh>\r\n        ): void => {\r\n            const engine = scene.getEngine();\r\n            let index: number;\r\n\r\n            if (depthOnlySubMeshes.length) {\r\n                engine.setColorWrite(false);\r\n                for (index = 0; index < depthOnlySubMeshes.length; index++) {\r\n                    renderSubMesh(depthOnlySubMeshes.data[index]);\r\n                }\r\n                engine.setColorWrite(true);\r\n            }\r\n\r\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\r\n                renderSubMesh(opaqueSubMeshes.data[index]);\r\n            }\r\n\r\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\r\n                renderSubMesh(alphaTestSubMeshes.data[index]);\r\n            }\r\n\r\n            if (transparentSubMeshes.length) {\r\n                // Sort sub meshes\r\n                for (index = 0; index < transparentSubMeshes.length; index++) {\r\n                    const submesh = transparentSubMeshes.data[index];\r\n                    const boundingInfo = submesh.getBoundingInfo();\r\n\r\n                    if (boundingInfo && scene.activeCamera) {\r\n                        submesh._alphaIndex = submesh.getMesh().alphaIndex;\r\n                        submesh._distanceToCamera = boundingInfo.boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\r\n                    }\r\n                }\r\n\r\n                const sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\r\n                sortedArray.sort((a, b) => {\r\n                    // Alpha index first\r\n                    if (a._alphaIndex > b._alphaIndex) {\r\n                        return 1;\r\n                    }\r\n                    if (a._alphaIndex < b._alphaIndex) {\r\n                        return -1;\r\n                    }\r\n\r\n                    // Then distance to camera\r\n                    if (a._distanceToCamera < b._distanceToCamera) {\r\n                        return 1;\r\n                    }\r\n                    if (a._distanceToCamera > b._distanceToCamera) {\r\n                        return -1;\r\n                    }\r\n\r\n                    return 0;\r\n                });\r\n\r\n                // Render sub meshes\r\n                engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n                for (index = 0; index < sortedArray.length; index++) {\r\n                    renderSubMesh(sortedArray[index]);\r\n                }\r\n                engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n            }\r\n        };\r\n    }\r\n\r\n    private _updateMeshScreenCoordinates(scene: Scene): void {\r\n        const transform = scene.getTransformMatrix();\r\n        let meshPosition: Vector3;\r\n\r\n        if (this.useCustomMeshPosition) {\r\n            meshPosition = this.customMeshPosition;\r\n        } else if (this.attachedNode) {\r\n            meshPosition = this.attachedNode.position;\r\n        } else {\r\n            meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\r\n        }\r\n\r\n        const pos = Vector3.Project(meshPosition, Matrix.Identity(), transform, this._viewPort);\r\n\r\n        this._screenCoordinates.x = pos.x / this._viewPort.width;\r\n        this._screenCoordinates.y = pos.y / this._viewPort.height;\r\n\r\n        if (this.invert) {\r\n            this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\r\n        }\r\n    }\r\n\r\n    // Static methods\r\n    /**\r\n     * Creates a default mesh for the Volumeric Light Scattering post-process\r\n     * @param name The mesh name\r\n     * @param scene The scene where to create the mesh\r\n     * @returns the default mesh\r\n     */\r\n    public static CreateDefaultMesh(name: string, scene: Scene): Mesh {\r\n        const mesh = CreatePlane(name, { size: 1 }, scene);\r\n        mesh.billboardMode = AbstractMesh.BILLBOARDMODE_ALL;\r\n\r\n        const material = new StandardMaterial(name + \"Material\", scene);\r\n        material.emissiveColor = new Color3(1, 1, 1);\r\n\r\n        mesh.material = material;\r\n\r\n        return mesh;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VolumetricLightScatteringPostProcess\", VolumetricLightScatteringPostProcess);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}