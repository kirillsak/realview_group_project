{"ast":null,"code":"import { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { ReflectionTextureBaseBlock } from \"../Dual/reflectionTextureBaseBlock.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\nimport { Scalar } from \"../../../../Maths/math.scalar.js\";\n/**\n * Block used to implement the reflection module of the PBR material\n */\nexport class ReflectionBlock extends ReflectionTextureBaseBlock {\n  /**\n   * Create a new ReflectionBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name);\n    /**\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\n     * diffuse part of the IBL.\n     */\n    this.useSphericalHarmonics = true;\n    /**\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\n     */\n    this.forceIrradianceInFragment = false;\n    this._isUnique = true;\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\n    this.registerOutput(\"reflection\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, \"ReflectionBlock\"));\n    this.position.addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  _onGenerateOnlyFragmentCodeChanged() {\n    if (this.position.isConnected) {\n      this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\n      console.error(\"The position input must not be connected to be able to switch!\");\n      return false;\n    }\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    super._setTarget();\n    this.getInputByName(\"position\").target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\n    if (this.generateOnlyFragmentCode) {\n      this.forceIrradianceInFragment = true;\n    }\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this.worldPositionConnectionPoint;\n  }\n  /**\n   * Gets the world normal input component\n   */\n  get worldNormal() {\n    return this.worldNormalConnectionPoint;\n  }\n  /**\n   * Gets the world input component\n   */\n  get world() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the camera (or eye) position component\n   */\n  get cameraPosition() {\n    return this.cameraPositionConnectionPoint;\n  }\n  /**\n   * Gets the view input component\n   */\n  get view() {\n    return this.viewConnectionPoint;\n  }\n  /**\n   * Gets the color input component\n   */\n  get color() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the reflection object output component\n   */\n  get reflection() {\n    return this._outputs[0];\n  }\n  /**\n   * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)\n   */\n  get hasTexture() {\n    return !!this._getTexture();\n  }\n  /**\n   * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)\n   */\n  get reflectionColor() {\n    return this.color.isConnected ? this.color.associatedVariableName : \"vec3(1., 1., 1.)\";\n  }\n  _getTexture() {\n    if (this.texture) {\n      return this.texture;\n    }\n    return this._scene.environmentTexture;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    const reflectionTexture = this._getTexture();\n    const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;\n    defines.setValue(\"REFLECTION\", reflection, true);\n    if (!reflection) {\n      return;\n    }\n    defines.setValue(this._defineLODReflectionAlpha, reflectionTexture.lodLevelInAlpha, true);\n    defines.setValue(this._defineLinearSpecularReflection, reflectionTexture.linearSpecularLOD, true);\n    defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ, true);\n    defines.setValue(\"SPHERICAL_HARMONICS\", this.useSphericalHarmonics, true);\n    defines.setValue(\"GAMMAREFLECTION\", reflectionTexture.gammaSpace, true);\n    defines.setValue(\"RGBDREFLECTION\", reflectionTexture.isRGBD, true);\n    if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\n      if (reflectionTexture.isCube) {\n        defines.setValue(\"USESPHERICALFROMREFLECTIONMAP\", true);\n        defines.setValue(\"USEIRRADIANCEMAP\", false);\n        if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {\n          defines.setValue(\"USESPHERICALINVERTEX\", false);\n        } else {\n          defines.setValue(\"USESPHERICALINVERTEX\", true);\n        }\n      }\n    }\n  }\n  bind(effect, nodeMaterial, mesh, subMesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    const reflectionTexture = this._getTexture();\n    if (!reflectionTexture || !subMesh) {\n      return;\n    }\n    if (reflectionTexture.isCube) {\n      effect.setTexture(this._cubeSamplerName, reflectionTexture);\n    } else {\n      effect.setTexture(this._2DSamplerName, reflectionTexture);\n    }\n    const width = reflectionTexture.getSize().width;\n    effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n    effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));\n    const defines = subMesh.materialDefines;\n    const polynomials = reflectionTexture.sphericalPolynomial;\n    if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\n      if (defines.SPHERICAL_HARMONICS) {\n        const preScaledHarmonics = polynomials.preScaledHarmonics;\n        effect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\n        effect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\n        effect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\n        effect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\n        effect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\n        effect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\n        effect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\n        effect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\n        effect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\n      } else {\n        effect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n        effect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n        effect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n        effect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n        effect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n        effect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n        effect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n        effect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n        effect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n      }\n    }\n  }\n  /**\n   * Gets the code to inject in the vertex shader\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  handleVertexSide(state) {\n    let code = super.handleVertexSide(state);\n    state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\n      replaceStrings: [{\n        search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g,\n        replace: \"\"\n      }, {\n        search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g,\n        replace: \"\"\n      }]\n    });\n    const reflectionVectorName = state._getFreeVariableName(\"reflectionVector\");\n    this._vEnvironmentIrradianceName = state._getFreeVariableName(\"vEnvironmentIrradiance\");\n    state._emitVaryingFromString(this._vEnvironmentIrradianceName, \"vec3\", \"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\");\n    state._emitUniformFromString(\"vSphericalL00\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL1_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL10\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL11\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL2_2\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL2_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL20\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL21\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalL22\", \"vec3\", \"SPHERICAL_HARMONICS\");\n    state._emitUniformFromString(\"vSphericalX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalXX_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalYY_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalXY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalYZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    state._emitUniformFromString(\"vSphericalZX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\n    code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\n                vec3 ${reflectionVectorName} = vec3(${this._reflectionMatrixName} * vec4(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;\n                #ifdef ${this._defineOppositeZ}\n                    ${reflectionVectorName}.z *= -1.0;\n                #endif\n                ${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});\n            #endif\\r\\n`;\n    return code;\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param normalVarName name of the existing variable corresponding to the normal\n   * @returns the shader code\n   */\n  getCode(state, normalVarName) {\n    let code = \"\";\n    this.handleFragmentSideInits(state);\n    state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\n      replaceStrings: [{\n        search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g,\n        replace: \"\"\n      }, {\n        search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g,\n        replace: \"\"\n      }]\n    });\n    state._emitFunction(\"sampleReflection\", `\n            #ifdef ${this._define3DName}\n                #define sampleReflection(s, c) textureCube(s, c)\n            #else\n                #define sampleReflection(s, c) texture2D(s, c)\n            #endif\\r\\n`, `//${this.name}`);\n    state._emitFunction(\"sampleReflectionLod\", `\n            #ifdef ${this._define3DName}\n                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\n            #else\n                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\n            #endif\\r\\n`, `//${this.name}`);\n    const computeReflectionCoordsFunc = `\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\n                ${this.handleFragmentSideCodeReflectionCoords(\"worldNormal\", \"worldPos\", true, true)}\n                return ${this._reflectionVectorName};\n            }\\r\\n`;\n    state._emitFunction(\"computeReflectionCoordsPBR\", computeReflectionCoordsFunc, `//${this.name}`);\n    this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName(\"vReflectionMicrosurfaceInfos\");\n    state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, \"vec3\");\n    this._vReflectionInfosName = state._getFreeVariableName(\"vReflectionInfos\");\n    this._vReflectionFilteringInfoName = state._getFreeVariableName(\"vReflectionFilteringInfo\");\n    state._emitUniformFromString(this._vReflectionFilteringInfoName, \"vec2\");\n    code += `#ifdef REFLECTION\n            vec2 ${this._vReflectionInfosName} = vec2(1., 0.);\n\n            reflectionOutParams reflectionOut;\n\n            reflectionBlock(\n                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName}.xyz,\n                ${normalVarName},\n                alphaG,\n                ${this._vReflectionMicrosurfaceInfosName},\n                ${this._vReflectionInfosName},\n                ${this.reflectionColor},\n            #ifdef ANISOTROPIC\n                anisotropicOut,\n            #endif\n            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})\n                NdotVUnclamped,\n            #endif\n            #ifdef ${this._defineLinearSpecularReflection}\n                roughness,\n            #endif\n            #ifdef ${this._define3DName}\n                ${this._cubeSamplerName},\n            #else\n                ${this._2DSamplerName},\n            #endif\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\n                ${this._vEnvironmentIrradianceName},\n            #endif\n            #ifdef USESPHERICALFROMREFLECTIONMAP\n                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\n                    ${this._reflectionMatrixName},\n                #endif\n            #endif\n            #ifdef USEIRRADIANCEMAP\n                irradianceSampler, // ** not handled **\n            #endif\n            #ifndef LODBASEDMICROSFURACE\n                #ifdef ${this._define3DName}\n                    ${this._cubeSamplerName},\n                    ${this._cubeSamplerName},\n                #else\n                    ${this._2DSamplerName},\n                    ${this._2DSamplerName},\n                #endif\n            #endif\n            #ifdef REALTIME_FILTERING\n                ${this._vReflectionFilteringInfoName},\n            #endif\n                reflectionOut\n            );\n        #endif\\r\\n`;\n    return code;\n  }\n  _buildBlock(state) {\n    this._scene = state.sharedData.scene;\n    if (state.target !== NodeMaterialBlockTargets.Fragment) {\n      this._defineLODReflectionAlpha = state._getFreeDefineName(\"LODINREFLECTIONALPHA\");\n      this._defineLinearSpecularReflection = state._getFreeDefineName(\"LINEARSPECULARREFLECTION\");\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (this.texture) {\n      codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};\\r\\n`;\n    }\n    codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};\\r\\n`;\n    codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};\\r\\n`;\n    return codeString;\n  }\n  serialize() {\n    var _a, _b;\n    const serializationObject = super.serialize();\n    serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;\n    serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;\n    serializationObject.gammaSpace = (_b = (_a = this.texture) === null || _a === void 0 ? void 0 : _a.gammaSpace) !== null && _b !== void 0 ? _b : true;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;\n    this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;\n    if (this.texture) {\n      this.texture.gammaSpace = serializationObject.gammaSpace;\n    }\n  }\n}\n__decorate([editableInPropertyPage(\"Spherical Harmonics\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], ReflectionBlock.prototype, \"useSphericalHarmonics\", void 0);\n__decorate([editableInPropertyPage(\"Force irradiance in fragment\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    update: true\n  }\n})], ReflectionBlock.prototype, \"forceIrradianceInFragment\", void 0);\nRegisterClass(\"BABYLON.ReflectionBlock\", ReflectionBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","NodeMaterialConnectionPointCustomObject","ReflectionTextureBaseBlock","Texture","editableInPropertyPage","PropertyTypeForEdition","Scalar","ReflectionBlock","constructor","name","_isUnique","registerInput","AutoDetect","Vertex","Matrix","Color3","Fragment","registerOutput","Object","Output","position","addExcludedConnectionPointFromAllowedTypes","Vector3","Vector4","_onGenerateOnlyFragmentCodeChanged","isConnected","generateOnlyFragmentCode","console","error","_setTarget","getInputByName","target","forceIrradianceInFragment","getClassName","_inputs","worldPosition","worldPositionConnectionPoint","worldNormal","worldNormalConnectionPoint","world","cameraPosition","cameraPositionConnectionPoint","view","viewConnectionPoint","color","reflection","_outputs","hasTexture","_getTexture","reflectionColor","associatedVariableName","texture","_scene","environmentTexture","prepareDefines","mesh","nodeMaterial","defines","reflectionTexture","getTextureMatrix","setValue","_defineLODReflectionAlpha","lodLevelInAlpha","_defineLinearSpecularReflection","linearSpecularLOD","_defineOppositeZ","useRightHandedSystem","invertZ","useSphericalHarmonics","gammaSpace","isRGBD","coordinatesMode","SKYBOX_MODE","isCube","getEngine","getCaps","maxVaryingVectors","bind","effect","subMesh","setTexture","_cubeSamplerName","_2DSamplerName","width","getSize","setFloat3","_vReflectionMicrosurfaceInfosName","lodGenerationScale","lodGenerationOffset","setFloat2","_vReflectionFilteringInfoName","Log2","materialDefines","polynomials","sphericalPolynomial","USESPHERICALFROMREFLECTIONMAP","SPHERICAL_HARMONICS","preScaledHarmonics","setVector3","l00","l1_1","l10","l11","l2_2","l2_1","l20","l21","l22","x","y","z","xx","zz","yy","xy","yz","zx","handleVertexSide","state","code","_emitFunctionFromInclude","replaceStrings","search","replace","reflectionVectorName","_getFreeVariableName","_vEnvironmentIrradianceName","_emitVaryingFromString","_emitUniformFromString","_reflectionMatrixName","getCode","normalVarName","handleFragmentSideInits","_emitFunction","_define3DName","computeReflectionCoordsFunc","handleFragmentSideCodeReflectionCoords","_reflectionVectorName","_vReflectionInfosName","_worldPositionNameInFragmentOnlyMode","_defineSkyboxName","_buildBlock","sharedData","scene","_getFreeDefineName","_dumpPropertiesCode","codeString","_codeVariableName","serialize","serializationObject","_deserialize","rootUrl","__decorate","Boolean","notifiers","update"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/PBR/reflectionBlock.ts"],"sourcesContent":["import { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { ReflectionTextureBaseBlock } from \"../Dual/reflectionTextureBaseBlock\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { SubMesh } from \"../../../../Meshes/subMesh\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { Scalar } from \"../../../../Maths/math.scalar\";\r\n\r\n/**\r\n * Block used to implement the reflection module of the PBR material\r\n */\r\nexport class ReflectionBlock extends ReflectionTextureBaseBlock {\r\n    /** @internal */\r\n    public _defineLODReflectionAlpha: string;\r\n    /** @internal */\r\n    public _defineLinearSpecularReflection: string;\r\n    private _vEnvironmentIrradianceName: string;\r\n    /** @internal */\r\n    public _vReflectionMicrosurfaceInfosName: string;\r\n    /** @internal */\r\n    public _vReflectionInfosName: string;\r\n    /** @internal */\r\n    public _vReflectionFilteringInfoName: string;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public cameraPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public viewConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Defines if the material uses spherical harmonics vs spherical polynomials for the\r\n     * diffuse part of the IBL.\r\n     */\r\n    @editableInPropertyPage(\"Spherical Harmonics\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public useSphericalHarmonics: boolean = true;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take bump in account.\r\n     */\r\n    @editableInPropertyPage(\"Force irradiance in fragment\", PropertyTypeForEdition.Boolean, \"ADVANCED\", { notifiers: { update: true } })\r\n    public forceIrradianceInFragment: boolean = false;\r\n\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        if (this.position.isConnected) {\r\n            this.generateOnlyFragmentCode = !this.generateOnlyFragmentCode;\r\n            console.error(\"The position input must not be connected to be able to switch!\");\r\n            return false;\r\n        }\r\n\r\n        this._setTarget();\r\n\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        super._setTarget();\r\n        this.getInputByName(\"position\")!.target = this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.Vertex;\r\n        if (this.generateOnlyFragmentCode) {\r\n            this.forceIrradianceInFragment = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"world\", NodeMaterialBlockConnectionPointTypes.Matrix, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerInput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3, true, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this.registerOutput(\r\n            \"reflection\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"reflection\", this, NodeMaterialConnectionPointDirection.Output, ReflectionBlock, \"ReflectionBlock\")\r\n        );\r\n\r\n        this.position.addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this.worldPositionConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public get worldNormal(): NodeMaterialConnectionPoint {\r\n        return this.worldNormalConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public get world(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public get cameraPosition(): NodeMaterialConnectionPoint {\r\n        return this.cameraPositionConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public get view(): NodeMaterialConnectionPoint {\r\n        return this.viewConnectionPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the color input component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection object output component\r\n     */\r\n    public get reflection(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the block has a texture (either its own texture or the environment texture from the scene, if set)\r\n     */\r\n    public get hasTexture(): boolean {\r\n        return !!this._getTexture();\r\n    }\r\n\r\n    /**\r\n     * Gets the reflection color (either the name of the variable if the color input is connected, else a default value)\r\n     */\r\n    public get reflectionColor(): string {\r\n        return this.color.isConnected ? this.color.associatedVariableName : \"vec3(1., 1., 1.)\";\r\n    }\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        if (this.texture) {\r\n            return this.texture;\r\n        }\r\n\r\n        return this._scene.environmentTexture;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        const reflectionTexture = this._getTexture();\r\n        const reflection = reflectionTexture && reflectionTexture.getTextureMatrix;\r\n\r\n        defines.setValue(\"REFLECTION\", reflection, true);\r\n\r\n        if (!reflection) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._defineLODReflectionAlpha, reflectionTexture!.lodLevelInAlpha, true);\r\n        defines.setValue(this._defineLinearSpecularReflection, reflectionTexture!.linearSpecularLOD, true);\r\n        defines.setValue(this._defineOppositeZ, this._scene.useRightHandedSystem ? !reflectionTexture!.invertZ : reflectionTexture!.invertZ, true);\r\n\r\n        defines.setValue(\"SPHERICAL_HARMONICS\", this.useSphericalHarmonics, true);\r\n        defines.setValue(\"GAMMAREFLECTION\", reflectionTexture!.gammaSpace, true);\r\n        defines.setValue(\"RGBDREFLECTION\", reflectionTexture!.isRGBD, true);\r\n\r\n        if (reflectionTexture && reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\r\n            if (reflectionTexture.isCube) {\r\n                defines.setValue(\"USESPHERICALFROMREFLECTIONMAP\", true);\r\n                defines.setValue(\"USEIRRADIANCEMAP\", false);\r\n                if (this.forceIrradianceInFragment || this._scene.getEngine().getCaps().maxVaryingVectors <= 8) {\r\n                    defines.setValue(\"USESPHERICALINVERTEX\", false);\r\n                } else {\r\n                    defines.setValue(\"USESPHERICALINVERTEX\", true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh, subMesh?: SubMesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        const reflectionTexture = this._getTexture();\r\n\r\n        if (!reflectionTexture || !subMesh) {\r\n            return;\r\n        }\r\n\r\n        if (reflectionTexture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, reflectionTexture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, reflectionTexture);\r\n        }\r\n\r\n        const width = reflectionTexture.getSize().width;\r\n\r\n        effect.setFloat3(this._vReflectionMicrosurfaceInfosName, width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\r\n        effect.setFloat2(this._vReflectionFilteringInfoName, width, Scalar.Log2(width));\r\n\r\n        const defines = subMesh.materialDefines as NodeMaterialDefines;\r\n\r\n        const polynomials = reflectionTexture.sphericalPolynomial;\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\r\n            if (defines.SPHERICAL_HARMONICS) {\r\n                const preScaledHarmonics = polynomials.preScaledHarmonics;\r\n                effect.setVector3(\"vSphericalL00\", preScaledHarmonics.l00);\r\n                effect.setVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\r\n                effect.setVector3(\"vSphericalL10\", preScaledHarmonics.l10);\r\n                effect.setVector3(\"vSphericalL11\", preScaledHarmonics.l11);\r\n                effect.setVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\r\n                effect.setVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\r\n                effect.setVector3(\"vSphericalL20\", preScaledHarmonics.l20);\r\n                effect.setVector3(\"vSphericalL21\", preScaledHarmonics.l21);\r\n                effect.setVector3(\"vSphericalL22\", preScaledHarmonics.l22);\r\n            } else {\r\n                effect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\r\n                effect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\r\n                effect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\r\n                effect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\r\n                effect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\r\n                effect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\r\n                effect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        let code = super.handleVertexSide(state);\r\n\r\n        state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\r\n            replaceStrings: [\r\n                { search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g, replace: \"\" },\r\n                { search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g, replace: \"\" },\r\n            ],\r\n        });\r\n\r\n        const reflectionVectorName = state._getFreeVariableName(\"reflectionVector\");\r\n\r\n        this._vEnvironmentIrradianceName = state._getFreeVariableName(\"vEnvironmentIrradiance\");\r\n\r\n        state._emitVaryingFromString(this._vEnvironmentIrradianceName, \"vec3\", \"defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\");\r\n\r\n        state._emitUniformFromString(\"vSphericalL00\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL1_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL10\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL11\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL2_2\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL2_1\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL20\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL21\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n        state._emitUniformFromString(\"vSphericalL22\", \"vec3\", \"SPHERICAL_HARMONICS\");\r\n\r\n        state._emitUniformFromString(\"vSphericalX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalXX_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalYY_ZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalXY\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalYZ\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n        state._emitUniformFromString(\"vSphericalZX\", \"vec3\", \"SPHERICAL_HARMONICS\", true);\r\n\r\n        code += `#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)\r\n                vec3 ${reflectionVectorName} = vec3(${this._reflectionMatrixName} * vec4(normalize(${this.worldNormal.associatedVariableName}).xyz, 0)).xyz;\r\n                #ifdef ${this._defineOppositeZ}\r\n                    ${reflectionVectorName}.z *= -1.0;\r\n                #endif\r\n                ${this._vEnvironmentIrradianceName} = computeEnvironmentIrradiance(${reflectionVectorName});\r\n            #endif\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param normalVarName name of the existing variable corresponding to the normal\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, normalVarName: string): string {\r\n        let code = \"\";\r\n\r\n        this.handleFragmentSideInits(state);\r\n\r\n        state._emitFunctionFromInclude(\"harmonicsFunctions\", `//${this.name}`, {\r\n            replaceStrings: [\r\n                { search: /uniform vec3 vSphericalL00;[\\s\\S]*?uniform vec3 vSphericalL22;/g, replace: \"\" },\r\n                { search: /uniform vec3 vSphericalX;[\\s\\S]*?uniform vec3 vSphericalZX;/g, replace: \"\" },\r\n            ],\r\n        });\r\n\r\n        state._emitFunction(\r\n            \"sampleReflection\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleReflection(s, c) textureCube(s, c)\r\n            #else\r\n                #define sampleReflection(s, c) texture2D(s, c)\r\n            #endif\\r\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        state._emitFunction(\r\n            \"sampleReflectionLod\",\r\n            `\r\n            #ifdef ${this._define3DName}\r\n                #define sampleReflectionLod(s, c, l) textureCubeLodEXT(s, c, l)\r\n            #else\r\n                #define sampleReflectionLod(s, c, l) texture2DLodEXT(s, c, l)\r\n            #endif\\r\\n`,\r\n            `//${this.name}`\r\n        );\r\n\r\n        const computeReflectionCoordsFunc = `\r\n            vec3 computeReflectionCoordsPBR(vec4 worldPos, vec3 worldNormal) {\r\n                ${this.handleFragmentSideCodeReflectionCoords(\"worldNormal\", \"worldPos\", true, true)}\r\n                return ${this._reflectionVectorName};\r\n            }\\r\\n`;\r\n\r\n        state._emitFunction(\"computeReflectionCoordsPBR\", computeReflectionCoordsFunc, `//${this.name}`);\r\n\r\n        this._vReflectionMicrosurfaceInfosName = state._getFreeVariableName(\"vReflectionMicrosurfaceInfos\");\r\n\r\n        state._emitUniformFromString(this._vReflectionMicrosurfaceInfosName, \"vec3\");\r\n\r\n        this._vReflectionInfosName = state._getFreeVariableName(\"vReflectionInfos\");\r\n\r\n        this._vReflectionFilteringInfoName = state._getFreeVariableName(\"vReflectionFilteringInfo\");\r\n\r\n        state._emitUniformFromString(this._vReflectionFilteringInfoName, \"vec2\");\r\n\r\n        code += `#ifdef REFLECTION\r\n            vec2 ${this._vReflectionInfosName} = vec2(1., 0.);\r\n\r\n            reflectionOutParams reflectionOut;\r\n\r\n            reflectionBlock(\r\n                ${this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName}.xyz,\r\n                ${normalVarName},\r\n                alphaG,\r\n                ${this._vReflectionMicrosurfaceInfosName},\r\n                ${this._vReflectionInfosName},\r\n                ${this.reflectionColor},\r\n            #ifdef ANISOTROPIC\r\n                anisotropicOut,\r\n            #endif\r\n            #if defined(${this._defineLODReflectionAlpha}) && !defined(${this._defineSkyboxName})\r\n                NdotVUnclamped,\r\n            #endif\r\n            #ifdef ${this._defineLinearSpecularReflection}\r\n                roughness,\r\n            #endif\r\n            #ifdef ${this._define3DName}\r\n                ${this._cubeSamplerName},\r\n            #else\r\n                ${this._2DSamplerName},\r\n            #endif\r\n            #if defined(NORMAL) && defined(USESPHERICALINVERTEX)\r\n                ${this._vEnvironmentIrradianceName},\r\n            #endif\r\n            #ifdef USESPHERICALFROMREFLECTIONMAP\r\n                #if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)\r\n                    ${this._reflectionMatrixName},\r\n                #endif\r\n            #endif\r\n            #ifdef USEIRRADIANCEMAP\r\n                irradianceSampler, // ** not handled **\r\n            #endif\r\n            #ifndef LODBASEDMICROSFURACE\r\n                #ifdef ${this._define3DName}\r\n                    ${this._cubeSamplerName},\r\n                    ${this._cubeSamplerName},\r\n                #else\r\n                    ${this._2DSamplerName},\r\n                    ${this._2DSamplerName},\r\n                #endif\r\n            #endif\r\n            #ifdef REALTIME_FILTERING\r\n                ${this._vReflectionFilteringInfoName},\r\n            #endif\r\n                reflectionOut\r\n            );\r\n        #endif\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        this._scene = state.sharedData.scene;\r\n\r\n        if (state.target !== NodeMaterialBlockTargets.Fragment) {\r\n            this._defineLODReflectionAlpha = state._getFreeDefineName(\"LODINREFLECTIONALPHA\");\r\n            this._defineLinearSpecularReflection = state._getFreeDefineName(\"LINEARSPECULARREFLECTION\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (this.texture) {\r\n            codeString += `${this._codeVariableName}.texture.gammaSpace = ${this.texture.gammaSpace};\\r\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.useSphericalHarmonics = ${this.useSphericalHarmonics};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.forceIrradianceInFragment = ${this.forceIrradianceInFragment};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.useSphericalHarmonics = this.useSphericalHarmonics;\r\n        serializationObject.forceIrradianceInFragment = this.forceIrradianceInFragment;\r\n        serializationObject.gammaSpace = this.texture?.gammaSpace ?? true;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.useSphericalHarmonics = serializationObject.useSphericalHarmonics;\r\n        this.forceIrradianceInFragment = serializationObject.forceIrradianceInFragment;\r\n        if (this.texture) {\r\n            this.texture.gammaSpace = serializationObject.gammaSpace;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionBlock\", ReflectionBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}