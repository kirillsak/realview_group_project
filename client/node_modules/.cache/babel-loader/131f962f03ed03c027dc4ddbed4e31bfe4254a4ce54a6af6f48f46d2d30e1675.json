{"ast":null,"code":"import { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { PrecisionDate } from \"../../Misc/precisionDate.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\n */\nexport class AutoRotationBehavior {\n  constructor() {\n    this._zoomStopsAnimation = false;\n    this._idleRotationSpeed = 0.05;\n    this._idleRotationWaitTime = 2000;\n    this._idleRotationSpinupTime = 2000;\n    this.targetAlpha = null;\n    this._isPointerDown = false;\n    this._lastFrameTime = null;\n    this._lastInteractionTime = -Infinity;\n    this._cameraRotationSpeed = 0;\n    this._lastFrameRadius = 0;\n  }\n  /**\n   * Gets the name of the behavior.\n   */\n  get name() {\n    return \"AutoRotation\";\n  }\n  /**\n   * Sets the flag that indicates if user zooming should stop animation.\n   */\n  set zoomStopsAnimation(flag) {\n    this._zoomStopsAnimation = flag;\n  }\n  /**\n   * Gets the flag that indicates if user zooming should stop animation.\n   */\n  get zoomStopsAnimation() {\n    return this._zoomStopsAnimation;\n  }\n  /**\n   * Sets the default speed at which the camera rotates around the model.\n   */\n  set idleRotationSpeed(speed) {\n    this._idleRotationSpeed = speed;\n  }\n  /**\n   * Gets the default speed at which the camera rotates around the model.\n   */\n  get idleRotationSpeed() {\n    return this._idleRotationSpeed;\n  }\n  /**\n   * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\n   */\n  set idleRotationWaitTime(time) {\n    this._idleRotationWaitTime = time;\n  }\n  /**\n   * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\n   */\n  get idleRotationWaitTime() {\n    return this._idleRotationWaitTime;\n  }\n  /**\n   * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\n   */\n  set idleRotationSpinupTime(time) {\n    this._idleRotationSpinupTime = time;\n  }\n  /**\n   * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\n   */\n  get idleRotationSpinupTime() {\n    return this._idleRotationSpinupTime;\n  }\n  /**\n   * Gets a value indicating if the camera is currently rotating because of this behavior\n   */\n  get rotationInProgress() {\n    return Math.abs(this._cameraRotationSpeed) > 0;\n  }\n  /**\n   * Initializes the behavior.\n   */\n  init() {\n    // Do nothing\n  }\n  /**\n   * Attaches the behavior to its arc rotate camera.\n   * @param camera Defines the camera to attach the behavior to\n   */\n  attach(camera) {\n    this._attachedCamera = camera;\n    const scene = this._attachedCamera.getScene();\n    this._onPrePointerObservableObserver = scene.onPrePointerObservable.add(pointerInfoPre => {\n      if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\n        this._isPointerDown = true;\n        return;\n      }\n      if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\n        this._isPointerDown = false;\n      }\n    });\n    this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\n      if (this._reachTargetAlpha()) {\n        return;\n      }\n      const now = PrecisionDate.Now;\n      let dt = 0;\n      if (this._lastFrameTime != null) {\n        dt = now - this._lastFrameTime;\n      }\n      this._lastFrameTime = now;\n      // Stop the animation if there is user interaction and the animation should stop for this interaction\n      this._applyUserInteraction();\n      const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\n      const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\n      this._cameraRotationSpeed = this._idleRotationSpeed * scale;\n      // Step camera rotation by rotation speed\n      if (this._attachedCamera) {\n        this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\n      }\n    });\n  }\n  /**\n   * Detaches the behavior from its current arc rotate camera.\n   */\n  detach() {\n    if (!this._attachedCamera) {\n      return;\n    }\n    const scene = this._attachedCamera.getScene();\n    if (this._onPrePointerObservableObserver) {\n      scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\n    }\n    this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\n    this._attachedCamera = null;\n  }\n  /**\n   * Force-reset the last interaction time\n   * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\n   */\n  resetLastInteractionTime(customTime) {\n    this._lastInteractionTime = customTime !== null && customTime !== void 0 ? customTime : PrecisionDate.Now;\n  }\n  /**\n   * Returns true if camera alpha reaches the target alpha\n   * @returns true if camera alpha reaches the target alpha\n   */\n  _reachTargetAlpha() {\n    if (this._attachedCamera && this.targetAlpha) {\n      return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\n    }\n    return false;\n  }\n  /**\n   * Returns true if user is scrolling.\n   * @returns true if user is scrolling.\n   */\n  _userIsZooming() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialRadiusOffset !== 0;\n  }\n  _shouldAnimationStopForInteraction() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    let zoomHasHitLimit = false;\n    if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\n      zoomHasHitLimit = true;\n    }\n    // Update the record of previous radius - works as an approx. indicator of hitting radius limits\n    this._lastFrameRadius = this._attachedCamera.radius;\n    return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\n  }\n  /**\n   *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\n   */\n  _applyUserInteraction() {\n    if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\n      this._lastInteractionTime = PrecisionDate.Now;\n    }\n  }\n  // Tools\n  _userIsMoving() {\n    if (!this._attachedCamera) {\n      return false;\n    }\n    return this._attachedCamera.inertialAlphaOffset !== 0 || this._attachedCamera.inertialBetaOffset !== 0 || this._attachedCamera.inertialRadiusOffset !== 0 || this._attachedCamera.inertialPanningX !== 0 || this._attachedCamera.inertialPanningY !== 0 || this._isPointerDown;\n  }\n}","map":{"version":3,"mappings":"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","names":["PointerEventTypes","PrecisionDate","Epsilon","AutoRotationBehavior","constructor","Infinity","name","zoomStopsAnimation","flag","_zoomStopsAnimation","idleRotationSpeed","speed","_idleRotationSpeed","idleRotationWaitTime","time","_idleRotationWaitTime","idleRotationSpinupTime","_idleRotationSpinupTime","rotationInProgress","Math","abs","_cameraRotationSpeed","init","attach","camera","_attachedCamera","scene","getScene","_onPrePointerObservableObserver","onPrePointerObservable","add","pointerInfoPre","type","POINTERDOWN","_isPointerDown","POINTERUP","_onAfterCheckInputsObserver","onAfterCheckInputsObservable","_reachTargetAlpha","now","Now","dt","_lastFrameTime","_applyUserInteraction","timeToRotation","_lastInteractionTime","scale","max","min","alpha","detach","remove","resetLastInteractionTime","customTime","targetAlpha","_userIsZooming","inertialRadiusOffset","_shouldAnimationStopForInteraction","zoomHasHitLimit","_lastFrameRadius","radius","_userIsMoving","inertialAlphaOffset","inertialBetaOffset","inertialPanningX","inertialPanningY"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Cameras/autoRotationBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../../Behaviors/behavior\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { PrecisionDate } from \"../../Misc/precisionDate\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * The autoRotation behavior (AutoRotationBehavior) is designed to create a smooth rotation of an ArcRotateCamera when there is no user interaction.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors/cameraBehaviors#autorotation-behavior\r\n */\r\nexport class AutoRotationBehavior implements Behavior<ArcRotateCamera> {\r\n    /**\r\n     * Gets the name of the behavior.\r\n     */\r\n    public get name(): string {\r\n        return \"AutoRotation\";\r\n    }\r\n\r\n    private _zoomStopsAnimation = false;\r\n    private _idleRotationSpeed = 0.05;\r\n    private _idleRotationWaitTime = 2000;\r\n    private _idleRotationSpinupTime = 2000;\r\n\r\n    public targetAlpha: Nullable<number> = null;\r\n\r\n    /**\r\n     * Sets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public set zoomStopsAnimation(flag: boolean) {\r\n        this._zoomStopsAnimation = flag;\r\n    }\r\n\r\n    /**\r\n     * Gets the flag that indicates if user zooming should stop animation.\r\n     */\r\n    public get zoomStopsAnimation(): boolean {\r\n        return this._zoomStopsAnimation;\r\n    }\r\n\r\n    /**\r\n     * Sets the default speed at which the camera rotates around the model.\r\n     */\r\n    public set idleRotationSpeed(speed: number) {\r\n        this._idleRotationSpeed = speed;\r\n    }\r\n\r\n    /**\r\n     * Gets the default speed at which the camera rotates around the model.\r\n     */\r\n    public get idleRotationSpeed() {\r\n        return this._idleRotationSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public set idleRotationWaitTime(time: number) {\r\n        this._idleRotationWaitTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.\r\n     */\r\n    public get idleRotationWaitTime() {\r\n        return this._idleRotationWaitTime;\r\n    }\r\n\r\n    /**\r\n     * Sets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public set idleRotationSpinupTime(time: number) {\r\n        this._idleRotationSpinupTime = time;\r\n    }\r\n\r\n    /**\r\n     * Gets the time (milliseconds) to take to spin up to the full idle rotation speed.\r\n     */\r\n    public get idleRotationSpinupTime() {\r\n        return this._idleRotationSpinupTime;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the camera is currently rotating because of this behavior\r\n     */\r\n    public get rotationInProgress(): boolean {\r\n        return Math.abs(this._cameraRotationSpeed) > 0;\r\n    }\r\n\r\n    // Default behavior functions\r\n    private _onPrePointerObservableObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _onAfterCheckInputsObserver: Nullable<Observer<Camera>>;\r\n    private _attachedCamera: Nullable<ArcRotateCamera>;\r\n    private _isPointerDown = false;\r\n    private _lastFrameTime: Nullable<number> = null;\r\n    private _lastInteractionTime = -Infinity;\r\n    private _cameraRotationSpeed: number = 0;\r\n\r\n    /**\r\n     * Initializes the behavior.\r\n     */\r\n    public init(): void {\r\n        // Do nothing\r\n    }\r\n\r\n    /**\r\n     * Attaches the behavior to its arc rotate camera.\r\n     * @param camera Defines the camera to attach the behavior to\r\n     */\r\n    public attach(camera: ArcRotateCamera): void {\r\n        this._attachedCamera = camera;\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        this._onPrePointerObservableObserver = scene.onPrePointerObservable.add((pointerInfoPre) => {\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERDOWN) {\r\n                this._isPointerDown = true;\r\n                return;\r\n            }\r\n\r\n            if (pointerInfoPre.type === PointerEventTypes.POINTERUP) {\r\n                this._isPointerDown = false;\r\n            }\r\n        });\r\n\r\n        this._onAfterCheckInputsObserver = camera.onAfterCheckInputsObservable.add(() => {\r\n            if (this._reachTargetAlpha()) {\r\n                return;\r\n            }\r\n            const now = PrecisionDate.Now;\r\n            let dt = 0;\r\n            if (this._lastFrameTime != null) {\r\n                dt = now - this._lastFrameTime;\r\n            }\r\n            this._lastFrameTime = now;\r\n\r\n            // Stop the animation if there is user interaction and the animation should stop for this interaction\r\n            this._applyUserInteraction();\r\n\r\n            const timeToRotation = now - this._lastInteractionTime - this._idleRotationWaitTime;\r\n            const scale = Math.max(Math.min(timeToRotation / this._idleRotationSpinupTime, 1), 0);\r\n            this._cameraRotationSpeed = this._idleRotationSpeed * scale;\r\n\r\n            // Step camera rotation by rotation speed\r\n            if (this._attachedCamera) {\r\n                this._attachedCamera.alpha -= this._cameraRotationSpeed * (dt / 1000);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Detaches the behavior from its current arc rotate camera.\r\n     */\r\n    public detach(): void {\r\n        if (!this._attachedCamera) {\r\n            return;\r\n        }\r\n        const scene = this._attachedCamera.getScene();\r\n\r\n        if (this._onPrePointerObservableObserver) {\r\n            scene.onPrePointerObservable.remove(this._onPrePointerObservableObserver);\r\n        }\r\n\r\n        this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver);\r\n        this._attachedCamera = null;\r\n    }\r\n\r\n    /**\r\n     * Force-reset the last interaction time\r\n     * @param customTime an optional time that will be used instead of the current last interaction time. For example `Date.now()`\r\n     */\r\n    public resetLastInteractionTime(customTime?: number): void {\r\n        this._lastInteractionTime = customTime ?? PrecisionDate.Now;\r\n    }\r\n\r\n    /**\r\n     * Returns true if camera alpha reaches the target alpha\r\n     * @returns true if camera alpha reaches the target alpha\r\n     */\r\n    private _reachTargetAlpha(): boolean {\r\n        if (this._attachedCamera && this.targetAlpha) {\r\n            return Math.abs(this._attachedCamera.alpha - this.targetAlpha) < Epsilon;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns true if user is scrolling.\r\n     * @returns true if user is scrolling.\r\n     */\r\n    private _userIsZooming(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n        return this._attachedCamera.inertialRadiusOffset !== 0;\r\n    }\r\n\r\n    private _lastFrameRadius = 0;\r\n    private _shouldAnimationStopForInteraction(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        let zoomHasHitLimit = false;\r\n        if (this._lastFrameRadius === this._attachedCamera.radius && this._attachedCamera.inertialRadiusOffset !== 0) {\r\n            zoomHasHitLimit = true;\r\n        }\r\n\r\n        // Update the record of previous radius - works as an approx. indicator of hitting radius limits\r\n        this._lastFrameRadius = this._attachedCamera.radius;\r\n        return this._zoomStopsAnimation ? zoomHasHitLimit : this._userIsZooming();\r\n    }\r\n\r\n    /**\r\n     *  Applies any current user interaction to the camera. Takes into account maximum alpha rotation.\r\n     */\r\n    private _applyUserInteraction(): void {\r\n        if (this._userIsMoving() && !this._shouldAnimationStopForInteraction()) {\r\n            this._lastInteractionTime = PrecisionDate.Now;\r\n        }\r\n    }\r\n\r\n    // Tools\r\n    private _userIsMoving(): boolean {\r\n        if (!this._attachedCamera) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this._attachedCamera.inertialAlphaOffset !== 0 ||\r\n            this._attachedCamera.inertialBetaOffset !== 0 ||\r\n            this._attachedCamera.inertialRadiusOffset !== 0 ||\r\n            this._attachedCamera.inertialPanningX !== 0 ||\r\n            this._attachedCamera.inertialPanningY !== 0 ||\r\n            this._isPointerDown\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}