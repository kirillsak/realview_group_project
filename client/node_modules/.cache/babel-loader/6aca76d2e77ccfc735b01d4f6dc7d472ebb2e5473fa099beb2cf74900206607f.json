{"ast":null,"code":"import { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { DeepCopier } from \"../../Misc/deepCopier.js\";\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\n */\nexport class SphereParticleEmitter {\n  /**\n   * Creates a new instance SphereParticleEmitter\n   * @param radius the radius of the emission sphere (1 by default)\n   * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1]\n   */\n  constructor(\n  /**\n   * The radius of the emission sphere.\n   */\n  radius = 1,\n  /**\n   * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\n   */\n  radiusRange = 1,\n  /**\n   * How much to randomize the particle direction [0-1].\n   */\n  directionRandomizer = 0) {\n    this.radius = radius;\n    this.radiusRange = radiusRange;\n    this.directionRandomizer = directionRandomizer;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\n    const randX = Scalar.RandomRange(0, this.directionRandomizer);\n    const randY = Scalar.RandomRange(0, this.directionRandomizer);\n    const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    direction.x += randX;\n    direction.y += randY;\n    direction.z += randZ;\n    direction.normalize();\n    if (isLocal) {\n      directionToUpdate.copyFrom(direction);\n      return;\n    }\n    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\n    const v = Scalar.RandomRange(0, 1.0);\n    const phi = Scalar.RandomRange(0, 2 * Math.PI);\n    const theta = Math.acos(2 * v - 1);\n    const randX = randRadius * Math.cos(phi) * Math.sin(theta);\n    const randY = randRadius * Math.cos(theta);\n    const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\n    if (isLocal) {\n      positionToUpdate.copyFromFloats(randX, randY, randZ);\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define SPHEREEMITTER\";\n  }\n  /**\n   * Returns the string \"SphereParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"SphereParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this.radius;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.radiusRange = serializationObject.radiusRange;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n  }\n}\n/**\n * Particle emitter emitting particles from the inside of a sphere.\n * It emits the particles randomly between two vectors.\n */\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\n  /**\n   * Creates a new instance SphereDirectedParticleEmitter\n   * @param radius the radius of the emission sphere (1 by default)\n   * @param direction1 the min limit of the emission direction (up vector by default)\n   * @param direction2 the max limit of the emission direction (up vector by default)\n   */\n  constructor(radius = 1,\n  /**\n   * The min limit of the emission direction.\n   */\n  direction1 = new Vector3(0, 1, 0),\n  /**\n   * The max limit of the emission direction.\n   */\n  direction2 = new Vector3(0, 1, 0)) {\n    super(radius);\n    this.direction1 = direction1;\n    this.direction2 = direction2;\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate) {\n    const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\n    const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\n    const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\n    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat(\"radius\", this.radius);\n    uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\n    uboOrEffect.setVector3(\"direction1\", this.direction1);\n    uboOrEffect.setVector3(\"direction2\", this.direction2);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 1);\n    ubo.addUniform(\"radiusRange\", 1);\n    ubo.addUniform(\"direction1\", 3);\n    ubo.addUniform(\"direction2\", 3);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\n  }\n  /**\n   * Returns the string \"SphereDirectedParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"SphereDirectedParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.direction1 = this.direction1.asArray();\n    serializationObject.direction2 = this.direction2.asArray();\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    super.parse(serializationObject);\n    this.direction1.copyFrom(serializationObject.direction1);\n    this.direction2.copyFrom(serializationObject.direction2);\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Scalar","DeepCopier","SphereParticleEmitter","constructor","radius","radiusRange","directionRandomizer","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","direction","position","subtract","getTranslation","normalize","randX","RandomRange","randY","randZ","x","y","z","copyFrom","TransformNormalFromFloatsToRef","startPositionFunction","positionToUpdate","randRadius","v","phi","Math","PI","theta","acos","cos","sin","copyFromFloats","TransformCoordinatesFromFloatsToRef","clone","newOne","DeepCopy","applyToShader","uboOrEffect","setFloat","buildUniformLayout","ubo","addUniform","getEffectDefines","getClassName","serialize","serializationObject","type","parse","SphereDirectedParticleEmitter","direction1","direction2","setVector3","asArray"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/EmitterTypes/sphereParticleEmitter.ts"],"sourcesContent":["import type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles alongside the sphere radius. The emission direction might be randomized.\r\n */\r\nexport class SphereParticleEmitter implements IParticleEmitterType {\r\n    /**\r\n     * Creates a new instance SphereParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param radiusRange the range of the emission sphere [0-1] 0 Surface only, 1 Entire Radius (1 by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1]\r\n     */\r\n    constructor(\r\n        /**\r\n         * The radius of the emission sphere.\r\n         */\r\n        public radius = 1,\r\n        /**\r\n         * The range of emission [0-1] 0 Surface only, 1 Entire Radius.\r\n         */\r\n        public radiusRange = 1,\r\n        /**\r\n         * How much to randomize the particle direction [0-1].\r\n         */\r\n        public directionRandomizer = 0\r\n    ) {}\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        direction.x += randX;\r\n        direction.y += randY;\r\n        direction.z += randZ;\r\n        direction.normalize();\r\n\r\n        if (isLocal) {\r\n            directionToUpdate.copyFrom(direction);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    public startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);\r\n        const v = Scalar.RandomRange(0, 1.0);\r\n        const phi = Scalar.RandomRange(0, 2 * Math.PI);\r\n        const theta = Math.acos(2 * v - 1);\r\n        const randX = randRadius * Math.cos(phi) * Math.sin(theta);\r\n        const randY = randRadius * Math.cos(theta);\r\n        const randZ = randRadius * Math.sin(phi) * Math.sin(theta);\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.copyFromFloats(randX, randY, randZ);\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereParticleEmitter {\r\n        const newOne = new SphereParticleEmitter(this.radius, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this.radius;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.radiusRange = serializationObject.radiusRange;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n    }\r\n}\r\n\r\n/**\r\n * Particle emitter emitting particles from the inside of a sphere.\r\n * It emits the particles randomly between two vectors.\r\n */\r\nexport class SphereDirectedParticleEmitter extends SphereParticleEmitter {\r\n    /**\r\n     * Creates a new instance SphereDirectedParticleEmitter\r\n     * @param radius the radius of the emission sphere (1 by default)\r\n     * @param direction1 the min limit of the emission direction (up vector by default)\r\n     * @param direction2 the max limit of the emission direction (up vector by default)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        /**\r\n         * The min limit of the emission direction.\r\n         */\r\n        public direction1 = new Vector3(0, 1, 0),\r\n        /**\r\n         * The max limit of the emission direction.\r\n         */\r\n        public direction2 = new Vector3(0, 1, 0)\r\n    ) {\r\n        super(radius);\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3): void {\r\n        const randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);\r\n        const randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);\r\n        const randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);\r\n        Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): SphereDirectedParticleEmitter {\r\n        const newOne = new SphereDirectedParticleEmitter(this.radius, this.direction1, this.direction2);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat(\"radius\", this.radius);\r\n        uboOrEffect.setFloat(\"radiusRange\", this.radiusRange);\r\n        uboOrEffect.setVector3(\"direction1\", this.direction1);\r\n        uboOrEffect.setVector3(\"direction2\", this.direction2);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 1);\r\n        ubo.addUniform(\"radiusRange\", 1);\r\n        ubo.addUniform(\"direction1\", 3);\r\n        ubo.addUniform(\"direction2\", 3);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        return \"#define SPHEREEMITTER\\n#define DIRECTEDSPHEREEMITTER\";\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SphereDirectedParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"SphereDirectedParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.direction1 = this.direction1.asArray();\r\n        serializationObject.direction2 = this.direction2.asArray();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        super.parse(serializationObject);\r\n        this.direction1.copyFrom(serializationObject.direction1);\r\n        this.direction2.copyFrom(serializationObject.direction2);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}