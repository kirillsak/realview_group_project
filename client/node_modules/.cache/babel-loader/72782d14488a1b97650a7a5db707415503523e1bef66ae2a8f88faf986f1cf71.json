{"ast":null,"code":"import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math.js\";\n/**\n * Represents one particle of a points cloud system.\n */\nexport class CloudPoint {\n  /**\n   * Creates a Point Cloud object.\n   * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n   * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n   * @param group (PointsGroup) is the group the particle belongs to\n   * @param groupId (integer) is the group identifier in the PCS.\n   * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n   * @param pcs defines the PCS it is associated to\n   */\n  constructor(particleIndex, group, groupId, idxInGroup, pcs) {\n    /**\n     * particle global index\n     */\n    this.idx = 0;\n    /**\n     * The color of the particle\n     */\n    this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n    /**\n     * The world space position of the particle.\n     */\n    this.position = Vector3.Zero();\n    /**\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n     */\n    this.rotation = Vector3.Zero();\n    /**\n     * The uv of the particle.\n     */\n    this.uv = new Vector2(0.0, 0.0);\n    /**\n     * The current speed of the particle.\n     */\n    this.velocity = Vector3.Zero();\n    /**\n     * The pivot point in the particle local space.\n     */\n    this.pivot = Vector3.Zero();\n    /**\n     * Must the particle be translated from its pivot point in its local space ?\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n     * Default : false\n     */\n    this.translateFromPivot = false;\n    /**\n     * Index of this particle in the global \"positions\" array (Internal use)\n     * @internal\n     */\n    this._pos = 0;\n    /**\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\n     */\n    this._ind = 0;\n    /**\n     * Group id of this particle\n     */\n    this.groupId = 0;\n    /**\n     * Index of the particle in its group id (Internal use)\n     */\n    this.idxInGroup = 0;\n    /**\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\n     */\n    this._stillInvisible = false;\n    /**\n     * @internal Last computed particle rotation matrix\n     */\n    this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n    /**\n     * Parent particle Id, if any.\n     * Default null.\n     */\n    this.parentId = null;\n    /**\n     * @internal Internal global position in the PCS.\n     */\n    this._globalPosition = Vector3.Zero();\n    this.idx = particleIndex;\n    this._group = group;\n    this.groupId = groupId;\n    this.idxInGroup = idxInGroup;\n    this._pcs = pcs;\n  }\n  /**\n   * get point size\n   */\n  get size() {\n    return this.size;\n  }\n  /**\n   * Set point size\n   */\n  set size(scale) {\n    this.size = scale;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  get quaternion() {\n    return this.rotationQuaternion;\n  }\n  /**\n   * Legacy support, changed quaternion to rotationQuaternion\n   */\n  set quaternion(q) {\n    this.rotationQuaternion = q;\n  }\n  /**\n   * Returns a boolean. True if the particle intersects a mesh, else false\n   * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n   * @param target is the object (point or mesh) what the intersection is computed against\n   * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n   * @returns true if it intersects\n   */\n  intersectsMesh(target, isSphere) {\n    if (!target.hasBoundingInfo) {\n      return false;\n    }\n    if (!this._pcs.mesh) {\n      throw new Error(\"Point Cloud System doesnt contain the Mesh\");\n    }\n    if (isSphere) {\n      return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n    }\n    const bbox = target.getBoundingInfo().boundingBox;\n    const maxX = bbox.maximumWorld.x;\n    const minX = bbox.minimumWorld.x;\n    const maxY = bbox.maximumWorld.y;\n    const minY = bbox.minimumWorld.y;\n    const maxZ = bbox.maximumWorld.z;\n    const minZ = bbox.minimumWorld.z;\n    const x = this.position.x + this._pcs.mesh.position.x;\n    const y = this.position.y + this._pcs.mesh.position.y;\n    const z = this.position.z + this._pcs.mesh.position.z;\n    return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n  }\n  /**\n   * get the rotation matrix of the particle\n   * @internal\n   */\n  getRotationMatrix(m) {\n    let quaternion;\n    if (this.rotationQuaternion) {\n      quaternion = this.rotationQuaternion;\n    } else {\n      quaternion = TmpVectors.Quaternion[0];\n      const rotation = this.rotation;\n      Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n    }\n    quaternion.toRotationMatrix(m);\n  }\n}\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\nexport class PointsGroup {\n  /**\n   * Creates a points group object. This is an internal reference to produce particles for the PCS.\n   * PCS internal tool, don't use it manually.\n   * @internal\n   */\n  constructor(id, posFunction) {\n    this.groupId = id;\n    this._positionFunction = posFunction;\n  }\n  /**\n   * Get or set the groupId\n   * @deprecated Please use groupId instead\n   */\n  get groupID() {\n    return this.groupId;\n  }\n  set groupID(groupID) {\n    this.groupId = groupID;\n  }\n}","map":{"version":3,"mappings":"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","names":["Color4","Vector2","Vector3","TmpVectors","Quaternion","CloudPoint","constructor","particleIndex","group","groupId","idxInGroup","pcs","Zero","idx","_group","_pcs","size","scale","quaternion","rotationQuaternion","q","intersectsMesh","target","isSphere","hasBoundingInfo","mesh","Error","getBoundingInfo","boundingSphere","intersectsPoint","position","add","bbox","boundingBox","maxX","maximumWorld","x","minX","minimumWorld","maxY","y","minY","maxZ","z","minZ","getRotationMatrix","m","rotation","RotationYawPitchRollToRef","toRotationMatrix","PointsGroup","id","posFunction","_positionFunction","groupID"],"sourceRoot":"","sources":["../../../../lts/core/generated/Particles/cloudPoint.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math\";\r\nimport { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { PointsCloudSystem } from \"./pointsCloudSystem\";\r\n/**\r\n * Represents one particle of a points cloud system.\r\n */\r\nexport class CloudPoint {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The uv of the particle.\r\n     */\r\n    public uv: Nullable<Vector2> = new Vector2(0.0, 0.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @internal\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * Group this particle belongs to\r\n     */\r\n    public _group: PointsGroup;\r\n    /**\r\n     * Group id of this particle\r\n     */\r\n    public groupId: number = 0;\r\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\r\n    public idxInGroup: number = 0;\r\n    /**\r\n     * @internal Particle BoundingInfo object (Internal use)\r\n     */\r\n    public _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @internal Reference to the PCS that the particle belongs to (Internal use)\r\n     */\r\n    public _pcs: PointsCloudSystem;\r\n    /**\r\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @internal Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * @internal Internal global position in the PCS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a Point Cloud object.\r\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n     * @param group (PointsGroup) is the group the particle belongs to\r\n     * @param groupId (integer) is the group identifier in the PCS.\r\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n     * @param pcs defines the PCS it is associated to\r\n     */\r\n    constructor(particleIndex: number, group: PointsGroup, groupId: number, idxInGroup: number, pcs: PointsCloudSystem) {\r\n        this.idx = particleIndex;\r\n        this._group = group;\r\n        this.groupId = groupId;\r\n        this.idxInGroup = idxInGroup;\r\n        this._pcs = pcs;\r\n    }\r\n\r\n    /**\r\n     * get point size\r\n     */\r\n    public get size(): Vector3 {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Set point size\r\n     */\r\n    public set size(scale: Vector3) {\r\n        this.size = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects a mesh, else false\r\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n     * @param target is the object (point or mesh) what the intersection is computed against\r\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh, isSphere: boolean): boolean {\r\n        if (!target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._pcs.mesh) {\r\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\r\n        }\r\n\r\n        if (isSphere) {\r\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\r\n        }\r\n\r\n        const bbox = target.getBoundingInfo().boundingBox;\r\n\r\n        const maxX = bbox.maximumWorld.x;\r\n        const minX = bbox.minimumWorld.x;\r\n        const maxY = bbox.maximumWorld.y;\r\n        const minY = bbox.minimumWorld.y;\r\n        const maxZ = bbox.maximumWorld.z;\r\n        const minZ = bbox.minimumWorld.z;\r\n\r\n        const x = this.position.x + this._pcs.mesh.position.x;\r\n        const y = this.position.y + this._pcs.mesh.position.y;\r\n        const z = this.position.z + this._pcs.mesh.position.z;\r\n\r\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @internal\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\r\nexport class PointsGroup {\r\n    /**\r\n     * Get or set the groupId\r\n     * @deprecated Please use groupId instead\r\n     */\r\n    public get groupID(): number {\r\n        return this.groupId;\r\n    }\r\n    public set groupID(groupID: number) {\r\n        this.groupId = groupID;\r\n    }\r\n    /**\r\n     * The group id\r\n     * @internal\r\n     */\r\n    public groupId: number;\r\n    /**\r\n     * image data for group (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImageData: Nullable<ArrayBufferView>;\r\n    /**\r\n     * Image Width (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImgWidth: number;\r\n    /**\r\n     * Image Height (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImgHeight: number;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @internal\r\n     */\r\n    public _positionFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>;\r\n    /**\r\n     * density per facet for surface points\r\n     * @internal\r\n     */\r\n    public _groupDensity: number[];\r\n    /**\r\n     * Only when points are colored by texture carries pointer to texture list array\r\n     * @internal\r\n     */\r\n    public _textureNb: number;\r\n\r\n    /**\r\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n     * PCS internal tool, don't use it manually.\r\n     * @internal\r\n     */\r\n    constructor(id: number, posFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>) {\r\n        this.groupId = id;\r\n        this._positionFunction = posFunction;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}