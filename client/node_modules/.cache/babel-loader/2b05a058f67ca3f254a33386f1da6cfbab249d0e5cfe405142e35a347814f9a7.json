{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Quaternion, Matrix, TmpVectors } from \"@babylonjs/core/Maths/math.vector.js\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader.js\";\nimport \"@babylonjs/core/Meshes/thinInstanceMesh.js\";\nconst NAME = \"EXT_mesh_gpu_instancing\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_mesh_gpu_instancing {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n  }\n  /**\n   * @internal\n   */\n  loadNodeAsync(context, node, assign) {\n    return GLTFLoader.LoadExtensionAsync(context, node, this.name, (extensionContext, extension) => {\n      this._loader._disableInstancedMesh++;\n      const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\n      this._loader._disableInstancedMesh--;\n      if (!node._primitiveBabylonMeshes) {\n        return promise;\n      }\n      const promises = new Array();\n      let instanceCount = 0;\n      const loadAttribute = attribute => {\n        if (extension.attributes[attribute] == undefined) {\n          promises.push(Promise.resolve(null));\n          return;\n        }\n        const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\n        promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\n        if (instanceCount === 0) {\n          instanceCount = accessor.count;\n        } else if (instanceCount !== accessor.count) {\n          throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\n        }\n      };\n      loadAttribute(\"TRANSLATION\");\n      loadAttribute(\"ROTATION\");\n      loadAttribute(\"SCALE\");\n      return promise.then(babylonTransformNode => {\n        return Promise.all(promises).then(([translationBuffer, rotationBuffer, scaleBuffer]) => {\n          const matrices = new Float32Array(instanceCount * 16);\n          TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\n          TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\n          TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\n          for (let i = 0; i < instanceCount; ++i) {\n            translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\n            rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\n            scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\n            Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\n            TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\n          }\n          for (const babylonMesh of node._primitiveBabylonMeshes) {\n            babylonMesh.thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\n          }\n          return babylonTransformNode;\n        });\n      });\n    });\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new EXT_mesh_gpu_instancing(loader));","map":{"version":3,"mappings":"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","names":["Vector3","Quaternion","Matrix","TmpVectors","GLTFLoader","ArrayItem","NAME","EXT_mesh_gpu_instancing","constructor","loader","_loader","enabled","isExtensionUsed","dispose","loadNodeAsync","context","node","assign","LoadExtensionAsync","name","extensionContext","extension","_disableInstancedMesh","promise","index","_primitiveBabylonMeshes","promises","Array","instanceCount","loadAttribute","attribute","attributes","undefined","push","Promise","resolve","accessor","Get","gltf","accessors","_loadFloatAccessorAsync","bufferView","count","Error","then","babylonTransformNode","all","translationBuffer","rotationBuffer","scaleBuffer","matrices","Float32Array","copyFromFloats","i","FromArrayToRef","ComposeToRef","copyToArray","babylonMesh","thinInstanceSetBuffer","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts"],"sourcesContent":["import { Vector3, Quaternion, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { INode } from \"../glTFLoaderInterfaces\";\r\n\r\nimport type { IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\n\r\nimport \"core/Meshes/thinInstanceMesh\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshGpuInstancing, TransformNode>(context, node, this.name, (extensionContext, extension) => {\r\n            this._loader._disableInstancedMesh++;\r\n\r\n            const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\r\n\r\n            this._loader._disableInstancedMesh--;\r\n\r\n            if (!node._primitiveBabylonMeshes) {\r\n                return promise;\r\n            }\r\n\r\n            const promises = new Array<Promise<Nullable<Float32Array>>>();\r\n            let instanceCount = 0;\r\n\r\n            const loadAttribute = (attribute: string) => {\r\n                if (extension.attributes[attribute] == undefined) {\r\n                    promises.push(Promise.resolve(null));\r\n                    return;\r\n                }\r\n\r\n                const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\r\n                promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\r\n\r\n                if (instanceCount === 0) {\r\n                    instanceCount = accessor.count;\r\n                } else if (instanceCount !== accessor.count) {\r\n                    throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"TRANSLATION\");\r\n            loadAttribute(\"ROTATION\");\r\n            loadAttribute(\"SCALE\");\r\n\r\n            return promise.then((babylonTransformNode) => {\r\n                return Promise.all(promises).then(([translationBuffer, rotationBuffer, scaleBuffer]) => {\r\n                    const matrices = new Float32Array(instanceCount * 16);\r\n\r\n                    TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\r\n                    TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\r\n                    TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\r\n\r\n                    for (let i = 0; i < instanceCount; ++i) {\r\n                        translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\r\n                        rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\r\n                        scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\r\n\r\n                        Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\r\n\r\n                        TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\r\n                    }\r\n\r\n                    for (const babylonMesh of node._primitiveBabylonMeshes!) {\r\n                        (babylonMesh as Mesh).thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\r\n                    }\r\n\r\n                    return babylonTransformNode;\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new EXT_mesh_gpu_instancing(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}