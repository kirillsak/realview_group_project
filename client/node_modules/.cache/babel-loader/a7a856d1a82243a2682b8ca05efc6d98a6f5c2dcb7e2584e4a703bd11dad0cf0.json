{"ast":null,"code":"import { ArrayTools } from \"../Misc/arrayTools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { BoundingBox } from \"./boundingBox.js\";\nimport { BoundingSphere } from \"./boundingSphere.js\";\nconst _result0 = {\n  min: 0,\n  max: 0\n};\nconst _result1 = {\n  min: 0,\n  max: 0\n};\nconst computeBoxExtents = (axis, box, result) => {\n  const p = Vector3.Dot(box.centerWorld, axis);\n  const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n  const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n  const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n  const r = r0 + r1 + r2;\n  result.min = p - r;\n  result.max = p + r;\n};\nconst axisOverlap = (axis, box0, box1) => {\n  computeBoxExtents(axis, box0, _result0);\n  computeBoxExtents(axis, box1, _result1);\n  return !(_result0.min > _result1.max || _result1.min > _result0.max);\n};\n/**\n * Info for a bounding data of a mesh\n */\nexport class BoundingInfo {\n  /**\n   * Constructs bounding info\n   * @param minimum min vector of the bounding box/sphere\n   * @param maximum max vector of the bounding box/sphere\n   * @param worldMatrix defines the new world matrix\n   */\n  constructor(minimum, maximum, worldMatrix) {\n    this._isLocked = false;\n    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\n    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\n  }\n  /**\n   * Recreates the entire bounding info from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n  reConstruct(min, max, worldMatrix) {\n    this.boundingBox.reConstruct(min, max, worldMatrix);\n    this.boundingSphere.reConstruct(min, max, worldMatrix);\n  }\n  /**\n   * min vector of the bounding box/sphere\n   */\n  get minimum() {\n    return this.boundingBox.minimum;\n  }\n  /**\n   * max vector of the bounding box/sphere\n   */\n  get maximum() {\n    return this.boundingBox.maximum;\n  }\n  /**\n   * If the info is locked and won't be updated to avoid perf overhead\n   */\n  get isLocked() {\n    return this._isLocked;\n  }\n  set isLocked(value) {\n    this._isLocked = value;\n  }\n  // Methods\n  /**\n   * Updates the bounding sphere and box\n   * @param world world matrix to be used to update\n   */\n  update(world) {\n    if (this._isLocked) {\n      return;\n    }\n    this.boundingBox._update(world);\n    this.boundingSphere._update(world);\n  }\n  /**\n   * Recreate the bounding info to be centered around a specific point given a specific extend.\n   * @param center New center of the bounding info\n   * @param extend New extend of the bounding info\n   * @returns the current bounding info\n   */\n  centerOn(center, extend) {\n    const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\n    const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\n    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  }\n  /**\n   * Grows the bounding info to include the given point.\n   * @param point The point that will be included in the current bounding info\n   * @returns the current bounding info\n   */\n  encapsulate(point) {\n    const minimum = Vector3.Minimize(this.minimum, point);\n    const maximum = Vector3.Maximize(this.maximum, point);\n    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  }\n  /**\n   * Grows the bounding info to encapsulate the given bounding info.\n   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\n   * @returns the current bounding info\n   */\n  encapsulateBoundingInfo(toEncapsulate) {\n    this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));\n    this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));\n    return this;\n  }\n  /**\n   * Scale the current bounding info by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding info\n   */\n  scale(factor) {\n    this.boundingBox.scale(factor);\n    this.boundingSphere.scale(factor);\n    return this;\n  }\n  /**\n   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum to test\n   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\n   * The different strategies available are:\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n   * @returns true if the bounding info is in the frustum planes\n   */\n  isInFrustum(frustumPlanes, strategy = 0) {\n    const inclusionTest = strategy === 2 || strategy === 3;\n    if (inclusionTest) {\n      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\n        return true;\n      }\n    }\n    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n    const bSphereOnlyTest = strategy === 1 || strategy === 3;\n    if (bSphereOnlyTest) {\n      return true;\n    }\n    return this.boundingBox.isInFrustum(frustumPlanes);\n  }\n  /**\n   * Gets the world distance between the min and max points of the bounding box\n   */\n  get diagonalLength() {\n    const boundingBox = this.boundingBox;\n    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\n    return diag.length();\n  }\n  /**\n   * Checks if a cullable object (mesh...) is in the camera frustum\n   * Unlike isInFrustum this checks the full bounding box\n   * @param frustumPlanes Camera near/planes\n   * @returns true if the object is in frustum otherwise false\n   */\n  isCompletelyInFrustum(frustumPlanes) {\n    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * @internal\n   */\n  _checkCollision(collider) {\n    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n  }\n  /**\n   * Checks if a point is inside the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n   * @param point the point to check intersection with\n   * @returns if the point intersects\n   */\n  intersectsPoint(point) {\n    if (!this.boundingSphere.centerWorld) {\n      return false;\n    }\n    if (!this.boundingSphere.intersectsPoint(point)) {\n      return false;\n    }\n    if (!this.boundingBox.intersectsPoint(point)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n   * @param boundingInfo the bounding info to check intersection with\n   * @param precise if the intersection should be done using OBB\n   * @returns if the bounding info intersects\n   */\n  intersects(boundingInfo, precise) {\n    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n      return false;\n    }\n    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n      return false;\n    }\n    if (!precise) {\n      return true;\n    }\n    const box0 = this.boundingBox;\n    const box1 = boundingInfo.boundingBox;\n    if (!axisOverlap(box0.directions[0], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box0.directions[1], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box0.directions[2], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box1.directions[0], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box1.directions[1], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(box1.directions[2], box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n    return true;\n  }\n}\nBoundingInfo._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);","map":{"version":3,"mappings":"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","names":["ArrayTools","Vector3","BoundingBox","BoundingSphere","_result0","min","max","_result1","computeBoxExtents","axis","box","result","p","Dot","centerWorld","r0","Math","abs","directions","extendSize","x","r1","y","r2","z","r","axisOverlap","box0","box1","BoundingInfo","constructor","minimum","maximum","worldMatrix","boundingBox","boundingSphere","reConstruct","isLocked","_isLocked","value","update","world","_update","centerOn","center","extend","_TmpVector3","copyFrom","subtractInPlace","addInPlace","getWorldMatrix","encapsulate","point","Minimize","Maximize","encapsulateBoundingInfo","toEncapsulate","subtract","extendSizeWorld","add","scale","factor","isInFrustum","frustumPlanes","strategy","inclusionTest","isCenterInFrustum","bSphereOnlyTest","diagonalLength","diag","maximumWorld","subtractToRef","minimumWorld","length","isCompletelyInFrustum","_checkCollision","collider","_canDoCollision","radiusWorld","intersectsPoint","intersects","boundingInfo","precise","Intersects","Cross","BuildArray","Zero"],"sourceRoot":"","sources":["../../../../lts/core/generated/Culling/boundingInfo.ts"],"sourcesContent":["import type { DeepImmutable } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { BoundingBox } from \"./boundingBox\";\r\nimport { BoundingSphere } from \"./boundingSphere\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\ndeclare type Collider = import(\"../Collisions/collider\").Collider;\r\n\r\nconst _result0 = { min: 0, max: 0 };\r\nconst _result1 = { min: 0, max: 0 };\r\nconst computeBoxExtents = (axis: DeepImmutable<Vector3>, box: DeepImmutable<BoundingBox>, result: { min: number; max: number }) => {\r\n    const p = Vector3.Dot(box.centerWorld, axis);\r\n\r\n    const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\r\n    const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\r\n    const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\r\n\r\n    const r = r0 + r1 + r2;\r\n    result.min = p - r;\r\n    result.max = p + r;\r\n};\r\n\r\nconst axisOverlap = (axis: DeepImmutable<Vector3>, box0: DeepImmutable<BoundingBox>, box1: DeepImmutable<BoundingBox>): boolean => {\r\n    computeBoxExtents(axis, box0, _result0);\r\n    computeBoxExtents(axis, box1, _result1);\r\n    return !(_result0.min > _result1.max || _result1.min > _result0.max);\r\n};\r\n\r\n/**\r\n * Interface for cullable objects\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#back-face-culling\r\n */\r\nexport interface ICullable {\r\n    /**\r\n     * Checks if the object or part of the object is in the frustum\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isInFrustum(frustumPlanes: Plane[]): boolean;\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    isCompletelyInFrustum(frustumPlanes: Plane[]): boolean;\r\n}\r\n\r\n/**\r\n * Info for a bounding data of a mesh\r\n */\r\nexport class BoundingInfo implements ICullable {\r\n    /**\r\n     * Bounding box for the mesh\r\n     */\r\n    public readonly boundingBox: BoundingBox;\r\n    /**\r\n     * Bounding sphere for the mesh\r\n     */\r\n    public readonly boundingSphere: BoundingSphere;\r\n\r\n    private _isLocked = false;\r\n\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);\r\n\r\n    /**\r\n     * Constructs bounding info\r\n     * @param minimum min vector of the bounding box/sphere\r\n     * @param maximum max vector of the bounding box/sphere\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    constructor(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);\r\n        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * Recreates the entire bounding info from scratch as if we call the constructor in place\r\n     * @param min defines the new minimum vector (in local space)\r\n     * @param max defines the new maximum vector (in local space)\r\n     * @param worldMatrix defines the new world matrix\r\n     */\r\n    public reConstruct(min: DeepImmutable<Vector3>, max: DeepImmutable<Vector3>, worldMatrix?: DeepImmutable<Matrix>) {\r\n        this.boundingBox.reConstruct(min, max, worldMatrix);\r\n        this.boundingSphere.reConstruct(min, max, worldMatrix);\r\n    }\r\n\r\n    /**\r\n     * min vector of the bounding box/sphere\r\n     */\r\n    public get minimum(): Vector3 {\r\n        return this.boundingBox.minimum;\r\n    }\r\n\r\n    /**\r\n     * max vector of the bounding box/sphere\r\n     */\r\n    public get maximum(): Vector3 {\r\n        return this.boundingBox.maximum;\r\n    }\r\n\r\n    /**\r\n     * If the info is locked and won't be updated to avoid perf overhead\r\n     */\r\n    public get isLocked(): boolean {\r\n        return this._isLocked;\r\n    }\r\n\r\n    public set isLocked(value: boolean) {\r\n        this._isLocked = value;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the bounding sphere and box\r\n     * @param world world matrix to be used to update\r\n     */\r\n    public update(world: DeepImmutable<Matrix>) {\r\n        if (this._isLocked) {\r\n            return;\r\n        }\r\n        this.boundingBox._update(world);\r\n        this.boundingSphere._update(world);\r\n    }\r\n\r\n    /**\r\n     * Recreate the bounding info to be centered around a specific point given a specific extend.\r\n     * @param center New center of the bounding info\r\n     * @param extend New extend of the bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public centerOn(center: DeepImmutable<Vector3>, extend: DeepImmutable<Vector3>): BoundingInfo {\r\n        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\r\n        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\r\n\r\n        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to include the given point.\r\n     * @param point The point that will be included in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulate(point: Vector3): BoundingInfo {\r\n        const minimum = Vector3.Minimize(this.minimum, point);\r\n        const maximum = Vector3.Maximize(this.maximum, point);\r\n        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Grows the bounding info to encapsulate the given bounding info.\r\n     * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\r\n     * @returns the current bounding info\r\n     */\r\n    public encapsulateBoundingInfo(toEncapsulate: BoundingInfo): BoundingInfo {\r\n        this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));\r\n        this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Scale the current bounding info by applying a scale factor\r\n     * @param factor defines the scale factor to apply\r\n     * @returns the current bounding info\r\n     */\r\n    public scale(factor: number): BoundingInfo {\r\n        this.boundingBox.scale(factor);\r\n        this.boundingSphere.scale(factor);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\r\n     * @param frustumPlanes defines the frustum to test\r\n     * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\r\n     * The different strategies available are:\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\r\n     * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\r\n     * @returns true if the bounding info is in the frustum planes\r\n     */\r\n    public isInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>, strategy: number = Constants.MESHES_CULLINGSTRATEGY_STANDARD): boolean {\r\n        const inclusionTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (inclusionTest) {\r\n            if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\r\n            return false;\r\n        }\r\n\r\n        const bSphereOnlyTest =\r\n            strategy === Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY || strategy === Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n        if (bSphereOnlyTest) {\r\n            return true;\r\n        }\r\n\r\n        return this.boundingBox.isInFrustum(frustumPlanes);\r\n    }\r\n\r\n    /**\r\n     * Gets the world distance between the min and max points of the bounding box\r\n     */\r\n    public get diagonalLength(): number {\r\n        const boundingBox = this.boundingBox;\r\n        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\r\n        return diag.length();\r\n    }\r\n\r\n    /**\r\n     * Checks if a cullable object (mesh...) is in the camera frustum\r\n     * Unlike isInFrustum this checks the full bounding box\r\n     * @param frustumPlanes Camera near/planes\r\n     * @returns true if the object is in frustum otherwise false\r\n     */\r\n    public isCompletelyInFrustum(frustumPlanes: Array<DeepImmutable<Plane>>): boolean {\r\n        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _checkCollision(collider: Collider): boolean {\r\n        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\r\n    }\r\n\r\n    /**\r\n     * Checks if a point is inside the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param point the point to check intersection with\r\n     * @returns if the point intersects\r\n     */\r\n    public intersectsPoint(point: DeepImmutable<Vector3>): boolean {\r\n        if (!this.boundingSphere.centerWorld) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingSphere.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this.boundingBox.intersectsPoint(point)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\r\n     * @param boundingInfo the bounding info to check intersection with\r\n     * @param precise if the intersection should be done using OBB\r\n     * @returns if the bounding info intersects\r\n     */\r\n    public intersects(boundingInfo: DeepImmutable<BoundingInfo>, precise: boolean): boolean {\r\n        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\r\n            return false;\r\n        }\r\n\r\n        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\r\n            return false;\r\n        }\r\n\r\n        if (!precise) {\r\n            return true;\r\n        }\r\n\r\n        const box0 = this.boundingBox;\r\n        const box1 = boundingInfo.boundingBox;\r\n\r\n        if (!axisOverlap(box0.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box0.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[0], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[1], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(box1.directions[2], box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\r\n            return false;\r\n        }\r\n        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}