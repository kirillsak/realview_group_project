{"ast":null,"code":"import { Logger } from \"../Misc/logger.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Camera } from \"./camera.js\";\n/**\n * @ignore\n * This is a list of all the different input types that are available in the application.\n * Fo instance: ArcRotateCameraGamepadInput...\n */\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\nexport var CameraInputTypes = {};\n/**\n * This represents the input manager used within a camera.\n * It helps dealing with all the different kind of input attached to a camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class CameraInputsManager {\n  /**\n   * Instantiate a new Camera Input Manager.\n   * @param camera Defines the camera the input manager belongs to\n   */\n  constructor(camera) {\n    /**\n     * Defines the dom element the camera is collecting inputs from.\n     * This is null if the controls have not been attached.\n     */\n    this.attachedToElement = false;\n    this.attached = {};\n    this.camera = camera;\n    this.checkInputs = () => {};\n  }\n  /**\n   * Add an input method to a camera\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   * @param input Camera input method\n   */\n  add(input) {\n    const type = input.getSimpleName();\n    if (this.attached[type]) {\n      Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\n      return;\n    }\n    this.attached[type] = input;\n    input.camera = this.camera;\n    // for checkInputs, we are dynamically creating a function\n    // the goal is to avoid the performance penalty of looping for inputs in the render loop\n    if (input.checkInputs) {\n      this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\n    }\n    if (this.attachedToElement) {\n      input.attachControl(this.noPreventDefault);\n    }\n  }\n  /**\n   * Remove a specific input method from a camera\n   * example: camera.inputs.remove(camera.inputs.attached.mouse);\n   * @param inputToRemove camera input method\n   */\n  remove(inputToRemove) {\n    for (const cam in this.attached) {\n      const input = this.attached[cam];\n      if (input === inputToRemove) {\n        input.detachControl();\n        input.camera = null;\n        delete this.attached[cam];\n        this.rebuildInputCheck();\n        return;\n      }\n    }\n  }\n  /**\n   * Remove a specific input type from a camera\n   * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\n   * @param inputType the type of the input to remove\n   */\n  removeByType(inputType) {\n    for (const cam in this.attached) {\n      const input = this.attached[cam];\n      if (input.getClassName() === inputType) {\n        input.detachControl();\n        input.camera = null;\n        delete this.attached[cam];\n        this.rebuildInputCheck();\n      }\n    }\n  }\n  _addCheckInputs(fn) {\n    const current = this.checkInputs;\n    return () => {\n      current();\n      fn();\n    };\n  }\n  /**\n   * Attach the input controls to the currently attached dom element to listen the events from.\n   * @param input Defines the input to attach\n   */\n  attachInput(input) {\n    if (this.attachedToElement) {\n      input.attachControl(this.noPreventDefault);\n    }\n  }\n  /**\n   * Attach the current manager inputs controls to a specific dom element to listen the events from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachElement(noPreventDefault = false) {\n    if (this.attachedToElement) {\n      return;\n    }\n    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n    this.attachedToElement = true;\n    this.noPreventDefault = noPreventDefault;\n    for (const cam in this.attached) {\n      this.attached[cam].attachControl(noPreventDefault);\n    }\n  }\n  /**\n   * Detach the current manager inputs controls from a specific dom element.\n   * @param disconnect Defines whether the input should be removed from the current list of attached inputs\n   */\n  detachElement(disconnect = false) {\n    for (const cam in this.attached) {\n      this.attached[cam].detachControl();\n      if (disconnect) {\n        this.attached[cam].camera = null;\n      }\n    }\n    this.attachedToElement = false;\n  }\n  /**\n   * Rebuild the dynamic inputCheck function from the current list of\n   * defined inputs in the manager.\n   */\n  rebuildInputCheck() {\n    this.checkInputs = () => {};\n    for (const cam in this.attached) {\n      const input = this.attached[cam];\n      if (input.checkInputs) {\n        this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\n      }\n    }\n  }\n  /**\n   * Remove all attached input methods from a camera\n   */\n  clear() {\n    if (this.attachedToElement) {\n      this.detachElement(true);\n    }\n    this.attached = {};\n    this.attachedToElement = false;\n    this.checkInputs = () => {};\n  }\n  /**\n   * Serialize the current input manager attached to a camera.\n   * This ensures than once parsed,\n   * the input associated to the camera will be identical to the current ones\n   * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\n   */\n  serialize(serializedCamera) {\n    const inputs = {};\n    for (const cam in this.attached) {\n      const input = this.attached[cam];\n      const res = SerializationHelper.Serialize(input);\n      inputs[input.getClassName()] = res;\n    }\n    serializedCamera.inputsmgr = inputs;\n  }\n  /**\n   * Parses an input manager serialized JSON to restore the previous list of inputs\n   * and states associated to a camera.\n   * @param parsedCamera Defines the JSON to parse\n   */\n  parse(parsedCamera) {\n    const parsedInputs = parsedCamera.inputsmgr;\n    if (parsedInputs) {\n      this.clear();\n      for (const n in parsedInputs) {\n        const construct = CameraInputTypes[n];\n        if (construct) {\n          const parsedinput = parsedInputs[n];\n          const input = SerializationHelper.Parse(() => {\n            return new construct();\n          }, parsedinput, null);\n          this.add(input);\n        }\n      }\n    } else {\n      //2016-03-08 this part is for managing backward compatibility\n      for (const n in this.attached) {\n        const construct = CameraInputTypes[this.attached[n].getClassName()];\n        if (construct) {\n          const input = SerializationHelper.Parse(() => {\n            return new construct();\n          }, parsedCamera, null);\n          this.remove(this.attached[n]);\n          this.add(input);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAM,QAAQ,mBAAiB;AACxC,SAASC,mBAAmB,QAAQ,uBAAqB;AAEzD,SAASC,MAAM,QAAQ,aAAW;AAClC;;;;;AAKA;AACA,OAAO,IAAIC,gBAAgB,GAAG,EAAE;AAmDhC;;;;;AAKA,OAAM,MAAOC,mBAAmB;EA4B5B;;;;EAIAC,YAAYC,MAAe;IA1B3B;;;;IAIO,sBAAiB,GAAY,KAAK;IAuBrC,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,WAAW,GAAG,MAAK,CAAE,CAAC;EAC/B;EAEA;;;;;EAKOC,GAAG,CAACC,KAA4B;IACnC,MAAMC,IAAI,GAAGD,KAAK,CAACE,aAAa,EAAE;IAClC,IAAI,IAAI,CAACL,QAAQ,CAACI,IAAI,CAAC,EAAE;MACrBX,MAAM,CAACa,IAAI,CAAC,uBAAuB,GAAGF,IAAI,GAAG,2BAA2B,CAAC;MACzE;;IAGJ,IAAI,CAACJ,QAAQ,CAACI,IAAI,CAAC,GAAGD,KAAK;IAE3BA,KAAK,CAACJ,MAAM,GAAG,IAAI,CAACA,MAAM;IAE1B;IACA;IACA,IAAII,KAAK,CAACF,WAAW,EAAE;MACnB,IAAI,CAACA,WAAW,GAAG,IAAI,CAACM,eAAe,CAACJ,KAAK,CAACF,WAAW,CAACO,IAAI,CAACL,KAAK,CAAC,CAAC;;IAG1E,IAAI,IAAI,CAACM,iBAAiB,EAAE;MACxBN,KAAK,CAACO,aAAa,CAAC,IAAI,CAACC,gBAAgB,CAAC;;EAElD;EAEA;;;;;EAKOC,MAAM,CAACC,aAAoC;IAC9C,KAAK,MAAMC,GAAG,IAAI,IAAI,CAACd,QAAQ,EAAE;MAC7B,MAAMG,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACc,GAAG,CAAC;MAChC,IAAIX,KAAK,KAAKU,aAAa,EAAE;QACzBV,KAAK,CAACY,aAAa,EAAE;QACrBZ,KAAK,CAACJ,MAAM,GAAG,IAAI;QACnB,OAAO,IAAI,CAACC,QAAQ,CAACc,GAAG,CAAC;QACzB,IAAI,CAACE,iBAAiB,EAAE;QAExB;;;EAGZ;EAEA;;;;;EAKOC,YAAY,CAACC,SAAiB;IACjC,KAAK,MAAMJ,GAAG,IAAI,IAAI,CAACd,QAAQ,EAAE;MAC7B,MAAMG,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACc,GAAG,CAAC;MAChC,IAAIX,KAAK,CAACgB,YAAY,EAAE,KAAKD,SAAS,EAAE;QACpCf,KAAK,CAACY,aAAa,EAAE;QACrBZ,KAAK,CAACJ,MAAM,GAAG,IAAI;QACnB,OAAO,IAAI,CAACC,QAAQ,CAACc,GAAG,CAAC;QACzB,IAAI,CAACE,iBAAiB,EAAE;;;EAGpC;EAEQT,eAAe,CAACa,EAAc;IAClC,MAAMC,OAAO,GAAG,IAAI,CAACpB,WAAW;IAChC,OAAO,MAAK;MACRoB,OAAO,EAAE;MACTD,EAAE,EAAE;IACR,CAAC;EACL;EAEA;;;;EAIOE,WAAW,CAACnB,KAA4B;IAC3C,IAAI,IAAI,CAACM,iBAAiB,EAAE;MACxBN,KAAK,CAACO,aAAa,CAAC,IAAI,CAACC,gBAAgB,CAAC;;EAElD;EAEA;;;;EAIOY,aAAa,CAACZ,mBAA4B,KAAK;IAClD,IAAI,IAAI,CAACF,iBAAiB,EAAE;MACxB;;IAGJE,gBAAgB,GAAGhB,MAAM,CAAC6B,wCAAwC,GAAG,KAAK,GAAGb,gBAAgB;IAC7F,IAAI,CAACF,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACE,gBAAgB,GAAGA,gBAAgB;IAExC,KAAK,MAAMG,GAAG,IAAI,IAAI,CAACd,QAAQ,EAAE;MAC7B,IAAI,CAACA,QAAQ,CAACc,GAAG,CAAC,CAACJ,aAAa,CAACC,gBAAgB,CAAC;;EAE1D;EAEA;;;;EAIOc,aAAa,CAACC,UAAU,GAAG,KAAK;IACnC,KAAK,MAAMZ,GAAG,IAAI,IAAI,CAACd,QAAQ,EAAE;MAC7B,IAAI,CAACA,QAAQ,CAACc,GAAG,CAAC,CAACC,aAAa,EAAE;MAElC,IAAIW,UAAU,EAAE;QACZ,IAAI,CAAC1B,QAAQ,CAACc,GAAG,CAAC,CAACf,MAAM,GAAG,IAAI;;;IAGxC,IAAI,CAACU,iBAAiB,GAAG,KAAK;EAClC;EAEA;;;;EAIOO,iBAAiB;IACpB,IAAI,CAACf,WAAW,GAAG,MAAK,CAAE,CAAC;IAE3B,KAAK,MAAMa,GAAG,IAAI,IAAI,CAACd,QAAQ,EAAE;MAC7B,MAAMG,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACc,GAAG,CAAC;MAChC,IAAIX,KAAK,CAACF,WAAW,EAAE;QACnB,IAAI,CAACA,WAAW,GAAG,IAAI,CAACM,eAAe,CAACJ,KAAK,CAACF,WAAW,CAACO,IAAI,CAACL,KAAK,CAAC,CAAC;;;EAGlF;EAEA;;;EAGOwB,KAAK;IACR,IAAI,IAAI,CAAClB,iBAAiB,EAAE;MACxB,IAAI,CAACgB,aAAa,CAAC,IAAI,CAAC;;IAE5B,IAAI,CAACzB,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACS,iBAAiB,GAAG,KAAK;IAC9B,IAAI,CAACR,WAAW,GAAG,MAAK,CAAE,CAAC;EAC/B;EAEA;;;;;;EAMO2B,SAAS,CAACC,gBAAqB;IAClC,MAAMC,MAAM,GAA2B,EAAE;IACzC,KAAK,MAAMhB,GAAG,IAAI,IAAI,CAACd,QAAQ,EAAE;MAC7B,MAAMG,KAAK,GAAG,IAAI,CAACH,QAAQ,CAACc,GAAG,CAAC;MAChC,MAAMiB,GAAG,GAAGrC,mBAAmB,CAACsC,SAAS,CAAC7B,KAAK,CAAC;MAChD2B,MAAM,CAAC3B,KAAK,CAACgB,YAAY,EAAE,CAAC,GAAGY,GAAG;;IAGtCF,gBAAgB,CAACI,SAAS,GAAGH,MAAM;EACvC;EAEA;;;;;EAKOI,KAAK,CAACC,YAAiB;IAC1B,MAAMC,YAAY,GAAGD,YAAY,CAACF,SAAS;IAC3C,IAAIG,YAAY,EAAE;MACd,IAAI,CAACT,KAAK,EAAE;MAEZ,KAAK,MAAMU,CAAC,IAAID,YAAY,EAAE;QAC1B,MAAME,SAAS,GAAS1C,gBAAiB,CAACyC,CAAC,CAAC;QAC5C,IAAIC,SAAS,EAAE;UACX,MAAMC,WAAW,GAAGH,YAAY,CAACC,CAAC,CAAC;UACnC,MAAMlC,KAAK,GAAGT,mBAAmB,CAAC8C,KAAK,CACnC,MAAK;YACD,OAAO,IAAIF,SAAS,EAAE;UAC1B,CAAC,EACDC,WAAW,EACX,IAAI,CACP;UACD,IAAI,CAACrC,GAAG,CAACC,KAAY,CAAC;;;KAGjC,MAAM;MACH;MACA,KAAK,MAAMkC,CAAC,IAAI,IAAI,CAACrC,QAAQ,EAAE;QAC3B,MAAMsC,SAAS,GAAS1C,gBAAiB,CAAC,IAAI,CAACI,QAAQ,CAACqC,CAAC,CAAC,CAAClB,YAAY,EAAE,CAAC;QAC1E,IAAImB,SAAS,EAAE;UACX,MAAMnC,KAAK,GAAGT,mBAAmB,CAAC8C,KAAK,CACnC,MAAK;YACD,OAAO,IAAIF,SAAS,EAAE;UAC1B,CAAC,EACDH,YAAY,EACZ,IAAI,CACP;UACD,IAAI,CAACvB,MAAM,CAAC,IAAI,CAACZ,QAAQ,CAACqC,CAAC,CAAC,CAAC;UAC7B,IAAI,CAACnC,GAAG,CAACC,KAAY,CAAC;;;;EAItC","names":["Logger","SerializationHelper","Camera","CameraInputTypes","CameraInputsManager","constructor","camera","attached","checkInputs","add","input","type","getSimpleName","Warn","_addCheckInputs","bind","attachedToElement","attachControl","noPreventDefault","remove","inputToRemove","cam","detachControl","rebuildInputCheck","removeByType","inputType","getClassName","fn","current","attachInput","attachElement","ForceAttachControlToAlwaysPreventDefault","detachElement","disconnect","clear","serialize","serializedCamera","inputs","res","Serialize","inputsmgr","parse","parsedCamera","parsedInputs","n","construct","parsedinput","Parse"],"sourceRoot":"","sources":["../../../../lts/core/generated/Cameras/cameraInputsManager.ts"],"sourcesContent":["import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}