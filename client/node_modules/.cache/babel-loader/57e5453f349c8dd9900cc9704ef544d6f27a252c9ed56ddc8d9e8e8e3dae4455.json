{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../tslib.es6.js\";\nimport { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3, TmpColors } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { GetClass } from \"../Misc/typeStore.js\";\nimport { LightConstants } from \"./lightConstants.js\";\n/**\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\n */\nexport class Light extends Node {\n  /**\n   * Creates a Light object in the scene.\n   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n   * @param name The friendly name of the light\n   * @param scene The scene the light belongs too\n   */\n  constructor(name, scene) {\n    super(name, scene);\n    /**\n     * Diffuse gives the basic color to an object.\n     */\n    this.diffuse = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Specular produces a highlight color on an object.\n     * Note: This is not affecting PBR materials.\n     */\n    this.specular = new Color3(1.0, 1.0, 1.0);\n    /**\n     * Defines the falloff type for this light. This lets overriding how punctual light are\n     * falling off base on range or angle.\n     * This can be set to any values in Light.FALLOFF_x.\n     *\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\n     * other types of materials.\n     */\n    this.falloffType = Light.FALLOFF_DEFAULT;\n    /**\n     * Strength of the light.\n     * Note: By default it is define in the framework own unit.\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\n     */\n    this.intensity = 1.0;\n    this._range = Number.MAX_VALUE;\n    this._inverseSquaredRange = 0;\n    /**\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n     * of light.\n     */\n    this._photometricScale = 1.0;\n    this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n    this._radius = 0.00001;\n    /**\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\n     * exceeding the number allowed of the materials.\n     */\n    this.renderPriority = 0;\n    this._shadowEnabled = true;\n    this._excludeWithLayerMask = 0;\n    this._includeOnlyWithLayerMask = 0;\n    this._lightmapMode = 0;\n    /**\n     * Shadow generators associated to the light.\n     * @internal Internal use only.\n     */\n    this._shadowGenerators = null;\n    /**\n     * @internal Internal use only.\n     */\n    this._excludedMeshesIds = new Array();\n    /**\n     * @internal Internal use only.\n     */\n    this._includedOnlyMeshesIds = new Array();\n    /** @internal */\n    this._isLight = true;\n    this.getScene().addLight(this);\n    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\n    this._buildUniformLayout();\n    this.includedOnlyMeshes = new Array();\n    this.excludedMeshes = new Array();\n    this._resyncMeshes();\n  }\n  /**\n   * Defines how far from the source the light is impacting in scene units.\n   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n   */\n  get range() {\n    return this._range;\n  }\n  /**\n   * Defines how far from the source the light is impacting in scene units.\n   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\n   */\n  set range(value) {\n    this._range = value;\n    this._inverseSquaredRange = 1.0 / (this.range * this.range);\n  }\n  /**\n   * Gets the photometric scale used to interpret the intensity.\n   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n   */\n  get intensityMode() {\n    return this._intensityMode;\n  }\n  /**\n   * Sets the photometric scale used to interpret the intensity.\n   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n   */\n  set intensityMode(value) {\n    this._intensityMode = value;\n    this._computePhotometricScale();\n  }\n  /**\n   * Gets the light radius used by PBR Materials to simulate soft area lights.\n   */\n  get radius() {\n    return this._radius;\n  }\n  /**\n   * sets the light radius used by PBR Materials to simulate soft area lights.\n   */\n  set radius(value) {\n    this._radius = value;\n    this._computePhotometricScale();\n  }\n  /**\n   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n   * the current shadow generator.\n   */\n  get shadowEnabled() {\n    return this._shadowEnabled;\n  }\n  /**\n   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n   * the current shadow generator.\n   */\n  set shadowEnabled(value) {\n    if (this._shadowEnabled === value) {\n      return;\n    }\n    this._shadowEnabled = value;\n    this._markMeshesAsLightDirty();\n  }\n  /**\n   * Gets the only meshes impacted by this light.\n   */\n  get includedOnlyMeshes() {\n    return this._includedOnlyMeshes;\n  }\n  /**\n   * Sets the only meshes impacted by this light.\n   */\n  set includedOnlyMeshes(value) {\n    this._includedOnlyMeshes = value;\n    this._hookArrayForIncludedOnly(value);\n  }\n  /**\n   * Gets the meshes not impacted by this light.\n   */\n  get excludedMeshes() {\n    return this._excludedMeshes;\n  }\n  /**\n   * Sets the meshes not impacted by this light.\n   */\n  set excludedMeshes(value) {\n    this._excludedMeshes = value;\n    this._hookArrayForExcluded(value);\n  }\n  /**\n   * Gets the layer id use to find what meshes are not impacted by the light.\n   * Inactive if 0\n   */\n  get excludeWithLayerMask() {\n    return this._excludeWithLayerMask;\n  }\n  /**\n   * Sets the layer id use to find what meshes are not impacted by the light.\n   * Inactive if 0\n   */\n  set excludeWithLayerMask(value) {\n    this._excludeWithLayerMask = value;\n    this._resyncMeshes();\n  }\n  /**\n   * Gets the layer id use to find what meshes are impacted by the light.\n   * Inactive if 0\n   */\n  get includeOnlyWithLayerMask() {\n    return this._includeOnlyWithLayerMask;\n  }\n  /**\n   * Sets the layer id use to find what meshes are impacted by the light.\n   * Inactive if 0\n   */\n  set includeOnlyWithLayerMask(value) {\n    this._includeOnlyWithLayerMask = value;\n    this._resyncMeshes();\n  }\n  /**\n   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n   */\n  get lightmapMode() {\n    return this._lightmapMode;\n  }\n  /**\n   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\n   */\n  set lightmapMode(value) {\n    if (this._lightmapMode === value) {\n      return;\n    }\n    this._lightmapMode = value;\n    this._markMeshesAsLightDirty();\n  }\n  /**\n   * Sets the passed Effect \"effect\" with the Light textures.\n   * @param effect The effect to update\n   * @param lightIndex The index of the light in the effect to update\n   * @returns The light\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  transferTexturesToEffect(effect, lightIndex) {\n    // Do nothing by default.\n    return this;\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n    var _a;\n    const iAsString = lightIndex.toString();\n    let needUpdate = false;\n    this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\n    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\n      this._renderId = scene.getRenderId();\n      this._lastUseSpecular = useSpecular;\n      const scaledIntensity = this.getScaledIntensity();\n      this.transferToEffect(effect, iAsString);\n      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\n      this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\n      if (useSpecular) {\n        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\n        this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\n      }\n      needUpdate = true;\n    }\n    // Textures might still need to be rebound.\n    this.transferTexturesToEffect(effect, iAsString);\n    // Shadows\n    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\n      const shadowGenerator = (_a = this.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : this.getShadowGenerator();\n      if (shadowGenerator) {\n        shadowGenerator.bindShadowLight(iAsString, effect);\n        needUpdate = true;\n      }\n    }\n    if (needUpdate) {\n      this._uniformBuffer.update();\n    } else {\n      this._uniformBuffer.bindUniformBuffer();\n    }\n  }\n  /**\n   * Returns the string \"Light\".\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Light\";\n  }\n  /**\n   * Converts the light information to a readable string for debug purpose.\n   * @param fullDetails Supports for multiple levels of logging within scene loading\n   * @returns the human readable light info\n   */\n  toString(fullDetails) {\n    let ret = \"Name: \" + this.name;\n    ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\n    if (this.animations) {\n      for (let i = 0; i < this.animations.length; i++) {\n        ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n      }\n    }\n    return ret;\n  }\n  /** @internal */\n  _syncParentEnabledState() {\n    super._syncParentEnabledState();\n    if (!this.isDisposed()) {\n      this._resyncMeshes();\n    }\n  }\n  /**\n   * Set the enabled state of this node.\n   * @param value - the new enabled state\n   */\n  setEnabled(value) {\n    super.setEnabled(value);\n    this._resyncMeshes();\n  }\n  /**\n   * Returns the Light associated shadow generator if any.\n   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\n   * @returns the associated shadow generator.\n   */\n  getShadowGenerator(camera = null) {\n    var _a;\n    if (this._shadowGenerators === null) {\n      return null;\n    }\n    return (_a = this._shadowGenerators.get(camera)) !== null && _a !== void 0 ? _a : null;\n  }\n  /**\n   * Returns all the shadow generators associated to this light\n   * @returns\n   */\n  getShadowGenerators() {\n    return this._shadowGenerators;\n  }\n  /**\n   * Returns a Vector3, the absolute light position in the World.\n   * @returns the world space position of the light\n   */\n  getAbsolutePosition() {\n    return Vector3.Zero();\n  }\n  /**\n   * Specifies if the light will affect the passed mesh.\n   * @param mesh The mesh to test against the light\n   * @returns true the mesh is affected otherwise, false.\n   */\n  canAffectMesh(mesh) {\n    if (!mesh) {\n      return true;\n    }\n    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n      return false;\n    }\n    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n      return false;\n    }\n    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n      return false;\n    }\n    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Releases resources associated with this node.\n   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n   */\n  dispose(doNotRecurse, disposeMaterialAndTextures = false) {\n    if (this._shadowGenerators) {\n      const iterator = this._shadowGenerators.values();\n      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n        const shadowGenerator = key.value;\n        shadowGenerator.dispose();\n      }\n      this._shadowGenerators = null;\n    }\n    // Animations\n    this.getScene().stopAnimation(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.lights.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.lights.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    // Remove from meshes\n    for (const mesh of this.getScene().meshes) {\n      mesh._removeLightSource(this, true);\n    }\n    this._uniformBuffer.dispose();\n    // Remove from scene\n    this.getScene().removeLight(this);\n    super.dispose(doNotRecurse, disposeMaterialAndTextures);\n  }\n  /**\n   * Returns the light type ID (integer).\n   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n   */\n  getTypeID() {\n    return 0;\n  }\n  /**\n   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n   * @returns the scaled intensity in intensity mode unit\n   */\n  getScaledIntensity() {\n    return this._photometricScale * this.intensity;\n  }\n  /**\n   * Returns a new Light object, named \"name\", from the current one.\n   * @param name The name of the cloned light\n   * @param newParent The parent of this light, if it has one\n   * @returns the new created light\n   */\n  clone(name, newParent = null) {\n    const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\n    if (!constructor) {\n      return null;\n    }\n    const clonedLight = SerializationHelper.Clone(constructor, this);\n    if (name) {\n      clonedLight.name = name;\n    }\n    if (newParent) {\n      clonedLight.parent = newParent;\n    }\n    clonedLight.setEnabled(this.isEnabled());\n    this.onClonedObservable.notifyObservers(clonedLight);\n    return clonedLight;\n  }\n  /**\n   * Serializes the current light into a Serialization object.\n   * @returns the serialized object.\n   */\n  serialize() {\n    const serializationObject = SerializationHelper.Serialize(this);\n    serializationObject.uniqueId = this.uniqueId;\n    // Type\n    serializationObject.type = this.getTypeID();\n    // Parent\n    if (this.parent) {\n      this.parent._serializeAsParent(serializationObject);\n    }\n    // Inclusion / exclusions\n    if (this.excludedMeshes.length > 0) {\n      serializationObject.excludedMeshesIds = [];\n      this.excludedMeshes.forEach(mesh => {\n        serializationObject.excludedMeshesIds.push(mesh.id);\n      });\n    }\n    if (this.includedOnlyMeshes.length > 0) {\n      serializationObject.includedOnlyMeshesIds = [];\n      this.includedOnlyMeshes.forEach(mesh => {\n        serializationObject.includedOnlyMeshesIds.push(mesh.id);\n      });\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n    serializationObject.ranges = this.serializeAnimationRanges();\n    serializationObject.isEnabled = this.isEnabled();\n    return serializationObject;\n  }\n  /**\n   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n   * This new light is named \"name\" and added to the passed scene.\n   * @param type Type according to the types available in Light.LIGHTTYPEID_x\n   * @param name The friendly name of the light\n   * @param scene The scene the new light will belong to\n   * @returns the constructor function\n   */\n  static GetConstructorFromName(type, name, scene) {\n    const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\n    if (constructorFunc) {\n      return constructorFunc;\n    }\n    // Default to no light for none present once.\n    return null;\n  }\n  /**\n   * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n   * @param parsedLight The JSON representation of the light\n   * @param scene The scene to create the parsed light in\n   * @returns the created light after parsing\n   */\n  static Parse(parsedLight, scene) {\n    const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\n    if (!constructor) {\n      return null;\n    }\n    const light = SerializationHelper.Parse(constructor, parsedLight, scene);\n    // Inclusion / exclusions\n    if (parsedLight.excludedMeshesIds) {\n      light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n    }\n    if (parsedLight.includedOnlyMeshesIds) {\n      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n    }\n    // Parent\n    if (parsedLight.parentId !== undefined) {\n      light._waitingParentId = parsedLight.parentId;\n    }\n    if (parsedLight.parentInstanceIndex !== undefined) {\n      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\n    }\n    // Falloff\n    if (parsedLight.falloffType !== undefined) {\n      light.falloffType = parsedLight.falloffType;\n    }\n    // Lightmaps\n    if (parsedLight.lightmapMode !== undefined) {\n      light.lightmapMode = parsedLight.lightmapMode;\n    }\n    // Animations\n    if (parsedLight.animations) {\n      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n        const parsedAnimation = parsedLight.animations[animationIndex];\n        const internalClass = GetClass(\"BABYLON.Animation\");\n        if (internalClass) {\n          light.animations.push(internalClass.Parse(parsedAnimation));\n        }\n      }\n      Node.ParseAnimationRanges(light, parsedLight, scene);\n    }\n    if (parsedLight.autoAnimate) {\n      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n    }\n    // Check if isEnabled is defined to be back compatible with prior serialized versions.\n    if (parsedLight.isEnabled !== undefined) {\n      light.setEnabled(parsedLight.isEnabled);\n    }\n    return light;\n  }\n  _hookArrayForExcluded(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      for (const item of items) {\n        item._resyncLightSource(this);\n      }\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      for (const item of deleted) {\n        item._resyncLightSource(this);\n      }\n      return deleted;\n    };\n    for (const item of array) {\n      item._resyncLightSource(this);\n    }\n  }\n  _hookArrayForIncludedOnly(array) {\n    const oldPush = array.push;\n    array.push = (...items) => {\n      const result = oldPush.apply(array, items);\n      this._resyncMeshes();\n      return result;\n    };\n    const oldSplice = array.splice;\n    array.splice = (index, deleteCount) => {\n      const deleted = oldSplice.apply(array, [index, deleteCount]);\n      this._resyncMeshes();\n      return deleted;\n    };\n    this._resyncMeshes();\n  }\n  _resyncMeshes() {\n    for (const mesh of this.getScene().meshes) {\n      mesh._resyncLightSource(this);\n    }\n  }\n  /**\n   * Forces the meshes to update their light related information in their rendering used effects\n   * @internal Internal Use Only\n   */\n  _markMeshesAsLightDirty() {\n    for (const mesh of this.getScene().meshes) {\n      if (mesh.lightSources.indexOf(this) !== -1) {\n        mesh._markSubMeshesAsLightDirty();\n      }\n    }\n  }\n  /**\n   * Recomputes the cached photometric scale if needed.\n   */\n  _computePhotometricScale() {\n    this._photometricScale = this._getPhotometricScale();\n    this.getScene().resetCachedMaterial();\n  }\n  /**\n   * Returns the Photometric Scale according to the light type and intensity mode.\n   */\n  _getPhotometricScale() {\n    let photometricScale = 0.0;\n    const lightTypeID = this.getTypeID();\n    //get photometric mode\n    let photometricMode = this.intensityMode;\n    if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n      if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n        photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n      } else {\n        photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n      }\n    }\n    //compute photometric scale\n    switch (lightTypeID) {\n      case Light.LIGHTTYPEID_POINTLIGHT:\n      case Light.LIGHTTYPEID_SPOTLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_LUMINOUSPOWER:\n            photometricScale = 1.0 / (4.0 * Math.PI);\n            break;\n          case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n            photometricScale = 1.0;\n            break;\n          case Light.INTENSITYMODE_LUMINANCE:\n            photometricScale = this.radius * this.radius;\n            break;\n        }\n        break;\n      case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n        switch (photometricMode) {\n          case Light.INTENSITYMODE_ILLUMINANCE:\n            photometricScale = 1.0;\n            break;\n          case Light.INTENSITYMODE_LUMINANCE:\n            {\n              // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n              // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n              let apexAngleRadians = this.radius;\n              // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n              apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n              const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n              photometricScale = solidAngle;\n              break;\n            }\n        }\n        break;\n      case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n        // No fall off in hemispheric light.\n        photometricScale = 1.0;\n        break;\n    }\n    return photometricScale;\n  }\n  /**\n   * Reorder the light in the scene according to their defined priority.\n   * @internal Internal Use Only\n   */\n  _reorderLightsInScene() {\n    const scene = this.getScene();\n    if (this._renderPriority != 0) {\n      scene.requireLightSorting = true;\n    }\n    this.getScene().sortLightsByPriority();\n  }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLight.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLight.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLight.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLight.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLight.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLight.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLight.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLight.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\n/**\n * lumen (lm)\n */\nLight.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\n/**\n * candela (lm/sr)\n */\nLight.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\n/**\n * lux (lm/m^2)\n */\nLight.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\n/**\n * nit (cd/m^2)\n */\nLight.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLight.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\n/**\n * Light type const id of the directional light.\n */\nLight.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\n/**\n * Light type const id of the spot light.\n */\nLight.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\n/**\n * Light type const id of the hemispheric light.\n */\nLight.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\n__decorate([serializeAsColor3()], Light.prototype, \"diffuse\", void 0);\n__decorate([serializeAsColor3()], Light.prototype, \"specular\", void 0);\n__decorate([serialize()], Light.prototype, \"falloffType\", void 0);\n__decorate([serialize()], Light.prototype, \"intensity\", void 0);\n__decorate([serialize()], Light.prototype, \"range\", null);\n__decorate([serialize()], Light.prototype, \"intensityMode\", null);\n__decorate([serialize()], Light.prototype, \"radius\", null);\n__decorate([serialize()], Light.prototype, \"_renderPriority\", void 0);\n__decorate([expandToProperty(\"_reorderLightsInScene\")], Light.prototype, \"renderPriority\", void 0);\n__decorate([serialize(\"shadowEnabled\")], Light.prototype, \"_shadowEnabled\", void 0);\n__decorate([serialize(\"excludeWithLayerMask\")], Light.prototype, \"_excludeWithLayerMask\", void 0);\n__decorate([serialize(\"includeOnlyWithLayerMask\")], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n__decorate([serialize(\"lightmapMode\")], Light.prototype, \"_lightmapMode\", void 0);","map":{"version":3,"mappings":";;AAAA,SAASA,SAAS,EAAEC,mBAAmB,EAAEC,iBAAiB,EAAEC,gBAAgB,QAAQ,uBAAqB;AAGzG,SAASC,OAAO,QAAQ,yBAAuB;AAC/C,SAASC,MAAM,EAAEC,SAAS,QAAQ,wBAAsB;AACxD,SAASC,IAAI,QAAQ,YAAU;AAG/B,SAASC,aAAa,QAAQ,+BAA6B;AAE3D,SAASC,QAAQ,QAAQ,sBAAoB;AAE7C,SAASC,cAAc,QAAQ,qBAAmB;AAGlD;;;;;AAKA,OAAM,MAAgBC,KAAM,SAAQJ,IAAI;EAmUpC;;;;;;EAMAK,YAAYC,IAAY,EAAEC,KAAY;IAClC,KAAK,CAACD,IAAI,EAAEC,KAAK,CAAC;IAnPtB;;;IAIO,YAAO,GAAG,IAAIT,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAE1C;;;;IAKO,aAAQ,GAAG,IAAIA,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAE3C;;;;;;;;IASO,gBAAW,GAAGM,KAAK,CAACI,eAAe;IAE1C;;;;;IAMO,cAAS,GAAG,GAAG;IAEd,WAAM,GAAGC,MAAM,CAACC,SAAS;IACvB,yBAAoB,GAAG,CAAC;IAmBlC;;;;IAIQ,sBAAiB,GAAG,GAAG;IAEvB,mBAAc,GAAWN,KAAK,CAACO,uBAAuB;IAkBtD,YAAO,GAAG,OAAO;IAkBzB;;;;IAKO,mBAAc,GAAW,CAAC;IAGzB,mBAAc,GAAY,IAAI;IAoD9B,0BAAqB,GAAG,CAAC;IAkBzB,8BAAyB,GAAG,CAAC;IAkB7B,kBAAa,GAAG,CAAC;IAmBzB;;;;IAIO,sBAAiB,GAAsD,IAAI;IAElF;;;IAGO,uBAAkB,GAAG,IAAIC,KAAK,EAAU;IAE/C;;;IAGO,2BAAsB,GAAG,IAAIA,KAAK,EAAU;IAuHnD;IACgB,aAAQ,GAAG,IAAI;IAnG3B,IAAI,CAACC,QAAQ,EAAE,CAACC,QAAQ,CAAC,IAAI,CAAC;IAC9B,IAAI,CAACC,cAAc,GAAG,IAAId,aAAa,CAAC,IAAI,CAACY,QAAQ,EAAE,CAACG,SAAS,EAAE,EAAEC,SAAS,EAAEA,SAAS,EAAEX,IAAI,CAAC;IAChG,IAAI,CAACY,mBAAmB,EAAE;IAE1B,IAAI,CAACC,kBAAkB,GAAG,IAAIP,KAAK,EAAgB;IACnD,IAAI,CAACQ,cAAc,GAAG,IAAIR,KAAK,EAAgB;IAE/C,IAAI,CAACS,aAAa,EAAE;EACxB;EAzNA;;;;EAKA,IAAWC,KAAK;IACZ,OAAO,IAAI,CAACC,MAAM;EACtB;EACA;;;;EAIA,IAAWD,KAAK,CAACE,KAAa;IAC1B,IAAI,CAACD,MAAM,GAAGC,KAAK;IACnB,IAAI,CAACC,oBAAoB,GAAG,GAAG,IAAI,IAAI,CAACH,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC;EAC/D;EASA;;;;EAKA,IAAWI,aAAa;IACpB,OAAO,IAAI,CAACC,cAAc;EAC9B;EACA;;;;EAIA,IAAWD,aAAa,CAACF,KAAa;IAClC,IAAI,CAACG,cAAc,GAAGH,KAAK;IAC3B,IAAI,CAACI,wBAAwB,EAAE;EACnC;EAGA;;;EAIA,IAAWC,MAAM;IACb,OAAO,IAAI,CAACC,OAAO;EACvB;EACA;;;EAGA,IAAWD,MAAM,CAACL,KAAa;IAC3B,IAAI,CAACM,OAAO,GAAGN,KAAK;IACpB,IAAI,CAACI,wBAAwB,EAAE;EACnC;EAaA;;;;EAIA,IAAWG,aAAa;IACpB,OAAO,IAAI,CAACC,cAAc;EAC9B;EACA;;;;EAIA,IAAWD,aAAa,CAACP,KAAc;IACnC,IAAI,IAAI,CAACQ,cAAc,KAAKR,KAAK,EAAE;MAC/B;;IAGJ,IAAI,CAACQ,cAAc,GAAGR,KAAK;IAC3B,IAAI,CAACS,uBAAuB,EAAE;EAClC;EAGA;;;EAGA,IAAWd,kBAAkB;IACzB,OAAO,IAAI,CAACe,mBAAmB;EACnC;EACA;;;EAGA,IAAWf,kBAAkB,CAACK,KAAqB;IAC/C,IAAI,CAACU,mBAAmB,GAAGV,KAAK;IAChC,IAAI,CAACW,yBAAyB,CAACX,KAAK,CAAC;EACzC;EAGA;;;EAGA,IAAWJ,cAAc;IACrB,OAAO,IAAI,CAACgB,eAAe;EAC/B;EACA;;;EAGA,IAAWhB,cAAc,CAACI,KAAqB;IAC3C,IAAI,CAACY,eAAe,GAAGZ,KAAK;IAC5B,IAAI,CAACa,qBAAqB,CAACb,KAAK,CAAC;EACrC;EAIA;;;;EAIA,IAAWc,oBAAoB;IAC3B,OAAO,IAAI,CAACC,qBAAqB;EACrC;EACA;;;;EAIA,IAAWD,oBAAoB,CAACd,KAAa;IACzC,IAAI,CAACe,qBAAqB,GAAGf,KAAK;IAClC,IAAI,CAACH,aAAa,EAAE;EACxB;EAIA;;;;EAIA,IAAWmB,wBAAwB;IAC/B,OAAO,IAAI,CAACC,yBAAyB;EACzC;EACA;;;;EAIA,IAAWD,wBAAwB,CAAChB,KAAa;IAC7C,IAAI,CAACiB,yBAAyB,GAAGjB,KAAK;IACtC,IAAI,CAACH,aAAa,EAAE;EACxB;EAIA;;;EAGA,IAAWqB,YAAY;IACnB,OAAO,IAAI,CAACC,aAAa;EAC7B;EACA;;;EAGA,IAAWD,YAAY,CAAClB,KAAa;IACjC,IAAI,IAAI,CAACmB,aAAa,KAAKnB,KAAK,EAAE;MAC9B;;IAGJ,IAAI,CAACmB,aAAa,GAAGnB,KAAK;IAC1B,IAAI,CAACS,uBAAuB,EAAE;EAClC;EAyDA;;;;;;EAMA;EACOW,wBAAwB,CAACC,MAAc,EAAEC,UAAkB;IAC9D;IACA,OAAO,IAAI;EACf;EAEA;;;;;;;;EAQOC,UAAU,CAACD,UAAkB,EAAEvC,KAAY,EAAEsC,MAAc,EAAEG,WAAoB,EAAEC,cAAc,GAAG,IAAI;;IAC3G,MAAMC,SAAS,GAAGJ,UAAU,CAACK,QAAQ,EAAE;IACvC,IAAIC,UAAU,GAAG,KAAK;IAEtB,IAAI,CAACrC,cAAc,CAACsC,YAAY,CAACR,MAAM,EAAE,OAAO,GAAGK,SAAS,CAAC;IAE7D,IAAI,IAAI,CAACI,SAAS,KAAK/C,KAAK,CAACgD,WAAW,EAAE,IAAI,IAAI,CAACC,gBAAgB,KAAKR,WAAW,IAAI,CAAC,IAAI,CAACjC,cAAc,CAAC0C,MAAM,EAAE;MAChH,IAAI,CAACH,SAAS,GAAG/C,KAAK,CAACgD,WAAW,EAAE;MACpC,IAAI,CAACC,gBAAgB,GAAGR,WAAW;MAEnC,MAAMU,eAAe,GAAG,IAAI,CAACC,kBAAkB,EAAE;MAEjD,IAAI,CAACC,gBAAgB,CAACf,MAAM,EAAEK,SAAS,CAAC;MAExC,IAAI,CAACW,OAAO,CAACC,UAAU,CAACJ,eAAe,EAAE3D,SAAS,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;MAC7D,IAAI,CAACiB,cAAc,CAACgD,YAAY,CAAC,eAAe,EAAEhE,SAAS,CAACD,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACwB,KAAK,EAAE4B,SAAS,CAAC;MAC7F,IAAIF,WAAW,EAAE;QACb,IAAI,CAACgB,QAAQ,CAACF,UAAU,CAACJ,eAAe,EAAE3D,SAAS,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;QAC9D,IAAI,CAACiB,cAAc,CAACgD,YAAY,CAAC,gBAAgB,EAAEhE,SAAS,CAACD,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC+B,MAAM,EAAEqB,SAAS,CAAC;;MAEnGE,UAAU,GAAG,IAAI;;IAGrB;IACA,IAAI,CAACR,wBAAwB,CAACC,MAAM,EAAEK,SAAS,CAAC;IAEhD;IACA,IAAI3C,KAAK,CAAC0D,cAAc,IAAI,IAAI,CAAClC,aAAa,IAAIkB,cAAc,EAAE;MAC9D,MAAMiB,eAAe,GAAG,UAAI,CAACC,kBAAkB,CAAC5D,KAAK,CAAC6D,YAAY,CAAC,mCAAI,IAAI,CAACD,kBAAkB,EAAE;MAChG,IAAID,eAAe,EAAE;QACjBA,eAAe,CAACG,eAAe,CAACnB,SAAS,EAAEL,MAAM,CAAC;QAClDO,UAAU,GAAG,IAAI;;;IAIzB,IAAIA,UAAU,EAAE;MACZ,IAAI,CAACrC,cAAc,CAACuD,MAAM,EAAE;KAC/B,MAAM;MACH,IAAI,CAACvD,cAAc,CAACwD,iBAAiB,EAAE;;EAE/C;EAUA;;;;EAIOC,YAAY;IACf,OAAO,OAAO;EAClB;EAKA;;;;;EAKOrB,QAAQ,CAACsB,WAAqB;IACjC,IAAIC,GAAG,GAAG,QAAQ,GAAG,IAAI,CAACpE,IAAI;IAC9BoE,GAAG,IAAI,UAAU,GAAG,CAAC,OAAO,EAAE,aAAa,EAAE,MAAM,EAAE,aAAa,CAAC,CAAC,IAAI,CAACC,SAAS,EAAE,CAAC;IACrF,IAAI,IAAI,CAACC,UAAU,EAAE;MACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACD,UAAU,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;QAC7CH,GAAG,IAAI,kBAAkB,GAAG,IAAI,CAACE,UAAU,CAACC,CAAC,CAAC,CAAC1B,QAAQ,CAACsB,WAAW,CAAC;;;IAG5E,OAAOC,GAAG;EACd;EAEA;EACUK,uBAAuB;IAC7B,KAAK,CAACA,uBAAuB,EAAE;IAC/B,IAAI,CAAC,IAAI,CAACC,UAAU,EAAE,EAAE;MACpB,IAAI,CAAC3D,aAAa,EAAE;;EAE5B;EAEA;;;;EAIO4D,UAAU,CAACzD,KAAc;IAC5B,KAAK,CAACyD,UAAU,CAACzD,KAAK,CAAC;IAEvB,IAAI,CAACH,aAAa,EAAE;EACxB;EAEA;;;;;EAKO8C,kBAAkB,CAACe,SAA2B,IAAI;;IACrD,IAAI,IAAI,CAACC,iBAAiB,KAAK,IAAI,EAAE;MACjC,OAAO,IAAI;;IAGf,OAAO,UAAI,CAACA,iBAAiB,CAACC,GAAG,CAACF,MAAM,CAAC,mCAAI,IAAI;EACrD;EAEA;;;;EAIOG,mBAAmB;IACtB,OAAO,IAAI,CAACF,iBAAiB;EACjC;EAEA;;;;EAIOG,mBAAmB;IACtB,OAAOzF,OAAO,CAAC0F,IAAI,EAAE;EACzB;EAEA;;;;;EAKOC,aAAa,CAACC,IAAkB;IACnC,IAAI,CAACA,IAAI,EAAE;MACP,OAAO,IAAI;;IAGf,IAAI,IAAI,CAACtE,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAAC2D,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC3D,kBAAkB,CAACuE,OAAO,CAACD,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MAC/G,OAAO,KAAK;;IAGhB,IAAI,IAAI,CAACrE,cAAc,IAAI,IAAI,CAACA,cAAc,CAAC0D,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC1D,cAAc,CAACsE,OAAO,CAACD,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;MACnG,OAAO,KAAK;;IAGhB,IAAI,IAAI,CAACjD,wBAAwB,KAAK,CAAC,IAAI,CAAC,IAAI,CAACA,wBAAwB,GAAGiD,IAAI,CAACE,SAAS,MAAM,CAAC,EAAE;MAC/F,OAAO,KAAK;;IAGhB,IAAI,IAAI,CAACrD,oBAAoB,KAAK,CAAC,IAAI,IAAI,CAACA,oBAAoB,GAAGmD,IAAI,CAACE,SAAS,EAAE;MAC/E,OAAO,KAAK;;IAGhB,OAAO,IAAI;EACf;EAEA;;;;;EAKOC,OAAO,CAACC,YAAsB,EAAEC,0BAA0B,GAAG,KAAK;IACrE,IAAI,IAAI,CAACX,iBAAiB,EAAE;MACxB,MAAMY,QAAQ,GAAG,IAAI,CAACZ,iBAAiB,CAACa,MAAM,EAAE;MAChD,KAAK,IAAIC,GAAG,GAAGF,QAAQ,CAACG,IAAI,EAAE,EAAED,GAAG,CAACE,IAAI,KAAK,IAAI,EAAEF,GAAG,GAAGF,QAAQ,CAACG,IAAI,EAAE,EAAE;QACtE,MAAMhC,eAAe,GAAG+B,GAAG,CAACzE,KAAK;QACjC0C,eAAe,CAAC0B,OAAO,EAAE;;MAE7B,IAAI,CAACT,iBAAiB,GAAG,IAAI;;IAGjC;IACA,IAAI,CAACtE,QAAQ,EAAE,CAACuF,aAAa,CAAC,IAAI,CAAC;IAEnC,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACvB,MAAMC,KAAK,GAAG,IAAI,CAACD,gBAAgB,CAACE,MAAM,CAACb,OAAO,CAAC,IAAI,CAAC;MACxD,IAAIY,KAAK,GAAG,CAAC,CAAC,EAAE;QACZ,IAAI,CAACD,gBAAgB,CAACE,MAAM,CAACC,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;;MAEjD,IAAI,CAACD,gBAAgB,GAAG,IAAI;;IAGhC;IACA,KAAK,MAAMZ,IAAI,IAAI,IAAI,CAAC5E,QAAQ,EAAE,CAAC4F,MAAM,EAAE;MACvChB,IAAI,CAACiB,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAAC;;IAGvC,IAAI,CAAC3F,cAAc,CAAC6E,OAAO,EAAE;IAE7B;IACA,IAAI,CAAC/E,QAAQ,EAAE,CAAC8F,WAAW,CAAC,IAAI,CAAC;IACjC,KAAK,CAACf,OAAO,CAACC,YAAY,EAAEC,0BAA0B,CAAC;EAC3D;EAEA;;;;EAIOnB,SAAS;IACZ,OAAO,CAAC;EACZ;EAEA;;;;EAIOhB,kBAAkB;IACrB,OAAO,IAAI,CAACiD,iBAAiB,GAAG,IAAI,CAACC,SAAS;EAClD;EAEA;;;;;;EAMOC,KAAK,CAACxG,IAAY,EAAEyG,YAA4B,IAAI;IACvD,MAAM1G,WAAW,GAAGD,KAAK,CAAC4G,sBAAsB,CAAC,IAAI,CAACrC,SAAS,EAAE,EAAErE,IAAI,EAAE,IAAI,CAACO,QAAQ,EAAE,CAAC;IAEzF,IAAI,CAACR,WAAW,EAAE;MACd,OAAO,IAAI;;IAEf,MAAM4G,WAAW,GAAGvH,mBAAmB,CAACwH,KAAK,CAAC7G,WAAW,EAAE,IAAI,CAAC;IAChE,IAAIC,IAAI,EAAE;MACN2G,WAAW,CAAC3G,IAAI,GAAGA,IAAI;;IAE3B,IAAIyG,SAAS,EAAE;MACXE,WAAW,CAACE,MAAM,GAAGJ,SAAS;;IAElCE,WAAW,CAAChC,UAAU,CAAC,IAAI,CAACmC,SAAS,EAAE,CAAC;IAExC,IAAI,CAACC,kBAAkB,CAACC,eAAe,CAACL,WAAW,CAAC;IAEpD,OAAOA,WAAW;EACtB;EAEA;;;;EAIOxH,SAAS;IACZ,MAAM8H,mBAAmB,GAAG7H,mBAAmB,CAAC8H,SAAS,CAAC,IAAI,CAAC;IAC/DD,mBAAmB,CAACE,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAE5C;IACAF,mBAAmB,CAACG,IAAI,GAAG,IAAI,CAAC/C,SAAS,EAAE;IAE3C;IACA,IAAI,IAAI,CAACwC,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAACQ,kBAAkB,CAACJ,mBAAmB,CAAC;;IAGvD;IACA,IAAI,IAAI,CAACnG,cAAc,CAAC0D,MAAM,GAAG,CAAC,EAAE;MAChCyC,mBAAmB,CAACK,iBAAiB,GAAG,EAAE;MAC1C,IAAI,CAACxG,cAAc,CAACyG,OAAO,CAAEpC,IAAkB,IAAI;QAC/C8B,mBAAmB,CAACK,iBAAiB,CAACE,IAAI,CAACrC,IAAI,CAACsC,EAAE,CAAC;MACvD,CAAC,CAAC;;IAGN,IAAI,IAAI,CAAC5G,kBAAkB,CAAC2D,MAAM,GAAG,CAAC,EAAE;MACpCyC,mBAAmB,CAACS,qBAAqB,GAAG,EAAE;MAC9C,IAAI,CAAC7G,kBAAkB,CAAC0G,OAAO,CAAEpC,IAAkB,IAAI;QACnD8B,mBAAmB,CAACS,qBAAqB,CAACF,IAAI,CAACrC,IAAI,CAACsC,EAAE,CAAC;MAC3D,CAAC,CAAC;;IAGN;IACArI,mBAAmB,CAACuI,0BAA0B,CAAC,IAAI,EAAEV,mBAAmB,CAAC;IACzEA,mBAAmB,CAACW,MAAM,GAAG,IAAI,CAACC,wBAAwB,EAAE;IAE5DZ,mBAAmB,CAACH,SAAS,GAAG,IAAI,CAACA,SAAS,EAAE;IAEhD,OAAOG,mBAAmB;EAC9B;EAEA;;;;;;;;EAQA,OAAOP,sBAAsB,CAACU,IAAY,EAAEpH,IAAY,EAAEC,KAAY;IAClE,MAAM6H,eAAe,GAAGpI,IAAI,CAACqI,SAAS,CAAC,aAAa,GAAGX,IAAI,EAAEpH,IAAI,EAAEC,KAAK,CAAC;IAEzE,IAAI6H,eAAe,EAAE;MACjB,OAAoBA,eAAe;;IAGvC;IACA,OAAO,IAAI;EACf;EAEA;;;;;;EAMO,OAAOE,KAAK,CAACC,WAAgB,EAAEhI,KAAY;IAC9C,MAAMF,WAAW,GAAGD,KAAK,CAAC4G,sBAAsB,CAACuB,WAAW,CAACb,IAAI,EAAEa,WAAW,CAACjI,IAAI,EAAEC,KAAK,CAAC;IAE3F,IAAI,CAACF,WAAW,EAAE;MACd,OAAO,IAAI;;IAGf,MAAMmI,KAAK,GAAG9I,mBAAmB,CAAC4I,KAAK,CAACjI,WAAW,EAAEkI,WAAW,EAAEhI,KAAK,CAAC;IAExE;IACA,IAAIgI,WAAW,CAACX,iBAAiB,EAAE;MAC/BY,KAAK,CAACC,kBAAkB,GAAGF,WAAW,CAACX,iBAAiB;;IAG5D,IAAIW,WAAW,CAACP,qBAAqB,EAAE;MACnCQ,KAAK,CAACE,sBAAsB,GAAGH,WAAW,CAACP,qBAAqB;;IAGpE;IACA,IAAIO,WAAW,CAACI,QAAQ,KAAK1H,SAAS,EAAE;MACpCuH,KAAK,CAACI,gBAAgB,GAAGL,WAAW,CAACI,QAAQ;;IAGjD,IAAIJ,WAAW,CAACM,mBAAmB,KAAK5H,SAAS,EAAE;MAC/CuH,KAAK,CAACM,2BAA2B,GAAGP,WAAW,CAACM,mBAAmB;;IAGvE;IACA,IAAIN,WAAW,CAACQ,WAAW,KAAK9H,SAAS,EAAE;MACvCuH,KAAK,CAACO,WAAW,GAAGR,WAAW,CAACQ,WAAW;;IAG/C;IACA,IAAIR,WAAW,CAAC7F,YAAY,KAAKzB,SAAS,EAAE;MACxCuH,KAAK,CAAC9F,YAAY,GAAG6F,WAAW,CAAC7F,YAAY;;IAGjD;IACA,IAAI6F,WAAW,CAAC3D,UAAU,EAAE;MACxB,KAAK,IAAIoE,cAAc,GAAG,CAAC,EAAEA,cAAc,GAAGT,WAAW,CAAC3D,UAAU,CAACE,MAAM,EAAEkE,cAAc,EAAE,EAAE;QAC3F,MAAMC,eAAe,GAAGV,WAAW,CAAC3D,UAAU,CAACoE,cAAc,CAAC;QAC9D,MAAME,aAAa,GAAGhJ,QAAQ,CAAC,mBAAmB,CAAC;QACnD,IAAIgJ,aAAa,EAAE;UACfV,KAAK,CAAC5D,UAAU,CAACkD,IAAI,CAACoB,aAAa,CAACZ,KAAK,CAACW,eAAe,CAAC,CAAC;;;MAGnEjJ,IAAI,CAACmJ,oBAAoB,CAACX,KAAK,EAAED,WAAW,EAAEhI,KAAK,CAAC;;IAGxD,IAAIgI,WAAW,CAACa,WAAW,EAAE;MACzB7I,KAAK,CAAC8I,cAAc,CAACb,KAAK,EAAED,WAAW,CAACe,eAAe,EAAEf,WAAW,CAACgB,aAAa,EAAEhB,WAAW,CAACiB,eAAe,EAAEjB,WAAW,CAACkB,gBAAgB,IAAI,GAAG,CAAC;;IAGzJ;IACA,IAAIlB,WAAW,CAACnB,SAAS,KAAKnG,SAAS,EAAE;MACrCuH,KAAK,CAACvD,UAAU,CAACsD,WAAW,CAACnB,SAAS,CAAC;;IAG3C,OAAOoB,KAAK;EAChB;EAEQnG,qBAAqB,CAACqH,KAAqB;IAC/C,MAAMC,OAAO,GAAGD,KAAK,CAAC5B,IAAI;IAC1B4B,KAAK,CAAC5B,IAAI,GAAG,CAAC,GAAG8B,KAAqB,KAAI;MACtC,MAAMC,MAAM,GAAGF,OAAO,CAACG,KAAK,CAACJ,KAAK,EAAEE,KAAK,CAAC;MAE1C,KAAK,MAAMG,IAAI,IAAIH,KAAK,EAAE;QACtBG,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC;;MAGjC,OAAOH,MAAM;IACjB,CAAC;IAED,MAAMI,SAAS,GAAGP,KAAK,CAAClD,MAAM;IAC9BkD,KAAK,CAAClD,MAAM,GAAG,CAACF,KAAa,EAAE4D,WAAoB,KAAI;MACnD,MAAMC,OAAO,GAAGF,SAAS,CAACH,KAAK,CAACJ,KAAK,EAAE,CAACpD,KAAK,EAAE4D,WAAW,CAAC,CAAC;MAE5D,KAAK,MAAMH,IAAI,IAAII,OAAO,EAAE;QACxBJ,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC;;MAGjC,OAAOG,OAAO;IAClB,CAAC;IAED,KAAK,MAAMJ,IAAI,IAAIL,KAAK,EAAE;MACtBK,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC;;EAErC;EAEQ7H,yBAAyB,CAACuH,KAAqB;IACnD,MAAMC,OAAO,GAAGD,KAAK,CAAC5B,IAAI;IAC1B4B,KAAK,CAAC5B,IAAI,GAAG,CAAC,GAAG8B,KAAqB,KAAI;MACtC,MAAMC,MAAM,GAAGF,OAAO,CAACG,KAAK,CAACJ,KAAK,EAAEE,KAAK,CAAC;MAE1C,IAAI,CAACvI,aAAa,EAAE;MAEpB,OAAOwI,MAAM;IACjB,CAAC;IAED,MAAMI,SAAS,GAAGP,KAAK,CAAClD,MAAM;IAC9BkD,KAAK,CAAClD,MAAM,GAAG,CAACF,KAAa,EAAE4D,WAAoB,KAAI;MACnD,MAAMC,OAAO,GAAGF,SAAS,CAACH,KAAK,CAACJ,KAAK,EAAE,CAACpD,KAAK,EAAE4D,WAAW,CAAC,CAAC;MAE5D,IAAI,CAAC7I,aAAa,EAAE;MAEpB,OAAO8I,OAAO;IAClB,CAAC;IAED,IAAI,CAAC9I,aAAa,EAAE;EACxB;EAEQA,aAAa;IACjB,KAAK,MAAMoE,IAAI,IAAI,IAAI,CAAC5E,QAAQ,EAAE,CAAC4F,MAAM,EAAE;MACvChB,IAAI,CAACuE,kBAAkB,CAAC,IAAI,CAAC;;EAErC;EAEA;;;;EAIO/H,uBAAuB;IAC1B,KAAK,MAAMwD,IAAI,IAAI,IAAI,CAAC5E,QAAQ,EAAE,CAAC4F,MAAM,EAAE;MACvC,IAAIhB,IAAI,CAAC2E,YAAY,CAAC1E,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;QACxCD,IAAI,CAAC4E,0BAA0B,EAAE;;;EAG7C;EAEA;;;EAGQzI,wBAAwB;IAC5B,IAAI,CAACgF,iBAAiB,GAAG,IAAI,CAAC0D,oBAAoB,EAAE;IACpD,IAAI,CAACzJ,QAAQ,EAAE,CAAC0J,mBAAmB,EAAE;EACzC;EAEA;;;EAGQD,oBAAoB;IACxB,IAAIE,gBAAgB,GAAG,GAAG;IAC1B,MAAMC,WAAW,GAAG,IAAI,CAAC9F,SAAS,EAAE;IAEpC;IACA,IAAI+F,eAAe,GAAG,IAAI,CAAChJ,aAAa;IACxC,IAAIgJ,eAAe,KAAKtK,KAAK,CAACO,uBAAuB,EAAE;MACnD,IAAI8J,WAAW,KAAKrK,KAAK,CAACuK,4BAA4B,EAAE;QACpDD,eAAe,GAAGtK,KAAK,CAACwK,yBAAyB;OACpD,MAAM;QACHF,eAAe,GAAGtK,KAAK,CAACyK,+BAA+B;;;IAI/D;IACA,QAAQJ,WAAW;MACf,KAAKrK,KAAK,CAAC0K,sBAAsB;MACjC,KAAK1K,KAAK,CAAC2K,qBAAqB;QAC5B,QAAQL,eAAe;UACnB,KAAKtK,KAAK,CAAC4K,2BAA2B;YAClCR,gBAAgB,GAAG,GAAG,IAAI,GAAG,GAAGS,IAAI,CAACC,EAAE,CAAC;YACxC;UACJ,KAAK9K,KAAK,CAACyK,+BAA+B;YACtCL,gBAAgB,GAAG,GAAG;YACtB;UACJ,KAAKpK,KAAK,CAAC+K,uBAAuB;YAC9BX,gBAAgB,GAAG,IAAI,CAAC3I,MAAM,GAAG,IAAI,CAACA,MAAM;YAC5C;QAAM;QAEd;MAEJ,KAAKzB,KAAK,CAACuK,4BAA4B;QACnC,QAAQD,eAAe;UACnB,KAAKtK,KAAK,CAACwK,yBAAyB;YAChCJ,gBAAgB,GAAG,GAAG;YACtB;UACJ,KAAKpK,KAAK,CAAC+K,uBAAuB;YAAE;cAChC;cACA;cACA,IAAIC,gBAAgB,GAAG,IAAI,CAACvJ,MAAM;cAClC;cACAuJ,gBAAgB,GAAGH,IAAI,CAACI,GAAG,CAACD,gBAAgB,EAAE,KAAK,CAAC;cACpD,MAAME,UAAU,GAAG,GAAG,GAAGL,IAAI,CAACC,EAAE,IAAI,GAAG,GAAGD,IAAI,CAACM,GAAG,CAACH,gBAAgB,CAAC,CAAC;cACrEZ,gBAAgB,GAAGc,UAAU;cAC7B;;QACH;QAEL;MAEJ,KAAKlL,KAAK,CAACoL,4BAA4B;QACnC;QACAhB,gBAAgB,GAAG,GAAG;QACtB;IAAM;IAEd,OAAOA,gBAAgB;EAC3B;EAEA;;;;EAIOiB,qBAAqB;IACxB,MAAMlL,KAAK,GAAG,IAAI,CAACM,QAAQ,EAAE;IAC7B,IAAI,IAAI,CAAC6K,eAAe,IAAI,CAAC,EAAE;MAC3BnL,KAAK,CAACoL,mBAAmB,GAAG,IAAI;;IAEpC,IAAI,CAAC9K,QAAQ,EAAE,CAAC+K,oBAAoB,EAAE;EAC1C;;AA32BA;;;;AAIuBxL,qBAAe,GAAGD,cAAc,CAACK,eAAe;AAEvE;;;AAGuBJ,sBAAgB,GAAGD,cAAc,CAAC0L,gBAAgB;AAEzE;;;;AAIuBzL,kBAAY,GAAGD,cAAc,CAAC2L,YAAY;AAEjE;;;;AAIuB1L,sBAAgB,GAAGD,cAAc,CAAC4L,gBAAgB;AAEzE;AACA;;;;;;AAMuB3L,sBAAgB,GAAGD,cAAc,CAAC6L,gBAAgB;AACzE;;;;;AAKuB5L,uBAAiB,GAAGD,cAAc,CAAC8L,iBAAiB;AAC3E;;;;;AAKuB7L,0BAAoB,GAAGD,cAAc,CAAC+L,oBAAoB;AAEjF;AACA;;;;;AAKuB9L,6BAAuB,GAAGD,cAAc,CAACQ,uBAAuB;AACvF;;;AAGuBP,iCAA2B,GAAGD,cAAc,CAAC6K,2BAA2B;AAC/F;;;AAGuB5K,qCAA+B,GAAGD,cAAc,CAAC0K,+BAA+B;AACvG;;;AAGuBzK,+BAAyB,GAAGD,cAAc,CAACyK,yBAAyB;AAC3F;;;AAGuBxK,6BAAuB,GAAGD,cAAc,CAACgL,uBAAuB;AAEvF;AACA;;;AAGuB/K,4BAAsB,GAAGD,cAAc,CAAC2K,sBAAsB;AACrF;;;AAGuB1K,kCAA4B,GAAGD,cAAc,CAACwK,4BAA4B;AACjG;;;AAGuBvK,2BAAqB,GAAGD,cAAc,CAAC4K,qBAAqB;AACnF;;;AAGuB3K,kCAA4B,GAAGD,cAAc,CAACqL,4BAA4B;AAMjGW,YADCxM,iBAAiB,EAAE,sCACuB;AAO3CwM,YADCxM,iBAAiB,EAAE,uCACwB;AAW5CwM,YADC1M,SAAS,EAAE,0CAC+B;AAQ3C0M,YADC1M,SAAS,EAAE,wCACW;AAUvB0M,YADC1M,SAAS,EAAE,kCAGX;AAsBD0M,YADC1M,SAAS,EAAE,0CAGX;AAeD0M,YADC1M,SAAS,EAAE,mCAGX;AAUD0M,YADC1M,SAAS,EAAE,8CACoB;AAMhC0M,YADCvM,gBAAgB,CAAC,uBAAuB,CAAC,6CACR;AAGlCuM,YADC1M,SAAS,CAAC,eAAe,CAAC,6CACY;AAoDvC0M,YADC1M,SAAS,CAAC,sBAAsB,CAAC,oDACA;AAkBlC0M,YADC1M,SAAS,CAAC,0BAA0B,CAAC,wDACA;AAkBtC0M,YADC1M,SAAS,CAAC,cAAc,CAAC,4CACA","names":["serialize","SerializationHelper","serializeAsColor3","expandToProperty","Vector3","Color3","TmpColors","Node","UniformBuffer","GetClass","LightConstants","Light","constructor","name","scene","FALLOFF_DEFAULT","Number","MAX_VALUE","INTENSITYMODE_AUTOMATIC","Array","getScene","addLight","_uniformBuffer","getEngine","undefined","_buildUniformLayout","includedOnlyMeshes","excludedMeshes","_resyncMeshes","range","_range","value","_inverseSquaredRange","intensityMode","_intensityMode","_computePhotometricScale","radius","_radius","shadowEnabled","_shadowEnabled","_markMeshesAsLightDirty","_includedOnlyMeshes","_hookArrayForIncludedOnly","_excludedMeshes","_hookArrayForExcluded","excludeWithLayerMask","_excludeWithLayerMask","includeOnlyWithLayerMask","_includeOnlyWithLayerMask","lightmapMode","_lightmapMode","transferTexturesToEffect","effect","lightIndex","_bindLight","useSpecular","receiveShadows","iAsString","toString","needUpdate","bindToEffect","_renderId","getRenderId","_lastUseSpecular","useUbo","scaledIntensity","getScaledIntensity","transferToEffect","diffuse","scaleToRef","updateColor4","specular","shadowsEnabled","shadowGenerator","getShadowGenerator","activeCamera","bindShadowLight","update","bindUniformBuffer","getClassName","fullDetails","ret","getTypeID","animations","i","length","_syncParentEnabledState","isDisposed","setEnabled","camera","_shadowGenerators","get","getShadowGenerators","getAbsolutePosition","Zero","canAffectMesh","mesh","indexOf","layerMask","dispose","doNotRecurse","disposeMaterialAndTextures","iterator","values","key","next","done","stopAnimation","_parentContainer","index","lights","splice","meshes","_removeLightSource","removeLight","_photometricScale","intensity","clone","newParent","GetConstructorFromName","clonedLight","Clone","parent","isEnabled","onClonedObservable","notifyObservers","serializationObject","Serialize","uniqueId","type","_serializeAsParent","excludedMeshesIds","forEach","push","id","includedOnlyMeshesIds","AppendSerializedAnimations","ranges","serializeAnimationRanges","constructorFunc","Construct","Parse","parsedLight","light","_excludedMeshesIds","_includedOnlyMeshesIds","parentId","_waitingParentId","parentInstanceIndex","_waitingParentInstanceIndex","falloffType","animationIndex","parsedAnimation","internalClass","ParseAnimationRanges","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","array","oldPush","items","result","apply","item","_resyncLightSource","oldSplice","deleteCount","deleted","lightSources","_markSubMeshesAsLightDirty","_getPhotometricScale","resetCachedMaterial","photometricScale","lightTypeID","photometricMode","LIGHTTYPEID_DIRECTIONALLIGHT","INTENSITYMODE_ILLUMINANCE","INTENSITYMODE_LUMINOUSINTENSITY","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_SPOTLIGHT","INTENSITYMODE_LUMINOUSPOWER","Math","PI","INTENSITYMODE_LUMINANCE","apexAngleRadians","max","solidAngle","cos","LIGHTTYPEID_HEMISPHERICLIGHT","_reorderLightsInScene","_renderPriority","requireLightSorting","sortLightsByPriority","FALLOFF_PHYSICAL","FALLOFF_GLTF","FALLOFF_STANDARD","LIGHTMAP_DEFAULT","LIGHTMAP_SPECULAR","LIGHTMAP_SHADOWSONLY","__decorate"],"sourceRoot":"","sources":["../../../../lts/core/generated/Lights/light.ts"],"sourcesContent":["import { serialize, SerializationHelper, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = new Array<AbstractMesh>();\r\n        this.excludedMeshes = new Array<AbstractMesh>();\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * Returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}