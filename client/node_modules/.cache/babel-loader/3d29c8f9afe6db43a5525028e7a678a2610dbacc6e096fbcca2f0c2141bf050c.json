{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Animation } from \"./animation.js\";\nimport { RuntimeAnimation } from \"./runtimeAnimation.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Scene } from \"../scene.js\";\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { PrecisionDate } from \"../Misc/precisionDate.js\";\nimport { Bone } from \"../Bones/bone.js\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n  /**\n   * Creates a new Animatable\n   * @param scene defines the hosting scene\n   * @param target defines the target object\n   * @param fromFrame defines the starting frame number (default is 0)\n   * @param toFrame defines the ending frame number (default is 100)\n   * @param loopAnimation defines if the animation must loop (default is false)\n   * @param speedRatio defines the factor to apply to animation speed (default is 1)\n   * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n   * @param animations defines a group of animation to add to the new Animatable\n   * @param onAnimationLoop defines a callback to call when animation loops\n   * @param isAdditive defines whether the animation should be evaluated additively\n   */\n  constructor(scene, /** defines the target object */\n  target, /** defines the starting frame number (default is 0) */\n  fromFrame = 0, /** defines the ending frame number (default is 100) */\n  toFrame = 100, /** defines if the animation must loop (default is false)  */\n  loopAnimation = false, speedRatio = 1.0, /** defines a callback to call when animation ends if it is not looping */\n  onAnimationEnd, animations, /** defines a callback to call when animation loops */\n  onAnimationLoop, /** defines whether the animation should be evaluated additively */\n  isAdditive = false) {\n    this.target = target;\n    this.fromFrame = fromFrame;\n    this.toFrame = toFrame;\n    this.loopAnimation = loopAnimation;\n    this.onAnimationEnd = onAnimationEnd;\n    this.onAnimationLoop = onAnimationLoop;\n    this.isAdditive = isAdditive;\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n    this._manualJumpDelay = null;\n    this._runtimeAnimations = new Array();\n    this._paused = false;\n    this._speedRatio = 1;\n    this._weight = -1.0;\n    this._syncRoot = null;\n    this._frameToSyncFromJump = null;\n    this._goToFrame = null;\n    /**\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n     * This will only apply for non looping animation (default is true)\n     */\n    this.disposeOnEnd = true;\n    /**\n     * Gets a boolean indicating if the animation has started\n     */\n    this.animationStarted = false;\n    /**\n     * Observer raised when the animation ends\n     */\n    this.onAnimationEndObservable = new Observable();\n    /**\n     * Observer raised when the animation loops\n     */\n    this.onAnimationLoopObservable = new Observable();\n    this._scene = scene;\n    if (animations) {\n      this.appendAnimations(target, animations);\n    }\n    this._speedRatio = speedRatio;\n    scene._activeAnimatables.push(this);\n  }\n  /**\n   * Gets the root Animatable used to synchronize and normalize animations\n   */\n  get syncRoot() {\n    return this._syncRoot;\n  }\n  /**\n   * Gets the current frame of the first RuntimeAnimation\n   * Used to synchronize Animatables\n   */\n  get masterFrame() {\n    if (this._runtimeAnimations.length === 0) {\n      return 0;\n    }\n    return this._runtimeAnimations[0].currentFrame;\n  }\n  /**\n   * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n   */\n  get weight() {\n    return this._weight;\n  }\n  set weight(value) {\n    if (value === -1) {\n      // -1 is ok and means no weight\n      this._weight = -1;\n      return;\n    }\n    // Else weight must be in [0, 1] range\n    this._weight = Math.min(Math.max(value, 0), 1.0);\n  }\n  /**\n   * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n   */\n  get speedRatio() {\n    return this._speedRatio;\n  }\n  set speedRatio(value) {\n    for (let index = 0; index < this._runtimeAnimations.length; index++) {\n      const animation = this._runtimeAnimations[index];\n      animation._prepareForSpeedRatioChange(value);\n    }\n    this._speedRatio = value;\n    // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n    if (this._goToFrame !== null) {\n      this.goToFrame(this._goToFrame);\n    }\n  }\n  // Methods\n  /**\n   * Synchronize and normalize current Animatable with a source Animatable\n   * This is useful when using animation weights and when animations are not of the same length\n   * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n   * @returns the current Animatable\n   */\n  syncWith(root) {\n    this._syncRoot = root;\n    if (root) {\n      // Make sure this animatable will animate after the root\n      const index = this._scene._activeAnimatables.indexOf(this);\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n        this._scene._activeAnimatables.push(this);\n      }\n    }\n    return this;\n  }\n  /**\n   * Gets the list of runtime animations\n   * @returns an array of RuntimeAnimation\n   */\n  getAnimations() {\n    return this._runtimeAnimations;\n  }\n  /**\n   * Adds more animations to the current animatable\n   * @param target defines the target of the animations\n   * @param animations defines the new animations to add\n   */\n  appendAnimations(target, animations) {\n    for (let index = 0; index < animations.length; index++) {\n      const animation = animations[index];\n      const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n      newRuntimeAnimation._onLoop = () => {\n        this.onAnimationLoopObservable.notifyObservers(this);\n        if (this.onAnimationLoop) {\n          this.onAnimationLoop();\n        }\n      };\n      this._runtimeAnimations.push(newRuntimeAnimation);\n    }\n  }\n  /**\n   * Gets the source animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the source animation for the given property\n   */\n  getAnimationByTargetProperty(property) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index].animation;\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets the runtime animation for a specific property\n   * @param property defines the property to look for\n   * @returns null or the runtime animation for the given property\n   */\n  getRuntimeAnimationByTargetProperty(property) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      if (runtimeAnimations[index].animation.targetProperty === property) {\n        return runtimeAnimations[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * Resets the animatable to its original state\n   */\n  reset() {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].reset(true);\n    }\n    this._localDelayOffset = null;\n    this._pausedDelay = null;\n  }\n  /**\n   * Allows the animatable to blend with current running animations\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   * @param blendingSpeed defines the blending speed to use\n   */\n  enableBlending(blendingSpeed) {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = true;\n      runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n    }\n  }\n  /**\n   * Disable animation blending\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   */\n  disableBlending() {\n    const runtimeAnimations = this._runtimeAnimations;\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].animation.enableBlending = false;\n    }\n  }\n  /**\n   * Jump directly to a given frame\n   * @param frame defines the frame to jump to\n   */\n  goToFrame(frame) {\n    var _a;\n    const runtimeAnimations = this._runtimeAnimations;\n    if (runtimeAnimations[0]) {\n      const fps = runtimeAnimations[0].animation.framePerSecond;\n      this._frameToSyncFromJump = (_a = this._frameToSyncFromJump) !== null && _a !== void 0 ? _a : runtimeAnimations[0].currentFrame;\n      const delay = this.speedRatio === 0 ? 0 : (frame - this._frameToSyncFromJump) / fps * 1000 / this.speedRatio;\n      this._manualJumpDelay = -delay;\n    }\n    for (let index = 0; index < runtimeAnimations.length; index++) {\n      runtimeAnimations[index].goToFrame(frame);\n    }\n    this._goToFrame = frame;\n  }\n  /**\n   * Pause the animation\n   */\n  pause() {\n    if (this._paused) {\n      return;\n    }\n    this._paused = true;\n  }\n  /**\n   * Restart the animation\n   */\n  restart() {\n    this._paused = false;\n  }\n  _raiseOnAnimationEnd() {\n    if (this.onAnimationEnd) {\n      this.onAnimationEnd();\n    }\n    this.onAnimationEndObservable.notifyObservers(this);\n  }\n  /**\n   * Stop and delete the current animation\n   * @param animationName defines a string used to only stop some of the runtime animations instead of all\n   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n   */\n  stop(animationName, targetMask) {\n    if (animationName || targetMask) {\n      const idx = this._scene._activeAnimatables.indexOf(this);\n      if (idx > -1) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n          const runtimeAnimation = runtimeAnimations[index];\n          if (animationName && runtimeAnimation.animation.name != animationName) {\n            continue;\n          }\n          if (targetMask && !targetMask(runtimeAnimation.target)) {\n            continue;\n          }\n          runtimeAnimation.dispose();\n          runtimeAnimations.splice(index, 1);\n        }\n        if (runtimeAnimations.length == 0) {\n          this._scene._activeAnimatables.splice(idx, 1);\n          this._raiseOnAnimationEnd();\n        }\n      }\n    } else {\n      const index = this._scene._activeAnimatables.indexOf(this);\n      if (index > -1) {\n        this._scene._activeAnimatables.splice(index, 1);\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n        this._raiseOnAnimationEnd();\n      }\n    }\n  }\n  /**\n   * Wait asynchronously for the animation to end\n   * @returns a promise which will be fulfilled when the animation ends\n   */\n  waitAsync() {\n    return new Promise(resolve => {\n      this.onAnimationEndObservable.add(() => {\n        resolve(this);\n      }, undefined, undefined, this, true);\n    });\n  }\n  /**\n   * @internal\n   */\n  _animate(delay) {\n    if (this._paused) {\n      this.animationStarted = false;\n      if (this._pausedDelay === null) {\n        this._pausedDelay = delay;\n      }\n      return true;\n    }\n    if (this._localDelayOffset === null) {\n      this._localDelayOffset = delay;\n      this._pausedDelay = null;\n    } else if (this._pausedDelay !== null) {\n      this._localDelayOffset += delay - this._pausedDelay;\n      this._pausedDelay = null;\n    }\n    if (this._manualJumpDelay !== null) {\n      this._localDelayOffset += this._manualJumpDelay;\n      this._manualJumpDelay = null;\n      this._frameToSyncFromJump = null;\n    }\n    this._goToFrame = null;\n    if (this._weight === 0) {\n      // We consider that an animation with a weight === 0 is \"actively\" paused\n      return true;\n    }\n    // Animating\n    let running = false;\n    const runtimeAnimations = this._runtimeAnimations;\n    let index;\n    for (index = 0; index < runtimeAnimations.length; index++) {\n      const animation = runtimeAnimations[index];\n      const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n      running = running || isRunning;\n    }\n    this.animationStarted = running;\n    if (!running) {\n      if (this.disposeOnEnd) {\n        // Remove from active animatables\n        index = this._scene._activeAnimatables.indexOf(this);\n        this._scene._activeAnimatables.splice(index, 1);\n        // Dispose all runtime animations\n        for (index = 0; index < runtimeAnimations.length; index++) {\n          runtimeAnimations[index].dispose();\n        }\n      }\n      this._raiseOnAnimationEnd();\n      if (this.disposeOnEnd) {\n        this.onAnimationEnd = null;\n        this.onAnimationLoop = null;\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationEndObservable.clear();\n      }\n    }\n    return running;\n  }\n}\nScene.prototype._animate = function () {\n  if (!this.animationsEnabled) {\n    return;\n  }\n  // Getting time\n  const now = PrecisionDate.Now;\n  if (!this._animationTimeLast) {\n    if (this._pendingData.length > 0) {\n      return;\n    }\n    this._animationTimeLast = now;\n  }\n  this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n  this._animationTimeLast = now;\n  const animatables = this._activeAnimatables;\n  if (animatables.length === 0) {\n    return;\n  }\n  this._animationTime += this.deltaTime;\n  const animationTime = this._animationTime;\n  for (let index = 0; index < animatables.length; index++) {\n    const animatable = animatables[index];\n    if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n      index--; // Array was updated\n    }\n  }\n  // Late animation bindings\n  this._processLateAnimationBindings();\n};\nScene.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n  const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n  returnedAnimatable.weight = weight;\n  return returnedAnimatable;\n};\nScene.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  }\n  if (stopCurrent) {\n    this.stopAnimation(target, undefined, targetMask);\n  }\n  if (!animatable) {\n    animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n  }\n  const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n  // Local animations\n  if (target.animations && shouldRunTargetAnimations) {\n    animatable.appendAnimations(target, target.animations);\n  }\n  // Children animations\n  if (target.getAnimatables) {\n    const animatables = target.getAnimatables();\n    for (let index = 0; index < animatables.length; index++) {\n      this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n    }\n  }\n  animatable.reset();\n  return animatable;\n};\nScene.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n  const children = target.getDescendants(directDescendantsOnly);\n  const result = [];\n  result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  for (const child of children) {\n    result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n  }\n  return result;\n};\nScene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n  if (speedRatio === undefined) {\n    speedRatio = 1.0;\n  }\n  if (from > to && speedRatio > 0) {\n    speedRatio *= -1;\n  } else if (to > from && speedRatio < 0) {\n    const temp = to;\n    to = from;\n    from = temp;\n  }\n  const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n  return animatable;\n};\nScene.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n  const children = target.getDescendants(directDescendantsOnly);\n  const result = [];\n  result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  for (const child of children) {\n    result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n  }\n  return result;\n};\nScene.prototype.getAnimatableByTarget = function (target) {\n  for (let index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      return this._activeAnimatables[index];\n    }\n  }\n  return null;\n};\nScene.prototype.getAllAnimatablesByTarget = function (target) {\n  const result = [];\n  for (let index = 0; index < this._activeAnimatables.length; index++) {\n    if (this._activeAnimatables[index].target === target) {\n      result.push(this._activeAnimatables[index]);\n    }\n  }\n  return result;\n};\n/**\n * Will stop the animation of the given target\n * @param target - the target\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n */\nScene.prototype.stopAnimation = function (target, animationName, targetMask) {\n  const animatables = this.getAllAnimatablesByTarget(target);\n  for (const animatable of animatables) {\n    animatable.stop(animationName, targetMask);\n  }\n};\n/**\n * Stops and removes all animations that have been applied to the scene\n */\nScene.prototype.stopAllAnimations = function () {\n  if (this._activeAnimatables) {\n    for (let i = 0; i < this._activeAnimatables.length; i++) {\n      this._activeAnimatables[i].stop();\n    }\n    this._activeAnimatables.length = 0;\n  }\n  for (const group of this.animationGroups) {\n    group.stop();\n  }\n};\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation, originalValue) {\n  const target = runtimeAnimation.target;\n  this._registeredForLateAnimationBindings.pushNoDuplicate(target);\n  if (!target._lateAnimationHolders) {\n    target._lateAnimationHolders = {};\n  }\n  if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n      totalWeight: 0,\n      totalAdditiveWeight: 0,\n      animations: [],\n      additiveAnimations: [],\n      originalValue: originalValue\n    };\n  }\n  if (runtimeAnimation.isAdditive) {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n  } else {\n    target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n    target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n  }\n};\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return holder.originalValue;\n  }\n  let normalizer = 1.0;\n  const finalPosition = TmpVectors.Vector3[0];\n  const finalScaling = TmpVectors.Vector3[1];\n  const finalQuaternion = TmpVectors.Quaternion[0];\n  let startIndex = 0;\n  const originalAnimation = holder.animations[0];\n  const originalValue = holder.originalValue;\n  let scale = 1;\n  let skipOverride = false;\n  if (holder.totalWeight < 1.0) {\n    // We need to mix the original value in\n    scale = 1.0 - holder.totalWeight;\n    originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  } else {\n    startIndex = 1;\n    // We need to normalize the weights\n    normalizer = holder.totalWeight;\n    scale = originalAnimation.weight / normalizer;\n    if (scale == 1) {\n      if (holder.totalAdditiveWeight) {\n        skipOverride = true;\n      } else {\n        return originalAnimation.currentValue;\n      }\n    }\n    originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n  }\n  // Add up the override animations\n  if (!skipOverride) {\n    finalScaling.scaleInPlace(scale);\n    finalPosition.scaleInPlace(scale);\n    finalQuaternion.scaleInPlace(scale);\n    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n      const runtimeAnimation = holder.animations[animIndex];\n      if (runtimeAnimation.weight === 0) {\n        continue;\n      }\n      scale = runtimeAnimation.weight / normalizer;\n      const currentPosition = TmpVectors.Vector3[2];\n      const currentScaling = TmpVectors.Vector3[3];\n      const currentQuaternion = TmpVectors.Quaternion[1];\n      runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n      currentScaling.scaleAndAddToRef(scale, finalScaling);\n      currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n      currentPosition.scaleAndAddToRef(scale, finalPosition);\n    }\n    finalQuaternion.normalize();\n  }\n  // Add up the additive animations\n  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    const runtimeAnimation = holder.additiveAnimations[animIndex];\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n    const currentPosition = TmpVectors.Vector3[2];\n    const currentScaling = TmpVectors.Vector3[3];\n    const currentQuaternion = TmpVectors.Quaternion[1];\n    runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n    currentScaling.multiplyToRef(finalScaling, currentScaling);\n    Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n    finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n    Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n    currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n  }\n  const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n  Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n  return workValue;\n};\nScene.prototype._processLateAnimationBindingsForQuaternions = function (holder, refQuaternion) {\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n    return refQuaternion;\n  }\n  const originalAnimation = holder.animations[0];\n  const originalValue = holder.originalValue;\n  let cumulativeQuaternion = refQuaternion;\n  if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n    cumulativeQuaternion.copyFrom(originalValue);\n  } else if (holder.animations.length === 1) {\n    Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n    if (holder.totalAdditiveWeight === 0) {\n      return cumulativeQuaternion;\n    }\n  } else if (holder.animations.length > 1) {\n    // Add up the override animations\n    let normalizer = 1.0;\n    let quaternions;\n    let weights;\n    if (holder.totalWeight < 1.0) {\n      const scale = 1.0 - holder.totalWeight;\n      quaternions = [];\n      weights = [];\n      quaternions.push(originalValue);\n      weights.push(scale);\n    } else {\n      if (holder.animations.length === 2) {\n        // Slerp as soon as we can\n        Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n          return refQuaternion;\n        }\n      }\n      quaternions = [];\n      weights = [];\n      normalizer = holder.totalWeight;\n    }\n    for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n      const runtimeAnimation = holder.animations[animIndex];\n      quaternions.push(runtimeAnimation.currentValue);\n      weights.push(runtimeAnimation.weight / normalizer);\n    }\n    // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n    let cumulativeAmount = 0;\n    for (let index = 0; index < quaternions.length;) {\n      if (!index) {\n        Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n        cumulativeQuaternion = refQuaternion;\n        cumulativeAmount = weights[index] + weights[index + 1];\n        index += 2;\n        continue;\n      }\n      cumulativeAmount += weights[index];\n      Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n      index++;\n    }\n  }\n  // Add up the additive animations\n  for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n    const runtimeAnimation = holder.additiveAnimations[animIndex];\n    if (runtimeAnimation.weight === 0) {\n      continue;\n    }\n    cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n    Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n  }\n  return cumulativeQuaternion;\n};\nScene.prototype._processLateAnimationBindings = function () {\n  if (!this._registeredForLateAnimationBindings.length) {\n    return;\n  }\n  for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\n    const target = this._registeredForLateAnimationBindings.data[index];\n    for (const path in target._lateAnimationHolders) {\n      const holder = target._lateAnimationHolders[path];\n      const originalAnimation = holder.animations[0];\n      const originalValue = holder.originalValue;\n      if (originalValue === undefined || originalValue === null) {\n        continue;\n      }\n      const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n      let finalValue = target[path];\n      if (matrixDecomposeMode) {\n        finalValue = this._processLateAnimationBindingsForMatrices(holder);\n      } else {\n        const quaternionMode = originalValue.w !== undefined;\n        if (quaternionMode) {\n          finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n        } else {\n          let startIndex = 0;\n          let normalizer = 1.0;\n          if (holder.totalWeight < 1.0) {\n            // We need to mix the original value in\n            if (originalAnimation && originalValue.scale) {\n              finalValue = originalValue.scale(1.0 - holder.totalWeight);\n            } else if (originalAnimation) {\n              finalValue = originalValue * (1.0 - holder.totalWeight);\n            } else if (originalValue.clone) {\n              finalValue = originalValue.clone();\n            } else {\n              finalValue = originalValue;\n            }\n          } else if (originalAnimation) {\n            // We need to normalize the weights\n            normalizer = holder.totalWeight;\n            const scale = originalAnimation.weight / normalizer;\n            if (scale !== 1) {\n              if (originalAnimation.currentValue.scale) {\n                finalValue = originalAnimation.currentValue.scale(scale);\n              } else {\n                finalValue = originalAnimation.currentValue * scale;\n              }\n            } else {\n              finalValue = originalAnimation.currentValue;\n            }\n            startIndex = 1;\n          }\n          // Add up the override animations\n          for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            const scale = runtimeAnimation.weight / normalizer;\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n          // Add up the additive animations\n          for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n            const runtimeAnimation = holder.additiveAnimations[animIndex];\n            const scale = runtimeAnimation.weight;\n            if (!scale) {\n              continue;\n            } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n              runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n            } else {\n              finalValue += runtimeAnimation.currentValue * scale;\n            }\n          }\n        }\n      }\n      target[path] = finalValue;\n    }\n    target._lateAnimationHolders = {};\n  }\n  this._registeredForLateAnimationBindings.reset();\n};\nBone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n  // all animation may be coming from a library skeleton, so may need to create animation\n  if (this.animations.length === 0) {\n    this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n    this.animations[0].setKeys([]);\n  }\n  // get animation info / verify there is such a range from the source bone\n  const sourceRange = source.animations[0].getRange(rangeName);\n  if (!sourceRange) {\n    return false;\n  }\n  const from = sourceRange.from;\n  const to = sourceRange.to;\n  const sourceKeys = source.animations[0].getKeys();\n  // rescaling prep\n  const sourceBoneLength = source.length;\n  const sourceParent = source.getParent();\n  const parent = this.getParent();\n  const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n  const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n  const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n  const destKeys = this.animations[0].getKeys();\n  // loop vars declaration\n  let orig;\n  let origTranslation;\n  let mat;\n  for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n    orig = sourceKeys[key];\n    if (orig.frame >= from && orig.frame <= to) {\n      if (rescaleAsRequired) {\n        mat = orig.value.clone();\n        // scale based on parent ratio, when bone has parent\n        if (parentScalingReqd) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n          // scale based on skeleton dimension ratio when root bone, and value is passed\n        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\n          origTranslation = mat.getTranslation();\n          mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n          // use original when root bone, and no data for skelDimensionsRatio\n        } else {\n          mat = orig.value;\n        }\n      } else {\n        mat = orig.value;\n      }\n      destKeys.push({\n        frame: orig.frame + frameOffset,\n        value: mat\n      });\n    }\n  }\n  this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n  return true;\n};","map":{"version":3,"mappings":"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","names":["Animation","RuntimeAnimation","Observable","Scene","Matrix","Quaternion","Vector3","TmpVectors","PrecisionDate","Bone","Animatable","constructor","scene","target","fromFrame","toFrame","loopAnimation","speedRatio","onAnimationEnd","animations","onAnimationLoop","isAdditive","Array","_scene","appendAnimations","_speedRatio","_activeAnimatables","push","syncRoot","_syncRoot","masterFrame","_runtimeAnimations","length","currentFrame","weight","_weight","value","Math","min","max","index","animation","_prepareForSpeedRatioChange","_goToFrame","goToFrame","syncWith","root","indexOf","splice","getAnimations","newRuntimeAnimation","_onLoop","onAnimationLoopObservable","notifyObservers","getAnimationByTargetProperty","property","runtimeAnimations","targetProperty","getRuntimeAnimationByTargetProperty","reset","_localDelayOffset","_pausedDelay","enableBlending","blendingSpeed","disableBlending","frame","fps","framePerSecond","_frameToSyncFromJump","delay","_manualJumpDelay","pause","_paused","restart","_raiseOnAnimationEnd","onAnimationEndObservable","stop","animationName","targetMask","idx","runtimeAnimation","name","dispose","waitAsync","Promise","resolve","add","undefined","_animate","animationStarted","running","isRunning","animate","disposeOnEnd","clear","prototype","animationsEnabled","now","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","_animationTime","animationTime","animatable","_processLateAnimationBindings","beginWeightedAnimation","from","to","loop","returnedAnimatable","beginAnimation","stopCurrent","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","child","beginDirectAnimation","temp","beginDirectHierarchyAnimation","getAnimatableByTarget","getAllAnimatablesByTarget","stopAllAnimations","i","group","animationGroups","_registerTargetForLateAnimationBinding","originalValue","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","targetPath","totalWeight","totalAdditiveWeight","additiveAnimations","_processLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","finalScaling","finalQuaternion","startIndex","originalAnimation","scale","skipOverride","decompose","currentValue","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","Dot","normalize","multiplyToRef","LerpToRef","SlerpToRef","workValue","_animationState","clone","ComposeToRef","_processLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","copyFrom","quaternions","weights","cumulativeAmount","data","path","matrixDecomposeMode","AllowMatrixDecomposeForInterpolation","m","finalValue","quaternionMode","w","Identity","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","ANIMATIONTYPE_MATRIX","setKeys","sourceRange","getRange","sourceKeys","getKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","key","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange"],"sourceRoot":"","sources":["../../../../lts/core/generated/Animations/animatable.ts"],"sourcesContent":["import { Animation } from \"./animation\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Quaternion, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    private _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     */\r\n    public goToFrame(frame: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    this._scene._activeAnimatables.splice(idx, 1);\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._raiseOnAnimationEnd();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public waitAsync(): Promise<Animatable> {\r\n        return new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (this._weight === 0) {\r\n            // We consider that an animation with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindingsForMatrices(holder: {\r\n            totalWeight: number;\r\n            totalAdditiveWeight: number;\r\n            animations: RuntimeAnimation[];\r\n            additiveAnimations: RuntimeAnimation[];\r\n            originalValue: Matrix;\r\n        }): any;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindingsForQuaternions(\r\n            holder: {\r\n                totalWeight: number;\r\n                totalAdditiveWeight: number;\r\n                animations: RuntimeAnimation[];\r\n                additiveAnimations: RuntimeAnimation[];\r\n                originalValue: Quaternion;\r\n            },\r\n            refQuaternion: Quaternion\r\n        ): Quaternion;\r\n\r\n        /** @internal */\r\n        _processLateAnimationBindings(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n\r\n        /**\r\n         * Gets the current delta time used by animation engine\r\n         */\r\n        deltaTime: number;\r\n    }\r\n}\r\n\r\nScene.prototype._animate = function (): void {\r\n    if (!this.animationsEnabled) {\r\n        return;\r\n    }\r\n\r\n    // Getting time\r\n    const now = PrecisionDate.Now;\r\n    if (!this._animationTimeLast) {\r\n        if (this._pendingData.length > 0) {\r\n            return;\r\n        }\r\n        this._animationTimeLast = now;\r\n    }\r\n\r\n    this.deltaTime = this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n    this._animationTimeLast = now;\r\n\r\n    const animatables = this._activeAnimatables;\r\n    if (animatables.length === 0) {\r\n        return;\r\n    }\r\n\r\n    this._animationTime += this.deltaTime;\r\n    const animationTime = this._animationTime;\r\n\r\n    for (let index = 0; index < animatables.length; index++) {\r\n        const animatable = animatables[index];\r\n\r\n        if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n            index--; // Array was updated\r\n        }\r\n    }\r\n\r\n    // Late animation bindings\r\n    this._processLateAnimationBindings();\r\n};\r\n\r\nScene.prototype.beginWeightedAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    weight = 1.0,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n    returnedAnimatable.weight = weight;\r\n\r\n    return returnedAnimatable;\r\n};\r\n\r\nScene.prototype.beginAnimation = function (\r\n    target: any,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    }\r\n\r\n    if (stopCurrent) {\r\n        this.stopAnimation(target, undefined, targetMask);\r\n    }\r\n\r\n    if (!animatable) {\r\n        animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n    }\r\n\r\n    const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n    // Local animations\r\n    if (target.animations && shouldRunTargetAnimations) {\r\n        animatable.appendAnimations(target, target.animations);\r\n    }\r\n\r\n    // Children animations\r\n    if (target.getAnimatables) {\r\n        const animatables = target.getAnimatables();\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n        }\r\n    }\r\n\r\n    animatable.reset();\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginHierarchyAnimation = function (\r\n    target: any,\r\n    directDescendantsOnly: boolean,\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio: number = 1.0,\r\n    onAnimationEnd?: () => void,\r\n    animatable?: Animatable,\r\n    stopCurrent = true,\r\n    targetMask?: (target: any) => boolean,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.beginDirectAnimation = function (\r\n    target: any,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable {\r\n    if (speedRatio === undefined) {\r\n        speedRatio = 1.0;\r\n    }\r\n\r\n    if (from > to && speedRatio > 0) {\r\n        speedRatio *= -1;\r\n    } else if (to > from && speedRatio < 0) {\r\n        const temp = to;\r\n        to = from;\r\n        from = temp;\r\n    }\r\n\r\n    const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n    return animatable;\r\n};\r\n\r\nScene.prototype.beginDirectHierarchyAnimation = function (\r\n    target: Node,\r\n    directDescendantsOnly: boolean,\r\n    animations: Animation[],\r\n    from: number,\r\n    to: number,\r\n    loop?: boolean,\r\n    speedRatio?: number,\r\n    onAnimationEnd?: () => void,\r\n    onAnimationLoop?: () => void,\r\n    isAdditive = false\r\n): Animatable[] {\r\n    const children = target.getDescendants(directDescendantsOnly);\r\n\r\n    const result = [];\r\n    result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    for (const child of children) {\r\n        result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            return this._activeAnimatables[index];\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nScene.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n    const result = [];\r\n    for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n        if (this._activeAnimatables[index].target === target) {\r\n            result.push(this._activeAnimatables[index]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/**\r\n * Will stop the animation of the given target\r\n * @param target - the target\r\n * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\r\n * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n */\r\nScene.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n    const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n    for (const animatable of animatables) {\r\n        animatable.stop(animationName, targetMask);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops and removes all animations that have been applied to the scene\r\n */\r\nScene.prototype.stopAllAnimations = function (): void {\r\n    if (this._activeAnimatables) {\r\n        for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n            this._activeAnimatables[i].stop();\r\n        }\r\n        this._activeAnimatables.length = 0;\r\n    }\r\n\r\n    for (const group of this.animationGroups) {\r\n        group.stop();\r\n    }\r\n};\r\n\r\nScene.prototype._registerTargetForLateAnimationBinding = function (runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    this._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForMatrices = function (holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindingsForQuaternions = function (\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion!;\r\n};\r\n\r\nScene.prototype._processLateAnimationBindings = function (): void {\r\n    if (!this._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < this._registeredForLateAnimationBindings.length; index++) {\r\n        const target = this._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = this._processLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = this._processLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    this._registeredForLateAnimationBindings.reset();\r\n};\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\nBone.prototype.copyAnimationRange = function (\r\n    source: Bone,\r\n    rangeName: string,\r\n    frameOffset: number,\r\n    rescaleAsRequired = false,\r\n    skelDimensionsRatio: Nullable<Vector3> = null\r\n): boolean {\r\n    // all animation may be coming from a library skeleton, so may need to create animation\r\n    if (this.animations.length === 0) {\r\n        this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n        this.animations[0].setKeys([]);\r\n    }\r\n\r\n    // get animation info / verify there is such a range from the source bone\r\n    const sourceRange = source.animations[0].getRange(rangeName);\r\n    if (!sourceRange) {\r\n        return false;\r\n    }\r\n    const from = sourceRange.from;\r\n    const to = sourceRange.to;\r\n    const sourceKeys = source.animations[0].getKeys();\r\n\r\n    // rescaling prep\r\n    const sourceBoneLength = source.length;\r\n    const sourceParent = source.getParent();\r\n    const parent = this.getParent();\r\n    const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n    const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n    const dimensionsScalingReqd =\r\n        rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n    const destKeys = this.animations[0].getKeys();\r\n\r\n    // loop vars declaration\r\n    let orig: { frame: number; value: Matrix };\r\n    let origTranslation: Vector3;\r\n    let mat: Matrix;\r\n\r\n    for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n        orig = sourceKeys[key];\r\n        if (orig.frame >= from && orig.frame <= to) {\r\n            if (rescaleAsRequired) {\r\n                mat = orig.value.clone();\r\n\r\n                // scale based on parent ratio, when bone has parent\r\n                if (parentScalingReqd) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                    // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                    origTranslation = mat.getTranslation();\r\n                    mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                    // use original when root bone, and no data for skelDimensionsRatio\r\n                } else {\r\n                    mat = orig.value;\r\n                }\r\n            } else {\r\n                mat = orig.value;\r\n            }\r\n            destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n        }\r\n    }\r\n    this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n    return true;\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}