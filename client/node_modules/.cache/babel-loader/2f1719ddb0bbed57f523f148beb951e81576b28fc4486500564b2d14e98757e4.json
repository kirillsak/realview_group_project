{"ast":null,"code":"import { Logger } from \"./logger.js\";\nimport { SceneSerializer } from \"./sceneSerializer.js\";\n/**\n * Class used to connect with the reflector zone of the sandbox via the reflector bridge\n * @since 5.0.0\n */\nexport class Reflector {\n  /**\n   * Constructs a reflector object.\n   * @param scene The scene to use\n   * @param hostname The hostname of the reflector bridge\n   * @param port The port of the reflector bridge\n   */\n  constructor(scene, hostname, port) {\n    this._scene = scene;\n    Logger.Log(`[Reflector] Connecting to ws://${hostname}:${port}`);\n    this._webSocket = new WebSocket(`ws://${hostname}:${port}`);\n    this._webSocket.onmessage = event => {\n      const message = event.data;\n      if (message.startsWith(Reflector._SERVER_PREFIX)) {\n        const serverMessage = message.substr(Reflector._SERVER_PREFIX.length);\n        Logger.Log(`[Reflector] Received server message: ${serverMessage.substr(0, 64)}`);\n        this._handleServerMessage(serverMessage);\n        return;\n      } else {\n        Logger.Log(`[Reflector] Received client message: ${message.substr(0, 64)}`);\n        this._handleClientMessage();\n      }\n    };\n    this._webSocket.onclose = event => {\n      Logger.Log(`[Reflector] Disconnected ${event.code} ${event.reason}`);\n    };\n  }\n  /**\n   * Closes the reflector connection\n   */\n  close() {\n    this._webSocket.close();\n  }\n  _handleServerMessage(message) {\n    switch (message) {\n      case \"connected\":\n        {\n          SceneSerializer.SerializeAsync(this._scene).then(serialized => {\n            this._webSocket.send(`load|${JSON.stringify(serialized)}`);\n          });\n          break;\n        }\n    }\n  }\n  _handleClientMessage() {\n    // do nothing\n  }\n}\nReflector._SERVER_PREFIX = \"$$\";","map":{"version":3,"mappings":"AACA,SAASA,MAAM,QAAQ,aAAW;AAClC,SAASC,eAAe,QAAQ,sBAAoB;AAEpD;;;;AAIA,OAAM,MAAOC,SAAS;EAMlB;;;;;;EAMAC,YAAmBC,KAAY,EAAEC,QAAgB,EAAEC,IAAY;IAC3D,IAAI,CAACC,MAAM,GAAGH,KAAK;IAEnBJ,MAAM,CAACQ,GAAG,CAAC,kCAAkCH,QAAQ,IAAIC,IAAI,EAAE,CAAC;IAChE,IAAI,CAACG,UAAU,GAAG,IAAIC,SAAS,CAAC,QAAQL,QAAQ,IAAIC,IAAI,EAAE,CAAC;IAE3D,IAAI,CAACG,UAAU,CAACE,SAAS,GAAIC,KAAK,IAAI;MAClC,MAAMC,OAAO,GAAWD,KAAK,CAACE,IAAI;MAClC,IAAID,OAAO,CAACE,UAAU,CAACb,SAAS,CAACc,cAAc,CAAC,EAAE;QAC9C,MAAMC,aAAa,GAAGJ,OAAO,CAACK,MAAM,CAAChB,SAAS,CAACc,cAAc,CAACG,MAAM,CAAC;QACrEnB,MAAM,CAACQ,GAAG,CAAC,wCAAwCS,aAAa,CAACC,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;QACjF,IAAI,CAACE,oBAAoB,CAACH,aAAa,CAAC;QACxC;OACH,MAAM;QACHjB,MAAM,CAACQ,GAAG,CAAC,wCAAwCK,OAAO,CAACK,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC;QAC3E,IAAI,CAACG,oBAAoB,EAAE;;IAEnC,CAAC;IAED,IAAI,CAACZ,UAAU,CAACa,OAAO,GAAIV,KAAK,IAAI;MAChCZ,MAAM,CAACQ,GAAG,CAAC,4BAA4BI,KAAK,CAACW,IAAI,IAAIX,KAAK,CAACY,MAAM,EAAE,CAAC;IACxE,CAAC;EACL;EAEA;;;EAGOC,KAAK;IACR,IAAI,CAAChB,UAAU,CAACgB,KAAK,EAAE;EAC3B;EAEQL,oBAAoB,CAACP,OAAe;IACxC,QAAQA,OAAO;MACX,KAAK,WAAW;QAAE;UACdZ,eAAe,CAACyB,cAAc,CAAC,IAAI,CAACnB,MAAM,CAAC,CAACoB,IAAI,CAAEC,UAAU,IAAI;YAC5D,IAAI,CAACnB,UAAU,CAACoB,IAAI,CAAC,QAAQC,IAAI,CAACC,SAAS,CAACH,UAAU,CAAC,EAAE,CAAC;UAC9D,CAAC,CAAC;UACF;;IACH;EAET;EAEQP,oBAAoB;IACxB;EAAA;;AAtDoBnB,wBAAc,GAAG,IAAI","names":["Logger","SceneSerializer","Reflector","constructor","scene","hostname","port","_scene","Log","_webSocket","WebSocket","onmessage","event","message","data","startsWith","_SERVER_PREFIX","serverMessage","substr","length","_handleServerMessage","_handleClientMessage","onclose","code","reason","close","SerializeAsync","then","serialized","send","JSON","stringify"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/reflector.ts"],"sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { Logger } from \"./logger\";\r\nimport { SceneSerializer } from \"./sceneSerializer\";\r\n\r\n/**\r\n * Class used to connect with the reflector zone of the sandbox via the reflector bridge\r\n * @since 5.0.0\r\n */\r\nexport class Reflector {\r\n    private static readonly _SERVER_PREFIX = \"$$\";\r\n\r\n    private _scene: Scene;\r\n    private _webSocket: WebSocket;\r\n\r\n    /**\r\n     * Constructs a reflector object.\r\n     * @param scene The scene to use\r\n     * @param hostname The hostname of the reflector bridge\r\n     * @param port The port of the reflector bridge\r\n     */\r\n    public constructor(scene: Scene, hostname: string, port: number) {\r\n        this._scene = scene;\r\n\r\n        Logger.Log(`[Reflector] Connecting to ws://${hostname}:${port}`);\r\n        this._webSocket = new WebSocket(`ws://${hostname}:${port}`);\r\n\r\n        this._webSocket.onmessage = (event) => {\r\n            const message: string = event.data;\r\n            if (message.startsWith(Reflector._SERVER_PREFIX)) {\r\n                const serverMessage = message.substr(Reflector._SERVER_PREFIX.length);\r\n                Logger.Log(`[Reflector] Received server message: ${serverMessage.substr(0, 64)}`);\r\n                this._handleServerMessage(serverMessage);\r\n                return;\r\n            } else {\r\n                Logger.Log(`[Reflector] Received client message: ${message.substr(0, 64)}`);\r\n                this._handleClientMessage();\r\n            }\r\n        };\r\n\r\n        this._webSocket.onclose = (event) => {\r\n            Logger.Log(`[Reflector] Disconnected ${event.code} ${event.reason}`);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Closes the reflector connection\r\n     */\r\n    public close(): void {\r\n        this._webSocket.close();\r\n    }\r\n\r\n    private _handleServerMessage(message: string): void {\r\n        switch (message) {\r\n            case \"connected\": {\r\n                SceneSerializer.SerializeAsync(this._scene).then((serialized) => {\r\n                    this._webSocket.send(`load|${JSON.stringify(serialized)}`);\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _handleClientMessage(): void {\r\n        // do nothing\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}