{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SerializationHelper } from \"./decorators.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nlet serializedGeometries = [];\nconst SerializeGeometry = (geometry, serializationGeometries) => {\n  if (geometry.doNotSerialize) {\n    return;\n  }\n  serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n  serializedGeometries[geometry.id] = true;\n};\nconst SerializeMesh = (mesh, serializationScene) => {\n  const serializationObject = {};\n  // Geometry\n  const geometry = mesh._geometry;\n  if (geometry) {\n    if (!mesh.getScene().getGeometryById(geometry.id)) {\n      // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n      SerializeGeometry(geometry, serializationScene.geometries);\n    }\n  }\n  // Custom\n  if (mesh.serialize) {\n    mesh.serialize(serializationObject);\n  }\n  return serializationObject;\n};\nconst FinalizeSingleMesh = (mesh, serializationObject) => {\n  //only works if the mesh is already loaded\n  if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n    const serializeMaterial = material => {\n      serializationObject.materials = serializationObject.materials || [];\n      if (mesh.material && !serializationObject.materials.some(mat => mat.id === mesh.material.id)) {\n        serializationObject.materials.push(material.serialize());\n      }\n    };\n    //serialize material\n    if (mesh.material && !mesh.material.doNotSerialize) {\n      if (mesh.material instanceof MultiMaterial) {\n        serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n        if (!serializationObject.multiMaterials.some(mat => mat.id === mesh.material.id)) {\n          serializationObject.multiMaterials.push(mesh.material.serialize());\n          for (const submaterial of mesh.material.subMaterials) {\n            if (submaterial) {\n              serializeMaterial(submaterial);\n            }\n          }\n        }\n      } else {\n        serializeMaterial(mesh.material);\n      }\n    } else if (!mesh.material) {\n      serializeMaterial(mesh.getScene().defaultMaterial);\n    }\n    //serialize geometry\n    const geometry = mesh._geometry;\n    if (geometry) {\n      if (!serializationObject.geometries) {\n        serializationObject.geometries = {};\n        serializationObject.geometries.boxes = [];\n        serializationObject.geometries.spheres = [];\n        serializationObject.geometries.cylinders = [];\n        serializationObject.geometries.toruses = [];\n        serializationObject.geometries.grounds = [];\n        serializationObject.geometries.planes = [];\n        serializationObject.geometries.torusKnots = [];\n        serializationObject.geometries.vertexData = [];\n      }\n      SerializeGeometry(geometry, serializationObject.geometries);\n    }\n    // Skeletons\n    if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\n      serializationObject.skeletons = serializationObject.skeletons || [];\n      serializationObject.skeletons.push(mesh.skeleton.serialize());\n    }\n    //serialize the actual mesh\n    serializationObject.meshes = serializationObject.meshes || [];\n    serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n  }\n};\n/**\n * Class used to serialize a scene into a string\n */\nexport class SceneSerializer {\n  /**\n   * Clear cache used by a previous serialization\n   */\n  static ClearCache() {\n    serializedGeometries = [];\n  }\n  /**\n   * Serialize a scene into a JSON compatible object\n   * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\n   * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\n   * @param scene defines the scene to serialize\n   * @returns a JSON compatible object\n   */\n  static Serialize(scene) {\n    return SceneSerializer._Serialize(scene);\n  }\n  static _Serialize(scene, checkSyncReadSupported = true) {\n    const serializationObject = {};\n    if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\n      console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\n    }\n    SceneSerializer.ClearCache();\n    // Scene\n    serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n    serializationObject.autoClear = scene.autoClear;\n    serializationObject.clearColor = scene.clearColor.asArray();\n    serializationObject.ambientColor = scene.ambientColor.asArray();\n    serializationObject.gravity = scene.gravity.asArray();\n    serializationObject.collisionsEnabled = scene.collisionsEnabled;\n    serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\n    // Fog\n    if (scene.fogMode && scene.fogMode !== 0) {\n      serializationObject.fogMode = scene.fogMode;\n      serializationObject.fogColor = scene.fogColor.asArray();\n      serializationObject.fogStart = scene.fogStart;\n      serializationObject.fogEnd = scene.fogEnd;\n      serializationObject.fogDensity = scene.fogDensity;\n    }\n    //Physics\n    if (scene.isPhysicsEnabled()) {\n      const physicEngine = scene.getPhysicsEngine();\n      if (physicEngine) {\n        serializationObject.physicsEnabled = true;\n        serializationObject.physicsGravity = physicEngine.gravity.asArray();\n        serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\n      }\n    }\n    // Metadata\n    if (scene.metadata) {\n      serializationObject.metadata = scene.metadata;\n    }\n    // Morph targets\n    serializationObject.morphTargetManagers = [];\n    for (const abstractMesh of scene.meshes) {\n      const manager = abstractMesh.morphTargetManager;\n      if (manager) {\n        serializationObject.morphTargetManagers.push(manager.serialize());\n      }\n    }\n    // Lights\n    serializationObject.lights = [];\n    let index;\n    let light;\n    for (index = 0; index < scene.lights.length; index++) {\n      light = scene.lights[index];\n      if (!light.doNotSerialize) {\n        serializationObject.lights.push(light.serialize());\n      }\n    }\n    // Cameras\n    serializationObject.cameras = [];\n    for (index = 0; index < scene.cameras.length; index++) {\n      const camera = scene.cameras[index];\n      if (!camera.doNotSerialize) {\n        serializationObject.cameras.push(camera.serialize());\n      }\n    }\n    if (scene.activeCamera) {\n      serializationObject.activeCameraID = scene.activeCamera.id;\n    }\n    // Animations\n    SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\n    // Animation Groups\n    if (scene.animationGroups && scene.animationGroups.length > 0) {\n      serializationObject.animationGroups = [];\n      for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\n        const animationGroup = scene.animationGroups[animationGroupIndex];\n        serializationObject.animationGroups.push(animationGroup.serialize());\n      }\n    }\n    // Reflection probes\n    if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\n      serializationObject.reflectionProbes = [];\n      for (index = 0; index < scene.reflectionProbes.length; index++) {\n        const reflectionProbe = scene.reflectionProbes[index];\n        serializationObject.reflectionProbes.push(reflectionProbe.serialize());\n      }\n    }\n    // Materials\n    serializationObject.materials = [];\n    serializationObject.multiMaterials = [];\n    let material;\n    for (index = 0; index < scene.materials.length; index++) {\n      material = scene.materials[index];\n      if (!material.doNotSerialize) {\n        serializationObject.materials.push(material.serialize());\n      }\n    }\n    // MultiMaterials\n    serializationObject.multiMaterials = [];\n    for (index = 0; index < scene.multiMaterials.length; index++) {\n      const multiMaterial = scene.multiMaterials[index];\n      serializationObject.multiMaterials.push(multiMaterial.serialize());\n    }\n    // Environment texture\n    if (scene.environmentTexture) {\n      if (scene.environmentTexture._files) {\n        serializationObject.environmentTexture = scene.environmentTexture.serialize();\n      } else {\n        serializationObject.environmentTexture = scene.environmentTexture.name;\n        serializationObject.environmentTextureRotationY = scene.environmentTexture.rotationY;\n      }\n    }\n    // Environment Intensity\n    serializationObject.environmentIntensity = scene.environmentIntensity;\n    // Skeletons\n    serializationObject.skeletons = [];\n    for (index = 0; index < scene.skeletons.length; index++) {\n      const skeleton = scene.skeletons[index];\n      if (!skeleton.doNotSerialize) {\n        serializationObject.skeletons.push(skeleton.serialize());\n      }\n    }\n    // Transform nodes\n    serializationObject.transformNodes = [];\n    for (index = 0; index < scene.transformNodes.length; index++) {\n      if (!scene.transformNodes[index].doNotSerialize) {\n        serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\n      }\n    }\n    // Geometries\n    serializationObject.geometries = {};\n    serializationObject.geometries.boxes = [];\n    serializationObject.geometries.spheres = [];\n    serializationObject.geometries.cylinders = [];\n    serializationObject.geometries.toruses = [];\n    serializationObject.geometries.grounds = [];\n    serializationObject.geometries.planes = [];\n    serializationObject.geometries.torusKnots = [];\n    serializationObject.geometries.vertexData = [];\n    serializedGeometries = [];\n    const geometries = scene.getGeometries();\n    for (index = 0; index < geometries.length; index++) {\n      const geometry = geometries[index];\n      if (geometry.isReady()) {\n        SerializeGeometry(geometry, serializationObject.geometries);\n      }\n    }\n    // Meshes\n    serializationObject.meshes = [];\n    for (index = 0; index < scene.meshes.length; index++) {\n      const abstractMesh = scene.meshes[index];\n      if (abstractMesh instanceof Mesh) {\n        const mesh = abstractMesh;\n        if (!mesh.doNotSerialize) {\n          if (mesh.delayLoadState === 1 || mesh.delayLoadState === 0) {\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\n          }\n        }\n      }\n    }\n    // Particles Systems\n    serializationObject.particleSystems = [];\n    for (index = 0; index < scene.particleSystems.length; index++) {\n      serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\n    }\n    // Post processes\n    serializationObject.postProcesses = [];\n    for (index = 0; index < scene.postProcesses.length; index++) {\n      serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\n    }\n    // Action Manager\n    if (scene.actionManager) {\n      serializationObject.actions = scene.actionManager.serialize(\"scene\");\n    }\n    // Components\n    for (const component of scene._serializableComponents) {\n      component.serialize(serializationObject);\n    }\n    return serializationObject;\n  }\n  /**\n   * Serialize a scene into a JSON compatible object\n   * @param scene defines the scene to serialize\n   * @returns a JSON promise compatible object\n   */\n  static SerializeAsync(scene) {\n    const serializationObject = SceneSerializer._Serialize(scene, false);\n    const promises = [];\n    this._CollectPromises(serializationObject, promises);\n    return Promise.all(promises).then(() => serializationObject);\n  }\n  static _CollectPromises(obj, promises) {\n    if (Array.isArray(obj)) {\n      for (let i = 0; i < obj.length; ++i) {\n        const o = obj[i];\n        if (o instanceof Promise) {\n          promises.push(o.then(res => obj[i] = res));\n        } else if (o instanceof Object || Array.isArray(o)) {\n          this._CollectPromises(o, promises);\n        }\n      }\n    } else if (obj instanceof Object) {\n      for (const name in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, name)) {\n          const o = obj[name];\n          if (o instanceof Promise) {\n            promises.push(o.then(res => obj[name] = res));\n          } else if (o instanceof Object || Array.isArray(o)) {\n            this._CollectPromises(o, promises);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Serialize a mesh into a JSON compatible object\n   * @param toSerialize defines the mesh to serialize\n   * @param withParents defines if parents must be serialized as well\n   * @param withChildren defines if children must be serialized as well\n   * @returns a JSON compatible object\n   */\n  static SerializeMesh(toSerialize /* Mesh || Mesh[] */, withParents = false, withChildren = false) {\n    const serializationObject = {};\n    SceneSerializer.ClearCache();\n    toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\n    if (withParents || withChildren) {\n      //deliberate for loop! not for each, appended should be processed as well.\n      for (let i = 0; i < toSerialize.length; ++i) {\n        if (withChildren) {\n          toSerialize[i].getDescendants().forEach(node => {\n            if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\n              toSerialize.push(node);\n            }\n          });\n        }\n        //make sure the array doesn't contain the object already\n        if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\n          toSerialize.push(toSerialize[i].parent);\n        }\n      }\n    }\n    toSerialize.forEach(mesh => {\n      FinalizeSingleMesh(mesh, serializationObject);\n    });\n    return serializationObject;\n  }\n}","map":{"version":3,"mappings":"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","names":["Mesh","MultiMaterial","SerializationHelper","Texture","serializedGeometries","SerializeGeometry","geometry","serializationGeometries","doNotSerialize","vertexData","push","serializeVerticeData","id","SerializeMesh","mesh","serializationScene","serializationObject","_geometry","getScene","getGeometryById","geometries","serialize","FinalizeSingleMesh","delayLoadState","serializeMaterial","material","materials","some","mat","multiMaterials","submaterial","subMaterials","defaultMaterial","boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","skeleton","skeletons","meshes","SceneSerializer","ClearCache","Serialize","scene","_Serialize","checkSyncReadSupported","getEngine","_features","supportSyncTextureRead","ForceSerializeBuffers","console","warn","useDelayedTextureLoading","autoClear","clearColor","asArray","ambientColor","gravity","collisionsEnabled","useRightHandedSystem","fogMode","fogColor","fogStart","fogEnd","fogDensity","isPhysicsEnabled","physicEngine","getPhysicsEngine","physicsEnabled","physicsGravity","physicsEngine","getPhysicsPluginName","metadata","morphTargetManagers","abstractMesh","manager","morphTargetManager","lights","index","light","length","cameras","camera","activeCamera","activeCameraID","AppendSerializedAnimations","animationGroups","animationGroupIndex","animationGroup","reflectionProbes","reflectionProbe","multiMaterial","environmentTexture","_files","name","environmentTextureRotationY","rotationY","environmentIntensity","transformNodes","getGeometries","isReady","particleSystems","postProcesses","actionManager","actions","component","_serializableComponents","SerializeAsync","promises","_CollectPromises","Promise","all","then","obj","Array","isArray","i","o","res","Object","prototype","hasOwnProperty","call","toSerialize","withParents","withChildren","getDescendants","forEach","node","indexOf","parent"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/sceneSerializer.ts"],"sourcesContent":["import type { Geometry } from \"../Meshes/geometry\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { SerializationHelper } from \"./decorators\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\n\r\nlet serializedGeometries: Geometry[] = [];\r\nconst SerializeGeometry = (geometry: Geometry, serializationGeometries: any): any => {\r\n    if (geometry.doNotSerialize) {\r\n        return;\r\n    }\r\n\r\n    serializationGeometries.vertexData.push(geometry.serializeVerticeData());\r\n\r\n    (<any>serializedGeometries)[geometry.id] = true;\r\n};\r\n\r\nconst SerializeMesh = (mesh: Mesh, serializationScene: any): any => {\r\n    const serializationObject: any = {};\r\n\r\n    // Geometry\r\n    const geometry = mesh._geometry;\r\n    if (geometry) {\r\n        if (!mesh.getScene().getGeometryById(geometry.id)) {\r\n            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\r\n            SerializeGeometry(geometry, serializationScene.geometries);\r\n        }\r\n    }\r\n\r\n    // Custom\r\n    if (mesh.serialize) {\r\n        mesh.serialize(serializationObject);\r\n    }\r\n\r\n    return serializationObject;\r\n};\r\n\r\nconst FinalizeSingleMesh = (mesh: Mesh, serializationObject: any) => {\r\n    //only works if the mesh is already loaded\r\n    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n        const serializeMaterial = (material: Material) => {\r\n            serializationObject.materials = serializationObject.materials || [];\r\n            if (mesh.material && !serializationObject.materials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        };\r\n\r\n        //serialize material\r\n        if (mesh.material && !mesh.material.doNotSerialize) {\r\n            if (mesh.material instanceof MultiMaterial) {\r\n                serializationObject.multiMaterials = serializationObject.multiMaterials || [];\r\n                if (!serializationObject.multiMaterials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                    serializationObject.multiMaterials.push(mesh.material.serialize());\r\n                    for (const submaterial of mesh.material.subMaterials) {\r\n                        if (submaterial) {\r\n                            serializeMaterial(submaterial);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                serializeMaterial(mesh.material);\r\n            }\r\n        } else if (!mesh.material) {\r\n            serializeMaterial(mesh.getScene().defaultMaterial);\r\n        }\r\n\r\n        //serialize geometry\r\n        const geometry = mesh._geometry;\r\n        if (geometry) {\r\n            if (!serializationObject.geometries) {\r\n                serializationObject.geometries = {};\r\n\r\n                serializationObject.geometries.boxes = [];\r\n                serializationObject.geometries.spheres = [];\r\n                serializationObject.geometries.cylinders = [];\r\n                serializationObject.geometries.toruses = [];\r\n                serializationObject.geometries.grounds = [];\r\n                serializationObject.geometries.planes = [];\r\n                serializationObject.geometries.torusKnots = [];\r\n                serializationObject.geometries.vertexData = [];\r\n            }\r\n\r\n            SerializeGeometry(geometry, serializationObject.geometries);\r\n        }\r\n        // Skeletons\r\n        if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\r\n            serializationObject.skeletons = serializationObject.skeletons || [];\r\n            serializationObject.skeletons.push(mesh.skeleton.serialize());\r\n        }\r\n\r\n        //serialize the actual mesh\r\n        serializationObject.meshes = serializationObject.meshes || [];\r\n        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n    }\r\n};\r\n\r\n/**\r\n * Class used to serialize a scene into a string\r\n */\r\nexport class SceneSerializer {\r\n    /**\r\n     * Clear cache used by a previous serialization\r\n     */\r\n    public static ClearCache(): void {\r\n        serializedGeometries = [];\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\r\n     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static Serialize(scene: Scene): any {\r\n        return SceneSerializer._Serialize(scene);\r\n    }\r\n\r\n    private static _Serialize(scene: Scene, checkSyncReadSupported = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\r\n            console.warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\r\n        }\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        // Scene\r\n        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        serializationObject.autoClear = scene.autoClear;\r\n        serializationObject.clearColor = scene.clearColor.asArray();\r\n        serializationObject.ambientColor = scene.ambientColor.asArray();\r\n        serializationObject.gravity = scene.gravity.asArray();\r\n        serializationObject.collisionsEnabled = scene.collisionsEnabled;\r\n        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Fog\r\n        if (scene.fogMode && scene.fogMode !== 0) {\r\n            serializationObject.fogMode = scene.fogMode;\r\n            serializationObject.fogColor = scene.fogColor.asArray();\r\n            serializationObject.fogStart = scene.fogStart;\r\n            serializationObject.fogEnd = scene.fogEnd;\r\n            serializationObject.fogDensity = scene.fogDensity;\r\n        }\r\n\r\n        //Physics\r\n        if (scene.isPhysicsEnabled()) {\r\n            const physicEngine = scene.getPhysicsEngine();\r\n\r\n            if (physicEngine) {\r\n                serializationObject.physicsEnabled = true;\r\n                serializationObject.physicsGravity = physicEngine.gravity.asArray();\r\n                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\r\n            }\r\n        }\r\n\r\n        // Metadata\r\n        if (scene.metadata) {\r\n            serializationObject.metadata = scene.metadata;\r\n        }\r\n\r\n        // Morph targets\r\n        serializationObject.morphTargetManagers = [];\r\n        for (const abstractMesh of scene.meshes) {\r\n            const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n\r\n            if (manager) {\r\n                serializationObject.morphTargetManagers.push(manager.serialize());\r\n            }\r\n        }\r\n\r\n        // Lights\r\n        serializationObject.lights = [];\r\n        let index: number;\r\n        let light: Light;\r\n        for (index = 0; index < scene.lights.length; index++) {\r\n            light = scene.lights[index];\r\n\r\n            if (!light.doNotSerialize) {\r\n                serializationObject.lights.push(light.serialize());\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        serializationObject.cameras = [];\r\n        for (index = 0; index < scene.cameras.length; index++) {\r\n            const camera = scene.cameras[index];\r\n\r\n            if (!camera.doNotSerialize) {\r\n                serializationObject.cameras.push(camera.serialize());\r\n            }\r\n        }\r\n\r\n        if (scene.activeCamera) {\r\n            serializationObject.activeCameraID = scene.activeCamera.id;\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\r\n\r\n        // Animation Groups\r\n        if (scene.animationGroups && scene.animationGroups.length > 0) {\r\n            serializationObject.animationGroups = [];\r\n            for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\r\n                const animationGroup = scene.animationGroups[animationGroupIndex];\r\n\r\n                serializationObject.animationGroups.push(animationGroup.serialize());\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\r\n            serializationObject.reflectionProbes = [];\r\n\r\n            for (index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const reflectionProbe = scene.reflectionProbes[index];\r\n                serializationObject.reflectionProbes.push(reflectionProbe.serialize());\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        serializationObject.materials = [];\r\n        serializationObject.multiMaterials = [];\r\n        let material: Material;\r\n        for (index = 0; index < scene.materials.length; index++) {\r\n            material = scene.materials[index];\r\n            if (!material.doNotSerialize) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        }\r\n\r\n        // MultiMaterials\r\n        serializationObject.multiMaterials = [];\r\n        for (index = 0; index < scene.multiMaterials.length; index++) {\r\n            const multiMaterial = scene.multiMaterials[index];\r\n            serializationObject.multiMaterials.push(multiMaterial.serialize());\r\n        }\r\n\r\n        // Environment texture\r\n        if (scene.environmentTexture) {\r\n            if ((scene.environmentTexture as CubeTexture)._files) {\r\n                serializationObject.environmentTexture = scene.environmentTexture.serialize();\r\n            } else {\r\n                serializationObject.environmentTexture = scene.environmentTexture.name;\r\n                serializationObject.environmentTextureRotationY = (scene.environmentTexture as CubeTexture).rotationY;\r\n            }\r\n        }\r\n\r\n        // Environment Intensity\r\n        serializationObject.environmentIntensity = scene.environmentIntensity;\r\n\r\n        // Skeletons\r\n        serializationObject.skeletons = [];\r\n        for (index = 0; index < scene.skeletons.length; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (!skeleton.doNotSerialize) {\r\n                serializationObject.skeletons.push(skeleton.serialize());\r\n            }\r\n        }\r\n\r\n        // Transform nodes\r\n        serializationObject.transformNodes = [];\r\n        for (index = 0; index < scene.transformNodes.length; index++) {\r\n            if (!scene.transformNodes[index].doNotSerialize) {\r\n                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        serializationObject.geometries = {};\r\n\r\n        serializationObject.geometries.boxes = [];\r\n        serializationObject.geometries.spheres = [];\r\n        serializationObject.geometries.cylinders = [];\r\n        serializationObject.geometries.toruses = [];\r\n        serializationObject.geometries.grounds = [];\r\n        serializationObject.geometries.planes = [];\r\n        serializationObject.geometries.torusKnots = [];\r\n        serializationObject.geometries.vertexData = [];\r\n\r\n        serializedGeometries = [];\r\n        const geometries = scene.getGeometries();\r\n        for (index = 0; index < geometries.length; index++) {\r\n            const geometry = geometries[index];\r\n\r\n            if (geometry.isReady()) {\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        serializationObject.meshes = [];\r\n        for (index = 0; index < scene.meshes.length; index++) {\r\n            const abstractMesh = scene.meshes[index];\r\n\r\n            if (abstractMesh instanceof Mesh) {\r\n                const mesh = abstractMesh;\r\n                if (!mesh.doNotSerialize) {\r\n                    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Particles Systems\r\n        serializationObject.particleSystems = [];\r\n        for (index = 0; index < scene.particleSystems.length; index++) {\r\n            serializationObject.particleSystems.push(scene.particleSystems[index].serialize(false));\r\n        }\r\n\r\n        // Post processes\r\n        serializationObject.postProcesses = [];\r\n        for (index = 0; index < scene.postProcesses.length; index++) {\r\n            serializationObject.postProcesses.push(scene.postProcesses[index].serialize());\r\n        }\r\n\r\n        // Action Manager\r\n        if (scene.actionManager) {\r\n            serializationObject.actions = scene.actionManager.serialize(\"scene\");\r\n        }\r\n\r\n        // Components\r\n        for (const component of scene._serializableComponents) {\r\n            component.serialize(serializationObject);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON promise compatible object\r\n     */\r\n    public static SerializeAsync(scene: Scene): Promise<any> {\r\n        const serializationObject = SceneSerializer._Serialize(scene, false);\r\n\r\n        const promises: Array<Promise<any>> = [];\r\n\r\n        this._CollectPromises(serializationObject, promises);\r\n\r\n        return Promise.all(promises).then(() => serializationObject);\r\n    }\r\n\r\n    private static _CollectPromises(obj: any, promises: Array<Promise<any>>): void {\r\n        if (Array.isArray(obj)) {\r\n            for (let i = 0; i < obj.length; ++i) {\r\n                const o = obj[i];\r\n                if (o instanceof Promise) {\r\n                    promises.push(o.then((res: any) => (obj[i] = res)));\r\n                } else if (o instanceof Object || Array.isArray(o)) {\r\n                    this._CollectPromises(o, promises);\r\n                }\r\n            }\r\n        } else if (obj instanceof Object) {\r\n            for (const name in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, name)) {\r\n                    const o = obj[name];\r\n                    if (o instanceof Promise) {\r\n                        promises.push(o.then((res: any) => (obj[name] = res)));\r\n                    } else if (o instanceof Object || Array.isArray(o)) {\r\n                        this._CollectPromises(o, promises);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize a mesh into a JSON compatible object\r\n     * @param toSerialize defines the mesh to serialize\r\n     * @param withParents defines if parents must be serialized as well\r\n     * @param withChildren defines if children must be serialized as well\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static SerializeMesh(toSerialize: any /* Mesh || Mesh[] */, withParents: boolean = false, withChildren: boolean = false): any {\r\n        const serializationObject: any = {};\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\r\n\r\n        if (withParents || withChildren) {\r\n            //deliberate for loop! not for each, appended should be processed as well.\r\n            for (let i = 0; i < toSerialize.length; ++i) {\r\n                if (withChildren) {\r\n                    toSerialize[i].getDescendants().forEach((node: Node) => {\r\n                        if (node instanceof Mesh && toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\r\n                            toSerialize.push(node);\r\n                        }\r\n                    });\r\n                }\r\n                //make sure the array doesn't contain the object already\r\n                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\r\n                    toSerialize.push(toSerialize[i].parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        toSerialize.forEach((mesh: Mesh) => {\r\n            FinalizeSingleMesh(mesh, serializationObject);\r\n        });\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}