{"ast":null,"code":"import { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport \"../Engines/Extensions/engine.renderTarget.js\";\nimport { ApplyPostProcess } from \"./textureTools.js\";\n/**\n * Class used to host RGBD texture specific utilities\n */\nexport class RGBDTextureTools {\n  /**\n   * Expand the RGBD Texture from RGBD to Half Float if possible.\n   * @param texture the texture to expand.\n   */\n  static ExpandRGBDTexture(texture) {\n    const internalTexture = texture._texture;\n    if (!internalTexture || !texture.isRGBD) {\n      return;\n    }\n    // Gets everything ready.\n    const engine = internalTexture.getEngine();\n    const caps = engine.getCaps();\n    const isReady = internalTexture.isReady;\n    let expandTexture = false;\n    // If half float available we can uncompress the texture\n    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 2;\n    }\n    // If full float available we can uncompress the texture\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n      expandTexture = true;\n      internalTexture.type = 1;\n    }\n    if (expandTexture) {\n      // Do not use during decode.\n      internalTexture.isReady = false;\n      internalTexture._isRGBD = false;\n      internalTexture.invertY = false;\n    }\n    const expandRGBDTexture = () => {\n      // Expand the texture if possible\n      if (expandTexture) {\n        // Simply run through the decode PP.\n        const rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, internalTexture.type, undefined, null, false);\n        rgbdPostProcess.externalTextureSamplerBinding = true;\n        // Hold the output of the decoding.\n        const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\n          generateDepthBuffer: false,\n          generateMipMaps: false,\n          generateStencilBuffer: false,\n          samplingMode: internalTexture.samplingMode,\n          type: internalTexture.type,\n          format: 5\n        });\n        rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n          // PP Render Pass\n          rgbdPostProcess.onApply = effect => {\n            effect._bindTexture(\"textureSampler\", internalTexture);\n            effect.setFloat2(\"scale\", 1, 1);\n          };\n          texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);\n          // Cleanup\n          engine.restoreDefaultFramebuffer();\n          engine._releaseTexture(internalTexture);\n          if (rgbdPostProcess) {\n            rgbdPostProcess.dispose();\n          }\n          // Internal Swap\n          expandedTexture._swapAndDie(internalTexture);\n          // Ready to get rolling again.\n          internalTexture.isReady = true;\n        });\n      }\n    };\n    if (isReady) {\n      expandRGBDTexture();\n    } else {\n      texture.onLoadObservable.addOnce(expandRGBDTexture);\n    }\n  }\n  /**\n   * Encode the texture to RGBD if possible.\n   * @param internalTexture the texture to encode\n   * @param scene the scene hosting the texture\n   * @param outputTextureType type of the texture in which the encoding is performed\n   * @returns a promise with the internalTexture having its texture replaced by the result of the processing\n   */\n  static EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {\n    return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, 1, 5);\n  }\n}","map":{"version":3,"mappings":"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","names":["PostProcess","ApplyPostProcess","RGBDTextureTools","ExpandRGBDTexture","texture","internalTexture","_texture","isRGBD","engine","getEngine","caps","getCaps","isReady","expandTexture","textureHalfFloatRender","textureHalfFloatLinearFiltering","type","textureFloatRender","textureFloatLinearFiltering","_isRGBD","invertY","expandRGBDTexture","rgbdPostProcess","undefined","externalTextureSamplerBinding","expandedTexture","createRenderTargetTexture","width","generateDepthBuffer","generateMipMaps","generateStencilBuffer","samplingMode","format","getEffect","executeWhenCompiled","onApply","effect","_bindTexture","setFloat2","getScene","postProcessManager","directRender","restoreDefaultFramebuffer","_releaseTexture","dispose","_swapAndDie","onLoadObservable","addOnce","EncodeTextureToRGBD","scene","outputTextureType"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/rgbdTextureTools.ts"],"sourcesContent":["import { Constants } from \"../Engines/constants\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport type { Engine } from \"../Engines/engine\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTarget\";\r\nimport { ApplyPostProcess } from \"./textureTools\";\r\n\r\ndeclare type Texture = import(\"../Materials/Textures/texture\").Texture;\r\ndeclare type InternalTexture = import(\"../Materials/Textures/internalTexture\").InternalTexture;\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/**\r\n * Class used to host RGBD texture specific utilities\r\n */\r\nexport class RGBDTextureTools {\r\n    /**\r\n     * Expand the RGBD Texture from RGBD to Half Float if possible.\r\n     * @param texture the texture to expand.\r\n     */\r\n    public static ExpandRGBDTexture(texture: Texture) {\r\n        const internalTexture = texture._texture;\r\n        if (!internalTexture || !texture.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        // Gets everything ready.\r\n        const engine = internalTexture.getEngine() as Engine;\r\n        const caps = engine.getCaps();\r\n        const isReady = internalTexture.isReady;\r\n        let expandTexture = false;\r\n\r\n        // If half float available we can uncompress the texture\r\n        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        }\r\n        // If full float available we can uncompress the texture\r\n        else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n            expandTexture = true;\r\n            internalTexture.type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        if (expandTexture) {\r\n            // Do not use during decode.\r\n            internalTexture.isReady = false;\r\n            internalTexture._isRGBD = false;\r\n            internalTexture.invertY = false;\r\n        }\r\n\r\n        const expandRGBDTexture = () => {\r\n            // Expand the texture if possible\r\n            if (expandTexture) {\r\n                // Simply run through the decode PP.\r\n                const rgbdPostProcess = new PostProcess(\r\n                    \"rgbdDecode\",\r\n                    \"rgbdDecode\",\r\n                    null,\r\n                    null,\r\n                    1,\r\n                    null,\r\n                    Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                    engine,\r\n                    false,\r\n                    undefined,\r\n                    internalTexture.type,\r\n                    undefined,\r\n                    null,\r\n                    false\r\n                );\r\n                rgbdPostProcess.externalTextureSamplerBinding = true;\r\n\r\n                // Hold the output of the decoding.\r\n                const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {\r\n                    generateDepthBuffer: false,\r\n                    generateMipMaps: false,\r\n                    generateStencilBuffer: false,\r\n                    samplingMode: internalTexture.samplingMode,\r\n                    type: internalTexture.type,\r\n                    format: Constants.TEXTUREFORMAT_RGBA,\r\n                });\r\n\r\n                rgbdPostProcess.getEffect().executeWhenCompiled(() => {\r\n                    // PP Render Pass\r\n                    rgbdPostProcess.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", internalTexture);\r\n                        effect.setFloat2(\"scale\", 1, 1);\r\n                    };\r\n                    texture.getScene()!.postProcessManager.directRender([rgbdPostProcess!], expandedTexture, true);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    engine._releaseTexture(internalTexture);\r\n                    if (rgbdPostProcess) {\r\n                        rgbdPostProcess.dispose();\r\n                    }\r\n\r\n                    // Internal Swap\r\n                    expandedTexture._swapAndDie(internalTexture);\r\n\r\n                    // Ready to get rolling again.\r\n                    internalTexture.isReady = true;\r\n                });\r\n            }\r\n        };\r\n\r\n        if (isReady) {\r\n            expandRGBDTexture();\r\n        } else {\r\n            texture.onLoadObservable.addOnce(expandRGBDTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Encode the texture to RGBD if possible.\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param outputTextureType type of the texture in which the encoding is performed\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    public static EncodeTextureToRGBD(internalTexture: InternalTexture, scene: Scene, outputTextureType = Constants.TEXTURETYPE_UNSIGNED_BYTE): Promise<InternalTexture> {\r\n        return ApplyPostProcess(\"rgbdEncode\", internalTexture, scene, outputTextureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}