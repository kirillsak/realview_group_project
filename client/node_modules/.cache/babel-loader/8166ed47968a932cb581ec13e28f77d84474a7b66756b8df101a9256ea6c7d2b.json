{"ast":null,"code":"import { WebGPUEngine } from \"../../webgpuEngine.js\";\nimport * as WebGPUConstants from \"../webgpuConstants.js\";\nimport { Effect } from \"../../../Materials/effect.js\";\nEffect.prototype.setStorageBuffer = function (name, buffer) {\n  this._engine.setStorageBuffer(name, buffer);\n};\nWebGPUEngine.prototype.createStorageBuffer = function (data, creationFlags) {\n  return this._createBuffer(data, creationFlags | 32);\n};\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer, data, byteOffset, byteLength) {\n  const dataBuffer = buffer;\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  }\n  let view;\n  if (byteLength === undefined) {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n    byteLength = view.byteLength;\n  } else {\n    if (data instanceof Array) {\n      view = new Float32Array(data);\n    } else if (data instanceof ArrayBuffer) {\n      view = new Uint8Array(data);\n    } else {\n      view = data;\n    }\n  }\n  this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\n};\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer, offset, size, buffer) {\n  size = size || storageBuffer.capacity;\n  const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\n  this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset !== null && offset !== void 0 ? offset : 0, gpuBuffer, 0, size);\n  return new Promise((resolve, reject) => {\n    // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\n    // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\n    this.onEndFrameObservable.addOnce(() => {\n      gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(() => {\n        const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\n        let data = buffer;\n        if (data === undefined) {\n          data = new Uint8Array(size);\n          data.set(new Uint8Array(copyArrayBuffer));\n        } else {\n          const ctor = data.constructor; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\n          data = new ctor(data.buffer);\n          data.set(new ctor(copyArrayBuffer));\n        }\n        gpuBuffer.unmap();\n        this._bufferManager.releaseBuffer(gpuBuffer);\n        resolve(data);\n      }, reason => reject(reason));\n    });\n  });\n};\nWebGPUEngine.prototype.setStorageBuffer = function (name, buffer) {\n  var _a, _b;\n  (_a = this._currentDrawContext) === null || _a === void 0 ? void 0 : _a.setBuffer(name, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.getBuffer()) !== null && _b !== void 0 ? _b : null);\n};","map":{"version":3,"mappings":"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","names":["WebGPUEngine","WebGPUConstants","Effect","prototype","setStorageBuffer","name","buffer","_engine","createStorageBuffer","data","creationFlags","_createBuffer","updateStorageBuffer","byteOffset","byteLength","dataBuffer","undefined","view","Array","Float32Array","ArrayBuffer","Uint8Array","_bufferManager","setSubData","readFromStorageBuffer","storageBuffer","offset","size","capacity","gpuBuffer","createRawBuffer","BufferUsage","MapRead","CopyDst","_renderTargetEncoder","copyBufferToBuffer","underlyingResource","Promise","resolve","reject","onEndFrameObservable","addOnce","mapAsync","MapMode","Read","then","copyArrayBuffer","getMappedRange","set","ctor","constructor","unmap","releaseBuffer","reason","_currentDrawContext","setBuffer","getBuffer"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.storageBuffer.ts"],"sourcesContent":["import type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport type { WebGPUDataBuffer } from \"../../../Meshes/WebGPU/webgpuDataBuffer\";\r\nimport type { DataArray, Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport * as WebGPUConstants from \"../webgpuConstants\";\r\nimport { Effect } from \"../../../Materials/effect\";\r\n\r\ndeclare type StorageBuffer = import(\"../../../Buffers/storageBuffer\").StorageBuffer;\r\n\r\ndeclare module \"../../../Materials/effect\" {\r\n    export interface Effect {\r\n        /**\r\n         * Sets a storage buffer on the engine to be used in the shader.\r\n         * @param name Name of the storage buffer variable.\r\n         * @param buffer Storage buffer to set.\r\n         */\r\n        setStorageBuffer(name: string, buffer: Nullable<StorageBuffer>): void;\r\n    }\r\n}\r\n\r\nEffect.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._engine.setStorageBuffer(name, buffer);\r\n};\r\n\r\nWebGPUEngine.prototype.createStorageBuffer = function (data: DataArray | number, creationFlags: number): DataBuffer {\r\n    return this._createBuffer(data, creationFlags | Constants.BUFFER_CREATIONFLAG_STORAGE);\r\n};\r\n\r\nWebGPUEngine.prototype.updateStorageBuffer = function (buffer: DataBuffer, data: DataArray, byteOffset?: number, byteLength?: number): void {\r\n    const dataBuffer = buffer as WebGPUDataBuffer;\r\n    if (byteOffset === undefined) {\r\n        byteOffset = 0;\r\n    }\r\n\r\n    let view: ArrayBufferView;\r\n    if (byteLength === undefined) {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n        byteLength = view.byteLength;\r\n    } else {\r\n        if (data instanceof Array) {\r\n            view = new Float32Array(data);\r\n        } else if (data instanceof ArrayBuffer) {\r\n            view = new Uint8Array(data);\r\n        } else {\r\n            view = data;\r\n        }\r\n    }\r\n\r\n    this._bufferManager.setSubData(dataBuffer, byteOffset, view, 0, byteLength);\r\n};\r\n\r\nWebGPUEngine.prototype.readFromStorageBuffer = function (storageBuffer: DataBuffer, offset?: number, size?: number, buffer?: ArrayBufferView): Promise<ArrayBufferView> {\r\n    size = size || storageBuffer.capacity;\r\n\r\n    const gpuBuffer = this._bufferManager.createRawBuffer(size, WebGPUConstants.BufferUsage.MapRead | WebGPUConstants.BufferUsage.CopyDst);\r\n\r\n    this._renderTargetEncoder.copyBufferToBuffer(storageBuffer.underlyingResource, offset ?? 0, gpuBuffer, 0, size);\r\n\r\n    return new Promise((resolve, reject) => {\r\n        // we are using onEndFrameObservable because we need to map the gpuBuffer AFTER the command buffers\r\n        // have been submitted, else we get the error: \"Buffer used in a submit while mapped\"\r\n        this.onEndFrameObservable.addOnce(() => {\r\n            gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read, 0, size).then(\r\n                () => {\r\n                    const copyArrayBuffer = gpuBuffer.getMappedRange(0, size);\r\n                    let data: ArrayBufferView | undefined = buffer;\r\n                    if (data === undefined) {\r\n                        data = new Uint8Array(size!);\r\n                        (data as Uint8Array).set(new Uint8Array(copyArrayBuffer));\r\n                    } else {\r\n                        const ctor = data.constructor as any; // we want to create result data with the same type as buffer (Uint8Array, Float32Array, ...)\r\n                        data = new ctor(data.buffer);\r\n                        (data as any).set(new ctor(copyArrayBuffer));\r\n                    }\r\n                    gpuBuffer.unmap();\r\n                    this._bufferManager.releaseBuffer(gpuBuffer);\r\n                    resolve(data!);\r\n                },\r\n                (reason) => reject(reason)\r\n            );\r\n        });\r\n    });\r\n};\r\n\r\nWebGPUEngine.prototype.setStorageBuffer = function (name: string, buffer: Nullable<StorageBuffer>): void {\r\n    this._currentDrawContext?.setBuffer(name, (buffer?.getBuffer() as WebGPUDataBuffer) ?? null);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}