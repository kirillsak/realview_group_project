{"ast":null,"code":"import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector.js\";\n/**\n * @internal\n */\nclass FaceDirectionInfo {\n  constructor(direction, rotatedDirection = new Vector3(), diff = 0, ignore = false) {\n    this.direction = direction;\n    this.rotatedDirection = rotatedDirection;\n    this.diff = diff;\n    this.ignore = ignore;\n  }\n}\n/**\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\n */\nexport class AttachToBoxBehavior {\n  /**\n   * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\n   * @param _ui The transform node that should be attached to the mesh\n   */\n  constructor(_ui) {\n    this._ui = _ui;\n    /**\n     *  The name of the behavior\n     */\n    this.name = \"AttachToBoxBehavior\";\n    /**\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\n     */\n    this.distanceAwayFromFace = 0.15;\n    /**\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\n     */\n    this.distanceAwayFromBottomOfFace = 0.15;\n    this._faceVectors = [new FaceDirectionInfo(Vector3.Up()), new FaceDirectionInfo(Vector3.Down()), new FaceDirectionInfo(Vector3.Left()), new FaceDirectionInfo(Vector3.Right()), new FaceDirectionInfo(Vector3.Forward()), new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1))];\n    this._tmpMatrix = new Matrix();\n    this._tmpVector = new Vector3();\n    this._zeroVector = Vector3.Zero();\n    this._lookAtTmpMatrix = new Matrix();\n    /* Does nothing */\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {\n    /* Does nothing */\n  }\n  _closestFace(targetDirection) {\n    // Go over each face and calculate the angle between the face's normal and targetDirection\n    this._faceVectors.forEach(v => {\n      if (!this._target.rotationQuaternion) {\n        this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\n      }\n      this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\n      Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\n      v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\n    });\n    // Return the face information of the one with the normal closest to target direction\n    return this._faceVectors.reduce((min, p) => {\n      if (min.ignore) {\n        return p;\n      } else if (p.ignore) {\n        return min;\n      } else {\n        return min.diff < p.diff ? min : p;\n      }\n    }, this._faceVectors[0]);\n  }\n  _lookAtToRef(pos, up = new Vector3(0, 1, 0), ref) {\n    Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\n    this._lookAtTmpMatrix.invert();\n    Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\n  }\n  /**\n   * Attaches the AttachToBoxBehavior to the passed in mesh\n   * @param target The mesh that the specified node will be attached to\n   */\n  attach(target) {\n    this._target = target;\n    this._scene = this._target.getScene();\n    // Every frame, update the app bars position\n    this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n      if (!this._scene.activeCamera) {\n        return;\n      }\n      // Find the face closest to the cameras position\n      let cameraPos = this._scene.activeCamera.position;\n      if (this._scene.activeCamera.devicePosition) {\n        cameraPos = this._scene.activeCamera.devicePosition;\n      }\n      const facing = this._closestFace(cameraPos.subtract(target.position));\n      if (this._scene.activeCamera.leftCamera) {\n        this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n      } else {\n        this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\n      }\n      // Get camera up direction\n      Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\n      // Ignore faces to not select a parallel face for the up vector of the UI\n      this._faceVectors.forEach(v => {\n        if (facing.direction.x && v.direction.x) {\n          v.ignore = true;\n        }\n        if (facing.direction.y && v.direction.y) {\n          v.ignore = true;\n        }\n        if (facing.direction.z && v.direction.z) {\n          v.ignore = true;\n        }\n      });\n      const facingUp = this._closestFace(this._tmpVector);\n      // Unignore faces\n      this._faceVectors.forEach(v => {\n        v.ignore = false;\n      });\n      // Position the app bar on that face\n      this._ui.position.copyFrom(target.position);\n      if (facing.direction.x) {\n        facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      if (facing.direction.y) {\n        facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      if (facing.direction.z) {\n        facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\n        this._ui.position.addInPlace(this._tmpVector);\n      }\n      // Rotate to be oriented properly to the camera\n      if (!this._ui.rotationQuaternion) {\n        this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\n      }\n      facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\n      this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\n      // Place ui the correct distance from the bottom of the mesh\n      if (facingUp.direction.x) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\n      }\n      if (facingUp.direction.y) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\n      }\n      if (facingUp.direction.z) {\n        this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\n      }\n      this._ui.position.addInPlace(this._tmpVector);\n    });\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","Quaternion","FaceDirectionInfo","constructor","direction","rotatedDirection","diff","ignore","AttachToBoxBehavior","_ui","Up","Down","Left","Right","Forward","scaleInPlace","Zero","init","_closestFace","targetDirection","_faceVectors","forEach","v","_target","rotationQuaternion","RotationYawPitchRoll","rotation","y","x","z","toRotationMatrix","_tmpMatrix","TransformCoordinatesToRef","GetAngleBetweenVectors","Cross","reduce","min","p","_lookAtToRef","pos","up","ref","LookAtLHToRef","_zeroVector","_lookAtTmpMatrix","invert","FromRotationMatrixToRef","attach","target","_scene","getScene","_onRenderObserver","onBeforeRenderObservable","add","activeCamera","cameraPos","position","devicePosition","facing","subtract","leftCamera","computeWorldMatrix","getRotationMatrixToRef","_tmpVector","facingUp","copyFrom","scaleToRef","scaling","distanceAwayFromFace","addInPlace","distanceAwayFromBottomOfFace","detach","remove"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/attachToBoxBehavior.ts"],"sourcesContent":["import { Vector3, Matrix, Quaternion } from \"../../Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Behavior } from \"../../Behaviors/behavior\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass FaceDirectionInfo {\r\n    constructor(public direction: Vector3, public rotatedDirection = new Vector3(), public diff = 0, public ignore = false) {}\r\n}\r\n\r\n/**\r\n * A behavior that when attached to a mesh will will place a specified node on the meshes face pointing towards the camera\r\n */\r\nexport class AttachToBoxBehavior implements Behavior<Mesh> {\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public name = \"AttachToBoxBehavior\";\r\n    /**\r\n     * The distance away from the face of the mesh that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromFace = 0.15;\r\n    /**\r\n     * The distance from the bottom of the face that the UI should be attached to (default: 0.15)\r\n     */\r\n    public distanceAwayFromBottomOfFace = 0.15;\r\n    private _faceVectors = [\r\n        new FaceDirectionInfo(Vector3.Up()),\r\n        new FaceDirectionInfo(Vector3.Down()),\r\n        new FaceDirectionInfo(Vector3.Left()),\r\n        new FaceDirectionInfo(Vector3.Right()),\r\n        new FaceDirectionInfo(Vector3.Forward()),\r\n        new FaceDirectionInfo(Vector3.Forward().scaleInPlace(-1)),\r\n    ];\r\n    private _target: Mesh;\r\n    private _scene: Scene;\r\n    private _onRenderObserver: Nullable<Observer<Scene>>;\r\n    private _tmpMatrix = new Matrix();\r\n    private _tmpVector = new Vector3();\r\n\r\n    /**\r\n     * Creates the AttachToBoxBehavior, used to attach UI to the closest face of the box to a camera\r\n     * @param _ui The transform node that should be attached to the mesh\r\n     */\r\n    constructor(private _ui: TransformNode) {\r\n        /* Does nothing */\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {\r\n        /* Does nothing */\r\n    }\r\n\r\n    private _closestFace(targetDirection: Vector3) {\r\n        // Go over each face and calculate the angle between the face's normal and targetDirection\r\n        this._faceVectors.forEach((v) => {\r\n            if (!this._target.rotationQuaternion) {\r\n                this._target.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._target.rotation.y, this._target.rotation.x, this._target.rotation.z);\r\n            }\r\n            this._target.rotationQuaternion.toRotationMatrix(this._tmpMatrix);\r\n            Vector3.TransformCoordinatesToRef(v.direction, this._tmpMatrix, v.rotatedDirection);\r\n            v.diff = Vector3.GetAngleBetweenVectors(v.rotatedDirection, targetDirection, Vector3.Cross(v.rotatedDirection, targetDirection));\r\n        });\r\n        // Return the face information of the one with the normal closest to target direction\r\n        return this._faceVectors.reduce((min, p) => {\r\n            if (min.ignore) {\r\n                return p;\r\n            } else if (p.ignore) {\r\n                return min;\r\n            } else {\r\n                return min.diff < p.diff ? min : p;\r\n            }\r\n        }, this._faceVectors[0]);\r\n    }\r\n\r\n    private _zeroVector = Vector3.Zero();\r\n    private _lookAtTmpMatrix = new Matrix();\r\n    private _lookAtToRef(pos: Vector3, up = new Vector3(0, 1, 0), ref: Quaternion) {\r\n        Matrix.LookAtLHToRef(this._zeroVector, pos, up, this._lookAtTmpMatrix);\r\n        this._lookAtTmpMatrix.invert();\r\n        Quaternion.FromRotationMatrixToRef(this._lookAtTmpMatrix, ref);\r\n    }\r\n\r\n    /**\r\n     * Attaches the AttachToBoxBehavior to the passed in mesh\r\n     * @param target The mesh that the specified node will be attached to\r\n     */\r\n    attach(target: Mesh) {\r\n        this._target = target;\r\n        this._scene = this._target.getScene();\r\n\r\n        // Every frame, update the app bars position\r\n        this._onRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this._scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            // Find the face closest to the cameras position\r\n            let cameraPos = this._scene.activeCamera.position;\r\n            if ((<any>this._scene.activeCamera).devicePosition) {\r\n                cameraPos = (<any>this._scene.activeCamera).devicePosition;\r\n            }\r\n            const facing = this._closestFace(cameraPos.subtract(target.position));\r\n            if (this._scene.activeCamera.leftCamera) {\r\n                this._scene.activeCamera.leftCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            } else {\r\n                this._scene.activeCamera.computeWorldMatrix().getRotationMatrixToRef(this._tmpMatrix);\r\n            }\r\n\r\n            // Get camera up direction\r\n            Vector3.TransformCoordinatesToRef(Vector3.Up(), this._tmpMatrix, this._tmpVector);\r\n            // Ignore faces to not select a parallel face for the up vector of the UI\r\n            this._faceVectors.forEach((v) => {\r\n                if (facing.direction.x && v.direction.x) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.y && v.direction.y) {\r\n                    v.ignore = true;\r\n                }\r\n                if (facing.direction.z && v.direction.z) {\r\n                    v.ignore = true;\r\n                }\r\n            });\r\n            const facingUp = this._closestFace(this._tmpVector);\r\n            // Unignore faces\r\n            this._faceVectors.forEach((v) => {\r\n                v.ignore = false;\r\n            });\r\n\r\n            // Position the app bar on that face\r\n            this._ui.position.copyFrom(target.position);\r\n            if (facing.direction.x) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.x / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.y) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.y / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n            if (facing.direction.z) {\r\n                facing.rotatedDirection.scaleToRef(target.scaling.z / 2 + this.distanceAwayFromFace, this._tmpVector);\r\n                this._ui.position.addInPlace(this._tmpVector);\r\n            }\r\n\r\n            // Rotate to be oriented properly to the camera\r\n            if (!this._ui.rotationQuaternion) {\r\n                this._ui.rotationQuaternion = Quaternion.RotationYawPitchRoll(this._ui.rotation.y, this._ui.rotation.x, this._ui.rotation.z);\r\n            }\r\n            facing.rotatedDirection.scaleToRef(-1, this._tmpVector);\r\n            this._lookAtToRef(this._tmpVector, facingUp.rotatedDirection, this._ui.rotationQuaternion);\r\n\r\n            // Place ui the correct distance from the bottom of the mesh\r\n            if (facingUp.direction.x) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.x / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.y) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.y / 2, this._tmpVector);\r\n            }\r\n            if (facingUp.direction.z) {\r\n                this._ui.up.scaleToRef(this.distanceAwayFromBottomOfFace - target.scaling.z / 2, this._tmpVector);\r\n            }\r\n            this._ui.position.addInPlace(this._tmpVector);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    detach() {\r\n        this._scene.onBeforeRenderObservable.remove(this._onRenderObserver);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}