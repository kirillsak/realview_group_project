{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Scene } from \"../scene.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { AbstractMesh } from \"../Meshes/abstractMesh.js\";\nimport { Matrix } from \"../Maths/math.vector.js\";\nimport { SmartArray } from \"../Misc/smartArray.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { ShaderMaterial } from \"../Materials/shaderMaterial.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { DrawWrapper } from \"../Materials/drawWrapper.js\";\nimport { UniformBuffer } from \"../Materials/uniformBuffer.js\";\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder.js\";\nimport \"../Shaders/boundingBoxRenderer.fragment.js\";\nimport \"../Shaders/boundingBoxRenderer.vertex.js\";\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\n  get: function () {\n    return this._forceShowBoundingBoxes || false;\n  },\n  set: function (value) {\n    this._forceShowBoundingBoxes = value;\n    // Lazyly creates a BB renderer if needed.\n    if (value) {\n      this.getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.getBoundingBoxRenderer = function () {\n  if (!this._boundingBoxRenderer) {\n    this._boundingBoxRenderer = new BoundingBoxRenderer(this);\n  }\n  return this._boundingBoxRenderer;\n};\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\n  get: function () {\n    return this._showBoundingBox || false;\n  },\n  set: function (value) {\n    this._showBoundingBox = value;\n    // Lazyly creates a BB renderer if needed.\n    if (value) {\n      this.getScene().getBoundingBoxRenderer();\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\n/**\n * Component responsible of rendering the bounding box of the meshes in a scene.\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\n */\nexport class BoundingBoxRenderer {\n  /**\n   * Instantiates a new bounding box renderer in a scene.\n   * @param scene the scene the  renderer renders in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\n    /**\n     * Color of the bounding box lines placed in front of an object\n     */\n    this.frontColor = new Color3(1, 1, 1);\n    /**\n     * Color of the bounding box lines placed behind an object\n     */\n    this.backColor = new Color3(0.1, 0.1, 0.1);\n    /**\n     * Defines if the renderer should show the back lines or not\n     */\n    this.showBackLines = true;\n    /**\n     * Observable raised before rendering a bounding box\n     */\n    this.onBeforeBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after rendering a bounding box\n     */\n    this.onAfterBoxRenderingObservable = new Observable();\n    /**\n     * Observable raised after resources are created\n     */\n    this.onResourcesReadyObservable = new Observable();\n    /**\n     * When false, no bounding boxes will be rendered\n     */\n    this.enabled = true;\n    /**\n     * @internal\n     */\n    this.renderList = new SmartArray(32);\n    this._vertexBuffers = {};\n    this._fillIndexBuffer = null;\n    this._fillIndexData = null;\n    this.scene = scene;\n    scene._addComponent(this);\n    this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\n    this._buildUniformLayout(this._uniformBufferFront);\n    this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\n    this._buildUniformLayout(this._uniformBufferBack);\n  }\n  _buildUniformLayout(ubo) {\n    ubo.addUniform(\"color\", 4);\n    ubo.addUniform(\"world\", 16);\n    ubo.addUniform(\"viewProjection\", 16);\n    ubo.addUniform(\"viewProjectionR\", 16);\n    ubo.create();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\n    this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\n    this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\n  }\n  _evaluateSubMesh(mesh, subMesh) {\n    if (mesh.showSubMeshesBoundingBox) {\n      const boundingInfo = subMesh.getBoundingInfo();\n      if (boundingInfo !== null && boundingInfo !== undefined) {\n        boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n        this.renderList.push(boundingInfo.boundingBox);\n      }\n    }\n  }\n  _preActiveMesh(mesh) {\n    if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\n      const boundingInfo = mesh.getBoundingInfo();\n      boundingInfo.boundingBox._tag = mesh.renderingGroupId;\n      this.renderList.push(boundingInfo.boundingBox);\n    }\n  }\n  _prepareResources() {\n    if (this._colorShader) {\n      return;\n    }\n    this._colorShader = new ShaderMaterial(\"colorShader\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, false);\n    this._colorShader.doNotSerialize = true;\n    this._colorShader.reservedDataStore = {\n      hidden: true\n    };\n    this._colorShaderForOcclusionQuery = new ShaderMaterial(\"colorShaderOccQuery\", this.scene, \"boundingBoxRenderer\", {\n      attributes: [VertexBuffer.PositionKind],\n      uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\n      uniformBuffers: [\"BoundingBoxRenderer\"]\n    }, true);\n    this._colorShaderForOcclusionQuery.doNotSerialize = true;\n    this._colorShaderForOcclusionQuery.reservedDataStore = {\n      hidden: true\n    };\n    const engine = this.scene.getEngine();\n    const boxdata = CreateBoxVertexData({\n      size: 1.0\n    });\n    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, boxdata.positions, VertexBuffer.PositionKind, false);\n    this._createIndexBuffer();\n    this._fillIndexData = boxdata.indices;\n    this.onResourcesReadyObservable.notifyObservers(this);\n  }\n  _createIndexBuffer() {\n    const engine = this.scene.getEngine();\n    this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const vb = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (vb) {\n      vb._rebuild();\n    }\n    this._createIndexBuffer();\n  }\n  /**\n   * @internal\n   */\n  reset() {\n    this.renderList.reset();\n  }\n  /**\n   * Render the bounding boxes of a specific rendering group\n   * @param renderingGroupId defines the rendering group to render\n   */\n  render(renderingGroupId) {\n    var _a, _b;\n    if (this.renderList.length === 0 || !this.enabled) {\n      return;\n    }\n    this._prepareResources();\n    if (!this._colorShader.isReady()) {\n      return;\n    }\n    const engine = this.scene.getEngine();\n    engine.setDepthWrite(false);\n    const frontColor = this.frontColor.toColor4();\n    const backColor = this.backColor.toColor4();\n    const transformMatrix = this.scene.getTransformMatrix();\n    for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n      const boundingBox = this.renderList.data[boundingBoxIndex];\n      if (boundingBox._tag !== renderingGroupId) {\n        continue;\n      }\n      this._createWrappersForBoundingBox(boundingBox);\n      this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\n      const min = boundingBox.minimum;\n      const max = boundingBox.maximum;\n      const diff = max.subtract(min);\n      const median = min.add(diff.scale(0.5));\n      const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n      const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n      if (this.showBackLines) {\n        const drawWrapperBack = (_a = boundingBox._drawWrapperBack) !== null && _a !== void 0 ? _a : this._colorShader._getDrawWrapper();\n        this._colorShader._preBind(drawWrapperBack);\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n        // Back\n        if (useReverseDepthBuffer) {\n          engine.setDepthFunctionToLessOrEqual();\n        } else {\n          engine.setDepthFunctionToGreaterOrEqual();\n        }\n        this._uniformBufferBack.bindToEffect(drawWrapperBack.effect, \"BoundingBoxRenderer\");\n        this._uniformBufferBack.updateDirectColor4(\"color\", backColor);\n        this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\n        this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\n        this._uniformBufferBack.update();\n        // Draw order\n        engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      }\n      const drawWrapperFront = (_b = boundingBox._drawWrapperFront) !== null && _b !== void 0 ? _b : this._colorShader._getDrawWrapper();\n      this._colorShader._preBind(drawWrapperFront);\n      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n      // Front\n      if (useReverseDepthBuffer) {\n        engine.setDepthFunctionToGreater();\n      } else {\n        engine.setDepthFunctionToLess();\n      }\n      this._uniformBufferFront.bindToEffect(drawWrapperFront.effect, \"BoundingBoxRenderer\");\n      this._uniformBufferFront.updateDirectColor4(\"color\", frontColor);\n      this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n      this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\n      this._uniformBufferFront.update();\n      // Draw order\n      engine.drawElementsType(Material.LineListDrawMode, 0, 24);\n      this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\n    }\n    this._colorShader.unbind();\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n  }\n  _createWrappersForBoundingBox(boundingBox) {\n    if (!boundingBox._drawWrapperFront) {\n      const engine = this.scene.getEngine();\n      boundingBox._drawWrapperFront = new DrawWrapper(engine);\n      boundingBox._drawWrapperBack = new DrawWrapper(engine);\n      boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\n      boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\n    }\n  }\n  /**\n   * In case of occlusion queries, we can render the occlusion bounding box through this method\n   * @param mesh Define the mesh to render the occlusion bounding box for\n   */\n  renderOcclusionBoundingBox(mesh) {\n    const engine = this.scene.getEngine();\n    if (this._renderPassIdForOcclusionQuery === undefined) {\n      this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\n    }\n    const currentRenderPassId = engine.currentRenderPassId;\n    engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\n    this._prepareResources();\n    const subMesh = mesh.subMeshes[0];\n    if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\n      engine.currentRenderPassId = currentRenderPassId;\n      return;\n    }\n    if (!this._fillIndexBuffer) {\n      this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData);\n    }\n    const useReverseDepthBuffer = engine.useReverseDepthBuffer;\n    engine.setDepthWrite(false);\n    engine.setColorWrite(false);\n    const boundingBox = mesh.getBoundingInfo().boundingBox;\n    const min = boundingBox.minimum;\n    const max = boundingBox.maximum;\n    const diff = max.subtract(min);\n    const median = min.add(diff.scale(0.5));\n    const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\n    const drawWrapper = subMesh._drawWrapper;\n    this._colorShaderForOcclusionQuery._preBind(drawWrapper);\n    engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, drawWrapper.effect);\n    if (useReverseDepthBuffer) {\n      engine.setDepthFunctionToGreater();\n    } else {\n      engine.setDepthFunctionToLess();\n    }\n    this.scene.resetCachedMaterial();\n    this._uniformBufferFront.bindToEffect(drawWrapper.effect, \"BoundingBoxRenderer\");\n    this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\n    this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\n    this._uniformBufferFront.update();\n    engine.drawElementsType(Material.TriangleFillMode, 0, 36);\n    this._colorShaderForOcclusionQuery.unbind();\n    engine.setDepthFunctionToLessOrEqual();\n    engine.setDepthWrite(true);\n    engine.setColorWrite(true);\n    engine.currentRenderPassId = currentRenderPassId;\n  }\n  /**\n   * Dispose and release the resources attached to this renderer.\n   */\n  dispose() {\n    if (this._renderPassIdForOcclusionQuery !== undefined) {\n      this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\n      this._renderPassIdForOcclusionQuery = undefined;\n    }\n    if (!this._colorShader) {\n      return;\n    }\n    this.onBeforeBoxRenderingObservable.clear();\n    this.onAfterBoxRenderingObservable.clear();\n    this.onResourcesReadyObservable.clear();\n    this.renderList.dispose();\n    this._colorShader.dispose();\n    this._colorShaderForOcclusionQuery.dispose();\n    this._uniformBufferFront.dispose();\n    this._uniformBufferBack.dispose();\n    const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\n    if (buffer) {\n      buffer.dispose();\n      this._vertexBuffers[VertexBuffer.PositionKind] = null;\n    }\n    this.scene.getEngine()._releaseBuffer(this._indexBuffer);\n    if (this._fillIndexBuffer) {\n      this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\n      this._fillIndexBuffer = null;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Scene","VertexBuffer","AbstractMesh","Matrix","SmartArray","SceneComponentConstants","Material","ShaderMaterial","Color3","Observable","DrawWrapper","UniformBuffer","CreateBoxVertexData","Object","defineProperty","prototype","get","_forceShowBoundingBoxes","set","value","getBoundingBoxRenderer","enumerable","configurable","_boundingBoxRenderer","BoundingBoxRenderer","_showBoundingBox","getScene","constructor","scene","NAME_BOUNDINGBOXRENDERER","_addComponent","_uniformBufferFront","getEngine","undefined","isWebGPU","_buildUniformLayout","_uniformBufferBack","ubo","addUniform","create","register","_beforeEvaluateActiveMeshStage","registerStep","STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER","reset","_preActiveMeshStage","STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER","_preActiveMesh","_evaluateSubMeshStage","STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER","_evaluateSubMesh","_afterRenderingGroupDrawStage","STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER","render","mesh","subMesh","showSubMeshesBoundingBox","boundingInfo","getBoundingInfo","boundingBox","_tag","renderingGroupId","renderList","push","showBoundingBox","forceShowBoundingBoxes","_prepareResources","_colorShader","attributes","PositionKind","uniforms","uniformBuffers","doNotSerialize","reservedDataStore","hidden","_colorShaderForOcclusionQuery","engine","boxdata","size","_vertexBuffers","positions","_createIndexBuffer","_fillIndexData","indices","onResourcesReadyObservable","notifyObservers","_indexBuffer","createIndexBuffer","rebuild","vb","_rebuild","length","enabled","isReady","setDepthWrite","frontColor","toColor4","backColor","transformMatrix","getTransformMatrix","boundingBoxIndex","data","_createWrappersForBoundingBox","onBeforeBoxRenderingObservable","min","minimum","max","maximum","diff","subtract","median","add","scale","worldMatrix","Scaling","x","y","z","multiply","Translation","getWorldMatrix","useReverseDepthBuffer","showBackLines","drawWrapperBack","_drawWrapperBack","_getDrawWrapper","_preBind","bindBuffers","getEffect","setDepthFunctionToLessOrEqual","setDepthFunctionToGreaterOrEqual","bindToEffect","effect","updateDirectColor4","updateMatrix","update","drawElementsType","LineListDrawMode","drawWrapperFront","_drawWrapperFront","setDepthFunctionToGreater","setDepthFunctionToLess","onAfterBoxRenderingObservable","unbind","setEffect","renderOcclusionBoundingBox","_renderPassIdForOcclusionQuery","createRenderPassId","currentRenderPassId","subMeshes","hasBoundingInfo","_fillIndexBuffer","setColorWrite","drawWrapper","_drawWrapper","resetCachedMaterial","TriangleFillMode","dispose","releaseRenderPassId","clear","buffer","_releaseBuffer"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/boundingBoxRenderer.ts"],"sourcesContent":["import { Scene } from \"../scene\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport type { BoundingBox } from \"../Culling/boundingBox\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder\";\r\n\r\nimport \"../Shaders/boundingBoxRenderer.fragment\";\r\nimport \"../Shaders/boundingBoxRenderer.vertex\";\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _boundingBoxRenderer: BoundingBoxRenderer;\r\n\r\n        /** @internal (Backing field) */\r\n        _forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if all bounding boxes must be rendered\r\n         */\r\n        forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets the bounding box renderer associated with the scene\r\n         * @returns a BoundingBoxRenderer\r\n         */\r\n        getBoundingBoxRenderer(): BoundingBoxRenderer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\r\n    get: function (this: Scene) {\r\n        return this._forceShowBoundingBoxes || false;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        this._forceShowBoundingBoxes = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getBoundingBoxRenderer = function (): BoundingBoxRenderer {\r\n    if (!this._boundingBoxRenderer) {\r\n        this._boundingBoxRenderer = new BoundingBoxRenderer(this);\r\n    }\r\n\r\n    return this._boundingBoxRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /** @internal (Backing field) */\r\n        _showBoundingBox: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)\r\n         */\r\n        showBoundingBox: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._showBoundingBox || false;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._showBoundingBox = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getScene().getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Component responsible of rendering the bounding box of the meshes in a scene.\r\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\r\n */\r\nexport class BoundingBoxRenderer implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Color of the bounding box lines placed in front of an object\r\n     */\r\n    public frontColor = new Color3(1, 1, 1);\r\n    /**\r\n     * Color of the bounding box lines placed behind an object\r\n     */\r\n    public backColor = new Color3(0.1, 0.1, 0.1);\r\n    /**\r\n     * Defines if the renderer should show the back lines or not\r\n     */\r\n    public showBackLines = true;\r\n\r\n    /**\r\n     * Observable raised before rendering a bounding box\r\n     */\r\n    public onBeforeBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after rendering a bounding box\r\n     */\r\n    public onAfterBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after resources are created\r\n     */\r\n    public onResourcesReadyObservable = new Observable<BoundingBoxRenderer>();\r\n\r\n    /**\r\n     * When false, no bounding boxes will be rendered\r\n     */\r\n    public enabled = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public renderList = new SmartArray<BoundingBox>(32);\r\n\r\n    private _colorShader: ShaderMaterial;\r\n    private _colorShaderForOcclusionQuery: ShaderMaterial;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: DataBuffer;\r\n    private _fillIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _fillIndexData: Nullable<IndicesArray> = null;\r\n    private _uniformBufferFront: UniformBuffer;\r\n    private _uniformBufferBack: UniformBuffer;\r\n    private _renderPassIdForOcclusionQuery: number;\r\n\r\n    /**\r\n     * Instantiates a new bounding box renderer in a scene.\r\n     * @param scene the scene the  renderer renders in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        scene._addComponent(this);\r\n        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", !this.scene.getEngine().isWebGPU);\r\n        this._buildUniformLayout(this._uniformBufferFront);\r\n        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", !this.scene.getEngine().isWebGPU);\r\n        this._buildUniformLayout(this._uniformBufferBack);\r\n    }\r\n\r\n    private _buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"color\", 4);\r\n        ubo.addUniform(\"world\", 16);\r\n        ubo.addUniform(\"viewProjection\", 16);\r\n        ubo.addUniform(\"viewProjectionR\", 16);\r\n        ubo.create();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\r\n\r\n        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\r\n\r\n        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\r\n    }\r\n\r\n    private _evaluateSubMesh(mesh: AbstractMesh, subMesh: SubMesh): void {\r\n        if (mesh.showSubMeshesBoundingBox) {\r\n            const boundingInfo = subMesh.getBoundingInfo();\r\n            if (boundingInfo !== null && boundingInfo !== undefined) {\r\n                boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n                this.renderList.push(boundingInfo.boundingBox);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _preActiveMesh(mesh: AbstractMesh): void {\r\n        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n            this.renderList.push(boundingInfo.boundingBox);\r\n        }\r\n    }\r\n\r\n    private _prepareResources(): void {\r\n        if (this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\r\n            \"colorShader\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n            },\r\n            false\r\n        );\r\n        this._colorShader.doNotSerialize = true;\r\n\r\n        this._colorShader.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        this._colorShaderForOcclusionQuery = new ShaderMaterial(\r\n            \"colorShaderOccQuery\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n            },\r\n            true\r\n        );\r\n        this._colorShaderForOcclusionQuery.doNotSerialize = true;\r\n\r\n        this._colorShaderForOcclusionQuery.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const engine = this.scene.getEngine();\r\n        const boxdata = CreateBoxVertexData({ size: 1.0 });\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, <FloatArray>boxdata.positions, VertexBuffer.PositionKind, false);\r\n        this._createIndexBuffer();\r\n        this._fillIndexData = boxdata.indices;\r\n        this.onResourcesReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this.scene.getEngine();\r\n        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        this.renderList.reset();\r\n    }\r\n\r\n    /**\r\n     * Render the bounding boxes of a specific rendering group\r\n     * @param renderingGroupId defines the rendering group to render\r\n     */\r\n    public render(renderingGroupId: number): void {\r\n        if (this.renderList.length === 0 || !this.enabled) {\r\n            return;\r\n        }\r\n\r\n        this._prepareResources();\r\n\r\n        if (!this._colorShader.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this.scene.getEngine();\r\n        engine.setDepthWrite(false);\r\n\r\n        const frontColor = this.frontColor.toColor4();\r\n        const backColor = this.backColor.toColor4();\r\n        const transformMatrix = this.scene.getTransformMatrix();\r\n\r\n        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\r\n            const boundingBox = this.renderList.data[boundingBoxIndex];\r\n            if (boundingBox._tag !== renderingGroupId) {\r\n                continue;\r\n            }\r\n\r\n            this._createWrappersForBoundingBox(boundingBox);\r\n            this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\r\n\r\n            const min = boundingBox.minimum;\r\n            const max = boundingBox.maximum;\r\n            const diff = max.subtract(min);\r\n            const median = min.add(diff.scale(0.5));\r\n\r\n            const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\r\n\r\n            const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n            if (this.showBackLines) {\r\n                const drawWrapperBack = boundingBox._drawWrapperBack ?? this._colorShader._getDrawWrapper();\r\n\r\n                this._colorShader._preBind(drawWrapperBack);\r\n\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, <Effect>this._colorShader.getEffect());\r\n\r\n                // Back\r\n                if (useReverseDepthBuffer) {\r\n                    engine.setDepthFunctionToLessOrEqual();\r\n                } else {\r\n                    engine.setDepthFunctionToGreaterOrEqual();\r\n                }\r\n                this._uniformBufferBack.bindToEffect(drawWrapperBack.effect!, \"BoundingBoxRenderer\");\r\n                this._uniformBufferBack.updateDirectColor4(\"color\", backColor);\r\n                this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\r\n                this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\r\n                this._uniformBufferBack.update();\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n            }\r\n\r\n            const drawWrapperFront = boundingBox._drawWrapperFront ?? this._colorShader._getDrawWrapper();\r\n\r\n            this._colorShader._preBind(drawWrapperFront);\r\n\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, <Effect>this._colorShader.getEffect());\r\n\r\n            // Front\r\n            if (useReverseDepthBuffer) {\r\n                engine.setDepthFunctionToGreater();\r\n            } else {\r\n                engine.setDepthFunctionToLess();\r\n            }\r\n            this._uniformBufferFront.bindToEffect(drawWrapperFront.effect!, \"BoundingBoxRenderer\");\r\n            this._uniformBufferFront.updateDirectColor4(\"color\", frontColor);\r\n            this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n            this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\r\n            this._uniformBufferFront.update();\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n\r\n            this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\r\n        }\r\n        this._colorShader.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    private _createWrappersForBoundingBox(boundingBox: BoundingBox): void {\r\n        if (!boundingBox._drawWrapperFront) {\r\n            const engine = this.scene.getEngine();\r\n\r\n            boundingBox._drawWrapperFront = new DrawWrapper(engine);\r\n            boundingBox._drawWrapperBack = new DrawWrapper(engine);\r\n\r\n            boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\r\n            boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case of occlusion queries, we can render the occlusion bounding box through this method\r\n     * @param mesh Define the mesh to render the occlusion bounding box for\r\n     */\r\n    public renderOcclusionBoundingBox(mesh: AbstractMesh): void {\r\n        const engine = this.scene.getEngine();\r\n\r\n        if (this._renderPassIdForOcclusionQuery === undefined) {\r\n            this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\r\n        }\r\n\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\r\n\r\n        this._prepareResources();\r\n\r\n        const subMesh = mesh.subMeshes[0];\r\n\r\n        if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\r\n            engine.currentRenderPassId = currentRenderPassId;\r\n            return;\r\n        }\r\n\r\n        if (!this._fillIndexBuffer) {\r\n            this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData!);\r\n        }\r\n\r\n        const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n        engine.setDepthWrite(false);\r\n        engine.setColorWrite(false);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        const min = boundingBox.minimum;\r\n        const max = boundingBox.maximum;\r\n        const diff = max.subtract(min);\r\n        const median = min.add(diff.scale(0.5));\r\n\r\n        const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z).multiply(Matrix.Translation(median.x, median.y, median.z)).multiply(boundingBox.getWorldMatrix());\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._colorShaderForOcclusionQuery._preBind(drawWrapper);\r\n\r\n        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, <Effect>drawWrapper.effect);\r\n\r\n        if (useReverseDepthBuffer) {\r\n            engine.setDepthFunctionToGreater();\r\n        } else {\r\n            engine.setDepthFunctionToLess();\r\n        }\r\n\r\n        this.scene.resetCachedMaterial();\r\n\r\n        this._uniformBufferFront.bindToEffect(drawWrapper.effect!, \"BoundingBoxRenderer\");\r\n        this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n        this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\r\n        this._uniformBufferFront.update();\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 36);\r\n\r\n        this._colorShaderForOcclusionQuery.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n        engine.setColorWrite(true);\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the resources attached to this renderer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._renderPassIdForOcclusionQuery !== undefined) {\r\n            this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\r\n            this._renderPassIdForOcclusionQuery = undefined as any;\r\n        }\r\n\r\n        if (!this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeBoxRenderingObservable.clear();\r\n        this.onAfterBoxRenderingObservable.clear();\r\n        this.onResourcesReadyObservable.clear();\r\n\r\n        this.renderList.dispose();\r\n\r\n        this._colorShader.dispose();\r\n        this._colorShaderForOcclusionQuery.dispose();\r\n\r\n        this._uniformBufferFront.dispose();\r\n        this._uniformBufferBack.dispose();\r\n\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n        this.scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n\r\n        if (this._fillIndexBuffer) {\r\n            this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\r\n            this._fillIndexBuffer = null;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}