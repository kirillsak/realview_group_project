{"ast":null,"code":"/**\n * Scalar computation library\n */\nexport class Scalar {\n  /**\n   * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n   * @param a number\n   * @param b number\n   * @param epsilon (default = 1.401298E-45)\n   * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n   */\n  static WithinEpsilon(a, b, epsilon = 1.401298e-45) {\n    return Math.abs(a - b) <= epsilon;\n  }\n  /**\n   * Returns a string : the upper case translation of the number i to hexadecimal.\n   * @param i number\n   * @returns the upper case translation of the number i to hexadecimal.\n   */\n  static ToHex(i) {\n    const str = i.toString(16);\n    if (i <= 15) {\n      return (\"0\" + str).toUpperCase();\n    }\n    return str.toUpperCase();\n  }\n  /**\n   * Returns -1 if value is negative and +1 is value is positive.\n   * @param value the value\n   * @returns the value itself if it's equal to zero.\n   */\n  static Sign(value) {\n    value = +value; // convert to a number\n    if (value === 0 || isNaN(value)) {\n      return value;\n    }\n    return value > 0 ? 1 : -1;\n  }\n  /**\n   * Returns the value itself if it's between min and max.\n   * Returns min if the value is lower than min.\n   * Returns max if the value is greater than max.\n   * @param value the value to clmap\n   * @param min the min value to clamp to (default: 0)\n   * @param max the max value to clamp to (default: 1)\n   * @returns the clamped value\n   */\n  static Clamp(value, min = 0, max = 1) {\n    return Math.min(max, Math.max(min, value));\n  }\n  /**\n   * the log2 of value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n  static Log2(value) {\n    return Math.log(value) * Math.LOG2E;\n  }\n  /**\n   * the floor part of a log2 value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n  static ILog2(value) {\n    if (Math.log2) {\n      return Math.floor(Math.log2(value));\n    }\n    if (value < 0) {\n      return NaN;\n    } else if (value === 0) {\n      return -Infinity;\n    }\n    let n = 0;\n    if (value < 1) {\n      while (value < 1) {\n        n++;\n        value = value * 2;\n      }\n      n = -n;\n    } else if (value > 1) {\n      while (value > 1) {\n        n++;\n        value = Math.floor(value / 2);\n      }\n    }\n    return n;\n  }\n  /**\n   * Loops the value, so that it is never larger than length and never smaller than 0.\n   *\n   * This is similar to the modulo operator but it works with floating point numbers.\n   * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n   * With t = 5 and length = 2.5, the result would be 0.0.\n   * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n   * @param value the value\n   * @param length the length\n   * @returns the looped value\n   */\n  static Repeat(value, length) {\n    return value - Math.floor(value / length) * length;\n  }\n  /**\n   * Normalize the value between 0.0 and 1.0 using min and max values\n   * @param value value to normalize\n   * @param min max to normalize between\n   * @param max min to normalize between\n   * @returns the normalized value\n   */\n  static Normalize(value, min, max) {\n    return (value - min) / (max - min);\n  }\n  /**\n   * Denormalize the value from 0.0 and 1.0 using min and max values\n   * @param normalized value to denormalize\n   * @param min max to denormalize between\n   * @param max min to denormalize between\n   * @returns the denormalized value\n   */\n  static Denormalize(normalized, min, max) {\n    return normalized * (max - min) + min;\n  }\n  /**\n   * Calculates the shortest difference between two given angles given in degrees.\n   * @param current current angle in degrees\n   * @param target target angle in degrees\n   * @returns the delta\n   */\n  static DeltaAngle(current, target) {\n    let num = Scalar.Repeat(target - current, 360.0);\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n    return num;\n  }\n  /**\n   * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n   * @param tx value\n   * @param length length\n   * @returns The returned value will move back and forth between 0 and length\n   */\n  static PingPong(tx, length) {\n    const t = Scalar.Repeat(tx, length * 2.0);\n    return length - Math.abs(t - length);\n  }\n  /**\n   * Interpolates between min and max with smoothing at the limits.\n   *\n   * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n   * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n   * @param from from\n   * @param to to\n   * @param tx value\n   * @returns the smooth stepped value\n   */\n  static SmoothStep(from, to, tx) {\n    let t = Scalar.Clamp(tx);\n    t = -2.0 * t * t * t + 3.0 * t * t;\n    return to * t + from * (1.0 - t);\n  }\n  /**\n   * Moves a value current towards target.\n   *\n   * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n   * Negative values of maxDelta pushes the value away from target.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting value\n   */\n  static MoveTowards(current, target, maxDelta) {\n    let result = 0;\n    if (Math.abs(target - current) <= maxDelta) {\n      result = target;\n    } else {\n      result = current + Scalar.Sign(target - current) * maxDelta;\n    }\n    return result;\n  }\n  /**\n   * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   *\n   * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n   *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting angle\n   */\n  static MoveTowardsAngle(current, target, maxDelta) {\n    const num = Scalar.DeltaAngle(current, target);\n    let result = 0;\n    if (-maxDelta < num && num < maxDelta) {\n      result = target;\n    } else {\n      target = current + num;\n      result = Scalar.MoveTowards(current, target, maxDelta);\n    }\n    return result;\n  }\n  /**\n   * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n  static Lerp(start, end, amount) {\n    return start + (end - start) * amount;\n  }\n  /**\n   * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n  static LerpAngle(start, end, amount) {\n    let num = Scalar.Repeat(end - start, 360.0);\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n    return start + num * Scalar.Clamp(amount);\n  }\n  /**\n   * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n   * @param a start value\n   * @param b target value\n   * @param value value between a and b\n   * @returns the inverseLerp value\n   */\n  static InverseLerp(a, b, value) {\n    let result = 0;\n    if (a != b) {\n      result = Scalar.Clamp((value - a) / (b - a));\n    } else {\n      result = 0.0;\n    }\n    return result;\n  }\n  /**\n   * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n   * @see http://mathworld.wolfram.com/HermitePolynomial.html\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns hermite result\n   */\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n  }\n  /**\n   * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const t2 = time * time;\n    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\n  }\n  /**\n   * Returns a random float number between and min and max values\n   * @param min min value of random\n   * @param max max value of random\n   * @returns random value\n   */\n  static RandomRange(min, max) {\n    if (min === max) {\n      return min;\n    }\n    return Math.random() * (max - min) + min;\n  }\n  /**\n   * This function returns percentage of a number in a given range.\n   *\n   * RangeToPercent(40,20,60) will return 0.5 (50%)\n   * RangeToPercent(34,0,100) will return 0.34 (34%)\n   * @param number to convert to percentage\n   * @param min min range\n   * @param max max range\n   * @returns the percentage\n   */\n  static RangeToPercent(number, min, max) {\n    return (number - min) / (max - min);\n  }\n  /**\n   * This function returns number that corresponds to the percentage in a given range.\n   *\n   * PercentToRange(0.34,0,100) will return 34.\n   * @param percent to convert to number\n   * @param min min range\n   * @param max max range\n   * @returns the number\n   */\n  static PercentToRange(percent, min, max) {\n    return (max - min) * percent + min;\n  }\n  /**\n   * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n   * @param angle The angle to normalize in radian.\n   * @returns The converted angle.\n   */\n  static NormalizeRadians(angle) {\n    // More precise but slower version kept for reference.\n    // angle = angle % Tools.TwoPi;\n    // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n    //if (angle > Math.PI) {\n    //\tangle -= Tools.TwoPi;\n    //}\n    angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n    return angle;\n  }\n  /**\n   * Returns the highest common factor of two integers.\n   * @param a first parameter\n   * @param b second parameter\n   * @returns HCF of a and b\n   */\n  static HCF(a, b) {\n    const r = a % b;\n    if (r === 0) {\n      return b;\n    }\n    return Scalar.HCF(b, r);\n  }\n}\n/**\n * Two pi constants convenient for computation.\n */\nScalar.TwoPi = Math.PI * 2;","map":{"version":3,"mappings":"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","names":["Scalar","WithinEpsilon","a","b","epsilon","Math","abs","ToHex","i","str","toString","toUpperCase","Sign","value","isNaN","Clamp","min","max","Log2","log","LOG2E","ILog2","log2","floor","NaN","Infinity","n","Repeat","length","Normalize","Denormalize","normalized","DeltaAngle","current","target","num","PingPong","tx","t","SmoothStep","from","to","MoveTowards","maxDelta","result","MoveTowardsAngle","Lerp","start","end","amount","LerpAngle","InverseLerp","Hermite","value1","tangent1","value2","tangent2","squared","cubed","part1","part2","part3","part4","Hermite1stDerivative","time","t2","RandomRange","random","RangeToPercent","number","PercentToRange","percent","NormalizeRadians","angle","TwoPi","PI","HCF","r"],"sourceRoot":"","sources":["../../../../lts/core/generated/Maths/math.scalar.ts"],"sourcesContent":["/**\r\n * Scalar computation library\r\n */\r\nexport class Scalar {\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    public static TwoPi: number = Math.PI * 2;\r\n\r\n    /**\r\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     * @param a number\r\n     * @param b number\r\n     * @param epsilon (default = 1.401298E-45)\r\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\r\n     */\r\n    public static WithinEpsilon(a: number, b: number, epsilon: number = 1.401298e-45): boolean {\r\n        return Math.abs(a - b) <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Returns a string : the upper case translation of the number i to hexadecimal.\r\n     * @param i number\r\n     * @returns the upper case translation of the number i to hexadecimal.\r\n     */\r\n    public static ToHex(i: number): string {\r\n        const str = i.toString(16);\r\n\r\n        if (i <= 15) {\r\n            return (\"0\" + str).toUpperCase();\r\n        }\r\n\r\n        return str.toUpperCase();\r\n    }\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    public static Sign(value: number): number {\r\n        value = +value; // convert to a number\r\n\r\n        if (value === 0 || isNaN(value)) {\r\n            return value;\r\n        }\r\n\r\n        return value > 0 ? 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Returns the value itself if it's between min and max.\r\n     * Returns min if the value is lower than min.\r\n     * Returns max if the value is greater than max.\r\n     * @param value the value to clmap\r\n     * @param min the min value to clamp to (default: 0)\r\n     * @param max the max value to clamp to (default: 1)\r\n     * @returns the clamped value\r\n     */\r\n    public static Clamp(value: number, min = 0, max = 1): number {\r\n        return Math.min(max, Math.max(min, value));\r\n    }\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static Log2(value: number): number {\r\n        return Math.log(value) * Math.LOG2E;\r\n    }\r\n\r\n    /**\r\n     * the floor part of a log2 value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    public static ILog2(value: number): number {\r\n        if (Math.log2) {\r\n            return Math.floor(Math.log2(value));\r\n        }\r\n\r\n        if (value < 0) {\r\n            return NaN;\r\n        } else if (value === 0) {\r\n            return -Infinity;\r\n        }\r\n\r\n        let n = 0;\r\n        if (value < 1) {\r\n            while (value < 1) {\r\n                n++;\r\n                value = value * 2;\r\n            }\r\n            n = -n;\r\n        } else if (value > 1) {\r\n            while (value > 1) {\r\n                n++;\r\n                value = Math.floor(value / 2);\r\n            }\r\n        }\r\n\r\n        return n;\r\n    }\r\n\r\n    /**\r\n     * Loops the value, so that it is never larger than length and never smaller than 0.\r\n     *\r\n     * This is similar to the modulo operator but it works with floating point numbers.\r\n     * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\r\n     * With t = 5 and length = 2.5, the result would be 0.0.\r\n     * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\r\n     * @param value the value\r\n     * @param length the length\r\n     * @returns the looped value\r\n     */\r\n    public static Repeat(value: number, length: number): number {\r\n        return value - Math.floor(value / length) * length;\r\n    }\r\n\r\n    /**\r\n     * Normalize the value between 0.0 and 1.0 using min and max values\r\n     * @param value value to normalize\r\n     * @param min max to normalize between\r\n     * @param max min to normalize between\r\n     * @returns the normalized value\r\n     */\r\n    public static Normalize(value: number, min: number, max: number): number {\r\n        return (value - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n     * Denormalize the value from 0.0 and 1.0 using min and max values\r\n     * @param normalized value to denormalize\r\n     * @param min max to denormalize between\r\n     * @param max min to denormalize between\r\n     * @returns the denormalized value\r\n     */\r\n    public static Denormalize(normalized: number, min: number, max: number): number {\r\n        return normalized * (max - min) + min;\r\n    }\r\n\r\n    /**\r\n     * Calculates the shortest difference between two given angles given in degrees.\r\n     * @param current current angle in degrees\r\n     * @param target target angle in degrees\r\n     * @returns the delta\r\n     */\r\n    public static DeltaAngle(current: number, target: number): number {\r\n        let num: number = Scalar.Repeat(target - current, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n     * @param tx value\r\n     * @param length length\r\n     * @returns The returned value will move back and forth between 0 and length\r\n     */\r\n    public static PingPong(tx: number, length: number): number {\r\n        const t: number = Scalar.Repeat(tx, length * 2.0);\r\n        return length - Math.abs(t - length);\r\n    }\r\n\r\n    /**\r\n     * Interpolates between min and max with smoothing at the limits.\r\n     *\r\n     * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\r\n     * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\r\n     * @param from from\r\n     * @param to to\r\n     * @param tx value\r\n     * @returns the smooth stepped value\r\n     */\r\n    public static SmoothStep(from: number, to: number, tx: number): number {\r\n        let t: number = Scalar.Clamp(tx);\r\n        t = -2.0 * t * t * t + 3.0 * t * t;\r\n        return to * t + from * (1.0 - t);\r\n    }\r\n\r\n    /**\r\n     * Moves a value current towards target.\r\n     *\r\n     * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\r\n     * Negative values of maxDelta pushes the value away from target.\r\n     * @param current current value\r\n     * @param target target value\r\n     * @param maxDelta max distance to move\r\n     * @returns resulting value\r\n     */\r\n    public static MoveTowards(current: number, target: number, maxDelta: number): number {\r\n        let result: number = 0;\r\n        if (Math.abs(target - current) <= maxDelta) {\r\n            result = target;\r\n        } else {\r\n            result = current + Scalar.Sign(target - current) * maxDelta;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n     *\r\n     * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\r\n     *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\r\n     * @param current current value\r\n     * @param target target value\r\n     * @param maxDelta max distance to move\r\n     * @returns resulting angle\r\n     */\r\n    public static MoveTowardsAngle(current: number, target: number, maxDelta: number): number {\r\n        const num: number = Scalar.DeltaAngle(current, target);\r\n        let result: number = 0;\r\n        if (-maxDelta < num && num < maxDelta) {\r\n            result = target;\r\n        } else {\r\n            target = current + num;\r\n            result = Scalar.MoveTowards(current, target, maxDelta);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static Lerp(start: number, end: number, amount: number): number {\r\n        return start + (end - start) * amount;\r\n    }\r\n\r\n    /**\r\n     * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\r\n     * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\r\n     * @param start start value\r\n     * @param end target value\r\n     * @param amount amount to lerp between\r\n     * @returns the lerped value\r\n     */\r\n    public static LerpAngle(start: number, end: number, amount: number): number {\r\n        let num: number = Scalar.Repeat(end - start, 360.0);\r\n        if (num > 180.0) {\r\n            num -= 360.0;\r\n        }\r\n        return start + num * Scalar.Clamp(amount);\r\n    }\r\n\r\n    /**\r\n     * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\r\n     * @param a start value\r\n     * @param b target value\r\n     * @param value value between a and b\r\n     * @returns the inverseLerp value\r\n     */\r\n    public static InverseLerp(a: number, b: number, value: number): number {\r\n        let result: number = 0;\r\n        if (a != b) {\r\n            result = Scalar.Clamp((value - a) / (b - a));\r\n        } else {\r\n            result = 0.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\r\n     * @see http://mathworld.wolfram.com/HermitePolynomial.html\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param amount defines the amount on the interpolation spline (between 0 and 1)\r\n     * @returns hermite result\r\n     */\r\n    public static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number {\r\n        const squared = amount * amount;\r\n        const cubed = amount * squared;\r\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\r\n        const part2 = -2.0 * cubed + 3.0 * squared;\r\n        const part3 = cubed - 2.0 * squared + amount;\r\n        const part4 = cubed - squared;\r\n\r\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\r\n    }\r\n\r\n    /**\r\n     * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\r\n     * @param value1 defines the first control point\r\n     * @param tangent1 defines the first tangent\r\n     * @param value2 defines the second control point\r\n     * @param tangent2 defines the second tangent\r\n     * @param time define where the derivative must be done\r\n     * @returns 1st derivative\r\n     */\r\n    public static Hermite1stDerivative(value1: number, tangent1: number, value2: number, tangent2: number, time: number): number {\r\n        const t2 = time * time;\r\n        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\r\n    }\r\n\r\n    /**\r\n     * Returns a random float number between and min and max values\r\n     * @param min min value of random\r\n     * @param max max value of random\r\n     * @returns random value\r\n     */\r\n    public static RandomRange(min: number, max: number): number {\r\n        if (min === max) {\r\n            return min;\r\n        }\r\n        return Math.random() * (max - min) + min;\r\n    }\r\n\r\n    /**\r\n     * This function returns percentage of a number in a given range.\r\n     *\r\n     * RangeToPercent(40,20,60) will return 0.5 (50%)\r\n     * RangeToPercent(34,0,100) will return 0.34 (34%)\r\n     * @param number to convert to percentage\r\n     * @param min min range\r\n     * @param max max range\r\n     * @returns the percentage\r\n     */\r\n    public static RangeToPercent(number: number, min: number, max: number): number {\r\n        return (number - min) / (max - min);\r\n    }\r\n\r\n    /**\r\n     * This function returns number that corresponds to the percentage in a given range.\r\n     *\r\n     * PercentToRange(0.34,0,100) will return 34.\r\n     * @param percent to convert to number\r\n     * @param min min range\r\n     * @param max max range\r\n     * @returns the number\r\n     */\r\n    public static PercentToRange(percent: number, min: number, max: number): number {\r\n        return (max - min) * percent + min;\r\n    }\r\n\r\n    /**\r\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\r\n     * @param angle The angle to normalize in radian.\r\n     * @returns The converted angle.\r\n     */\r\n    public static NormalizeRadians(angle: number): number {\r\n        // More precise but slower version kept for reference.\r\n        // angle = angle % Tools.TwoPi;\r\n        // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\r\n\r\n        //if (angle > Math.PI) {\r\n        //\tangle -= Tools.TwoPi;\r\n        //}\r\n\r\n        angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\r\n\r\n        return angle;\r\n    }\r\n\r\n    /**\r\n     * Returns the highest common factor of two integers.\r\n     * @param a first parameter\r\n     * @param b second parameter\r\n     * @returns HCF of a and b\r\n     */\r\n    public static HCF(a: number, b: number): number {\r\n        const r: number = a % b;\r\n        if (r === 0) {\r\n            return b;\r\n        }\r\n        return Scalar.HCF(b, r);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}