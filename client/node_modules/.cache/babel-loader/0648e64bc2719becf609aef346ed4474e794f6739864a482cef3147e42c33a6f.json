{"ast":null,"code":"import { DeepCopier } from \"../../Misc/deepCopier.js\";\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\n/**\n * Particle emitter emitting particles from the inside of a cone.\n * It emits the particles alongside the cone volume from the base to the particle.\n * The emission direction might be randomized.\n */\nexport class ConeParticleEmitter {\n  /**\n   * Creates a new instance ConeParticleEmitter\n   * @param radius the radius of the emission cone (1 by default)\n   * @param angle the cone base angle (PI by default)\n   * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\n   */\n  constructor(radius = 1, angle = Math.PI, /** defines how much to randomize the particle direction [0-1] (default is 0) */\n  directionRandomizer = 0) {\n    this.directionRandomizer = directionRandomizer;\n    /**\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\n     */\n    this.radiusRange = 1;\n    /**\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\n     */\n    this.heightRange = 1;\n    /**\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\n     */\n    this.emitFromSpawnPointOnly = false;\n    this.angle = angle;\n    this.radius = radius;\n  }\n  /**\n   * Gets or sets the radius of the emission cone\n   */\n  get radius() {\n    return this._radius;\n  }\n  set radius(value) {\n    this._radius = value;\n    this._buildHeight();\n  }\n  /**\n   * Gets or sets the angle of the emission cone\n   */\n  get angle() {\n    return this._angle;\n  }\n  set angle(value) {\n    this._angle = value;\n    this._buildHeight();\n  }\n  _buildHeight() {\n    if (this._angle !== 0) {\n      this._height = this._radius / Math.tan(this._angle / 2);\n    } else {\n      this._height = 1;\n    }\n  }\n  /**\n   * Called by the particle System when the direction is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param directionToUpdate is the direction vector to update with the result\n   * @param particle is the particle we are computed the direction for\n   * @param isLocal defines if the direction should be set in local space\n   */\n  startDirectionFunction(worldMatrix, directionToUpdate, particle, isLocal) {\n    if (isLocal) {\n      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();\n    } else {\n      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\n    }\n    const randX = Scalar.RandomRange(0, this.directionRandomizer);\n    const randY = Scalar.RandomRange(0, this.directionRandomizer);\n    const randZ = Scalar.RandomRange(0, this.directionRandomizer);\n    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\n    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\n    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\n    directionToUpdate.normalize();\n  }\n  /**\n   * Called by the particle System when the position is computed for the created particle.\n   * @param worldMatrix is the world matrix of the particle system\n   * @param positionToUpdate is the position vector to update with the result\n   * @param particle is the particle we are computed the position for\n   * @param isLocal defines if the position should be set in local space\n   */\n  startPositionFunction(worldMatrix, positionToUpdate, particle, isLocal) {\n    const s = Scalar.RandomRange(0, Math.PI * 2);\n    let h;\n    if (!this.emitFromSpawnPointOnly) {\n      h = Scalar.RandomRange(0, this.heightRange);\n      // Better distribution in a cone at normal angles.\n      h = 1 - h * h;\n    } else {\n      h = 0.0001;\n    }\n    let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\n    radius = radius * h;\n    const randX = radius * Math.sin(s);\n    const randZ = radius * Math.cos(s);\n    const randY = h * this._height;\n    if (isLocal) {\n      positionToUpdate.x = randX;\n      positionToUpdate.y = randY;\n      positionToUpdate.z = randZ;\n      return;\n    }\n    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n  }\n  /**\n   * Clones the current emitter and returns a copy of it\n   * @returns the new emitter\n   */\n  clone() {\n    const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\n    DeepCopier.DeepCopy(this, newOne);\n    return newOne;\n  }\n  /**\n   * Called by the GPUParticleSystem to setup the update shader\n   * @param uboOrEffect defines the update shader\n   */\n  applyToShader(uboOrEffect) {\n    uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\n    uboOrEffect.setFloat(\"coneAngle\", this._angle);\n    uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\n    uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\n  }\n  /**\n   * Creates the structure of the ubo for this particle emitter\n   * @param ubo ubo to create the structure for\n   */\n  buildUniformLayout(ubo) {\n    ubo.addUniform(\"radius\", 2);\n    ubo.addUniform(\"coneAngle\", 1);\n    ubo.addUniform(\"height\", 2);\n    ubo.addUniform(\"directionRandomizer\", 1);\n  }\n  /**\n   * Returns a string to use to update the GPU particles update shader\n   * @returns a string containing the defines string\n   */\n  getEffectDefines() {\n    let defines = \"#define CONEEMITTER\";\n    if (this.emitFromSpawnPointOnly) {\n      defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\n    }\n    return defines;\n  }\n  /**\n   * Returns the string \"ConeParticleEmitter\"\n   * @returns a string containing the class name\n   */\n  getClassName() {\n    return \"ConeParticleEmitter\";\n  }\n  /**\n   * Serializes the particle system to a JSON object.\n   * @returns the JSON object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.type = this.getClassName();\n    serializationObject.radius = this._radius;\n    serializationObject.angle = this._angle;\n    serializationObject.directionRandomizer = this.directionRandomizer;\n    serializationObject.radiusRange = this.radiusRange;\n    serializationObject.heightRange = this.heightRange;\n    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\n    return serializationObject;\n  }\n  /**\n   * Parse properties from a JSON object\n   * @param serializationObject defines the JSON object\n   */\n  parse(serializationObject) {\n    this.radius = serializationObject.radius;\n    this.angle = serializationObject.angle;\n    this.directionRandomizer = serializationObject.directionRandomizer;\n    this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\n    this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\n    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\n  }\n}","map":{"version":3,"mappings":"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","names":["DeepCopier","Vector3","TmpVectors","Scalar","ConeParticleEmitter","constructor","radius","angle","Math","PI","directionRandomizer","_radius","value","_buildHeight","_angle","_height","tan","startDirectionFunction","worldMatrix","directionToUpdate","particle","isLocal","copyFrom","_localPosition","normalize","position","subtractToRef","getTranslation","randX","RandomRange","randY","randZ","x","y","z","startPositionFunction","positionToUpdate","s","h","emitFromSpawnPointOnly","heightRange","radiusRange","sin","cos","TransformCoordinatesFromFloatsToRef","clone","newOne","DeepCopy","applyToShader","uboOrEffect","setFloat2","setFloat","buildUniformLayout","ubo","addUniform","getEffectDefines","defines","getClassName","serialize","serializationObject","type","parse","undefined"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Particles/EmitterTypes/coneParticleEmitter.ts"],"sourcesContent":["import { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { Particle } from \"../../Particles/particle\";\r\nimport type { IParticleEmitterType } from \"./IParticleEmitterType\";\r\nimport type { UniformBufferEffectCommonAccessor } from \"../../Materials/uniformBufferEffectCommonAccessor\";\r\nimport type { UniformBuffer } from \"../../Materials/uniformBuffer\";\r\n/**\r\n * Particle emitter emitting particles from the inside of a cone.\r\n * It emits the particles alongside the cone volume from the base to the particle.\r\n * The emission direction might be randomized.\r\n */\r\nexport class ConeParticleEmitter implements IParticleEmitterType {\r\n    private _radius: number;\r\n    private _angle: number;\r\n    private _height: number;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the radius the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public radiusRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating where on the height the start position should be picked (1 = everywhere, 0 = only surface)\r\n     */\r\n    public heightRange = 1;\r\n\r\n    /**\r\n     * Gets or sets a value indicating if all the particles should be emitted from the spawn point only (the base of the cone)\r\n     */\r\n    public emitFromSpawnPointOnly = false;\r\n\r\n    /**\r\n     * Gets or sets the radius of the emission cone\r\n     */\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the angle of the emission cone\r\n     */\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._buildHeight();\r\n    }\r\n\r\n    private _buildHeight() {\r\n        if (this._angle !== 0) {\r\n            this._height = this._radius / Math.tan(this._angle / 2);\r\n        } else {\r\n            this._height = 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance ConeParticleEmitter\r\n     * @param radius the radius of the emission cone (1 by default)\r\n     * @param angle the cone base angle (PI by default)\r\n     * @param directionRandomizer defines how much to randomize the particle direction [0-1] (default is 0)\r\n     */\r\n    constructor(\r\n        radius = 1,\r\n        angle = Math.PI,\r\n        /** defines how much to randomize the particle direction [0-1] (default is 0) */\r\n        public directionRandomizer = 0\r\n    ) {\r\n        this.angle = angle;\r\n        this.radius = radius;\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the direction is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param directionToUpdate is the direction vector to update with the result\r\n     * @param particle is the particle we are computed the direction for\r\n     * @param isLocal defines if the direction should be set in local space\r\n     */\r\n    public startDirectionFunction(worldMatrix: Matrix, directionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        if (isLocal) {\r\n            TmpVectors.Vector3[0].copyFrom(particle._localPosition!).normalize();\r\n        } else {\r\n            particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();\r\n        }\r\n\r\n        const randX = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randY = Scalar.RandomRange(0, this.directionRandomizer);\r\n        const randZ = Scalar.RandomRange(0, this.directionRandomizer);\r\n        directionToUpdate.x = TmpVectors.Vector3[0].x + randX;\r\n        directionToUpdate.y = TmpVectors.Vector3[0].y + randY;\r\n        directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;\r\n        directionToUpdate.normalize();\r\n    }\r\n\r\n    /**\r\n     * Called by the particle System when the position is computed for the created particle.\r\n     * @param worldMatrix is the world matrix of the particle system\r\n     * @param positionToUpdate is the position vector to update with the result\r\n     * @param particle is the particle we are computed the position for\r\n     * @param isLocal defines if the position should be set in local space\r\n     */\r\n    startPositionFunction(worldMatrix: Matrix, positionToUpdate: Vector3, particle: Particle, isLocal: boolean): void {\r\n        const s = Scalar.RandomRange(0, Math.PI * 2);\r\n        let h: number;\r\n\r\n        if (!this.emitFromSpawnPointOnly) {\r\n            h = Scalar.RandomRange(0, this.heightRange);\r\n            // Better distribution in a cone at normal angles.\r\n            h = 1 - h * h;\r\n        } else {\r\n            h = 0.0001;\r\n        }\r\n        let radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);\r\n        radius = radius * h;\r\n\r\n        const randX = radius * Math.sin(s);\r\n        const randZ = radius * Math.cos(s);\r\n        const randY = h * this._height;\r\n\r\n        if (isLocal) {\r\n            positionToUpdate.x = randX;\r\n            positionToUpdate.y = randY;\r\n            positionToUpdate.z = randZ;\r\n            return;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\r\n    }\r\n\r\n    /**\r\n     * Clones the current emitter and returns a copy of it\r\n     * @returns the new emitter\r\n     */\r\n    public clone(): ConeParticleEmitter {\r\n        const newOne = new ConeParticleEmitter(this._radius, this._angle, this.directionRandomizer);\r\n\r\n        DeepCopier.DeepCopy(this, newOne);\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Called by the GPUParticleSystem to setup the update shader\r\n     * @param uboOrEffect defines the update shader\r\n     */\r\n    public applyToShader(uboOrEffect: UniformBufferEffectCommonAccessor): void {\r\n        uboOrEffect.setFloat2(\"radius\", this._radius, this.radiusRange);\r\n        uboOrEffect.setFloat(\"coneAngle\", this._angle);\r\n        uboOrEffect.setFloat2(\"height\", this._height, this.heightRange);\r\n        uboOrEffect.setFloat(\"directionRandomizer\", this.directionRandomizer);\r\n    }\r\n\r\n    /**\r\n     * Creates the structure of the ubo for this particle emitter\r\n     * @param ubo ubo to create the structure for\r\n     */\r\n    public buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"radius\", 2);\r\n        ubo.addUniform(\"coneAngle\", 1);\r\n        ubo.addUniform(\"height\", 2);\r\n        ubo.addUniform(\"directionRandomizer\", 1);\r\n    }\r\n\r\n    /**\r\n     * Returns a string to use to update the GPU particles update shader\r\n     * @returns a string containing the defines string\r\n     */\r\n    public getEffectDefines(): string {\r\n        let defines = \"#define CONEEMITTER\";\r\n\r\n        if (this.emitFromSpawnPointOnly) {\r\n            defines += \"\\n#define CONEEMITTERSPAWNPOINT\";\r\n        }\r\n\r\n        return defines;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"ConeParticleEmitter\"\r\n     * @returns a string containing the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ConeParticleEmitter\";\r\n    }\r\n\r\n    /**\r\n     * Serializes the particle system to a JSON object.\r\n     * @returns the JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.type = this.getClassName();\r\n        serializationObject.radius = this._radius;\r\n        serializationObject.angle = this._angle;\r\n        serializationObject.directionRandomizer = this.directionRandomizer;\r\n        serializationObject.radiusRange = this.radiusRange;\r\n        serializationObject.heightRange = this.heightRange;\r\n        serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse properties from a JSON object\r\n     * @param serializationObject defines the JSON object\r\n     */\r\n    public parse(serializationObject: any): void {\r\n        this.radius = serializationObject.radius;\r\n        this.angle = serializationObject.angle;\r\n        this.directionRandomizer = serializationObject.directionRandomizer;\r\n\r\n        this.radiusRange = serializationObject.radiusRange !== undefined ? serializationObject.radiusRange : 1;\r\n        this.heightRange = serializationObject.radiusRange !== undefined ? serializationObject.heightRange : 1;\r\n        this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== undefined ? serializationObject.emitFromSpawnPointOnly : false;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}