{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Color3 } from \"@babylonjs/core/Maths/math.color.js\";\nimport { Texture } from \"@babylonjs/core/Materials/Textures/texture.js\";\nimport { StandardMaterial } from \"@babylonjs/core/Materials/standardMaterial.js\";\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n  constructor() {\n    /**\n     * All material loaded from the mtl will be set here\n     */\n    this.materials = [];\n  }\n  /**\n   * This function will read the mtl file and create each material described inside\n   * This function could be improve by adding :\n   * -some component missing (Ni, Tf...)\n   * -including the specific options available\n   *\n   * @param scene defines the scene the material will be created in\n   * @param data defines the mtl data to parse\n   * @param rootUrl defines the rooturl to use in order to load relative dependencies\n   * @param assetContainer defines the asset container to store the material in (can be null)\n   */\n  parseMTL(scene, data, rootUrl, assetContainer) {\n    if (data instanceof ArrayBuffer) {\n      return;\n    }\n    //Split the lines from the file\n    const lines = data.split(\"\\n\");\n    // whitespace char ie: [ \\t\\r\\n\\f]\n    const delimiter_pattern = /\\s+/;\n    //Array with RGB colors\n    let color;\n    //New material\n    let material = null;\n    //Look at each line\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trim();\n      // Blank line or comment\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      //Get the first parameter (keyword)\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      //Get the data following the key\n      const value = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\n      //This mtl keyword will create the new material\n      if (key === \"newmtl\") {\n        //Check if it is the first material.\n        // Materials specifications are described after this keyword.\n        if (material) {\n          //Add the previous material in the material array.\n          this.materials.push(material);\n        }\n        //Create a new material.\n        // value is the name of the material read in the mtl file\n        scene._blockEntityCollection = !!assetContainer;\n        material = new StandardMaterial(value, scene);\n        material._parentContainer = assetContainer;\n        scene._blockEntityCollection = false;\n      } else if (key === \"kd\" && material) {\n        // Diffuse color (color under white light) using RGB values\n        //value  = \"r g b\"\n        color = value.split(delimiter_pattern, 3).map(parseFloat);\n        //color = [r,g,b]\n        //Set tghe color into the material\n        material.diffuseColor = Color3.FromArray(color);\n      } else if (key === \"ka\" && material) {\n        // Ambient color (color under shadow) using RGB values\n        //value = \"r g b\"\n        color = value.split(delimiter_pattern, 3).map(parseFloat);\n        //color = [r,g,b]\n        //Set tghe color into the material\n        material.ambientColor = Color3.FromArray(color);\n      } else if (key === \"ks\" && material) {\n        // Specular color (color when light is reflected from shiny surface) using RGB values\n        //value = \"r g b\"\n        color = value.split(delimiter_pattern, 3).map(parseFloat);\n        //color = [r,g,b]\n        //Set the color into the material\n        material.specularColor = Color3.FromArray(color);\n      } else if (key === \"ke\" && material) {\n        // Emissive color using RGB values\n        color = value.split(delimiter_pattern, 3).map(parseFloat);\n        material.emissiveColor = Color3.FromArray(color);\n      } else if (key === \"ns\" && material) {\n        //value = \"Integer\"\n        material.specularPower = parseFloat(value);\n      } else if (key === \"d\" && material) {\n        //d is dissolve for current material. It mean alpha for BABYLON\n        material.alpha = parseFloat(value);\n        //Texture\n        //This part can be improved by adding the possible options of texture\n      } else if (key === \"map_ka\" && material) {\n        // ambient texture map with a loaded image\n        //We must first get the folder of the image\n        material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n      } else if (key === \"map_kd\" && material) {\n        // Diffuse texture map with a loaded image\n        material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n      } else if (key === \"map_ks\" && material) {\n        // Specular texture map with a loaded image\n        //We must first get the folder of the image\n        material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n      } else if (key === \"map_ns\") {\n        //Specular\n        //Specular highlight component\n        //We must first get the folder of the image\n        //\n        //Not supported by BABYLON\n        //\n        //    continue;\n      } else if (key === \"map_bump\" && material) {\n        //The bump texture\n        const values = value.split(delimiter_pattern);\n        const bumpMultiplierIndex = values.indexOf(\"-bm\");\n        let bumpMultiplier = null;\n        if (bumpMultiplierIndex >= 0) {\n          bumpMultiplier = values[bumpMultiplierIndex + 1];\n          values.splice(bumpMultiplierIndex, 2); // remove\n        }\n\n        material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\n        if (material.bumpTexture && bumpMultiplier !== null) {\n          material.bumpTexture.level = parseFloat(bumpMultiplier);\n        }\n      } else if (key === \"map_d\" && material) {\n        // The dissolve of the material\n        material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n        //Options for illumination\n      } else if (key === \"illum\") {\n        //Illumination\n        if (value === \"0\") {\n          //That mean Kd == Kd\n        } else if (value === \"1\") {\n          //Color on and Ambient on\n        } else if (value === \"2\") {\n          //Highlight on\n        } else if (value === \"3\") {\n          //Reflection on and Ray trace on\n        } else if (value === \"4\") {\n          //Transparency: Glass on, Reflection: Ray trace on\n        } else if (value === \"5\") {\n          //Reflection: Fresnel on and Ray trace on\n        } else if (value === \"6\") {\n          //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n        } else if (value === \"7\") {\n          //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n        } else if (value === \"8\") {\n          //Reflection on and Ray trace off\n        } else if (value === \"9\") {\n          //Transparency: Glass on, Reflection: Ray trace off\n        } else if (value === \"10\") {\n          //Casts shadows onto invisible surfaces\n        }\n      } else {\n        // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n      }\n    }\n    //At the end of the file, add the last material\n    if (material) {\n      this.materials.push(material);\n    }\n  }\n  /**\n   * Gets the texture for the material.\n   *\n   * If the material is imported from input file,\n   * We sanitize the url to ensure it takes the texture from aside the material.\n   *\n   * @param rootUrl The root url to load from\n   * @param value The value stored in the mtl\n   * @param scene\n   * @returns The Texture\n   */\n  static _GetTexture(rootUrl, value, scene) {\n    if (!value) {\n      return null;\n    }\n    let url = rootUrl;\n    // Load from input file.\n    if (rootUrl === \"file:\") {\n      let lastDelimiter = value.lastIndexOf(\"\\\\\");\n      if (lastDelimiter === -1) {\n        lastDelimiter = value.lastIndexOf(\"/\");\n      }\n      if (lastDelimiter > -1) {\n        url += value.substr(lastDelimiter + 1);\n      } else {\n        url += value;\n      }\n    }\n    // Not from input file.\n    else {\n      url += value;\n    }\n    return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\n  }\n}\n/**\n * Invert Y-Axis of referenced textures on load\n */\nMTLFileLoader.INVERT_TEXTURE_Y = true;","map":{"version":3,"mappings":";AACA,SAASA,MAAM,QAAE;AACjB,SAASC,OAAO,QAAE;AAClB,SAASC,gBAAgB,QAAE;AAI3B;;;AAGA,OAAM,MAAOC,aAAa;EAA1BC;IAMI;;;IAGO,cAAS,GAAuB,EAAE;EA+M7C;EA7MI;;;;;;;;;;;EAWOC,QAAQ,CAACC,KAAY,EAAEC,IAA0B,EAAEC,OAAe,EAAEC,cAAwC;IAC/G,IAAIF,IAAI,YAAYG,WAAW,EAAE;MAC7B;;IAGJ;IACA,MAAMC,KAAK,GAAGJ,IAAI,CAACK,KAAK,CAAC,IAAI,CAAC;IAC9B;IACA,MAAMC,iBAAiB,GAAG,KAAK;IAC/B;IACA,IAAIC,KAAe;IACnB;IACA,IAAIC,QAAQ,GAA+B,IAAI;IAE/C;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,KAAK,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;MACnC,MAAME,IAAI,GAAGP,KAAK,CAACK,CAAC,CAAC,CAACG,IAAI,EAAE;MAE5B;MACA,IAAID,IAAI,CAACD,MAAM,KAAK,CAAC,IAAIC,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7C;;MAGJ;MACA,MAAMC,GAAG,GAAGH,IAAI,CAACI,OAAO,CAAC,GAAG,CAAC;MAC7B,IAAIC,GAAG,GAAGF,GAAG,IAAI,CAAC,GAAGH,IAAI,CAACM,SAAS,CAAC,CAAC,EAAEH,GAAG,CAAC,GAAGH,IAAI;MAClDK,GAAG,GAAGA,GAAG,CAACE,WAAW,EAAE;MAEvB;MACA,MAAMC,KAAK,GAAWL,GAAG,IAAI,CAAC,GAAGH,IAAI,CAACM,SAAS,CAACH,GAAG,GAAG,CAAC,CAAC,CAACF,IAAI,EAAE,GAAG,EAAE;MAEpE;MACA,IAAII,GAAG,KAAK,QAAQ,EAAE;QAClB;QACA;QACA,IAAIR,QAAQ,EAAE;UACV;UACA,IAAI,CAACY,SAAS,CAACC,IAAI,CAACb,QAAQ,CAAC;;QAEjC;QACA;QAEAT,KAAK,CAACuB,sBAAsB,GAAG,CAAC,CAACpB,cAAc;QAC/CM,QAAQ,GAAG,IAAIb,gBAAgB,CAACwB,KAAK,EAAEpB,KAAK,CAAC;QAC7CS,QAAQ,CAACe,gBAAgB,GAAGrB,cAAc;QAC1CH,KAAK,CAACuB,sBAAsB,GAAG,KAAK;OACvC,MAAM,IAAIN,GAAG,KAAK,IAAI,IAAIR,QAAQ,EAAE;QACjC;QAEA;QACAD,KAAK,GAAaY,KAAK,CAACd,KAAK,CAACC,iBAAiB,EAAE,CAAC,CAAC,CAACkB,GAAG,CAACC,UAAU,CAAC;QACnE;QACA;QACAjB,QAAQ,CAACkB,YAAY,GAAGjC,MAAM,CAACkC,SAAS,CAACpB,KAAK,CAAC;OAClD,MAAM,IAAIS,GAAG,KAAK,IAAI,IAAIR,QAAQ,EAAE;QACjC;QAEA;QACAD,KAAK,GAAaY,KAAK,CAACd,KAAK,CAACC,iBAAiB,EAAE,CAAC,CAAC,CAACkB,GAAG,CAACC,UAAU,CAAC;QACnE;QACA;QACAjB,QAAQ,CAACoB,YAAY,GAAGnC,MAAM,CAACkC,SAAS,CAACpB,KAAK,CAAC;OAClD,MAAM,IAAIS,GAAG,KAAK,IAAI,IAAIR,QAAQ,EAAE;QACjC;QAEA;QACAD,KAAK,GAAaY,KAAK,CAACd,KAAK,CAACC,iBAAiB,EAAE,CAAC,CAAC,CAACkB,GAAG,CAACC,UAAU,CAAC;QACnE;QACA;QACAjB,QAAQ,CAACqB,aAAa,GAAGpC,MAAM,CAACkC,SAAS,CAACpB,KAAK,CAAC;OACnD,MAAM,IAAIS,GAAG,KAAK,IAAI,IAAIR,QAAQ,EAAE;QACjC;QACAD,KAAK,GAAGY,KAAK,CAACd,KAAK,CAACC,iBAAiB,EAAE,CAAC,CAAC,CAACkB,GAAG,CAACC,UAAU,CAAC;QACzDjB,QAAQ,CAACsB,aAAa,GAAGrC,MAAM,CAACkC,SAAS,CAACpB,KAAK,CAAC;OACnD,MAAM,IAAIS,GAAG,KAAK,IAAI,IAAIR,QAAQ,EAAE;QACjC;QACAA,QAAQ,CAACuB,aAAa,GAAGN,UAAU,CAACN,KAAK,CAAC;OAC7C,MAAM,IAAIH,GAAG,KAAK,GAAG,IAAIR,QAAQ,EAAE;QAChC;QACAA,QAAQ,CAACwB,KAAK,GAAGP,UAAU,CAACN,KAAK,CAAC;QAElC;QACA;OACH,MAAM,IAAIH,GAAG,KAAK,QAAQ,IAAIR,QAAQ,EAAE;QACrC;QACA;QACAA,QAAQ,CAACyB,cAAc,GAAGrC,aAAa,CAACsC,WAAW,CAACjC,OAAO,EAAEkB,KAAK,EAAEpB,KAAK,CAAC;OAC7E,MAAM,IAAIiB,GAAG,KAAK,QAAQ,IAAIR,QAAQ,EAAE;QACrC;QACAA,QAAQ,CAAC2B,cAAc,GAAGvC,aAAa,CAACsC,WAAW,CAACjC,OAAO,EAAEkB,KAAK,EAAEpB,KAAK,CAAC;OAC7E,MAAM,IAAIiB,GAAG,KAAK,QAAQ,IAAIR,QAAQ,EAAE;QACrC;QACA;QACAA,QAAQ,CAAC4B,eAAe,GAAGxC,aAAa,CAACsC,WAAW,CAACjC,OAAO,EAAEkB,KAAK,EAAEpB,KAAK,CAAC;OAC9E,MAAM,IAAIiB,GAAG,KAAK,QAAQ,EAAE;QACzB;QACA;QACA;QACA;QACA;QACA;QACA;MAAA,CACH,MAAM,IAAIA,GAAG,KAAK,UAAU,IAAIR,QAAQ,EAAE;QACvC;QACA,MAAM6B,MAAM,GAAGlB,KAAK,CAACd,KAAK,CAACC,iBAAiB,CAAC;QAC7C,MAAMgC,mBAAmB,GAAGD,MAAM,CAACtB,OAAO,CAAC,KAAK,CAAC;QACjD,IAAIwB,cAAc,GAAqB,IAAI;QAE3C,IAAID,mBAAmB,IAAI,CAAC,EAAE;UAC1BC,cAAc,GAAGF,MAAM,CAACC,mBAAmB,GAAG,CAAC,CAAC;UAChDD,MAAM,CAACG,MAAM,CAACF,mBAAmB,EAAE,CAAC,CAAC,CAAC,CAAC;;;QAG3C9B,QAAQ,CAACiC,WAAW,GAAG7C,aAAa,CAACsC,WAAW,CAACjC,OAAO,EAAEoC,MAAM,CAACK,IAAI,CAAC,GAAG,CAAC,EAAE3C,KAAK,CAAC;QAClF,IAAIS,QAAQ,CAACiC,WAAW,IAAIF,cAAc,KAAK,IAAI,EAAE;UACjD/B,QAAQ,CAACiC,WAAW,CAACE,KAAK,GAAGlB,UAAU,CAACc,cAAc,CAAC;;OAE9D,MAAM,IAAIvB,GAAG,KAAK,OAAO,IAAIR,QAAQ,EAAE;QACpC;QACAA,QAAQ,CAACoC,cAAc,GAAGhD,aAAa,CAACsC,WAAW,CAACjC,OAAO,EAAEkB,KAAK,EAAEpB,KAAK,CAAC;QAE1E;OACH,MAAM,IAAIiB,GAAG,KAAK,OAAO,EAAE;QACxB;QACA,IAAIG,KAAK,KAAK,GAAG,EAAE;UACf;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,GAAG,EAAE;UACtB;QAAA,CACH,MAAM,IAAIA,KAAK,KAAK,IAAI,EAAE;UACvB;QAAA;OAEP,MAAM;QACH;MAAA;;IAGR;IACA,IAAIX,QAAQ,EAAE;MACV,IAAI,CAACY,SAAS,CAACC,IAAI,CAACb,QAAQ,CAAC;;EAErC;EAEA;;;;;;;;;;;EAWQ,OAAO0B,WAAW,CAACjC,OAAe,EAAEkB,KAAa,EAAEpB,KAAY;IACnE,IAAI,CAACoB,KAAK,EAAE;MACR,OAAO,IAAI;;IAGf,IAAI0B,GAAG,GAAG5C,OAAO;IACjB;IACA,IAAIA,OAAO,KAAK,OAAO,EAAE;MACrB,IAAI6C,aAAa,GAAG3B,KAAK,CAAC4B,WAAW,CAAC,IAAI,CAAC;MAC3C,IAAID,aAAa,KAAK,CAAC,CAAC,EAAE;QACtBA,aAAa,GAAG3B,KAAK,CAAC4B,WAAW,CAAC,GAAG,CAAC;;MAG1C,IAAID,aAAa,GAAG,CAAC,CAAC,EAAE;QACpBD,GAAG,IAAI1B,KAAK,CAAC6B,MAAM,CAACF,aAAa,GAAG,CAAC,CAAC;OACzC,MAAM;QACHD,GAAG,IAAI1B,KAAK;;;IAGpB;IAAA,KACK;MACD0B,GAAG,IAAI1B,KAAK;;IAGhB,OAAO,IAAIzB,OAAO,CAACmD,GAAG,EAAE9C,KAAK,EAAE,KAAK,EAAEH,aAAa,CAACqD,gBAAgB,CAAC;EACzE;;AAtNA;;;AAGcrD,8BAAgB,GAAG,IAAI","names":["Color3","Texture","StandardMaterial","MTLFileLoader","constructor","parseMTL","scene","data","rootUrl","assetContainer","ArrayBuffer","lines","split","delimiter_pattern","color","material","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","value","materials","push","_blockEntityCollection","_parentContainer","map","parseFloat","diffuseColor","FromArray","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","join","level","opacityTexture","url","lastDelimiter","lastIndexOf","substr","INVERT_TEXTURE_Y"],"sourceRoot":"","sources":["../../../../lts/loaders/generated/OBJ/mtlFileLoader.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiter_pattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = <number[]>value.split(delimiter_pattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiter_pattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiter_pattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @returns The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substr(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}