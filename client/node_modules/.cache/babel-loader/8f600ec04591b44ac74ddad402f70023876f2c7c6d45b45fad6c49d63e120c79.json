{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { PBRMaterial } from \"@babylonjs/core/Materials/PBR/pbrMaterial.js\";\nimport { GLTFLoader } from \"../glTFLoader.js\";\nimport { RenderTargetTexture } from \"@babylonjs/core/Materials/Textures/renderTargetTexture.js\";\nimport { Observable } from \"@babylonjs/core/Misc/observable.js\";\nimport { Constants } from \"@babylonjs/core/Engines/constants.js\";\nimport { Tools } from \"@babylonjs/core/Misc/tools.js\";\n/**\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\n */\nclass TransmissionHelper {\n  /**\n   * constructor\n   * @param options Defines the options we want to customize the helper\n   * @param scene The scene to add the material to\n   */\n  constructor(options, scene) {\n    this._opaqueRenderTarget = null;\n    this._opaqueMeshesCache = [];\n    this._transparentMeshesCache = [];\n    this._materialObservers = {};\n    this._options = {\n      ...TransmissionHelper._GetDefaultOptions(),\n      ...options\n    };\n    this._scene = scene;\n    this._scene._transmissionHelper = this;\n    this.onErrorObservable = new Observable();\n    this._scene.onDisposeObservable.addOnce(() => {\n      this.dispose();\n    });\n    this._parseScene();\n    this._setupRenderTargets();\n  }\n  /**\n   * Creates the default options for the helper.\n   */\n  static _GetDefaultOptions() {\n    return {\n      renderSize: 1024,\n      samples: 4,\n      lodGenerationScale: 1,\n      lodGenerationOffset: -4,\n      renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\n      generateMipmaps: true\n    };\n  }\n  /**\n   * Updates the background according to the new options\n   * @param options\n   */\n  updateOptions(options) {\n    // First check if any options are actually being changed. If not, exit.\n    const newValues = Object.keys(options).filter(key => this._options[key] !== options[key]);\n    if (!newValues.length) {\n      return;\n    }\n    const newOptions = {\n      ...this._options,\n      ...options\n    };\n    const oldOptions = this._options;\n    this._options = newOptions;\n    // If size changes, recreate everything\n    if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {\n      this._setupRenderTargets();\n    } else {\n      this._opaqueRenderTarget.samples = newOptions.samples;\n      this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\n      this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\n    }\n  }\n  /**\n   * Gets the opaque render target texture or null if not available.\n   */\n  getOpaqueTarget() {\n    return this._opaqueRenderTarget;\n  }\n  _shouldRenderAsTransmission(material) {\n    if (!material) {\n      return false;\n    }\n    if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\n      return true;\n    }\n    return false;\n  }\n  _addMesh(mesh) {\n    this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\n    // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\n    // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\n    Tools.SetImmediate(() => {\n      if (this._shouldRenderAsTransmission(mesh.material)) {\n        mesh.material.refractionTexture = this._opaqueRenderTarget;\n        this._transparentMeshesCache.push(mesh);\n      } else {\n        this._opaqueMeshesCache.push(mesh);\n      }\n    });\n  }\n  _removeMesh(mesh) {\n    mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\n    delete this._materialObservers[mesh.uniqueId];\n    let idx = this._transparentMeshesCache.indexOf(mesh);\n    if (idx !== -1) {\n      this._transparentMeshesCache.splice(idx, 1);\n    }\n    idx = this._opaqueMeshesCache.indexOf(mesh);\n    if (idx !== -1) {\n      this._opaqueMeshesCache.splice(idx, 1);\n    }\n  }\n  _parseScene() {\n    this._scene.meshes.forEach(this._addMesh.bind(this));\n    // Listen for when a mesh is added to the scene and add it to our cache lists.\n    this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\n    // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\n    this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\n  }\n  // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\n  _onMeshMaterialChanged(mesh) {\n    const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\n    const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\n    // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\n    const useTransmission = this._shouldRenderAsTransmission(mesh.material);\n    if (useTransmission) {\n      if (mesh.material instanceof PBRMaterial) {\n        mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\n      }\n      if (opaqueIdx !== -1) {\n        this._opaqueMeshesCache.splice(opaqueIdx, 1);\n        this._transparentMeshesCache.push(mesh);\n      } else if (transparentIdx === -1) {\n        this._transparentMeshesCache.push(mesh);\n      }\n      // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\n    } else {\n      if (transparentIdx !== -1) {\n        this._transparentMeshesCache.splice(transparentIdx, 1);\n        this._opaqueMeshesCache.push(mesh);\n      } else if (opaqueIdx === -1) {\n        this._opaqueMeshesCache.push(mesh);\n      }\n    }\n  }\n  /**\n   * Setup the render targets according to the specified options.\n   */\n  _setupRenderTargets() {\n    var _a, _b;\n    if (this._opaqueRenderTarget) {\n      this._opaqueRenderTarget.dispose();\n    }\n    this._opaqueRenderTarget = new RenderTargetTexture(\"opaqueSceneTexture\", this._options.renderSize, this._scene, this._options.generateMipmaps, undefined, this._options.renderTargetTextureType);\n    this._opaqueRenderTarget.ignoreCameraViewport = true;\n    this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\n    this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();\n    this._opaqueRenderTarget.gammaSpace = false;\n    this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\n    this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\n    this._opaqueRenderTarget.samples = this._options.samples;\n    let sceneImageProcessingapplyByPostProcess;\n    let saveSceneEnvIntensity;\n    this._opaqueRenderTarget.onBeforeBindObservable.add(opaqueRenderTarget => {\n      saveSceneEnvIntensity = this._scene.environmentIntensity;\n      this._scene.environmentIntensity = 1.0;\n      sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\n      if (!this._options.clearColor) {\n        this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\n      } else {\n        opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\n      }\n      // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\n      this._scene.imageProcessingConfiguration._applyByPostProcess = true;\n    });\n    this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\n      this._scene.environmentIntensity = saveSceneEnvIntensity;\n      this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;\n    });\n    this._transparentMeshesCache.forEach(mesh => {\n      if (this._shouldRenderAsTransmission(mesh.material)) {\n        mesh.material.refractionTexture = this._opaqueRenderTarget;\n      }\n    });\n  }\n  /**\n   * Dispose all the elements created by the Helper.\n   */\n  dispose() {\n    this._scene._transmissionHelper = undefined;\n    if (this._opaqueRenderTarget) {\n      this._opaqueRenderTarget.dispose();\n      this._opaqueRenderTarget = null;\n    }\n    this._transparentMeshesCache = [];\n    this._opaqueMeshesCache = [];\n  }\n}\nconst NAME = \"KHR_materials_transmission\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_materials_transmission {\n  /**\n   * @internal\n   */\n  constructor(loader) {\n    /**\n     * The name of this extension.\n     */\n    this.name = NAME;\n    /**\n     * Defines a number that determines the order the extensions are applied.\n     */\n    this.order = 175;\n    this._loader = loader;\n    this.enabled = this._loader.isExtensionUsed(NAME);\n    if (this.enabled) {\n      loader.parent.transparencyAsCoverage = true;\n    }\n  }\n  /** @internal */\n  dispose() {\n    this._loader = null;\n  }\n  /**\n   * @internal\n   */\n  loadMaterialPropertiesAsync(context, material, babylonMaterial) {\n    return GLTFLoader.LoadExtensionAsync(context, material, this.name, (extensionContext, extension) => {\n      const promises = new Array();\n      promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\n      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\n      promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\n      return Promise.all(promises).then(() => {});\n    });\n  }\n  _loadTransparentPropertiesAsync(context, material, babylonMaterial, extension) {\n    if (!(babylonMaterial instanceof PBRMaterial)) {\n      throw new Error(`${context}: Material type not supported`);\n    }\n    const pbrMaterial = babylonMaterial;\n    // Enables \"refraction\" texture which represents transmitted light.\n    pbrMaterial.subSurface.isRefractionEnabled = true;\n    // Since this extension models thin-surface transmission only, we must make IOR = 1.0\n    pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\n    // Albedo colour will tint transmission.\n    pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\n    if (extension.transmissionFactor !== undefined) {\n      pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\n      const scene = pbrMaterial.getScene();\n      if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\n        new TransmissionHelper({}, pbrMaterial.getScene());\n      }\n    } else {\n      pbrMaterial.subSurface.refractionIntensity = 0.0;\n      pbrMaterial.subSurface.isRefractionEnabled = false;\n      return Promise.resolve();\n    }\n    pbrMaterial.subSurface.minimumThickness = 0.0;\n    pbrMaterial.subSurface.maximumThickness = 0.0;\n    if (extension.transmissionTexture) {\n      extension.transmissionTexture.nonColorData = true;\n      return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then(texture => {\n        pbrMaterial.subSurface.refractionIntensityTexture = texture;\n        pbrMaterial.subSurface.useGltfStyleTextures = true;\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n}\nGLTFLoader.RegisterExtension(NAME, loader => new KHR_materials_transmission(loader));","map":{"version":3,"mappings":"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","names":["PBRMaterial","GLTFLoader","RenderTargetTexture","Observable","Constants","Tools","TransmissionHelper","constructor","options","scene","_options","_GetDefaultOptions","_scene","_transmissionHelper","onErrorObservable","onDisposeObservable","addOnce","dispose","_parseScene","_setupRenderTargets","renderSize","samples","lodGenerationScale","lodGenerationOffset","renderTargetTextureType","TEXTURETYPE_HALF_FLOAT","generateMipmaps","updateOptions","newValues","Object","keys","filter","key","length","newOptions","oldOptions","_opaqueRenderTarget","getOpaqueTarget","_shouldRenderAsTransmission","material","subSurface","isRefractionEnabled","_addMesh","mesh","_materialObservers","uniqueId","onMaterialChangedObservable","add","_onMeshMaterialChanged","bind","SetImmediate","refractionTexture","_transparentMeshesCache","push","_opaqueMeshesCache","_removeMesh","remove","idx","indexOf","splice","meshes","forEach","onNewMeshAddedObservable","onMeshRemovedObservable","transparentIdx","opaqueIdx","useTransmission","undefined","ignoreCameraViewport","renderList","clearColor","clone","gammaSpace","sceneImageProcessingapplyByPostProcess","saveSceneEnvIntensity","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","imageProcessingConfiguration","applyByPostProcess","toLinearSpaceToRef","copyFrom","_applyByPostProcess","onAfterUnbindObservable","NAME","KHR_materials_transmission","loader","_loader","enabled","isExtensionUsed","parent","transparencyAsCoverage","loadMaterialPropertiesAsync","context","babylonMaterial","LoadExtensionAsync","name","extensionContext","extension","promises","Array","loadMaterialBasePropertiesAsync","_loadTransparentPropertiesAsync","Promise","all","then","Error","pbrMaterial","volumeIndexOfRefraction","useAlbedoToTintRefraction","transmissionFactor","refractionIntensity","getScene","resolve","minimumThickness","maximumThickness","transmissionTexture","nonColorData","loadTextureInfoAsync","texture","refractionIntensityTexture","useGltfStyleTextures","RegisterExtension"],"sourceRoot":"","sources":["../../../../../../lts/loaders/generated/glTF/2.0/Extensions/KHR_materials_transmission.ts"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @internal\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the opaque render target texture or null if not available.\r\n     */\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        if (!material) {\r\n            return false;\r\n        }\r\n        if (material instanceof PBRMaterial && material.subSurface.isRefractionEnabled) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material instanceof PBRMaterial) {\r\n                mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    private _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n\r\n        let sceneImageProcessingapplyByPostProcess: boolean;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            sceneImageProcessingapplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n            // we do not use the applyByPostProcess setter to avoid flagging all the materials as \"image processing dirty\"!\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = true;\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n            this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;\r\n        });\r\n\r\n        this._transparentMeshesCache.forEach((mesh: AbstractMesh) => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n        const pbrMaterial = babylonMaterial as PBRMaterial;\r\n\r\n        // Enables \"refraction\" texture which represents transmitted light.\r\n        pbrMaterial.subSurface.isRefractionEnabled = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\r\n        pbrMaterial.subSurface.volumeIndexOfRefraction = 1.0;\r\n\r\n        // Albedo colour will tint transmission.\r\n        pbrMaterial.subSurface.useAlbedoToTintRefraction = true;\r\n\r\n        if (extension.transmissionFactor !== undefined) {\r\n            pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;\r\n            const scene = pbrMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {\r\n                new TransmissionHelper({}, pbrMaterial.getScene());\r\n            }\r\n        } else {\r\n            pbrMaterial.subSurface.refractionIntensity = 0.0;\r\n            pbrMaterial.subSurface.isRefractionEnabled = false;\r\n            return Promise.resolve();\r\n        }\r\n\r\n        pbrMaterial.subSurface.minimumThickness = 0.0;\r\n        pbrMaterial.subSurface.maximumThickness = 0.0;\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            return this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, undefined).then((texture: BaseTexture) => {\r\n                pbrMaterial.subSurface.refractionIntensityTexture = texture;\r\n                pbrMaterial.subSurface.useGltfStyleTextures = true;\r\n            });\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(NAME, (loader) => new KHR_materials_transmission(loader));\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}