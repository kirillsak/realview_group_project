{"ast":null,"code":"import { PanoramaToCubeMapTools } from \"./panoramaToCubemap.js\";\n/**\n * This groups tools to convert HDR texture to native colors array.\n */\nexport class HDRTools {\n  static _Ldexp(mantissa, exponent) {\n    if (exponent > 1023) {\n      return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n    }\n    if (exponent < -1074) {\n      return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n    }\n    return mantissa * Math.pow(2, exponent);\n  }\n  static _Rgbe2float(float32array, red, green, blue, exponent, index) {\n    if (exponent > 0) {\n      /*nonzero pixel*/\n      exponent = this._Ldexp(1.0, exponent - (128 + 8));\n      float32array[index + 0] = red * exponent;\n      float32array[index + 1] = green * exponent;\n      float32array[index + 2] = blue * exponent;\n    } else {\n      float32array[index + 0] = 0;\n      float32array[index + 1] = 0;\n      float32array[index + 2] = 0;\n    }\n  }\n  static _ReadStringLine(uint8array, startIndex) {\n    let line = \"\";\n    let character = \"\";\n    for (let i = startIndex; i < uint8array.length - startIndex; i++) {\n      character = String.fromCharCode(uint8array[i]);\n      if (character == \"\\n\") {\n        break;\n      }\n      line += character;\n    }\n    return line;\n  }\n  /**\n   * Reads header information from an RGBE texture stored in a native array.\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param uint8array The binary file stored in  native array.\n   * @returns The header information.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static RGBE_ReadHeader(uint8array) {\n    let height = 0;\n    let width = 0;\n    let line = this._ReadStringLine(uint8array, 0);\n    if (line[0] != \"#\" || line[1] != \"?\") {\n      throw \"Bad HDR Format.\";\n    }\n    let endOfHeader = false;\n    let findFormat = false;\n    let lineIndex = 0;\n    do {\n      lineIndex += line.length + 1;\n      line = this._ReadStringLine(uint8array, lineIndex);\n      if (line == \"FORMAT=32-bit_rle_rgbe\") {\n        findFormat = true;\n      } else if (line.length == 0) {\n        endOfHeader = true;\n      }\n    } while (!endOfHeader);\n    if (!findFormat) {\n      throw \"HDR Bad header format, unsupported FORMAT\";\n    }\n    lineIndex += line.length + 1;\n    line = this._ReadStringLine(uint8array, lineIndex);\n    const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\n    const match = sizeRegexp.exec(line);\n    // TODO. Support +Y and -X if needed.\n    if (!match || match.length < 3) {\n      throw \"HDR Bad header format, no size\";\n    }\n    width = parseInt(match[2]);\n    height = parseInt(match[1]);\n    if (width < 8 || width > 0x7fff) {\n      throw \"HDR Bad header format, unsupported size\";\n    }\n    lineIndex += line.length + 1;\n    return {\n      height: height,\n      width: width,\n      dataPosition: lineIndex\n    };\n  }\n  /**\n   * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n   * This RGBE texture needs to store the information as a panorama.\n   *\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param buffer The binary file stored in an array buffer.\n   * @param size The expected size of the extracted cubemap.\n   * @returns The Cube Map information.\n   */\n  static GetCubeMapTextureData(buffer, size) {\n    const uint8array = new Uint8Array(buffer);\n    const hdrInfo = this.RGBE_ReadHeader(uint8array);\n    const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\n    const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\n    return cubeMapData;\n  }\n  /**\n   * Returns the pixels data extracted from an RGBE texture.\n   * This pixels will be stored left to right up to down in the R G B order in one array.\n   *\n   * More information on this format are available here:\n   * https://en.wikipedia.org/wiki/RGBE_image_format\n   *\n   * @param uint8array The binary file stored in an array buffer.\n   * @param hdrInfo The header information of the file.\n   * @returns The pixels data in RGB right to left up to down order.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static RGBE_ReadPixels(uint8array, hdrInfo) {\n    return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\n  }\n  static _RGBEReadPixelsRLE(uint8array, hdrInfo) {\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, count;\n    let dataIndex = hdrInfo.dataPosition;\n    let index = 0,\n      endIndex = 0,\n      i = 0;\n    const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n    const scanLineArray = new Uint8Array(scanLineArrayBuffer);\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n      a = uint8array[dataIndex++];\n      b = uint8array[dataIndex++];\n      c = uint8array[dataIndex++];\n      d = uint8array[dataIndex++];\n      if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\n        return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\n      }\n      if ((c << 8 | d) != scanline_width) {\n        throw \"HDR Bad header format, wrong scan line width\";\n      }\n      index = 0;\n      // read each of the four channels for the scanline into the buffer\n      for (i = 0; i < 4; i++) {\n        endIndex = (i + 1) * scanline_width;\n        while (index < endIndex) {\n          a = uint8array[dataIndex++];\n          b = uint8array[dataIndex++];\n          if (a > 128) {\n            // a run of the same value\n            count = a - 128;\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (run)\";\n            }\n            while (count-- > 0) {\n              scanLineArray[index++] = b;\n            }\n          } else {\n            // a non-run\n            count = a;\n            if (count == 0 || count > endIndex - index) {\n              throw \"HDR Bad Format, bad scanline data (non-run)\";\n            }\n            scanLineArray[index++] = b;\n            if (--count > 0) {\n              for (let j = 0; j < count; j++) {\n                scanLineArray[index++] = uint8array[dataIndex++];\n              }\n            }\n          }\n        }\n      }\n      // now convert data from buffer into floats\n      for (i = 0; i < scanline_width; i++) {\n        a = scanLineArray[i];\n        b = scanLineArray[i + scanline_width];\n        c = scanLineArray[i + 2 * scanline_width];\n        d = scanLineArray[i + 3 * scanline_width];\n        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n      num_scanlines--;\n    }\n    return resultArray;\n  }\n  static _RGBEReadPixelsNOTRLE(uint8array, hdrInfo) {\n    // this file is not run length encoded\n    // read values sequentially\n    let num_scanlines = hdrInfo.height;\n    const scanline_width = hdrInfo.width;\n    let a, b, c, d, i;\n    let dataIndex = hdrInfo.dataPosition;\n    // 3 channels of 4 bytes per pixel in float.\n    const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n    const resultArray = new Float32Array(resultBuffer);\n    // read in each successive scanline\n    while (num_scanlines > 0) {\n      for (i = 0; i < hdrInfo.width; i++) {\n        a = uint8array[dataIndex++];\n        b = uint8array[dataIndex++];\n        c = uint8array[dataIndex++];\n        d = uint8array[dataIndex++];\n        this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n      }\n      num_scanlines--;\n    }\n    return resultArray;\n  }\n}","map":{"version":3,"mappings":"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","names":["PanoramaToCubeMapTools","HDRTools","_Ldexp","mantissa","exponent","Math","pow","_Rgbe2float","float32array","red","green","blue","index","_ReadStringLine","uint8array","startIndex","line","character","i","length","String","fromCharCode","RGBE_ReadHeader","height","width","endOfHeader","findFormat","lineIndex","sizeRegexp","match","exec","parseInt","dataPosition","GetCubeMapTextureData","buffer","size","Uint8Array","hdrInfo","data","RGBE_ReadPixels","cubeMapData","ConvertPanoramaToCubemap","_RGBEReadPixelsRLE","num_scanlines","scanline_width","a","b","c","d","count","dataIndex","endIndex","scanLineArrayBuffer","ArrayBuffer","scanLineArray","resultBuffer","resultArray","Float32Array","_RGBEReadPixelsNOTRLE","j"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Misc/HighDynamicRange/hdr.ts"],"sourcesContent":["import type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { PanoramaToCubeMapTools } from \"./panoramaToCubemap\";\r\n\r\n/**\r\n * Header information of HDR texture files.\r\n */\r\nexport interface HDRInfo {\r\n    /**\r\n     * The height of the texture in pixels.\r\n     */\r\n    height: number;\r\n\r\n    /**\r\n     * The width of the texture in pixels.\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * The index of the beginning of the data in the binary file.\r\n     */\r\n    dataPosition: number;\r\n}\r\n\r\n/**\r\n * This groups tools to convert HDR texture to native colors array.\r\n */\r\nexport class HDRTools {\r\n    private static _Ldexp(mantissa: number, exponent: number): number {\r\n        if (exponent > 1023) {\r\n            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\r\n        }\r\n\r\n        if (exponent < -1074) {\r\n            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\r\n        }\r\n\r\n        return mantissa * Math.pow(2, exponent);\r\n    }\r\n\r\n    private static _Rgbe2float(float32array: Float32Array, red: number, green: number, blue: number, exponent: number, index: number) {\r\n        if (exponent > 0) {\r\n            /*nonzero pixel*/\r\n            exponent = this._Ldexp(1.0, exponent - (128 + 8));\r\n\r\n            float32array[index + 0] = red * exponent;\r\n            float32array[index + 1] = green * exponent;\r\n            float32array[index + 2] = blue * exponent;\r\n        } else {\r\n            float32array[index + 0] = 0;\r\n            float32array[index + 1] = 0;\r\n            float32array[index + 2] = 0;\r\n        }\r\n    }\r\n\r\n    private static _ReadStringLine(uint8array: Uint8Array, startIndex: number): string {\r\n        let line = \"\";\r\n        let character = \"\";\r\n\r\n        for (let i = startIndex; i < uint8array.length - startIndex; i++) {\r\n            character = String.fromCharCode(uint8array[i]);\r\n\r\n            if (character == \"\\n\") {\r\n                break;\r\n            }\r\n\r\n            line += character;\r\n        }\r\n\r\n        return line;\r\n    }\r\n\r\n    /**\r\n     * Reads header information from an RGBE texture stored in a native array.\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in  native array.\r\n     * @returns The header information.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadHeader(uint8array: Uint8Array): HDRInfo {\r\n        let height: number = 0;\r\n        let width: number = 0;\r\n\r\n        let line = this._ReadStringLine(uint8array, 0);\r\n        if (line[0] != \"#\" || line[1] != \"?\") {\r\n            throw \"Bad HDR Format.\";\r\n        }\r\n\r\n        let endOfHeader = false;\r\n        let findFormat = false;\r\n        let lineIndex: number = 0;\r\n\r\n        do {\r\n            lineIndex += line.length + 1;\r\n            line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n            if (line == \"FORMAT=32-bit_rle_rgbe\") {\r\n                findFormat = true;\r\n            } else if (line.length == 0) {\r\n                endOfHeader = true;\r\n            }\r\n        } while (!endOfHeader);\r\n\r\n        if (!findFormat) {\r\n            throw \"HDR Bad header format, unsupported FORMAT\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n        line = this._ReadStringLine(uint8array, lineIndex);\r\n\r\n        const sizeRegexp = /^-Y (.*) \\+X (.*)$/g;\r\n        const match = sizeRegexp.exec(line);\r\n\r\n        // TODO. Support +Y and -X if needed.\r\n        if (!match || match.length < 3) {\r\n            throw \"HDR Bad header format, no size\";\r\n        }\r\n        width = parseInt(match[2]);\r\n        height = parseInt(match[1]);\r\n\r\n        if (width < 8 || width > 0x7fff) {\r\n            throw \"HDR Bad header format, unsupported size\";\r\n        }\r\n\r\n        lineIndex += line.length + 1;\r\n\r\n        return {\r\n            height: height,\r\n            width: width,\r\n            dataPosition: lineIndex,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\r\n     * This RGBE texture needs to store the information as a panorama.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param buffer The binary file stored in an array buffer.\r\n     * @param size The expected size of the extracted cubemap.\r\n     * @returns The Cube Map information.\r\n     */\r\n    public static GetCubeMapTextureData(buffer: ArrayBuffer, size: number): CubeMapInfo {\r\n        const uint8array = new Uint8Array(buffer);\r\n        const hdrInfo = this.RGBE_ReadHeader(uint8array);\r\n        const data = this.RGBE_ReadPixels(uint8array, hdrInfo);\r\n\r\n        const cubeMapData = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\r\n\r\n        return cubeMapData;\r\n    }\r\n\r\n    /**\r\n     * Returns the pixels data extracted from an RGBE texture.\r\n     * This pixels will be stored left to right up to down in the R G B order in one array.\r\n     *\r\n     * More information on this format are available here:\r\n     * https://en.wikipedia.org/wiki/RGBE_image_format\r\n     *\r\n     * @param uint8array The binary file stored in an array buffer.\r\n     * @param hdrInfo The header information of the file.\r\n     * @returns The pixels data in RGB right to left up to down order.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static RGBE_ReadPixels(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        return this._RGBEReadPixelsRLE(uint8array, hdrInfo);\r\n    }\r\n\r\n    private static _RGBEReadPixelsRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, count: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n        let index = 0,\r\n            endIndex = 0,\r\n            i = 0;\r\n\r\n        const scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\r\n        const scanLineArray = new Uint8Array(scanLineArrayBuffer);\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            a = uint8array[dataIndex++];\r\n            b = uint8array[dataIndex++];\r\n            c = uint8array[dataIndex++];\r\n            d = uint8array[dataIndex++];\r\n\r\n            if (a != 2 || b != 2 || c & 0x80 || hdrInfo.width < 8 || hdrInfo.width > 32767) {\r\n                return this._RGBEReadPixelsNOTRLE(uint8array, hdrInfo);\r\n            }\r\n\r\n            if (((c << 8) | d) != scanline_width) {\r\n                throw \"HDR Bad header format, wrong scan line width\";\r\n            }\r\n\r\n            index = 0;\r\n\r\n            // read each of the four channels for the scanline into the buffer\r\n            for (i = 0; i < 4; i++) {\r\n                endIndex = (i + 1) * scanline_width;\r\n\r\n                while (index < endIndex) {\r\n                    a = uint8array[dataIndex++];\r\n                    b = uint8array[dataIndex++];\r\n\r\n                    if (a > 128) {\r\n                        // a run of the same value\r\n                        count = a - 128;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (run)\";\r\n                        }\r\n\r\n                        while (count-- > 0) {\r\n                            scanLineArray[index++] = b;\r\n                        }\r\n                    } else {\r\n                        // a non-run\r\n                        count = a;\r\n                        if (count == 0 || count > endIndex - index) {\r\n                            throw \"HDR Bad Format, bad scanline data (non-run)\";\r\n                        }\r\n\r\n                        scanLineArray[index++] = b;\r\n                        if (--count > 0) {\r\n                            for (let j = 0; j < count; j++) {\r\n                                scanLineArray[index++] = uint8array[dataIndex++];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now convert data from buffer into floats\r\n            for (i = 0; i < scanline_width; i++) {\r\n                a = scanLineArray[i];\r\n                b = scanLineArray[i + scanline_width];\r\n                c = scanLineArray[i + 2 * scanline_width];\r\n                d = scanLineArray[i + 3 * scanline_width];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n\r\n    private static _RGBEReadPixelsNOTRLE(uint8array: Uint8Array, hdrInfo: HDRInfo): Float32Array {\r\n        // this file is not run length encoded\r\n        // read values sequentially\r\n\r\n        let num_scanlines = hdrInfo.height;\r\n        const scanline_width = hdrInfo.width;\r\n\r\n        let a: number, b: number, c: number, d: number, i: number;\r\n        let dataIndex = hdrInfo.dataPosition;\r\n\r\n        // 3 channels of 4 bytes per pixel in float.\r\n        const resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\r\n        const resultArray = new Float32Array(resultBuffer);\r\n\r\n        // read in each successive scanline\r\n        while (num_scanlines > 0) {\r\n            for (i = 0; i < hdrInfo.width; i++) {\r\n                a = uint8array[dataIndex++];\r\n                b = uint8array[dataIndex++];\r\n                c = uint8array[dataIndex++];\r\n                d = uint8array[dataIndex++];\r\n\r\n                this._Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\r\n            }\r\n\r\n            num_scanlines--;\r\n        }\r\n\r\n        return resultArray;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}