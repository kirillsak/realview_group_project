{"ast":null,"code":"import { Matrix } from \"../../Maths/math.vector.js\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture.js\";\nimport { RegisterClass } from \"../../Misc/typeStore.js\";\n// Ensures Raw texture are included\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\n/**\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\n * It can help converting any input color in a desired output one. This can then be used to create effects\n * from sepia, black and white to sixties or futuristic rendering...\n *\n * The only supported format is currently 3dl.\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\n */\nexport class ColorGradingTexture extends BaseTexture {\n  /**\n   * Instantiates a ColorGradingTexture from the following parameters.\n   *\n   * @param url The location of the color grading data (currently only supporting 3dl)\n   * @param sceneOrEngine The scene or engine the texture will be used in\n   * @param onLoad defines a callback triggered when the texture has been loaded\n   */\n  constructor(url, sceneOrEngine, onLoad = null) {\n    super(sceneOrEngine);\n    if (!url) {\n      return;\n    }\n    this._textureMatrix = Matrix.Identity();\n    this.name = url;\n    this.url = url;\n    this._onLoad = onLoad;\n    this._texture = this._getFromCache(url, true);\n    if (!this._texture) {\n      const scene = this.getScene();\n      if (scene) {\n        if (!scene.useDelayedTextureLoading) {\n          this._loadTexture();\n        } else {\n          this.delayLoadState = 4;\n        }\n      } else {\n        this._loadTexture();\n      }\n    } else {\n      this._triggerOnLoad();\n    }\n  }\n  /**\n   * Fires the onload event from the constructor if requested.\n   */\n  _triggerOnLoad() {\n    if (this._onLoad) {\n      this._onLoad();\n    }\n  }\n  /**\n   * Returns the texture matrix used in most of the material.\n   * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\n   */\n  getTextureMatrix() {\n    return this._textureMatrix;\n  }\n  /**\n   * Occurs when the file being loaded is a .3dl LUT file.\n   */\n  _load3dlTexture() {\n    const engine = this._getEngine();\n    let texture;\n    if (!engine._features.support3DTextures) {\n      texture = engine.createRawTexture(null, 1, 1, 5, false, false, 2, null, 0);\n    } else {\n      texture = engine.createRawTexture3D(null, 1, 1, 1, 5, false, false, 2, null, 0);\n    }\n    this._texture = texture;\n    this._texture.isReady = false;\n    this.isCube = false;\n    this.is3D = engine._features.support3DTextures;\n    this.wrapU = 0;\n    this.wrapV = 0;\n    this.wrapR = 0;\n    this.anisotropicFilteringLevel = 1;\n    const callback = text => {\n      if (typeof text !== \"string\") {\n        return;\n      }\n      let data = null;\n      let tempData = null;\n      let line;\n      const lines = text.split(\"\\n\");\n      let size = 0,\n        pixelIndexW = 0,\n        pixelIndexH = 0,\n        pixelIndexSlice = 0;\n      let maxColor = 0;\n      for (let i = 0; i < lines.length; i++) {\n        line = lines[i];\n        if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\n          continue;\n        }\n        if (line.indexOf(\"#\") === 0) {\n          continue;\n        }\n        const words = line.split(\" \");\n        if (size === 0) {\n          // Number of space + one\n          size = words.length;\n          data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n          tempData = new Float32Array(size * size * size * 4);\n          continue;\n        }\n        if (size != 0) {\n          const r = Math.max(parseInt(words[0]), 0);\n          const g = Math.max(parseInt(words[1]), 0);\n          const b = Math.max(parseInt(words[2]), 0);\n          maxColor = Math.max(r, maxColor);\n          maxColor = Math.max(g, maxColor);\n          maxColor = Math.max(b, maxColor);\n          const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n          if (tempData) {\n            tempData[pixelStorageIndex + 0] = r;\n            tempData[pixelStorageIndex + 1] = g;\n            tempData[pixelStorageIndex + 2] = b;\n          }\n          // Keep for reference in case of back compat problems.\n          // pixelIndexSlice++;\n          // if (pixelIndexSlice % size == 0) {\n          //     pixelIndexH++;\n          //     pixelIndexSlice = 0;\n          //     if (pixelIndexH % size == 0) {\n          //         pixelIndexW++;\n          //         pixelIndexH = 0;\n          //     }\n          // }\n          pixelIndexH++;\n          if (pixelIndexH % size == 0) {\n            pixelIndexSlice++;\n            pixelIndexH = 0;\n            if (pixelIndexSlice % size == 0) {\n              pixelIndexW++;\n              pixelIndexSlice = 0;\n            }\n          }\n        }\n      }\n      if (tempData && data) {\n        for (let i = 0; i < tempData.length; i++) {\n          if (i > 0 && (i + 1) % 4 === 0) {\n            data[i] = 255;\n          } else {\n            const value = tempData[i];\n            data[i] = value / maxColor * 255;\n          }\n        }\n      }\n      if (texture.is3D) {\n        texture.updateSize(size, size, size);\n        engine.updateRawTexture3D(texture, data, 5, false);\n      } else {\n        texture.updateSize(size * size, size);\n        engine.updateRawTexture(texture, data, 5, false);\n      }\n      texture.isReady = true;\n      this._triggerOnLoad();\n    };\n    const scene = this.getScene();\n    if (scene) {\n      scene._loadFile(this.url, callback);\n    } else {\n      engine._loadFile(this.url, callback);\n    }\n    return this._texture;\n  }\n  /**\n   * Starts the loading process of the texture.\n   */\n  _loadTexture() {\n    if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\n      this._load3dlTexture();\n    }\n  }\n  /**\n   * Clones the color grading texture.\n   */\n  clone() {\n    const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine());\n    // Base texture\n    newTexture.level = this.level;\n    return newTexture;\n  }\n  /**\n   * Called during delayed load for textures.\n   */\n  delayLoad() {\n    if (this.delayLoadState !== 4) {\n      return;\n    }\n    this.delayLoadState = 1;\n    this._texture = this._getFromCache(this.url, true);\n    if (!this._texture) {\n      this._loadTexture();\n    }\n  }\n  /**\n   * Parses a color grading texture serialized by Babylon.\n   * @param parsedTexture The texture information being parsedTexture\n   * @param scene The scene to load the texture in\n   * @returns A color grading texture\n   */\n  static Parse(parsedTexture, scene) {\n    let texture = null;\n    if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n      texture = new ColorGradingTexture(parsedTexture.name, scene);\n      texture.name = parsedTexture.name;\n      texture.level = parsedTexture.level;\n    }\n    return texture;\n  }\n  /**\n   * Serializes the LUT texture to json format.\n   */\n  serialize() {\n    if (!this.name) {\n      return null;\n    }\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.level = this.level;\n    serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n    return serializationObject;\n  }\n}\n/**\n * Empty line regex stored for GC.\n */\nColorGradingTexture._NoneEmptyLineRegex = /\\S+/;\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);","map":{"version":3,"mappings":"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","names":["Matrix","BaseTexture","RegisterClass","ColorGradingTexture","constructor","url","sceneOrEngine","onLoad","_textureMatrix","Identity","name","_onLoad","_texture","_getFromCache","scene","getScene","useDelayedTextureLoading","_loadTexture","delayLoadState","_triggerOnLoad","getTextureMatrix","_load3dlTexture","engine","_getEngine","texture","_features","support3DTextures","createRawTexture","createRawTexture3D","isReady","isCube","is3D","wrapU","wrapV","wrapR","anisotropicFilteringLevel","callback","text","data","tempData","line","lines","split","size","pixelIndexW","pixelIndexH","pixelIndexSlice","maxColor","i","length","_NoneEmptyLineRegex","test","indexOf","words","Uint8Array","Float32Array","r","Math","max","parseInt","g","b","pixelStorageIndex","value","updateSize","updateRawTexture3D","updateRawTexture","_loadFile","toLocaleLowerCase","clone","newTexture","level","delayLoad","Parse","parsedTexture","isRenderTarget","serialize","serializationObject","customType"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/colorGradingTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\n\r\n// Ensures Raw texture are included\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\n\r\n/**\r\n * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\r\n * It can help converting any input color in a desired output one. This can then be used to create effects\r\n * from sepia, black and white to sixties or futuristic rendering...\r\n *\r\n * The only supported format is currently 3dl.\r\n * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table\r\n */\r\nexport class ColorGradingTexture extends BaseTexture {\r\n    /**\r\n     * The texture URL.\r\n     */\r\n    public url: string;\r\n\r\n    /**\r\n     * Empty line regex stored for GC.\r\n     */\r\n    private static _NoneEmptyLineRegex = /\\S+/;\r\n\r\n    private _textureMatrix: Matrix;\r\n    private _onLoad: Nullable<() => void>;\r\n\r\n    /**\r\n     * Instantiates a ColorGradingTexture from the following parameters.\r\n     *\r\n     * @param url The location of the color grading data (currently only supporting 3dl)\r\n     * @param sceneOrEngine The scene or engine the texture will be used in\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     */\r\n    constructor(url: string, sceneOrEngine: Scene | ThinEngine, onLoad: Nullable<() => void> = null) {\r\n        super(sceneOrEngine);\r\n\r\n        if (!url) {\r\n            return;\r\n        }\r\n\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.name = url;\r\n        this.url = url;\r\n        this._onLoad = onLoad;\r\n\r\n        this._texture = this._getFromCache(url, true);\r\n\r\n        if (!this._texture) {\r\n            const scene = this.getScene();\r\n            if (scene) {\r\n                if (!scene.useDelayedTextureLoading) {\r\n                    this._loadTexture();\r\n                } else {\r\n                    this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n                }\r\n            } else {\r\n                this._loadTexture();\r\n            }\r\n        } else {\r\n            this._triggerOnLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fires the onload event from the constructor if requested.\r\n     */\r\n    private _triggerOnLoad(): void {\r\n        if (this._onLoad) {\r\n            this._onLoad();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture matrix used in most of the material.\r\n     * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Occurs when the file being loaded is a .3dl LUT file.\r\n     */\r\n    private _load3dlTexture() {\r\n        const engine = this._getEngine()!;\r\n        let texture: InternalTexture;\r\n        if (!engine._features.support3DTextures) {\r\n            texture = engine.createRawTexture(\r\n                null,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                null,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n        } else {\r\n            texture = engine.createRawTexture3D(\r\n                null,\r\n                1,\r\n                1,\r\n                1,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n                null,\r\n                Constants.TEXTURETYPE_UNSIGNED_INT\r\n            );\r\n        }\r\n\r\n        this._texture = texture;\r\n        this._texture.isReady = false;\r\n\r\n        this.isCube = false;\r\n        this.is3D = engine._features.support3DTextures;\r\n        this.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.wrapR = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        this.anisotropicFilteringLevel = 1;\r\n\r\n        const callback = (text: string | ArrayBuffer) => {\r\n            if (typeof text !== \"string\") {\r\n                return;\r\n            }\r\n\r\n            let data: Nullable<Uint8Array> = null;\r\n            let tempData: Nullable<Float32Array> = null;\r\n\r\n            let line: string;\r\n            const lines = text.split(\"\\n\");\r\n            let size = 0,\r\n                pixelIndexW = 0,\r\n                pixelIndexH = 0,\r\n                pixelIndexSlice = 0;\r\n            let maxColor = 0;\r\n\r\n            for (let i = 0; i < lines.length; i++) {\r\n                line = lines[i];\r\n\r\n                if (!ColorGradingTexture._NoneEmptyLineRegex.test(line)) {\r\n                    continue;\r\n                }\r\n\r\n                if (line.indexOf(\"#\") === 0) {\r\n                    continue;\r\n                }\r\n\r\n                const words = line.split(\" \");\r\n                if (size === 0) {\r\n                    // Number of space + one\r\n                    size = words.length;\r\n                    data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\r\n                    tempData = new Float32Array(size * size * size * 4);\r\n                    continue;\r\n                }\r\n\r\n                if (size != 0) {\r\n                    const r = Math.max(parseInt(words[0]), 0);\r\n                    const g = Math.max(parseInt(words[1]), 0);\r\n                    const b = Math.max(parseInt(words[2]), 0);\r\n\r\n                    maxColor = Math.max(r, maxColor);\r\n                    maxColor = Math.max(g, maxColor);\r\n                    maxColor = Math.max(b, maxColor);\r\n\r\n                    const pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\r\n\r\n                    if (tempData) {\r\n                        tempData[pixelStorageIndex + 0] = r;\r\n                        tempData[pixelStorageIndex + 1] = g;\r\n                        tempData[pixelStorageIndex + 2] = b;\r\n                    }\r\n\r\n                    // Keep for reference in case of back compat problems.\r\n                    // pixelIndexSlice++;\r\n                    // if (pixelIndexSlice % size == 0) {\r\n                    //     pixelIndexH++;\r\n                    //     pixelIndexSlice = 0;\r\n                    //     if (pixelIndexH % size == 0) {\r\n                    //         pixelIndexW++;\r\n                    //         pixelIndexH = 0;\r\n                    //     }\r\n                    // }\r\n\r\n                    pixelIndexH++;\r\n                    if (pixelIndexH % size == 0) {\r\n                        pixelIndexSlice++;\r\n                        pixelIndexH = 0;\r\n                        if (pixelIndexSlice % size == 0) {\r\n                            pixelIndexW++;\r\n                            pixelIndexSlice = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (tempData && data) {\r\n                for (let i = 0; i < tempData.length; i++) {\r\n                    if (i > 0 && (i + 1) % 4 === 0) {\r\n                        data[i] = 255;\r\n                    } else {\r\n                        const value = tempData[i];\r\n                        data[i] = (value / maxColor) * 255;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (texture.is3D) {\r\n                texture.updateSize(size, size, size);\r\n                engine.updateRawTexture3D(texture, data, Constants.TEXTUREFORMAT_RGBA, false);\r\n            } else {\r\n                texture.updateSize(size * size, size);\r\n                engine.updateRawTexture(texture, data, Constants.TEXTUREFORMAT_RGBA, false);\r\n            }\r\n\r\n            texture.isReady = true;\r\n            this._triggerOnLoad();\r\n        };\r\n\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene._loadFile(this.url, callback);\r\n        } else {\r\n            engine._loadFile(this.url, callback);\r\n        }\r\n\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Starts the loading process of the texture.\r\n     */\r\n    private _loadTexture() {\r\n        if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == this.url.length - 4) {\r\n            this._load3dlTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the color grading texture.\r\n     */\r\n    public clone(): ColorGradingTexture {\r\n        const newTexture = new ColorGradingTexture(this.url, this.getScene() || this._getEngine()!);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Called during delayed load for textures.\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, true);\r\n\r\n        if (!this._texture) {\r\n            this._loadTexture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses a color grading texture serialized by Babylon.\r\n     * @param parsedTexture The texture information being parsedTexture\r\n     * @param scene The scene to load the texture in\r\n     * @returns A color grading texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): Nullable<ColorGradingTexture> {\r\n        let texture = null;\r\n        if (parsedTexture.name && !parsedTexture.isRenderTarget) {\r\n            texture = new ColorGradingTexture(parsedTexture.name, scene);\r\n            texture.name = parsedTexture.name;\r\n            texture.level = parsedTexture.level;\r\n        }\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the LUT texture to json format.\r\n     */\r\n    public serialize(): any {\r\n        if (!this.name) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject: any = {};\r\n        serializationObject.name = this.name;\r\n        serializationObject.level = this.level;\r\n        serializationObject.customType = \"BABYLON.ColorGradingTexture\";\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ColorGradingTexture\", ColorGradingTexture);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}