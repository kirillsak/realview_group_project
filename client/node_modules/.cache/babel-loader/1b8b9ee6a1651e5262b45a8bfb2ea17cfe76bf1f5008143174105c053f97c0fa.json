{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Logger } from \"../Misc/logger.js\";\nMesh.prototype.thinInstanceAdd = function (matrix, refresh = true) {\n  if (!this.getScene().getEngine().getCaps().instancedArrays) {\n    Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\n    return -1;\n  }\n  this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n  const index = this._thinInstanceDataStorage.instancesCount;\n  if (Array.isArray(matrix)) {\n    for (let i = 0; i < matrix.length; ++i) {\n      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n    }\n  } else {\n    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n  }\n  return index;\n};\nMesh.prototype.thinInstanceAddSelf = function (refresh = true) {\n  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  this.removeVerticesData(kind);\n  this._thinInstanceInitializeUserStorage();\n  this._userThinInstanceBuffersStorage.strides[kind] = stride;\n  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh = true) {\n  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n  const matrixData = this._thinInstanceDataStorage.matrixData;\n  matrix.copyToArray(matrixData, index * 16);\n  if (this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n  }\n  if (refresh) {\n    this.thinInstanceBufferUpdated(\"matrix\");\n    if (!this.doNotSyncBoundingInfo) {\n      this.thinInstanceRefreshBoundingInfo(false);\n    }\n  }\n  return true;\n};\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh = true) {\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n    return false;\n  }\n  this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n  if (refresh) {\n    this.thinInstanceBufferUpdated(kind);\n  }\n  return true;\n};\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n  get: function () {\n    return this._thinInstanceDataStorage.instancesCount;\n  },\n  set: function (value) {\n    var _a, _b;\n    const matrixData = (_a = this._thinInstanceDataStorage.matrixData) !== null && _a !== void 0 ? _a : (_b = this.source) === null || _b === void 0 ? void 0 : _b._thinInstanceDataStorage.matrixData;\n    const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\n    if (value <= numMaxInstances) {\n      this._thinInstanceDataStorage.instancesCount = value;\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind, buffer, staticBuffer = false) {\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\n  for (let i = 0; i < 4; i++) {\n    this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\n  }\n  return matrixBuffer;\n};\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride = 0, staticBuffer = false) {\n  var _a, _b, _c;\n  stride = stride || 16;\n  if (kind === \"matrix\") {\n    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n    this._thinInstanceDataStorage.matrixData = buffer;\n    this._thinInstanceDataStorage.worldMatrices = null;\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    } else {\n      this._thinInstanceDataStorage.instancesCount = 0;\n      if (!this.doNotSyncBoundingInfo) {\n        // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n        this.refreshBoundingInfo();\n      }\n    }\n  } else if (kind === \"previousMatrix\") {\n    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._thinInstanceDataStorage.previousMatrixBuffer = null;\n    this._thinInstanceDataStorage.previousMatrixData = buffer;\n    if (buffer !== null) {\n      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\n    }\n  } else {\n    // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\n    // hot switching kind here to preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    if (buffer === null) {\n      if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.data[kind]) {\n        this.removeVerticesData(kind);\n        delete this._userThinInstanceBuffersStorage.data[kind];\n        delete this._userThinInstanceBuffersStorage.strides[kind];\n        delete this._userThinInstanceBuffersStorage.sizes[kind];\n        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n      }\n    } else {\n      this._thinInstanceInitializeUserStorage();\n      this._userThinInstanceBuffersStorage.data[kind] = buffer;\n      this._userThinInstanceBuffersStorage.strides[kind] = stride;\n      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n  var _a, _b, _c;\n  if (kind === \"matrix\") {\n    (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n  } else if (kind === \"previousMatrix\") {\n    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);\n  } else {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.vertexBuffers[kind]) {\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n    }\n  }\n};\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n  var _a;\n  if (kind === \"matrix\") {\n    if (this._thinInstanceDataStorage.matrixBuffer) {\n      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n    }\n  } else {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n      kind = VertexBuffer.ColorInstanceKind;\n    }\n    if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n    }\n  }\n};\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return [];\n  }\n  const matrixData = this._thinInstanceDataStorage.matrixData;\n  if (!this._thinInstanceDataStorage.worldMatrices) {\n    this._thinInstanceDataStorage.worldMatrices = new Array();\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n    }\n  }\n  return this._thinInstanceDataStorage.worldMatrices;\n};\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {\n  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n    return;\n  }\n  const vectors = this._thinInstanceDataStorage.boundingVectors;\n  if (forceRefreshParentInfo) {\n    vectors.length = 0;\n    this.refreshBoundingInfo(applySkeleton, applyMorph);\n  }\n  const boundingInfo = this.getBoundingInfo();\n  const matrixData = this._thinInstanceDataStorage.matrixData;\n  if (vectors.length === 0) {\n    for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n      vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n    }\n  }\n  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n  for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n    for (let v = 0; v < vectors.length; ++v) {\n      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n    }\n  }\n  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n  this._updateBoundingInfo();\n};\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances = 1) {\n  var _a, _b, _c;\n  // preserve backward compatibility\n  if (kind === VertexBuffer.ColorKind) {\n    kind = VertexBuffer.ColorInstanceKind;\n  }\n  const kindIsMatrix = kind === \"matrix\";\n  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n    return;\n  }\n  const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n  const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n  let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n  const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n  let newSize = currentSize;\n  while (newSize < bufferSize) {\n    newSize *= 2;\n  }\n  if (!data || currentSize != newSize) {\n    if (!data) {\n      data = new Float32Array(newSize);\n    } else {\n      const newData = new Float32Array(newSize);\n      newData.set(data, 0);\n      data = newData;\n    }\n    if (kindIsMatrix) {\n      (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();\n      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\n      this._thinInstanceDataStorage.matrixData = data;\n      this._thinInstanceDataStorage.matrixBufferSize = newSize;\n      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\n        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\n      }\n    } else {\n      (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _c === void 0 ? void 0 : _c.dispose();\n      this._userThinInstanceBuffersStorage.data[kind] = data;\n      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n  }\n};\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n  if (!this._userThinInstanceBuffersStorage) {\n    this._userThinInstanceBuffersStorage = {\n      data: {},\n      sizes: {},\n      vertexBuffers: {},\n      strides: {}\n    };\n  }\n};\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n  var _a;\n  if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {\n    this._thinInstanceDataStorage.matrixBuffer.dispose();\n    this._thinInstanceDataStorage.matrixBuffer = null;\n  }\n};","map":{"version":3,"mappings":"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","names":["Mesh","VertexBuffer","Buffer","Matrix","Vector3","TmpVectors","Logger","prototype","thinInstanceAdd","matrix","refresh","getScene","getEngine","getCaps","instancedArrays","Error","_thinInstanceUpdateBufferSize","Array","isArray","length","index","_thinInstanceDataStorage","instancesCount","i","thinInstanceSetMatrixAt","thinInstanceAddSelf","IdentityReadOnly","thinInstanceRegisterAttribute","kind","stride","ColorKind","ColorInstanceKind","removeVerticesData","_thinInstanceInitializeUserStorage","_userThinInstanceBuffersStorage","strides","sizes","Math","max","data","Float32Array","vertexBuffers","setVerticesBuffer","matrixData","copyToArray","worldMatrices","thinInstanceBufferUpdated","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","thinInstanceSetAttributeAt","value","set","Object","defineProperty","get","source","numMaxInstances","enumerable","configurable","_thinInstanceCreateMatrixBuffer","buffer","staticBuffer","matrixBuffer","createVertexBuffer","thinInstanceSetBuffer","dispose","matrixBufferSize","refreshBoundingInfo","previousMatrixBuffer","previousMatrixData","updateDirectly","thinInstancePartialBufferUpdate","offset","thinInstanceGetWorldMatrices","FromArray","forceRefreshParentInfo","applySkeleton","applyMorph","vectors","boundingVectors","boundingInfo","getBoundingInfo","v","boundingBox","push","clone","setAll","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","FromArrayToRef","TransformCoordinatesToRef","minimizeInPlace","maximizeInPlace","reConstruct","_updateBoundingInfo","numInstances","kindIsMatrix","currentSize","bufferSize","newSize","newData","_scene","needsPreviousWorldMatrices","_disposeThinInstanceSpecificData"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/thinInstanceMesh.ts"],"sourcesContent":["import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - false by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @returns an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @internal */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\r\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\r\n        return -1;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\r\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = false): Buffer {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = false): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = new Array<Matrix>();\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}