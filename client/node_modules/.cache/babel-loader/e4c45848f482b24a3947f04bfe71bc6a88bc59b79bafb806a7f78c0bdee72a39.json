{"ast":null,"code":"import { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\n/**\n * block used to Generate a Voronoi Noise Pattern\n */\nexport class VoronoiNoiseBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new VoronoiNoiseBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.Vector2);\n    this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerInput(\"density\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"cells\", NodeMaterialBlockConnectionPointTypes.Float);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"VoronoiNoiseBlock\";\n  }\n  /**\n   * Gets the seed input component\n   */\n  get seed() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the offset input component\n   */\n  get offset() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the density input component\n   */\n  get density() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the output component\n   */\n  get output() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the output component\n   */\n  get cells() {\n    return this._outputs[1];\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (!this.seed.isConnected) {\n      return;\n    }\n    let functionString = `vec2 voronoiRandom(vec2 seed, float offset){\n            mat2 m = mat2(15.27, 47.63, 99.41, 89.98);\n            vec2 uv = fract(sin(m * seed) * 46839.32);\n            return vec2(sin(uv.y * offset) * 0.5 + 0.5, cos(uv.x * offset) * 0.5 + 0.5);\n        }\n        `;\n    state._emitFunction(\"voronoiRandom\", functionString, \"// Voronoi random generator\");\n    functionString = `void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){\n            vec2 g = floor(seed * density);\n            vec2 f = fract(seed * density);\n            float t = 8.0;\n            vec3 res = vec3(8.0, 0.0, 0.0);\n\n            for(int y=-1; y<=1; y++)\n            {\n                for(int x=-1; x<=1; x++)\n                {\n                    vec2 lattice = vec2(x,y);\n                    vec2 randomOffset = voronoiRandom(lattice + g, offset);\n                    float d = distance(lattice + randomOffset, f);\n                    if(d < res.x)\n                    {\n                        res = vec3(d, randomOffset.x, randomOffset.y);\n                        outValue = res.x;\n                        cells = res.y;\n                    }\n                }\n            }\n        }\n        `;\n    state._emitFunction(\"voronoi\", functionString, \"// Voronoi\");\n    const tempOutput = state._getFreeVariableName(\"tempOutput\");\n    const tempCells = state._getFreeVariableName(\"tempCells\");\n    state.compilationString += `float ${tempOutput} = 0.0;\\r\\n`;\n    state.compilationString += `float ${tempCells} = 0.0;\\r\\n`;\n    state.compilationString += `voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${tempOutput}, ${tempCells});\\r\\n`;\n    if (this.output.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.output, state) + ` = ${tempOutput};\\r\\n`;\n    }\n    if (this.cells.hasEndpoints) {\n      state.compilationString += this._declareOutput(this.cells, state) + ` = ${tempCells};\\r\\n`;\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.VoronoiNoiseBlock\", VoronoiNoiseBlock);","map":{"version":3,"mappings":"AAAA,SAASA,iBAAiB,QAAQ,yBAAuB;AACzD,SAASC,qCAAqC,QAAQ,mDAAiD;AAGvG,SAASC,wBAAwB,QAAQ,sCAAoC;AAC7E,SAASC,aAAa,QAAQ,4BAA0B;AAExD;;;AAGA,OAAM,MAAOC,iBAAkB,SAAQJ,iBAAiB;EACpD;;;;EAIAK,YAAmBC,IAAY;IAC3B,KAAK,CAACA,IAAI,EAAEJ,wBAAwB,CAACK,OAAO,CAAC;IAC7C,IAAI,CAACC,aAAa,CAAC,MAAM,EAAEP,qCAAqC,CAACQ,OAAO,CAAC;IACzE,IAAI,CAACD,aAAa,CAAC,QAAQ,EAAEP,qCAAqC,CAACS,KAAK,CAAC;IACzE,IAAI,CAACF,aAAa,CAAC,SAAS,EAAEP,qCAAqC,CAACS,KAAK,CAAC;IAE1E,IAAI,CAACC,cAAc,CAAC,QAAQ,EAAEV,qCAAqC,CAACS,KAAK,CAAC;IAC1E,IAAI,CAACC,cAAc,CAAC,OAAO,EAAEV,qCAAqC,CAACS,KAAK,CAAC;EAC7E;EAEA;;;;EAIOE,YAAY;IACf,OAAO,mBAAmB;EAC9B;EAEA;;;EAGA,IAAWC,IAAI;IACX,OAAO,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWC,MAAM;IACb,OAAO,IAAI,CAACD,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWE,OAAO;IACd,OAAO,IAAI,CAACF,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWG,MAAM;IACb,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWC,KAAK;IACZ,OAAO,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEUE,WAAW,CAACC,KAA6B;IAC/C,KAAK,CAACD,WAAW,CAACC,KAAK,CAAC;IAExB,IAAI,CAAC,IAAI,CAACR,IAAI,CAACS,WAAW,EAAE;MACxB;;IAGJ,IAAIC,cAAc,GAAG;;;;;SAKpB;IAEDF,KAAK,CAACG,aAAa,CAAC,eAAe,EAAED,cAAc,EAAE,6BAA6B,CAAC;IAEnFA,cAAc,GAAG;;;;;;;;;;;;;;;;;;;;;;SAsBhB;IAEDF,KAAK,CAACG,aAAa,CAAC,SAAS,EAAED,cAAc,EAAE,YAAY,CAAC;IAE5D,MAAME,UAAU,GAAGJ,KAAK,CAACK,oBAAoB,CAAC,YAAY,CAAC;IAC3D,MAAMC,SAAS,GAAGN,KAAK,CAACK,oBAAoB,CAAC,WAAW,CAAC;IAEzDL,KAAK,CAACO,iBAAiB,IAAI,SAASH,UAAU,aAAa;IAC3DJ,KAAK,CAACO,iBAAiB,IAAI,SAASD,SAAS,aAAa;IAC1DN,KAAK,CAACO,iBAAiB,IAAI,WAAW,IAAI,CAACf,IAAI,CAACgB,sBAAsB,KAAK,IAAI,CAACd,MAAM,CAACc,sBAAsB,KAAK,IAAI,CAACb,OAAO,CAACa,sBAAsB,KAAKJ,UAAU,KAAKE,SAAS,QAAQ;IAE1L,IAAI,IAAI,CAACV,MAAM,CAACa,YAAY,EAAE;MAC1BT,KAAK,CAACO,iBAAiB,IAAI,IAAI,CAACG,cAAc,CAAC,IAAI,CAACd,MAAM,EAAEI,KAAK,CAAC,GAAG,MAAMI,UAAU,OAAO;;IAGhG,IAAI,IAAI,CAACN,KAAK,CAACW,YAAY,EAAE;MACzBT,KAAK,CAACO,iBAAiB,IAAI,IAAI,CAACG,cAAc,CAAC,IAAI,CAACZ,KAAK,EAAEE,KAAK,CAAC,GAAG,MAAMM,SAAS,OAAO;;IAG9F,OAAO,IAAI;EACf;;AAGJxB,aAAa,CAAC,2BAA2B,EAAEC,iBAAiB,CAAC","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","VoronoiNoiseBlock","constructor","name","Neutral","registerInput","Vector2","Float","registerOutput","getClassName","seed","_inputs","offset","density","output","_outputs","cells","_buildBlock","state","isConnected","functionString","_emitFunction","tempOutput","_getFreeVariableName","tempCells","compilationString","associatedVariableName","hasEndpoints","_declareOutput"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Node/Blocks/voronoiNoiseBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\n/**\r\n * block used to Generate a Voronoi Noise Pattern\r\n */\r\nexport class VoronoiNoiseBlock extends NodeMaterialBlock {\r\n    /**\r\n     * Creates a new VoronoiNoiseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n        this.registerInput(\"seed\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n        this.registerInput(\"offset\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerInput(\"density\", NodeMaterialBlockConnectionPointTypes.Float);\r\n\r\n        this.registerOutput(\"output\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"cells\", NodeMaterialBlockConnectionPointTypes.Float);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"VoronoiNoiseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the seed input component\r\n     */\r\n    public get seed(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the offset input component\r\n     */\r\n    public get offset(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the density input component\r\n     */\r\n    public get density(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get output(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the output component\r\n     */\r\n    public get cells(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (!this.seed.isConnected) {\r\n            return;\r\n        }\r\n\r\n        let functionString = `vec2 voronoiRandom(vec2 seed, float offset){\r\n            mat2 m = mat2(15.27, 47.63, 99.41, 89.98);\r\n            vec2 uv = fract(sin(m * seed) * 46839.32);\r\n            return vec2(sin(uv.y * offset) * 0.5 + 0.5, cos(uv.x * offset) * 0.5 + 0.5);\r\n        }\r\n        `;\r\n\r\n        state._emitFunction(\"voronoiRandom\", functionString, \"// Voronoi random generator\");\r\n\r\n        functionString = `void voronoi(vec2 seed, float offset, float density, out float outValue, out float cells){\r\n            vec2 g = floor(seed * density);\r\n            vec2 f = fract(seed * density);\r\n            float t = 8.0;\r\n            vec3 res = vec3(8.0, 0.0, 0.0);\r\n\r\n            for(int y=-1; y<=1; y++)\r\n            {\r\n                for(int x=-1; x<=1; x++)\r\n                {\r\n                    vec2 lattice = vec2(x,y);\r\n                    vec2 randomOffset = voronoiRandom(lattice + g, offset);\r\n                    float d = distance(lattice + randomOffset, f);\r\n                    if(d < res.x)\r\n                    {\r\n                        res = vec3(d, randomOffset.x, randomOffset.y);\r\n                        outValue = res.x;\r\n                        cells = res.y;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        `;\r\n\r\n        state._emitFunction(\"voronoi\", functionString, \"// Voronoi\");\r\n\r\n        const tempOutput = state._getFreeVariableName(\"tempOutput\");\r\n        const tempCells = state._getFreeVariableName(\"tempCells\");\r\n\r\n        state.compilationString += `float ${tempOutput} = 0.0;\\r\\n`;\r\n        state.compilationString += `float ${tempCells} = 0.0;\\r\\n`;\r\n        state.compilationString += `voronoi(${this.seed.associatedVariableName}, ${this.offset.associatedVariableName}, ${this.density.associatedVariableName}, ${tempOutput}, ${tempCells});\\r\\n`;\r\n\r\n        if (this.output.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(this.output, state) + ` = ${tempOutput};\\r\\n`;\r\n        }\r\n\r\n        if (this.cells.hasEndpoints) {\r\n            state.compilationString += this._declareOutput(this.cells, state) + ` = ${tempCells};\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.VoronoiNoiseBlock\", VoronoiNoiseBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}