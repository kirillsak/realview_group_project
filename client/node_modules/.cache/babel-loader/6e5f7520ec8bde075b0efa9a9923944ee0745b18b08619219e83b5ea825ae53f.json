{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Bone } from \"./bone.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector.js\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Animation } from \"../Animations/animation.js\";\nimport { AnimationRange } from \"../Animations/animationRange.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n  /**\n   * Creates a new skeleton\n   * @param name defines the skeleton name\n   * @param id defines the skeleton Id\n   * @param scene defines the hosting scene\n   */\n  constructor( /** defines the skeleton name */\n  name, /** defines the skeleton Id */\n  id, scene) {\n    this.name = name;\n    this.id = id;\n    /**\n     * Defines the list of child bones\n     */\n    this.bones = new Array();\n    /**\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n     */\n    this.needInitialSkinMatrix = false;\n    this._isDirty = true;\n    this._meshesWithPoseMatrix = new Array();\n    this._identity = Matrix.Identity();\n    this._ranges = {};\n    this._absoluteTransformIsDirty = true;\n    this._canUseTextureForBones = false;\n    this._uniqueId = 0;\n    /** @internal */\n    this._numBonesWithLinkedTransformNode = 0;\n    /** @internal */\n    this._hasWaitingData = null;\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * Specifies if the skeleton should be serialized\n     */\n    this.doNotSerialize = false;\n    this._useTextureToStoreBoneMatrices = true;\n    this._animationPropertiesOverride = null;\n    // Events\n    /**\n     * An observable triggered before computing the skeleton's matrices\n     */\n    this.onBeforeComputeObservable = new Observable();\n    this.bones = [];\n    this._scene = scene || EngineStore.LastCreatedScene;\n    this._uniqueId = this._scene.getUniqueId();\n    this._scene.addSkeleton(this);\n    //make sure it will recalculate the matrix next time prepare is called.\n    this._isDirty = true;\n    const engineCaps = this._scene.getEngine().getCaps();\n    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n  }\n  /**\n   * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n   * Please note that this option is not available if the hardware does not support it\n   */\n  get useTextureToStoreBoneMatrices() {\n    return this._useTextureToStoreBoneMatrices;\n  }\n  set useTextureToStoreBoneMatrices(value) {\n    this._useTextureToStoreBoneMatrices = value;\n    this._markAsDirty();\n  }\n  /**\n   * Gets or sets the animation properties override\n   */\n  get animationPropertiesOverride() {\n    if (!this._animationPropertiesOverride) {\n      return this._scene.animationPropertiesOverride;\n    }\n    return this._animationPropertiesOverride;\n  }\n  set animationPropertiesOverride(value) {\n    this._animationPropertiesOverride = value;\n  }\n  /**\n   * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n   */\n  get isUsingTextureForMatrices() {\n    return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n  }\n  /**\n   * Gets the unique ID of this skeleton\n   */\n  get uniqueId() {\n    return this._uniqueId;\n  }\n  /**\n   * Gets the current object class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"Skeleton\";\n  }\n  /**\n   * Returns an array containing the root bones\n   * @returns an array containing the root bones\n   */\n  getChildren() {\n    return this.bones.filter(b => !b.getParent());\n  }\n  // Members\n  /**\n   * Gets the list of transform matrices to send to shaders (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a Float32Array containing matrices data\n   */\n  getTransformMatrices(mesh) {\n    if (this.needInitialSkinMatrix) {\n      if (!mesh._bonesTransformMatrices) {\n        this.prepare();\n      }\n      return mesh._bonesTransformMatrices;\n    }\n    if (!this._transformMatrices) {\n      this.prepare();\n    }\n    return this._transformMatrices;\n  }\n  /**\n   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n   * @returns a raw texture containing the data\n   */\n  getTransformMatrixTexture(mesh) {\n    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n      return mesh._transformMatrixTexture;\n    }\n    return this._transformMatrixTexture;\n  }\n  /**\n   * Gets the current hosting scene\n   * @returns a scene object\n   */\n  getScene() {\n    return this._scene;\n  }\n  // Methods\n  /**\n   * Gets a string representing the current skeleton data\n   * @param fullDetails defines a boolean indicating if we want a verbose version\n   * @returns a string representing the current skeleton data\n   */\n  toString(fullDetails) {\n    let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n    ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n    if (fullDetails) {\n      ret += \", Ranges: {\";\n      let first = true;\n      for (const name in this._ranges) {\n        if (first) {\n          ret += \", \";\n          first = false;\n        }\n        ret += name;\n      }\n      ret += \"}\";\n    }\n    return ret;\n  }\n  /**\n   * Get bone's index searching by name\n   * @param name defines bone's name to search for\n   * @returns the indice of the bone. Returns -1 if not found\n   */\n  getBoneIndexByName(name) {\n    for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n      if (this.bones[boneIndex].name === name) {\n        return boneIndex;\n      }\n    }\n    return -1;\n  }\n  /**\n   * Create a new animation range\n   * @param name defines the name of the range\n   * @param from defines the start key\n   * @param to defines the end key\n   */\n  createAnimationRange(name, from, to) {\n    // check name not already in use\n    if (!this._ranges[name]) {\n      this._ranges[name] = new AnimationRange(name, from, to);\n      for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n        if (this.bones[i].animations[0]) {\n          this.bones[i].animations[0].createRange(name, from, to);\n        }\n      }\n    }\n  }\n  /**\n   * Delete a specific animation range\n   * @param name defines the name of the range\n   * @param deleteFrames defines if frames must be removed as well\n   */\n  deleteAnimationRange(name, deleteFrames = true) {\n    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        this.bones[i].animations[0].deleteRange(name, deleteFrames);\n      }\n    }\n    this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n  }\n  /**\n   * Gets a specific animation range\n   * @param name defines the name of the range to look for\n   * @returns the requested animation range or null if not found\n   */\n  getAnimationRange(name) {\n    return this._ranges[name] || null;\n  }\n  /**\n   * Gets the list of all animation ranges defined on this skeleton\n   * @returns an array\n   */\n  getAnimationRanges() {\n    const animationRanges = [];\n    let name;\n    for (name in this._ranges) {\n      animationRanges.push(this._ranges[name]);\n    }\n    return animationRanges;\n  }\n  /**\n   * Copy animation range from a source skeleton.\n   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n   * @param source defines the source skeleton\n   * @param name defines the name of the range to copy\n   * @param rescaleAsRequired defines if rescaling must be applied if required\n   * @returns true if operation was successful\n   */\n  copyAnimationRange(source, name, rescaleAsRequired = false) {\n    if (this._ranges[name] || !source.getAnimationRange(name)) {\n      return false;\n    }\n    let ret = true;\n    const frameOffset = this._getHighestAnimationFrame() + 1;\n    // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n    const boneDict = {};\n    const sourceBones = source.bones;\n    let nBones;\n    let i;\n    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n      boneDict[sourceBones[i].name] = sourceBones[i];\n    }\n    if (this.bones.length !== sourceBones.length) {\n      Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n      ret = false;\n    }\n    const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n    for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n      const boneName = this.bones[i].name;\n      const sourceBone = boneDict[boneName];\n      if (sourceBone) {\n        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n      } else {\n        Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n        ret = false;\n      }\n    }\n    // do not call createAnimationRange(), since it also is done to bones, which was already done\n    const range = source.getAnimationRange(name);\n    if (range) {\n      this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n    }\n    return ret;\n  }\n  /**\n   * Forces the skeleton to go to rest pose\n   */\n  returnToRest() {\n    for (const bone of this.bones) {\n      if (bone._index !== -1) {\n        bone.returnToRest();\n      }\n    }\n  }\n  _getHighestAnimationFrame() {\n    let ret = 0;\n    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n      if (this.bones[i].animations[0]) {\n        const highest = this.bones[i].animations[0].getHighestFrame();\n        if (ret < highest) {\n          ret = highest;\n        }\n      }\n    }\n    return ret;\n  }\n  /**\n   * Begin a specific animation range\n   * @param name defines the name of the range to start\n   * @param loop defines if looping must be turned on (false by default)\n   * @param speedRatio defines the speed ratio to apply (1 by default)\n   * @param onAnimationEnd defines a callback which will be called when animation will end\n   * @returns a new animatable\n   */\n  beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n    const range = this.getAnimationRange(name);\n    if (!range) {\n      return null;\n    }\n    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n  }\n  /**\n   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n   * @param skeleton defines the Skeleton containing the animation range to convert\n   * @param referenceFrame defines the frame that keyframes in the range will be relative to\n   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n   * @returns the original skeleton\n   */\n  static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n    const rangeValue = skeleton.getAnimationRange(range);\n    // We can't make a range additive if it doesn't exist\n    if (!rangeValue) {\n      return null;\n    }\n    // Find any current scene-level animatable belonging to the target that matches the range\n    const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n    let rangeAnimatable = null;\n    for (let index = 0; index < sceneAnimatables.length; index++) {\n      const sceneAnimatable = sceneAnimatables[index];\n      if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {\n        rangeAnimatable = sceneAnimatable;\n        break;\n      }\n    }\n    // Convert the animations belonging to the skeleton to additive keyframes\n    const animatables = skeleton.getAnimatables();\n    for (let index = 0; index < animatables.length; index++) {\n      const animatable = animatables[index];\n      const animations = animatable.animations;\n      if (!animations) {\n        continue;\n      }\n      for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n      }\n    }\n    // Mark the scene-level animatable as additive\n    if (rangeAnimatable) {\n      rangeAnimatable.isAdditive = true;\n    }\n    return skeleton;\n  }\n  /** @internal */\n  _markAsDirty() {\n    this._isDirty = true;\n    this._absoluteTransformIsDirty = true;\n  }\n  /**\n   * @internal\n   */\n  _registerMeshWithPoseMatrix(mesh) {\n    this._meshesWithPoseMatrix.push(mesh);\n  }\n  /**\n   * @internal\n   */\n  _unregisterMeshWithPoseMatrix(mesh) {\n    const index = this._meshesWithPoseMatrix.indexOf(mesh);\n    if (index > -1) {\n      this._meshesWithPoseMatrix.splice(index, 1);\n    }\n  }\n  _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n    this.onBeforeComputeObservable.notifyObservers(this);\n    for (let index = 0; index < this.bones.length; index++) {\n      const bone = this.bones[index];\n      bone._childUpdateId++;\n      const parentBone = bone.getParent();\n      if (parentBone) {\n        bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\n      } else {\n        if (initialSkinMatrix) {\n          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\n        } else {\n          bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\n        }\n      }\n      if (bone._index !== -1) {\n        const mappedIndex = bone._index === null ? index : bone._index;\n        bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\n      }\n    }\n    this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n  }\n  /**\n   * Build all resources required to render a skeleton\n   */\n  prepare() {\n    // Update the local matrix of bones with linked transform nodes.\n    if (this._numBonesWithLinkedTransformNode > 0) {\n      for (const bone of this.bones) {\n        if (bone._linkedTransformNode) {\n          const node = bone._linkedTransformNode;\n          bone.position = node.position;\n          if (node.rotationQuaternion) {\n            bone.rotationQuaternion = node.rotationQuaternion;\n          } else {\n            bone.rotation = node.rotation;\n          }\n          bone.scaling = node.scaling;\n        }\n      }\n    }\n    if (this.needInitialSkinMatrix) {\n      for (const mesh of this._meshesWithPoseMatrix) {\n        const poseMatrix = mesh.getPoseMatrix();\n        let needsUpdate = this._isDirty;\n        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n          needsUpdate = true;\n        }\n        if (!needsUpdate) {\n          continue;\n        }\n        if (this._synchronizedWithMesh !== mesh) {\n          this._synchronizedWithMesh = mesh;\n          // Prepare bones\n          for (const bone of this.bones) {\n            if (!bone.getParent()) {\n              const matrix = bone.getBaseMatrix();\n              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n              bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\n            }\n          }\n          if (this.isUsingTextureForMatrices) {\n            const textureWidth = (this.bones.length + 1) * 4;\n            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n              if (mesh._transformMatrixTexture) {\n                mesh._transformMatrixTexture.dispose();\n              }\n              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n            }\n          }\n        }\n        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n        }\n      }\n    } else {\n      if (!this._isDirty) {\n        return;\n      }\n      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n        if (this.isUsingTextureForMatrices) {\n          if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n          }\n          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);\n        }\n      }\n      this._computeTransformMatrices(this._transformMatrices, null);\n      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n        this._transformMatrixTexture.update(this._transformMatrices);\n      }\n    }\n    this._isDirty = false;\n  }\n  /**\n   * Gets the list of animatables currently running for this skeleton\n   * @returns an array of animatables\n   */\n  getAnimatables() {\n    if (!this._animatables || this._animatables.length !== this.bones.length) {\n      this._animatables = [];\n      for (let index = 0; index < this.bones.length; index++) {\n        this._animatables.push(this.bones[index]);\n      }\n    }\n    return this._animatables;\n  }\n  /**\n   * Clone the current skeleton\n   * @param name defines the name of the new skeleton\n   * @param id defines the id of the new skeleton\n   * @returns the new skeleton\n   */\n  clone(name, id) {\n    const result = new Skeleton(name, id || name, this._scene);\n    result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    for (let index = 0; index < this.bones.length; index++) {\n      const source = this.bones[index];\n      let parentBone = null;\n      const parent = source.getParent();\n      if (parent) {\n        const parentIndex = this.bones.indexOf(parent);\n        parentBone = result.bones[parentIndex];\n      }\n      const bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\n      bone._index = source._index;\n      if (source._linkedTransformNode) {\n        bone.linkTransformNode(source._linkedTransformNode);\n      }\n      DeepCopier.DeepCopy(source.animations, bone.animations);\n    }\n    if (this._ranges) {\n      result._ranges = {};\n      for (const rangeName in this._ranges) {\n        const range = this._ranges[rangeName];\n        if (range) {\n          result._ranges[rangeName] = range.clone();\n        }\n      }\n    }\n    this._isDirty = true;\n    return result;\n  }\n  /**\n   * Enable animation blending for this skeleton\n   * @param blendingSpeed defines the blending speed to apply\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n   */\n  enableBlending(blendingSpeed = 0.01) {\n    this.bones.forEach(bone => {\n      bone.animations.forEach(animation => {\n        animation.enableBlending = true;\n        animation.blendingSpeed = blendingSpeed;\n      });\n    });\n  }\n  /**\n   * Releases all resources associated with the current skeleton\n   */\n  dispose() {\n    this._meshesWithPoseMatrix.length = 0;\n    // Animations\n    this.getScene().stopAnimation(this);\n    // Remove from scene\n    this.getScene().removeSkeleton(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.skeletons.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.skeletons.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    if (this._transformMatrixTexture) {\n      this._transformMatrixTexture.dispose();\n      this._transformMatrixTexture = null;\n    }\n  }\n  /**\n   * Serialize the skeleton in a JSON object\n   * @returns a JSON object\n   */\n  serialize() {\n    var _a;\n    const serializationObject = {};\n    serializationObject.name = this.name;\n    serializationObject.id = this.id;\n    if (this.dimensionsAtRest) {\n      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n    }\n    serializationObject.bones = [];\n    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n    for (let index = 0; index < this.bones.length; index++) {\n      const bone = this.bones[index];\n      const parent = bone.getParent();\n      const serializedBone = {\n        parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n        index: bone.getIndex(),\n        name: bone.name,\n        id: bone.id,\n        matrix: bone.getBaseMatrix().toArray(),\n        rest: bone.getRestPose().toArray(),\n        linkedTransformNodeId: (_a = bone.getTransformNode()) === null || _a === void 0 ? void 0 : _a.id\n      };\n      serializationObject.bones.push(serializedBone);\n      if (bone.length) {\n        serializedBone.length = bone.length;\n      }\n      if (bone.metadata) {\n        serializedBone.metadata = bone.metadata;\n      }\n      if (bone.animations && bone.animations.length > 0) {\n        serializedBone.animation = bone.animations[0].serialize();\n      }\n      serializationObject.ranges = [];\n      for (const name in this._ranges) {\n        const source = this._ranges[name];\n        if (!source) {\n          continue;\n        }\n        const range = {};\n        range.name = name;\n        range.from = source.from;\n        range.to = source.to;\n        serializationObject.ranges.push(range);\n      }\n    }\n    return serializationObject;\n  }\n  /**\n   * Creates a new skeleton from serialized data\n   * @param parsedSkeleton defines the serialized data\n   * @param scene defines the hosting scene\n   * @returns a new skeleton\n   */\n  static Parse(parsedSkeleton, scene) {\n    const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n    if (parsedSkeleton.dimensionsAtRest) {\n      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n    }\n    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n    let index;\n    for (index = 0; index < parsedSkeleton.bones.length; index++) {\n      const parsedBone = parsedSkeleton.bones[index];\n      const parsedBoneIndex = parsedSkeleton.bones[index].index;\n      let parentBone = null;\n      if (parsedBone.parentBoneIndex > -1) {\n        parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n      }\n      const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n      const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n      if (parsedBone.id !== undefined && parsedBone.id !== null) {\n        bone.id = parsedBone.id;\n      }\n      if (parsedBone.length) {\n        bone.length = parsedBone.length;\n      }\n      if (parsedBone.metadata) {\n        bone.metadata = parsedBone.metadata;\n      }\n      if (parsedBone.animation) {\n        bone.animations.push(Animation.Parse(parsedBone.animation));\n      }\n      if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n        skeleton._hasWaitingData = true;\n        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n      }\n    }\n    // placed after bones, so createAnimationRange can cascade down\n    if (parsedSkeleton.ranges) {\n      for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n        const data = parsedSkeleton.ranges[index];\n        skeleton.createAnimationRange(data.name, data.from, data.to);\n      }\n    }\n    return skeleton;\n  }\n  /**\n   * Compute all node absolute transforms\n   * @param forceUpdate defines if computation must be done even if cache is up to date\n   */\n  computeAbsoluteTransforms(forceUpdate = false) {\n    if (this._absoluteTransformIsDirty || forceUpdate) {\n      this.bones[0].computeAbsoluteTransforms();\n      this._absoluteTransformIsDirty = false;\n    }\n  }\n  /**\n   * Gets the root pose matrix\n   * @returns a matrix\n   */\n  getPoseMatrix() {\n    let poseMatrix = null;\n    if (this._meshesWithPoseMatrix.length > 0) {\n      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n    }\n    return poseMatrix;\n  }\n  /**\n   * Sorts bones per internal index\n   */\n  sortBones() {\n    const bones = new Array();\n    const visited = new Array(this.bones.length);\n    for (let index = 0; index < this.bones.length; index++) {\n      this._sortBones(index, bones, visited);\n    }\n    this.bones = bones;\n  }\n  _sortBones(index, bones, visited) {\n    if (visited[index]) {\n      return;\n    }\n    visited[index] = true;\n    const bone = this.bones[index];\n    if (!bone) return;\n    if (bone._index === undefined) {\n      bone._index = index;\n    }\n    const parentBone = bone.getParent();\n    if (parentBone) {\n      this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n    }\n    bones.push(bone);\n  }\n  /**\n   * Set the current local matrix as the restPose for all bones in the skeleton.\n   */\n  setCurrentPoseAsRest() {\n    this.bones.forEach(b => {\n      b.setCurrentPoseAsRest();\n    });\n  }\n}","map":{"version":3,"mappings":";AAAA,SAASA,IAAI,QAAQ,WAAS;AAC9B,SAASC,UAAU,QAAQ,uBAAqB;AAChD,SAASC,OAAO,EAAEC,MAAM,EAAEC,UAAU,QAAQ,yBAAuB;AAInE,SAASC,UAAU,QAAQ,qCAAmC;AAG9D,SAASC,SAAS,QAAQ,4BAA0B;AACpD,SAASC,cAAc,QAAQ,iCAA+B;AAC9D,SAASC,WAAW,QAAQ,2BAAyB;AAErD,SAASC,MAAM,QAAQ,mBAAiB;AACxC,SAASC,UAAU,QAAQ,uBAAqB;AAKhD;;;;AAIA,OAAM,MAAOC,QAAQ;EA0GjB;;;;;;EAMAC,aACI;EACOC,IAAY,EACnB;EACOC,EAAU,EACjBC,KAAY;IAHL,SAAI,GAAJF,IAAI;IAEJ,OAAE,GAAFC,EAAE;IAnHb;;;IAGO,UAAK,GAAG,IAAIE,KAAK,EAAQ;IAKhC;;;IAGO,0BAAqB,GAAG,KAAK;IAQ5B,aAAQ,GAAG,IAAI;IAGf,0BAAqB,GAAG,IAAIA,KAAK,EAAgB;IAEjD,cAAS,GAAGb,MAAM,CAACc,QAAQ,EAAE;IAG7B,YAAO,GAAiD,EAAE;IAE1D,8BAAyB,GAAG,IAAI;IAEhC,2BAAsB,GAAG,KAAK;IAC9B,cAAS,GAAG,CAAC;IAErB;IACO,qCAAgC,GAAG,CAAC;IAE3C;IACO,oBAAe,GAAsB,IAAI;IAEhD;IACO,qBAAgB,GAA4B,IAAI;IAEvD;;;IAGO,mBAAc,GAAG,KAAK;IAErB,mCAA8B,GAAG,IAAI;IAcrC,iCAA4B,GAA0C,IAAI;IAsBlF;IAEA;;;IAGO,8BAAyB,GAAG,IAAIhB,UAAU,EAAY;IA6BzD,IAAI,CAACiB,KAAK,GAAG,EAAE;IAEf,IAAI,CAACC,MAAM,GAAGJ,KAAK,IAAIP,WAAW,CAACY,gBAAgB;IACnD,IAAI,CAACC,SAAS,GAAG,IAAI,CAACF,MAAM,CAACG,WAAW,EAAE;IAE1C,IAAI,CAACH,MAAM,CAACI,WAAW,CAAC,IAAI,CAAC;IAE7B;IACA,IAAI,CAACC,QAAQ,GAAG,IAAI;IAEpB,MAAMC,UAAU,GAAG,IAAI,CAACN,MAAM,CAACO,SAAS,EAAE,CAACC,OAAO,EAAE;IACpD,IAAI,CAACC,sBAAsB,GAAGH,UAAU,CAACI,YAAY,IAAIJ,UAAU,CAACK,0BAA0B,GAAG,CAAC;EACtG;EAjFA;;;;EAIA,IAAWC,6BAA6B;IACpC,OAAO,IAAI,CAACC,8BAA8B;EAC9C;EAEA,IAAWD,6BAA6B,CAACE,KAAc;IACnD,IAAI,CAACD,8BAA8B,GAAGC,KAAK;IAC3C,IAAI,CAACC,YAAY,EAAE;EACvB;EAIA;;;EAGA,IAAWC,2BAA2B;IAClC,IAAI,CAAC,IAAI,CAACC,4BAA4B,EAAE;MACpC,OAAO,IAAI,CAACjB,MAAM,CAACgB,2BAA2B;;IAElD,OAAO,IAAI,CAACC,4BAA4B;EAC5C;EAEA,IAAWD,2BAA2B,CAACF,KAA4C;IAC/E,IAAI,CAACG,4BAA4B,GAAGH,KAAK;EAC7C;EAeA;;;EAGA,IAAWI,yBAAyB;IAChC,OAAO,IAAI,CAACN,6BAA6B,IAAI,IAAI,CAACH,sBAAsB;EAC5E;EAEA;;;EAGA,IAAWU,QAAQ;IACf,OAAO,IAAI,CAACjB,SAAS;EACzB;EA6BA;;;;EAIOkB,YAAY;IACf,OAAO,UAAU;EACrB;EAEA;;;;EAIOC,WAAW;IACd,OAAO,IAAI,CAACtB,KAAK,CAACuB,MAAM,CAAEC,CAAC,IAAK,CAACA,CAAC,CAACC,SAAS,EAAE,CAAC;EACnD;EAEA;EACA;;;;;EAKOC,oBAAoB,CAACC,IAAkB;IAC1C,IAAI,IAAI,CAACC,qBAAqB,EAAE;MAC5B,IAAI,CAACD,IAAI,CAACE,uBAAuB,EAAE;QAC/B,IAAI,CAACC,OAAO,EAAE;;MAGlB,OAAOH,IAAI,CAACE,uBAAwB;;IAGxC,IAAI,CAAC,IAAI,CAACE,kBAAkB,EAAE;MAC1B,IAAI,CAACD,OAAO,EAAE;;IAGlB,OAAO,IAAI,CAACC,kBAAkB;EAClC;EAEA;;;;;EAKOC,yBAAyB,CAACL,IAAkB;IAC/C,IAAI,IAAI,CAACC,qBAAqB,IAAID,IAAI,CAACM,uBAAuB,EAAE;MAC5D,OAAON,IAAI,CAACM,uBAAuB;;IAGvC,OAAO,IAAI,CAACA,uBAAuB;EACvC;EAEA;;;;EAIOC,QAAQ;IACX,OAAO,IAAI,CAACjC,MAAM;EACtB;EAEA;EAEA;;;;;EAKOkC,QAAQ,CAACC,WAAqB;IACjC,IAAIC,GAAG,GAAG,SAAS,IAAI,CAAC1C,IAAI,aAAa,IAAI,CAACK,KAAK,CAACsC,MAAM,EAAE;IAC5DD,GAAG,IAAI,uBAAuB,IAAI,CAACE,OAAO,GAAGC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACF,OAAO,CAAC,CAACD,MAAM,GAAG,MAAM,EAAE;IACxF,IAAIF,WAAW,EAAE;MACbC,GAAG,IAAI,aAAa;MACpB,IAAIK,KAAK,GAAG,IAAI;MAChB,KAAK,MAAM/C,IAAI,IAAI,IAAI,CAAC4C,OAAO,EAAE;QAC7B,IAAIG,KAAK,EAAE;UACPL,GAAG,IAAI,IAAI;UACXK,KAAK,GAAG,KAAK;;QAEjBL,GAAG,IAAI1C,IAAI;;MAEf0C,GAAG,IAAI,GAAG;;IAEd,OAAOA,GAAG;EACd;EAEA;;;;;EAKOM,kBAAkB,CAAChD,IAAY;IAClC,KAAK,IAAIiD,SAAS,GAAG,CAAC,EAAEC,KAAK,GAAG,IAAI,CAAC7C,KAAK,CAACsC,MAAM,EAAEM,SAAS,GAAGC,KAAK,EAAED,SAAS,EAAE,EAAE;MAC/E,IAAI,IAAI,CAAC5C,KAAK,CAAC4C,SAAS,CAAC,CAACjD,IAAI,KAAKA,IAAI,EAAE;QACrC,OAAOiD,SAAS;;;IAGxB,OAAO,CAAC,CAAC;EACb;EAEA;;;;;;EAMOE,oBAAoB,CAACnD,IAAY,EAAEoD,IAAY,EAAEC,EAAU;IAC9D;IACA,IAAI,CAAC,IAAI,CAACT,OAAO,CAAC5C,IAAI,CAAC,EAAE;MACrB,IAAI,CAAC4C,OAAO,CAAC5C,IAAI,CAAC,GAAG,IAAIN,cAAc,CAACM,IAAI,EAAEoD,IAAI,EAAEC,EAAE,CAAC;MACvD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACsC,MAAM,EAAEW,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;QACzD,IAAI,IAAI,CAACjD,KAAK,CAACiD,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,CAAC,EAAE;UAC7B,IAAI,CAACnD,KAAK,CAACiD,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,CAAC,CAACC,WAAW,CAACzD,IAAI,EAAEoD,IAAI,EAAEC,EAAE,CAAC;;;;EAIvE;EAEA;;;;;EAKOK,oBAAoB,CAAC1D,IAAY,EAAE2D,YAAY,GAAG,IAAI;IACzD,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACsC,MAAM,EAAEW,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;MACzD,IAAI,IAAI,CAACjD,KAAK,CAACiD,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,CAAC,EAAE;QAC7B,IAAI,CAACnD,KAAK,CAACiD,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,CAAC,CAACI,WAAW,CAAC5D,IAAI,EAAE2D,YAAY,CAAC;;;IAGnE,IAAI,CAACf,OAAO,CAAC5C,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;EAC/B;EAEA;;;;;EAKO6D,iBAAiB,CAAC7D,IAAY;IACjC,OAAO,IAAI,CAAC4C,OAAO,CAAC5C,IAAI,CAAC,IAAI,IAAI;EACrC;EAEA;;;;EAIO8D,kBAAkB;IACrB,MAAMC,eAAe,GAA+B,EAAE;IACtD,IAAI/D,IAAY;IAChB,KAAKA,IAAI,IAAI,IAAI,CAAC4C,OAAO,EAAE;MACvBmB,eAAe,CAACC,IAAI,CAAC,IAAI,CAACpB,OAAO,CAAC5C,IAAI,CAAC,CAAC;;IAE5C,OAAO+D,eAAe;EAC1B;EAEA;;;;;;;;EAQOE,kBAAkB,CAACC,MAAgB,EAAElE,IAAY,EAAEmE,iBAAiB,GAAG,KAAK;IAC/E,IAAI,IAAI,CAACvB,OAAO,CAAC5C,IAAI,CAAC,IAAI,CAACkE,MAAM,CAACL,iBAAiB,CAAC7D,IAAI,CAAC,EAAE;MACvD,OAAO,KAAK;;IAEhB,IAAI0C,GAAG,GAAG,IAAI;IACd,MAAM0B,WAAW,GAAG,IAAI,CAACC,yBAAyB,EAAE,GAAG,CAAC;IAExD;IACA,MAAMC,QAAQ,GAA4B,EAAE;IAC5C,MAAMC,WAAW,GAAGL,MAAM,CAAC7D,KAAK;IAChC,IAAIkD,MAAc;IAClB,IAAID,CAAS;IACb,KAAKA,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAGgB,WAAW,CAAC5B,MAAM,EAAEW,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;MACtDgB,QAAQ,CAACC,WAAW,CAACjB,CAAC,CAAC,CAACtD,IAAI,CAAC,GAAGuE,WAAW,CAACjB,CAAC,CAAC;;IAGlD,IAAI,IAAI,CAACjD,KAAK,CAACsC,MAAM,KAAK4B,WAAW,CAAC5B,MAAM,EAAE;MAC1C/C,MAAM,CAAC4E,IAAI,CAAC,oCAAoC,IAAI,CAACnE,KAAK,CAACsC,MAAM,2BAA2B4B,WAAW,CAAC5B,MAAM,EAAE,CAAC;MACjHD,GAAG,GAAG,KAAK;;IAGf,MAAM+B,mBAAmB,GAAGN,iBAAiB,IAAI,IAAI,CAACO,gBAAgB,IAAIR,MAAM,CAACQ,gBAAgB,GAAG,IAAI,CAACA,gBAAgB,CAACC,MAAM,CAACT,MAAM,CAACQ,gBAAgB,CAAC,GAAG,IAAI;IAEhK,KAAKpB,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACsC,MAAM,EAAEW,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;MACrD,MAAMsB,QAAQ,GAAG,IAAI,CAACvE,KAAK,CAACiD,CAAC,CAAC,CAACtD,IAAI;MACnC,MAAM6E,UAAU,GAAGP,QAAQ,CAACM,QAAQ,CAAC;MACrC,IAAIC,UAAU,EAAE;QACZnC,GAAG,GAAGA,GAAG,IAAI,IAAI,CAACrC,KAAK,CAACiD,CAAC,CAAC,CAACW,kBAAkB,CAACY,UAAU,EAAE7E,IAAI,EAAEoE,WAAW,EAAED,iBAAiB,EAAEM,mBAAmB,CAAC;OACvH,MAAM;QACH7E,MAAM,CAAC4E,IAAI,CAAC,wDAAwD,GAAGI,QAAQ,CAAC;QAChFlC,GAAG,GAAG,KAAK;;;IAGnB;IACA,MAAMoC,KAAK,GAAGZ,MAAM,CAACL,iBAAiB,CAAC7D,IAAI,CAAC;IAC5C,IAAI8E,KAAK,EAAE;MACP,IAAI,CAAClC,OAAO,CAAC5C,IAAI,CAAC,GAAG,IAAIN,cAAc,CAACM,IAAI,EAAE8E,KAAK,CAAC1B,IAAI,GAAGgB,WAAW,EAAEU,KAAK,CAACzB,EAAE,GAAGe,WAAW,CAAC;;IAEnG,OAAO1B,GAAG;EACd;EAEA;;;EAGOqC,YAAY;IACf,KAAK,MAAMC,IAAI,IAAI,IAAI,CAAC3E,KAAK,EAAE;MAC3B,IAAI2E,IAAI,CAACC,MAAM,KAAK,CAAC,CAAC,EAAE;QACpBD,IAAI,CAACD,YAAY,EAAE;;;EAG/B;EAEQV,yBAAyB;IAC7B,IAAI3B,GAAG,GAAG,CAAC;IACX,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEC,MAAM,GAAG,IAAI,CAAClD,KAAK,CAACsC,MAAM,EAAEW,CAAC,GAAGC,MAAM,EAAED,CAAC,EAAE,EAAE;MACzD,IAAI,IAAI,CAACjD,KAAK,CAACiD,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,CAAC,EAAE;QAC7B,MAAM0B,OAAO,GAAG,IAAI,CAAC7E,KAAK,CAACiD,CAAC,CAAC,CAACE,UAAU,CAAC,CAAC,CAAC,CAAC2B,eAAe,EAAE;QAC7D,IAAIzC,GAAG,GAAGwC,OAAO,EAAE;UACfxC,GAAG,GAAGwC,OAAO;;;;IAIzB,OAAOxC,GAAG;EACd;EAEA;;;;;;;;EAQO0C,cAAc,CAACpF,IAAY,EAAEqF,IAAc,EAAEC,UAAmB,EAAEC,cAA2B;IAChG,MAAMT,KAAK,GAAG,IAAI,CAACjB,iBAAiB,CAAC7D,IAAI,CAAC;IAE1C,IAAI,CAAC8E,KAAK,EAAE;MACR,OAAO,IAAI;;IAGf,OAAO,IAAI,CAACxE,MAAM,CAAC8E,cAAc,CAAC,IAAI,EAAEN,KAAK,CAAC1B,IAAI,EAAE0B,KAAK,CAACzB,EAAE,EAAEgC,IAAI,EAAEC,UAAU,EAAEC,cAAc,CAAC;EACnG;EAEA;;;;;;;EAOO,OAAOC,qBAAqB,CAACC,QAAkB,EAAEC,cAAc,GAAG,CAAC,EAAEZ,KAAa;IACrF,MAAMa,UAAU,GAAGF,QAAQ,CAAC5B,iBAAiB,CAACiB,KAAK,CAAC;IAEpD;IACA,IAAI,CAACa,UAAU,EAAE;MACb,OAAO,IAAI;;IAGf;IACA,MAAMC,gBAAgB,GAAGH,QAAQ,CAACnF,MAAM,CAACuF,yBAAyB,CAACJ,QAAQ,CAAC;IAC5E,IAAIK,eAAe,GAAyB,IAAI;IAEhD,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,gBAAgB,CAACjD,MAAM,EAAEoD,KAAK,EAAE,EAAE;MAC1D,MAAMC,eAAe,GAAGJ,gBAAgB,CAACG,KAAK,CAAC;MAE/C,IAAIC,eAAe,CAACC,SAAS,MAAKN,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEvC,IAAI,KAAI4C,eAAe,CAACE,OAAO,MAAKP,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEtC,EAAE,GAAE;QAC9FyC,eAAe,GAAGE,eAAe;QACjC;;;IAIR;IACA,MAAMG,WAAW,GAAGV,QAAQ,CAACW,cAAc,EAAE;IAE7C,KAAK,IAAIL,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGI,WAAW,CAACxD,MAAM,EAAEoD,KAAK,EAAE,EAAE;MACrD,MAAMM,UAAU,GAAGF,WAAW,CAACJ,KAAK,CAAC;MACrC,MAAMvC,UAAU,GAAG6C,UAAU,CAAC7C,UAAU;MAExC,IAAI,CAACA,UAAU,EAAE;QACb;;MAGJ,KAAK,IAAI8C,SAAS,GAAG,CAAC,EAAEA,SAAS,GAAG9C,UAAU,CAACb,MAAM,EAAE2D,SAAS,EAAE,EAAE;QAChE7G,SAAS,CAAC+F,qBAAqB,CAAChC,UAAU,CAAC8C,SAAS,CAAC,EAAEZ,cAAc,EAAEZ,KAAK,CAAC;;;IAIrF;IACA,IAAIgB,eAAe,EAAE;MACjBA,eAAe,CAACS,UAAU,GAAG,IAAI;;IAGrC,OAAOd,QAAQ;EACnB;EAEA;EACOpE,YAAY;IACf,IAAI,CAACV,QAAQ,GAAG,IAAI;IACpB,IAAI,CAAC6F,yBAAyB,GAAG,IAAI;EACzC;EAEA;;;EAGOC,2BAA2B,CAACzE,IAAkB;IACjD,IAAI,CAAC0E,qBAAqB,CAAC1C,IAAI,CAAChC,IAAI,CAAC;EACzC;EAEA;;;EAGO2E,6BAA6B,CAAC3E,IAAkB;IACnD,MAAM+D,KAAK,GAAG,IAAI,CAACW,qBAAqB,CAACE,OAAO,CAAC5E,IAAI,CAAC;IAEtD,IAAI+D,KAAK,GAAG,CAAC,CAAC,EAAE;MACZ,IAAI,CAACW,qBAAqB,CAACG,MAAM,CAACd,KAAK,EAAE,CAAC,CAAC;;EAEnD;EAEQe,yBAAyB,CAACC,YAA0B,EAAEC,iBAAmC;IAC7F,IAAI,CAACC,yBAAyB,CAACC,eAAe,CAAC,IAAI,CAAC;IAEpD,KAAK,IAAInB,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAAC1F,KAAK,CAACsC,MAAM,EAAEoD,KAAK,EAAE,EAAE;MACpD,MAAMf,IAAI,GAAG,IAAI,CAAC3E,KAAK,CAAC0F,KAAK,CAAC;MAC9Bf,IAAI,CAACmC,cAAc,EAAE;MACrB,MAAMC,UAAU,GAAGpC,IAAI,CAAClD,SAAS,EAAE;MAEnC,IAAIsF,UAAU,EAAE;QACZpC,IAAI,CAACqC,cAAc,EAAE,CAACC,aAAa,CAACF,UAAU,CAACG,cAAc,EAAE,EAAEvC,IAAI,CAACuC,cAAc,EAAE,CAAC;OAC1F,MAAM;QACH,IAAIP,iBAAiB,EAAE;UACnBhC,IAAI,CAACqC,cAAc,EAAE,CAACC,aAAa,CAACN,iBAAiB,EAAEhC,IAAI,CAACuC,cAAc,EAAE,CAAC;SAChF,MAAM;UACHvC,IAAI,CAACuC,cAAc,EAAE,CAACC,QAAQ,CAACxC,IAAI,CAACqC,cAAc,EAAE,CAAC;;;MAI7D,IAAIrC,IAAI,CAACC,MAAM,KAAK,CAAC,CAAC,EAAE;QACpB,MAAMwC,WAAW,GAAGzC,IAAI,CAACC,MAAM,KAAK,IAAI,GAAGc,KAAK,GAAGf,IAAI,CAACC,MAAM;QAC9DD,IAAI,CAAC0C,4BAA4B,EAAE,CAACC,eAAe,CAAC3C,IAAI,CAACuC,cAAc,EAAE,EAAER,YAAY,EAAEU,WAAW,GAAG,EAAE,CAAC;;;IAIlH,IAAI,CAACG,SAAS,CAACC,WAAW,CAACd,YAAY,EAAE,IAAI,CAAC1G,KAAK,CAACsC,MAAM,GAAG,EAAE,CAAC;EACpE;EAEA;;;EAGOR,OAAO;IACV;IACA,IAAI,IAAI,CAAC2F,gCAAgC,GAAG,CAAC,EAAE;MAC3C,KAAK,MAAM9C,IAAI,IAAI,IAAI,CAAC3E,KAAK,EAAE;QAC3B,IAAI2E,IAAI,CAAC+C,oBAAoB,EAAE;UAC3B,MAAMC,IAAI,GAAGhD,IAAI,CAAC+C,oBAAoB;UACtC/C,IAAI,CAACiD,QAAQ,GAAGD,IAAI,CAACC,QAAQ;UAC7B,IAAID,IAAI,CAACE,kBAAkB,EAAE;YACzBlD,IAAI,CAACkD,kBAAkB,GAAGF,IAAI,CAACE,kBAAkB;WACpD,MAAM;YACHlD,IAAI,CAACmD,QAAQ,GAAGH,IAAI,CAACG,QAAQ;;UAEjCnD,IAAI,CAACoD,OAAO,GAAGJ,IAAI,CAACI,OAAO;;;;IAKvC,IAAI,IAAI,CAACnG,qBAAqB,EAAE;MAC5B,KAAK,MAAMD,IAAI,IAAI,IAAI,CAAC0E,qBAAqB,EAAE;QAC3C,MAAM2B,UAAU,GAAGrG,IAAI,CAACsG,aAAa,EAAE;QAEvC,IAAIC,WAAW,GAAG,IAAI,CAAC5H,QAAQ;QAC/B,IAAI,CAACqB,IAAI,CAACE,uBAAuB,IAAIF,IAAI,CAACE,uBAAuB,CAACS,MAAM,KAAK,EAAE,IAAI,IAAI,CAACtC,KAAK,CAACsC,MAAM,GAAG,CAAC,CAAC,EAAE;UACvGX,IAAI,CAACE,uBAAuB,GAAG,IAAIsG,YAAY,CAAC,EAAE,IAAI,IAAI,CAACnI,KAAK,CAACsC,MAAM,GAAG,CAAC,CAAC,CAAC;UAC7E4F,WAAW,GAAG,IAAI;;QAGtB,IAAI,CAACA,WAAW,EAAE;UACd;;QAGJ,IAAI,IAAI,CAACE,qBAAqB,KAAKzG,IAAI,EAAE;UACrC,IAAI,CAACyG,qBAAqB,GAAGzG,IAAI;UAEjC;UACA,KAAK,MAAMgD,IAAI,IAAI,IAAI,CAAC3E,KAAK,EAAE;YAC3B,IAAI,CAAC2E,IAAI,CAAClD,SAAS,EAAE,EAAE;cACnB,MAAM4G,MAAM,GAAG1D,IAAI,CAAC2D,aAAa,EAAE;cACnCD,MAAM,CAACpB,aAAa,CAACe,UAAU,EAAE9I,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;cACtD0F,IAAI,CAAC4D,uBAAuB,CAACrJ,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;;;UAI1D,IAAI,IAAI,CAACkC,yBAAyB,EAAE;YAChC,MAAMqH,YAAY,GAAG,CAAC,IAAI,CAACxI,KAAK,CAACsC,MAAM,GAAG,CAAC,IAAI,CAAC;YAChD,IAAI,CAACX,IAAI,CAACM,uBAAuB,IAAIN,IAAI,CAACM,uBAAuB,CAACwG,OAAO,EAAE,CAACC,KAAK,KAAKF,YAAY,EAAE;cAChG,IAAI7G,IAAI,CAACM,uBAAuB,EAAE;gBAC9BN,IAAI,CAACM,uBAAuB,CAAC0G,OAAO,EAAE;;cAG1ChH,IAAI,CAACM,uBAAuB,GAAG9C,UAAU,CAACyJ,iBAAiB,CACvDjH,IAAI,CAACE,uBAAuB,EAC5B,CAAC,IAAI,CAAC7B,KAAK,CAACsC,MAAM,GAAG,CAAC,IAAI,CAAC,EAC3B,CAAC,EACD,IAAI,CAACrC,MAAM,EACX,KAAK,EACL,KAAK,EACL;;;;QAOhB,IAAI,CAACwG,yBAAyB,CAAC9E,IAAI,CAACE,uBAAuB,EAAEmG,UAAU,CAAC;QAExE,IAAI,IAAI,CAAC7G,yBAAyB,IAAIQ,IAAI,CAACM,uBAAuB,EAAE;UAChEN,IAAI,CAACM,uBAAuB,CAAC4G,MAAM,CAAClH,IAAI,CAACE,uBAAuB,CAAC;;;KAG5E,MAAM;MACH,IAAI,CAAC,IAAI,CAACvB,QAAQ,EAAE;QAChB;;MAGJ,IAAI,CAAC,IAAI,CAACyB,kBAAkB,IAAI,IAAI,CAACA,kBAAkB,CAACO,MAAM,KAAK,EAAE,IAAI,IAAI,CAACtC,KAAK,CAACsC,MAAM,GAAG,CAAC,CAAC,EAAE;QAC7F,IAAI,CAACP,kBAAkB,GAAG,IAAIoG,YAAY,CAAC,EAAE,IAAI,IAAI,CAACnI,KAAK,CAACsC,MAAM,GAAG,CAAC,CAAC,CAAC;QAExE,IAAI,IAAI,CAACnB,yBAAyB,EAAE;UAChC,IAAI,IAAI,CAACc,uBAAuB,EAAE;YAC9B,IAAI,CAACA,uBAAuB,CAAC0G,OAAO,EAAE;;UAG1C,IAAI,CAAC1G,uBAAuB,GAAG9C,UAAU,CAACyJ,iBAAiB,CACvD,IAAI,CAAC7G,kBAAkB,EACvB,CAAC,IAAI,CAAC/B,KAAK,CAACsC,MAAM,GAAG,CAAC,IAAI,CAAC,EAC3B,CAAC,EACD,IAAI,CAACrC,MAAM,EACX,KAAK,EACL,KAAK,EACL;;;MAMZ,IAAI,CAACwG,yBAAyB,CAAC,IAAI,CAAC1E,kBAAkB,EAAE,IAAI,CAAC;MAE7D,IAAI,IAAI,CAACZ,yBAAyB,IAAI,IAAI,CAACc,uBAAuB,EAAE;QAChE,IAAI,CAACA,uBAAuB,CAAC4G,MAAM,CAAC,IAAI,CAAC9G,kBAAkB,CAAC;;;IAIpE,IAAI,CAACzB,QAAQ,GAAG,KAAK;EACzB;EAEA;;;;EAIOyF,cAAc;IACjB,IAAI,CAAC,IAAI,CAAC+C,YAAY,IAAI,IAAI,CAACA,YAAY,CAACxG,MAAM,KAAK,IAAI,CAACtC,KAAK,CAACsC,MAAM,EAAE;MACtE,IAAI,CAACwG,YAAY,GAAG,EAAE;MAEtB,KAAK,IAAIpD,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAAC1F,KAAK,CAACsC,MAAM,EAAEoD,KAAK,EAAE,EAAE;QACpD,IAAI,CAACoD,YAAY,CAACnF,IAAI,CAAC,IAAI,CAAC3D,KAAK,CAAC0F,KAAK,CAAC,CAAC;;;IAIjD,OAAO,IAAI,CAACoD,YAAY;EAC5B;EAEA;;;;;;EAMOC,KAAK,CAACpJ,IAAY,EAAEC,EAAW;IAClC,MAAMoJ,MAAM,GAAG,IAAIvJ,QAAQ,CAACE,IAAI,EAAEC,EAAE,IAAID,IAAI,EAAE,IAAI,CAACM,MAAM,CAAC;IAE1D+I,MAAM,CAACpH,qBAAqB,GAAG,IAAI,CAACA,qBAAqB;IAEzD,KAAK,IAAI8D,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAAC1F,KAAK,CAACsC,MAAM,EAAEoD,KAAK,EAAE,EAAE;MACpD,MAAM7B,MAAM,GAAG,IAAI,CAAC7D,KAAK,CAAC0F,KAAK,CAAC;MAChC,IAAIqB,UAAU,GAAG,IAAI;MAErB,MAAMkC,MAAM,GAAGpF,MAAM,CAACpC,SAAS,EAAE;MACjC,IAAIwH,MAAM,EAAE;QACR,MAAMC,WAAW,GAAG,IAAI,CAAClJ,KAAK,CAACuG,OAAO,CAAC0C,MAAM,CAAC;QAC9ClC,UAAU,GAAGiC,MAAM,CAAChJ,KAAK,CAACkJ,WAAW,CAAC;;MAG1C,MAAMvE,IAAI,GAAG,IAAI7F,IAAI,CAAC+E,MAAM,CAAClE,IAAI,EAAEqJ,MAAM,EAAEjC,UAAU,EAAElD,MAAM,CAACyE,aAAa,EAAE,CAACS,KAAK,EAAE,EAAElF,MAAM,CAACsF,WAAW,EAAE,CAACJ,KAAK,EAAE,CAAC;MACpHpE,IAAI,CAACC,MAAM,GAAGf,MAAM,CAACe,MAAM;MAE3B,IAAIf,MAAM,CAAC6D,oBAAoB,EAAE;QAC7B/C,IAAI,CAACyE,iBAAiB,CAACvF,MAAM,CAAC6D,oBAAoB,CAAC;;MAGvDlI,UAAU,CAAC6J,QAAQ,CAACxF,MAAM,CAACV,UAAU,EAAEwB,IAAI,CAACxB,UAAU,CAAC;;IAG3D,IAAI,IAAI,CAACZ,OAAO,EAAE;MACdyG,MAAM,CAACzG,OAAO,GAAG,EAAE;MACnB,KAAK,MAAM+G,SAAS,IAAI,IAAI,CAAC/G,OAAO,EAAE;QAClC,MAAMkC,KAAK,GAAG,IAAI,CAAClC,OAAO,CAAC+G,SAAS,CAAC;QAErC,IAAI7E,KAAK,EAAE;UACPuE,MAAM,CAACzG,OAAO,CAAC+G,SAAS,CAAC,GAAG7E,KAAK,CAACsE,KAAK,EAAE;;;;IAKrD,IAAI,CAACzI,QAAQ,GAAG,IAAI;IAEpB,OAAO0I,MAAM;EACjB;EAEA;;;;;EAKOO,cAAc,CAACC,aAAa,GAAG,IAAI;IACtC,IAAI,CAACxJ,KAAK,CAACyJ,OAAO,CAAE9E,IAAI,IAAI;MACxBA,IAAI,CAACxB,UAAU,CAACsG,OAAO,CAAEC,SAAoB,IAAI;QAC7CA,SAAS,CAACH,cAAc,GAAG,IAAI;QAC/BG,SAAS,CAACF,aAAa,GAAGA,aAAa;MAC3C,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEA;;;EAGOb,OAAO;IACV,IAAI,CAACtC,qBAAqB,CAAC/D,MAAM,GAAG,CAAC;IAErC;IACA,IAAI,CAACJ,QAAQ,EAAE,CAACyH,aAAa,CAAC,IAAI,CAAC;IAEnC;IACA,IAAI,CAACzH,QAAQ,EAAE,CAAC0H,cAAc,CAAC,IAAI,CAAC;IAEpC,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACvB,MAAMnE,KAAK,GAAG,IAAI,CAACmE,gBAAgB,CAACC,SAAS,CAACvD,OAAO,CAAC,IAAI,CAAC;MAC3D,IAAIb,KAAK,GAAG,CAAC,CAAC,EAAE;QACZ,IAAI,CAACmE,gBAAgB,CAACC,SAAS,CAACtD,MAAM,CAACd,KAAK,EAAE,CAAC,CAAC;;MAEpD,IAAI,CAACmE,gBAAgB,GAAG,IAAI;;IAGhC,IAAI,IAAI,CAAC5H,uBAAuB,EAAE;MAC9B,IAAI,CAACA,uBAAuB,CAAC0G,OAAO,EAAE;MACtC,IAAI,CAAC1G,uBAAuB,GAAG,IAAI;;EAE3C;EAEA;;;;EAIO8H,SAAS;;IACZ,MAAMC,mBAAmB,GAAQ,EAAE;IAEnCA,mBAAmB,CAACrK,IAAI,GAAG,IAAI,CAACA,IAAI;IACpCqK,mBAAmB,CAACpK,EAAE,GAAG,IAAI,CAACA,EAAE;IAEhC,IAAI,IAAI,CAACyE,gBAAgB,EAAE;MACvB2F,mBAAmB,CAAC3F,gBAAgB,GAAG,IAAI,CAACA,gBAAgB,CAAC4F,OAAO,EAAE;;IAG1ED,mBAAmB,CAAChK,KAAK,GAAG,EAAE;IAE9BgK,mBAAmB,CAACpI,qBAAqB,GAAG,IAAI,CAACA,qBAAqB;IAEtE,KAAK,IAAI8D,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAAC1F,KAAK,CAACsC,MAAM,EAAEoD,KAAK,EAAE,EAAE;MACpD,MAAMf,IAAI,GAAG,IAAI,CAAC3E,KAAK,CAAC0F,KAAK,CAAC;MAC9B,MAAMuD,MAAM,GAAGtE,IAAI,CAAClD,SAAS,EAAE;MAE/B,MAAMyI,cAAc,GAAQ;QACxBC,eAAe,EAAElB,MAAM,GAAG,IAAI,CAACjJ,KAAK,CAACuG,OAAO,CAAC0C,MAAM,CAAC,GAAG,CAAC,CAAC;QACzDvD,KAAK,EAAEf,IAAI,CAACyF,QAAQ,EAAE;QACtBzK,IAAI,EAAEgF,IAAI,CAAChF,IAAI;QACfC,EAAE,EAAE+E,IAAI,CAAC/E,EAAE;QACXyI,MAAM,EAAE1D,IAAI,CAAC2D,aAAa,EAAE,CAAC+B,OAAO,EAAE;QACtCC,IAAI,EAAE3F,IAAI,CAACwE,WAAW,EAAE,CAACkB,OAAO,EAAE;QAClCE,qBAAqB,EAAE,UAAI,CAACC,gBAAgB,EAAE,0CAAE5K;OACnD;MAEDoK,mBAAmB,CAAChK,KAAK,CAAC2D,IAAI,CAACuG,cAAc,CAAC;MAE9C,IAAIvF,IAAI,CAACrC,MAAM,EAAE;QACb4H,cAAc,CAAC5H,MAAM,GAAGqC,IAAI,CAACrC,MAAM;;MAGvC,IAAIqC,IAAI,CAAC8F,QAAQ,EAAE;QACfP,cAAc,CAACO,QAAQ,GAAG9F,IAAI,CAAC8F,QAAQ;;MAG3C,IAAI9F,IAAI,CAACxB,UAAU,IAAIwB,IAAI,CAACxB,UAAU,CAACb,MAAM,GAAG,CAAC,EAAE;QAC/C4H,cAAc,CAACR,SAAS,GAAG/E,IAAI,CAACxB,UAAU,CAAC,CAAC,CAAC,CAAC4G,SAAS,EAAE;;MAG7DC,mBAAmB,CAACU,MAAM,GAAG,EAAE;MAC/B,KAAK,MAAM/K,IAAI,IAAI,IAAI,CAAC4C,OAAO,EAAE;QAC7B,MAAMsB,MAAM,GAAG,IAAI,CAACtB,OAAO,CAAC5C,IAAI,CAAC;QAEjC,IAAI,CAACkE,MAAM,EAAE;UACT;;QAGJ,MAAMY,KAAK,GAAQ,EAAE;QACrBA,KAAK,CAAC9E,IAAI,GAAGA,IAAI;QACjB8E,KAAK,CAAC1B,IAAI,GAAGc,MAAM,CAACd,IAAI;QACxB0B,KAAK,CAACzB,EAAE,GAAGa,MAAM,CAACb,EAAE;QACpBgH,mBAAmB,CAACU,MAAM,CAAC/G,IAAI,CAACc,KAAK,CAAC;;;IAG9C,OAAOuF,mBAAmB;EAC9B;EAEA;;;;;;EAMO,OAAOW,KAAK,CAACC,cAAmB,EAAE/K,KAAY;IACjD,MAAMuF,QAAQ,GAAG,IAAI3F,QAAQ,CAACmL,cAAc,CAACjL,IAAI,EAAEiL,cAAc,CAAChL,EAAE,EAAEC,KAAK,CAAC;IAC5E,IAAI+K,cAAc,CAACvG,gBAAgB,EAAE;MACjCe,QAAQ,CAACf,gBAAgB,GAAGrF,OAAO,CAAC6L,SAAS,CAACD,cAAc,CAACvG,gBAAgB,CAAC;;IAGlFe,QAAQ,CAACxD,qBAAqB,GAAGgJ,cAAc,CAAChJ,qBAAqB;IAErE,IAAI8D,KAAa;IACjB,KAAKA,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGkF,cAAc,CAAC5K,KAAK,CAACsC,MAAM,EAAEoD,KAAK,EAAE,EAAE;MAC1D,MAAMoF,UAAU,GAAGF,cAAc,CAAC5K,KAAK,CAAC0F,KAAK,CAAC;MAC9C,MAAMqF,eAAe,GAAGH,cAAc,CAAC5K,KAAK,CAAC0F,KAAK,CAAC,CAACA,KAAK;MACzD,IAAIqB,UAAU,GAAG,IAAI;MACrB,IAAI+D,UAAU,CAACX,eAAe,GAAG,CAAC,CAAC,EAAE;QACjCpD,UAAU,GAAG3B,QAAQ,CAACpF,KAAK,CAAC8K,UAAU,CAACX,eAAe,CAAC;;MAG3D,MAAMG,IAAI,GAAqBQ,UAAU,CAACR,IAAI,GAAGrL,MAAM,CAAC4L,SAAS,CAACC,UAAU,CAACR,IAAI,CAAC,GAAG,IAAI;MACzF,MAAM3F,IAAI,GAAG,IAAI7F,IAAI,CAACgM,UAAU,CAACnL,IAAI,EAAEyF,QAAQ,EAAE2B,UAAU,EAAE9H,MAAM,CAAC4L,SAAS,CAACC,UAAU,CAACzC,MAAM,CAAC,EAAEiC,IAAI,EAAE,IAAI,EAAES,eAAe,CAAC;MAE9H,IAAID,UAAU,CAAClL,EAAE,KAAKoL,SAAS,IAAIF,UAAU,CAAClL,EAAE,KAAK,IAAI,EAAE;QACvD+E,IAAI,CAAC/E,EAAE,GAAGkL,UAAU,CAAClL,EAAE;;MAG3B,IAAIkL,UAAU,CAACxI,MAAM,EAAE;QACnBqC,IAAI,CAACrC,MAAM,GAAGwI,UAAU,CAACxI,MAAM;;MAGnC,IAAIwI,UAAU,CAACL,QAAQ,EAAE;QACrB9F,IAAI,CAAC8F,QAAQ,GAAGK,UAAU,CAACL,QAAQ;;MAGvC,IAAIK,UAAU,CAACpB,SAAS,EAAE;QACtB/E,IAAI,CAACxB,UAAU,CAACQ,IAAI,CAACvE,SAAS,CAACuL,KAAK,CAACG,UAAU,CAACpB,SAAS,CAAC,CAAC;;MAG/D,IAAIoB,UAAU,CAACP,qBAAqB,KAAKS,SAAS,IAAIF,UAAU,CAACP,qBAAqB,KAAK,IAAI,EAAE;QAC7FnF,QAAQ,CAAC6F,eAAe,GAAG,IAAI;QAC/BtG,IAAI,CAACuG,uBAAuB,GAAGJ,UAAU,CAACP,qBAAqB;;;IAIvE;IACA,IAAIK,cAAc,CAACF,MAAM,EAAE;MACvB,KAAKhF,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGkF,cAAc,CAACF,MAAM,CAACpI,MAAM,EAAEoD,KAAK,EAAE,EAAE;QAC3D,MAAMyF,IAAI,GAAGP,cAAc,CAACF,MAAM,CAAChF,KAAK,CAAC;QACzCN,QAAQ,CAACtC,oBAAoB,CAACqI,IAAI,CAACxL,IAAI,EAAEwL,IAAI,CAACpI,IAAI,EAAEoI,IAAI,CAACnI,EAAE,CAAC;;;IAGpE,OAAOoC,QAAQ;EACnB;EAEA;;;;EAIOgG,yBAAyB,CAACC,WAAW,GAAG,KAAK;IAChD,IAAI,IAAI,CAAClF,yBAAyB,IAAIkF,WAAW,EAAE;MAC/C,IAAI,CAACrL,KAAK,CAAC,CAAC,CAAC,CAACoL,yBAAyB,EAAE;MACzC,IAAI,CAACjF,yBAAyB,GAAG,KAAK;;EAE9C;EAEA;;;;EAIO8B,aAAa;IAChB,IAAID,UAAU,GAAqB,IAAI;IAEvC,IAAI,IAAI,CAAC3B,qBAAqB,CAAC/D,MAAM,GAAG,CAAC,EAAE;MACvC0F,UAAU,GAAG,IAAI,CAAC3B,qBAAqB,CAAC,CAAC,CAAC,CAAC4B,aAAa,EAAE;;IAG9D,OAAOD,UAAU;EACrB;EAEA;;;EAGOsD,SAAS;IACZ,MAAMtL,KAAK,GAAG,IAAIF,KAAK,EAAQ;IAC/B,MAAMyL,OAAO,GAAG,IAAIzL,KAAK,CAAU,IAAI,CAACE,KAAK,CAACsC,MAAM,CAAC;IACrD,KAAK,IAAIoD,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAG,IAAI,CAAC1F,KAAK,CAACsC,MAAM,EAAEoD,KAAK,EAAE,EAAE;MACpD,IAAI,CAAC8F,UAAU,CAAC9F,KAAK,EAAE1F,KAAK,EAAEuL,OAAO,CAAC;;IAG1C,IAAI,CAACvL,KAAK,GAAGA,KAAK;EACtB;EAEQwL,UAAU,CAAC9F,KAAa,EAAE1F,KAAa,EAAEuL,OAAkB;IAC/D,IAAIA,OAAO,CAAC7F,KAAK,CAAC,EAAE;MAChB;;IAGJ6F,OAAO,CAAC7F,KAAK,CAAC,GAAG,IAAI;IAErB,MAAMf,IAAI,GAAG,IAAI,CAAC3E,KAAK,CAAC0F,KAAK,CAAC;IAC9B,IAAI,CAACf,IAAI,EAAE;IAEX,IAAIA,IAAI,CAACC,MAAM,KAAKoG,SAAS,EAAE;MAC3BrG,IAAI,CAACC,MAAM,GAAGc,KAAK;;IAGvB,MAAMqB,UAAU,GAAGpC,IAAI,CAAClD,SAAS,EAAE;IACnC,IAAIsF,UAAU,EAAE;MACZ,IAAI,CAACyE,UAAU,CAAC,IAAI,CAACxL,KAAK,CAACuG,OAAO,CAACQ,UAAU,CAAC,EAAE/G,KAAK,EAAEuL,OAAO,CAAC;;IAGnEvL,KAAK,CAAC2D,IAAI,CAACgB,IAAI,CAAC;EACpB;EAEA;;;EAGO8G,oBAAoB;IACvB,IAAI,CAACzL,KAAK,CAACyJ,OAAO,CAAEjI,CAAC,IAAI;MACrBA,CAAC,CAACiK,oBAAoB,EAAE;IAC5B,CAAC,CAAC;EACN","names":["Bone","Observable","Vector3","Matrix","TmpVectors","RawTexture","Animation","AnimationRange","EngineStore","Logger","DeepCopier","Skeleton","constructor","name","id","scene","Array","Identity","bones","_scene","LastCreatedScene","_uniqueId","getUniqueId","addSkeleton","_isDirty","engineCaps","getEngine","getCaps","_canUseTextureForBones","textureFloat","maxVertexTextureImageUnits","useTextureToStoreBoneMatrices","_useTextureToStoreBoneMatrices","value","_markAsDirty","animationPropertiesOverride","_animationPropertiesOverride","isUsingTextureForMatrices","uniqueId","getClassName","getChildren","filter","b","getParent","getTransformMatrices","mesh","needInitialSkinMatrix","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","getScene","toString","fullDetails","ret","length","_ranges","Object","keys","first","getBoneIndexByName","boneIndex","cache","createAnimationRange","from","to","i","nBones","animations","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","push","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","returnToRest","bone","_index","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","MakeAnimationAdditive","skeleton","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","index","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animatable","animIndex","isAdditive","_absoluteTransformIsDirty","_registerMeshWithPoseMatrix","_meshesWithPoseMatrix","_unregisterMeshWithPoseMatrix","indexOf","splice","_computeTransformMatrices","targetMatrix","initialSkinMatrix","onBeforeComputeObservable","notifyObservers","_childUpdateId","parentBone","getLocalMatrix","multiplyToRef","getWorldMatrix","copyFrom","mappedIndex","getInvertedAbsoluteTransform","multiplyToArray","_identity","copyToArray","_numBonesWithLinkedTransformNode","_linkedTransformNode","node","position","rotationQuaternion","rotation","scaling","poseMatrix","getPoseMatrix","needsUpdate","Float32Array","_synchronizedWithMesh","matrix","getBaseMatrix","_updateDifferenceMatrix","textureWidth","getSize","width","dispose","CreateRGBATexture","update","_animatables","clone","result","parent","parentIndex","getRestPose","linkTransformNode","DeepCopy","rangeName","enableBlending","blendingSpeed","forEach","animation","stopAnimation","removeSkeleton","_parentContainer","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","getIndex","toArray","rest","linkedTransformNodeId","getTransformNode","metadata","ranges","Parse","parsedSkeleton","FromArray","parsedBone","parsedBoneIndex","undefined","_hasWaitingData","_waitingTransformNodeId","data","computeAbsoluteTransforms","forceUpdate","sortBones","visited","_sortBones","setCurrentPoseAsRest"],"sourceRoot":"","sources":["../../../../lts/core/generated/Bones/skeleton.ts"],"sourcesContent":["import { Bone } from \"./bone\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Animatable } from \"../Animations/animatable\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones = new Array<Bone>();\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _absoluteTransformIsDirty = true;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @internal */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @internal */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string,\r\n        scene: Scene\r\n    ) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: AbstractMesh): Float32Array {\r\n        if (this.needInitialSkinMatrix) {\r\n            if (!mesh._bonesTransformMatrices) {\r\n                this.prepare();\r\n            }\r\n\r\n            return mesh._bonesTransformMatrices!;\r\n        }\r\n\r\n        if (!this._transformMatrices) {\r\n            this.prepare();\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get bone's index searching by name\r\n     * @param name defines bone's name to search for\r\n     * @returns the indice of the bone. Returns -1 if not found\r\n     */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Create a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        let ret = true;\r\n        const frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\r\n        const boneDict: { [key: string]: Bone } = {};\r\n        const sourceBones = source.bones;\r\n        let nBones: number;\r\n        let i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            const boneName = this.bones[i].name;\r\n            const sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        const range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        for (const bone of this.bones) {\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        let ret = 0;\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                const highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        const rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        let rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            const sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        const animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n            const animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n        this._absoluteTransformIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            const parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\r\n                } else {\r\n                    bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                const mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     */\r\n    public prepare(): void {\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    const node = bone._linkedTransformNode;\r\n                    bone.position = node.position;\r\n                    if (node.rotationQuaternion) {\r\n                        bone.rotationQuaternion = node.rotationQuaternion;\r\n                    } else {\r\n                        bone.rotation = node.rotation;\r\n                    }\r\n                    bone.scaling = node.scaling;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (const mesh of this._meshesWithPoseMatrix) {\r\n                const poseMatrix = mesh.getPoseMatrix();\r\n\r\n                let needsUpdate = this._isDirty;\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                    needsUpdate = true;\r\n                }\r\n\r\n                if (!needsUpdate) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (const bone of this.bones) {\r\n                        if (!bone.getParent()) {\r\n                            const matrix = bone.getBaseMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateDifferenceMatrix(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                                mesh._bonesTransformMatrices,\r\n                                (this.bones.length + 1) * 4,\r\n                                1,\r\n                                this._scene,\r\n                                false,\r\n                                false,\r\n                                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                                Constants.TEXTURETYPE_FLOAT\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._isDirty) {\r\n                return;\r\n            }\r\n\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                        this._transformMatrices,\r\n                        (this.bones.length + 1) * 4,\r\n                        1,\r\n                        this._scene,\r\n                        false,\r\n                        false,\r\n                        Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTURETYPE_FLOAT\r\n                    );\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (let index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        const result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const source = this.bones[index];\r\n            let parentBone = null;\r\n\r\n            const parent = source.getParent();\r\n            if (parent) {\r\n                const parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            const bone = new Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (const rangeName in this._ranges) {\r\n                const range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        this.bones.forEach((bone) => {\r\n            bone.animations.forEach((animation: Animation) => {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix.length = 0;\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.skeletons.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.skeletons.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            const parent = bone.getParent();\r\n\r\n            const serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                id: bone.id,\r\n                matrix: bone.getBaseMatrix().toArray(),\r\n                rest: bone.getRestPose().toArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id,\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (const name in this._ranges) {\r\n                const source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                const range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            const parsedBone = parsedSkeleton.bones[index];\r\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            let parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            const rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                const data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute transforms\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n        if (this._absoluteTransformIsDirty || forceUpdate) {\r\n            this.bones[0].computeAbsoluteTransforms();\r\n            this._absoluteTransformIsDirty = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        let poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        const bones = new Array<Bone>();\r\n        const visited = new Array<boolean>(this.bones.length);\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        const bone = this.bones[index];\r\n        if (!bone) return;\r\n\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        const parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        this.bones.forEach((b) => {\r\n            b.setCurrentPoseAsRest();\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}