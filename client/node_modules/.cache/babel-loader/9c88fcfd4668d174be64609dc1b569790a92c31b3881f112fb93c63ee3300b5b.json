{"ast":null,"code":"import { RawTexture } from \"../Materials/Textures/rawTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { EncodeArrayBufferToBase64, DecodeBase64ToBinary } from \"../Misc/stringTools.js\";\n\n/**\n * Class to bake vertex animation textures.\n * @since 5.0\n */\nexport class VertexAnimationBaker {\n  /**\n   * Create a new VertexAnimationBaker object which can help baking animations into a texture.\n   * @param scene Defines the scene the VAT belongs to\n   * @param mesh Defines the mesh the VAT belongs to\n   */\n  constructor(scene, mesh) {\n    this._scene = scene;\n    this._mesh = mesh;\n  }\n  /**\n   * Bakes the animation into the texture. This should be called once, when the\n   * scene starts, so the VAT is generated and associated to the mesh.\n   * @param ranges Defines the ranges in the animation that will be baked.\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n  async bakeVertexData(ranges) {\n    if (!this._mesh.skeleton) {\n      throw new Error(\"No skeleton in this mesh.\");\n    }\n    const boneCount = this._mesh.skeleton.bones.length;\n    /** total number of frames in our animations */\n    const frameCount = ranges.reduce((previous, current) => previous + current.to - current.from + 1, 0);\n    if (isNaN(frameCount)) {\n      throw new Error(\"Invalid animation ranges.\");\n    }\n    // reset our loop data\n    let textureIndex = 0;\n    const textureSize = (boneCount + 1) * 4 * 4 * frameCount;\n    const vertexData = new Float32Array(textureSize);\n    this._scene.stopAnimation(this._mesh);\n    this._mesh.skeleton.returnToRest();\n    // render all frames from our slices\n    for (const range of ranges) {\n      for (let frameIndex = range.from; frameIndex <= range.to; frameIndex++) {\n        await this._executeAnimationFrame(vertexData, frameIndex, textureIndex++);\n      }\n    }\n    return vertexData;\n  }\n  /**\n   * Runs an animation frame and stores its vertex data\n   *\n   * @param vertexData The array to save data to.\n   * @param frameIndex Current frame in the skeleton animation to render.\n   * @param textureIndex Current index of the texture data.\n   */\n  async _executeAnimationFrame(vertexData, frameIndex, textureIndex) {\n    return new Promise((resolve, _reject) => {\n      this._scene.beginAnimation(this._mesh.skeleton, frameIndex, frameIndex, false, 1.0, () => {\n        // generate matrices\n        const skeletonMatrices = this._mesh.skeleton.getTransformMatrices(this._mesh);\n        vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);\n        resolve();\n      });\n    });\n  }\n  /**\n   * Builds a vertex animation texture given the vertexData in an array.\n   * @param vertexData The vertex animation data. You can generate it with bakeVertexData().\n   * @returns The vertex animation texture to be used with BakedVertexAnimationManager.\n   */\n  textureFromBakedVertexData(vertexData) {\n    if (!this._mesh.skeleton) {\n      throw new Error(\"No skeleton in this mesh.\");\n    }\n    const boneCount = this._mesh.skeleton.bones.length;\n    const texture = RawTexture.CreateRGBATexture(vertexData, (boneCount + 1) * 4, vertexData.length / ((boneCount + 1) * 4 * 4), this._scene, false, false, Texture.NEAREST_NEAREST, 1);\n    texture.name = \"VAT\" + this._mesh.skeleton.name;\n    return texture;\n  }\n  /**\n   * Serializes our vertexData to an object, with a nice string for the vertexData.\n   * @param vertexData The vertex array data.\n   * @returns This object serialized to a JS dict.\n   */\n  serializeBakedVertexDataToObject(vertexData) {\n    if (!this._mesh.skeleton) {\n      throw new Error(\"No skeleton in this mesh.\");\n    }\n    // this converts the float array to a serialized base64 string, ~1.3x larger\n    // than the original.\n    const boneCount = this._mesh.skeleton.bones.length;\n    const width = (boneCount + 1) * 4;\n    const height = vertexData.length / ((boneCount + 1) * 4 * 4);\n    const data = {\n      vertexData: EncodeArrayBufferToBase64(vertexData),\n      width,\n      height\n    };\n    return data;\n  }\n  /**\n   * Loads previously baked data.\n   * @param data The object as serialized by serializeBakedVertexDataToObject()\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n  loadBakedVertexDataFromObject(data) {\n    return new Float32Array(DecodeBase64ToBinary(data.vertexData));\n  }\n  /**\n   * Serializes our vertexData to a JSON string, with a nice string for the vertexData.\n   * Should be called right after bakeVertexData().\n   * @param vertexData The vertex array data.\n   * @returns This object serialized to a safe string.\n   */\n  serializeBakedVertexDataToJSON(vertexData) {\n    return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));\n  }\n  /**\n   * Loads previously baked data in string format.\n   * @param json The json string as serialized by serializeBakedVertexDataToJSON().\n   * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\n   */\n  loadBakedVertexDataFromJSON(json) {\n    return this.loadBakedVertexDataFromObject(JSON.parse(json));\n  }\n}","map":{"version":3,"mappings":"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","names":["RawTexture","Texture","EncodeArrayBufferToBase64","DecodeBase64ToBinary","VertexAnimationBaker","constructor","scene","mesh","_scene","_mesh","bakeVertexData","ranges","skeleton","Error","boneCount","bones","length","frameCount","reduce","previous","current","to","from","isNaN","textureIndex","textureSize","vertexData","Float32Array","stopAnimation","returnToRest","range","frameIndex","_executeAnimationFrame","Promise","resolve","_reject","beginAnimation","skeletonMatrices","getTransformMatrices","set","textureFromBakedVertexData","texture","CreateRGBATexture","NEAREST_NEAREST","name","serializeBakedVertexDataToObject","width","height","data","loadBakedVertexDataFromObject","serializeBakedVertexDataToJSON","JSON","stringify","loadBakedVertexDataFromJSON","json","parse"],"sourceRoot":"","sources":["../../../../lts/core/generated/BakedVertexAnimation/vertexAnimationBaker.ts"],"sourcesContent":["import type { AnimationRange } from \"../Animations/animationRange\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { EncodeArrayBufferToBase64, DecodeBase64ToBinary } from \"../Misc/stringTools\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Class to bake vertex animation textures.\r\n * @since 5.0\r\n */\r\nexport class VertexAnimationBaker {\r\n    private _scene: Scene;\r\n    private _mesh: Mesh;\r\n\r\n    /**\r\n     * Create a new VertexAnimationBaker object which can help baking animations into a texture.\r\n     * @param scene Defines the scene the VAT belongs to\r\n     * @param mesh Defines the mesh the VAT belongs to\r\n     */\r\n    constructor(scene: Scene, mesh: Mesh) {\r\n        this._scene = scene;\r\n        this._mesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Bakes the animation into the texture. This should be called once, when the\r\n     * scene starts, so the VAT is generated and associated to the mesh.\r\n     * @param ranges Defines the ranges in the animation that will be baked.\r\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\r\n     */\r\n    public async bakeVertexData(ranges: AnimationRange[]): Promise<Float32Array> {\r\n        if (!this._mesh.skeleton) {\r\n            throw new Error(\"No skeleton in this mesh.\");\r\n        }\r\n        const boneCount = this._mesh.skeleton.bones.length;\r\n\r\n        /** total number of frames in our animations */\r\n        const frameCount = ranges.reduce((previous: number, current: AnimationRange) => previous + current.to - current.from + 1, 0);\r\n\r\n        if (isNaN(frameCount)) {\r\n            throw new Error(\"Invalid animation ranges.\");\r\n        }\r\n\r\n        // reset our loop data\r\n        let textureIndex = 0;\r\n        const textureSize = (boneCount + 1) * 4 * 4 * frameCount;\r\n        const vertexData = new Float32Array(textureSize);\r\n        this._scene.stopAnimation(this._mesh);\r\n        this._mesh.skeleton.returnToRest();\r\n\r\n        // render all frames from our slices\r\n        for (const range of ranges) {\r\n            for (let frameIndex = range.from; frameIndex <= range.to; frameIndex++) {\r\n                await this._executeAnimationFrame(vertexData, frameIndex, textureIndex++);\r\n            }\r\n        }\r\n\r\n        return vertexData;\r\n    }\r\n\r\n    /**\r\n     * Runs an animation frame and stores its vertex data\r\n     *\r\n     * @param vertexData The array to save data to.\r\n     * @param frameIndex Current frame in the skeleton animation to render.\r\n     * @param textureIndex Current index of the texture data.\r\n     */\r\n    private async _executeAnimationFrame(vertexData: Float32Array, frameIndex: number, textureIndex: number): Promise<void> {\r\n        return new Promise<void>((resolve, _reject) => {\r\n            this._scene.beginAnimation(this._mesh.skeleton, frameIndex, frameIndex, false, 1.0, () => {\r\n                // generate matrices\r\n                const skeletonMatrices = this._mesh.skeleton!.getTransformMatrices(this._mesh);\r\n                vertexData.set(skeletonMatrices, textureIndex * skeletonMatrices.length);\r\n\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Builds a vertex animation texture given the vertexData in an array.\r\n     * @param vertexData The vertex animation data. You can generate it with bakeVertexData().\r\n     * @returns The vertex animation texture to be used with BakedVertexAnimationManager.\r\n     */\r\n    public textureFromBakedVertexData(vertexData: Float32Array): RawTexture {\r\n        if (!this._mesh.skeleton) {\r\n            throw new Error(\"No skeleton in this mesh.\");\r\n        }\r\n        const boneCount = this._mesh.skeleton.bones.length;\r\n\r\n        const texture = RawTexture.CreateRGBATexture(\r\n            vertexData,\r\n            (boneCount + 1) * 4,\r\n            vertexData.length / ((boneCount + 1) * 4 * 4),\r\n            this._scene,\r\n            false,\r\n            false,\r\n            Texture.NEAREST_NEAREST,\r\n            Constants.TEXTURETYPE_FLOAT\r\n        );\r\n        texture.name = \"VAT\" + this._mesh.skeleton.name;\r\n        return texture;\r\n    }\r\n    /**\r\n     * Serializes our vertexData to an object, with a nice string for the vertexData.\r\n     * @param vertexData The vertex array data.\r\n     * @returns This object serialized to a JS dict.\r\n     */\r\n    public serializeBakedVertexDataToObject(vertexData: Float32Array): Record<string, any> {\r\n        if (!this._mesh.skeleton) {\r\n            throw new Error(\"No skeleton in this mesh.\");\r\n        }\r\n\r\n        // this converts the float array to a serialized base64 string, ~1.3x larger\r\n        // than the original.\r\n        const boneCount = this._mesh.skeleton.bones.length;\r\n        const width = (boneCount + 1) * 4;\r\n        const height = vertexData.length / ((boneCount + 1) * 4 * 4);\r\n        const data = {\r\n            vertexData: EncodeArrayBufferToBase64(vertexData),\r\n            width,\r\n            height,\r\n        };\r\n        return data;\r\n    }\r\n    /**\r\n     * Loads previously baked data.\r\n     * @param data The object as serialized by serializeBakedVertexDataToObject()\r\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\r\n     */\r\n    public loadBakedVertexDataFromObject(data: Record<string, any>): Float32Array {\r\n        return new Float32Array(DecodeBase64ToBinary(data.vertexData));\r\n    }\r\n    /**\r\n     * Serializes our vertexData to a JSON string, with a nice string for the vertexData.\r\n     * Should be called right after bakeVertexData().\r\n     * @param vertexData The vertex array data.\r\n     * @returns This object serialized to a safe string.\r\n     */\r\n    public serializeBakedVertexDataToJSON(vertexData: Float32Array): string {\r\n        return JSON.stringify(this.serializeBakedVertexDataToObject(vertexData));\r\n    }\r\n    /**\r\n     * Loads previously baked data in string format.\r\n     * @param json The json string as serialized by serializeBakedVertexDataToJSON().\r\n     * @returns The array of matrix transforms for each vertex (columns) and frame (rows), as a Float32Array.\r\n     */\r\n    public loadBakedVertexDataFromJSON(json: string): Float32Array {\r\n        return this.loadBakedVertexDataFromObject(JSON.parse(json));\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}