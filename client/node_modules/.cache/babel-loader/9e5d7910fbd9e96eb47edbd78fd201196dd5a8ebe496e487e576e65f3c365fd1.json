{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\nimport { Path3D } from \"../../Maths/math.path.js\";\n/**\n * Creates a tube mesh.\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.path\n * @param options.radius\n * @param options.tessellation\n * @param options.radiusFunction\n * @param options.cap\n * @param options.arc\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.instance\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the tube mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\n */\nexport function CreateTube(name, options, scene = null) {\n  const path = options.path;\n  let instance = options.instance;\n  let radius = 1.0;\n  if (options.radius !== undefined) {\n    radius = options.radius;\n  } else if (instance) {\n    radius = instance._creationDataStorage.radius;\n  }\n  const tessellation = options.tessellation || 64 | 0;\n  const radiusFunction = options.radiusFunction || null;\n  let cap = options.cap || Mesh.NO_CAP;\n  const invertUV = options.invertUV || false;\n  const updatable = options.updatable;\n  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\n  // tube geometry\n  const tubePathArray = (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) => {\n    const tangents = path3D.getTangents();\n    const normals = path3D.getNormals();\n    const distances = path3D.getDistances();\n    const pi2 = Math.PI * 2;\n    const step = pi2 / tessellation * arc;\n    const returnRadius = () => radius;\n    const radiusFunctionFinal = radiusFunction || returnRadius;\n    let circlePath;\n    let rad;\n    let normal;\n    let rotated;\n    const rotationMatrix = TmpVectors.Matrix[0];\n    let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\n    for (let i = 0; i < path.length; i++) {\n      rad = radiusFunctionFinal(i, distances[i]); // current radius\n      circlePath = Array(); // current circle array\n      normal = normals[i]; // current normal\n      for (let t = 0; t < tessellation; t++) {\n        Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n        rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n        rotated.scaleInPlace(rad).addInPlace(path[i]);\n        circlePath[t] = rotated;\n      }\n      circlePaths[index] = circlePath;\n      index++;\n    }\n    // cap\n    const capPath = (nbPoints, pathIndex) => {\n      const pointCap = Array();\n      for (let i = 0; i < nbPoints; i++) {\n        pointCap.push(path[pathIndex]);\n      }\n      return pointCap;\n    };\n    switch (cap) {\n      case Mesh.NO_CAP:\n        break;\n      case Mesh.CAP_START:\n        circlePaths[0] = capPath(tessellation, 0);\n        circlePaths[1] = circlePaths[2].slice(0);\n        break;\n      case Mesh.CAP_END:\n        circlePaths[index] = circlePaths[index - 1].slice(0);\n        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n        break;\n      case Mesh.CAP_ALL:\n        circlePaths[0] = capPath(tessellation, 0);\n        circlePaths[1] = circlePaths[2].slice(0);\n        circlePaths[index] = circlePaths[index - 1].slice(0);\n        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n        break;\n      default:\n        break;\n    }\n    return circlePaths;\n  };\n  let path3D;\n  let pathArray;\n  if (instance) {\n    // tube update\n    const storage = instance._creationDataStorage;\n    const arc = options.arc || storage.arc;\n    path3D = storage.path3D.update(path);\n    pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\n    instance = CreateRibbon(\"\", {\n      pathArray: pathArray,\n      instance: instance\n    });\n    // Update mode, no need to recreate the storage.\n    storage.path3D = path3D;\n    storage.pathArray = pathArray;\n    storage.arc = arc;\n    storage.radius = radius;\n    return instance;\n  }\n  // tube creation\n  path3D = new Path3D(path);\n  const newPathArray = new Array();\n  cap = cap < 0 || cap > 3 ? 0 : cap;\n  pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n  const tube = CreateRibbon(name, {\n    pathArray: pathArray,\n    closePath: true,\n    closeArray: false,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    invertUV: invertUV,\n    frontUVs: options.frontUVs,\n    backUVs: options.backUVs\n  }, scene);\n  tube._creationDataStorage.pathArray = pathArray;\n  tube._creationDataStorage.path3D = path3D;\n  tube._creationDataStorage.tessellation = tessellation;\n  tube._creationDataStorage.cap = cap;\n  tube._creationDataStorage.arc = options.arc;\n  tube._creationDataStorage.radius = radius;\n  return tube;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use CreateTube directly\n */\nexport const TubeBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateTube\n};\nMesh.CreateTube = (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) => {\n  const options = {\n    path: path,\n    radius: radius,\n    tessellation: tessellation,\n    radiusFunction: radiusFunction,\n    arc: 1,\n    cap: cap,\n    updatable: updatable,\n    sideOrientation: sideOrientation,\n    instance: instance\n  };\n  return CreateTube(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","TmpVectors","Matrix","Mesh","CreateRibbon","Path3D","CreateTube","name","options","scene","path","instance","radius","undefined","_creationDataStorage","tessellation","radiusFunction","cap","NO_CAP","invertUV","updatable","sideOrientation","_GetDefaultSideOrientation","arc","tubePathArray","path3D","circlePaths","tangents","getTangents","normals","getNormals","distances","getDistances","pi2","Math","PI","step","returnRadius","radiusFunctionFinal","circlePath","rad","normal","rotated","rotationMatrix","index","CAP_END","i","length","Array","t","RotationAxisToRef","Zero","TransformCoordinatesToRef","scaleInPlace","addInPlace","capPath","nbPoints","pathIndex","pointCap","push","CAP_START","slice","CAP_ALL","pathArray","storage","update","newPathArray","tube","closePath","closeArray","frontUVs","backUVs","TubeBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/tubeBuilder.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3, TmpVectors, Matrix } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport { Path3D } from \"../../Maths/math.path\";\r\n\r\n/**\r\n * Creates a tube mesh.\r\n * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overrides the parameter `radius`\r\n * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter. The `path`Array HAS to have the SAME number of points as the previous one: https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#tube\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created. The NUMBER of points CAN'T CHANGE, only their positions.\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.path\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.radiusFunction\r\n * @param options.cap\r\n * @param options.arc\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.instance\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the tube mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tube\r\n */\r\nexport function CreateTube(\r\n    name: string,\r\n    options: {\r\n        path: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        radiusFunction?: { (i: number, distance: number): number };\r\n        cap?: number;\r\n        arc?: number;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        instance?: Mesh;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const path = options.path;\r\n    let instance = options.instance;\r\n    let radius = 1.0;\r\n\r\n    if (options.radius !== undefined) {\r\n        radius = options.radius;\r\n    } else if (instance) {\r\n        radius = instance._creationDataStorage!.radius;\r\n    }\r\n\r\n    const tessellation = options.tessellation || 64 | 0;\r\n    const radiusFunction = options.radiusFunction || null;\r\n    let cap = options.cap || Mesh.NO_CAP;\r\n    const invertUV = options.invertUV || false;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n\r\n    // tube geometry\r\n    const tubePathArray = (\r\n        path: Vector3[],\r\n        path3D: Path3D,\r\n        circlePaths: Vector3[][],\r\n        radius: number,\r\n        tessellation: number,\r\n        radiusFunction: Nullable<{ (i: number, distance: number): number }>,\r\n        cap: number,\r\n        arc: number\r\n    ) => {\r\n        const tangents = path3D.getTangents();\r\n        const normals = path3D.getNormals();\r\n        const distances = path3D.getDistances();\r\n        const pi2 = Math.PI * 2;\r\n        const step = (pi2 / tessellation) * arc;\r\n        const returnRadius: { (i: number, distance: number): number } = () => radius;\r\n        const radiusFunctionFinal: { (i: number, distance: number): number } = radiusFunction || returnRadius;\r\n\r\n        let circlePath: Vector3[];\r\n        let rad: number;\r\n        let normal: Vector3;\r\n        let rotated: Vector3;\r\n        const rotationMatrix: Matrix = TmpVectors.Matrix[0];\r\n        let index = cap === Mesh.NO_CAP || cap === Mesh.CAP_END ? 0 : 2;\r\n        for (let i = 0; i < path.length; i++) {\r\n            rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n            circlePath = Array<Vector3>(); // current circle array\r\n            normal = normals[i]; // current normal\r\n            for (let t = 0; t < tessellation; t++) {\r\n                Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                rotated = circlePath[t] ? circlePath[t] : Vector3.Zero();\r\n                Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                circlePath[t] = rotated;\r\n            }\r\n            circlePaths[index] = circlePath;\r\n            index++;\r\n        }\r\n        // cap\r\n        const capPath = (nbPoints: number, pathIndex: number): Array<Vector3> => {\r\n            const pointCap = Array<Vector3>();\r\n            for (let i = 0; i < nbPoints; i++) {\r\n                pointCap.push(path[pathIndex]);\r\n            }\r\n            return pointCap;\r\n        };\r\n        switch (cap) {\r\n            case Mesh.NO_CAP:\r\n                break;\r\n            case Mesh.CAP_START:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                break;\r\n            case Mesh.CAP_END:\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            case Mesh.CAP_ALL:\r\n                circlePaths[0] = capPath(tessellation, 0);\r\n                circlePaths[1] = circlePaths[2].slice(0);\r\n                circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        return circlePaths;\r\n    };\r\n\r\n    let path3D;\r\n    let pathArray;\r\n    if (instance) {\r\n        // tube update\r\n        const storage = instance._creationDataStorage!;\r\n        const arc = options.arc || storage.arc;\r\n        path3D = storage.path3D.update(path);\r\n        pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n        instance = CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n        // Update mode, no need to recreate the storage.\r\n        storage.path3D = path3D;\r\n        storage.pathArray = pathArray;\r\n        storage.arc = arc;\r\n        storage.radius = radius;\r\n\r\n        return instance;\r\n    }\r\n\r\n    // tube creation\r\n    path3D = <any>new Path3D(path);\r\n    const newPathArray = new Array<Array<Vector3>>();\r\n    cap = cap < 0 || cap > 3 ? 0 : cap;\r\n    pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n    const tube = CreateRibbon(\r\n        name,\r\n        {\r\n            pathArray: pathArray,\r\n            closePath: true,\r\n            closeArray: false,\r\n            updatable: updatable,\r\n            sideOrientation: sideOrientation,\r\n            invertUV: invertUV,\r\n            frontUVs: options.frontUVs,\r\n            backUVs: options.backUVs,\r\n        },\r\n        scene\r\n    );\r\n    tube._creationDataStorage!.pathArray = pathArray;\r\n    tube._creationDataStorage!.path3D = path3D;\r\n    tube._creationDataStorage!.tessellation = tessellation;\r\n    tube._creationDataStorage!.cap = cap;\r\n    tube._creationDataStorage!.arc = options.arc;\r\n    tube._creationDataStorage!.radius = radius;\r\n\r\n    return tube;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use CreateTube directly\r\n */\r\nexport const TubeBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTube,\r\n};\r\n\r\n(Mesh as any).CreateTube = (\r\n    name: string,\r\n    path: Vector3[],\r\n    radius: number,\r\n    tessellation: number,\r\n    radiusFunction: { (i: number, distance: number): number },\r\n    cap: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    instance?: Mesh\r\n): Mesh => {\r\n    const options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n    };\r\n    return CreateTube(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}