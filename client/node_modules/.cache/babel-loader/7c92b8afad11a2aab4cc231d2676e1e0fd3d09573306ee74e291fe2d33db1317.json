{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SceneSerializer } from \"./sceneSerializer.js\";\nimport { Mesh } from \"../Meshes/mesh.js\";\nimport { Light } from \"../Lights/light.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { Skeleton } from \"../Bones/skeleton.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { TransformNode } from \"../Meshes/transformNode.js\";\nimport { ParticleSystem } from \"../Particles/particleSystem.js\";\nimport { MorphTargetManager } from \"../Morph/morphTargetManager.js\";\nimport { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { SerializationHelper } from \"./decorators.js\";\n/**\n * Class used to record delta files between 2 scene states\n */\nexport class SceneRecorder {\n  constructor() {\n    this._trackedScene = null;\n  }\n  /**\n   * Track a given scene. This means the current scene state will be considered the original state\n   * @param scene defines the scene to track\n   */\n  track(scene) {\n    this._trackedScene = scene;\n    SerializationHelper.AllowLoadingUniqueId = true;\n    this._savedJSON = SceneSerializer.Serialize(scene);\n    SerializationHelper.AllowLoadingUniqueId = false;\n  }\n  /**\n   * Get the delta between current state and original state\n   * @returns a any containing the delta\n   */\n  getDelta() {\n    if (!this._trackedScene) {\n      return null;\n    }\n    const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;\n    Texture.ForceSerializeBuffers = false;\n    SerializationHelper.AllowLoadingUniqueId = true;\n    const newJSON = SceneSerializer.Serialize(this._trackedScene);\n    SerializationHelper.AllowLoadingUniqueId = false;\n    const deltaJSON = {};\n    for (const node in newJSON) {\n      this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\n    }\n    Texture.ForceSerializeBuffers = currentForceSerializeBuffers;\n    return deltaJSON;\n  }\n  _compareArray(key, original, current, deltaJSON) {\n    if (original.length === 0 && current.length === 0) {\n      return true;\n    }\n    // Numbers?\n    if (original.length && !isNaN(original[0]) || current.length && !isNaN(current[0])) {\n      if (original.length !== current.length) {\n        return false;\n      }\n      if (original.length === 0) {\n        return true;\n      }\n      for (let index = 0; index < original.length; index++) {\n        if (original[index] !== current[index]) {\n          deltaJSON[key] = current;\n          return false;\n        }\n      }\n      return true;\n    }\n    // let's use uniqueId to find similar objects\n    const originalUniqueIds = [];\n    for (let index = 0; index < original.length; index++) {\n      const originalObject = original[index];\n      const originalUniqueId = originalObject.uniqueId;\n      originalUniqueIds.push(originalUniqueId);\n      // Look for that object in current state\n      const currentObjects = current.filter(c => c.uniqueId === originalUniqueId);\n      if (currentObjects.length) {\n        // We have a candidate\n        const currentObject = currentObjects[0];\n        const newObject = {};\n        if (!this._compareObjects(originalObject, currentObject, newObject)) {\n          if (!deltaJSON[key]) {\n            deltaJSON[key] = [];\n          }\n          newObject.__state = {\n            id: currentObject.id || currentObject.name\n          };\n          deltaJSON[key].push(newObject);\n        }\n      } else {\n        // We need to delete\n        const newObject = {\n          __state: {\n            deleteId: originalObject.id || originalObject.name\n          }\n        };\n        deltaJSON[key].push(newObject);\n      }\n    }\n    // Checking for new objects\n    for (let index = 0; index < current.length; index++) {\n      const currentObject = current[index];\n      const currentUniqueId = currentObject.uniqueId;\n      // Object was added\n      if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\n        if (!deltaJSON[key]) {\n          deltaJSON[key] = [];\n        }\n        deltaJSON[key].push(currentObject);\n      }\n    }\n    return true;\n  }\n  _compareObjects(originalObjet, currentObject, deltaJSON) {\n    let aDifferenceWasFound = false;\n    for (const prop in originalObjet) {\n      if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {\n        continue;\n      }\n      const originalValue = originalObjet[prop];\n      const currentValue = currentObject[prop];\n      let diffFound = false;\n      if (Array.isArray(originalValue)) {\n        diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\n      } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == \"[object String]\") {\n        diffFound = originalValue !== currentValue;\n      } else if (typeof originalValue === \"object\" && typeof currentValue === \"object\") {\n        const newObject = {};\n        if (!this._compareObjects(originalValue, currentValue, newObject)) {\n          deltaJSON[prop] = newObject;\n          aDifferenceWasFound = true;\n        }\n      }\n      if (diffFound) {\n        aDifferenceWasFound = true;\n        deltaJSON[prop] = currentValue;\n      }\n    }\n    return !aDifferenceWasFound;\n  }\n  _compareCollections(key, original, current, deltaJSON) {\n    // Same ?\n    if (original === current) {\n      return;\n    }\n    if (original && current) {\n      // Array?\n      if (Array.isArray(original) && Array.isArray(current)) {\n        if (this._compareArray(key, original, current, deltaJSON)) {\n          return;\n        }\n      } else if (typeof original === \"object\" && typeof current === \"object\") {\n        // Object\n        const newObject = {};\n        if (!this._compareObjects(original, current, newObject)) {\n          deltaJSON[key] = newObject;\n        }\n        return;\n      }\n    }\n  }\n  static GetShadowGeneratorById(scene, id) {\n    const allGenerators = scene.lights.map(l => l.getShadowGenerators());\n    for (const generators of allGenerators) {\n      if (generators) {\n        const iterator = generators.values();\n        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n          const generator = key.value;\n          if (generator && generator.id === id) {\n            return generator;\n          }\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Apply a given delta to a given scene\n   * @param deltaJSON defines the JSON containing the delta\n   * @param scene defines the scene to apply the delta to\n   */\n  static ApplyDelta(deltaJSON, scene) {\n    if (typeof deltaJSON === \"string\") {\n      deltaJSON = JSON.parse(deltaJSON);\n    }\n    // Scene\n    const anyScene = scene;\n    for (const prop in deltaJSON) {\n      const source = deltaJSON[prop];\n      const property = anyScene[prop];\n      if (Array.isArray(property) || prop === \"shadowGenerators\") {\n        // Restore array\n        switch (prop) {\n          case \"cameras\":\n            this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), data => Camera.Parse(data, scene));\n            break;\n          case \"lights\":\n            this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), data => Light.Parse(data, scene));\n            break;\n          case \"shadowGenerators\":\n            this._ApplyDeltaForEntity(source, scene, id => this.GetShadowGeneratorById(scene, id), data => ShadowGenerator.Parse(data, scene));\n            break;\n          case \"meshes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), data => Mesh.Parse(data, scene, \"\"));\n            break;\n          case \"skeletons\":\n            this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), data => Skeleton.Parse(data, scene));\n            break;\n          case \"materials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), data => Material.Parse(data, scene, \"\"));\n            break;\n          case \"multiMaterials\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), data => MultiMaterial.Parse(data, scene, \"\"));\n            break;\n          case \"transformNodes\":\n            this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), data => TransformNode.Parse(data, scene, \"\"));\n            break;\n          case \"particleSystems\":\n            this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), data => ParticleSystem.Parse(data, scene, \"\"));\n            break;\n          case \"morphTargetManagers\":\n            this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), data => MorphTargetManager.Parse(data, scene));\n            break;\n          case \"postProcesses\":\n            this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), data => PostProcess.Parse(data, scene, \"\"));\n            break;\n        }\n      } else if (!isNaN(property)) {\n        anyScene[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      }\n    }\n  }\n  static _ApplyPropertiesToEntity(deltaJSON, entity) {\n    for (const prop in deltaJSON) {\n      const source = deltaJSON[prop];\n      const property = entity[prop];\n      if (property === undefined) {\n        continue;\n      }\n      if (!isNaN(property) || Array.isArray(property)) {\n        entity[prop] = source;\n      } else if (property.fromArray) {\n        property.fromArray(source);\n      } else if (typeof property === \"object\" && property !== null) {\n        this._ApplyPropertiesToEntity(source, property);\n      }\n    }\n  }\n  static _ApplyDeltaForEntity(sources, scene, finder, addNew) {\n    for (const source of sources) {\n      // Update\n      if (source.__state && source.__state.id !== undefined) {\n        const targetEntity = finder(source.__state.id);\n        if (targetEntity) {\n          this._ApplyPropertiesToEntity(source, targetEntity);\n        }\n      } else if (source.__state && source.__state.deleteId !== undefined) {\n        const target = finder(source.__state.deleteId);\n        target === null || target === void 0 ? void 0 : target.dispose();\n      } else {\n        // New\n        addNew(source);\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["SceneSerializer","Mesh","Light","Camera","Skeleton","Material","MultiMaterial","TransformNode","ParticleSystem","MorphTargetManager","ShadowGenerator","PostProcess","Texture","SerializationHelper","SceneRecorder","constructor","track","scene","_trackedScene","AllowLoadingUniqueId","_savedJSON","Serialize","getDelta","currentForceSerializeBuffers","ForceSerializeBuffers","newJSON","deltaJSON","node","_compareCollections","_compareArray","key","original","current","length","isNaN","index","originalUniqueIds","originalObject","originalUniqueId","uniqueId","push","currentObjects","filter","c","currentObject","newObject","_compareObjects","__state","id","name","deleteId","currentUniqueId","indexOf","originalObjet","aDifferenceWasFound","prop","Object","prototype","hasOwnProperty","call","originalValue","currentValue","diffFound","Array","isArray","JSON","stringify","toString","GetShadowGeneratorById","allGenerators","lights","map","l","getShadowGenerators","generators","iterator","values","next","done","generator","value","ApplyDelta","parse","anyScene","source","property","_ApplyDeltaForEntity","getCameraById","bind","data","Parse","getLightById","getMeshById","getSkeletonById","getMaterialById","getTransformNodeById","getParticleSystemById","getMorphTargetById","getPostProcessByName","fromArray","_ApplyPropertiesToEntity","entity","undefined","sources","finder","addNew","targetEntity","target","dispose"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/sceneRecorder.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport { SceneSerializer } from \"./sceneSerializer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Light } from \"../Lights/light\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport { Skeleton } from \"../Bones/skeleton\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport { TransformNode } from \"../Meshes/transformNode\";\r\nimport { ParticleSystem } from \"../Particles/particleSystem\";\r\nimport { MorphTargetManager } from \"../Morph/morphTargetManager\";\r\nimport { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { SerializationHelper } from \"./decorators\";\r\n\r\n/**\r\n * Class used to record delta files between 2 scene states\r\n */\r\nexport class SceneRecorder {\r\n    private _trackedScene: Nullable<Scene> = null;\r\n    private _savedJSON: any;\r\n\r\n    /**\r\n     * Track a given scene. This means the current scene state will be considered the original state\r\n     * @param scene defines the scene to track\r\n     */\r\n    public track(scene: Scene) {\r\n        this._trackedScene = scene;\r\n\r\n        SerializationHelper.AllowLoadingUniqueId = true;\r\n        this._savedJSON = SceneSerializer.Serialize(scene);\r\n        SerializationHelper.AllowLoadingUniqueId = false;\r\n    }\r\n\r\n    /**\r\n     * Get the delta between current state and original state\r\n     * @returns a any containing the delta\r\n     */\r\n    public getDelta(): any {\r\n        if (!this._trackedScene) {\r\n            return null;\r\n        }\r\n\r\n        const currentForceSerializeBuffers = Texture.ForceSerializeBuffers;\r\n        Texture.ForceSerializeBuffers = false;\r\n\r\n        SerializationHelper.AllowLoadingUniqueId = true;\r\n        const newJSON = SceneSerializer.Serialize(this._trackedScene);\r\n        SerializationHelper.AllowLoadingUniqueId = false;\r\n        const deltaJSON: any = {};\r\n\r\n        for (const node in newJSON) {\r\n            this._compareCollections(node, this._savedJSON[node], newJSON[node], deltaJSON);\r\n        }\r\n\r\n        Texture.ForceSerializeBuffers = currentForceSerializeBuffers;\r\n\r\n        return deltaJSON;\r\n    }\r\n\r\n    private _compareArray(key: string, original: any[], current: any[], deltaJSON: any) {\r\n        if (original.length === 0 && current.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        // Numbers?\r\n        if ((original.length && !isNaN(original[0])) || (current.length && !isNaN(current[0]))) {\r\n            if (original.length !== current.length) {\r\n                return false;\r\n            }\r\n\r\n            if (original.length === 0) {\r\n                return true;\r\n            }\r\n            for (let index = 0; index < original.length; index++) {\r\n                if (original[index] !== current[index]) {\r\n                    deltaJSON[key] = current;\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        // let's use uniqueId to find similar objects\r\n        const originalUniqueIds: number[] = [];\r\n        for (let index = 0; index < original.length; index++) {\r\n            const originalObject = original[index];\r\n            const originalUniqueId = originalObject.uniqueId;\r\n\r\n            originalUniqueIds.push(originalUniqueId);\r\n            // Look for that object in current state\r\n            const currentObjects = current.filter((c) => c.uniqueId === originalUniqueId);\r\n            if (currentObjects.length) {\r\n                // We have a candidate\r\n                const currentObject = currentObjects[0];\r\n\r\n                const newObject: any = {};\r\n                if (!this._compareObjects(originalObject, currentObject, newObject)) {\r\n                    if (!deltaJSON[key]) {\r\n                        deltaJSON[key] = [];\r\n                    }\r\n                    newObject.__state = {\r\n                        id: currentObject.id || currentObject.name,\r\n                    };\r\n                    deltaJSON[key].push(newObject);\r\n                }\r\n            } else {\r\n                // We need to delete\r\n                const newObject: any = {\r\n                    __state: {\r\n                        deleteId: originalObject.id || originalObject.name,\r\n                    },\r\n                };\r\n                deltaJSON[key].push(newObject);\r\n            }\r\n        }\r\n\r\n        // Checking for new objects\r\n        for (let index = 0; index < current.length; index++) {\r\n            const currentObject = current[index];\r\n            const currentUniqueId = currentObject.uniqueId;\r\n\r\n            // Object was added\r\n            if (originalUniqueIds.indexOf(currentUniqueId) === -1) {\r\n                if (!deltaJSON[key]) {\r\n                    deltaJSON[key] = [];\r\n                }\r\n\r\n                deltaJSON[key].push(currentObject);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _compareObjects(originalObjet: any, currentObject: any, deltaJSON: any) {\r\n        let aDifferenceWasFound = false;\r\n\r\n        for (const prop in originalObjet) {\r\n            if (!Object.prototype.hasOwnProperty.call(originalObjet, prop)) {\r\n                continue;\r\n            }\r\n            const originalValue = originalObjet[prop];\r\n            const currentValue = currentObject[prop];\r\n            let diffFound = false;\r\n\r\n            if (Array.isArray(originalValue)) {\r\n                diffFound = JSON.stringify(originalValue) !== JSON.stringify(currentValue);\r\n            } else if (!isNaN(originalValue) || Object.prototype.toString.call(originalValue) == \"[object String]\") {\r\n                diffFound = originalValue !== currentValue;\r\n            } else if (typeof originalValue === \"object\" && typeof currentValue === \"object\") {\r\n                const newObject = {};\r\n                if (!this._compareObjects(originalValue, currentValue, newObject)) {\r\n                    deltaJSON[prop] = newObject;\r\n                    aDifferenceWasFound = true;\r\n                }\r\n            }\r\n\r\n            if (diffFound) {\r\n                aDifferenceWasFound = true;\r\n                deltaJSON[prop] = currentValue;\r\n            }\r\n        }\r\n\r\n        return !aDifferenceWasFound;\r\n    }\r\n\r\n    private _compareCollections(key: string, original: any[], current: any[], deltaJSON: any) {\r\n        // Same ?\r\n        if (original === current) {\r\n            return;\r\n        }\r\n\r\n        if (original && current) {\r\n            // Array?\r\n            if (Array.isArray(original) && Array.isArray(current)) {\r\n                if (this._compareArray(key, original, current, deltaJSON)) {\r\n                    return;\r\n                }\r\n            } else if (typeof original === \"object\" && typeof current === \"object\") {\r\n                // Object\r\n                const newObject = {};\r\n                if (!this._compareObjects(original, current, newObject)) {\r\n                    deltaJSON[key] = newObject;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static GetShadowGeneratorById(scene: Scene, id: string) {\r\n        const allGenerators = scene.lights.map((l) => l.getShadowGenerators());\r\n\r\n        for (const generators of allGenerators) {\r\n            if (generators) {\r\n                const iterator = generators.values();\r\n                for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                    const generator = key.value;\r\n                    if (generator && generator.id === id) {\r\n                        return generator;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply a given delta to a given scene\r\n     * @param deltaJSON defines the JSON containing the delta\r\n     * @param scene defines the scene to apply the delta to\r\n     */\r\n    public static ApplyDelta(deltaJSON: any | string, scene: Scene) {\r\n        if (typeof deltaJSON === \"string\") {\r\n            deltaJSON = JSON.parse(deltaJSON);\r\n        }\r\n\r\n        // Scene\r\n        const anyScene = scene as any;\r\n        for (const prop in deltaJSON) {\r\n            const source = deltaJSON[prop];\r\n            const property = anyScene[prop];\r\n\r\n            if (Array.isArray(property) || prop === \"shadowGenerators\") {\r\n                // Restore array\r\n                switch (prop) {\r\n                    case \"cameras\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getCameraById.bind(scene), (data) => Camera.Parse(data, scene));\r\n                        break;\r\n                    case \"lights\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getLightById.bind(scene), (data) => Light.Parse(data, scene));\r\n                        break;\r\n                    case \"shadowGenerators\":\r\n                        this._ApplyDeltaForEntity(\r\n                            source,\r\n                            scene,\r\n                            (id) => this.GetShadowGeneratorById(scene, id),\r\n                            (data) => ShadowGenerator.Parse(data, scene)\r\n                        );\r\n                        break;\r\n                    case \"meshes\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMeshById.bind(scene), (data) => Mesh.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"skeletons\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getSkeletonById.bind(scene), (data) => Skeleton.Parse(data, scene));\r\n                        break;\r\n                    case \"materials\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => Material.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"multiMaterials\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMaterialById.bind(scene), (data) => MultiMaterial.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"transformNodes\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getTransformNodeById.bind(scene), (data) => TransformNode.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"particleSystems\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getParticleSystemById.bind(scene), (data) => ParticleSystem.Parse(data, scene, \"\"));\r\n                        break;\r\n                    case \"morphTargetManagers\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getMorphTargetById.bind(scene), (data) => MorphTargetManager.Parse(data, scene));\r\n                        break;\r\n                    case \"postProcesses\":\r\n                        this._ApplyDeltaForEntity(source, scene, scene.getPostProcessByName.bind(scene), (data) => PostProcess.Parse(data, scene, \"\"));\r\n                        break;\r\n                }\r\n            } else if (!isNaN(property)) {\r\n                anyScene[prop] = source;\r\n            } else if (property.fromArray) {\r\n                property.fromArray(source);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _ApplyPropertiesToEntity(deltaJSON: any, entity: any) {\r\n        for (const prop in deltaJSON) {\r\n            const source = deltaJSON[prop];\r\n            const property = entity[prop];\r\n\r\n            if (property === undefined) {\r\n                continue;\r\n            }\r\n\r\n            if (!isNaN(property) || Array.isArray(property)) {\r\n                entity[prop] = source;\r\n            } else if (property.fromArray) {\r\n                property.fromArray(source);\r\n            } else if (typeof property === \"object\" && property !== null) {\r\n                this._ApplyPropertiesToEntity(source, property);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _ApplyDeltaForEntity(sources: any[], scene: Scene, finder: (id: string) => any, addNew: (data: any) => void) {\r\n        for (const source of sources) {\r\n            // Update\r\n            if (source.__state && source.__state.id !== undefined) {\r\n                const targetEntity = finder(source.__state.id);\r\n\r\n                if (targetEntity) {\r\n                    this._ApplyPropertiesToEntity(source, targetEntity);\r\n                }\r\n            } else if (source.__state && source.__state.deleteId !== undefined) {\r\n                const target = finder(source.__state.deleteId);\r\n                target?.dispose();\r\n            } else {\r\n                // New\r\n                addNew(source);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}