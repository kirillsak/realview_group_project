{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\n\n/**\n * This represents the object necessary to create a rendering group.\n * This is exclusively used and created by the rendering manager.\n * To modify the behavior, you use the available helpers in your scene or meshes.\n * @internal\n */\nexport class RenderingGroup {\n  /**\n   * Creates a new rendering group.\n   * @param index The rendering group index\n   * @param scene\n   * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n   * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n   * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n   */\n  constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n    this.index = index;\n    this._opaqueSubMeshes = new SmartArray(256);\n    this._transparentSubMeshes = new SmartArray(256);\n    this._alphaTestSubMeshes = new SmartArray(256);\n    this._depthOnlySubMeshes = new SmartArray(256);\n    this._particleSystems = new SmartArray(256);\n    this._spriteManagers = new SmartArray(256);\n    /** @internal */\n    this._empty = true;\n    /** @internal */\n    this._edgesRenderers = new SmartArrayNoDuplicate(16);\n    this._scene = scene;\n    this.opaqueSortCompareFn = opaqueSortCompareFn;\n    this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n    this.transparentSortCompareFn = transparentSortCompareFn;\n  }\n  /**\n   * Set the opaque sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set opaqueSortCompareFn(value) {\n    if (value) {\n      this._opaqueSortCompareFn = value;\n    } else {\n      this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\n    }\n    this._renderOpaque = this._renderOpaqueSorted;\n  }\n  /**\n   * Set the alpha test sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set alphaTestSortCompareFn(value) {\n    if (value) {\n      this._alphaTestSortCompareFn = value;\n    } else {\n      this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\n    }\n    this._renderAlphaTest = this._renderAlphaTestSorted;\n  }\n  /**\n   * Set the transparent sort comparison function.\n   * If null the sub meshes will be render in the order they were created\n   */\n  set transparentSortCompareFn(value) {\n    if (value) {\n      this._transparentSortCompareFn = value;\n    } else {\n      this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n    }\n    this._renderTransparent = this._renderTransparentSorted;\n  }\n  /**\n   * Render all the sub meshes contained in the group.\n   * @param customRenderFunction Used to override the default render behaviour of the group.\n   * @param renderSprites\n   * @param renderParticles\n   * @param activeMeshes\n   * @returns true if rendered some submeshes.\n   */\n  render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n    if (customRenderFunction) {\n      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\n      return;\n    }\n    const engine = this._scene.getEngine();\n    // Depth only\n    if (this._depthOnlySubMeshes.length !== 0) {\n      engine.setColorWrite(false);\n      this._renderAlphaTest(this._depthOnlySubMeshes);\n      engine.setColorWrite(true);\n    }\n    // Opaque\n    if (this._opaqueSubMeshes.length !== 0) {\n      this._renderOpaque(this._opaqueSubMeshes);\n    }\n    // Alpha test\n    if (this._alphaTestSubMeshes.length !== 0) {\n      this._renderAlphaTest(this._alphaTestSubMeshes);\n    }\n    const stencilState = engine.getStencilBuffer();\n    engine.setStencilBuffer(false);\n    // Sprites\n    if (renderSprites) {\n      this._renderSprites();\n    }\n    // Particles\n    if (renderParticles) {\n      this._renderParticles(activeMeshes);\n    }\n    if (this.onBeforeTransparentRendering) {\n      this.onBeforeTransparentRendering();\n    }\n    // Transparent\n    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\n      engine.setStencilBuffer(stencilState);\n      if (this._scene.useOrderIndependentTransparency) {\n        const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);\n        if (excludedMeshes.length) {\n          // Render leftover meshes that could not be processed by depth peeling\n          this._renderTransparent(excludedMeshes);\n        }\n      } else {\n        this._renderTransparent(this._transparentSubMeshes);\n      }\n      engine.setAlphaMode(0);\n    }\n    // Set back stencil to false in case it changes before the edge renderer.\n    engine.setStencilBuffer(false);\n    // Edges\n    if (this._edgesRenderers.length) {\n      for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n        this._edgesRenderers.data[edgesRendererIndex].render();\n      }\n      engine.setAlphaMode(0);\n    }\n    // Restore Stencil state.\n    engine.setStencilBuffer(stencilState);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderOpaqueSorted(subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderAlphaTestSorted(subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\n  }\n  /**\n   * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n   * @param subMeshes The submeshes to render\n   */\n  _renderTransparentSorted(subMeshes) {\n    return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\n  }\n  /**\n   * Renders the submeshes in a specified order.\n   * @param subMeshes The submeshes to sort before render\n   * @param sortCompareFn The comparison function use to sort\n   * @param camera The camera position use to preprocess the submeshes to help sorting\n   * @param transparent Specifies to activate blending if true\n   */\n  static _RenderSorted(subMeshes, sortCompareFn, camera, transparent) {\n    let subIndex = 0;\n    let subMesh;\n    const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\n    if (transparent) {\n      for (; subIndex < subMeshes.length; subIndex++) {\n        subMesh = subMeshes.data[subIndex];\n        subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n        subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n      }\n    }\n    const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\n    if (sortCompareFn) {\n      sortedArray.sort(sortCompareFn);\n    }\n    const scene = sortedArray[0].getMesh().getScene();\n    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n      subMesh = sortedArray[subIndex];\n      if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\n        continue;\n      }\n      if (transparent) {\n        const material = subMesh.getMaterial();\n        if (material && material.needDepthPrePass) {\n          const engine = material.getScene().getEngine();\n          engine.setColorWrite(false);\n          engine.setAlphaMode(0);\n          subMesh.render(false);\n          engine.setColorWrite(true);\n        }\n      }\n      subMesh.render(transparent);\n    }\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front if in the same alpha index.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static defaultTransparentSortCompare(a, b) {\n    // Alpha index first\n    if (a._alphaIndex > b._alphaIndex) {\n      return 1;\n    }\n    if (a._alphaIndex < b._alphaIndex) {\n      return -1;\n    }\n    // Then distance to camera\n    return RenderingGroup.backToFrontSortCompare(a, b);\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered back to front.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static backToFrontSortCompare(a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return 1;\n    }\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return -1;\n    }\n    return 0;\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are rendered front to back (prevent overdraw).\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  static frontToBackSortCompare(a, b) {\n    // Then distance to camera\n    if (a._distanceToCamera < b._distanceToCamera) {\n      return -1;\n    }\n    if (a._distanceToCamera > b._distanceToCamera) {\n      return 1;\n    }\n    return 0;\n  }\n  /**\n   * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n   * are grouped by material then geometry.\n   *\n   * @param a The first submesh\n   * @param b The second submesh\n   * @returns The result of the comparison\n   */\n  static PainterSortCompare(a, b) {\n    const meshA = a.getMesh();\n    const meshB = b.getMesh();\n    if (meshA.material && meshB.material) {\n      return meshA.material.uniqueId - meshB.material.uniqueId;\n    }\n    return meshA.uniqueId - meshB.uniqueId;\n  }\n  /**\n   * Resets the different lists of submeshes to prepare a new frame.\n   */\n  prepare() {\n    this._opaqueSubMeshes.reset();\n    this._transparentSubMeshes.reset();\n    this._alphaTestSubMeshes.reset();\n    this._depthOnlySubMeshes.reset();\n    this._particleSystems.reset();\n    this.prepareSprites();\n    this._edgesRenderers.reset();\n    this._empty = true;\n  }\n  /**\n   * Resets the different lists of sprites to prepare a new frame.\n   */\n  prepareSprites() {\n    this._spriteManagers.reset();\n  }\n  dispose() {\n    this._opaqueSubMeshes.dispose();\n    this._transparentSubMeshes.dispose();\n    this._alphaTestSubMeshes.dispose();\n    this._depthOnlySubMeshes.dispose();\n    this._particleSystems.dispose();\n    this._spriteManagers.dispose();\n    this._edgesRenderers.dispose();\n  }\n  /**\n   * Inserts the submesh in its correct queue depending on its material.\n   * @param subMesh The submesh to dispatch\n   * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n  dispatch(subMesh, mesh, material) {\n    // Get mesh and materials if not provided\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n    if (material === undefined) {\n      material = subMesh.getMaterial();\n    }\n    if (material === null || material === undefined) {\n      return;\n    }\n    if (material.needAlphaBlendingForMesh(mesh)) {\n      // Transparent\n      this._transparentSubMeshes.push(subMesh);\n    } else if (material.needAlphaTesting()) {\n      // Alpha test\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n      this._alphaTestSubMeshes.push(subMesh);\n    } else {\n      if (material.needDepthPrePass) {\n        this._depthOnlySubMeshes.push(subMesh);\n      }\n      this._opaqueSubMeshes.push(subMesh); // Opaque\n    }\n\n    mesh._renderingGroup = this;\n    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\n      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\n    }\n    this._empty = false;\n  }\n  dispatchSprites(spriteManager) {\n    this._spriteManagers.push(spriteManager);\n    this._empty = false;\n  }\n  dispatchParticles(particleSystem) {\n    this._particleSystems.push(particleSystem);\n    this._empty = false;\n  }\n  _renderParticles(activeMeshes) {\n    if (this._particleSystems.length === 0) {\n      return;\n    }\n    // Particles\n    const activeCamera = this._scene.activeCamera;\n    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\n    for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\n      const particleSystem = this._particleSystems.data[particleIndex];\n      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\n        continue;\n      }\n      const emitter = particleSystem.emitter;\n      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\n        this._scene._activeParticles.addCount(particleSystem.render(), false);\n      }\n    }\n    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\n  }\n  _renderSprites() {\n    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n      return;\n    }\n    // Sprites\n    const activeCamera = this._scene.activeCamera;\n    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\n    for (let id = 0; id < this._spriteManagers.length; id++) {\n      const spriteManager = this._spriteManagers.data[id];\n      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\n        spriteManager.render();\n      }\n    }\n    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\n  }\n}\nRenderingGroup._ZeroVector = Vector3.Zero();","map":{"version":3,"mappings":"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","names":["SmartArray","SmartArrayNoDuplicate","Vector3","RenderingGroup","constructor","index","scene","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","_scene","value","_opaqueSortCompareFn","PainterSortCompare","_renderOpaque","_renderOpaqueSorted","_alphaTestSortCompareFn","_renderAlphaTest","_renderAlphaTestSorted","_transparentSortCompareFn","defaultTransparentSortCompare","_renderTransparent","_renderTransparentSorted","render","customRenderFunction","renderSprites","renderParticles","activeMeshes","_opaqueSubMeshes","_alphaTestSubMeshes","_transparentSubMeshes","_depthOnlySubMeshes","engine","getEngine","length","setColorWrite","stencilState","getStencilBuffer","setStencilBuffer","_renderSprites","_renderParticles","onBeforeTransparentRendering","useOrderIndependentTransparency","excludedMeshes","depthPeelingRenderer","setAlphaMode","_edgesRenderers","edgesRendererIndex","data","subMeshes","_RenderSorted","activeCamera","sortCompareFn","camera","transparent","subIndex","subMesh","cameraPosition","globalPosition","_ZeroVector","_alphaIndex","getMesh","alphaIndex","_distanceToCamera","Distance","getBoundingInfo","boundingSphere","centerWorld","sortedArray","slice","sort","getScene","_activeMeshesFrozenButKeepClipping","isInFrustum","_frustumPlanes","material","getMaterial","needDepthPrePass","a","b","backToFrontSortCompare","frontToBackSortCompare","meshA","meshB","uniqueId","prepare","reset","_particleSystems","prepareSprites","_empty","_spriteManagers","dispose","dispatch","mesh","undefined","needAlphaBlendingForMesh","push","needAlphaTesting","_renderingGroup","_edgesRenderer","isEnabled","pushNoDuplicate","dispatchSprites","spriteManager","dispatchParticles","particleSystem","onBeforeParticlesRenderingObservable","notifyObservers","particleIndex","layerMask","emitter","position","indexOf","_activeParticles","addCount","onAfterParticlesRenderingObservable","spritesEnabled","onBeforeSpritesRenderingObservable","id","onAfterSpritesRenderingObservable","Zero"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/renderingGroup.ts"],"sourcesContent":["import { SmartArray, SmartArrayNoDuplicate } from \"../Misc/smartArray\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable, DeepImmutable } from \"../types\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport type { IEdgesRenderer } from \"./edgesRenderer\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\n\r\n/**\r\n * This represents the object necessary to create a rendering group.\r\n * This is exclusively used and created by the rendering manager.\r\n * To modify the behavior, you use the available helpers in your scene or meshes.\r\n * @internal\r\n */\r\nexport class RenderingGroup {\r\n    private static _ZeroVector: DeepImmutable<Vector3> = Vector3.Zero();\r\n    private _scene: Scene;\r\n    private _opaqueSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _transparentSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _alphaTestSubMeshes = new SmartArray<SubMesh>(256);\r\n    private _depthOnlySubMeshes = new SmartArray<SubMesh>(256);\r\n    private _particleSystems = new SmartArray<IParticleSystem>(256);\r\n    private _spriteManagers = new SmartArray<ISpriteManager>(256);\r\n\r\n    private _opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>;\r\n    private _transparentSortCompareFn: (a: SubMesh, b: SubMesh) => number;\r\n\r\n    private _renderOpaque: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderAlphaTest: (subMeshes: SmartArray<SubMesh>) => void;\r\n    private _renderTransparent: (subMeshes: SmartArray<SubMesh>) => void;\r\n\r\n    /** @internal */\r\n    public _empty = true;\r\n\r\n    /** @internal */\r\n    public _edgesRenderers = new SmartArrayNoDuplicate<IEdgesRenderer>(16);\r\n\r\n    public onBeforeTransparentRendering: () => void;\r\n\r\n    /**\r\n     * Set the opaque sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set opaqueSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._opaqueSortCompareFn = value;\r\n        } else {\r\n            this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderOpaque = this._renderOpaqueSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the alpha test sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set alphaTestSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._alphaTestSortCompareFn = value;\r\n        } else {\r\n            this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;\r\n        }\r\n        this._renderAlphaTest = this._renderAlphaTestSorted;\r\n    }\r\n\r\n    /**\r\n     * Set the transparent sort comparison function.\r\n     * If null the sub meshes will be render in the order they were created\r\n     */\r\n    public set transparentSortCompareFn(value: Nullable<(a: SubMesh, b: SubMesh) => number>) {\r\n        if (value) {\r\n            this._transparentSortCompareFn = value;\r\n        } else {\r\n            this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\r\n        }\r\n        this._renderTransparent = this._renderTransparentSorted;\r\n    }\r\n\r\n    /**\r\n     * Creates a new rendering group.\r\n     * @param index The rendering group index\r\n     * @param scene\r\n     * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\r\n     * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\r\n     * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\r\n     */\r\n    constructor(\r\n        public index: number,\r\n        scene: Scene,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        this.opaqueSortCompareFn = opaqueSortCompareFn;\r\n        this.alphaTestSortCompareFn = alphaTestSortCompareFn;\r\n        this.transparentSortCompareFn = transparentSortCompareFn;\r\n    }\r\n\r\n    /**\r\n     * Render all the sub meshes contained in the group.\r\n     * @param customRenderFunction Used to override the default render behaviour of the group.\r\n     * @param renderSprites\r\n     * @param renderParticles\r\n     * @param activeMeshes\r\n     * @returns true if rendered some submeshes.\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        renderSprites: boolean,\r\n        renderParticles: boolean,\r\n        activeMeshes: Nullable<AbstractMesh[]>\r\n    ): void {\r\n        if (customRenderFunction) {\r\n            customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        // Depth only\r\n        if (this._depthOnlySubMeshes.length !== 0) {\r\n            engine.setColorWrite(false);\r\n            this._renderAlphaTest(this._depthOnlySubMeshes);\r\n            engine.setColorWrite(true);\r\n        }\r\n\r\n        // Opaque\r\n        if (this._opaqueSubMeshes.length !== 0) {\r\n            this._renderOpaque(this._opaqueSubMeshes);\r\n        }\r\n\r\n        // Alpha test\r\n        if (this._alphaTestSubMeshes.length !== 0) {\r\n            this._renderAlphaTest(this._alphaTestSubMeshes);\r\n        }\r\n\r\n        const stencilState = engine.getStencilBuffer();\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Sprites\r\n        if (renderSprites) {\r\n            this._renderSprites();\r\n        }\r\n\r\n        // Particles\r\n        if (renderParticles) {\r\n            this._renderParticles(activeMeshes);\r\n        }\r\n\r\n        if (this.onBeforeTransparentRendering) {\r\n            this.onBeforeTransparentRendering();\r\n        }\r\n\r\n        // Transparent\r\n        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {\r\n            engine.setStencilBuffer(stencilState);\r\n            if (this._scene.useOrderIndependentTransparency) {\r\n                const excludedMeshes = this._scene.depthPeelingRenderer!.render(this._transparentSubMeshes);\r\n                if (excludedMeshes.length) {\r\n                    // Render leftover meshes that could not be processed by depth peeling\r\n                    this._renderTransparent(excludedMeshes);\r\n                }\r\n            } else {\r\n                this._renderTransparent(this._transparentSubMeshes);\r\n            }\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Set back stencil to false in case it changes before the edge renderer.\r\n        engine.setStencilBuffer(false);\r\n\r\n        // Edges\r\n        if (this._edgesRenderers.length) {\r\n            for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\r\n                this._edgesRenderers.data[edgesRendererIndex].render();\r\n            }\r\n\r\n            engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        // Restore Stencil state.\r\n        engine.setStencilBuffer(stencilState);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderOpaqueSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderAlphaTestSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);\r\n    }\r\n\r\n    /**\r\n     * Renders the opaque submeshes in the order from the transparentSortCompareFn.\r\n     * @param subMeshes The submeshes to render\r\n     */\r\n    private _renderTransparentSorted(subMeshes: SmartArray<SubMesh>): void {\r\n        return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);\r\n    }\r\n\r\n    /**\r\n     * Renders the submeshes in a specified order.\r\n     * @param subMeshes The submeshes to sort before render\r\n     * @param sortCompareFn The comparison function use to sort\r\n     * @param camera The camera position use to preprocess the submeshes to help sorting\r\n     * @param transparent Specifies to activate blending if true\r\n     */\r\n    private static _RenderSorted(\r\n        subMeshes: SmartArray<SubMesh>,\r\n        sortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number>,\r\n        camera: Nullable<Camera>,\r\n        transparent: boolean\r\n    ): void {\r\n        let subIndex = 0;\r\n        let subMesh: SubMesh;\r\n        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;\r\n\r\n        if (transparent) {\r\n            for (; subIndex < subMeshes.length; subIndex++) {\r\n                subMesh = subMeshes.data[subIndex];\r\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\r\n                subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\r\n            }\r\n        }\r\n\r\n        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);\r\n\r\n        if (sortCompareFn) {\r\n            sortedArray.sort(sortCompareFn);\r\n        }\r\n\r\n        const scene = sortedArray[0].getMesh().getScene();\r\n        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\r\n            subMesh = sortedArray[subIndex];\r\n\r\n            if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {\r\n                continue;\r\n            }\r\n\r\n            if (transparent) {\r\n                const material = subMesh.getMaterial();\r\n\r\n                if (material && material.needDepthPrePass) {\r\n                    const engine = material.getScene().getEngine();\r\n                    engine.setColorWrite(false);\r\n                    engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n                    subMesh.render(false);\r\n                    engine.setColorWrite(true);\r\n                }\r\n            }\r\n\r\n            subMesh.render(transparent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front if in the same alpha index.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static defaultTransparentSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Alpha index first\r\n        if (a._alphaIndex > b._alphaIndex) {\r\n            return 1;\r\n        }\r\n        if (a._alphaIndex < b._alphaIndex) {\r\n            return -1;\r\n        }\r\n\r\n        // Then distance to camera\r\n        return RenderingGroup.backToFrontSortCompare(a, b);\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered back to front.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static backToFrontSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are rendered front to back (prevent overdraw).\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static frontToBackSortCompare(a: SubMesh, b: SubMesh): number {\r\n        // Then distance to camera\r\n        if (a._distanceToCamera < b._distanceToCamera) {\r\n            return -1;\r\n        }\r\n        if (a._distanceToCamera > b._distanceToCamera) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\r\n     * are grouped by material then geometry.\r\n     *\r\n     * @param a The first submesh\r\n     * @param b The second submesh\r\n     * @returns The result of the comparison\r\n     */\r\n    public static PainterSortCompare(a: SubMesh, b: SubMesh): number {\r\n        const meshA = a.getMesh();\r\n        const meshB = b.getMesh();\r\n\r\n        if (meshA.material && meshB.material) {\r\n            return meshA.material.uniqueId - meshB.material.uniqueId;\r\n        }\r\n\r\n        return meshA.uniqueId - meshB.uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of submeshes to prepare a new frame.\r\n     */\r\n    public prepare(): void {\r\n        this._opaqueSubMeshes.reset();\r\n        this._transparentSubMeshes.reset();\r\n        this._alphaTestSubMeshes.reset();\r\n        this._depthOnlySubMeshes.reset();\r\n        this._particleSystems.reset();\r\n        this.prepareSprites();\r\n        this._edgesRenderers.reset();\r\n        this._empty = true;\r\n    }\r\n\r\n    /**\r\n     * Resets the different lists of sprites to prepare a new frame.\r\n     */\r\n    public prepareSprites(): void {\r\n        this._spriteManagers.reset();\r\n    }\r\n\r\n    public dispose(): void {\r\n        this._opaqueSubMeshes.dispose();\r\n        this._transparentSubMeshes.dispose();\r\n        this._alphaTestSubMeshes.dispose();\r\n        this._depthOnlySubMeshes.dispose();\r\n        this._particleSystems.dispose();\r\n        this._spriteManagers.dispose();\r\n        this._edgesRenderers.dispose();\r\n    }\r\n\r\n    /**\r\n     * Inserts the submesh in its correct queue depending on its material.\r\n     * @param subMesh The submesh to dispatch\r\n     * @param [mesh] Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param [material] Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        // Get mesh and materials if not provided\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (material === undefined) {\r\n            material = subMesh.getMaterial();\r\n        }\r\n\r\n        if (material === null || material === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (material.needAlphaBlendingForMesh(mesh)) {\r\n            // Transparent\r\n            this._transparentSubMeshes.push(subMesh);\r\n        } else if (material.needAlphaTesting()) {\r\n            // Alpha test\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._alphaTestSubMeshes.push(subMesh);\r\n        } else {\r\n            if (material.needDepthPrePass) {\r\n                this._depthOnlySubMeshes.push(subMesh);\r\n            }\r\n\r\n            this._opaqueSubMeshes.push(subMesh); // Opaque\r\n        }\r\n\r\n        mesh._renderingGroup = this;\r\n\r\n        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {\r\n            this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);\r\n        }\r\n\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        this._spriteManagers.push(spriteManager);\r\n        this._empty = false;\r\n    }\r\n\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        this._particleSystems.push(particleSystem);\r\n        this._empty = false;\r\n    }\r\n\r\n    private _renderParticles(activeMeshes: Nullable<AbstractMesh[]>): void {\r\n        if (this._particleSystems.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Particles\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);\r\n        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {\r\n            const particleSystem = this._particleSystems.data[particleIndex];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {\r\n                continue;\r\n            }\r\n\r\n            const emitter: any = particleSystem.emitter;\r\n            if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {\r\n                this._scene._activeParticles.addCount(particleSystem.render(), false);\r\n            }\r\n        }\r\n        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n\r\n    private _renderSprites(): void {\r\n        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Sprites\r\n        const activeCamera = this._scene.activeCamera;\r\n        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);\r\n        for (let id = 0; id < this._spriteManagers.length; id++) {\r\n            const spriteManager = this._spriteManagers.data[id];\r\n\r\n            if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {\r\n                spriteManager.render();\r\n            }\r\n        }\r\n        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}