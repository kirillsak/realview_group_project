{"ast":null,"code":"import { RenderingGroup } from \"./renderingGroup.js\";\n/**\n * This class is used by the onRenderingGroupObservable\n */\nexport class RenderingGroupInfo {}\n/**\n * This is the manager responsible of all the rendering for meshes sprites and particles.\n * It is enable to manage the different groups as well as the different necessary sort functions.\n * This should not be used directly aside of the few static configurations\n */\nexport class RenderingManager {\n  /**\n   * Instantiates a new rendering group for a particular scene\n   * @param scene Defines the scene the groups belongs to\n   */\n  constructor(scene) {\n    /**\n     * @internal\n     */\n    this._useSceneAutoClearSetup = false;\n    this._renderingGroups = new Array();\n    this._autoClearDepthStencil = {};\n    this._customOpaqueSortCompareFn = {};\n    this._customAlphaTestSortCompareFn = {};\n    this._customTransparentSortCompareFn = {};\n    this._renderingGroupInfo = new RenderingGroupInfo();\n    this._maintainStateBetweenFrames = false;\n    this._scene = scene;\n    for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n      this._autoClearDepthStencil[i] = {\n        autoClear: true,\n        depth: true,\n        stencil: true\n      };\n    }\n  }\n  /**\n   * Gets or sets a boolean indicating that the manager will not reset between frames.\n   * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\n   * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\n   * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\n   */\n  get maintainStateBetweenFrames() {\n    return this._maintainStateBetweenFrames;\n  }\n  set maintainStateBetweenFrames(value) {\n    if (value === this._maintainStateBetweenFrames) {\n      return;\n    }\n    this._maintainStateBetweenFrames = value;\n    // Restore wasDispatched flags when switching to maintainStateBetweenFrames to false\n    if (!this._maintainStateBetweenFrames) {\n      for (const mesh of this._scene.meshes) {\n        if (mesh.subMeshes) {\n          for (const subMesh of mesh.subMeshes) {\n            subMesh._wasDispatched = false;\n          }\n        }\n      }\n      for (const spriteManager of this._scene.spriteManagers) {\n        spriteManager._wasDispatched = false;\n      }\n      for (const particleSystem of this._scene.particleSystems) {\n        particleSystem._wasDispatched = false;\n      }\n    }\n  }\n  /**\n   * Gets the rendering group with the specified id.\n   */\n  getRenderingGroup(id) {\n    const renderingGroupId = id || 0;\n    this._prepareRenderingGroup(renderingGroupId);\n    return this._renderingGroups[renderingGroupId];\n  }\n  _clearDepthStencilBuffer(depth = true, stencil = true) {\n    if (this._depthStencilBufferAlreadyCleaned) {\n      return;\n    }\n    this._scene.getEngine().clear(null, false, depth, stencil);\n    this._depthStencilBufferAlreadyCleaned = true;\n  }\n  /**\n   * Renders the entire managed groups. This is used by the scene or the different render targets.\n   * @internal\n   */\n  render(customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n    // Update the observable context (not null as it only goes away on dispose)\n    const info = this._renderingGroupInfo;\n    info.scene = this._scene;\n    info.camera = this._scene.activeCamera;\n    // Dispatch sprites\n    if (this._scene.spriteManagers && renderSprites) {\n      for (let index = 0; index < this._scene.spriteManagers.length; index++) {\n        const manager = this._scene.spriteManagers[index];\n        this.dispatchSprites(manager);\n      }\n    }\n    // Render\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n      const renderingGroup = this._renderingGroups[index];\n      if (!renderingGroup || renderingGroup._empty) {\n        continue;\n      }\n      const renderingGroupMask = Math.pow(2, index);\n      info.renderingGroupId = index;\n      // Before Observable\n      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n      // Clear depth/stencil if needed\n      if (RenderingManager.AUTOCLEAR) {\n        const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\n        if (autoClear && autoClear.autoClear) {\n          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n        }\n      }\n      // Render\n      for (const step of this._scene._beforeRenderingGroupDrawStage) {\n        step.action(index);\n      }\n      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n      for (const step of this._scene._afterRenderingGroupDrawStage) {\n        step.action(index);\n      }\n      // After Observable\n      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\n    }\n  }\n  /**\n   * Resets the different information of the group to prepare a new frame\n   * @internal\n   */\n  reset() {\n    if (this.maintainStateBetweenFrames) {\n      return;\n    }\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      const renderingGroup = this._renderingGroups[index];\n      if (renderingGroup) {\n        renderingGroup.prepare();\n      }\n    }\n  }\n  /**\n   * Resets the sprites information of the group to prepare a new frame\n   * @internal\n   */\n  resetSprites() {\n    if (this.maintainStateBetweenFrames) {\n      return;\n    }\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      const renderingGroup = this._renderingGroups[index];\n      if (renderingGroup) {\n        renderingGroup.prepareSprites();\n      }\n    }\n  }\n  /**\n   * Dispose and release the group and its associated resources.\n   * @internal\n   */\n  dispose() {\n    this.freeRenderingGroups();\n    this._renderingGroups.length = 0;\n    this._renderingGroupInfo = null;\n  }\n  /**\n   * Clear the info related to rendering groups preventing retention points during dispose.\n   */\n  freeRenderingGroups() {\n    for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n      const renderingGroup = this._renderingGroups[index];\n      if (renderingGroup) {\n        renderingGroup.dispose();\n      }\n    }\n  }\n  _prepareRenderingGroup(renderingGroupId) {\n    if (this._renderingGroups[renderingGroupId] === undefined) {\n      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n    }\n  }\n  /**\n   * Add a sprite manager to the rendering manager in order to render it this frame.\n   * @param spriteManager Define the sprite manager to render\n   */\n  dispatchSprites(spriteManager) {\n    if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\n      return;\n    }\n    spriteManager._wasDispatched = true;\n    this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\n  }\n  /**\n   * Add a particle system to the rendering manager in order to render it this frame.\n   * @param particleSystem Define the particle system to render\n   */\n  dispatchParticles(particleSystem) {\n    if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\n      return;\n    }\n    particleSystem._wasDispatched = true;\n    this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\n  }\n  /**\n   * Add a submesh to the manager in order to render it this frame\n   * @param subMesh The submesh to dispatch\n   * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\n   * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\n   */\n  dispatch(subMesh, mesh, material) {\n    if (mesh === undefined) {\n      mesh = subMesh.getMesh();\n    }\n    if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\n      return;\n    }\n    subMesh._wasDispatched = true;\n    this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\n  }\n  /**\n   * Overrides the default sort function applied in the rendering group to prepare the meshes.\n   * This allowed control for front to back rendering or reversely depending of the special needs.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n   * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n   */\n  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {\n    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n    if (this._renderingGroups[renderingGroupId]) {\n      const group = this._renderingGroups[renderingGroupId];\n      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n    }\n  }\n  /**\n   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n   *\n   * @param renderingGroupId The rendering group id corresponding to its index\n   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n   * @param depth Automatically clears depth between groups if true and autoClear is true.\n   * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n   */\n  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {\n    this._autoClearDepthStencil[renderingGroupId] = {\n      autoClear: autoClearDepthStencil,\n      depth: depth,\n      stencil: stencil\n    };\n  }\n  /**\n   * Gets the current auto clear configuration for one rendering group of the rendering\n   * manager.\n   * @param index the rendering group index to get the information for\n   * @returns The auto clear setup for the requested rendering group\n   */\n  getAutoClearDepthStencilSetup(index) {\n    return this._autoClearDepthStencil[index];\n  }\n}\n/**\n * The max id used for rendering groups (not included)\n */\nRenderingManager.MAX_RENDERINGGROUPS = 4;\n/**\n * The min id used for rendering groups (included)\n */\nRenderingManager.MIN_RENDERINGGROUPS = 0;\n/**\n * Used to globally prevent autoclearing scenes.\n */\nRenderingManager.AUTOCLEAR = true;","map":{"version":3,"mappings":"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","names":["RenderingGroup","RenderingGroupInfo","RenderingManager","constructor","scene","Array","_scene","i","MIN_RENDERINGGROUPS","MAX_RENDERINGGROUPS","_autoClearDepthStencil","autoClear","depth","stencil","maintainStateBetweenFrames","_maintainStateBetweenFrames","value","mesh","meshes","subMeshes","subMesh","_wasDispatched","spriteManager","spriteManagers","particleSystem","particleSystems","getRenderingGroup","id","renderingGroupId","_prepareRenderingGroup","_renderingGroups","_clearDepthStencilBuffer","_depthStencilBufferAlreadyCleaned","getEngine","clear","render","customRenderFunction","activeMeshes","renderParticles","renderSprites","info","_renderingGroupInfo","camera","activeCamera","index","length","manager","dispatchSprites","renderingGroup","_empty","renderingGroupMask","Math","pow","onBeforeRenderingGroupObservable","notifyObservers","AUTOCLEAR","_useSceneAutoClearSetup","getAutoClearDepthStencilSetup","step","_beforeRenderingGroupDrawStage","action","_afterRenderingGroupDrawStage","onAfterRenderingGroupObservable","reset","prepare","resetSprites","prepareSprites","dispose","freeRenderingGroups","undefined","_customOpaqueSortCompareFn","_customAlphaTestSortCompareFn","_customTransparentSortCompareFn","dispatchParticles","dispatch","material","getMesh","setRenderingOrder","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","group","setRenderingAutoClearDepthStencil","autoClearDepthStencil"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/renderingManager.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport type { ISpriteManager } from \"../Sprites/spriteManager\";\r\nimport type { IParticleSystem } from \"../Particles/IParticleSystem\";\r\nimport { RenderingGroup } from \"./renderingGroup\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\ndeclare type Camera = import(\"../Cameras/camera\").Camera;\r\ndeclare type Material = import(\"../Materials/material\").Material;\r\ndeclare type SubMesh = import(\"../Meshes/subMesh\").SubMesh;\r\ndeclare type AbstractMesh = import(\"../Meshes/abstractMesh\").AbstractMesh;\r\n\r\n/**\r\n * Interface describing the different options available in the rendering manager\r\n * regarding Auto Clear between groups.\r\n */\r\nexport interface IRenderingManagerAutoClearSetup {\r\n    /**\r\n     * Defines whether or not autoclear is enable.\r\n     */\r\n    autoClear: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the depth buffer.\r\n     */\r\n    depth: boolean;\r\n    /**\r\n     * Defines whether or not to autoclear the stencil buffer.\r\n     */\r\n    stencil: boolean;\r\n}\r\n\r\n/**\r\n * This class is used by the onRenderingGroupObservable\r\n */\r\nexport class RenderingGroupInfo {\r\n    /**\r\n     * The Scene that being rendered\r\n     */\r\n    scene: Scene;\r\n\r\n    /**\r\n     * The camera currently used for the rendering pass\r\n     */\r\n    camera: Nullable<Camera>;\r\n\r\n    /**\r\n     * The ID of the renderingGroup being processed\r\n     */\r\n    renderingGroupId: number;\r\n}\r\n\r\n/**\r\n * This is the manager responsible of all the rendering for meshes sprites and particles.\r\n * It is enable to manage the different groups as well as the different necessary sort functions.\r\n * This should not be used directly aside of the few static configurations\r\n */\r\nexport class RenderingManager {\r\n    /**\r\n     * The max id used for rendering groups (not included)\r\n     */\r\n    public static MAX_RENDERINGGROUPS = 4;\r\n\r\n    /**\r\n     * The min id used for rendering groups (included)\r\n     */\r\n    public static MIN_RENDERINGGROUPS = 0;\r\n\r\n    /**\r\n     * Used to globally prevent autoclearing scenes.\r\n     */\r\n    public static AUTOCLEAR = true;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _useSceneAutoClearSetup = false;\r\n\r\n    private _scene: Scene;\r\n    private _renderingGroups = new Array<RenderingGroup>();\r\n    private _depthStencilBufferAlreadyCleaned: boolean;\r\n\r\n    private _autoClearDepthStencil: { [id: number]: IRenderingManagerAutoClearSetup } = {};\r\n    private _customOpaqueSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customAlphaTestSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _customTransparentSortCompareFn: { [id: number]: Nullable<(a: SubMesh, b: SubMesh) => number> } = {};\r\n    private _renderingGroupInfo: Nullable<RenderingGroupInfo> = new RenderingGroupInfo();\r\n\r\n    private _maintainStateBetweenFrames = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the manager will not reset between frames.\r\n     * This means that if a mesh becomes invisible or transparent it will not be visible until this boolean is set to false again.\r\n     * By default, the rendering manager will dispatch all active meshes per frame (moving them to the transparent, opaque or alpha testing lists).\r\n     * By turning this property on, you will accelerate the rendering by keeping all these lists unchanged between frames.\r\n     */\r\n    public get maintainStateBetweenFrames() {\r\n        return this._maintainStateBetweenFrames;\r\n    }\r\n\r\n    public set maintainStateBetweenFrames(value: boolean) {\r\n        if (value === this._maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        this._maintainStateBetweenFrames = value;\r\n\r\n        // Restore wasDispatched flags when switching to maintainStateBetweenFrames to false\r\n        if (!this._maintainStateBetweenFrames) {\r\n            for (const mesh of this._scene.meshes) {\r\n                if (mesh.subMeshes) {\r\n                    for (const subMesh of mesh.subMeshes) {\r\n                        subMesh._wasDispatched = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (const spriteManager of this._scene.spriteManagers) {\r\n                spriteManager._wasDispatched = false;\r\n            }\r\n\r\n            for (const particleSystem of this._scene.particleSystems) {\r\n                particleSystem._wasDispatched = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new rendering group for a particular scene\r\n     * @param scene Defines the scene the groups belongs to\r\n     */\r\n    constructor(scene: Scene) {\r\n        this._scene = scene;\r\n\r\n        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\r\n            this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the rendering group with the specified id.\r\n     */\r\n    public getRenderingGroup(id: number): RenderingGroup {\r\n        const renderingGroupId = id || 0;\r\n\r\n        this._prepareRenderingGroup(renderingGroupId);\r\n\r\n        return this._renderingGroups[renderingGroupId];\r\n    }\r\n\r\n    private _clearDepthStencilBuffer(depth = true, stencil = true): void {\r\n        if (this._depthStencilBufferAlreadyCleaned) {\r\n            return;\r\n        }\r\n\r\n        this._scene.getEngine().clear(null, false, depth, stencil);\r\n        this._depthStencilBufferAlreadyCleaned = true;\r\n    }\r\n\r\n    /**\r\n     * Renders the entire managed groups. This is used by the scene or the different render targets.\r\n     * @internal\r\n     */\r\n    public render(\r\n        customRenderFunction: Nullable<\r\n            (\r\n                opaqueSubMeshes: SmartArray<SubMesh>,\r\n                transparentSubMeshes: SmartArray<SubMesh>,\r\n                alphaTestSubMeshes: SmartArray<SubMesh>,\r\n                depthOnlySubMeshes: SmartArray<SubMesh>\r\n            ) => void\r\n        >,\r\n        activeMeshes: Nullable<AbstractMesh[]>,\r\n        renderParticles: boolean,\r\n        renderSprites: boolean\r\n    ): void {\r\n        // Update the observable context (not null as it only goes away on dispose)\r\n        const info = this._renderingGroupInfo!;\r\n        info.scene = this._scene;\r\n        info.camera = this._scene.activeCamera;\r\n\r\n        // Dispatch sprites\r\n        if (this._scene.spriteManagers && renderSprites) {\r\n            for (let index = 0; index < this._scene.spriteManagers.length; index++) {\r\n                const manager = this._scene.spriteManagers[index];\r\n                this.dispatchSprites(manager);\r\n            }\r\n        }\r\n\r\n        // Render\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (!renderingGroup || renderingGroup._empty) {\r\n                continue;\r\n            }\r\n\r\n            const renderingGroupMask = Math.pow(2, index);\r\n            info.renderingGroupId = index;\r\n\r\n            // Before Observable\r\n            this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n\r\n            // Clear depth/stencil if needed\r\n            if (RenderingManager.AUTOCLEAR) {\r\n                const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];\r\n\r\n                if (autoClear && autoClear.autoClear) {\r\n                    this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\r\n                }\r\n            }\r\n\r\n            // Render\r\n            for (const step of this._scene._beforeRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n            renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\r\n            for (const step of this._scene._afterRenderingGroupDrawStage) {\r\n                step.action(index);\r\n            }\r\n\r\n            // After Observable\r\n            this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the different information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepare();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the sprites information of the group to prepare a new frame\r\n     * @internal\r\n     */\r\n    public resetSprites(): void {\r\n        if (this.maintainStateBetweenFrames) {\r\n            return;\r\n        }\r\n\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.prepareSprites();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the group and its associated resources.\r\n     * @internal\r\n     */\r\n    public dispose(): void {\r\n        this.freeRenderingGroups();\r\n        this._renderingGroups.length = 0;\r\n        this._renderingGroupInfo = null;\r\n    }\r\n\r\n    /**\r\n     * Clear the info related to rendering groups preventing retention points during dispose.\r\n     */\r\n    public freeRenderingGroups(): void {\r\n        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\r\n            const renderingGroup = this._renderingGroups[index];\r\n            if (renderingGroup) {\r\n                renderingGroup.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _prepareRenderingGroup(renderingGroupId: number): void {\r\n        if (this._renderingGroups[renderingGroupId] === undefined) {\r\n            this._renderingGroups[renderingGroupId] = new RenderingGroup(\r\n                renderingGroupId,\r\n                this._scene,\r\n                this._customOpaqueSortCompareFn[renderingGroupId],\r\n                this._customAlphaTestSortCompareFn[renderingGroupId],\r\n                this._customTransparentSortCompareFn[renderingGroupId]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a sprite manager to the rendering manager in order to render it this frame.\r\n     * @param spriteManager Define the sprite manager to render\r\n     */\r\n    public dispatchSprites(spriteManager: ISpriteManager) {\r\n        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {\r\n            return;\r\n        }\r\n        spriteManager._wasDispatched = true;\r\n        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);\r\n    }\r\n\r\n    /**\r\n     * Add a particle system to the rendering manager in order to render it this frame.\r\n     * @param particleSystem Define the particle system to render\r\n     */\r\n    public dispatchParticles(particleSystem: IParticleSystem) {\r\n        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {\r\n            return;\r\n        }\r\n        particleSystem._wasDispatched = true;\r\n        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);\r\n    }\r\n\r\n    /**\r\n     * Add a submesh to the manager in order to render it this frame\r\n     * @param subMesh The submesh to dispatch\r\n     * @param mesh Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.\r\n     * @param material Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.\r\n     */\r\n    public dispatch(subMesh: SubMesh, mesh?: AbstractMesh, material?: Nullable<Material>): void {\r\n        if (mesh === undefined) {\r\n            mesh = subMesh.getMesh();\r\n        }\r\n        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {\r\n            return;\r\n        }\r\n        subMesh._wasDispatched = true;\r\n        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\r\n     * This allowed control for front to back rendering or reversely depending of the special needs.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\r\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\r\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\r\n     */\r\n    public setRenderingOrder(\r\n        renderingGroupId: number,\r\n        opaqueSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        alphaTestSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null,\r\n        transparentSortCompareFn: Nullable<(a: SubMesh, b: SubMesh) => number> = null\r\n    ) {\r\n        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\r\n        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\r\n        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\r\n\r\n        if (this._renderingGroups[renderingGroupId]) {\r\n            const group = this._renderingGroups[renderingGroupId];\r\n            group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\r\n            group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\r\n            group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\r\n     *\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\r\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean, depth = true, stencil = true): void {\r\n        this._autoClearDepthStencil[renderingGroupId] = {\r\n            autoClear: autoClearDepthStencil,\r\n            depth: depth,\r\n            stencil: stencil,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the current auto clear configuration for one rendering group of the rendering\r\n     * manager.\r\n     * @param index the rendering group index to get the information for\r\n     * @returns The auto clear setup for the requested rendering group\r\n     */\r\n    public getAutoClearDepthStencilSetup(index: number): IRenderingManagerAutoClearSetup {\r\n        return this._autoClearDepthStencil[index];\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}