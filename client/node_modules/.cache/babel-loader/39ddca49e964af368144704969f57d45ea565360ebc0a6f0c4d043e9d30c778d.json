{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { CreateRibbon } from \"./ribbonBuilder.js\";\n/**\n * Creates lathe mesh.\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\n * @param name defines the name of the mesh\n * @param options defines the options used to create the mesh\n * @param options.shape\n * @param options.radius\n * @param options.tessellation\n * @param options.clip\n * @param options.arc\n * @param options.closed\n * @param options.updatable\n * @param options.sideOrientation\n * @param options.frontUVs\n * @param options.backUVs\n * @param options.cap\n * @param options.invertUV\n * @param scene defines the hosting scene\n * @returns the lathe mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lathe\n */\nexport function CreateLathe(name, options, scene = null) {\n  const arc = options.arc ? options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc : 1.0;\n  const closed = options.closed === undefined ? true : options.closed;\n  const shape = options.shape;\n  const radius = options.radius || 1;\n  const tessellation = options.tessellation || 64;\n  const clip = options.clip || 0;\n  const updatable = options.updatable;\n  const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\n  const cap = options.cap || Mesh.NO_CAP;\n  const pi2 = Math.PI * 2;\n  const paths = new Array();\n  const invertUV = options.invertUV || false;\n  let i = 0;\n  let p = 0;\n  const step = pi2 / tessellation * arc;\n  let rotated;\n  let path;\n  for (i = 0; i <= tessellation - clip; i++) {\n    path = [];\n    if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\n      path.push(new Vector3(0, shape[0].y, 0));\n      path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\n    }\n    for (p = 0; p < shape.length; p++) {\n      rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\n      path.push(rotated);\n    }\n    if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\n      path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\n      path.push(new Vector3(0, shape[shape.length - 1].y, 0));\n    }\n    paths.push(path);\n  }\n  // lathe ribbon\n  const lathe = CreateRibbon(name, {\n    pathArray: paths,\n    closeArray: closed,\n    sideOrientation: sideOrientation,\n    updatable: updatable,\n    invertUV: invertUV,\n    frontUVs: options.frontUVs,\n    backUVs: options.backUVs\n  }, scene);\n  return lathe;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function direction from the module\n */\nexport const LatheBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateLathe\n};\nMesh.CreateLathe = (name, shape, radius, tessellation, scene, updatable, sideOrientation) => {\n  const options = {\n    shape: shape,\n    radius: radius,\n    tessellation: tessellation,\n    sideOrientation: sideOrientation,\n    updatable: updatable\n  };\n  return CreateLathe(name, options, scene);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Mesh","CreateRibbon","CreateLathe","name","options","scene","arc","closed","undefined","shape","radius","tessellation","clip","updatable","sideOrientation","_GetDefaultSideOrientation","cap","NO_CAP","pi2","Math","PI","paths","Array","invertUV","i","p","step","rotated","path","CAP_START","CAP_ALL","push","y","cos","x","sin","length","CAP_END","lathe","pathArray","closeArray","frontUVs","backUVs","LatheBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/latheBuilder.ts"],"sourcesContent":["import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { CreateRibbon } from \"./ribbonBuilder\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n/**\r\n * Creates lathe mesh.\r\n * The lathe is a shape with a symmetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.shape\r\n * @param options.radius\r\n * @param options.tessellation\r\n * @param options.clip\r\n * @param options.arc\r\n * @param options.closed\r\n * @param options.updatable\r\n * @param options.sideOrientation\r\n * @param options.frontUVs\r\n * @param options.backUVs\r\n * @param options.cap\r\n * @param options.invertUV\r\n * @param scene defines the hosting scene\r\n * @returns the lathe mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lathe\r\n */\r\nexport function CreateLathe(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        radius?: number;\r\n        tessellation?: number;\r\n        clip?: number;\r\n        arc?: number;\r\n        closed?: boolean;\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        cap?: number;\r\n        invertUV?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const arc: number = options.arc ? (options.arc <= 0 || options.arc > 1 ? 1.0 : options.arc) : 1.0;\r\n    const closed: boolean = options.closed === undefined ? true : options.closed;\r\n    const shape = options.shape;\r\n    const radius = options.radius || 1;\r\n    const tessellation = options.tessellation || 64;\r\n    const clip = options.clip || 0;\r\n    const updatable = options.updatable;\r\n    const sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const cap = options.cap || Mesh.NO_CAP;\r\n    const pi2 = Math.PI * 2;\r\n    const paths = new Array();\r\n    const invertUV = options.invertUV || false;\r\n\r\n    let i = 0;\r\n    let p = 0;\r\n    const step = (pi2 / tessellation) * arc;\r\n    let rotated;\r\n    let path: Array<Vector3>;\r\n    for (i = 0; i <= tessellation - clip; i++) {\r\n        path = [];\r\n        if (cap == Mesh.CAP_START || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(0, shape[0].y, 0));\r\n            path.push(new Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n        }\r\n        for (p = 0; p < shape.length; p++) {\r\n            rotated = new Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n            path.push(rotated);\r\n        }\r\n        if (cap == Mesh.CAP_END || cap == Mesh.CAP_ALL) {\r\n            path.push(new Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n            path.push(new Vector3(0, shape[shape.length - 1].y, 0));\r\n        }\r\n        paths.push(path);\r\n    }\r\n\r\n    // lathe ribbon\r\n    const lathe = CreateRibbon(\r\n        name,\r\n        { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs },\r\n        scene\r\n    );\r\n    return lathe;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function direction from the module\r\n */\r\nexport const LatheBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateLathe,\r\n};\r\n\r\n(Mesh as any).CreateLathe = (name: string, shape: Vector3[], radius: number, tessellation: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable,\r\n    };\r\n\r\n    return CreateLathe(name, options, scene);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}