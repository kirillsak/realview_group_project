{"ast":null,"code":"import { Texture } from \"../../Materials/Textures/texture.js\";\nimport { Vector2 } from \"../../Maths/math.vector.js\";\nimport { PostProcess } from \"../../PostProcesses/postProcess.js\";\nimport { Observable } from \"../../Misc/observable.js\";\n/** @internal */\nexport class FluidRenderingTextures {\n  constructor(name, scene, width, height, blurTextureSizeX, blurTextureSizeY, textureType = 1, textureFormat = 6, blurTextureType = 1, blurTextureFormat = 6, useStandardBlur = false, camera = null, generateDepthBuffer = true, samples = 1) {\n    this.enableBlur = true;\n    this.blurSizeDivisor = 1;\n    this.blurFilterSize = 7;\n    this._blurNumIterations = 3;\n    this.blurMaxFilterSize = 100;\n    this.blurDepthScale = 10;\n    this.particleSize = 0.02;\n    this.onDisposeObservable = new Observable();\n    this._name = name;\n    this._scene = scene;\n    this._camera = camera;\n    this._engine = scene.getEngine();\n    this._width = width;\n    this._height = height;\n    this._blurTextureSizeX = blurTextureSizeX;\n    this._blurTextureSizeY = blurTextureSizeY;\n    this._textureType = textureType;\n    this._textureFormat = textureFormat;\n    this._blurTextureType = blurTextureType;\n    this._blurTextureFormat = blurTextureFormat;\n    this._useStandardBlur = useStandardBlur;\n    this._generateDepthBuffer = generateDepthBuffer;\n    this._samples = samples;\n    this._postProcessRunningIndex = 0;\n    this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\n    this._rt = null;\n    this._texture = null;\n    this._rtBlur = null;\n    this._textureBlurred = null;\n    this._blurPostProcesses = null;\n  }\n  get blurNumIterations() {\n    return this._blurNumIterations;\n  }\n  set blurNumIterations(numIterations) {\n    if (this._blurNumIterations === numIterations) {\n      return;\n    }\n    this._blurNumIterations = numIterations;\n    if (this._blurPostProcesses !== null) {\n      const blurX = this._blurPostProcesses[0];\n      const blurY = this._blurPostProcesses[1];\n      this._blurPostProcesses = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\n      }\n    }\n  }\n  get renderTarget() {\n    return this._rt;\n  }\n  get renderTargetBlur() {\n    return this._rtBlur;\n  }\n  get texture() {\n    return this._texture;\n  }\n  get textureBlur() {\n    return this._textureBlurred;\n  }\n  initialize() {\n    this.dispose();\n    this._createRenderTarget();\n    if (this.enableBlur && this._texture) {\n      const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(this._texture, this._blurTextureType, this._blurTextureFormat, this.blurSizeDivisor, this._name, this._useStandardBlur);\n      this._rtBlur = rtBlur;\n      this._textureBlurred = textureBlurred;\n      this._blurPostProcesses = blurPostProcesses;\n    }\n  }\n  applyBlurPostProcesses() {\n    if (this.enableBlur && this._blurPostProcesses) {\n      this._postProcessRunningIndex = 0;\n      this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\n      this._engine.unBindFramebuffer(this._rtBlur);\n    }\n  }\n  _createRenderTarget() {\n    this._rt = this._engine.createRenderTargetTexture({\n      width: this._width,\n      height: this._height\n    }, {\n      generateMipMaps: false,\n      type: this._textureType,\n      format: this._textureFormat,\n      samplingMode: 1,\n      generateDepthBuffer: this._generateDepthBuffer,\n      generateStencilBuffer: false,\n      samples: this._samples\n    });\n    const renderTexture = this._rt.texture;\n    renderTexture.incrementReferences();\n    this._texture = new Texture(null, this._scene);\n    this._texture.name = \"rtt\" + this._name;\n    this._texture._texture = renderTexture;\n    this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    this._texture.anisotropicFilteringLevel = 1;\n  }\n  _createBlurPostProcesses(textureBlurSource, textureType, textureFormat, blurSizeDivisor, debugName, useStandardBlur = false) {\n    const engine = this._scene.getEngine();\n    const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\n    const useBilinearFiltering = textureType === 1 && engine.getCaps().textureFloatLinearFiltering || textureType === 2 && engine.getCaps().textureHalfFloatLinearFiltering;\n    const rtBlur = this._engine.createRenderTargetTexture({\n      width: targetSize.x,\n      height: targetSize.y\n    }, {\n      generateMipMaps: false,\n      type: textureType,\n      format: textureFormat,\n      samplingMode: useBilinearFiltering ? 2 : 1,\n      generateDepthBuffer: false,\n      generateStencilBuffer: false,\n      samples: this._samples\n    });\n    const renderTexture = rtBlur.texture;\n    renderTexture.incrementReferences();\n    const texture = new Texture(null, this._scene);\n    texture.name = \"rttBlurred\" + debugName;\n    texture._texture = renderTexture;\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n    texture.anisotropicFilteringLevel = 1;\n    if (useStandardBlur) {\n      const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurXPostprocess.samples = this._samples;\n      kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n      kernelBlurXPostprocess.onApplyObservable.add(effect => {\n        if (this._postProcessRunningIndex === 0) {\n          effect.setTexture(\"textureSampler\", textureBlurSource);\n        } else {\n          effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n        }\n        effect.setInt(\"filterSize\", this.blurFilterSize);\n        effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurXPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurXPostprocess);\n      const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingStandardBlur\", [\"filterSize\", \"blurDir\"], null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurYPostprocess.samples = this._samples;\n      kernelBlurYPostprocess.onApplyObservable.add(effect => {\n        effect.setInt(\"filterSize\", this.blurFilterSize);\n        effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurYPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurYPostprocess);\n      kernelBlurXPostprocess.autoClear = false;\n      kernelBlurYPostprocess.autoClear = false;\n      const blurList = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n      }\n      return [rtBlur, texture, blurList];\n    } else {\n      const uniforms = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\n      const kernelBlurXPostprocess = new PostProcess(\"BilateralBlurX\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurXPostprocess.samples = this._samples;\n      kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n      kernelBlurXPostprocess.onApplyObservable.add(effect => {\n        if (this._postProcessRunningIndex === 0) {\n          effect.setTexture(\"textureSampler\", textureBlurSource);\n        } else {\n          effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\n        }\n        effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n        effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n        effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n        effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurXPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurXPostprocess);\n      const kernelBlurYPostprocess = new PostProcess(\"BilateralBlurY\", \"fluidRenderingBilateralBlur\", uniforms, null, 1, null, 1, engine, true, null, textureType, undefined, undefined, undefined, textureFormat);\n      kernelBlurYPostprocess.samples = this._samples;\n      kernelBlurYPostprocess.onApplyObservable.add(effect => {\n        effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n        effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n        effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\n        effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n        this._postProcessRunningIndex++;\n      });\n      kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n        kernelBlurYPostprocess._textures.forEach(rt => {\n          rt.texture.wrapU = Texture.CLAMP_ADDRESSMODE;\n          rt.texture.wrapV = Texture.CLAMP_ADDRESSMODE;\n        });\n      });\n      this._fixReusablePostProcess(kernelBlurYPostprocess);\n      kernelBlurXPostprocess.autoClear = false;\n      kernelBlurYPostprocess.autoClear = false;\n      const blurList = [];\n      for (let i = 0; i < this._blurNumIterations * 2; ++i) {\n        blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\n      }\n      return [rtBlur, texture, blurList];\n    }\n  }\n  _fixReusablePostProcess(pp) {\n    if (!pp.isReusable()) {\n      return;\n    }\n    pp.onActivateObservable.add(() => {\n      // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\n      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n    });\n    pp.onApplyObservable.add(() => {\n      // now we can advance to the next texture\n      pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n    });\n  }\n  _getProjectedParticleConstant() {\n    var _a, _b;\n    return this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2) / Math.tan(((_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.fov) !== null && _b !== void 0 ? _b : 45 * Math.PI / 180) / 2);\n  }\n  _getDepthThreshold() {\n    return this.particleSize / 2 * this.blurDepthScale;\n  }\n  dispose() {\n    var _a, _b, _c, _d;\n    if (this.onDisposeObservable.hasObservers()) {\n      this.onDisposeObservable.notifyObservers(this);\n    }\n    (_a = this._rt) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._rt = null;\n    (_b = this._texture) === null || _b === void 0 ? void 0 : _b.dispose();\n    this._texture = null;\n    (_c = this._rtBlur) === null || _c === void 0 ? void 0 : _c.dispose();\n    this._rtBlur = null;\n    (_d = this._textureBlurred) === null || _d === void 0 ? void 0 : _d.dispose();\n    this._textureBlurred = null;\n    if (this._blurPostProcesses) {\n      this._blurPostProcesses[0].dispose();\n      this._blurPostProcesses[1].dispose();\n    }\n    this._blurPostProcesses = null;\n  }\n}","map":{"version":3,"mappings":"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","names":["Texture","Vector2","PostProcess","Observable","FluidRenderingTextures","constructor","name","scene","width","height","blurTextureSizeX","blurTextureSizeY","textureType","camera","_name","_scene","_camera","_engine","getEngine","_width","_height","_blurTextureSizeX","_blurTextureSizeY","_textureType","_textureFormat","textureFormat","_blurTextureType","blurTextureType","_blurTextureFormat","blurTextureFormat","_useStandardBlur","useStandardBlur","_generateDepthBuffer","generateDepthBuffer","_samples","samples","_postProcessRunningIndex","enableBlur","_rt","_texture","_rtBlur","_textureBlurred","_blurPostProcesses","blurNumIterations","_blurNumIterations","numIterations","blurX","blurY","i","renderTarget","renderTargetBlur","texture","textureBlur","initialize","dispose","_createRenderTarget","rtBlur","textureBlurred","blurPostProcesses","_createBlurPostProcesses","blurSizeDivisor","applyBlurPostProcesses","postProcessManager","directRender","unBindFramebuffer","createRenderTargetTexture","generateMipMaps","type","format","samplingMode","generateStencilBuffer","renderTexture","incrementReferences","wrapU","CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","textureBlurSource","debugName","engine","targetSize","Math","floor","useBilinearFiltering","x","y","kernelBlurXPostprocess","undefined","externalTextureSamplerBinding","onApplyObservable","add","effect","setTexture","_bindTexture","inputTexture","setInt","blurFilterSize","setFloat2","onSizeChangedObservable","_textures","forEach","rt","_fixReusablePostProcess","kernelBlurYPostprocess","autoClear","blurList","uniforms","blurMaxFilterSize","setFloat","_getProjectedParticleConstant","_getDepthThreshold","pp","isReusable","onActivateObservable","_currentRenderTextureInd","particleSize","tan","fov","PI","blurDepthScale","onDisposeObservable","hasObservers","notifyObservers"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Rendering/fluidRenderer/fluidRenderingTextures.ts"],"sourcesContent":["import type { Camera } from \"core/Cameras/camera\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { Engine } from \"core/Engines/engine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { PostProcess } from \"core/PostProcesses/postProcess\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\n\r\n/** @internal */\r\nexport class FluidRenderingTextures {\r\n    protected _name: string;\r\n    protected _scene: Scene;\r\n    protected _camera: Nullable<Camera>;\r\n    protected _engine: Engine;\r\n    protected _width: number;\r\n    protected _height: number;\r\n    protected _blurTextureSizeX: number;\r\n    protected _blurTextureSizeY: number;\r\n    protected _textureType: number;\r\n    protected _textureFormat: number;\r\n    protected _blurTextureType: number;\r\n    protected _blurTextureFormat: number;\r\n    protected _useStandardBlur: boolean;\r\n    protected _generateDepthBuffer: boolean;\r\n    protected _samples: number;\r\n    protected _postProcessRunningIndex: number;\r\n\r\n    protected _rt: Nullable<RenderTargetWrapper>;\r\n    protected _texture: Nullable<Texture>;\r\n    protected _rtBlur: Nullable<RenderTargetWrapper>;\r\n    protected _textureBlurred: Nullable<Texture>;\r\n    protected _blurPostProcesses: Nullable<PostProcess[]>;\r\n\r\n    public enableBlur = true;\r\n\r\n    public blurSizeDivisor = 1;\r\n\r\n    public blurFilterSize = 7;\r\n\r\n    private _blurNumIterations = 3;\r\n\r\n    public get blurNumIterations() {\r\n        return this._blurNumIterations;\r\n    }\r\n\r\n    public set blurNumIterations(numIterations: number) {\r\n        if (this._blurNumIterations === numIterations) {\r\n            return;\r\n        }\r\n\r\n        this._blurNumIterations = numIterations;\r\n        if (this._blurPostProcesses !== null) {\r\n            const blurX = this._blurPostProcesses[0];\r\n            const blurY = this._blurPostProcesses[1];\r\n\r\n            this._blurPostProcesses = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                this._blurPostProcesses[i] = i & 1 ? blurY : blurX;\r\n            }\r\n        }\r\n    }\r\n\r\n    public blurMaxFilterSize = 100;\r\n\r\n    public blurDepthScale = 10;\r\n\r\n    public particleSize = 0.02;\r\n\r\n    public onDisposeObservable: Observable<FluidRenderingTextures> = new Observable<FluidRenderingTextures>();\r\n\r\n    public get renderTarget() {\r\n        return this._rt;\r\n    }\r\n\r\n    public get renderTargetBlur() {\r\n        return this._rtBlur;\r\n    }\r\n\r\n    public get texture() {\r\n        return this._texture;\r\n    }\r\n\r\n    public get textureBlur() {\r\n        return this._textureBlurred;\r\n    }\r\n\r\n    constructor(\r\n        name: string,\r\n        scene: Scene,\r\n        width: number,\r\n        height: number,\r\n        blurTextureSizeX: number,\r\n        blurTextureSizeY: number,\r\n        textureType: number = Constants.TEXTURETYPE_FLOAT,\r\n        textureFormat: number = Constants.TEXTUREFORMAT_R,\r\n        blurTextureType: number = Constants.TEXTURETYPE_FLOAT,\r\n        blurTextureFormat: number = Constants.TEXTUREFORMAT_R,\r\n        useStandardBlur = false,\r\n        camera: Nullable<Camera> = null,\r\n        generateDepthBuffer = true,\r\n        samples = 1\r\n    ) {\r\n        this._name = name;\r\n        this._scene = scene;\r\n        this._camera = camera;\r\n        this._engine = scene.getEngine();\r\n        this._width = width;\r\n        this._height = height;\r\n        this._blurTextureSizeX = blurTextureSizeX;\r\n        this._blurTextureSizeY = blurTextureSizeY;\r\n        this._textureType = textureType;\r\n        this._textureFormat = textureFormat;\r\n        this._blurTextureType = blurTextureType;\r\n        this._blurTextureFormat = blurTextureFormat;\r\n        this._useStandardBlur = useStandardBlur;\r\n        this._generateDepthBuffer = generateDepthBuffer;\r\n        this._samples = samples;\r\n        this._postProcessRunningIndex = 0;\r\n        this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\r\n\r\n        this._rt = null;\r\n        this._texture = null;\r\n        this._rtBlur = null;\r\n        this._textureBlurred = null;\r\n        this._blurPostProcesses = null;\r\n    }\r\n\r\n    public initialize(): void {\r\n        this.dispose();\r\n\r\n        this._createRenderTarget();\r\n\r\n        if (this.enableBlur && this._texture) {\r\n            const [rtBlur, textureBlurred, blurPostProcesses] = this._createBlurPostProcesses(\r\n                this._texture,\r\n                this._blurTextureType,\r\n                this._blurTextureFormat,\r\n                this.blurSizeDivisor,\r\n                this._name,\r\n                this._useStandardBlur\r\n            );\r\n            this._rtBlur = rtBlur;\r\n            this._textureBlurred = textureBlurred;\r\n            this._blurPostProcesses = blurPostProcesses;\r\n        }\r\n    }\r\n\r\n    public applyBlurPostProcesses(): void {\r\n        if (this.enableBlur && this._blurPostProcesses) {\r\n            this._postProcessRunningIndex = 0;\r\n            this._scene.postProcessManager.directRender(this._blurPostProcesses, this._rtBlur, true);\r\n            this._engine.unBindFramebuffer(this._rtBlur!);\r\n        }\r\n    }\r\n\r\n    protected _createRenderTarget(): void {\r\n        this._rt = this._engine.createRenderTargetTexture(\r\n            { width: this._width, height: this._height },\r\n            {\r\n                generateMipMaps: false,\r\n                type: this._textureType,\r\n                format: this._textureFormat,\r\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: this._generateDepthBuffer,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n            }\r\n        );\r\n\r\n        const renderTexture = this._rt.texture!;\r\n\r\n        renderTexture.incrementReferences();\r\n\r\n        this._texture = new Texture(null, this._scene);\r\n        this._texture.name = \"rtt\" + this._name;\r\n        this._texture._texture = renderTexture;\r\n        this._texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._texture.anisotropicFilteringLevel = 1;\r\n    }\r\n\r\n    protected _createBlurPostProcesses(\r\n        textureBlurSource: ThinTexture,\r\n        textureType: number,\r\n        textureFormat: number,\r\n        blurSizeDivisor: number,\r\n        debugName: string,\r\n        useStandardBlur = false\r\n    ): [RenderTargetWrapper, Texture, PostProcess[]] {\r\n        const engine = this._scene.getEngine();\r\n        const targetSize = new Vector2(Math.floor(this._blurTextureSizeX / blurSizeDivisor), Math.floor(this._blurTextureSizeY / blurSizeDivisor));\r\n        const useBilinearFiltering =\r\n            (textureType === Constants.TEXTURETYPE_FLOAT && engine.getCaps().textureFloatLinearFiltering) ||\r\n            (textureType === Constants.TEXTURETYPE_HALF_FLOAT && engine.getCaps().textureHalfFloatLinearFiltering);\r\n\r\n        const rtBlur = this._engine.createRenderTargetTexture(\r\n            { width: targetSize.x, height: targetSize.y },\r\n            {\r\n                generateMipMaps: false,\r\n                type: textureType,\r\n                format: textureFormat,\r\n                samplingMode: useBilinearFiltering ? Constants.TEXTURE_BILINEAR_SAMPLINGMODE : Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                samples: this._samples,\r\n            }\r\n        );\r\n\r\n        const renderTexture = rtBlur.texture!;\r\n\r\n        renderTexture.incrementReferences();\r\n\r\n        const texture = new Texture(null, this._scene);\r\n        texture.name = \"rttBlurred\" + debugName;\r\n        texture._texture = renderTexture;\r\n        texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        texture.anisotropicFilteringLevel = 1;\r\n\r\n        if (useStandardBlur) {\r\n            const kernelBlurXPostprocess = new PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"fluidRenderingStandardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\r\n                }\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"fluidRenderingStandardBlur\",\r\n                [\"filterSize\", \"blurDir\"],\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"filterSize\", this.blurFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            const blurList = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\r\n            }\r\n\r\n            return [rtBlur, texture, blurList];\r\n        } else {\r\n            const uniforms: string[] = [\"maxFilterSize\", \"blurDir\", \"projectedParticleConstant\", \"depthThreshold\"];\r\n\r\n            const kernelBlurXPostprocess = new PostProcess(\r\n                \"BilateralBlurX\",\r\n                \"fluidRenderingBilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurXPostprocess.samples = this._samples;\r\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\r\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\r\n                if (this._postProcessRunningIndex === 0) {\r\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\r\n                } else {\r\n                    effect._bindTexture(\"textureSampler\", kernelBlurXPostprocess.inputTexture.texture);\r\n                }\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\r\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurXPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\r\n\r\n            const kernelBlurYPostprocess = new PostProcess(\r\n                \"BilateralBlurY\",\r\n                \"fluidRenderingBilateralBlur\",\r\n                uniforms,\r\n                null,\r\n                1,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                engine,\r\n                true,\r\n                null,\r\n                textureType,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                textureFormat\r\n            );\r\n            kernelBlurYPostprocess.samples = this._samples;\r\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\r\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\r\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\r\n                effect.setFloat(\"projectedParticleConstant\", this._getProjectedParticleConstant());\r\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\r\n                this._postProcessRunningIndex++;\r\n            });\r\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\r\n                kernelBlurYPostprocess._textures.forEach((rt) => {\r\n                    rt.texture!.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n                    rt.texture!.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n                });\r\n            });\r\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\r\n\r\n            kernelBlurXPostprocess.autoClear = false;\r\n            kernelBlurYPostprocess.autoClear = false;\r\n\r\n            const blurList = [];\r\n            for (let i = 0; i < this._blurNumIterations * 2; ++i) {\r\n                blurList[i] = i & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess;\r\n            }\r\n\r\n            return [rtBlur, texture, blurList];\r\n        }\r\n    }\r\n\r\n    private _fixReusablePostProcess(pp: PostProcess) {\r\n        if (!pp.isReusable()) {\r\n            return;\r\n        }\r\n\r\n        pp.onActivateObservable.add(() => {\r\n            // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n        pp.onApplyObservable.add(() => {\r\n            // now we can advance to the next texture\r\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\r\n        });\r\n    }\r\n\r\n    private _getProjectedParticleConstant() {\r\n        return (this.blurFilterSize * this.particleSize * 0.05 * (this._height / 2)) / Math.tan((this._camera?.fov ?? (45 * Math.PI) / 180) / 2);\r\n    }\r\n\r\n    private _getDepthThreshold() {\r\n        return (this.particleSize / 2) * this.blurDepthScale;\r\n    }\r\n\r\n    public dispose(): void {\r\n        if (this.onDisposeObservable.hasObservers()) {\r\n            this.onDisposeObservable.notifyObservers(this);\r\n        }\r\n\r\n        this._rt?.dispose();\r\n        this._rt = null;\r\n        this._texture?.dispose();\r\n        this._texture = null;\r\n        this._rtBlur?.dispose();\r\n        this._rtBlur = null;\r\n        this._textureBlurred?.dispose();\r\n        this._textureBlurred = null;\r\n        if (this._blurPostProcesses) {\r\n            this._blurPostProcesses[0].dispose();\r\n            this._blurPostProcesses[1].dispose();\r\n        }\r\n        this._blurPostProcesses = null;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}