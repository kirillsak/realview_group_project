{"ast":null,"code":"/**\n * Class used to store shared data between 2 NodeMaterialBuildState\n */\nexport class NodeMaterialBuildStateSharedData {\n  /** Creates a new shared data */\n  constructor() {\n    /**\n     * Gets the list of emitted varyings\n     */\n    this.temps = new Array();\n    /**\n     * Gets the list of emitted varyings\n     */\n    this.varyings = new Array();\n    /**\n     * Gets the varying declaration string\n     */\n    this.varyingDeclaration = \"\";\n    /**\n     * Input blocks\n     */\n    this.inputBlocks = new Array();\n    /**\n     * Input blocks\n     */\n    this.textureBlocks = new Array();\n    /**\n     * Bindable blocks (Blocks that need to set data to the effect)\n     */\n    this.bindableBlocks = new Array();\n    /**\n     * Bindable blocks (Blocks that need to set data to the effect) that will always be called (by bindForSubMesh), contrary to bindableBlocks that won't be called if _mustRebind() returns false\n     */\n    this.forcedBindableBlocks = new Array();\n    /**\n     * List of blocks that can provide a compilation fallback\n     */\n    this.blocksWithFallbacks = new Array();\n    /**\n     * List of blocks that can provide a define update\n     */\n    this.blocksWithDefines = new Array();\n    /**\n     * List of blocks that can provide a repeatable content\n     */\n    this.repeatableContentBlocks = new Array();\n    /**\n     * List of blocks that can provide a dynamic list of uniforms\n     */\n    this.dynamicUniformBlocks = new Array();\n    /**\n     * List of blocks that can block the isReady function for the material\n     */\n    this.blockingBlocks = new Array();\n    /**\n     * Gets the list of animated inputs\n     */\n    this.animatedInputs = new Array();\n    /** List of emitted variables */\n    this.variableNames = {};\n    /** List of emitted defines */\n    this.defineNames = {};\n    /**\n     * Gets the compilation hints emitted at compilation time\n     */\n    this.hints = {\n      needWorldViewMatrix: false,\n      needWorldViewProjectionMatrix: false,\n      needAlphaBlending: false,\n      needAlphaTesting: false\n    };\n    /**\n     * List of compilation checks\n     */\n    this.checks = {\n      emitVertex: false,\n      emitFragment: false,\n      notConnectedNonOptionalInputs: new Array()\n    };\n    /**\n     * Is vertex program allowed to be empty?\n     */\n    this.allowEmptyVertexProgram = false;\n    // Exclude usual attributes from free variable names\n    this.variableNames[\"position\"] = 0;\n    this.variableNames[\"normal\"] = 0;\n    this.variableNames[\"tangent\"] = 0;\n    this.variableNames[\"uv\"] = 0;\n    this.variableNames[\"uv2\"] = 0;\n    this.variableNames[\"uv3\"] = 0;\n    this.variableNames[\"uv4\"] = 0;\n    this.variableNames[\"uv5\"] = 0;\n    this.variableNames[\"uv6\"] = 0;\n    this.variableNames[\"color\"] = 0;\n    this.variableNames[\"matricesIndices\"] = 0;\n    this.variableNames[\"matricesWeights\"] = 0;\n    this.variableNames[\"matricesIndicesExtra\"] = 0;\n    this.variableNames[\"matricesWeightsExtra\"] = 0;\n    this.variableNames[\"diffuseBase\"] = 0;\n    this.variableNames[\"specularBase\"] = 0;\n    this.variableNames[\"worldPos\"] = 0;\n    this.variableNames[\"shadow\"] = 0;\n    this.variableNames[\"view\"] = 0;\n    // Exclude known varyings\n    this.variableNames[\"vTBN\"] = 0;\n    // Exclude defines\n    this.defineNames[\"MAINUV0\"] = 0;\n    this.defineNames[\"MAINUV1\"] = 0;\n    this.defineNames[\"MAINUV2\"] = 0;\n    this.defineNames[\"MAINUV3\"] = 0;\n    this.defineNames[\"MAINUV4\"] = 0;\n    this.defineNames[\"MAINUV5\"] = 0;\n    this.defineNames[\"MAINUV6\"] = 0;\n    this.defineNames[\"MAINUV7\"] = 0;\n  }\n  /**\n   * Emits console errors and exceptions if there is a failing check\n   */\n  emitErrors() {\n    let errorMessage = \"\";\n    if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\n      errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\\r\\n\";\n    }\n    if (!this.checks.emitFragment) {\n      errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\\r\\n\";\n    }\n    for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\n      errorMessage += `input ${notConnectedInput.name} from block ${notConnectedInput.ownerBlock.name}[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\r\\n`;\n    }\n    if (errorMessage) {\n      throw \"Build of NodeMaterial failed:\\r\\n\" + errorMessage;\n    }\n  }\n}","map":{"version":3,"mappings":"AAOA;;;AAGA,OAAM,MAAOA,gCAAgC;EAmHzC;EACAC;IAnHA;;;IAGO,UAAK,GAAG,IAAIC,KAAK,EAAU;IAElC;;;IAGO,aAAQ,GAAG,IAAIA,KAAK,EAAU;IAErC;;;IAGO,uBAAkB,GAAG,EAAE;IAO9B;;;IAGO,gBAAW,GAAG,IAAIA,KAAK,EAAc;IAE5C;;;IAGO,kBAAa,GAAG,IAAIA,KAAK,EAA6B;IAE7D;;;IAGO,mBAAc,GAAG,IAAIA,KAAK,EAAqB;IAEtD;;;IAGO,yBAAoB,GAAG,IAAIA,KAAK,EAAqB;IAE5D;;;IAGO,wBAAmB,GAAG,IAAIA,KAAK,EAAqB;IAE3D;;;IAGO,sBAAiB,GAAG,IAAIA,KAAK,EAAqB;IAEzD;;;IAGO,4BAAuB,GAAG,IAAIA,KAAK,EAAqB;IAE/D;;;IAGO,yBAAoB,GAAG,IAAIA,KAAK,EAAqB;IAE5D;;;IAGO,mBAAc,GAAG,IAAIA,KAAK,EAAqB;IAEtD;;;IAGO,mBAAc,GAAG,IAAIA,KAAK,EAAc;IAO/C;IACO,kBAAa,GAA8B,EAAE;IAEpD;IACO,gBAAW,GAA8B,EAAE;IAWlD;;;IAGO,UAAK,GAAG;MACXC,mBAAmB,EAAE,KAAK;MAC1BC,6BAA6B,EAAE,KAAK;MACpCC,iBAAiB,EAAE,KAAK;MACxBC,gBAAgB,EAAE;KACrB;IAED;;;IAGO,WAAM,GAAG;MACZC,UAAU,EAAE,KAAK;MACjBC,YAAY,EAAE,KAAK;MACnBC,6BAA6B,EAAE,IAAIP,KAAK;KAC3C;IAED;;;IAGO,4BAAuB,GAAY,KAAK;IAI3C;IACA,IAAI,CAACQ,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC;IAClC,IAAI,CAACA,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC;IAChC,IAAI,CAACA,aAAa,CAAC,SAAS,CAAC,GAAG,CAAC;IACjC,IAAI,CAACA,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC;IAC5B,IAAI,CAACA,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAI,CAACA,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAI,CAACA,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAI,CAACA,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAI,CAACA,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC;IAC7B,IAAI,CAACA,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,aAAa,CAAC,iBAAiB,CAAC,GAAG,CAAC;IACzC,IAAI,CAACA,aAAa,CAAC,iBAAiB,CAAC,GAAG,CAAC;IACzC,IAAI,CAACA,aAAa,CAAC,sBAAsB,CAAC,GAAG,CAAC;IAC9C,IAAI,CAACA,aAAa,CAAC,sBAAsB,CAAC,GAAG,CAAC;IAC9C,IAAI,CAACA,aAAa,CAAC,aAAa,CAAC,GAAG,CAAC;IACrC,IAAI,CAACA,aAAa,CAAC,cAAc,CAAC,GAAG,CAAC;IACtC,IAAI,CAACA,aAAa,CAAC,UAAU,CAAC,GAAG,CAAC;IAClC,IAAI,CAACA,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC;IAChC,IAAI,CAACA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC;IAE9B;IACA,IAAI,CAACA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC;IAE9B;IACA,IAAI,CAACC,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;IAC/B,IAAI,CAACA,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC;EACnC;EAEA;;;EAGOC,UAAU;IACb,IAAIC,YAAY,GAAG,EAAE;IAErB,IAAI,CAAC,IAAI,CAACC,MAAM,CAACP,UAAU,IAAI,CAAC,IAAI,CAACQ,uBAAuB,EAAE;MAC1DF,YAAY,IAAI,qHAAqH;;IAEzI,IAAI,CAAC,IAAI,CAACC,MAAM,CAACN,YAAY,EAAE;MAC3BK,YAAY,IAAI,wHAAwH;;IAE5I,KAAK,MAAMG,iBAAiB,IAAI,IAAI,CAACF,MAAM,CAACL,6BAA6B,EAAE;MACvEI,YAAY,IAAI,SAASG,iBAAiB,CAACC,IAAI,eAC3CD,iBAAiB,CAACE,UAAU,CAACD,IACjC,IAAID,iBAAiB,CAACE,UAAU,CAACC,YAAY,EAAE,6CAA6C;;IAGhG,IAAIN,YAAY,EAAE;MACd,MAAM,mCAAmC,GAAGA,YAAY;;EAEhE","names":["NodeMaterialBuildStateSharedData","constructor","Array","needWorldViewMatrix","needWorldViewProjectionMatrix","needAlphaBlending","needAlphaTesting","emitVertex","emitFragment","notConnectedNonOptionalInputs","variableNames","defineNames","emitErrors","errorMessage","checks","allowEmptyVertexProgram","notConnectedInput","name","ownerBlock","getClassName"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Node/nodeMaterialBuildStateSharedData.ts"],"sourcesContent":["import type { NodeMaterialConnectionPoint } from \"./nodeMaterialBlockConnectionPoint\";\r\nimport type { NodeMaterialBlock } from \"./nodeMaterialBlock\";\r\nimport type { InputBlock } from \"./Blocks/Input/inputBlock\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Immutable } from \"../../types\";\r\nimport type { NodeMaterialTextureBlocks } from \"./nodeMaterial\";\r\n\r\n/**\r\n * Class used to store shared data between 2 NodeMaterialBuildState\r\n */\r\nexport class NodeMaterialBuildStateSharedData {\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public temps = new Array<string>();\r\n\r\n    /**\r\n     * Gets the list of emitted varyings\r\n     */\r\n    public varyings = new Array<string>();\r\n\r\n    /**\r\n     * Gets the varying declaration string\r\n     */\r\n    public varyingDeclaration = \"\";\r\n\r\n    /**\r\n     * List of the fragment output nodes\r\n     */\r\n    public fragmentOutputNodes: Immutable<Array<NodeMaterialBlock>>;\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public inputBlocks = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Input blocks\r\n     */\r\n    public textureBlocks = new Array<NodeMaterialTextureBlocks>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect)\r\n     */\r\n    public bindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Bindable blocks (Blocks that need to set data to the effect) that will always be called (by bindForSubMesh), contrary to bindableBlocks that won't be called if _mustRebind() returns false\r\n     */\r\n    public forcedBindableBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a compilation fallback\r\n     */\r\n    public blocksWithFallbacks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a define update\r\n     */\r\n    public blocksWithDefines = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a repeatable content\r\n     */\r\n    public repeatableContentBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can provide a dynamic list of uniforms\r\n     */\r\n    public dynamicUniformBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * List of blocks that can block the isReady function for the material\r\n     */\r\n    public blockingBlocks = new Array<NodeMaterialBlock>();\r\n\r\n    /**\r\n     * Gets the list of animated inputs\r\n     */\r\n    public animatedInputs = new Array<InputBlock>();\r\n\r\n    /**\r\n     * Build Id used to avoid multiple recompilations\r\n     */\r\n    public buildId: number;\r\n\r\n    /** List of emitted variables */\r\n    public variableNames: { [key: string]: number } = {};\r\n\r\n    /** List of emitted defines */\r\n    public defineNames: { [key: string]: number } = {};\r\n\r\n    /** Should emit comments? */\r\n    public emitComments: boolean;\r\n\r\n    /** Emit build activity */\r\n    public verbose: boolean;\r\n\r\n    /** Gets or sets the hosting scene */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Gets the compilation hints emitted at compilation time\r\n     */\r\n    public hints = {\r\n        needWorldViewMatrix: false,\r\n        needWorldViewProjectionMatrix: false,\r\n        needAlphaBlending: false,\r\n        needAlphaTesting: false,\r\n    };\r\n\r\n    /**\r\n     * List of compilation checks\r\n     */\r\n    public checks = {\r\n        emitVertex: false,\r\n        emitFragment: false,\r\n        notConnectedNonOptionalInputs: new Array<NodeMaterialConnectionPoint>(),\r\n    };\r\n\r\n    /**\r\n     * Is vertex program allowed to be empty?\r\n     */\r\n    public allowEmptyVertexProgram: boolean = false;\r\n\r\n    /** Creates a new shared data */\r\n    public constructor() {\r\n        // Exclude usual attributes from free variable names\r\n        this.variableNames[\"position\"] = 0;\r\n        this.variableNames[\"normal\"] = 0;\r\n        this.variableNames[\"tangent\"] = 0;\r\n        this.variableNames[\"uv\"] = 0;\r\n        this.variableNames[\"uv2\"] = 0;\r\n        this.variableNames[\"uv3\"] = 0;\r\n        this.variableNames[\"uv4\"] = 0;\r\n        this.variableNames[\"uv5\"] = 0;\r\n        this.variableNames[\"uv6\"] = 0;\r\n        this.variableNames[\"color\"] = 0;\r\n        this.variableNames[\"matricesIndices\"] = 0;\r\n        this.variableNames[\"matricesWeights\"] = 0;\r\n        this.variableNames[\"matricesIndicesExtra\"] = 0;\r\n        this.variableNames[\"matricesWeightsExtra\"] = 0;\r\n        this.variableNames[\"diffuseBase\"] = 0;\r\n        this.variableNames[\"specularBase\"] = 0;\r\n        this.variableNames[\"worldPos\"] = 0;\r\n        this.variableNames[\"shadow\"] = 0;\r\n        this.variableNames[\"view\"] = 0;\r\n\r\n        // Exclude known varyings\r\n        this.variableNames[\"vTBN\"] = 0;\r\n\r\n        // Exclude defines\r\n        this.defineNames[\"MAINUV0\"] = 0;\r\n        this.defineNames[\"MAINUV1\"] = 0;\r\n        this.defineNames[\"MAINUV2\"] = 0;\r\n        this.defineNames[\"MAINUV3\"] = 0;\r\n        this.defineNames[\"MAINUV4\"] = 0;\r\n        this.defineNames[\"MAINUV5\"] = 0;\r\n        this.defineNames[\"MAINUV6\"] = 0;\r\n        this.defineNames[\"MAINUV7\"] = 0;\r\n    }\r\n\r\n    /**\r\n     * Emits console errors and exceptions if there is a failing check\r\n     */\r\n    public emitErrors() {\r\n        let errorMessage = \"\";\r\n\r\n        if (!this.checks.emitVertex && !this.allowEmptyVertexProgram) {\r\n            errorMessage += \"NodeMaterial does not have a vertex output. You need to at least add a block that generates a glPosition value.\\r\\n\";\r\n        }\r\n        if (!this.checks.emitFragment) {\r\n            errorMessage += \"NodeMaterial does not have a fragment output. You need to at least add a block that generates a glFragColor value.\\r\\n\";\r\n        }\r\n        for (const notConnectedInput of this.checks.notConnectedNonOptionalInputs) {\r\n            errorMessage += `input ${notConnectedInput.name} from block ${\r\n                notConnectedInput.ownerBlock.name\r\n            }[${notConnectedInput.ownerBlock.getClassName()}] is not connected and is not optional.\\r\\n`;\r\n        }\r\n\r\n        if (errorMessage) {\r\n            throw \"Build of NodeMaterial failed:\\r\\n\" + errorMessage;\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}