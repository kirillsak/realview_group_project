{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color4 } from \"../Maths/math.color.js\";\nimport { VertexData } from \"../Meshes/mesh.vertexData.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { SubMesh } from \"../Meshes/subMesh.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { BoundingInfo } from \"../Culling/boundingInfo.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { extractMinAndMax } from \"../Maths/math.functions.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions.js\";\n/**\n * Class used to store geometry data (vertex buffers + index buffer)\n */\nexport class Geometry {\n  /**\n   * Creates a new geometry\n   * @param id defines the unique ID\n   * @param scene defines the hosting scene\n   * @param vertexData defines the VertexData used to get geometry data\n   * @param updatable defines if geometry must be updatable (false by default)\n   * @param mesh defines the mesh that will be associated with the geometry\n   */\n  constructor(id, scene, vertexData, updatable = false, mesh = null) {\n    /**\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\n     */\n    this.delayLoadState = 0;\n    this._totalVertices = 0;\n    this._isDisposed = false;\n    this._indexBufferIsUpdatable = false;\n    this._positionsCache = [];\n    /** @internal */\n    this._parentContainer = null;\n    /**\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\n     */\n    this.useBoundingInfoFromGeometry = false;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n    this.id = id;\n    this.uniqueId = this._scene.getUniqueId();\n    this._engine = this._scene.getEngine();\n    this._meshes = [];\n    //Init vertex buffer cache\n    this._vertexBuffers = {};\n    this._indices = [];\n    this._updatable = updatable;\n    // vertexData\n    if (vertexData) {\n      this.setAllVerticesData(vertexData, updatable);\n    } else {\n      this._totalVertices = 0;\n    }\n    if (this._engine.getCaps().vertexArrayObject) {\n      this._vertexArrayObjects = {};\n    }\n    // applyToMesh\n    if (mesh) {\n      this.applyToMesh(mesh);\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n   */\n  get boundingBias() {\n    return this._boundingBias;\n  }\n  /**\n   *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n   */\n  set boundingBias(value) {\n    if (this._boundingBias) {\n      this._boundingBias.copyFrom(value);\n    } else {\n      this._boundingBias = value.clone();\n    }\n    this._updateBoundingInfo(true, null);\n  }\n  /**\n   * Static function used to attach a new empty geometry to a mesh\n   * @param mesh defines the mesh to attach the geometry to\n   * @returns the new Geometry\n   */\n  static CreateGeometryForMesh(mesh) {\n    const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\n    geometry.applyToMesh(mesh);\n    return geometry;\n  }\n  /** Get the list of meshes using this geometry */\n  get meshes() {\n    return this._meshes;\n  }\n  /**\n   * Gets the current extend of the geometry\n   */\n  get extend() {\n    return this._extend;\n  }\n  /**\n   * Gets the hosting scene\n   * @returns the hosting Scene\n   */\n  getScene() {\n    return this._scene;\n  }\n  /**\n   * Gets the hosting engine\n   * @returns the hosting Engine\n   */\n  getEngine() {\n    return this._engine;\n  }\n  /**\n   * Defines if the geometry is ready to use\n   * @returns true if the geometry is ready to be used\n   */\n  isReady() {\n    return this.delayLoadState === 1 || this.delayLoadState === 0;\n  }\n  /**\n   * Gets a value indicating that the geometry should not be serialized\n   */\n  get doNotSerialize() {\n    for (let index = 0; index < this._meshes.length; index++) {\n      if (!this._meshes[index].doNotSerialize) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /** @internal */\n  _rebuild() {\n    if (this._vertexArrayObjects) {\n      this._vertexArrayObjects = {};\n    }\n    // Index buffer\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n    }\n    // Vertex buffers\n    for (const key in this._vertexBuffers) {\n      const vertexBuffer = this._vertexBuffers[key];\n      vertexBuffer._rebuild();\n    }\n  }\n  /**\n   * Affects all geometry data in one call\n   * @param vertexData defines the geometry data\n   * @param updatable defines if the geometry must be flagged as updatable (false as default)\n   */\n  setAllVerticesData(vertexData, updatable) {\n    vertexData.applyToGeometry(this, updatable);\n    this._notifyUpdate();\n  }\n  /**\n   * Set specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the vertex data to use\n   * @param updatable defines if the vertex must be flagged as updatable (false as default)\n   * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\n   */\n  setVerticesData(kind, data, updatable = false, stride) {\n    if (updatable && Array.isArray(data)) {\n      // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\n      data = new Float32Array(data);\n    }\n    const buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\n    this.setVerticesBuffer(buffer);\n  }\n  /**\n   * Removes a specific vertex data\n   * @param kind defines the data kind (Position, normal, etc...)\n   */\n  removeVerticesData(kind) {\n    if (this._vertexBuffers[kind]) {\n      this._vertexBuffers[kind].dispose();\n      delete this._vertexBuffers[kind];\n    }\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n  }\n  /**\n   * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\n   * @param buffer defines the vertex buffer to use\n   * @param totalVertices defines the total number of vertices for position kind (could be null)\n   * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n   */\n  setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {\n    const kind = buffer.getKind();\n    if (this._vertexBuffers[kind] && disposeExistingBuffer) {\n      this._vertexBuffers[kind].dispose();\n    }\n    if (buffer._buffer) {\n      buffer._buffer._increaseReferences();\n    }\n    this._vertexBuffers[kind] = buffer;\n    const meshes = this._meshes;\n    const numOfMeshes = meshes.length;\n    if (kind === VertexBuffer.PositionKind) {\n      const data = buffer.getData();\n      if (totalVertices != null) {\n        this._totalVertices = totalVertices;\n      } else {\n        if (data != null) {\n          this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);\n        }\n      }\n      this._updateExtend(data);\n      this._resetPointsArrayCache();\n      for (let index = 0; index < numOfMeshes; index++) {\n        const mesh = meshes[index];\n        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        mesh._createGlobalSubMesh(mesh.isUnIndexed);\n        mesh.computeWorldMatrix(true);\n        mesh.synchronizeInstances();\n      }\n    }\n    this._notifyUpdate(kind);\n  }\n  /**\n   * Update a specific vertex buffer\n   * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\n   * It will do nothing if the buffer is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param useBytes set to true if the offset is in bytes\n   */\n  updateVerticesDataDirectly(kind, data, offset, useBytes = false) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return;\n    }\n    vertexBuffer.updateDirectly(data, offset, useBytes);\n    this._notifyUpdate(kind);\n  }\n  /**\n   * Update a specific vertex buffer\n   * This function will create a new buffer if the current one is not updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param data defines the data to use\n   * @param updateExtends defines if the geometry extends must be recomputed (false by default)\n   */\n  updateVerticesData(kind, data, updateExtends = false) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return;\n    }\n    vertexBuffer.update(data);\n    if (kind === VertexBuffer.PositionKind) {\n      this._updateBoundingInfo(updateExtends, data);\n    }\n    this._notifyUpdate(kind);\n  }\n  _updateBoundingInfo(updateExtends, data) {\n    if (updateExtends) {\n      this._updateExtend(data);\n    }\n    this._resetPointsArrayCache();\n    if (updateExtends) {\n      const meshes = this._meshes;\n      for (const mesh of meshes) {\n        if (mesh.hasBoundingInfo) {\n          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\n        } else {\n          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        }\n        const subMeshes = mesh.subMeshes;\n        for (const subMesh of subMeshes) {\n          subMesh.refreshBoundingInfo();\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {\n    if (!effect) {\n      return;\n    }\n    if (indexToBind === undefined) {\n      indexToBind = this._indexBuffer;\n    }\n    const vbs = this.getVertexBuffers();\n    if (!vbs) {\n      return;\n    }\n    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {\n      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\n      return;\n    }\n    const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\n    // Using VAO\n    if (!vaos[effect.key]) {\n      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\n    }\n    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\n  }\n  /**\n   * Gets total number of vertices\n   * @returns the total number of vertices\n   */\n  getTotalVertices() {\n    if (!this.isReady()) {\n      return 0;\n    }\n    return this._totalVertices;\n  }\n  /**\n   * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n  getVerticesData(kind, copyWhenShared, forceCopy) {\n    const vertexBuffer = this.getVertexBuffer(kind);\n    if (!vertexBuffer) {\n      return null;\n    }\n    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);\n  }\n  /**\n   * Returns a boolean defining if the vertex data for the requested `kind` is updatable\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if the vertex buffer with the specified kind is updatable\n   */\n  isVertexBufferUpdatable(kind) {\n    const vb = this._vertexBuffers[kind];\n    if (!vb) {\n      return false;\n    }\n    return vb.isUpdatable();\n  }\n  /**\n   * Gets a specific vertex buffer\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns a VertexBuffer\n   */\n  getVertexBuffer(kind) {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._vertexBuffers[kind];\n  }\n  /**\n   * Returns all vertex buffers\n   * @returns an object holding all vertex buffers indexed by kind\n   */\n  getVertexBuffers() {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._vertexBuffers;\n  }\n  /**\n   * Gets a boolean indicating if specific vertex buffer is present\n   * @param kind defines the data kind (Position, normal, etc...)\n   * @returns true if data is present\n   */\n  isVerticesDataPresent(kind) {\n    if (!this._vertexBuffers) {\n      if (this._delayInfo) {\n        return this._delayInfo.indexOf(kind) !== -1;\n      }\n      return false;\n    }\n    return this._vertexBuffers[kind] !== undefined;\n  }\n  /**\n   * Gets a list of all attached data kinds (Position, normal, etc...)\n   * @returns a list of string containing all kinds\n   */\n  getVerticesDataKinds() {\n    const result = [];\n    let kind;\n    if (!this._vertexBuffers && this._delayInfo) {\n      for (kind in this._delayInfo) {\n        result.push(kind);\n      }\n    } else {\n      for (kind in this._vertexBuffers) {\n        result.push(kind);\n      }\n    }\n    return result;\n  }\n  /**\n   * Update index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param offset defines the offset in the target buffer where to store the data\n   * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n   */\n  updateIndices(indices, offset, gpuMemoryOnly = false) {\n    if (!this._indexBuffer) {\n      return;\n    }\n    if (!this._indexBufferIsUpdatable) {\n      this.setIndices(indices, null, true);\n    } else {\n      const needToUpdateSubMeshes = indices.length !== this._indices.length;\n      if (!gpuMemoryOnly) {\n        this._indices = indices.slice();\n      }\n      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\n      if (needToUpdateSubMeshes) {\n        for (const mesh of this._meshes) {\n          mesh._createGlobalSubMesh(true);\n        }\n      }\n    }\n  }\n  /**\n   * Creates a new index buffer\n   * @param indices defines the indices to store in the index buffer\n   * @param totalVertices defines the total number of vertices (could be null)\n   * @param updatable defines if the index buffer must be flagged as updatable (false by default)\n   */\n  setIndices(indices, totalVertices = null, updatable = false) {\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n    this._indices = indices;\n    this._indexBufferIsUpdatable = updatable;\n    if (this._meshes.length !== 0 && this._indices) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\n    }\n    if (totalVertices != undefined) {\n      // including null and undefined\n      this._totalVertices = totalVertices;\n    }\n    for (const mesh of this._meshes) {\n      mesh._createGlobalSubMesh(true);\n      mesh.synchronizeInstances();\n    }\n    this._notifyUpdate();\n  }\n  /**\n   * Return the total number of indices\n   * @returns the total number of indices\n   */\n  getTotalIndices() {\n    if (!this.isReady()) {\n      return 0;\n    }\n    return this._indices.length;\n  }\n  /**\n   * Gets the index buffer array\n   * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns the index buffer array\n   */\n  getIndices(copyWhenShared, forceCopy) {\n    if (!this.isReady()) {\n      return null;\n    }\n    const orig = this._indices;\n    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n      return orig;\n    } else {\n      return orig.slice();\n    }\n  }\n  /**\n   * Gets the index buffer\n   * @returns the index buffer\n   */\n  getIndexBuffer() {\n    if (!this.isReady()) {\n      return null;\n    }\n    return this._indexBuffer;\n  }\n  /**\n   * @internal\n   */\n  _releaseVertexArrayObject(effect = null) {\n    if (!effect || !this._vertexArrayObjects) {\n      return;\n    }\n    if (this._vertexArrayObjects[effect.key]) {\n      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n      delete this._vertexArrayObjects[effect.key];\n    }\n  }\n  /**\n   * Release the associated resources for a specific mesh\n   * @param mesh defines the source mesh\n   * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\n   */\n  releaseForMesh(mesh, shouldDispose) {\n    const meshes = this._meshes;\n    const index = meshes.indexOf(mesh);\n    if (index === -1) {\n      return;\n    }\n    meshes.splice(index, 1);\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n    mesh._geometry = null;\n    if (meshes.length === 0 && shouldDispose) {\n      this.dispose();\n    }\n  }\n  /**\n   * Apply current geometry to a given mesh\n   * @param mesh defines the mesh to apply geometry to\n   */\n  applyToMesh(mesh) {\n    if (mesh._geometry === this) {\n      return;\n    }\n    const previousGeometry = mesh._geometry;\n    if (previousGeometry) {\n      previousGeometry.releaseForMesh(mesh);\n    }\n    if (this._vertexArrayObjects) {\n      mesh._invalidateInstanceVertexArrayObject();\n    }\n    const meshes = this._meshes;\n    // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n    mesh._geometry = this;\n    mesh._internalAbstractMeshDataInfo._positions = null;\n    this._scene.pushGeometry(this);\n    meshes.push(mesh);\n    if (this.isReady()) {\n      this._applyToMesh(mesh);\n    } else if (this._boundingInfo) {\n      mesh.setBoundingInfo(this._boundingInfo);\n    }\n  }\n  _updateExtend(data = null) {\n    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\n      this._extend = {\n        minimum: this._boundingInfo.minimum.clone(),\n        maximum: this._boundingInfo.maximum.clone()\n      };\n    } else {\n      if (!data) {\n        data = this.getVerticesData(VertexBuffer.PositionKind);\n        // This can happen if the buffer comes from a Hardware Buffer where\n        // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\n        if (!data) {\n          return;\n        }\n      }\n      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\n    }\n  }\n  _applyToMesh(mesh) {\n    const numOfMeshes = this._meshes.length;\n    // vertexBuffers\n    for (const kind in this._vertexBuffers) {\n      if (numOfMeshes === 1) {\n        this._vertexBuffers[kind].create();\n      }\n      if (kind === VertexBuffer.PositionKind) {\n        if (!this._extend) {\n          this._updateExtend();\n        }\n        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\n        mesh._createGlobalSubMesh(mesh.isUnIndexed);\n        //bounding info was just created again, world matrix should be applied again.\n        mesh._updateBoundingInfo();\n      }\n    }\n    // indexBuffer\n    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\n    }\n    // morphTargets\n    mesh._syncGeometryWithMorphTargetManager();\n    // instances\n    mesh.synchronizeInstances();\n  }\n  _notifyUpdate(kind) {\n    if (this.onGeometryUpdated) {\n      this.onGeometryUpdated(this, kind);\n    }\n    if (this._vertexArrayObjects) {\n      this._disposeVertexArrayObjects();\n    }\n    for (const mesh of this._meshes) {\n      mesh._markSubMeshesAsAttributesDirty();\n    }\n  }\n  /**\n   * Load the geometry if it was flagged as delay loaded\n   * @param scene defines the hosting scene\n   * @param onLoaded defines a callback called when the geometry is loaded\n   */\n  load(scene, onLoaded) {\n    if (this.delayLoadState === 2) {\n      return;\n    }\n    if (this.isReady()) {\n      if (onLoaded) {\n        onLoaded();\n      }\n      return;\n    }\n    this.delayLoadState = 2;\n    this._queueLoad(scene, onLoaded);\n  }\n  _queueLoad(scene, onLoaded) {\n    if (!this.delayLoadingFile) {\n      return;\n    }\n    scene.addPendingData(this);\n    scene._loadFile(this.delayLoadingFile, data => {\n      if (!this._delayLoadingFunction) {\n        return;\n      }\n      this._delayLoadingFunction(JSON.parse(data), this);\n      this.delayLoadState = 1;\n      this._delayInfo = [];\n      scene.removePendingData(this);\n      const meshes = this._meshes;\n      const numOfMeshes = meshes.length;\n      for (let index = 0; index < numOfMeshes; index++) {\n        this._applyToMesh(meshes[index]);\n      }\n      if (onLoaded) {\n        onLoaded();\n      }\n    }, undefined, true);\n  }\n  /**\n   * Invert the geometry to move from a right handed system to a left handed one.\n   */\n  toLeftHanded() {\n    // Flip faces\n    const tIndices = this.getIndices(false);\n    if (tIndices != null && tIndices.length > 0) {\n      for (let i = 0; i < tIndices.length; i += 3) {\n        const tTemp = tIndices[i + 0];\n        tIndices[i + 0] = tIndices[i + 2];\n        tIndices[i + 2] = tTemp;\n      }\n      this.setIndices(tIndices);\n    }\n    // Negate position.z\n    const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\n    if (tPositions != null && tPositions.length > 0) {\n      for (let i = 0; i < tPositions.length; i += 3) {\n        tPositions[i + 2] = -tPositions[i + 2];\n      }\n      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\n    }\n    // Negate normal.z\n    const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\n    if (tNormals != null && tNormals.length > 0) {\n      for (let i = 0; i < tNormals.length; i += 3) {\n        tNormals[i + 2] = -tNormals[i + 2];\n      }\n      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\n    }\n  }\n  // Cache\n  /** @internal */\n  _resetPointsArrayCache() {\n    this._positions = null;\n  }\n  /** @internal */\n  _generatePointsArray() {\n    if (this._positions) {\n      return true;\n    }\n    const data = this.getVerticesData(VertexBuffer.PositionKind);\n    if (!data || data.length === 0) {\n      return false;\n    }\n    for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\n    }\n    for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\n      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\n    }\n    // just in case the number of positions was reduced, splice the array\n    this._positionsCache.length = data.length / 3;\n    this._positions = this._positionsCache;\n    return true;\n  }\n  /**\n   * Gets a value indicating if the geometry is disposed\n   * @returns true if the geometry was disposed\n   */\n  isDisposed() {\n    return this._isDisposed;\n  }\n  _disposeVertexArrayObjects() {\n    if (this._vertexArrayObjects) {\n      for (const kind in this._vertexArrayObjects) {\n        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n      }\n      this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n      const meshes = this._meshes;\n      const numOfMeshes = meshes.length;\n      for (let index = 0; index < numOfMeshes; index++) {\n        meshes[index]._invalidateInstanceVertexArrayObject();\n      }\n    }\n  }\n  /**\n   * Free all associated resources\n   */\n  dispose() {\n    const meshes = this._meshes;\n    const numOfMeshes = meshes.length;\n    let index;\n    for (index = 0; index < numOfMeshes; index++) {\n      this.releaseForMesh(meshes[index]);\n    }\n    this._meshes.length = 0;\n    this._disposeVertexArrayObjects();\n    for (const kind in this._vertexBuffers) {\n      this._vertexBuffers[kind].dispose();\n    }\n    this._vertexBuffers = {};\n    this._totalVertices = 0;\n    if (this._indexBuffer) {\n      this._engine._releaseBuffer(this._indexBuffer);\n    }\n    this._indexBuffer = null;\n    this._indices = [];\n    this.delayLoadState = 0;\n    this.delayLoadingFile = null;\n    this._delayLoadingFunction = null;\n    this._delayInfo = [];\n    this._boundingInfo = null;\n    this._scene.removeGeometry(this);\n    if (this._parentContainer) {\n      const index = this._parentContainer.geometries.indexOf(this);\n      if (index > -1) {\n        this._parentContainer.geometries.splice(index, 1);\n      }\n      this._parentContainer = null;\n    }\n    this._isDisposed = true;\n  }\n  /**\n   * Clone the current geometry into a new geometry\n   * @param id defines the unique ID of the new geometry\n   * @returns a new geometry object\n   */\n  copy(id) {\n    const vertexData = new VertexData();\n    vertexData.indices = [];\n    const indices = this.getIndices();\n    if (indices) {\n      for (let index = 0; index < indices.length; index++) {\n        vertexData.indices.push(indices[index]);\n      }\n    }\n    let updatable = false;\n    let stopChecking = false;\n    let kind;\n    for (kind in this._vertexBuffers) {\n      // using slice() to make a copy of the array and not just reference it\n      const data = this.getVerticesData(kind);\n      if (data) {\n        if (data instanceof Float32Array) {\n          vertexData.set(new Float32Array(data), kind);\n        } else {\n          vertexData.set(data.slice(0), kind);\n        }\n        if (!stopChecking) {\n          const vb = this.getVertexBuffer(kind);\n          if (vb) {\n            updatable = vb.isUpdatable();\n            stopChecking = !updatable;\n          }\n        }\n      }\n    }\n    const geometry = new Geometry(id, this._scene, vertexData, updatable);\n    geometry.delayLoadState = this.delayLoadState;\n    geometry.delayLoadingFile = this.delayLoadingFile;\n    geometry._delayLoadingFunction = this._delayLoadingFunction;\n    for (kind in this._delayInfo) {\n      geometry._delayInfo = geometry._delayInfo || [];\n      geometry._delayInfo.push(kind);\n    }\n    // Bounding info\n    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\n    return geometry;\n  }\n  /**\n   * Serialize the current geometry info (and not the vertices data) into a JSON object\n   * @returns a JSON representation of the current geometry data (without the vertices data)\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.id = this.id;\n    serializationObject.uniqueId = this.uniqueId;\n    serializationObject.updatable = this._updatable;\n    if (Tags && Tags.HasTags(this)) {\n      serializationObject.tags = Tags.GetTags(this);\n    }\n    return serializationObject;\n  }\n  _toNumberArray(origin) {\n    if (Array.isArray(origin)) {\n      return origin;\n    } else {\n      return Array.prototype.slice.call(origin);\n    }\n  }\n  /**\n   * Release any memory retained by the cached data on the Geometry.\n   *\n   * Call this function to reduce memory footprint of the mesh.\n   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n   */\n  clearCachedData() {\n    this._indices = [];\n    this._resetPointsArrayCache();\n    for (const vbName in this._vertexBuffers) {\n      if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\n        continue;\n      }\n      this._vertexBuffers[vbName]._buffer._data = null;\n    }\n  }\n  /**\n   * Serialize all vertices data into a JSON object\n   * @returns a JSON representation of the current geometry data\n   */\n  serializeVerticeData() {\n    const serializationObject = this.serialize();\n    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n      serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n        serializationObject.positions._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n      serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n        serializationObject.normals._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\n      serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\n        serializationObject.tangents._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n      serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\n        serializationObject.uvs._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n      serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\n        serializationObject.uv2s._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\n      serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\n        serializationObject.uv3s._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\n      serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\n        serializationObject.uv4s._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\n      serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\n        serializationObject.uv5s._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\n      serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\n        serializationObject.uv6s._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n      serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\n        serializationObject.colors._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n      serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\n      serializationObject.matricesIndices._isExpanded = true;\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\n        serializationObject.matricesIndices._updatable = true;\n      }\n    }\n    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n      serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\n      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\n        serializationObject.matricesWeights._updatable = true;\n      }\n    }\n    serializationObject.indices = this._toNumberArray(this.getIndices());\n    return serializationObject;\n  }\n  // Statics\n  /**\n   * Extracts a clone of a mesh geometry\n   * @param mesh defines the source mesh\n   * @param id defines the unique ID of the new geometry object\n   * @returns the new geometry object\n   */\n  static ExtractFromMesh(mesh, id) {\n    const geometry = mesh._geometry;\n    if (!geometry) {\n      return null;\n    }\n    return geometry.copy(id);\n  }\n  /**\n   * You should now use Tools.RandomId(), this method is still here for legacy reasons.\n   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n   * Be aware Math.random() could cause collisions, but:\n   * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n   * @returns a string containing a new GUID\n   */\n  static RandomId() {\n    return Tools.RandomId();\n  }\n  static _GetGeometryByLoadedUniqueId(uniqueId, scene) {\n    for (let index = 0; index < scene.geometries.length; index++) {\n      if (scene.geometries[index]._loadedUniqueId === uniqueId) {\n        return scene.geometries[index];\n      }\n    }\n    return null;\n  }\n  /**\n   * @internal\n   */\n  static _ImportGeometry(parsedGeometry, mesh) {\n    const scene = mesh.getScene();\n    // Geometry\n    const geometryUniqueId = parsedGeometry.geometryUniqueId;\n    const geometryId = parsedGeometry.geometryId;\n    if (geometryUniqueId || geometryId) {\n      const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\n      if (geometry) {\n        geometry.applyToMesh(mesh);\n      }\n    } else if (parsedGeometry instanceof ArrayBuffer) {\n      const binaryInfo = mesh._binaryInfo;\n      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n        const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\n      }\n      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n        const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\n      }\n      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\n        const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\n      }\n      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n        const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvsData.length; index += 2) {\n            uvsData[index] = 1 - uvsData[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\n      }\n      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n        const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs2Data.length; index += 2) {\n            uvs2Data[index] = 1 - uvs2Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\n      }\n      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n        const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs3Data.length; index += 2) {\n            uvs3Data[index] = 1 - uvs3Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\n      }\n      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n        const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs4Data.length; index += 2) {\n            uvs4Data[index] = 1 - uvs4Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\n      }\n      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n        const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs5Data.length; index += 2) {\n            uvs5Data[index] = 1 - uvs5Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\n      }\n      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n        const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n        if (CompatibilityOptions.UseOpenGLOrientationForUV) {\n          for (let index = 1; index < uvs6Data.length; index += 2) {\n            uvs6Data[index] = 1 - uvs6Data[index];\n          }\n        }\n        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\n      }\n      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n        const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n      }\n      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n        const floatIndices = [];\n        for (let i = 0; i < matricesIndicesData.length; i++) {\n          const index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\n      }\n      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\n        const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\n        const floatIndices = [];\n        for (let i = 0; i < matricesIndicesData.length; i++) {\n          const index = matricesIndicesData[i];\n          floatIndices.push(index & 0x000000ff);\n          floatIndices.push((index & 0x0000ff00) >> 8);\n          floatIndices.push((index & 0x00ff0000) >> 16);\n          floatIndices.push(index >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n        }\n\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\n      }\n      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n        const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n      }\n      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n        const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n        mesh.setIndices(indicesData, null);\n      }\n      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n        const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n        mesh.subMeshes = [];\n        for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n          const materialIndex = subMeshesData[i * 5 + 0];\n          const verticesStart = subMeshesData[i * 5 + 1];\n          const verticesCount = subMeshesData[i * 5 + 2];\n          const indexStart = subMeshesData[i * 5 + 3];\n          const indexCount = subMeshesData[i * 5 + 4];\n          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n        }\n      }\n    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n      if (parsedGeometry.tangents) {\n        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\n      }\n      if (parsedGeometry.uvs) {\n        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n      }\n      if (parsedGeometry.uvs2) {\n        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n      }\n      if (parsedGeometry.uvs3) {\n        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n      }\n      if (parsedGeometry.uvs4) {\n        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n      }\n      if (parsedGeometry.uvs5) {\n        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n      }\n      if (parsedGeometry.uvs6) {\n        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n      }\n      if (parsedGeometry.colors) {\n        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n      }\n      if (parsedGeometry.matricesIndices) {\n        if (!parsedGeometry.matricesIndices._isExpanded) {\n          const floatIndices = [];\n          for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n            const matricesIndex = parsedGeometry.matricesIndices[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n        }\n      }\n      if (parsedGeometry.matricesIndicesExtra) {\n        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n          const floatIndices = [];\n          for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n            const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n            floatIndices.push(matricesIndex & 0x000000ff);\n            floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\n            floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\n            floatIndices.push(matricesIndex >> 24 & 0xff); // & 0xFF to convert to v + 256 if v < 0\n          }\n\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n        } else {\n          delete parsedGeometry.matricesIndices._isExpanded;\n          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n        }\n      }\n      if (parsedGeometry.matricesWeights) {\n        Geometry._CleanMatricesWeights(parsedGeometry, mesh);\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n      }\n      if (parsedGeometry.matricesWeightsExtra) {\n        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n      }\n      mesh.setIndices(parsedGeometry.indices, null);\n    }\n    // SubMeshes\n    if (parsedGeometry.subMeshes) {\n      mesh.subMeshes = [];\n      for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n        const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n      }\n    }\n    // Flat shading\n    if (mesh._shouldGenerateFlatShading) {\n      mesh.convertToFlatShadedMesh();\n      mesh._shouldGenerateFlatShading = false;\n    }\n    // Update\n    mesh.computeWorldMatrix(true);\n    scene.onMeshImportedObservable.notifyObservers(mesh);\n  }\n  static _CleanMatricesWeights(parsedGeometry, mesh) {\n    const epsilon = 1e-3;\n    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\n      return;\n    }\n    let noInfluenceBoneIndex = 0.0;\n    if (parsedGeometry.skeletonId > -1) {\n      const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\n      if (!skeleton) {\n        return;\n      }\n      noInfluenceBoneIndex = skeleton.bones.length;\n    } else {\n      return;\n    }\n    const matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\n    const matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n    const matricesWeights = parsedGeometry.matricesWeights;\n    const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\n    const influencers = parsedGeometry.numBoneInfluencer;\n    const size = matricesWeights.length;\n    for (let i = 0; i < size; i += 4) {\n      let weight = 0.0;\n      let firstZeroWeight = -1;\n      for (let j = 0; j < 4; j++) {\n        const w = matricesWeights[i + j];\n        weight += w;\n        if (w < epsilon && firstZeroWeight < 0) {\n          firstZeroWeight = j;\n        }\n      }\n      if (matricesWeightsExtra) {\n        for (let j = 0; j < 4; j++) {\n          const w = matricesWeightsExtra[i + j];\n          weight += w;\n          if (w < epsilon && firstZeroWeight < 0) {\n            firstZeroWeight = j + 4;\n          }\n        }\n      }\n      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\n        firstZeroWeight = influencers - 1;\n      }\n      if (weight > epsilon) {\n        const mweight = 1.0 / weight;\n        for (let j = 0; j < 4; j++) {\n          matricesWeights[i + j] *= mweight;\n        }\n        if (matricesWeightsExtra) {\n          for (let j = 0; j < 4; j++) {\n            matricesWeightsExtra[i + j] *= mweight;\n          }\n        }\n      } else {\n        if (firstZeroWeight >= 4) {\n          matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\n          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\n        } else {\n          matricesWeights[i + firstZeroWeight] = 1.0 - weight;\n          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\n        }\n      }\n    }\n    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\n    if (parsedGeometry.matricesWeightsExtra) {\n      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\n    }\n  }\n  /**\n   * Create a new geometry from persisted data (Using .babylon file format)\n   * @param parsedVertexData defines the persisted data\n   * @param scene defines the hosting scene\n   * @param rootUrl defines the root url to use to load assets (like delayed data)\n   * @returns the new geometry object\n   */\n  static Parse(parsedVertexData, scene, rootUrl) {\n    const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\n    geometry._loadedUniqueId = parsedVertexData.uniqueId;\n    if (Tags) {\n      Tags.AddTagsTo(geometry, parsedVertexData.tags);\n    }\n    if (parsedVertexData.delayLoadingFile) {\n      geometry.delayLoadState = 4;\n      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n      geometry._delayInfo = [];\n      if (parsedVertexData.hasUVs) {\n        geometry._delayInfo.push(VertexBuffer.UVKind);\n      }\n      if (parsedVertexData.hasUVs2) {\n        geometry._delayInfo.push(VertexBuffer.UV2Kind);\n      }\n      if (parsedVertexData.hasUVs3) {\n        geometry._delayInfo.push(VertexBuffer.UV3Kind);\n      }\n      if (parsedVertexData.hasUVs4) {\n        geometry._delayInfo.push(VertexBuffer.UV4Kind);\n      }\n      if (parsedVertexData.hasUVs5) {\n        geometry._delayInfo.push(VertexBuffer.UV5Kind);\n      }\n      if (parsedVertexData.hasUVs6) {\n        geometry._delayInfo.push(VertexBuffer.UV6Kind);\n      }\n      if (parsedVertexData.hasColors) {\n        geometry._delayInfo.push(VertexBuffer.ColorKind);\n      }\n      if (parsedVertexData.hasMatricesIndices) {\n        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n      }\n      if (parsedVertexData.hasMatricesWeights) {\n        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n      }\n      geometry._delayLoadingFunction = VertexData.ImportVertexData;\n    } else {\n      VertexData.ImportVertexData(parsedVertexData, geometry);\n    }\n    scene.pushGeometry(geometry, true);\n    return geometry;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","Color4","VertexData","VertexBuffer","SubMesh","SceneLoaderFlags","BoundingInfo","Tools","Tags","extractMinAndMax","EngineStore","CompatibilityOptions","Geometry","constructor","id","scene","vertexData","updatable","mesh","_scene","LastCreatedScene","uniqueId","getUniqueId","_engine","getEngine","_meshes","_vertexBuffers","_indices","_updatable","setAllVerticesData","_totalVertices","getCaps","vertexArrayObject","_vertexArrayObjects","applyToMesh","computeWorldMatrix","boundingBias","_boundingBias","value","copyFrom","clone","_updateBoundingInfo","CreateGeometryForMesh","geometry","RandomId","getScene","meshes","extend","_extend","isReady","delayLoadState","doNotSerialize","index","length","_rebuild","_indexBuffer","createIndexBuffer","key","vertexBuffer","applyToGeometry","_notifyUpdate","setVerticesData","kind","data","stride","Array","isArray","Float32Array","buffer","setVerticesBuffer","removeVerticesData","dispose","_disposeVertexArrayObjects","totalVertices","disposeExistingBuffer","getKind","_buffer","_increaseReferences","numOfMeshes","PositionKind","getData","type","BYTE","byteStride","_updateExtend","_resetPointsArrayCache","buildBoundingInfo","minimum","maximum","_createGlobalSubMesh","isUnIndexed","synchronizeInstances","updateVerticesDataDirectly","offset","useBytes","getVertexBuffer","updateDirectly","updateVerticesData","updateExtends","update","hasBoundingInfo","getBoundingInfo","reConstruct","subMeshes","subMesh","refreshBoundingInfo","_bind","effect","indexToBind","overrideVertexBuffers","overrideVertexArrayObjects","undefined","vbs","getVertexBuffers","bindBuffers","vaos","recordVertexArrayObject","bindVertexArrayObject","getTotalVertices","getVerticesData","copyWhenShared","forceCopy","getFloatData","isVertexBufferUpdatable","vb","isUpdatable","isVerticesDataPresent","_delayInfo","indexOf","getVerticesDataKinds","result","push","updateIndices","indices","gpuMemoryOnly","_indexBufferIsUpdatable","setIndices","needToUpdateSubMeshes","slice","updateDynamicIndexBuffer","_releaseBuffer","getTotalIndices","getIndices","orig","getIndexBuffer","_releaseVertexArrayObject","releaseVertexArrayObject","releaseForMesh","shouldDispose","splice","_invalidateInstanceVertexArrayObject","_geometry","previousGeometry","_internalAbstractMeshDataInfo","_positions","pushGeometry","_applyToMesh","_boundingInfo","setBoundingInfo","useBoundingInfoFromGeometry","create","_syncGeometryWithMorphTargetManager","onGeometryUpdated","_markSubMeshesAsAttributesDirty","load","onLoaded","_queueLoad","delayLoadingFile","addPendingData","_loadFile","_delayLoadingFunction","JSON","parse","removePendingData","toLeftHanded","tIndices","i","tTemp","tPositions","tNormals","NormalKind","_generatePointsArray","_positionsCache","arrayIdx","FromArray","set","isDisposed","_isDisposed","removeGeometry","_parentContainer","geometries","copy","stopChecking","serialize","serializationObject","HasTags","tags","GetTags","_toNumberArray","origin","prototype","call","clearCachedData","vbName","Object","hasOwnProperty","_data","serializeVerticeData","positions","normals","TangentKind","tangents","UVKind","uvs","UV2Kind","uv2s","UV3Kind","uv3s","UV4Kind","uv4s","UV5Kind","uv5s","UV6Kind","uv6s","ColorKind","colors","MatricesIndicesKind","matricesIndices","_isExpanded","MatricesWeightsKind","matricesWeights","ExtractFromMesh","_GetGeometryByLoadedUniqueId","_loadedUniqueId","_ImportGeometry","parsedGeometry","geometryUniqueId","geometryId","getGeometryById","ArrayBuffer","binaryInfo","_binaryInfo","positionsAttrDesc","count","positionsData","normalsAttrDesc","normalsData","tangetsAttrDesc","tangentsData","uvsAttrDesc","uvsData","UseOpenGLOrientationForUV","uvs2AttrDesc","uvs2Data","uvs3AttrDesc","uvs3Data","uvs4AttrDesc","uvs4Data","uvs5AttrDesc","uvs5Data","uvs6AttrDesc","uvs6Data","colorsAttrDesc","colorsData","matricesIndicesAttrDesc","matricesIndicesData","Int32Array","floatIndices","matricesIndicesExtraAttrDesc","MatricesIndicesExtraKind","matricesWeightsAttrDesc","matricesWeightsData","indicesAttrDesc","indicesData","subMeshesAttrDesc","subMeshesData","materialIndex","verticesStart","verticesCount","indexStart","indexCount","AddToMesh","uvs2","uvs3","uvs4","uvs5","uvs6","CheckColors4","matricesIndex","matricesIndicesExtra","_CleanMatricesWeights","matricesWeightsExtra","MatricesWeightsExtraKind","subIndex","parsedSubMesh","_shouldGenerateFlatShading","convertToFlatShadedMesh","onMeshImportedObservable","notifyObservers","epsilon","CleanBoneMatrixWeights","noInfluenceBoneIndex","skeletonId","skeleton","getLastSkeletonById","bones","influencers","numBoneInfluencer","size","weight","firstZeroWeight","j","w","mweight","Parse","parsedVertexData","rootUrl","AddTagsTo","boundingBoxMinimum","boundingBoxMaximum","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","ImportVertexData"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/geometry.ts"],"sourcesContent":["import type { Nullable, FloatArray, DataArray, IndicesArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Vector2 } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color4 } from \"../Maths/math.color\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { IGetSetVerticesData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags\";\r\nimport { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { extractMinAndMax } from \"../Maths/math.functions\";\r\nimport type { AbstractScene } from \"../abstractScene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { CompatibilityOptions } from \"../Compat/compatibilityOptions\";\r\n\r\ndeclare type Mesh = import(\"../Meshes/mesh\").Mesh;\r\n\r\n/**\r\n * Class used to store geometry data (vertex buffers + index buffer)\r\n */\r\nexport class Geometry implements IGetSetVerticesData {\r\n    // Members\r\n    /**\r\n     * Gets or sets the ID of the geometry\r\n     */\r\n    public id: string;\r\n    /**\r\n     * Gets or sets the unique ID of the geometry\r\n     */\r\n    public uniqueId: number;\r\n    /**\r\n     * Gets the delay loading state of the geometry (none by default which means not delayed)\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n    /**\r\n     * Gets the file containing the data to load when running in delay load state\r\n     */\r\n    public delayLoadingFile: Nullable<string>;\r\n    /**\r\n     * Callback called when the geometry is updated\r\n     */\r\n    public onGeometryUpdated: (geometry: Geometry, kind?: string) => void;\r\n\r\n    // Private\r\n    private _scene: Scene;\r\n    private _engine: Engine;\r\n    private _meshes: Mesh[];\r\n    private _totalVertices = 0;\r\n    /** @internal */\r\n    public _loadedUniqueId: string;\r\n    /** @internal */\r\n    public _indices: IndicesArray;\r\n    /** @internal */\r\n    public _vertexBuffers: { [key: string]: VertexBuffer };\r\n    private _isDisposed = false;\r\n    private _extend: { minimum: Vector3; maximum: Vector3 };\r\n    private _boundingBias: Vector2;\r\n    /** @internal */\r\n    public _delayInfo: Array<string>;\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _indexBufferIsUpdatable = false;\r\n    /** @internal */\r\n    public _boundingInfo: Nullable<BoundingInfo>;\r\n    /** @internal */\r\n    public _delayLoadingFunction: Nullable<(any: any, geometry: Geometry) => void>;\r\n    /** @internal */\r\n    public _softwareSkinningFrameId: number;\r\n    private _vertexArrayObjects: { [key: string]: WebGLVertexArrayObject };\r\n    private _updatable: boolean;\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _positions: Nullable<Vector3[]>;\r\n    private _positionsCache: Vector3[] = [];\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public get boundingBias(): Vector2 {\r\n        return this._boundingBias;\r\n    }\r\n\r\n    /**\r\n     *  Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\r\n     */\r\n    public set boundingBias(value: Vector2) {\r\n        if (this._boundingBias) {\r\n            this._boundingBias.copyFrom(value);\r\n        } else {\r\n            this._boundingBias = value.clone();\r\n        }\r\n\r\n        this._updateBoundingInfo(true, null);\r\n    }\r\n\r\n    /**\r\n     * Static function used to attach a new empty geometry to a mesh\r\n     * @param mesh defines the mesh to attach the geometry to\r\n     * @returns the new Geometry\r\n     */\r\n    public static CreateGeometryForMesh(mesh: Mesh): Geometry {\r\n        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());\r\n\r\n        geometry.applyToMesh(mesh);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /** Get the list of meshes using this geometry */\r\n    public get meshes(): Mesh[] {\r\n        return this._meshes;\r\n    }\r\n\r\n    /**\r\n     * If set to true (false by default), the bounding info applied to the meshes sharing this geometry will be the bounding info defined at the class level\r\n     * and won't be computed based on the vertex positions (which is what we get when useBoundingInfoFromGeometry = false)\r\n     */\r\n    public useBoundingInfoFromGeometry = false;\r\n\r\n    /**\r\n     * Creates a new geometry\r\n     * @param id defines the unique ID\r\n     * @param scene defines the hosting scene\r\n     * @param vertexData defines the VertexData used to get geometry data\r\n     * @param updatable defines if geometry must be updatable (false by default)\r\n     * @param mesh defines the mesh that will be associated with the geometry\r\n     */\r\n    constructor(id: string, scene?: Scene, vertexData?: VertexData, updatable: boolean = false, mesh: Nullable<Mesh> = null) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n        this.id = id;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n        this._engine = this._scene.getEngine();\r\n        this._meshes = [];\r\n        //Init vertex buffer cache\r\n        this._vertexBuffers = {};\r\n        this._indices = [];\r\n        this._updatable = updatable;\r\n\r\n        // vertexData\r\n        if (vertexData) {\r\n            this.setAllVerticesData(vertexData, updatable);\r\n        } else {\r\n            this._totalVertices = 0;\r\n        }\r\n\r\n        if (this._engine.getCaps().vertexArrayObject) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // applyToMesh\r\n        if (mesh) {\r\n            this.applyToMesh(mesh);\r\n            mesh.computeWorldMatrix(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current extend of the geometry\r\n     */\r\n    public get extend(): { minimum: Vector3; maximum: Vector3 } {\r\n        return this._extend;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns the hosting Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting engine\r\n     * @returns the hosting Engine\r\n     */\r\n    public getEngine(): Engine {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Defines if the geometry is ready to use\r\n     * @returns true if the geometry is ready to be used\r\n     */\r\n    public isReady(): boolean {\r\n        return this.delayLoadState === Constants.DELAYLOADSTATE_LOADED || this.delayLoadState === Constants.DELAYLOADSTATE_NONE;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the geometry should not be serialized\r\n     */\r\n    public get doNotSerialize(): boolean {\r\n        for (let index = 0; index < this._meshes.length; index++) {\r\n            if (!this._meshes[index].doNotSerialize) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(): void {\r\n        if (this._vertexArrayObjects) {\r\n            this._vertexArrayObjects = {};\r\n        }\r\n\r\n        // Index buffer\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // Vertex buffers\r\n        for (const key in this._vertexBuffers) {\r\n            const vertexBuffer = <VertexBuffer>this._vertexBuffers[key];\r\n            vertexBuffer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affects all geometry data in one call\r\n     * @param vertexData defines the geometry data\r\n     * @param updatable defines if the geometry must be flagged as updatable (false as default)\r\n     */\r\n    public setAllVerticesData(vertexData: VertexData, updatable?: boolean): void {\r\n        vertexData.applyToGeometry(this, updatable);\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Set specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the vertex data to use\r\n     * @param updatable defines if the vertex must be flagged as updatable (false as default)\r\n     * @param stride defines the stride to use (0 by default). This value is deduced from the kind value if not specified\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable: boolean = false, stride?: number): void {\r\n        if (updatable && Array.isArray(data)) {\r\n            // to avoid converting to Float32Array at each draw call in engine.updateDynamicVertexBuffer, we make the conversion a single time here\r\n            data = new Float32Array(data);\r\n        }\r\n        const buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\r\n        this.setVerticesBuffer(buffer);\r\n    }\r\n\r\n    /**\r\n     * Removes a specific vertex data\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     */\r\n    public removeVerticesData(kind: string) {\r\n        if (this._vertexBuffers[kind]) {\r\n            this._vertexBuffers[kind].dispose();\r\n            delete this._vertexBuffers[kind];\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data\r\n     * @param buffer defines the vertex buffer to use\r\n     * @param totalVertices defines the total number of vertices for position kind (could be null)\r\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\r\n     */\r\n    public setVerticesBuffer(buffer: VertexBuffer, totalVertices: Nullable<number> = null, disposeExistingBuffer = true): void {\r\n        const kind = buffer.getKind();\r\n        if (this._vertexBuffers[kind] && disposeExistingBuffer) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n\r\n        if (buffer._buffer) {\r\n            buffer._buffer._increaseReferences();\r\n        }\r\n\r\n        this._vertexBuffers[kind] = buffer;\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            const data = <FloatArray>buffer.getData();\r\n            if (totalVertices != null) {\r\n                this._totalVertices = totalVertices;\r\n            } else {\r\n                if (data != null) {\r\n                    this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);\r\n                }\r\n            }\r\n\r\n            this._updateExtend(data);\r\n            this._resetPointsArrayCache();\r\n\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                const mesh = meshes[index];\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\r\n                mesh.computeWorldMatrix(true);\r\n                mesh.synchronizeInstances();\r\n            }\r\n        }\r\n\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will directly update the underlying DataBuffer according to the passed numeric array or Float32Array\r\n     * It will do nothing if the buffer is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param useBytes set to true if the offset is in bytes\r\n     */\r\n    public updateVerticesDataDirectly(kind: string, data: DataArray, offset: number, useBytes: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.updateDirectly(data, offset, useBytes);\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    /**\r\n     * Update a specific vertex buffer\r\n     * This function will create a new buffer if the current one is not updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param data defines the data to use\r\n     * @param updateExtends defines if the geometry extends must be recomputed (false by default)\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends: boolean = false): void {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n\r\n        if (!vertexBuffer) {\r\n            return;\r\n        }\r\n\r\n        vertexBuffer.update(data);\r\n\r\n        if (kind === VertexBuffer.PositionKind) {\r\n            this._updateBoundingInfo(updateExtends, data);\r\n        }\r\n        this._notifyUpdate(kind);\r\n    }\r\n\r\n    private _updateBoundingInfo(updateExtends: boolean, data: Nullable<FloatArray>) {\r\n        if (updateExtends) {\r\n            this._updateExtend(data);\r\n        }\r\n\r\n        this._resetPointsArrayCache();\r\n\r\n        if (updateExtends) {\r\n            const meshes = this._meshes;\r\n            for (const mesh of meshes) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);\r\n                } else {\r\n                    mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n                }\r\n\r\n                const subMeshes = mesh.subMeshes;\r\n                for (const subMesh of subMeshes) {\r\n                    subMesh.refreshBoundingInfo();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(\r\n        effect: Nullable<Effect>,\r\n        indexToBind?: Nullable<DataBuffer>,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> },\r\n        overrideVertexArrayObjects?: { [key: string]: WebGLVertexArrayObject }\r\n    ): void {\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind === undefined) {\r\n            indexToBind = this._indexBuffer;\r\n        }\r\n        const vbs = this.getVertexBuffers();\r\n\r\n        if (!vbs) {\r\n            return;\r\n        }\r\n\r\n        if (indexToBind != this._indexBuffer || (!this._vertexArrayObjects && !overrideVertexArrayObjects)) {\r\n            this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);\r\n            return;\r\n        }\r\n\r\n        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;\r\n\r\n        // Using VAO\r\n        if (!vaos[effect.key]) {\r\n            vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);\r\n        }\r\n\r\n        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);\r\n    }\r\n\r\n    /**\r\n     * Gets total number of vertices\r\n     * @returns the total number of vertices\r\n     */\r\n    public getTotalVertices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n\r\n        return this._totalVertices;\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns a float array containing vertex data\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        const vertexBuffer = this.getVertexBuffer(kind);\r\n        if (!vertexBuffer) {\r\n            return null;\r\n        }\r\n\r\n        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || (copyWhenShared && this._meshes.length !== 1));\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if the vertex buffer with the specified kind is updatable\r\n     */\r\n    public isVertexBufferUpdatable(kind: string): boolean {\r\n        const vb = this._vertexBuffers[kind];\r\n\r\n        if (!vb) {\r\n            return false;\r\n        }\r\n\r\n        return vb.isUpdatable();\r\n    }\r\n\r\n    /**\r\n     * Gets a specific vertex buffer\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns a VertexBuffer\r\n     */\r\n    public getVertexBuffer(kind: string): Nullable<VertexBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers[kind];\r\n    }\r\n\r\n    /**\r\n     * Returns all vertex buffers\r\n     * @returns an object holding all vertex buffers indexed by kind\r\n     */\r\n    public getVertexBuffers(): Nullable<{ [key: string]: VertexBuffer }> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._vertexBuffers;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if specific vertex buffer is present\r\n     * @param kind defines the data kind (Position, normal, etc...)\r\n     * @returns true if data is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        if (!this._vertexBuffers) {\r\n            if (this._delayInfo) {\r\n                return this._delayInfo.indexOf(kind) !== -1;\r\n            }\r\n            return false;\r\n        }\r\n        return this._vertexBuffers[kind] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Gets a list of all attached data kinds (Position, normal, etc...)\r\n     * @returns a list of string containing all kinds\r\n     */\r\n    public getVerticesDataKinds(): string[] {\r\n        const result = [];\r\n        let kind;\r\n        if (!this._vertexBuffers && this._delayInfo) {\r\n            for (kind in this._delayInfo) {\r\n                result.push(kind);\r\n            }\r\n        } else {\r\n            for (kind in this._vertexBuffers) {\r\n                result.push(kind);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Update index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param offset defines the offset in the target buffer where to store the data\r\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\r\n     */\r\n    public updateIndices(indices: IndicesArray, offset?: number, gpuMemoryOnly = false): void {\r\n        if (!this._indexBuffer) {\r\n            return;\r\n        }\r\n\r\n        if (!this._indexBufferIsUpdatable) {\r\n            this.setIndices(indices, null, true);\r\n        } else {\r\n            const needToUpdateSubMeshes = indices.length !== this._indices.length;\r\n\r\n            if (!gpuMemoryOnly) {\r\n                this._indices = indices.slice();\r\n            }\r\n            this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);\r\n            if (needToUpdateSubMeshes) {\r\n                for (const mesh of this._meshes) {\r\n                    mesh._createGlobalSubMesh(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new index buffer\r\n     * @param indices defines the indices to store in the index buffer\r\n     * @param totalVertices defines the total number of vertices (could be null)\r\n     * @param updatable defines if the index buffer must be flagged as updatable (false by default)\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null, updatable: boolean = false): void {\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n\r\n        this._indices = indices;\r\n        this._indexBufferIsUpdatable = updatable;\r\n        if (this._meshes.length !== 0 && this._indices) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);\r\n        }\r\n\r\n        if (totalVertices != undefined) {\r\n            // including null and undefined\r\n            this._totalVertices = totalVertices;\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._createGlobalSubMesh(true);\r\n            mesh.synchronizeInstances();\r\n        }\r\n\r\n        this._notifyUpdate();\r\n    }\r\n\r\n    /**\r\n     * Return the total number of indices\r\n     * @returns the total number of indices\r\n     */\r\n    public getTotalIndices(): number {\r\n        if (!this.isReady()) {\r\n            return 0;\r\n        }\r\n        return this._indices.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer array\r\n     * @param copyWhenShared defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes\r\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\r\n     * @returns the index buffer array\r\n     */\r\n    public getIndices(copyWhenShared?: boolean, forceCopy?: boolean): Nullable<IndicesArray> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        const orig = this._indices;\r\n        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\r\n            return orig;\r\n        } else {\r\n            return orig.slice();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the index buffer\r\n     * @returns the index buffer\r\n     */\r\n    public getIndexBuffer(): Nullable<DataBuffer> {\r\n        if (!this.isReady()) {\r\n            return null;\r\n        }\r\n        return this._indexBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseVertexArrayObject(effect: Nullable<Effect> = null) {\r\n        if (!effect || !this._vertexArrayObjects) {\r\n            return;\r\n        }\r\n\r\n        if (this._vertexArrayObjects[effect.key]) {\r\n            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\r\n            delete this._vertexArrayObjects[effect.key];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the associated resources for a specific mesh\r\n     * @param mesh defines the source mesh\r\n     * @param shouldDispose defines if the geometry must be disposed if there is no more mesh pointing to it\r\n     */\r\n    public releaseForMesh(mesh: Mesh, shouldDispose?: boolean): void {\r\n        const meshes = this._meshes;\r\n        const index = meshes.indexOf(mesh);\r\n\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n\r\n        meshes.splice(index, 1);\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        mesh._geometry = null;\r\n\r\n        if (meshes.length === 0 && shouldDispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply current geometry to a given mesh\r\n     * @param mesh defines the mesh to apply geometry to\r\n     */\r\n    public applyToMesh(mesh: Mesh): void {\r\n        if (mesh._geometry === this) {\r\n            return;\r\n        }\r\n\r\n        const previousGeometry = mesh._geometry;\r\n        if (previousGeometry) {\r\n            previousGeometry.releaseForMesh(mesh);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            mesh._invalidateInstanceVertexArrayObject();\r\n        }\r\n\r\n        const meshes = this._meshes;\r\n\r\n        // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\r\n        mesh._geometry = this;\r\n        mesh._internalAbstractMeshDataInfo._positions = null;\r\n\r\n        this._scene.pushGeometry(this);\r\n\r\n        meshes.push(mesh);\r\n\r\n        if (this.isReady()) {\r\n            this._applyToMesh(mesh);\r\n        } else if (this._boundingInfo) {\r\n            mesh.setBoundingInfo(this._boundingInfo);\r\n        }\r\n    }\r\n\r\n    private _updateExtend(data: Nullable<FloatArray> = null) {\r\n        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {\r\n            this._extend = {\r\n                minimum: this._boundingInfo.minimum.clone(),\r\n                maximum: this._boundingInfo.maximum.clone(),\r\n            };\r\n        } else {\r\n            if (!data) {\r\n                data = this.getVerticesData(VertexBuffer.PositionKind)!;\r\n                // This can happen if the buffer comes from a Hardware Buffer where\r\n                // The data have not been uploaded by Babylon. (ex: Compute Shaders and Storage Buffers)\r\n                if (!data) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);\r\n        }\r\n    }\r\n\r\n    private _applyToMesh(mesh: Mesh): void {\r\n        const numOfMeshes = this._meshes.length;\r\n\r\n        // vertexBuffers\r\n        for (const kind in this._vertexBuffers) {\r\n            if (numOfMeshes === 1) {\r\n                this._vertexBuffers[kind].create();\r\n            }\r\n\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                if (!this._extend) {\r\n                    this._updateExtend();\r\n                }\r\n                mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n                mesh._createGlobalSubMesh(mesh.isUnIndexed);\r\n\r\n                //bounding info was just created again, world matrix should be applied again.\r\n                mesh._updateBoundingInfo();\r\n            }\r\n        }\r\n\r\n        // indexBuffer\r\n        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\r\n            this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);\r\n        }\r\n\r\n        // morphTargets\r\n        mesh._syncGeometryWithMorphTargetManager();\r\n\r\n        // instances\r\n        mesh.synchronizeInstances();\r\n    }\r\n\r\n    private _notifyUpdate(kind?: string) {\r\n        if (this.onGeometryUpdated) {\r\n            this.onGeometryUpdated(this, kind);\r\n        }\r\n\r\n        if (this._vertexArrayObjects) {\r\n            this._disposeVertexArrayObjects();\r\n        }\r\n\r\n        for (const mesh of this._meshes) {\r\n            mesh._markSubMeshesAsAttributesDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the geometry if it was flagged as delay loaded\r\n     * @param scene defines the hosting scene\r\n     * @param onLoaded defines a callback called when the geometry is loaded\r\n     */\r\n    public load(scene: Scene, onLoaded?: () => void): void {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_LOADING) {\r\n            return;\r\n        }\r\n\r\n        if (this.isReady()) {\r\n            if (onLoaded) {\r\n                onLoaded();\r\n            }\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADING;\r\n\r\n        this._queueLoad(scene, onLoaded);\r\n    }\r\n\r\n    private _queueLoad(scene: Scene, onLoaded?: () => void): void {\r\n        if (!this.delayLoadingFile) {\r\n            return;\r\n        }\r\n\r\n        scene.addPendingData(this);\r\n        scene._loadFile(\r\n            this.delayLoadingFile,\r\n            (data) => {\r\n                if (!this._delayLoadingFunction) {\r\n                    return;\r\n                }\r\n\r\n                this._delayLoadingFunction(JSON.parse(data as string), this);\r\n\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n                this._delayInfo = [];\r\n\r\n                scene.removePendingData(this);\r\n\r\n                const meshes = this._meshes;\r\n                const numOfMeshes = meshes.length;\r\n                for (let index = 0; index < numOfMeshes; index++) {\r\n                    this._applyToMesh(meshes[index]);\r\n                }\r\n\r\n                if (onLoaded) {\r\n                    onLoaded();\r\n                }\r\n            },\r\n            undefined,\r\n            true\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Invert the geometry to move from a right handed system to a left handed one.\r\n     */\r\n    public toLeftHanded(): void {\r\n        // Flip faces\r\n        const tIndices = this.getIndices(false);\r\n        if (tIndices != null && tIndices.length > 0) {\r\n            for (let i = 0; i < tIndices.length; i += 3) {\r\n                const tTemp = tIndices[i + 0];\r\n                tIndices[i + 0] = tIndices[i + 2];\r\n                tIndices[i + 2] = tTemp;\r\n            }\r\n            this.setIndices(tIndices);\r\n        }\r\n\r\n        // Negate position.z\r\n        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);\r\n        if (tPositions != null && tPositions.length > 0) {\r\n            for (let i = 0; i < tPositions.length; i += 3) {\r\n                tPositions[i + 2] = -tPositions[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);\r\n        }\r\n\r\n        // Negate normal.z\r\n        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);\r\n        if (tNormals != null && tNormals.length > 0) {\r\n            for (let i = 0; i < tNormals.length; i += 3) {\r\n                tNormals[i + 2] = -tNormals[i + 2];\r\n            }\r\n            this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);\r\n        }\r\n    }\r\n\r\n    // Cache\r\n    /** @internal */\r\n    public _resetPointsArrayCache(): void {\r\n        this._positions = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        if (this._positions) {\r\n            return true;\r\n        }\r\n\r\n        const data = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!data || data.length === 0) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);\r\n        }\r\n\r\n        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {\r\n            this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);\r\n        }\r\n\r\n        // just in case the number of positions was reduced, splice the array\r\n        this._positionsCache.length = data.length / 3;\r\n\r\n        this._positions = this._positionsCache;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating if the geometry is disposed\r\n     * @returns true if the geometry was disposed\r\n     */\r\n    public isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    private _disposeVertexArrayObjects(): void {\r\n        if (this._vertexArrayObjects) {\r\n            for (const kind in this._vertexArrayObjects) {\r\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\r\n            }\r\n            this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\r\n\r\n            const meshes = this._meshes;\r\n            const numOfMeshes = meshes.length;\r\n            for (let index = 0; index < numOfMeshes; index++) {\r\n                meshes[index]._invalidateInstanceVertexArrayObject();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Free all associated resources\r\n     */\r\n    public dispose(): void {\r\n        const meshes = this._meshes;\r\n        const numOfMeshes = meshes.length;\r\n        let index: number;\r\n        for (index = 0; index < numOfMeshes; index++) {\r\n            this.releaseForMesh(meshes[index]);\r\n        }\r\n        this._meshes.length = 0;\r\n\r\n        this._disposeVertexArrayObjects();\r\n\r\n        for (const kind in this._vertexBuffers) {\r\n            this._vertexBuffers[kind].dispose();\r\n        }\r\n        this._vertexBuffers = {};\r\n        this._totalVertices = 0;\r\n\r\n        if (this._indexBuffer) {\r\n            this._engine._releaseBuffer(this._indexBuffer);\r\n        }\r\n        this._indexBuffer = null;\r\n        this._indices = [];\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n        this.delayLoadingFile = null;\r\n        this._delayLoadingFunction = null;\r\n        this._delayInfo = [];\r\n\r\n        this._boundingInfo = null;\r\n\r\n        this._scene.removeGeometry(this);\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.geometries.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.geometries.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this._isDisposed = true;\r\n    }\r\n\r\n    /**\r\n     * Clone the current geometry into a new geometry\r\n     * @param id defines the unique ID of the new geometry\r\n     * @returns a new geometry object\r\n     */\r\n    public copy(id: string): Geometry {\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.indices = [];\r\n\r\n        const indices = this.getIndices();\r\n        if (indices) {\r\n            for (let index = 0; index < indices.length; index++) {\r\n                (<number[]>vertexData.indices).push(indices[index]);\r\n            }\r\n        }\r\n\r\n        let updatable = false;\r\n        let stopChecking = false;\r\n        let kind;\r\n        for (kind in this._vertexBuffers) {\r\n            // using slice() to make a copy of the array and not just reference it\r\n            const data = this.getVerticesData(kind);\r\n\r\n            if (data) {\r\n                if (data instanceof Float32Array) {\r\n                    vertexData.set(new Float32Array(<Float32Array>data), kind);\r\n                } else {\r\n                    vertexData.set((<number[]>data).slice(0), kind);\r\n                }\r\n                if (!stopChecking) {\r\n                    const vb = this.getVertexBuffer(kind);\r\n\r\n                    if (vb) {\r\n                        updatable = vb.isUpdatable();\r\n                        stopChecking = !updatable;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const geometry = new Geometry(id, this._scene, vertexData, updatable);\r\n\r\n        geometry.delayLoadState = this.delayLoadState;\r\n        geometry.delayLoadingFile = this.delayLoadingFile;\r\n        geometry._delayLoadingFunction = this._delayLoadingFunction;\r\n\r\n        for (kind in this._delayInfo) {\r\n            geometry._delayInfo = geometry._delayInfo || [];\r\n            geometry._delayInfo.push(kind);\r\n        }\r\n\r\n        // Bounding info\r\n        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);\r\n\r\n        return geometry;\r\n    }\r\n\r\n    /**\r\n     * Serialize the current geometry info (and not the vertices data) into a JSON object\r\n     * @returns a JSON representation of the current geometry data (without the vertices data)\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.id;\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.updatable = this._updatable;\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _toNumberArray(origin: Nullable<Float32Array | IndicesArray>): number[] {\r\n        if (Array.isArray(origin)) {\r\n            return origin;\r\n        } else {\r\n            return Array.prototype.slice.call(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release any memory retained by the cached data on the Geometry.\r\n     *\r\n     * Call this function to reduce memory footprint of the mesh.\r\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\r\n     */\r\n    public clearCachedData(): void {\r\n        this._indices = [];\r\n        this._resetPointsArrayCache();\r\n\r\n        for (const vbName in this._vertexBuffers) {\r\n            if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {\r\n                continue;\r\n            }\r\n            this._vertexBuffers[vbName]._buffer._data = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize all vertices data into a JSON object\r\n     * @returns a JSON representation of the current geometry data\r\n     */\r\n    public serializeVerticeData(): any {\r\n        const serializationObject = this.serialize();\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\r\n            serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\r\n                serializationObject.positions._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\r\n                serializationObject.normals._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {\r\n                serializationObject.tangents._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {\r\n                serializationObject.uvs._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {\r\n                serializationObject.uv2s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {\r\n            serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {\r\n                serializationObject.uv3s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {\r\n            serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {\r\n                serializationObject.uv4s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {\r\n            serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {\r\n                serializationObject.uv5s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {\r\n            serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {\r\n                serializationObject.uv6s._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {\r\n                serializationObject.colors._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\r\n            serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));\r\n            serializationObject.matricesIndices._isExpanded = true;\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {\r\n                serializationObject.matricesIndices._updatable = true;\r\n            }\r\n        }\r\n\r\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\r\n            serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));\r\n            if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {\r\n                serializationObject.matricesWeights._updatable = true;\r\n            }\r\n        }\r\n\r\n        serializationObject.indices = this._toNumberArray(this.getIndices());\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Extracts a clone of a mesh geometry\r\n     * @param mesh defines the source mesh\r\n     * @param id defines the unique ID of the new geometry object\r\n     * @returns the new geometry object\r\n     */\r\n    public static ExtractFromMesh(mesh: Mesh, id: string): Nullable<Geometry> {\r\n        const geometry = mesh._geometry;\r\n\r\n        if (!geometry) {\r\n            return null;\r\n        }\r\n\r\n        return geometry.copy(id);\r\n    }\r\n\r\n    /**\r\n     * You should now use Tools.RandomId(), this method is still here for legacy reasons.\r\n     * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\r\n     * Be aware Math.random() could cause collisions, but:\r\n     * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\r\n     * @returns a string containing a new GUID\r\n     */\r\n    public static RandomId(): string {\r\n        return Tools.RandomId();\r\n    }\r\n\r\n    private static _GetGeometryByLoadedUniqueId(uniqueId: string, scene: Scene) {\r\n        for (let index = 0; index < scene.geometries.length; index++) {\r\n            if (scene.geometries[index]._loadedUniqueId === uniqueId) {\r\n                return scene.geometries[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _ImportGeometry(parsedGeometry: any, mesh: Mesh): void {\r\n        const scene = mesh.getScene();\r\n\r\n        // Geometry\r\n        const geometryUniqueId = parsedGeometry.geometryUniqueId;\r\n        const geometryId = parsedGeometry.geometryId;\r\n        if (geometryUniqueId || geometryId) {\r\n            const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);\r\n            if (geometry) {\r\n                geometry.applyToMesh(mesh);\r\n            }\r\n        } else if (parsedGeometry instanceof ArrayBuffer) {\r\n            const binaryInfo = mesh._binaryInfo;\r\n\r\n            if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\r\n                const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);\r\n            }\r\n\r\n            if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\r\n                const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);\r\n            }\r\n\r\n            if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {\r\n                const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\r\n                const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvsData.length; index += 2) {\r\n                        uvsData[index] = 1 - uvsData[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\r\n                const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs2Data.length; index += 2) {\r\n                        uvs2Data[index] = 1 - uvs2Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\r\n                const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs3Data.length; index += 2) {\r\n                        uvs3Data[index] = 1 - uvs3Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\r\n                const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs4Data.length; index += 2) {\r\n                        uvs4Data[index] = 1 - uvs4Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\r\n                const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs5Data.length; index += 2) {\r\n                        uvs5Data[index] = 1 - uvs5Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);\r\n            }\r\n\r\n            if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\r\n                const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\r\n                if (CompatibilityOptions.UseOpenGLOrientationForUV) {\r\n                    for (let index = 1; index < uvs6Data.length; index += 2) {\r\n                        uvs6Data[index] = 1 - uvs6Data[index];\r\n                    }\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);\r\n            }\r\n\r\n            if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\r\n                const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {\r\n                const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);\r\n                const floatIndices = [];\r\n                for (let i = 0; i < matricesIndicesData.length; i++) {\r\n                    const index = matricesIndicesData[i];\r\n                    floatIndices.push(index & 0x000000ff);\r\n                    floatIndices.push((index & 0x0000ff00) >> 8);\r\n                    floatIndices.push((index & 0x00ff0000) >> 16);\r\n                    floatIndices.push((index >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                }\r\n                mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);\r\n            }\r\n\r\n            if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\r\n                const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\r\n            }\r\n\r\n            if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\r\n                const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\r\n                mesh.setIndices(indicesData, null);\r\n            }\r\n\r\n            if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\r\n                const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\r\n\r\n                mesh.subMeshes = [];\r\n                for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\r\n                    const materialIndex = subMeshesData[i * 5 + 0];\r\n                    const verticesStart = subMeshesData[i * 5 + 1];\r\n                    const verticesCount = subMeshesData[i * 5 + 2];\r\n                    const indexStart = subMeshesData[i * 5 + 3];\r\n                    const indexCount = subMeshesData[i * 5 + 4];\r\n\r\n                    SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, <AbstractMesh>mesh);\r\n                }\r\n            }\r\n        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\r\n            mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\r\n\r\n            mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\r\n\r\n            if (parsedGeometry.tangents) {\r\n                mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs) {\r\n                mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs2) {\r\n                mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs3) {\r\n                mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs4) {\r\n                mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs5) {\r\n                mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.uvs6) {\r\n                mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.colors) {\r\n                mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndices) {\r\n                if (!parsedGeometry.matricesIndices._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndices[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesIndicesExtra) {\r\n                if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\r\n                    const floatIndices = [];\r\n\r\n                    for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\r\n                        const matricesIndex = parsedGeometry.matricesIndicesExtra[i];\r\n\r\n                        floatIndices.push(matricesIndex & 0x000000ff);\r\n                        floatIndices.push((matricesIndex & 0x0000ff00) >> 8);\r\n                        floatIndices.push((matricesIndex & 0x00ff0000) >> 16);\r\n                        floatIndices.push((matricesIndex >> 24) & 0xff); // & 0xFF to convert to v + 256 if v < 0\r\n                    }\r\n\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\r\n                } else {\r\n                    delete parsedGeometry.matricesIndices._isExpanded;\r\n                    mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\r\n                }\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeights) {\r\n                Geometry._CleanMatricesWeights(parsedGeometry, mesh);\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            if (parsedGeometry.matricesWeightsExtra) {\r\n                mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\r\n            }\r\n\r\n            mesh.setIndices(parsedGeometry.indices, null);\r\n        }\r\n\r\n        // SubMeshes\r\n        if (parsedGeometry.subMeshes) {\r\n            mesh.subMeshes = [];\r\n            for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\r\n                const parsedSubMesh = parsedGeometry.subMeshes[subIndex];\r\n\r\n                SubMesh.AddToMesh(\r\n                    parsedSubMesh.materialIndex,\r\n                    parsedSubMesh.verticesStart,\r\n                    parsedSubMesh.verticesCount,\r\n                    parsedSubMesh.indexStart,\r\n                    parsedSubMesh.indexCount,\r\n                    <AbstractMesh>mesh\r\n                );\r\n            }\r\n        }\r\n\r\n        // Flat shading\r\n        if (mesh._shouldGenerateFlatShading) {\r\n            mesh.convertToFlatShadedMesh();\r\n            mesh._shouldGenerateFlatShading = false;\r\n        }\r\n\r\n        // Update\r\n        mesh.computeWorldMatrix(true);\r\n\r\n        scene.onMeshImportedObservable.notifyObservers(<AbstractMesh>mesh);\r\n    }\r\n\r\n    private static _CleanMatricesWeights(parsedGeometry: any, mesh: Mesh): void {\r\n        const epsilon: number = 1e-3;\r\n        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {\r\n            return;\r\n        }\r\n        let noInfluenceBoneIndex = 0.0;\r\n        if (parsedGeometry.skeletonId > -1) {\r\n            const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);\r\n\r\n            if (!skeleton) {\r\n                return;\r\n            }\r\n            noInfluenceBoneIndex = skeleton.bones.length;\r\n        } else {\r\n            return;\r\n        }\r\n        const matricesIndices = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);\r\n        const matricesIndicesExtra = <FloatArray>mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\r\n        const matricesWeights = parsedGeometry.matricesWeights;\r\n        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;\r\n        const influencers = parsedGeometry.numBoneInfluencer;\r\n        const size = matricesWeights.length;\r\n\r\n        for (let i = 0; i < size; i += 4) {\r\n            let weight = 0.0;\r\n            let firstZeroWeight = -1;\r\n            for (let j = 0; j < 4; j++) {\r\n                const w = matricesWeights[i + j];\r\n                weight += w;\r\n                if (w < epsilon && firstZeroWeight < 0) {\r\n                    firstZeroWeight = j;\r\n                }\r\n            }\r\n            if (matricesWeightsExtra) {\r\n                for (let j = 0; j < 4; j++) {\r\n                    const w = matricesWeightsExtra[i + j];\r\n                    weight += w;\r\n                    if (w < epsilon && firstZeroWeight < 0) {\r\n                        firstZeroWeight = j + 4;\r\n                    }\r\n                }\r\n            }\r\n            if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {\r\n                firstZeroWeight = influencers - 1;\r\n            }\r\n            if (weight > epsilon) {\r\n                const mweight = 1.0 / weight;\r\n                for (let j = 0; j < 4; j++) {\r\n                    matricesWeights[i + j] *= mweight;\r\n                }\r\n                if (matricesWeightsExtra) {\r\n                    for (let j = 0; j < 4; j++) {\r\n                        matricesWeightsExtra[i + j] *= mweight;\r\n                    }\r\n                }\r\n            } else {\r\n                if (firstZeroWeight >= 4) {\r\n                    matricesWeightsExtra[i + firstZeroWeight - 4] = 1.0 - weight;\r\n                    matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;\r\n                } else {\r\n                    matricesWeights[i + firstZeroWeight] = 1.0 - weight;\r\n                    matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;\r\n                }\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);\r\n        if (parsedGeometry.matricesWeightsExtra) {\r\n            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new geometry from persisted data (Using .babylon file format)\r\n     * @param parsedVertexData defines the persisted data\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url to use to load assets (like delayed data)\r\n     * @returns the new geometry object\r\n     */\r\n    public static Parse(parsedVertexData: any, scene: Scene, rootUrl: string): Nullable<Geometry> {\r\n        const geometry = new Geometry(parsedVertexData.id, scene, undefined, parsedVertexData.updatable);\r\n        geometry._loadedUniqueId = parsedVertexData.uniqueId;\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(geometry, parsedVertexData.tags);\r\n        }\r\n\r\n        if (parsedVertexData.delayLoadingFile) {\r\n            geometry.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\r\n            geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\r\n\r\n            geometry._delayInfo = [];\r\n            if (parsedVertexData.hasUVs) {\r\n                geometry._delayInfo.push(VertexBuffer.UVKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs2) {\r\n                geometry._delayInfo.push(VertexBuffer.UV2Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs3) {\r\n                geometry._delayInfo.push(VertexBuffer.UV3Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs4) {\r\n                geometry._delayInfo.push(VertexBuffer.UV4Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs5) {\r\n                geometry._delayInfo.push(VertexBuffer.UV5Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasUVs6) {\r\n                geometry._delayInfo.push(VertexBuffer.UV6Kind);\r\n            }\r\n\r\n            if (parsedVertexData.hasColors) {\r\n                geometry._delayInfo.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesIndices) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);\r\n            }\r\n\r\n            if (parsedVertexData.hasMatricesWeights) {\r\n                geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);\r\n            }\r\n\r\n            geometry._delayLoadingFunction = VertexData.ImportVertexData;\r\n        } else {\r\n            VertexData.ImportVertexData(parsedVertexData, geometry);\r\n        }\r\n\r\n        scene.pushGeometry(geometry, true);\r\n\r\n        return geometry;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}