{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterial } from \"../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport { Texture } from \"../../Textures/texture.js\";\nimport \"../../../Shaders/ShadersInclude/helperFunctions.js\";\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject.js\";\nimport { EngineStore } from \"../../../Engines/engineStore.js\";\n/**\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\n */\nexport class TriPlanarBlock extends NodeMaterialBlock {\n  /**\n   * Create a new TriPlanarBlock\n   * @param name defines the block name\n   */\n  constructor(name, hideSourceZ = false) {\n    super(name, NodeMaterialBlockTargets.Neutral);\n    this._convertToGammaSpace = false;\n    this._convertToLinearSpace = false;\n    /**\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\n     */\n    this.disableLevelMultiplication = false;\n    this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\n    this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\n    this.registerInput(\"source\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    this.registerInput(\"sourceY\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    if (!hideSourceZ) {\n      this.registerInput(\"sourceZ\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\"));\n    }\n    this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\n    this._inputs[0].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n    this._inputs[1].addExcludedConnectionPointFromAllowedTypes(NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4);\n  }\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    var _a;\n    if (this.source.isConnected) {\n      return ((_a = this.source.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;\n    }\n    return this._texture;\n  }\n  set texture(texture) {\n    var _a;\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  /**\n   * Gets the textureY associated with the node\n   */\n  get textureY() {\n    var _a;\n    if (this.sourceY.isConnected) {\n      return ((_a = this.sourceY.connectedPoint) === null || _a === void 0 ? void 0 : _a.ownerBlock).texture;\n    }\n    return null;\n  }\n  /**\n   * Gets the textureZ associated with the node\n   */\n  get textureZ() {\n    var _a, _b;\n    if ((_a = this.sourceZ) === null || _a === void 0 ? void 0 : _a.isConnected) {\n      return ((_b = this.sourceY.connectedPoint) === null || _b === void 0 ? void 0 : _b.ownerBlock).texture;\n    }\n    return null;\n  }\n  _getImageSourceBlock(connectionPoint) {\n    return (connectionPoint === null || connectionPoint === void 0 ? void 0 : connectionPoint.isConnected) ? connectionPoint.connectedPoint.ownerBlock : null;\n  }\n  /**\n   * Gets the sampler name associated with this texture\n   */\n  get samplerName() {\n    const imageSourceBlock = this._getImageSourceBlock(this.source);\n    if (imageSourceBlock) {\n      return imageSourceBlock.samplerName;\n    }\n    return this._samplerName;\n  }\n  /**\n   * Gets the samplerY name associated with this texture\n   */\n  get samplerYName() {\n    var _a, _b;\n    return (_b = (_a = this._getImageSourceBlock(this.sourceY)) === null || _a === void 0 ? void 0 : _a.samplerName) !== null && _b !== void 0 ? _b : null;\n  }\n  /**\n   * Gets the samplerZ name associated with this texture\n   */\n  get samplerZName() {\n    var _a, _b;\n    return (_b = (_a = this._getImageSourceBlock(this.sourceZ)) === null || _a === void 0 ? void 0 : _a.samplerName) !== null && _b !== void 0 ? _b : null;\n  }\n  /**\n   * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n   */\n  get hasImageSource() {\n    return this.source.isConnected;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to gamma space\n   */\n  set convertToGammaSpace(value) {\n    var _a;\n    if (value === this._convertToGammaSpace) {\n      return;\n    }\n    this._convertToGammaSpace = value;\n    if (this.texture) {\n      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToGammaSpace() {\n    return this._convertToGammaSpace;\n  }\n  /**\n   * Gets or sets a boolean indicating if content needs to be converted to linear space\n   */\n  set convertToLinearSpace(value) {\n    var _a;\n    if (value === this._convertToLinearSpace) {\n      return;\n    }\n    this._convertToLinearSpace = value;\n    if (this.texture) {\n      const scene = (_a = this.texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n      scene === null || scene === void 0 ? void 0 : scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this.texture);\n      });\n    }\n  }\n  get convertToLinearSpace() {\n    return this._convertToLinearSpace;\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"TriPlanarBlock\";\n  }\n  /**\n   * Gets the position input component\n   */\n  get position() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the normal input component\n   */\n  get normal() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the sharpness input component\n   */\n  get sharpness() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the source input component\n   */\n  get source() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the sourceY input component\n   */\n  get sourceY() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the sourceZ input component\n   */\n  get sourceZ() {\n    return this._inputs[5];\n  }\n  /**\n   * Gets the rgba output component\n   */\n  get rgba() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the rgb output component\n   */\n  get rgb() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the r output component\n   */\n  get r() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the g output component\n   */\n  get g() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the b output component\n   */\n  get b() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the a output component\n   */\n  get a() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the level output component\n   */\n  get level() {\n    return this._outputs[6];\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\n    const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\n    // Not a bug... Name defines the texture space not the required conversion\n    defines.setValue(this._linearDefineName, toGamma, true);\n    defines.setValue(this._gammaDefineName, toLinear, true);\n  }\n  isReady() {\n    if (this.texture && !this.texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect) {\n    if (!this.texture) {\n      return;\n    }\n    effect.setFloat(this._textureInfoName, this.texture.level);\n    if (!this._imageSource) {\n      effect.setTexture(this._samplerName, this.texture);\n    }\n  }\n  _generateTextureLookup(state) {\n    var _a, _b;\n    const samplerName = this.samplerName;\n    const samplerYName = (_a = this.samplerYName) !== null && _a !== void 0 ? _a : samplerName;\n    const samplerZName = (_b = this.samplerZName) !== null && _b !== void 0 ? _b : samplerName;\n    const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\n    const x = state._getFreeVariableName(\"x\");\n    const y = state._getFreeVariableName(\"y\");\n    const z = state._getFreeVariableName(\"z\");\n    const w = state._getFreeVariableName(\"z\");\n    state.compilationString += `\n            vec4 ${x} = texture2D(${samplerName}, ${this.position.associatedVariableName}.yz);\n            vec4 ${y} = texture2D(${samplerYName}, ${this.position.associatedVariableName}.zx);\n            vec4 ${z} = texture2D(${samplerZName}, ${this.position.associatedVariableName}.xy);\n            \n            // blend weights\n            vec3 ${w} = pow(abs(${this.normal.associatedVariableName}.xyz), vec3(${sharpness}));\n\n            // blend and return\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \n        `;\n  }\n  _generateConversionCode(state, output, swizzle) {\n    if (swizzle !== \"a\") {\n      // no conversion if the output is \"a\" (alpha)\n      if (!this.texture || !this.texture.gammaSpace) {\n        state.compilationString += `#ifdef ${this._linearDefineName}\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\n                    #endif\n                `;\n      }\n      state.compilationString += `#ifdef ${this._gammaDefineName}\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\n                #endif\n            `;\n    }\n  }\n  _writeOutput(state, output, swizzle) {\n    let complement = \"\";\n    if (!this.disableLevelMultiplication) {\n      complement = ` * ${this._textureInfoName}`;\n    }\n    state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\r\\n`;\n    this._generateConversionCode(state, output, swizzle);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    if (this.source.isConnected) {\n      this._imageSource = this.source.connectedPoint.ownerBlock;\n    } else {\n      this._imageSource = null;\n    }\n    this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\n    this.level.associatedVariableName = this._textureInfoName;\n    this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\n    this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\n    this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\n    if (!this._imageSource) {\n      this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\n      state._emit2DSampler(this._samplerName);\n    }\n    // Declarations\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    const comments = `//${this.name}`;\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitUniformFromString(this._textureInfoName, \"float\");\n    this._generateTextureLookup(state);\n    for (const output of this._outputs) {\n      if (output.hasEndpoints && output.name !== \"level\") {\n        this._writeOutput(state, output, output.name);\n      }\n    }\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\n    codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\n    codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\r\\n`;\n    if (!this.texture) {\n      return codeString;\n    }\n    codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    serializationObject.convertToGammaSpace = this.convertToGammaSpace;\n    serializationObject.convertToLinearSpace = this.convertToLinearSpace;\n    serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\n    if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\n      serializationObject.texture = this.texture.serialize();\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    this.convertToGammaSpace = serializationObject.convertToGammaSpace;\n    this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\n    this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n    }\n  }\n}\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);","map":{"version":3,"mappings":";AAAA,SAASA,iBAAiB,QAAQ,yBAAuB;AACzD,SAASC,qCAAqC,QAAQ,mDAAiD;AAEvG,SAASC,wBAAwB,QAAQ,sCAAoC;AAE7E,SAASC,oCAAoC,QAAQ,wCAAsC;AAG3F,SAASC,YAAY,QAAQ,oBAAkB;AAG/C,SAASC,aAAa,QAAQ,4BAA0B;AACxD,SAASC,OAAO,QAAQ,2BAAyB;AAGjD,OAAO,oDAAkD;AACzD,SAASC,gBAAgB,QAAQ,4BAA0B;AAC3D,SAASC,uCAAuC,QAAQ,+CAA6C;AACrG,SAASC,WAAW,QAAQ,iCAA+B;AAE3D;;;AAGA,OAAM,MAAOC,cAAe,SAAQV,iBAAiB;EAgJjD;;;;EAIAW,YAAmBC,IAAY,EAAEC,WAAW,GAAG,KAAK;IAChD,KAAK,CAACD,IAAI,EAAEV,wBAAwB,CAACY,OAAO,CAAC;IApDzC,yBAAoB,GAAG,KAAK;IAqB5B,0BAAqB,GAAG,KAAK;IAqBrC;;;IAGO,+BAA0B,GAAG,KAAK;IASrC,IAAI,CAACC,aAAa,CAAC,UAAU,EAAEd,qCAAqC,CAACe,UAAU,EAAE,KAAK,CAAC;IACvF,IAAI,CAACD,aAAa,CAAC,QAAQ,EAAEd,qCAAqC,CAACe,UAAU,EAAE,KAAK,CAAC;IACrF,IAAI,CAACD,aAAa,CAAC,WAAW,EAAEd,qCAAqC,CAACgB,KAAK,EAAE,IAAI,CAAC;IAClF,IAAI,CAACF,aAAa,CACd,QAAQ,EACRd,qCAAqC,CAACiB,MAAM,EAC5C,IAAI,EACJhB,wBAAwB,CAACiB,iBAAiB,EAC1C,IAAIX,uCAAuC,CAAC,QAAQ,EAAE,IAAI,EAAEL,oCAAoC,CAACiB,KAAK,EAAEb,gBAAgB,EAAE,kBAAkB,CAAC,CAChJ;IACD,IAAI,CAACQ,aAAa,CACd,SAAS,EACTd,qCAAqC,CAACiB,MAAM,EAC5C,IAAI,EACJhB,wBAAwB,CAACiB,iBAAiB,EAC1C,IAAIX,uCAAuC,CAAC,SAAS,EAAE,IAAI,EAAEL,oCAAoC,CAACiB,KAAK,EAAEb,gBAAgB,EAAE,kBAAkB,CAAC,CACjJ;IACD,IAAI,CAACM,WAAW,EAAE;MACd,IAAI,CAACE,aAAa,CACd,SAAS,EACTd,qCAAqC,CAACiB,MAAM,EAC5C,IAAI,EACJhB,wBAAwB,CAACiB,iBAAiB,EAC1C,IAAIX,uCAAuC,CAAC,SAAS,EAAE,IAAI,EAAEL,oCAAoC,CAACiB,KAAK,EAAEb,gBAAgB,EAAE,kBAAkB,CAAC,CACjJ;;IAGL,IAAI,CAACc,cAAc,CAAC,MAAM,EAAEpB,qCAAqC,CAACqB,MAAM,EAAEpB,wBAAwB,CAACY,OAAO,CAAC;IAC3G,IAAI,CAACO,cAAc,CAAC,KAAK,EAAEpB,qCAAqC,CAACsB,MAAM,EAAErB,wBAAwB,CAACY,OAAO,CAAC;IAC1G,IAAI,CAACO,cAAc,CAAC,GAAG,EAAEpB,qCAAqC,CAACgB,KAAK,EAAEf,wBAAwB,CAACY,OAAO,CAAC;IACvG,IAAI,CAACO,cAAc,CAAC,GAAG,EAAEpB,qCAAqC,CAACgB,KAAK,EAAEf,wBAAwB,CAACY,OAAO,CAAC;IACvG,IAAI,CAACO,cAAc,CAAC,GAAG,EAAEpB,qCAAqC,CAACgB,KAAK,EAAEf,wBAAwB,CAACY,OAAO,CAAC;IACvG,IAAI,CAACO,cAAc,CAAC,GAAG,EAAEpB,qCAAqC,CAACgB,KAAK,EAAEf,wBAAwB,CAACY,OAAO,CAAC;IAEvG,IAAI,CAACO,cAAc,CAAC,OAAO,EAAEpB,qCAAqC,CAACgB,KAAK,EAAEf,wBAAwB,CAACY,OAAO,CAAC;IAE3G,IAAI,CAACU,OAAO,CAAC,CAAC,CAAC,CAACC,0CAA0C,CACtDxB,qCAAqC,CAACsB,MAAM,GAAGtB,qCAAqC,CAACyB,OAAO,GAAGzB,qCAAqC,CAAC0B,OAAO,CAC/I;IACD,IAAI,CAACH,OAAO,CAAC,CAAC,CAAC,CAACC,0CAA0C,CACtDxB,qCAAqC,CAACsB,MAAM,GAAGtB,qCAAqC,CAACyB,OAAO,GAAGzB,qCAAqC,CAAC0B,OAAO,CAC/I;EACL;EAxLA;;;EAGA,IAAWC,OAAO;;IACd,IAAI,IAAI,CAACC,MAAM,CAACC,WAAW,EAAE;MACzB,OAAO,CAAC,UAAI,CAACD,MAAM,CAACE,cAAc,0CAAEC,UAA+B,EAACJ,OAAO;;IAE/E,OAAO,IAAI,CAACK,QAAQ;EACxB;EAEA,IAAWL,OAAO,CAACA,OAA0B;;IACzC,IAAI,IAAI,CAACK,QAAQ,KAAKL,OAAO,EAAE;MAC3B;;IAGJ,MAAMM,KAAK,GAAG,aAAO,aAAPN,OAAO,uBAAPA,OAAO,CAAEO,QAAQ,EAAE,mCAAI1B,WAAW,CAAC2B,gBAAgB;IAEjE,IAAI,CAACR,OAAO,IAAIM,KAAK,EAAE;MACnBA,KAAK,CAACG,uBAAuB,CAAC,UAAU;QACpC,OAAOC,GAAG,CAACC,UAAU,CAAC,IAAI,CAACN,QAAS,CAAC;MACzC,CAAC,CAAC;;IAGN,IAAI,CAACA,QAAQ,GAAGL,OAAO;IAEvB,IAAIA,OAAO,IAAIM,KAAK,EAAE;MAClBA,KAAK,CAACG,uBAAuB,CAAC,UAAU;QACpC,OAAOC,GAAG,CAACC,UAAU,CAACX,OAAO,CAAC;MAClC,CAAC,CAAC;;EAEV;EAEA;;;EAGA,IAAWY,QAAQ;;IACf,IAAI,IAAI,CAACC,OAAO,CAACX,WAAW,EAAE;MAC1B,OAAO,CAAC,UAAI,CAACW,OAAO,CAACV,cAAc,0CAAEC,UAA+B,EAACJ,OAAO;;IAEhF,OAAO,IAAI;EACf;EAEA;;;EAGA,IAAWc,QAAQ;;IACf,IAAI,UAAI,CAACC,OAAO,0CAAEb,WAAW,EAAE;MAC3B,OAAO,CAAC,UAAI,CAACW,OAAO,CAACV,cAAc,0CAAEC,UAA+B,EAACJ,OAAO;;IAEhF,OAAO,IAAI;EACf;EAEUgB,oBAAoB,CAACC,eAAsD;IACjF,OAAO,gBAAe,aAAfA,eAAe,uBAAfA,eAAe,CAAEf,WAAW,IAAIe,eAAe,CAACd,cAAe,CAACC,UAA+B,GAAG,IAAI;EACjH;EAEA;;;EAGA,IAAWc,WAAW;IAClB,MAAMC,gBAAgB,GAAG,IAAI,CAACH,oBAAoB,CAAC,IAAI,CAACf,MAAM,CAAC;IAC/D,IAAIkB,gBAAgB,EAAE;MAClB,OAAOA,gBAAgB,CAACD,WAAW;;IAEvC,OAAO,IAAI,CAACE,YAAY;EAC5B;EAEA;;;EAGA,IAAWC,YAAY;;IACnB,OAAO,gBAAI,CAACL,oBAAoB,CAAC,IAAI,CAACH,OAAO,CAAC,0CAAEK,WAAW,mCAAI,IAAI;EACvE;EAEA;;;EAGA,IAAWI,YAAY;;IACnB,OAAO,gBAAI,CAACN,oBAAoB,CAAC,IAAI,CAACD,OAAO,CAAC,0CAAEG,WAAW,mCAAI,IAAI;EACvE;EAEA;;;EAGA,IAAWK,cAAc;IACrB,OAAO,IAAI,CAACtB,MAAM,CAACC,WAAW;EAClC;EAGA;;;EAGA,IAAWsB,mBAAmB,CAACC,KAAc;;IACzC,IAAIA,KAAK,KAAK,IAAI,CAACC,oBAAoB,EAAE;MACrC;;IAGJ,IAAI,CAACA,oBAAoB,GAAGD,KAAK;IACjC,IAAI,IAAI,CAACzB,OAAO,EAAE;MACd,MAAMM,KAAK,GAAG,UAAI,CAACN,OAAO,CAACO,QAAQ,EAAE,mCAAI1B,WAAW,CAAC2B,gBAAgB;MACrEF,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEG,uBAAuB,CAAC,UAAU;QACrC,OAAOC,GAAG,CAACC,UAAU,CAAC,IAAI,CAACX,OAAQ,CAAC;MACxC,CAAC,CAAC;;EAEV;EACA,IAAWwB,mBAAmB;IAC1B,OAAO,IAAI,CAACE,oBAAoB;EACpC;EAGA;;;EAGA,IAAWC,oBAAoB,CAACF,KAAc;;IAC1C,IAAIA,KAAK,KAAK,IAAI,CAACG,qBAAqB,EAAE;MACtC;;IAGJ,IAAI,CAACA,qBAAqB,GAAGH,KAAK;IAClC,IAAI,IAAI,CAACzB,OAAO,EAAE;MACd,MAAMM,KAAK,GAAG,UAAI,CAACN,OAAO,CAACO,QAAQ,EAAE,mCAAI1B,WAAW,CAAC2B,gBAAgB;MACrEF,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEG,uBAAuB,CAAC,UAAU;QACrC,OAAOC,GAAG,CAACC,UAAU,CAAC,IAAI,CAACX,OAAQ,CAAC;MACxC,CAAC,CAAC;;EAEV;EACA,IAAW2B,oBAAoB;IAC3B,OAAO,IAAI,CAACC,qBAAqB;EACrC;EA0DA;;;;EAIOC,YAAY;IACf,OAAO,gBAAgB;EAC3B;EAEA;;;EAGA,IAAWC,QAAQ;IACf,OAAO,IAAI,CAAClC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWmC,MAAM;IACb,OAAO,IAAI,CAACnC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWoC,SAAS;IAChB,OAAO,IAAI,CAACpC,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWK,MAAM;IACb,OAAO,IAAI,CAACL,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWiB,OAAO;IACd,OAAO,IAAI,CAACjB,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWmB,OAAO;IACd,OAAO,IAAI,CAACnB,OAAO,CAAC,CAAC,CAAC;EAC1B;EAEA;;;EAGA,IAAWqC,IAAI;IACX,OAAO,IAAI,CAACC,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWC,GAAG;IACV,OAAO,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWE,CAAC;IACR,OAAO,IAAI,CAACF,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWG,CAAC;IACR,OAAO,IAAI,CAACH,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWI,CAAC;IACR,OAAO,IAAI,CAACJ,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWK,CAAC;IACR,OAAO,IAAI,CAACL,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEA;;;EAGA,IAAWM,KAAK;IACZ,OAAO,IAAI,CAACN,QAAQ,CAAC,CAAC,CAAC;EAC3B;EAEOO,cAAc,CAACC,IAAkB,EAAEC,YAA0B,EAAEC,OAA4B;IAC9F,IAAI,CAACA,OAAO,CAACC,iBAAiB,EAAE;MAC5B;;IAGJ,MAAMC,OAAO,GAAG,IAAI,CAACtB,mBAAmB,IAAI,IAAI,CAACxB,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAAC+C,UAAU;IACpF,MAAMC,QAAQ,GAAG,IAAI,CAACrB,oBAAoB,IAAI,IAAI,CAAC3B,OAAO,IAAI,IAAI,CAACA,OAAO,CAAC+C,UAAU;IAErF;IACAH,OAAO,CAACK,QAAQ,CAAC,IAAI,CAACC,iBAAiB,EAAEJ,OAAO,EAAE,IAAI,CAAC;IACvDF,OAAO,CAACK,QAAQ,CAAC,IAAI,CAACE,gBAAgB,EAAEH,QAAQ,EAAE,IAAI,CAAC;EAC3D;EAEOI,OAAO;IACV,IAAI,IAAI,CAACpD,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAACqD,oBAAoB,EAAE,EAAE;MACtD,OAAO,KAAK;;IAGhB,OAAO,IAAI;EACf;EAEOC,IAAI,CAACC,MAAc;IACtB,IAAI,CAAC,IAAI,CAACvD,OAAO,EAAE;MACf;;IAGJuD,MAAM,CAACC,QAAQ,CAAC,IAAI,CAACC,gBAAgB,EAAE,IAAI,CAACzD,OAAO,CAACwC,KAAK,CAAC;IAE1D,IAAI,CAAC,IAAI,CAACkB,YAAY,EAAE;MACpBH,MAAM,CAACI,UAAU,CAAC,IAAI,CAACvC,YAAY,EAAE,IAAI,CAACpB,OAAO,CAAC;;EAE1D;EAEU4D,sBAAsB,CAACC,KAA6B;;IAC1D,MAAM3C,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMG,YAAY,GAAG,UAAI,CAACA,YAAY,mCAAIH,WAAW;IACrD,MAAMI,YAAY,GAAG,UAAI,CAACA,YAAY,mCAAIJ,WAAW;IAErD,MAAMc,SAAS,GAAG,IAAI,CAACA,SAAS,CAAC9B,WAAW,GAAG,IAAI,CAAC8B,SAAS,CAAC8B,sBAAsB,GAAG,KAAK;IAE5F,MAAMC,CAAC,GAAGF,KAAK,CAACG,oBAAoB,CAAC,GAAG,CAAC;IACzC,MAAMC,CAAC,GAAGJ,KAAK,CAACG,oBAAoB,CAAC,GAAG,CAAC;IACzC,MAAME,CAAC,GAAGL,KAAK,CAACG,oBAAoB,CAAC,GAAG,CAAC;IACzC,MAAMG,CAAC,GAAGN,KAAK,CAACG,oBAAoB,CAAC,GAAG,CAAC;IAEzCH,KAAK,CAACO,iBAAiB,IAAI;mBAChBL,CAAC,gBAAgB7C,WAAW,KAAK,IAAI,CAACY,QAAQ,CAACgC,sBAAsB;mBACrEG,CAAC,gBAAgB5C,YAAY,KAAK,IAAI,CAACS,QAAQ,CAACgC,sBAAsB;mBACtEI,CAAC,gBAAgB5C,YAAY,KAAK,IAAI,CAACQ,QAAQ,CAACgC,sBAAsB;;;mBAGtEK,CAAC,cAAc,IAAI,CAACpC,MAAM,CAAC+B,sBAAsB,eAAe9B,SAAS;;;mBAGzE,IAAI,CAACqC,gBAAgB,OAAON,CAAC,IAAII,CAAC,QAAQF,CAAC,IAAIE,CAAC,QAAQD,CAAC,IAAIC,CAAC,UAAUA,CAAC,QAAQA,CAAC,QAAQA,CAAC;SACrG;EACL;EAEQG,uBAAuB,CAACT,KAA6B,EAAEU,MAAmC,EAAEC,OAAe;IAC/G,IAAIA,OAAO,KAAK,GAAG,EAAE;MACjB;MACA,IAAI,CAAC,IAAI,CAACxE,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAAC+C,UAAU,EAAE;QAC3Cc,KAAK,CAACO,iBAAiB,IAAI,UAAU,IAAI,CAAClB,iBAAiB;sBACrDqB,MAAM,CAACT,sBAAsB,mBAAmBS,MAAM,CAACT,sBAAsB;;iBAElF;;MAGLD,KAAK,CAACO,iBAAiB,IAAI,UAAU,IAAI,CAACjB,gBAAgB;kBACpDoB,MAAM,CAACT,sBAAsB,oBAAoBS,MAAM,CAACT,sBAAsB;;aAEnF;;EAET;EAEQW,YAAY,CAACZ,KAA6B,EAAEU,MAAmC,EAAEC,OAAe;IACpG,IAAIE,UAAU,GAAG,EAAE;IAEnB,IAAI,CAAC,IAAI,CAACC,0BAA0B,EAAE;MAClCD,UAAU,GAAG,MAAM,IAAI,CAACjB,gBAAgB,EAAE;;IAG9CI,KAAK,CAACO,iBAAiB,IAAI,GAAG,IAAI,CAACQ,cAAc,CAACL,MAAM,EAAEV,KAAK,CAAC,MAAM,IAAI,CAACQ,gBAAgB,IAAIG,OAAO,GAAGE,UAAU,OAAO;IAC1H,IAAI,CAACJ,uBAAuB,CAACT,KAAK,EAAEU,MAAM,EAAEC,OAAO,CAAC;EACxD;EAEUK,WAAW,CAAChB,KAA6B;IAC/C,KAAK,CAACgB,WAAW,CAAChB,KAAK,CAAC;IAExB,IAAI,IAAI,CAAC5D,MAAM,CAACC,WAAW,EAAE;MACzB,IAAI,CAACwD,YAAY,GAAG,IAAI,CAACzD,MAAM,CAACE,cAAe,CAACC,UAA8B;KACjF,MAAM;MACH,IAAI,CAACsD,YAAY,GAAG,IAAI;;IAG5B,IAAI,CAACD,gBAAgB,GAAGI,KAAK,CAACG,oBAAoB,CAAC,iBAAiB,CAAC;IAErE,IAAI,CAACxB,KAAK,CAACsB,sBAAsB,GAAG,IAAI,CAACL,gBAAgB;IAEzD,IAAI,CAACY,gBAAgB,GAAGR,KAAK,CAACG,oBAAoB,CAAC,iBAAiB,CAAC;IACrE,IAAI,CAACd,iBAAiB,GAAGW,KAAK,CAACiB,kBAAkB,CAAC,UAAU,CAAC;IAC7D,IAAI,CAAC3B,gBAAgB,GAAGU,KAAK,CAACiB,kBAAkB,CAAC,SAAS,CAAC;IAE3D,IAAI,CAAC,IAAI,CAACpB,YAAY,EAAE;MACpB,IAAI,CAACtC,YAAY,GAAGyC,KAAK,CAACG,oBAAoB,CAAC,IAAI,CAAChF,IAAI,GAAG,SAAS,CAAC;MAErE6E,KAAK,CAACkB,cAAc,CAAC,IAAI,CAAC3D,YAAY,CAAC;;IAG3C;IACAyC,KAAK,CAACmB,UAAU,CAACC,cAAc,CAACC,IAAI,CAAC,IAAI,CAAC;IAC1CrB,KAAK,CAACmB,UAAU,CAACG,aAAa,CAACD,IAAI,CAAC,IAAI,CAAC;IACzCrB,KAAK,CAACmB,UAAU,CAACI,iBAAiB,CAACF,IAAI,CAAC,IAAI,CAAC;IAC7CrB,KAAK,CAACmB,UAAU,CAACK,cAAc,CAACH,IAAI,CAAC,IAAI,CAAC;IAE1C,MAAMI,QAAQ,GAAG,KAAK,IAAI,CAACtG,IAAI,EAAE;IACjC6E,KAAK,CAAC0B,wBAAwB,CAAC,iBAAiB,EAAED,QAAQ,CAAC;IAE3DzB,KAAK,CAAC2B,sBAAsB,CAAC,IAAI,CAAC/B,gBAAgB,EAAE,OAAO,CAAC;IAE5D,IAAI,CAACG,sBAAsB,CAACC,KAAK,CAAC;IAElC,KAAK,MAAMU,MAAM,IAAI,IAAI,CAACrC,QAAQ,EAAE;MAChC,IAAIqC,MAAM,CAACkB,YAAY,IAAIlB,MAAM,CAACvF,IAAI,KAAK,OAAO,EAAE;QAChD,IAAI,CAACyF,YAAY,CAACZ,KAAK,EAAEU,MAAM,EAAEA,MAAM,CAACvF,IAAI,CAAC;;;IAIrD,OAAO,IAAI;EACf;EAEU0G,mBAAmB;IACzB,IAAIC,UAAU,GAAG,KAAK,CAACD,mBAAmB,EAAE;IAE5CC,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,0BAA0B,IAAI,CAACpE,mBAAmB,OAAO;IAChGmE,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,2BAA2B,IAAI,CAACjE,oBAAoB,OAAO;IAClGgE,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,iCAAiC,IAAI,CAACjB,0BAA0B,OAAO;IAE9G,IAAI,CAAC,IAAI,CAAC3E,OAAO,EAAE;MACf,OAAO2F,UAAU;;IAGrBA,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,mCAAmC,IAAI,CAAC5F,OAAO,CAAChB,IAAI,YAAY,IAAI,CAACgB,OAAO,CAAC6F,QAAQ,KAAK,IAAI,CAAC7F,OAAO,CAAC8F,OAAO,KAAK,IAAI,CAAC9F,OAAO,CAAC+F,YAAY,QAAQ;IAC3LJ,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,oBAAoB,IAAI,CAAC5F,OAAO,CAACgG,KAAK,OAAO;IACpFL,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,oBAAoB,IAAI,CAAC5F,OAAO,CAACiG,KAAK,OAAO;IACpFN,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,mBAAmB,IAAI,CAAC5F,OAAO,CAACkG,IAAI,OAAO;IAClFP,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,mBAAmB,IAAI,CAAC5F,OAAO,CAACmG,IAAI,OAAO;IAClFR,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,mBAAmB,IAAI,CAAC5F,OAAO,CAACoG,IAAI,OAAO;IAClFT,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,sBAAsB,IAAI,CAAC5F,OAAO,CAACqG,OAAO,OAAO;IACxFV,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,sBAAsB,IAAI,CAAC5F,OAAO,CAACsG,OAAO,OAAO;IACxFX,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,qBAAqB,IAAI,CAAC5F,OAAO,CAACuG,MAAM,OAAO;IACtFZ,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,qBAAqB,IAAI,CAAC5F,OAAO,CAACwG,MAAM,OAAO;IACtFb,UAAU,IAAI,GAAG,IAAI,CAACC,iBAAiB,8BAA8B,IAAI,CAAC5F,OAAO,CAACyG,eAAe,OAAO;IAExG,OAAOd,UAAU;EACrB;EAEOe,SAAS;IACZ,MAAMC,mBAAmB,GAAG,KAAK,CAACD,SAAS,EAAE;IAE7CC,mBAAmB,CAACnF,mBAAmB,GAAG,IAAI,CAACA,mBAAmB;IAClEmF,mBAAmB,CAAChF,oBAAoB,GAAG,IAAI,CAACA,oBAAoB;IACpEgF,mBAAmB,CAAChC,0BAA0B,GAAG,IAAI,CAACA,0BAA0B;IAChF,IAAI,CAAC,IAAI,CAACpD,cAAc,IAAI,IAAI,CAACvB,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAAC4G,cAAc,IAAI,IAAI,CAAC5G,OAAO,CAAC6B,YAAY,EAAE,KAAK,cAAc,EAAE;MACxH8E,mBAAmB,CAAC3G,OAAO,GAAG,IAAI,CAACA,OAAO,CAAC0G,SAAS,EAAE;;IAG1D,OAAOC,mBAAmB;EAC9B;EAEOE,YAAY,CAACF,mBAAwB,EAAErG,KAAY,EAAEwG,OAAe;IACvE,KAAK,CAACD,YAAY,CAACF,mBAAmB,EAAErG,KAAK,EAAEwG,OAAO,CAAC;IAEvD,IAAI,CAACtF,mBAAmB,GAAGmF,mBAAmB,CAACnF,mBAAmB;IAClE,IAAI,CAACG,oBAAoB,GAAG,CAAC,CAACgF,mBAAmB,CAAChF,oBAAoB;IACtE,IAAI,CAACgD,0BAA0B,GAAG,CAAC,CAACgC,mBAAmB,CAAChC,0BAA0B;IAElF,IAAIgC,mBAAmB,CAAC3G,OAAO,IAAI,CAACxB,YAAY,CAACuI,wBAAwB,IAAIJ,mBAAmB,CAAC3G,OAAO,CAACgH,GAAG,KAAKC,SAAS,EAAE;MACxHH,OAAO,GAAGH,mBAAmB,CAAC3G,OAAO,CAACgH,GAAG,CAACE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,GAAGJ,OAAO;MAC/E,IAAI,CAAC9G,OAAO,GAAGtB,OAAO,CAACyI,KAAK,CAACR,mBAAmB,CAAC3G,OAAO,EAAEM,KAAK,EAAEwG,OAAO,CAAY;;EAE5F;;AAGJrI,aAAa,CAAC,wBAAwB,EAAEK,cAAc,CAAC","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","NodeMaterialConnectionPointDirection","NodeMaterial","RegisterClass","Texture","ImageSourceBlock","NodeMaterialConnectionPointCustomObject","EngineStore","TriPlanarBlock","constructor","name","hideSourceZ","Neutral","registerInput","AutoDetect","Float","Object","VertexAndFragment","Input","registerOutput","Color4","Color3","_inputs","addExcludedConnectionPointFromAllowedTypes","Vector3","Vector4","texture","source","isConnected","connectedPoint","ownerBlock","_texture","scene","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","textureY","sourceY","textureZ","sourceZ","_getImageSourceBlock","connectionPoint","samplerName","imageSourceBlock","_samplerName","samplerYName","samplerZName","hasImageSource","convertToGammaSpace","value","_convertToGammaSpace","convertToLinearSpace","_convertToLinearSpace","getClassName","position","normal","sharpness","rgba","_outputs","rgb","r","g","b","a","level","prepareDefines","mesh","nodeMaterial","defines","_areTexturesDirty","toGamma","gammaSpace","toLinear","setValue","_linearDefineName","_gammaDefineName","isReady","isReadyOrNotBlocking","bind","effect","setFloat","_textureInfoName","_imageSource","setTexture","_generateTextureLookup","state","associatedVariableName","x","_getFreeVariableName","y","z","w","compilationString","_tempTextureRead","_generateConversionCode","output","swizzle","_writeOutput","complement","disableLevelMultiplication","_declareOutput","_buildBlock","_getFreeDefineName","_emit2DSampler","sharedData","blockingBlocks","push","textureBlocks","blocksWithDefines","bindableBlocks","comments","_emitFunctionFromInclude","_emitUniformFromString","hasEndpoints","_dumpPropertiesCode","codeString","_codeVariableName","noMipmap","invertY","samplingMode","wrapU","wrapV","uAng","vAng","wAng","uOffset","vOffset","uScale","vScale","coordinatesMode","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","IgnoreTexturesAtLoadTime","url","undefined","indexOf","Parse"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Node/Blocks/triPlanarBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../nodeMaterialBlockConnectionPoint\";\r\nimport type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../nodeMaterial\";\r\nimport { NodeMaterial } from \"../nodeMaterial\";\r\nimport type { Effect } from \"../../effect\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { Texture } from \"../../Textures/texture\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport \"../../../Shaders/ShadersInclude/helperFunctions\";\r\nimport { ImageSourceBlock } from \"./Dual/imageSourceBlock\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../nodeMaterialConnectionPointCustomObject\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\n\r\n/**\r\n * Block used to read a texture with triplanar mapping (see \"boxmap\" in https://iquilezles.org/articles/biplanar/)\r\n */\r\nexport class TriPlanarBlock extends NodeMaterialBlock {\r\n    private _linearDefineName: string;\r\n    private _gammaDefineName: string;\r\n    protected _tempTextureRead: string;\r\n    private _samplerName: string;\r\n    private _textureInfoName: string;\r\n    private _imageSource: Nullable<ImageSourceBlock>;\r\n\r\n    protected _texture: Nullable<Texture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<Texture> {\r\n        if (this.source.isConnected) {\r\n            return (this.source.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<Texture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the textureY associated with the node\r\n     */\r\n    public get textureY(): Nullable<Texture> {\r\n        if (this.sourceY.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the textureZ associated with the node\r\n     */\r\n    public get textureZ(): Nullable<Texture> {\r\n        if (this.sourceZ?.isConnected) {\r\n            return (this.sourceY.connectedPoint?.ownerBlock as ImageSourceBlock).texture;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _getImageSourceBlock(connectionPoint: Nullable<NodeMaterialConnectionPoint>): Nullable<ImageSourceBlock> {\r\n        return connectionPoint?.isConnected ? (connectionPoint.connectedPoint!.ownerBlock as ImageSourceBlock) : null;\r\n    }\r\n\r\n    /**\r\n     * Gets the sampler name associated with this texture\r\n     */\r\n    public get samplerName(): string {\r\n        const imageSourceBlock = this._getImageSourceBlock(this.source);\r\n        if (imageSourceBlock) {\r\n            return imageSourceBlock.samplerName;\r\n        }\r\n        return this._samplerName;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerY name associated with this texture\r\n     */\r\n    public get samplerYName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceY)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplerZ name associated with this texture\r\n     */\r\n    public get samplerZName(): Nullable<string> {\r\n        return this._getImageSourceBlock(this.sourceZ)?.samplerName ?? null;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\r\n     */\r\n    public get hasImageSource(): boolean {\r\n        return this.source.isConnected;\r\n    }\r\n\r\n    private _convertToGammaSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to gamma space\r\n     */\r\n    public set convertToGammaSpace(value: boolean) {\r\n        if (value === this._convertToGammaSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToGammaSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToGammaSpace(): boolean {\r\n        return this._convertToGammaSpace;\r\n    }\r\n\r\n    private _convertToLinearSpace = false;\r\n    /**\r\n     * Gets or sets a boolean indicating if content needs to be converted to linear space\r\n     */\r\n    public set convertToLinearSpace(value: boolean) {\r\n        if (value === this._convertToLinearSpace) {\r\n            return;\r\n        }\r\n\r\n        this._convertToLinearSpace = value;\r\n        if (this.texture) {\r\n            const scene = this.texture.getScene() ?? EngineStore.LastCreatedScene;\r\n            scene?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this.texture!);\r\n            });\r\n        }\r\n    }\r\n    public get convertToLinearSpace(): boolean {\r\n        return this._convertToLinearSpace;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if multiplication of texture with level should be disabled\r\n     */\r\n    public disableLevelMultiplication = false;\r\n\r\n    /**\r\n     * Create a new TriPlanarBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string, hideSourceZ = false) {\r\n        super(name, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerInput(\"position\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"normal\", NodeMaterialBlockConnectionPointTypes.AutoDetect, false);\r\n        this.registerInput(\"sharpness\", NodeMaterialBlockConnectionPointTypes.Float, true);\r\n        this.registerInput(\r\n            \"source\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        this.registerInput(\r\n            \"sourceY\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"sourceY\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n        );\r\n        if (!hideSourceZ) {\r\n            this.registerInput(\r\n                \"sourceZ\",\r\n                NodeMaterialBlockConnectionPointTypes.Object,\r\n                true,\r\n                NodeMaterialBlockTargets.VertexAndFragment,\r\n                new NodeMaterialConnectionPointCustomObject(\"sourceZ\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\r\n            );\r\n        }\r\n\r\n        this.registerOutput(\"rgba\", NodeMaterialBlockConnectionPointTypes.Color4, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"rgb\", NodeMaterialBlockConnectionPointTypes.Color3, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"r\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"g\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"b\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n        this.registerOutput(\"a\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this.registerOutput(\"level\", NodeMaterialBlockConnectionPointTypes.Float, NodeMaterialBlockTargets.Neutral);\r\n\r\n        this._inputs[0].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n        this._inputs[1].addExcludedConnectionPointFromAllowedTypes(\r\n            NodeMaterialBlockConnectionPointTypes.Color3 | NodeMaterialBlockConnectionPointTypes.Vector3 | NodeMaterialBlockConnectionPointTypes.Vector4\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"TriPlanarBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the position input component\r\n     */\r\n    public get position(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the normal input component\r\n     */\r\n    public get normal(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the sharpness input component\r\n     */\r\n    public get sharpness(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the source input component\r\n     */\r\n    public get source(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceY input component\r\n     */\r\n    public get sourceY(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the sourceZ input component\r\n     */\r\n    public get sourceZ(): Nullable<NodeMaterialConnectionPoint> {\r\n        return this._inputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgba output component\r\n     */\r\n    public get rgba(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the rgb output component\r\n     */\r\n    public get rgb(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the r output component\r\n     */\r\n    public get r(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the g output component\r\n     */\r\n    public get g(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the b output component\r\n     */\r\n    public get b(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the a output component\r\n     */\r\n    public get a(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the level output component\r\n     */\r\n    public get level(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const toGamma = this.convertToGammaSpace && this.texture && !this.texture.gammaSpace;\r\n        const toLinear = this.convertToLinearSpace && this.texture && this.texture.gammaSpace;\r\n\r\n        // Not a bug... Name defines the texture space not the required conversion\r\n        defines.setValue(this._linearDefineName, toGamma, true);\r\n        defines.setValue(this._gammaDefineName, toLinear, true);\r\n    }\r\n\r\n    public isReady() {\r\n        if (this.texture && !this.texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect) {\r\n        if (!this.texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setFloat(this._textureInfoName, this.texture.level);\r\n\r\n        if (!this._imageSource) {\r\n            effect.setTexture(this._samplerName, this.texture);\r\n        }\r\n    }\r\n\r\n    protected _generateTextureLookup(state: NodeMaterialBuildState): void {\r\n        const samplerName = this.samplerName;\r\n        const samplerYName = this.samplerYName ?? samplerName;\r\n        const samplerZName = this.samplerZName ?? samplerName;\r\n\r\n        const sharpness = this.sharpness.isConnected ? this.sharpness.associatedVariableName : \"1.0\";\r\n\r\n        const x = state._getFreeVariableName(\"x\");\r\n        const y = state._getFreeVariableName(\"y\");\r\n        const z = state._getFreeVariableName(\"z\");\r\n        const w = state._getFreeVariableName(\"z\");\r\n\r\n        state.compilationString += `\r\n            vec4 ${x} = texture2D(${samplerName}, ${this.position.associatedVariableName}.yz);\r\n            vec4 ${y} = texture2D(${samplerYName}, ${this.position.associatedVariableName}.zx);\r\n            vec4 ${z} = texture2D(${samplerZName}, ${this.position.associatedVariableName}.xy);\r\n            \r\n            // blend weights\r\n            vec3 ${w} = pow(abs(${this.normal.associatedVariableName}.xyz), vec3(${sharpness}));\r\n\r\n            // blend and return\r\n            vec4 ${this._tempTextureRead} = (${x}*${w}.x + ${y}*${w}.y + ${z}*${w}.z) / (${w}.x + ${w}.y + ${w}.z);        \r\n        `;\r\n    }\r\n\r\n    private _generateConversionCode(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string): void {\r\n        if (swizzle !== \"a\") {\r\n            // no conversion if the output is \"a\" (alpha)\r\n            if (!this.texture || !this.texture.gammaSpace) {\r\n                state.compilationString += `#ifdef ${this._linearDefineName}\r\n                    ${output.associatedVariableName} = toGammaSpace(${output.associatedVariableName});\r\n                    #endif\r\n                `;\r\n            }\r\n\r\n            state.compilationString += `#ifdef ${this._gammaDefineName}\r\n                ${output.associatedVariableName} = toLinearSpace(${output.associatedVariableName});\r\n                #endif\r\n            `;\r\n        }\r\n    }\r\n\r\n    private _writeOutput(state: NodeMaterialBuildState, output: NodeMaterialConnectionPoint, swizzle: string) {\r\n        let complement = \"\";\r\n\r\n        if (!this.disableLevelMultiplication) {\r\n            complement = ` * ${this._textureInfoName}`;\r\n        }\r\n\r\n        state.compilationString += `${this._declareOutput(output, state)} = ${this._tempTextureRead}.${swizzle}${complement};\\r\\n`;\r\n        this._generateConversionCode(state, output, swizzle);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        if (this.source.isConnected) {\r\n            this._imageSource = this.source.connectedPoint!.ownerBlock as ImageSourceBlock;\r\n        } else {\r\n            this._imageSource = null;\r\n        }\r\n\r\n        this._textureInfoName = state._getFreeVariableName(\"textureInfoName\");\r\n\r\n        this.level.associatedVariableName = this._textureInfoName;\r\n\r\n        this._tempTextureRead = state._getFreeVariableName(\"tempTextureRead\");\r\n        this._linearDefineName = state._getFreeDefineName(\"ISLINEAR\");\r\n        this._gammaDefineName = state._getFreeDefineName(\"ISGAMMA\");\r\n\r\n        if (!this._imageSource) {\r\n            this._samplerName = state._getFreeVariableName(this.name + \"Sampler\");\r\n\r\n            state._emit2DSampler(this._samplerName);\r\n        }\r\n\r\n        // Declarations\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n\r\n        state._emitUniformFromString(this._textureInfoName, \"float\");\r\n\r\n        this._generateTextureLookup(state);\r\n\r\n        for (const output of this._outputs) {\r\n            if (output.hasEndpoints && output.name !== \"level\") {\r\n                this._writeOutput(state, output, output.name);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        codeString += `${this._codeVariableName}.convertToGammaSpace = ${this.convertToGammaSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.convertToLinearSpace = ${this.convertToLinearSpace};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.disableLevelMultiplication = ${this.disableLevelMultiplication};\\r\\n`;\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null, ${this.texture.noMipmap}, ${this.texture.invertY}, ${this.texture.samplingMode});\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapU = ${this.texture.wrapU};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wrapV = ${this.texture.wrapV};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uAng = ${this.texture.uAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vAng = ${this.texture.vAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.wAng = ${this.texture.wAng};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uOffset = ${this.texture.uOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vOffset = ${this.texture.vOffset};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.uScale = ${this.texture.uScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.vScale = ${this.texture.vScale};\\r\\n`;\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        serializationObject.convertToGammaSpace = this.convertToGammaSpace;\r\n        serializationObject.convertToLinearSpace = this.convertToLinearSpace;\r\n        serializationObject.disableLevelMultiplication = this.disableLevelMultiplication;\r\n        if (!this.hasImageSource && this.texture && !this.texture.isRenderTarget && this.texture.getClassName() !== \"VideoTexture\") {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        this.convertToGammaSpace = serializationObject.convertToGammaSpace;\r\n        this.convertToLinearSpace = !!serializationObject.convertToLinearSpace;\r\n        this.disableLevelMultiplication = !!serializationObject.disableLevelMultiplication;\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime && serializationObject.texture.url !== undefined) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl) as Texture;\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.TriPlanarBlock\", TriPlanarBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}