{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * This represents a set of one or more post processes in Babylon.\n * A post process can be used to apply a shader to a texture after it is rendered.\n * @example https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\n */\nexport class PostProcessRenderEffect {\n  /**\n   * Instantiates a post process render effect.\n   * A post process can be used to apply a shader to a texture after it is rendered.\n   * @param engine The engine the effect is tied to\n   * @param name The name of the effect\n   * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\n   * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\n   */\n  constructor(engine, name, getPostProcesses, singleInstance) {\n    this._name = name;\n    this._singleInstance = singleInstance || true;\n    this._getPostProcesses = getPostProcesses;\n    this._cameras = {};\n    this._indicesForCamera = {};\n    this._postProcesses = {};\n  }\n  /**\n   * Checks if all the post processes in the effect are supported.\n   */\n  get isSupported() {\n    for (const index in this._postProcesses) {\n      if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\n        const pps = this._postProcesses[index];\n        for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\n          if (!pps[ppIndex].isSupported) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Updates the current state of the effect\n   * @internal\n   */\n  _update() {}\n  /**\n   * Attaches the effect on cameras\n   * @param cameras The camera to attach to.\n   * @internal\n   */\n  _attachCameras(cameras) {\n    let cameraKey;\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      if (!camera) {\n        continue;\n      }\n      const cameraName = camera.name;\n      if (this._singleInstance) {\n        cameraKey = 0;\n      } else {\n        cameraKey = cameraName;\n      }\n      if (!this._postProcesses[cameraKey]) {\n        const postProcess = this._getPostProcesses();\n        if (postProcess) {\n          this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\n        }\n      }\n      if (!this._indicesForCamera[cameraName]) {\n        this._indicesForCamera[cameraName] = [];\n      }\n      this._postProcesses[cameraKey].forEach(postProcess => {\n        const index = camera.attachPostProcess(postProcess);\n        this._indicesForCamera[cameraName].push(index);\n      });\n      if (!this._cameras[cameraName]) {\n        this._cameras[cameraName] = camera;\n      }\n    }\n  }\n  /**\n   * Detaches the effect on cameras\n   * @param cameras The camera to detach from.\n   * @internal\n   */\n  _detachCameras(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      const cameraName = camera.name;\n      const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\n      if (postProcesses) {\n        postProcesses.forEach(postProcess => {\n          camera.detachPostProcess(postProcess);\n        });\n      }\n      if (this._cameras[cameraName]) {\n        this._cameras[cameraName] = null;\n      }\n    }\n  }\n  /**\n   * Enables the effect on given cameras\n   * @param cameras The camera to enable.\n   * @internal\n   */\n  _enable(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      const cameraName = camera.name;\n      for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\n        if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {\n          this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(postProcess => {\n            cams[i].attachPostProcess(postProcess, this._indicesForCamera[cameraName][j]);\n          });\n        }\n      }\n    }\n  }\n  /**\n   * Disables the effect on the given cameras\n   * @param cameras The camera to disable.\n   * @internal\n   */\n  _disable(cameras) {\n    const cams = Tools.MakeArray(cameras || this._cameras);\n    if (!cams) {\n      return;\n    }\n    for (let i = 0; i < cams.length; i++) {\n      const camera = cams[i];\n      const cameraName = camera.name;\n      this._postProcesses[this._singleInstance ? 0 : cameraName].forEach(postProcess => {\n        camera.detachPostProcess(postProcess);\n      });\n    }\n  }\n  /**\n   * Gets a list of the post processes contained in the effect.\n   * @param camera The camera to get the post processes on.\n   * @returns The list of the post processes in the effect.\n   */\n  getPostProcesses(camera) {\n    if (this._singleInstance) {\n      return this._postProcesses[0];\n    } else {\n      if (!camera) {\n        return null;\n      }\n      return this._postProcesses[camera.name];\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Tools","PostProcessRenderEffect","constructor","engine","name","getPostProcesses","singleInstance","_name","_singleInstance","_getPostProcesses","_cameras","_indicesForCamera","_postProcesses","isSupported","index","Object","prototype","hasOwnProperty","call","pps","ppIndex","length","_update","_attachCameras","cameras","cameraKey","cams","MakeArray","i","camera","cameraName","postProcess","Array","isArray","forEach","attachPostProcess","push","_detachCameras","postProcesses","detachPostProcess","_enable","j","undefined","_disable"],"sourceRoot":"","sources":["../../../../../lts/core/generated/PostProcesses/RenderPipeline/postProcessRenderEffect.ts"],"sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { PostProcess } from \"../../PostProcesses/postProcess\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\n/**\r\n * This represents a set of one or more post processes in Babylon.\r\n * A post process can be used to apply a shader to a texture after it is rendered.\r\n * @example https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/postProcessRenderPipeline\r\n */\r\nexport class PostProcessRenderEffect {\r\n    private _postProcesses: { [Key: string]: Array<PostProcess> };\r\n    private _getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>;\r\n\r\n    private _singleInstance: boolean;\r\n\r\n    private _cameras: { [key: string]: Nullable<Camera> };\r\n    private _indicesForCamera: { [key: string]: number[] };\r\n\r\n    /**\r\n     * Name of the effect\r\n     * @internal\r\n     */\r\n    public _name: string;\r\n\r\n    /**\r\n     * Instantiates a post process render effect.\r\n     * A post process can be used to apply a shader to a texture after it is rendered.\r\n     * @param engine The engine the effect is tied to\r\n     * @param name The name of the effect\r\n     * @param getPostProcesses A function that returns a set of post processes which the effect will run in order to be run.\r\n     * @param singleInstance False if this post process can be run on multiple cameras. (default: true)\r\n     */\r\n    constructor(engine: Engine, name: string, getPostProcesses: () => Nullable<PostProcess | Array<PostProcess>>, singleInstance?: boolean) {\r\n        this._name = name;\r\n        this._singleInstance = singleInstance || true;\r\n\r\n        this._getPostProcesses = getPostProcesses;\r\n\r\n        this._cameras = {};\r\n        this._indicesForCamera = {};\r\n\r\n        this._postProcesses = {};\r\n    }\r\n\r\n    /**\r\n     * Checks if all the post processes in the effect are supported.\r\n     */\r\n    public get isSupported(): boolean {\r\n        for (const index in this._postProcesses) {\r\n            if (Object.prototype.hasOwnProperty.call(this._postProcesses, index)) {\r\n                const pps = this._postProcesses[index];\r\n                for (let ppIndex = 0; ppIndex < pps.length; ppIndex++) {\r\n                    if (!pps[ppIndex].isSupported) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Updates the current state of the effect\r\n     * @internal\r\n     */\r\n    public _update(): void {}\r\n\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: Camera): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Attaches the effect on cameras\r\n     * @param cameras The camera to attach to.\r\n     * @internal\r\n     */\r\n    public _attachCameras(cameras: any): void {\r\n        let cameraKey;\r\n\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            if (!camera) {\r\n                continue;\r\n            }\r\n\r\n            const cameraName = camera.name;\r\n\r\n            if (this._singleInstance) {\r\n                cameraKey = 0;\r\n            } else {\r\n                cameraKey = cameraName;\r\n            }\r\n\r\n            if (!this._postProcesses[cameraKey]) {\r\n                const postProcess = this._getPostProcesses();\r\n                if (postProcess) {\r\n                    this._postProcesses[cameraKey] = Array.isArray(postProcess) ? postProcess : [postProcess];\r\n                }\r\n            }\r\n\r\n            if (!this._indicesForCamera[cameraName]) {\r\n                this._indicesForCamera[cameraName] = [];\r\n            }\r\n\r\n            this._postProcesses[cameraKey].forEach((postProcess: PostProcess) => {\r\n                const index = camera.attachPostProcess(postProcess);\r\n\r\n                this._indicesForCamera[cameraName].push(index);\r\n            });\r\n\r\n            if (!this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = camera;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: Camera): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: Camera[]): void;\r\n    /**\r\n     * Detaches the effect on cameras\r\n     * @param cameras The camera to detach from.\r\n     * @internal\r\n     */\r\n    public _detachCameras(cameras: any): void {\r\n        const cams = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera: Camera = cams[i];\r\n            const cameraName: string = camera.name;\r\n            const postProcesses = this._postProcesses[this._singleInstance ? 0 : cameraName];\r\n\r\n            if (postProcesses) {\r\n                postProcesses.forEach((postProcess: PostProcess) => {\r\n                    camera.detachPostProcess(postProcess);\r\n                });\r\n            }\r\n\r\n            if (this._cameras[cameraName]) {\r\n                this._cameras[cameraName] = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: Camera): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Enables the effect on given cameras\r\n     * @param cameras The camera to enable.\r\n     * @internal\r\n     */\r\n    public _enable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n\r\n            for (let j = 0; j < this._indicesForCamera[cameraName].length; j++) {\r\n                if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined || camera._postProcesses[this._indicesForCamera[cameraName][j]] === null) {\r\n                    this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                        cams![i].attachPostProcess(postProcess, this._indicesForCamera[cameraName][j]);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: Camera): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: Nullable<Camera[]>): void;\r\n    /**\r\n     * Disables the effect on the given cameras\r\n     * @param cameras The camera to disable.\r\n     * @internal\r\n     */\r\n    public _disable(cameras: any): void {\r\n        const cams: Nullable<Array<Camera>> = Tools.MakeArray(cameras || this._cameras);\r\n\r\n        if (!cams) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < cams.length; i++) {\r\n            const camera = cams[i];\r\n            const cameraName = camera.name;\r\n            this._postProcesses[this._singleInstance ? 0 : cameraName].forEach((postProcess) => {\r\n                camera.detachPostProcess(postProcess);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of the post processes contained in the effect.\r\n     * @param camera The camera to get the post processes on.\r\n     * @returns The list of the post processes in the effect.\r\n     */\r\n    public getPostProcesses(camera?: Camera): Nullable<Array<PostProcess>> {\r\n        if (this._singleInstance) {\r\n            return this._postProcesses[0];\r\n        } else {\r\n            if (!camera) {\r\n                return null;\r\n            }\r\n            return this._postProcesses[camera.name];\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}