{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __decorate } from \"../../../../tslib.es6.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { NodeMaterial } from \"../../nodeMaterial.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { InputBlock } from \"../Input/inputBlock.js\";\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues.js\";\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction.js\";\nimport { CubeTexture } from \"../../../Textures/cubeTexture.js\";\nimport { Texture } from \"../../../Textures/texture.js\";\nimport { EngineStore } from \"../../../../Engines/engineStore.js\";\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator.js\";\n/**\n * Base block used to read a reflection texture from a sampler\n */\nexport class ReflectionTextureBaseBlock extends NodeMaterialBlock {\n  /**\n   * Create a new ReflectionTextureBaseBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.VertexAndFragment);\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\n    this.generateOnlyFragmentCode = false;\n  }\n  /**\n   * Gets or sets the texture associated with the node\n   */\n  get texture() {\n    return this._texture;\n  }\n  set texture(texture) {\n    var _a;\n    if (this._texture === texture) {\n      return;\n    }\n    const scene = (_a = texture === null || texture === void 0 ? void 0 : texture.getScene()) !== null && _a !== void 0 ? _a : EngineStore.LastCreatedScene;\n    if (!texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(this._texture);\n      });\n    }\n    this._texture = texture;\n    if (texture && scene) {\n      scene.markAllMaterialsAsDirty(1, mat => {\n        return mat.hasTexture(texture);\n      });\n    }\n  }\n  static _OnGenerateOnlyFragmentCodeChanged(block, _propertyName) {\n    const that = block;\n    return that._onGenerateOnlyFragmentCodeChanged();\n  }\n  _onGenerateOnlyFragmentCodeChanged() {\n    this._setTarget();\n    return true;\n  }\n  _setTarget() {\n    this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"ReflectionTextureBaseBlock\";\n  }\n  _getTexture() {\n    return this.texture;\n  }\n  autoConfigure(material) {\n    if (!this.position.isConnected) {\n      let positionInput = material.getInputBlockByPredicate(b => b.isAttribute && b.name === \"position\");\n      if (!positionInput) {\n        positionInput = new InputBlock(\"position\");\n        positionInput.setAsAttribute();\n      }\n      positionInput.output.connectTo(this.position);\n    }\n    if (!this.world.isConnected) {\n      let worldInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.World);\n      if (!worldInput) {\n        worldInput = new InputBlock(\"world\");\n        worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\n      }\n      worldInput.output.connectTo(this.world);\n    }\n    if (this.view && !this.view.isConnected) {\n      let viewInput = material.getInputBlockByPredicate(b => b.systemValue === NodeMaterialSystemValues.View);\n      if (!viewInput) {\n        viewInput = new InputBlock(\"view\");\n        viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\n      }\n      viewInput.output.connectTo(this.view);\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areTexturesDirty) {\n      return;\n    }\n    const texture = this._getTexture();\n    if (!texture || !texture.getTextureMatrix) {\n      return;\n    }\n    defines.setValue(this._define3DName, texture.isCube, true);\n    defines.setValue(this._defineLocalCubicName, texture.boundingBoxSize ? true : false, true);\n    defines.setValue(this._defineExplicitName, texture.coordinatesMode === 0, true);\n    defines.setValue(this._defineSkyboxName, texture.coordinatesMode === 5, true);\n    defines.setValue(this._defineCubicName, texture.coordinatesMode === 3 || texture.coordinatesMode === 6, true);\n    defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === 6, true);\n    defines.setValue(this._defineSphericalName, texture.coordinatesMode === 1, true);\n    defines.setValue(this._definePlanarName, texture.coordinatesMode === 2, true);\n    defines.setValue(this._defineProjectionName, texture.coordinatesMode === 4, true);\n    defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === 7, true);\n    defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === 8, true);\n    defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === 9, true);\n  }\n  isReady() {\n    const texture = this._getTexture();\n    if (texture && !texture.isReadyOrNotBlocking()) {\n      return false;\n    }\n    return true;\n  }\n  bind(effect, nodeMaterial, mesh) {\n    const texture = this._getTexture();\n    if (!mesh || !texture) {\n      return;\n    }\n    effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\n    if (texture.isCube) {\n      effect.setTexture(this._cubeSamplerName, texture);\n    } else {\n      effect.setTexture(this._2DSamplerName, texture);\n    }\n    if (texture.boundingBoxSize) {\n      const cubeTexture = texture;\n      effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\n      effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\n    }\n  }\n  /**\n   * Gets the code to inject in the vertex shader\n   * @param state current state of the node material building\n   * @returns the shader code\n   */\n  handleVertexSide(state) {\n    if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\n      return \"\";\n    }\n    this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\n    this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\n    this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\n    this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\n    this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\n    this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\n    this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n    this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\n    this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n    this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n    this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\n    this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\n    this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\n    state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\n    let code = \"\";\n    this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\n    const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\n      code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\r\\n`;\n    }\n    this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\n    this._directionWName = state._getFreeVariableName(\"directionW\");\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\n      code += `#ifdef ${this._defineSkyboxName}\\r\\n`;\n      code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\r\\n`;\n      code += `#endif\\r\\n`;\n    }\n    if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._directionWName, \"vec3\", `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`)) {\n      code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\r\\n`;\n      code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${this.position.associatedVariableName}.xyz, 0.0)));\\r\\n`;\n      code += `#endif\\r\\n`;\n    }\n    return code;\n  }\n  /**\n   * Handles the inits for the fragment code path\n   * @param state node material build state\n   */\n  handleFragmentSideInits(state) {\n    state.sharedData.blockingBlocks.push(this);\n    state.sharedData.textureBlocks.push(this);\n    // Samplers\n    this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\n    state.samplers.push(this._cubeSamplerName);\n    this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\n    state.samplers.push(this._2DSamplerName);\n    state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\n    state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\n    state._samplerDeclaration += `#else\\r\\n`;\n    state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\n    state._samplerDeclaration += `#endif\\r\\n`;\n    // Fragment\n    state.sharedData.blocksWithDefines.push(this);\n    state.sharedData.bindableBlocks.push(this);\n    const comments = `//${this.name}`;\n    state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\n    state._emitFunctionFromInclude(\"helperFunctions\", comments);\n    state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\n      replaceStrings: [{\n        search: /vec3 computeReflectionCoords/g,\n        replace: \"void DUMMYFUNC\"\n      }]\n    });\n    this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\n    this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\n    this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\n    this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\n    state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\n    this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\n    state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\n  }\n  /**\n   * Generates the reflection coords code for the fragment code path\n   * @param worldNormalVarName name of the world normal variable\n   * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\n   * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\n   * @param doNotEmitInvertZ if true, does not emit the invertZ code\n   * @returns the shader code\n   */\n  handleFragmentSideCodeReflectionCoords(worldNormalVarName, worldPos, onlyReflectionVector = false, doNotEmitInvertZ = false) {\n    if (!worldPos) {\n      worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\n    }\n    const reflectionMatrix = this._reflectionMatrixName;\n    const direction = `normalize(${this._directionWName})`;\n    const positionUVW = `${this._positionUVWName}`;\n    const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\n    const view = `${this.view.associatedVariableName}`;\n    worldNormalVarName += \".xyz\";\n    let code = `\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\n            #endif\n\n            #ifdef ${this._defineEquirectangularFixedName}\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\n            #endif\n\n            #ifdef ${this._defineEquirectangularName}\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineSphericalName}\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._definePlanarName}\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineCubicName}\n                #ifdef ${this._defineLocalCubicName}\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\n                #else\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\n                #endif\n            #endif\n\n            #ifdef ${this._defineProjectionName}\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineSkyboxName}\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\n            #endif\n\n            #ifdef ${this._defineExplicitName}\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\n            #endif\\r\\n`;\n    if (!doNotEmitInvertZ) {\n      code += `#ifdef ${this._defineOppositeZ}\n                ${this._reflectionVectorName}.z *= -1.0;\n            #endif\\r\\n`;\n    }\n    if (!onlyReflectionVector) {\n      code += `\n                #ifdef ${this._define3DName}\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\n                #else\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\n                    #ifdef ${this._defineProjectionName}\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\n                    #endif\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\n                #endif\\r\\n`;\n    }\n    return code;\n  }\n  /**\n   * Generates the reflection color code for the fragment code path\n   * @param lodVarName name of the lod variable\n   * @param swizzleLookupTexture swizzle to use for the final color variable\n   * @returns the shader code\n   */\n  handleFragmentSideCodeReflectionColor(lodVarName, swizzleLookupTexture = \".rgb\") {\n    const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\n    let code = `${colorType} ${this._reflectionColorName};\n            #ifdef ${this._define3DName}\\r\\n`;\n    if (lodVarName) {\n      code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\n    } else {\n      code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\r\\n`;\n    }\n    code += `\n            #else\\r\\n`;\n    if (lodVarName) {\n      code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\n    } else {\n      code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\r\\n`;\n    }\n    code += `#endif\\r\\n`;\n    return code;\n  }\n  /**\n   * Generates the code corresponding to the connected output points\n   * @param state node material build state\n   * @param varName name of the variable to output\n   * @returns the shader code\n   */\n  writeOutputs(state, varName) {\n    let code = \"\";\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      for (const output of this._outputs) {\n        if (output.hasEndpoints) {\n          code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\n        }\n      }\n    }\n    return code;\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    return this;\n  }\n  _dumpPropertiesCode() {\n    let codeString = super._dumpPropertiesCode();\n    if (!this.texture) {\n      return codeString;\n    }\n    if (this.texture.isCube) {\n      const forcedExtension = this.texture.forcedExtension;\n      codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${this.texture.noMipmap}, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\r\\n`;\n    } else {\n      codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\r\\n`;\n    }\n    codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\n    return codeString;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.texture && !this.texture.isRenderTarget) {\n      serializationObject.texture = this.texture.serialize();\n    }\n    serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\n      rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\n      if (serializationObject.texture.isCube) {\n        this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\n      } else {\n        this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\n      }\n    }\n    this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\n    this._setTarget();\n  }\n}\n__decorate([editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\n  notifiers: {\n    rebuild: true,\n    update: true,\n    onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged\n  }\n})], ReflectionTextureBaseBlock.prototype, \"generateOnlyFragmentCode\", void 0);\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockTargets","NodeMaterial","RegisterClass","InputBlock","NodeMaterialSystemValues","CubeTexture","Texture","EngineStore","editableInPropertyPage","PropertyTypeForEdition","ReflectionTextureBaseBlock","constructor","name","VertexAndFragment","texture","_texture","scene","getScene","LastCreatedScene","markAllMaterialsAsDirty","mat","hasTexture","_OnGenerateOnlyFragmentCodeChanged","block","_propertyName","that","_onGenerateOnlyFragmentCodeChanged","_setTarget","_setInitialTarget","generateOnlyFragmentCode","Fragment","getClassName","_getTexture","autoConfigure","material","position","isConnected","positionInput","getInputBlockByPredicate","b","isAttribute","setAsAttribute","output","connectTo","world","worldInput","systemValue","World","setAsSystemValue","view","viewInput","View","prepareDefines","mesh","nodeMaterial","defines","_areTexturesDirty","getTextureMatrix","setValue","_define3DName","isCube","_defineLocalCubicName","boundingBoxSize","_defineExplicitName","coordinatesMode","_defineSkyboxName","_defineCubicName","_defineSphericalName","_definePlanarName","_defineProjectionName","_defineEquirectangularName","_defineEquirectangularFixedName","_defineMirroredEquirectangularFixedName","isReady","isReadyOrNotBlocking","bind","effect","setMatrix","_reflectionMatrixName","getReflectionTextureMatrix","setTexture","_cubeSamplerName","_2DSamplerName","cubeTexture","setVector3","_reflectionPositionName","boundingBoxPosition","_reflectionSizeName","handleVertexSide","state","target","Vertex","_getFreeDefineName","_defineOppositeZ","_getFreeVariableName","_emitUniformFromString","code","_worldPositionNameInFragmentOnlyMode","worldPosVaryingName","worldPosition","associatedVariableName","_emitVaryingFromString","_positionUVWName","_directionWName","handleFragmentSideInits","sharedData","blockingBlocks","push","textureBlocks","samplers","_samplerDeclaration","blocksWithDefines","bindableBlocks","comments","_emitFunction","_emitFunctionFromInclude","replaceStrings","search","replace","_reflectionColorName","_reflectionVectorName","_reflectionCoordsName","handleFragmentSideCodeReflectionCoords","worldNormalVarName","worldPos","onlyReflectionVector","doNotEmitInvertZ","reflectionMatrix","direction","positionUVW","vEyePosition","cameraPosition","handleFragmentSideCodeReflectionColor","lodVarName","swizzleLookupTexture","colorType","length","writeOutputs","varName","_outputs","hasEndpoints","_declareOutput","_buildBlock","_dumpPropertiesCode","codeString","forcedExtension","_codeVariableName","noMipmap","_prefiltered","serialize","serializationObject","isRenderTarget","_deserialize","rootUrl","IgnoreTexturesAtLoadTime","url","indexOf","Parse","__decorate","Boolean","notifiers","rebuild","update","onValidation"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Dual/reflectionTextureBaseBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterial } from \"../../nodeMaterial\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport { InputBlock } from \"../Input/inputBlock\";\r\nimport { NodeMaterialSystemValues } from \"../../Enums/nodeMaterialSystemValues\";\r\nimport { Constants } from \"../../../../Engines/constants\";\r\n\r\nimport \"../../../../Shaders/ShadersInclude/reflectionFunction\";\r\nimport { CubeTexture } from \"../../../Textures/cubeTexture\";\r\nimport { Texture } from \"../../../Textures/texture\";\r\nimport { EngineStore } from \"../../../../Engines/engineStore\";\r\nimport { editableInPropertyPage, PropertyTypeForEdition } from \"../../nodeMaterialDecorator\";\r\n\r\n/**\r\n * Base block used to read a reflection texture from a sampler\r\n */\r\nexport abstract class ReflectionTextureBaseBlock extends NodeMaterialBlock {\r\n    /** @internal */\r\n    public _define3DName: string;\r\n    /** @internal */\r\n    public _defineCubicName: string;\r\n    /** @internal */\r\n    public _defineExplicitName: string;\r\n    /** @internal */\r\n    public _defineProjectionName: string;\r\n    /** @internal */\r\n    public _defineLocalCubicName: string;\r\n    /** @internal */\r\n    public _defineSphericalName: string;\r\n    /** @internal */\r\n    public _definePlanarName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularName: string;\r\n    /** @internal */\r\n    public _defineMirroredEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineEquirectangularFixedName: string;\r\n    /** @internal */\r\n    public _defineSkyboxName: string;\r\n    /** @internal */\r\n    public _defineOppositeZ: string;\r\n    /** @internal */\r\n    public _cubeSamplerName: string;\r\n    /** @internal */\r\n    public _2DSamplerName: string;\r\n    /** @internal */\r\n    public _reflectionPositionName: string;\r\n    /** @internal */\r\n    public _reflectionSizeName: string;\r\n\r\n    protected _positionUVWName: string;\r\n    protected _directionWName: string;\r\n    protected _reflectionVectorName: string;\r\n    /** @internal */\r\n    public _reflectionCoordsName: string;\r\n    /** @internal */\r\n    public _reflectionMatrixName: string;\r\n    protected _reflectionColorName: string;\r\n    protected _worldPositionNameInFragmentOnlyMode: string;\r\n\r\n    protected _texture: Nullable<BaseTexture>;\r\n    /**\r\n     * Gets or sets the texture associated with the node\r\n     */\r\n    public get texture(): Nullable<BaseTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    public set texture(texture: Nullable<BaseTexture>) {\r\n        if (this._texture === texture) {\r\n            return;\r\n        }\r\n\r\n        const scene = texture?.getScene() ?? EngineStore.LastCreatedScene;\r\n\r\n        if (!texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this._texture!);\r\n            });\r\n        }\r\n\r\n        this._texture = texture;\r\n\r\n        if (texture && scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(texture);\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Indicates that no code should be generated in the vertex shader. Can be useful in some specific circumstances (like when doing ray marching for eg) */\r\n    @editableInPropertyPage(\"Generate only fragment code\", PropertyTypeForEdition.Boolean, \"ADVANCED\", {\r\n        notifiers: { rebuild: true, update: true, onValidation: ReflectionTextureBaseBlock._OnGenerateOnlyFragmentCodeChanged },\r\n    })\r\n    public generateOnlyFragmentCode = false;\r\n\r\n    protected static _OnGenerateOnlyFragmentCodeChanged(block: NodeMaterialBlock, _propertyName: string): boolean {\r\n        const that = block as ReflectionTextureBaseBlock;\r\n        return that._onGenerateOnlyFragmentCodeChanged();\r\n    }\r\n\r\n    protected _onGenerateOnlyFragmentCodeChanged(): boolean {\r\n        this._setTarget();\r\n        return true;\r\n    }\r\n\r\n    protected _setTarget(): void {\r\n        this._setInitialTarget(this.generateOnlyFragmentCode ? NodeMaterialBlockTargets.Fragment : NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Create a new ReflectionTextureBaseBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.VertexAndFragment);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"ReflectionTextureBaseBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get position(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public abstract get worldPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world normal input component\r\n     */\r\n    public abstract get worldNormal(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the world input component\r\n     */\r\n    public abstract get world(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the camera (or eye) position component\r\n     */\r\n    public abstract get cameraPosition(): NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Gets the view input component\r\n     */\r\n    public abstract get view(): NodeMaterialConnectionPoint;\r\n\r\n    protected _getTexture(): Nullable<BaseTexture> {\r\n        return this.texture;\r\n    }\r\n\r\n    public autoConfigure(material: NodeMaterial) {\r\n        if (!this.position.isConnected) {\r\n            let positionInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"position\");\r\n\r\n            if (!positionInput) {\r\n                positionInput = new InputBlock(\"position\");\r\n                positionInput.setAsAttribute();\r\n            }\r\n            positionInput.output.connectTo(this.position);\r\n        }\r\n\r\n        if (!this.world.isConnected) {\r\n            let worldInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.World);\r\n\r\n            if (!worldInput) {\r\n                worldInput = new InputBlock(\"world\");\r\n                worldInput.setAsSystemValue(NodeMaterialSystemValues.World);\r\n            }\r\n            worldInput.output.connectTo(this.world);\r\n        }\r\n\r\n        if (this.view && !this.view.isConnected) {\r\n            let viewInput = material.getInputBlockByPredicate((b) => b.systemValue === NodeMaterialSystemValues.View);\r\n\r\n            if (!viewInput) {\r\n                viewInput = new InputBlock(\"view\");\r\n                viewInput.setAsSystemValue(NodeMaterialSystemValues.View);\r\n            }\r\n            viewInput.output.connectTo(this.view);\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areTexturesDirty) {\r\n            return;\r\n        }\r\n\r\n        const texture = this._getTexture();\r\n\r\n        if (!texture || !texture.getTextureMatrix) {\r\n            return;\r\n        }\r\n\r\n        defines.setValue(this._define3DName, texture.isCube, true);\r\n        defines.setValue(this._defineLocalCubicName, (<any>texture).boundingBoxSize ? true : false, true);\r\n        defines.setValue(this._defineExplicitName, texture.coordinatesMode === Constants.TEXTURE_EXPLICIT_MODE, true);\r\n        defines.setValue(this._defineSkyboxName, texture.coordinatesMode === Constants.TEXTURE_SKYBOX_MODE, true);\r\n        defines.setValue(this._defineCubicName, texture.coordinatesMode === Constants.TEXTURE_CUBIC_MODE || texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(\"INVERTCUBICMAP\", texture.coordinatesMode === Constants.TEXTURE_INVCUBIC_MODE, true);\r\n        defines.setValue(this._defineSphericalName, texture.coordinatesMode === Constants.TEXTURE_SPHERICAL_MODE, true);\r\n        defines.setValue(this._definePlanarName, texture.coordinatesMode === Constants.TEXTURE_PLANAR_MODE, true);\r\n        defines.setValue(this._defineProjectionName, texture.coordinatesMode === Constants.TEXTURE_PROJECTION_MODE, true);\r\n        defines.setValue(this._defineEquirectangularName, texture.coordinatesMode === Constants.TEXTURE_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE, true);\r\n        defines.setValue(this._defineMirroredEquirectangularFixedName, texture.coordinatesMode === Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE, true);\r\n    }\r\n\r\n    public isReady() {\r\n        const texture = this._getTexture();\r\n\r\n        if (texture && !texture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        const texture = this._getTexture();\r\n\r\n        if (!mesh || !texture) {\r\n            return;\r\n        }\r\n\r\n        effect.setMatrix(this._reflectionMatrixName, texture.getReflectionTextureMatrix());\r\n\r\n        if (texture.isCube) {\r\n            effect.setTexture(this._cubeSamplerName, texture);\r\n        } else {\r\n            effect.setTexture(this._2DSamplerName, texture);\r\n        }\r\n\r\n        if ((<any>texture).boundingBoxSize) {\r\n            const cubeTexture = <CubeTexture>texture;\r\n            effect.setVector3(this._reflectionPositionName, cubeTexture.boundingBoxPosition);\r\n            effect.setVector3(this._reflectionSizeName, cubeTexture.boundingBoxSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the code to inject in the vertex shader\r\n     * @param state current state of the node material building\r\n     * @returns the shader code\r\n     */\r\n    public handleVertexSide(state: NodeMaterialBuildState): string {\r\n        if (this.generateOnlyFragmentCode && state.target === NodeMaterialBlockTargets.Vertex) {\r\n            return \"\";\r\n        }\r\n\r\n        this._define3DName = state._getFreeDefineName(\"REFLECTIONMAP_3D\");\r\n        this._defineCubicName = state._getFreeDefineName(\"REFLECTIONMAP_CUBIC\");\r\n        this._defineSphericalName = state._getFreeDefineName(\"REFLECTIONMAP_SPHERICAL\");\r\n        this._definePlanarName = state._getFreeDefineName(\"REFLECTIONMAP_PLANAR\");\r\n        this._defineProjectionName = state._getFreeDefineName(\"REFLECTIONMAP_PROJECTION\");\r\n        this._defineExplicitName = state._getFreeDefineName(\"REFLECTIONMAP_EXPLICIT\");\r\n        this._defineEquirectangularName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n        this._defineLocalCubicName = state._getFreeDefineName(\"USE_LOCAL_REFLECTIONMAP_CUBIC\");\r\n        this._defineMirroredEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n        this._defineEquirectangularFixedName = state._getFreeDefineName(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n        this._defineSkyboxName = state._getFreeDefineName(\"REFLECTIONMAP_SKYBOX\");\r\n        this._defineOppositeZ = state._getFreeDefineName(\"REFLECTIONMAP_OPPOSITEZ\");\r\n\r\n        this._reflectionMatrixName = state._getFreeVariableName(\"reflectionMatrix\");\r\n\r\n        state._emitUniformFromString(this._reflectionMatrixName, \"mat4\");\r\n\r\n        let code = \"\";\r\n\r\n        this._worldPositionNameInFragmentOnlyMode = state._getFreeVariableName(\"worldPosition\");\r\n\r\n        const worldPosVaryingName = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : \"v_\" + this.worldPosition.associatedVariableName;\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(worldPosVaryingName, \"vec4\")) {\r\n            code += `${this.generateOnlyFragmentCode ? \"vec4 \" : \"\"}${worldPosVaryingName} = ${this.worldPosition.associatedVariableName};\\r\\n`;\r\n        }\r\n\r\n        this._positionUVWName = state._getFreeVariableName(\"positionUVW\");\r\n        this._directionWName = state._getFreeVariableName(\"directionW\");\r\n\r\n        if (this.generateOnlyFragmentCode || state._emitVaryingFromString(this._positionUVWName, \"vec3\", this._defineSkyboxName)) {\r\n            code += `#ifdef ${this._defineSkyboxName}\\r\\n`;\r\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._positionUVWName} = ${this.position.associatedVariableName}.xyz;\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        if (\r\n            this.generateOnlyFragmentCode ||\r\n            state._emitVaryingFromString(\r\n                this._directionWName,\r\n                \"vec3\",\r\n                `defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})`\r\n            )\r\n        ) {\r\n            code += `#if defined(${this._defineEquirectangularFixedName}) || defined(${this._defineMirroredEquirectangularFixedName})\\r\\n`;\r\n            code += `${this.generateOnlyFragmentCode ? \"vec3 \" : \"\"}${this._directionWName} = normalize(vec3(${this.world.associatedVariableName} * vec4(${\r\n                this.position.associatedVariableName\r\n            }.xyz, 0.0)));\\r\\n`;\r\n            code += `#endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Handles the inits for the fragment code path\r\n     * @param state node material build state\r\n     */\r\n    public handleFragmentSideInits(state: NodeMaterialBuildState) {\r\n        state.sharedData.blockingBlocks.push(this);\r\n        state.sharedData.textureBlocks.push(this);\r\n\r\n        // Samplers\r\n        this._cubeSamplerName = state._getFreeVariableName(this.name + \"CubeSampler\");\r\n        state.samplers.push(this._cubeSamplerName);\r\n\r\n        this._2DSamplerName = state._getFreeVariableName(this.name + \"2DSampler\");\r\n        state.samplers.push(this._2DSamplerName);\r\n\r\n        state._samplerDeclaration += `#ifdef ${this._define3DName}\\r\\n`;\r\n        state._samplerDeclaration += `uniform samplerCube ${this._cubeSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#else\\r\\n`;\r\n        state._samplerDeclaration += `uniform sampler2D ${this._2DSamplerName};\\r\\n`;\r\n        state._samplerDeclaration += `#endif\\r\\n`;\r\n\r\n        // Fragment\r\n        state.sharedData.blocksWithDefines.push(this);\r\n        state.sharedData.bindableBlocks.push(this);\r\n\r\n        const comments = `//${this.name}`;\r\n        state._emitFunction(\"ReciprocalPI\", \"#define RECIPROCAL_PI2 0.15915494\", \"\");\r\n        state._emitFunctionFromInclude(\"helperFunctions\", comments);\r\n        state._emitFunctionFromInclude(\"reflectionFunction\", comments, {\r\n            replaceStrings: [{ search: /vec3 computeReflectionCoords/g, replace: \"void DUMMYFUNC\" }],\r\n        });\r\n\r\n        this._reflectionColorName = state._getFreeVariableName(\"reflectionColor\");\r\n        this._reflectionVectorName = state._getFreeVariableName(\"reflectionUVW\");\r\n        this._reflectionCoordsName = state._getFreeVariableName(\"reflectionCoords\");\r\n\r\n        this._reflectionPositionName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionPositionName, \"vec3\");\r\n\r\n        this._reflectionSizeName = state._getFreeVariableName(\"vReflectionPosition\");\r\n        state._emitUniformFromString(this._reflectionSizeName, \"vec3\");\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection coords code for the fragment code path\r\n     * @param worldNormalVarName name of the world normal variable\r\n     * @param worldPos name of the world position variable. If not provided, will use the world position connected to this block\r\n     * @param onlyReflectionVector if true, generates code only for the reflection vector computation, not for the reflection coordinates\r\n     * @param doNotEmitInvertZ if true, does not emit the invertZ code\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionCoords(worldNormalVarName: string, worldPos?: string, onlyReflectionVector = false, doNotEmitInvertZ = false): string {\r\n        if (!worldPos) {\r\n            worldPos = this.generateOnlyFragmentCode ? this._worldPositionNameInFragmentOnlyMode : `v_${this.worldPosition.associatedVariableName}`;\r\n        }\r\n        const reflectionMatrix = this._reflectionMatrixName;\r\n        const direction = `normalize(${this._directionWName})`;\r\n        const positionUVW = `${this._positionUVWName}`;\r\n        const vEyePosition = `${this.cameraPosition.associatedVariableName}`;\r\n        const view = `${this.view.associatedVariableName}`;\r\n\r\n        worldNormalVarName += \".xyz\";\r\n\r\n        let code = `\r\n            #ifdef ${this._defineMirroredEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeMirroredFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularFixedName}\r\n                vec3 ${this._reflectionVectorName} = computeFixedEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${direction});\r\n            #endif\r\n\r\n            #ifdef ${this._defineEquirectangularName}\r\n                vec3 ${this._reflectionVectorName} = computeEquirectangularCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSphericalName}\r\n                vec3 ${this._reflectionVectorName} = computeSphericalCoords(${worldPos}, ${worldNormalVarName}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._definePlanarName}\r\n                vec3 ${this._reflectionVectorName} = computePlanarCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineCubicName}\r\n                #ifdef ${this._defineLocalCubicName}\r\n                    vec3 ${this._reflectionVectorName} = computeCubicLocalCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix}, ${this._reflectionSizeName}, ${this._reflectionPositionName});\r\n                #else\r\n                vec3 ${this._reflectionVectorName} = computeCubicCoords(${worldPos}, ${worldNormalVarName}, ${vEyePosition}.xyz, ${reflectionMatrix});\r\n                #endif\r\n            #endif\r\n\r\n            #ifdef ${this._defineProjectionName}\r\n                vec3 ${this._reflectionVectorName} = computeProjectionCoords(${worldPos}, ${view}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineSkyboxName}\r\n                vec3 ${this._reflectionVectorName} = computeSkyBoxCoords(${positionUVW}, ${reflectionMatrix});\r\n            #endif\r\n\r\n            #ifdef ${this._defineExplicitName}\r\n                vec3 ${this._reflectionVectorName} = vec3(0, 0, 0);\r\n            #endif\\r\\n`;\r\n\r\n        if (!doNotEmitInvertZ) {\r\n            code += `#ifdef ${this._defineOppositeZ}\r\n                ${this._reflectionVectorName}.z *= -1.0;\r\n            #endif\\r\\n`;\r\n        }\r\n\r\n        if (!onlyReflectionVector) {\r\n            code += `\r\n                #ifdef ${this._define3DName}\r\n                    vec3 ${this._reflectionCoordsName} = ${this._reflectionVectorName};\r\n                #else\r\n                    vec2 ${this._reflectionCoordsName} = ${this._reflectionVectorName}.xy;\r\n                    #ifdef ${this._defineProjectionName}\r\n                        ${this._reflectionCoordsName} /= ${this._reflectionVectorName}.z;\r\n                    #endif\r\n                    ${this._reflectionCoordsName}.y = 1.0 - ${this._reflectionCoordsName}.y;\r\n                #endif\\r\\n`;\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the reflection color code for the fragment code path\r\n     * @param lodVarName name of the lod variable\r\n     * @param swizzleLookupTexture swizzle to use for the final color variable\r\n     * @returns the shader code\r\n     */\r\n    public handleFragmentSideCodeReflectionColor(lodVarName?: string, swizzleLookupTexture = \".rgb\"): string {\r\n        const colorType = \"vec\" + (swizzleLookupTexture.length === 0 ? \"4\" : swizzleLookupTexture.length - 1);\r\n\r\n        let code = `${colorType} ${this._reflectionColorName};\r\n            #ifdef ${this._define3DName}\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = textureCubeLodEXT(${this._cubeSamplerName}, ${this._reflectionVectorName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = textureCube(${this._cubeSamplerName}, ${this._reflectionVectorName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #else\\r\\n`;\r\n\r\n        if (lodVarName) {\r\n            code += `${this._reflectionColorName} = texture2DLodEXT(${this._2DSamplerName}, ${this._reflectionCoordsName}, ${lodVarName})${swizzleLookupTexture};\\r\\n`;\r\n        } else {\r\n            code += `${this._reflectionColorName} = texture2D(${this._2DSamplerName}, ${this._reflectionCoordsName})${swizzleLookupTexture};\\r\\n`;\r\n        }\r\n\r\n        code += `#endif\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Generates the code corresponding to the connected output points\r\n     * @param state node material build state\r\n     * @param varName name of the variable to output\r\n     * @returns the shader code\r\n     */\r\n    public writeOutputs(state: NodeMaterialBuildState, varName: string): string {\r\n        let code = \"\";\r\n\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            for (const output of this._outputs) {\r\n                if (output.hasEndpoints) {\r\n                    code += `${this._declareOutput(output, state)} = ${varName}.${output.name};\\r\\n`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return code;\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n        return this;\r\n    }\r\n\r\n    protected _dumpPropertiesCode() {\r\n        let codeString = super._dumpPropertiesCode();\r\n\r\n        if (!this.texture) {\r\n            return codeString;\r\n        }\r\n\r\n        if (this.texture.isCube) {\r\n            const forcedExtension = (this.texture as CubeTexture).forcedExtension;\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.CubeTexture(\"${this.texture.name}\", undefined, undefined, ${\r\n                this.texture.noMipmap\r\n            }, null, undefined, undefined, undefined, ${this.texture._prefiltered}, ${forcedExtension ? '\"' + forcedExtension + '\"' : \"null\"});\\r\\n`;\r\n        } else {\r\n            codeString += `${this._codeVariableName}.texture = new BABYLON.Texture(\"${this.texture.name}\", null);\\r\\n`;\r\n        }\r\n        codeString += `${this._codeVariableName}.texture.coordinatesMode = ${this.texture.coordinatesMode};\\r\\n`;\r\n\r\n        return codeString;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.texture && !this.texture.isRenderTarget) {\r\n            serializationObject.texture = this.texture.serialize();\r\n        }\r\n\r\n        serializationObject.generateOnlyFragmentCode = this.generateOnlyFragmentCode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.texture && !NodeMaterial.IgnoreTexturesAtLoadTime) {\r\n            rootUrl = serializationObject.texture.url.indexOf(\"data:\") === 0 ? \"\" : rootUrl;\r\n            if (serializationObject.texture.isCube) {\r\n                this.texture = CubeTexture.Parse(serializationObject.texture, scene, rootUrl);\r\n            } else {\r\n                this.texture = Texture.Parse(serializationObject.texture, scene, rootUrl);\r\n            }\r\n        }\r\n\r\n        this.generateOnlyFragmentCode = serializationObject.generateOnlyFragmentCode;\r\n\r\n        this._setTarget();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ReflectionTextureBaseBlock\", ReflectionTextureBaseBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}