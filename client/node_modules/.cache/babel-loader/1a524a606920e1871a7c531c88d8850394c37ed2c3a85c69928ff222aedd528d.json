{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture.js\";\nimport { Logger } from \"../../../Misc/logger.js\";\nimport { WebGPUEngine } from \"../../webgpuEngine.js\";\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n  if (onBeforeUnbind) {\n    onBeforeUnbind();\n  }\n  const attachments = rtWrapper._attachments;\n  const count = attachments.length;\n  if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\n    this._endRenderTargetRenderPass();\n  }\n  for (let i = 0; i < count; i++) {\n    const texture = rtWrapper.textures[i];\n    if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      this._generateMipmaps(texture);\n    }\n  }\n  this._currentRenderTarget = null;\n  this._mrtAttachments = [];\n  this._cacheRenderPipeline.setMRT([]);\n  this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n  this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\n  this._setDepthTextureFormat(this._mainRenderPassWrapper);\n  this._setColorFormat(this._mainRenderPassWrapper);\n};\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n  var _a;\n  let generateMipMaps = false;\n  let generateDepthBuffer = true;\n  let generateStencilBuffer = false;\n  let generateDepthTexture = false;\n  let depthTextureFormat = 15;\n  let textureCount = 1;\n  const defaultType = 0;\n  const defaultSamplingMode = 3;\n  const defaultUseSRGBBuffer = false;\n  let types = new Array();\n  let samplingModes = new Array();\n  let useSRGBBuffers = new Array();\n  const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n  if (options !== undefined) {\n    generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\n    generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n    generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n    generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\n    textureCount = options.textureCount || 1;\n    depthTextureFormat = (_a = options.depthTextureFormat) !== null && _a !== void 0 ? _a : 15;\n    if (options.types) {\n      types = options.types;\n    }\n    if (options.samplingModes) {\n      samplingModes = options.samplingModes;\n    }\n    if (options.useSRGBBuffers) {\n      useSRGBBuffers = options.useSRGBBuffers;\n    }\n  }\n  const width = size.width || size;\n  const height = size.height || size;\n  let depthStencilTexture = null;\n  if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\n    depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\n  }\n  const textures = [];\n  const attachments = [];\n  const defaultAttachments = [];\n  rtWrapper._generateDepthBuffer = generateDepthBuffer;\n  rtWrapper._generateStencilBuffer = generateStencilBuffer;\n  rtWrapper._attachments = attachments;\n  rtWrapper._defaultAttachments = defaultAttachments;\n  for (let i = 0; i < textureCount; i++) {\n    let samplingMode = samplingModes[i] || defaultSamplingMode;\n    let type = types[i] || defaultType;\n    const useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n    }\n    const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\n    textures.push(texture);\n    attachments.push(i + 1);\n    defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.isReady = true;\n    texture.samples = 1;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture._cachedWrapU = 0;\n    texture._cachedWrapV = 0;\n    texture._useSRGBBuffer = useSRGBBuffer;\n    this._internalTexturesCache.push(texture);\n    this._textureHelper.createGPUTextureForInternalTexture(texture);\n  }\n  if (depthStencilTexture) {\n    depthStencilTexture.incrementReferences();\n    textures.push(depthStencilTexture);\n    this._internalTexturesCache.push(depthStencilTexture);\n  }\n  rtWrapper.setTextures(textures);\n  return rtWrapper;\n};\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n  if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\n    return samples;\n  }\n  const count = rtWrapper.textures.length;\n  if (count === 0) {\n    return 1;\n  }\n  samples = Math.min(samples, this.getCaps().maxMSAASamples);\n  for (let i = 0; i < count; ++i) {\n    const texture = rtWrapper.textures[i];\n    this._textureHelper.createMSAATexture(texture, samples);\n    texture.samples = samples;\n  }\n  // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\n  // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\n  // because rtWrapper._depthStencilTexture is the same texture than the depth texture\n  if (rtWrapper._depthStencilTexture && rtWrapper._depthStencilTexture !== rtWrapper.textures[rtWrapper.textures.length - 1]) {\n    this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\n    rtWrapper._depthStencilTexture.samples = samples;\n  }\n  return samples;\n};\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n  if (attachments.length === 0 || !this._currentRenderTarget) {\n    return;\n  }\n  this._mrtAttachments = attachments;\n  if (this._currentRenderPass) {\n    // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n    this._cacheRenderPipeline.setMRTAttachments(attachments);\n  } else {\n    // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n  }\n};\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus) {\n  const result = [];\n  for (let i = 0; i < textureStatus.length; i++) {\n    if (textureStatus[i]) {\n      result.push(i + 1);\n    } else {\n      result.push(0);\n    }\n  }\n  return result;\n};\nWebGPUEngine.prototype.restoreSingleAttachment = function () {\n  // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n  // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};","map":{"version":3,"mappings":"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","names":["InternalTexture","InternalTextureSource","Logger","WebGPUEngine","prototype","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","attachments","_attachments","count","length","_currentRenderPass","_mainRenderPassWrapper","renderPass","_endRenderTargetRenderPass","i","texture","textures","generateMipMaps","isCube","_generateMipmaps","_currentRenderTarget","_mrtAttachments","_cacheRenderPipeline","setMRT","setMRTAttachments","_setDepthTextureFormat","_setColorFormat","createMultipleRenderTarget","size","options","initializeBuffers","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","textureCount","defaultType","defaultSamplingMode","defaultUseSRGBBuffer","types","Array","samplingModes","useSRGBBuffers","_createHardwareRenderTargetWrapper","undefined","width","height","depthStencilTexture","createDepthStencilTexture","defaultAttachments","_generateDepthBuffer","_generateStencilBuffer","_defaultAttachments","samplingMode","type","useSRGBBuffer","Warn","MultiRenderTarget","push","baseWidth","baseHeight","isReady","samples","_cachedWrapU","_cachedWrapV","_useSRGBBuffer","_internalTexturesCache","_textureHelper","createGPUTextureForInternalTexture","incrementReferences","setTextures","updateMultipleRenderTargetTextureSampleCount","Math","min","getCaps","maxMSAASamples","createMSAATexture","_depthStencilTexture","bindAttachments","buildTextureLayout","textureStatus","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Engines/WebGPU/Extensions/engine.multiRender.ts"],"sourcesContent":["import { InternalTexture, InternalTextureSource } from \"../../../Materials/Textures/internalTexture\";\r\nimport type { IMultiRenderTargetOptions } from \"../../../Materials/Textures/multiRenderTarget\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Constants } from \"../../constants\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport type { RenderTargetWrapper } from \"../../renderTargetWrapper\";\r\nimport { WebGPUEngine } from \"../../webgpuEngine\";\r\nimport type { WebGPURenderTargetWrapper } from \"../webgpuRenderTargetWrapper\";\r\n\r\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (\r\n    rtWrapper: RenderTargetWrapper,\r\n    disableGenerateMipMaps: boolean = false,\r\n    onBeforeUnbind?: () => void\r\n): void {\r\n    if (onBeforeUnbind) {\r\n        onBeforeUnbind();\r\n    }\r\n\r\n    const attachments = rtWrapper._attachments!;\r\n    const count = attachments.length;\r\n\r\n    if (this._currentRenderPass && this._currentRenderPass !== this._mainRenderPassWrapper.renderPass) {\r\n        this._endRenderTargetRenderPass();\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n        const texture = rtWrapper.textures![i];\r\n        if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\r\n            this._generateMipmaps(texture);\r\n        }\r\n    }\r\n\r\n    this._currentRenderTarget = null;\r\n\r\n    this._mrtAttachments = [];\r\n    this._cacheRenderPipeline.setMRT([]);\r\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\r\n    this._currentRenderPass = this._mainRenderPassWrapper.renderPass;\r\n    this._setDepthTextureFormat(this._mainRenderPassWrapper);\r\n    this._setColorFormat(this._mainRenderPassWrapper);\r\n};\r\n\r\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size: TextureSize, options: IMultiRenderTargetOptions, initializeBuffers?: boolean): RenderTargetWrapper {\r\n    let generateMipMaps = false;\r\n    let generateDepthBuffer = true;\r\n    let generateStencilBuffer = false;\r\n    let generateDepthTexture = false;\r\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\r\n    let textureCount = 1;\r\n\r\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    const defaultUseSRGBBuffer = false;\r\n\r\n    let types = new Array<number>();\r\n    let samplingModes = new Array<number>();\r\n    let useSRGBBuffers = new Array<boolean>();\r\n\r\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size) as WebGPURenderTargetWrapper;\r\n\r\n    if (options !== undefined) {\r\n        generateMipMaps = options.generateMipMaps === undefined ? false : options.generateMipMaps;\r\n        generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\r\n        generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\r\n        generateDepthTexture = options.generateDepthTexture === undefined ? false : options.generateDepthTexture;\r\n        textureCount = options.textureCount || 1;\r\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\r\n\r\n        if (options.types) {\r\n            types = options.types;\r\n        }\r\n        if (options.samplingModes) {\r\n            samplingModes = options.samplingModes;\r\n        }\r\n        if (options.useSRGBBuffers) {\r\n            useSRGBBuffers = options.useSRGBBuffers;\r\n        }\r\n    }\r\n\r\n    const width = (<{ width: number; height: number }>size).width || <number>size;\r\n    const height = (<{ width: number; height: number }>size).height || <number>size;\r\n\r\n    let depthStencilTexture = null;\r\n    if (generateDepthBuffer || generateStencilBuffer || generateDepthTexture) {\r\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat);\r\n    }\r\n\r\n    const textures: InternalTexture[] = [];\r\n    const attachments: number[] = [];\r\n    const defaultAttachments: number[] = [];\r\n\r\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n    rtWrapper._attachments = attachments;\r\n    rtWrapper._defaultAttachments = defaultAttachments;\r\n\r\n    for (let i = 0; i < textureCount; i++) {\r\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\r\n        let type = types[i] || defaultType;\r\n        const useSRGBBuffer = useSRGBBuffers[i] || defaultUseSRGBBuffer;\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, InternalTextureSource.MultiRenderTarget);\r\n\r\n        textures.push(texture);\r\n        attachments.push(i + 1);\r\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.isReady = true;\r\n        texture.samples = 1;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        this._textureHelper.createGPUTextureForInternalTexture(texture);\r\n    }\r\n\r\n    if (depthStencilTexture) {\r\n        depthStencilTexture.incrementReferences();\r\n        textures.push(depthStencilTexture);\r\n        this._internalTexturesCache.push(depthStencilTexture);\r\n    }\r\n\r\n    rtWrapper.setTextures(textures);\r\n\r\n    return rtWrapper;\r\n};\r\n\r\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper: Nullable<RenderTargetWrapper>, samples: number): number {\r\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures[0].samples === samples) {\r\n        return samples;\r\n    }\r\n\r\n    const count = rtWrapper.textures.length;\r\n\r\n    if (count === 0) {\r\n        return 1;\r\n    }\r\n\r\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\r\n\r\n    for (let i = 0; i < count; ++i) {\r\n        const texture = rtWrapper.textures[i];\r\n        this._textureHelper.createMSAATexture(texture, samples);\r\n        texture.samples = samples;\r\n    }\r\n\r\n    // Note that the last texture of textures is the depth texture if the depth texture has been generated by the MRT class and so the MSAA texture\r\n    // will be recreated for this texture by the loop above: in that case, there's no need to create the MSAA texture for rtWrapper._depthStencilTexture\r\n    // because rtWrapper._depthStencilTexture is the same texture than the depth texture\r\n    if (rtWrapper._depthStencilTexture && rtWrapper._depthStencilTexture !== rtWrapper.textures[rtWrapper.textures.length - 1]) {\r\n        this._textureHelper.createMSAATexture(rtWrapper._depthStencilTexture, samples);\r\n        rtWrapper._depthStencilTexture.samples = samples;\r\n    }\r\n\r\n    return samples;\r\n};\r\n\r\nWebGPUEngine.prototype.bindAttachments = function (attachments: number[]): void {\r\n    if (attachments.length === 0 || !this._currentRenderTarget) {\r\n        return;\r\n    }\r\n\r\n    this._mrtAttachments = attachments;\r\n    if (this._currentRenderPass) {\r\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\r\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\r\n    } else {\r\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\r\n    }\r\n};\r\n\r\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus: boolean[]): number[] {\r\n    const result = [];\r\n\r\n    for (let i = 0; i < textureStatus.length; i++) {\r\n        if (textureStatus[i]) {\r\n            result.push(i + 1);\r\n        } else {\r\n            result.push(0);\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachment = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\r\n};\r\n\r\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function (): void {\r\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}