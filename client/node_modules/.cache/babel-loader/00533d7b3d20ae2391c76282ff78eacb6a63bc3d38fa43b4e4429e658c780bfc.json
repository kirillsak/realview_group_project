{"ast":null,"code":"import { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Epsilon } from \"../../Maths/math.constants.js\";\n/**\n * A behavior that when attached to a mesh will follow a camera\n * @since 5.0.0\n */\nexport class FollowBehavior {\n  constructor() {\n    // Memory cache to avoid GC usage\n    this._tmpQuaternion = new Quaternion();\n    this._tmpVectors = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n    this._tmpMatrix = new Matrix();\n    this._tmpInvertView = new Matrix();\n    this._tmpForward = new Vector3();\n    this._tmpNodeForward = new Vector3();\n    this._tmpPosition = new Vector3();\n    this._workingPosition = new Vector3();\n    this._workingQuaternion = new Quaternion();\n    this._lastTick = -1;\n    this._recenterNextUpdate = true;\n    /**\n     * Set to false if the node should strictly follow the camera without any interpolation time\n     */\n    this.interpolatePose = true;\n    /**\n     * Rate of interpolation of position and rotation of the attached node.\n     * Higher values will give a slower interpolation.\n     */\n    this.lerpTime = 500;\n    /**\n     * If the behavior should ignore the pitch and roll of the camera.\n     */\n    this.ignoreCameraPitchAndRoll = false;\n    /**\n     * Pitch offset from camera (relative to Max Distance)\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\n     */\n    this.pitchOffset = 15;\n    /**\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\n     */\n    this.maxViewVerticalDegrees = 30;\n    /**\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\n     */\n    this.maxViewHorizontalDegrees = 30;\n    /**\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\n     */\n    this.orientToCameraDeadzoneDegrees = 60;\n    /**\n     * Option to ignore distance clamping\n     */\n    this.ignoreDistanceClamp = false;\n    /**\n     * Option to ignore angle clamping\n     */\n    this.ignoreAngleClamp = false;\n    /**\n     * Max vertical distance between the attachedNode and camera\n     */\n    this.verticalMaxDistance = 0;\n    /**\n     *  Default distance from eye to attached node, i.e. the sphere radius\n     */\n    this.defaultDistance = 0.8;\n    /**\n     *  Max distance from eye to attached node, i.e. the sphere radius\n     */\n    this.maximumDistance = 2;\n    /**\n     *  Min distance from eye to attached node, i.e. the sphere radius\n     */\n    this.minimumDistance = 0.3;\n    /**\n     * Ignore vertical movement and lock the Y position of the object.\n     */\n    this.useFixedVerticalOffset = false;\n    /**\n     * Fixed vertical position offset distance.\n     */\n    this.fixedVerticalOffset = 0;\n    /**\n     * Enables/disables the behavior\n     * @internal\n     */\n    this._enabled = true;\n  }\n  /**\n   * The camera that should be followed by this behavior\n   */\n  get followedCamera() {\n    return this._followedCamera || this._scene.activeCamera;\n  }\n  set followedCamera(camera) {\n    this._followedCamera = camera;\n  }\n  /**\n   *  The name of the behavior\n   */\n  get name() {\n    return \"Follow\";\n  }\n  /**\n   *  Initializes the behavior\n   */\n  init() {}\n  /**\n   * Attaches the follow behavior\n   * @param ownerNode The mesh that will be following once attached\n   * @param followedCamera The camera that should be followed by the node\n   */\n  attach(ownerNode, followedCamera) {\n    this._scene = ownerNode.getScene();\n    this.attachedNode = ownerNode;\n    if (followedCamera) {\n      this.followedCamera = followedCamera;\n    }\n    this._addObservables();\n  }\n  /**\n   *  Detaches the behavior from the mesh\n   */\n  detach() {\n    this.attachedNode = null;\n    this._removeObservables();\n  }\n  /**\n   * Recenters the attached node in front of the camera on the next update\n   */\n  recenter() {\n    this._recenterNextUpdate = true;\n  }\n  _angleBetweenVectorAndPlane(vector, normal) {\n    // Work on copies\n    this._tmpVectors[0].copyFrom(vector);\n    vector = this._tmpVectors[0];\n    this._tmpVectors[1].copyFrom(normal);\n    normal = this._tmpVectors[1];\n    vector.normalize();\n    normal.normalize();\n    return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\n  }\n  _length2D(vector) {\n    return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\n  }\n  _distanceClamp(currentToTarget, moveToDefault = false) {\n    let minDistance = this.minimumDistance;\n    let maxDistance = this.maximumDistance;\n    const defaultDistance = this.defaultDistance;\n    const direction = this._tmpVectors[0];\n    direction.copyFrom(currentToTarget);\n    let currentDistance = direction.length();\n    direction.normalizeFromLength(currentDistance);\n    if (this.ignoreCameraPitchAndRoll) {\n      // If we don't account for pitch offset, the casted object will float up/down as the reference\n      // gets closer to it because we will still be casting in the direction of the pitched offset.\n      // To fix this, only modify the XZ position of the object.\n      minDistance = this._length2D(direction) * minDistance;\n      maxDistance = this._length2D(direction) * maxDistance;\n      const currentDistance2D = this._length2D(currentToTarget);\n      direction.scaleInPlace(currentDistance / currentDistance2D);\n      currentDistance = currentDistance2D;\n    }\n    let clampedDistance = currentDistance;\n    if (moveToDefault) {\n      clampedDistance = defaultDistance;\n    } else {\n      clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\n    }\n    currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\n    return currentDistance !== clampedDistance;\n  }\n  _applyVerticalClamp(currentToTarget) {\n    if (this.verticalMaxDistance !== 0) {\n      currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\n    }\n  }\n  _toOrientationQuatToRef(vector, quaternion) {\n    Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\n  }\n  _applyPitchOffset(invertView) {\n    const forward = this._tmpVectors[0];\n    const right = this._tmpVectors[1];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    right.copyFromFloats(1, 0, 0);\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    forward.y = 0;\n    forward.normalize();\n    Vector3.TransformNormalToRef(right, invertView, right);\n    Quaternion.RotationAxisToRef(right, this.pitchOffset * Math.PI / 180, this._tmpQuaternion);\n    forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\n    this._toOrientationQuatToRef(forward, this._tmpQuaternion);\n    this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\n    // Since we already extracted position from the invert view matrix, we can\n    // disregard the position part of the matrix in the copy\n    invertView.copyFrom(this._tmpMatrix);\n  }\n  _angularClamp(invertView, currentToTarget) {\n    const forward = this._tmpVectors[5];\n    forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n    const right = this._tmpVectors[6];\n    right.copyFromFloats(1, 0, 0);\n    // forward and right are related to camera frame of reference\n    Vector3.TransformNormalToRef(forward, invertView, forward);\n    Vector3.TransformNormalToRef(right, invertView, right);\n    // Up is global Z\n    const up = Vector3.UpReadOnly;\n    const dist = currentToTarget.length();\n    if (dist < Epsilon) {\n      return false;\n    }\n    let angularClamped = false;\n    const rotationQuat = this._tmpQuaternion;\n    // X-axis leashing\n    if (this.ignoreCameraPitchAndRoll) {\n      const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      Quaternion.RotationAxisToRef(right, angle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n    } else {\n      const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\n      const minMaxAngle = this.maxViewVerticalDegrees * Math.PI / 180 * 0.5;\n      if (angle < -minMaxAngle) {\n        Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      } else if (angle > minMaxAngle) {\n        Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\n        currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n        angularClamped = true;\n      }\n    }\n    // Y-axis leashing\n    const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\n    const minMaxAngle = this.maxViewHorizontalDegrees * Math.PI / 180 * 0.5;\n    if (angle < -minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    } else if (angle > minMaxAngle) {\n      Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\n      currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\n      angularClamped = true;\n    }\n    return angularClamped;\n  }\n  _orientationClamp(currentToTarget, rotationQuaternion) {\n    var _a;\n    // Construct a rotation quat from up vector and target vector\n    const toFollowed = this._tmpVectors[0];\n    toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\n    const up = this._tmpVectors[1];\n    const right = this._tmpVectors[2];\n    // We use global up vector to orient the following node (global +Y)\n    up.copyFromFloats(0, 1, 0);\n    // Gram-Schmidt to create an orthonormal frame\n    Vector3.CrossToRef(toFollowed, up, right);\n    const length = right.length();\n    if (length < Epsilon) {\n      return;\n    }\n    right.normalizeFromLength(length);\n    Vector3.CrossToRef(right, toFollowed, up);\n    if ((_a = this.attachedNode) === null || _a === void 0 ? void 0 : _a.getScene().useRightHandedSystem) {\n      Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\n    } else {\n      Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\n    }\n  }\n  _passedOrientationDeadzone(currentToTarget, forward) {\n    const leashToFollow = this._tmpVectors[5];\n    leashToFollow.copyFrom(currentToTarget);\n    leashToFollow.normalize();\n    const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\n    return angle * 180 / Math.PI > this.orientToCameraDeadzoneDegrees;\n  }\n  _updateLeashing(camera) {\n    if (this.attachedNode && this._enabled) {\n      const oldParent = this.attachedNode.parent;\n      this.attachedNode.setParent(null);\n      const worldMatrix = this.attachedNode.getWorldMatrix();\n      const currentToTarget = this._workingPosition;\n      const rotationQuaternion = this._workingQuaternion;\n      const pivot = this.attachedNode.getPivotPoint();\n      const invertView = this._tmpInvertView;\n      invertView.copyFrom(camera.getViewMatrix());\n      invertView.invert();\n      Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\n      const position = this._tmpPosition;\n      position.copyFromFloats(0, 0, 0);\n      Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\n      position.scaleInPlace(-1).subtractInPlace(pivot);\n      currentToTarget.subtractInPlace(camera.globalPosition);\n      if (this.ignoreCameraPitchAndRoll) {\n        this._applyPitchOffset(invertView);\n      }\n      let angularClamped = false;\n      const forward = this._tmpForward;\n      forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(forward, invertView, forward);\n      const nodeForward = this._tmpNodeForward;\n      nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\n      Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\n      if (this._recenterNextUpdate) {\n        currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\n      } else {\n        if (this.ignoreAngleClamp) {\n          const currentDistance = currentToTarget.length();\n          currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\n        } else {\n          angularClamped = this._angularClamp(invertView, currentToTarget);\n        }\n      }\n      let distanceClamped = false;\n      if (!this.ignoreDistanceClamp) {\n        distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\n        this._applyVerticalClamp(currentToTarget);\n      }\n      if (this.useFixedVerticalOffset) {\n        currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\n      }\n      if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\n        this._orientationClamp(currentToTarget, rotationQuaternion);\n      }\n      this._workingPosition.subtractInPlace(pivot);\n      this._recenterNextUpdate = false;\n      this.attachedNode.setParent(oldParent);\n    }\n  }\n  _updateTransformToGoal(elapsed) {\n    if (!this.attachedNode || !this.followedCamera || !this._enabled) {\n      return;\n    }\n    if (!this.attachedNode.rotationQuaternion) {\n      this.attachedNode.rotationQuaternion = Quaternion.Identity();\n    }\n    const oldParent = this.attachedNode.parent;\n    this.attachedNode.setParent(null);\n    if (!this.interpolatePose) {\n      this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\n      this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\n      return;\n    }\n    // position\n    const currentDirection = new Vector3();\n    currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\n    Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\n    currentDirection.addInPlace(this.followedCamera.globalPosition);\n    this.attachedNode.position.copyFrom(currentDirection);\n    // rotation\n    const currentRotation = new Quaternion();\n    currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\n    Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\n    this.attachedNode.setParent(oldParent);\n  }\n  _addObservables() {\n    this._lastTick = Date.now();\n    this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\n      if (!this.followedCamera) {\n        return;\n      }\n      const tick = Date.now();\n      this._updateLeashing(this.followedCamera);\n      this._updateTransformToGoal(tick - this._lastTick);\n      this._lastTick = tick;\n    });\n  }\n  _removeObservables() {\n    if (this._onBeforeRender) {\n      this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["Matrix","Quaternion","Vector3","Scalar","Epsilon","FollowBehavior","constructor","followedCamera","_followedCamera","_scene","activeCamera","camera","name","init","attach","ownerNode","getScene","attachedNode","_addObservables","detach","_removeObservables","recenter","_recenterNextUpdate","_angleBetweenVectorAndPlane","vector","normal","_tmpVectors","copyFrom","normalize","Math","PI","acos","Dot","_length2D","sqrt","x","z","_distanceClamp","currentToTarget","moveToDefault","minDistance","minimumDistance","maxDistance","maximumDistance","defaultDistance","direction","currentDistance","length","normalizeFromLength","ignoreCameraPitchAndRoll","currentDistance2D","scaleInPlace","clampedDistance","Clamp","_applyVerticalClamp","verticalMaxDistance","y","_toOrientationQuatToRef","quaternion","RotationYawPitchRollToRef","atan2","_applyPitchOffset","invertView","forward","right","copyFromFloats","useRightHandedSystem","TransformNormalToRef","RotationAxisToRef","pitchOffset","_tmpQuaternion","rotateByQuaternionToRef","toRotationMatrix","_tmpMatrix","_angularClamp","up","UpReadOnly","dist","angularClamped","rotationQuat","angle","GetAngleBetweenVectorsOnPlane","minMaxAngle","maxViewVerticalDegrees","maxViewHorizontalDegrees","_orientationClamp","rotationQuaternion","toFollowed","CrossToRef","FromLookDirectionRHToRef","FromLookDirectionLHToRef","_passedOrientationDeadzone","leashToFollow","abs","orientToCameraDeadzoneDegrees","_updateLeashing","_enabled","oldParent","parent","setParent","worldMatrix","getWorldMatrix","_workingPosition","_workingQuaternion","pivot","getPivotPoint","_tmpInvertView","getViewMatrix","invert","TransformCoordinatesToRef","position","_tmpPosition","subtractInPlace","globalPosition","_tmpForward","nodeForward","_tmpNodeForward","ignoreAngleClamp","distanceClamped","ignoreDistanceClamp","useFixedVerticalOffset","fixedVerticalOffset","_updateTransformToGoal","elapsed","Identity","interpolatePose","addInPlace","currentDirection","SmoothToRef","lerpTime","currentRotation","_lastTick","Date","now","_onBeforeRender","onBeforeRenderObservable","add","tick","remove"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Behaviors/Meshes/followBehavior.ts"],"sourcesContent":["import type { Behavior } from \"../behavior\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { Matrix, Quaternion, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\n\r\n/**\r\n * A behavior that when attached to a mesh will follow a camera\r\n * @since 5.0.0\r\n */\r\nexport class FollowBehavior implements Behavior<TransformNode> {\r\n    private _scene: Scene;\r\n\r\n    // Memory cache to avoid GC usage\r\n    private _tmpQuaternion: Quaternion = new Quaternion();\r\n    private _tmpVectors: Vector3[] = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];\r\n    private _tmpMatrix: Matrix = new Matrix();\r\n    private _tmpInvertView: Matrix = new Matrix();\r\n    private _tmpForward: Vector3 = new Vector3();\r\n    private _tmpNodeForward: Vector3 = new Vector3();\r\n    private _tmpPosition: Vector3 = new Vector3();\r\n\r\n    private _followedCamera: Nullable<Camera>;\r\n    private _onBeforeRender: Nullable<Observer<Scene>>;\r\n\r\n    private _workingPosition: Vector3 = new Vector3();\r\n    private _workingQuaternion: Quaternion = new Quaternion();\r\n    private _lastTick: number = -1;\r\n    private _recenterNextUpdate = true;\r\n\r\n    /**\r\n     * Attached node of this behavior\r\n     */\r\n    public attachedNode: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Set to false if the node should strictly follow the camera without any interpolation time\r\n     */\r\n    public interpolatePose = true;\r\n\r\n    /**\r\n     * Rate of interpolation of position and rotation of the attached node.\r\n     * Higher values will give a slower interpolation.\r\n     */\r\n    public lerpTime = 500;\r\n\r\n    /**\r\n     * If the behavior should ignore the pitch and roll of the camera.\r\n     */\r\n    public ignoreCameraPitchAndRoll = false;\r\n\r\n    /**\r\n     * Pitch offset from camera (relative to Max Distance)\r\n     * Is only effective if `ignoreCameraPitchAndRoll` is set to `true`.\r\n     */\r\n    public pitchOffset = 15;\r\n\r\n    /**\r\n     * The vertical angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewVerticalDegrees = 30;\r\n\r\n    /**\r\n     * The horizontal angle from the camera forward axis to the owner will not exceed this value\r\n     */\r\n    public maxViewHorizontalDegrees = 30;\r\n    /**\r\n     * The attached node will not reorient until the angle between its forward vector and the vector to the camera is greater than this value\r\n     */\r\n    public orientToCameraDeadzoneDegrees = 60;\r\n    /**\r\n     * Option to ignore distance clamping\r\n     */\r\n    public ignoreDistanceClamp = false;\r\n    /**\r\n     * Option to ignore angle clamping\r\n     */\r\n    public ignoreAngleClamp = false;\r\n    /**\r\n     * Max vertical distance between the attachedNode and camera\r\n     */\r\n    public verticalMaxDistance = 0;\r\n    /**\r\n     *  Default distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public defaultDistance = 0.8;\r\n    /**\r\n     *  Max distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public maximumDistance = 2;\r\n    /**\r\n     *  Min distance from eye to attached node, i.e. the sphere radius\r\n     */\r\n    public minimumDistance = 0.3;\r\n\r\n    /**\r\n     * Ignore vertical movement and lock the Y position of the object.\r\n     */\r\n    public useFixedVerticalOffset = false;\r\n\r\n    /**\r\n     * Fixed vertical position offset distance.\r\n     */\r\n    public fixedVerticalOffset = 0;\r\n\r\n    /**\r\n     * Enables/disables the behavior\r\n     * @internal\r\n     */\r\n    public _enabled = true;\r\n\r\n    /**\r\n     * The camera that should be followed by this behavior\r\n     */\r\n    public get followedCamera(): Nullable<Camera> {\r\n        return this._followedCamera || this._scene.activeCamera;\r\n    }\r\n\r\n    public set followedCamera(camera: Nullable<Camera>) {\r\n        this._followedCamera = camera;\r\n    }\r\n\r\n    /**\r\n     *  The name of the behavior\r\n     */\r\n    public get name(): string {\r\n        return \"Follow\";\r\n    }\r\n\r\n    /**\r\n     *  Initializes the behavior\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Attaches the follow behavior\r\n     * @param ownerNode The mesh that will be following once attached\r\n     * @param followedCamera The camera that should be followed by the node\r\n     */\r\n    public attach(ownerNode: TransformNode, followedCamera?: Camera): void {\r\n        this._scene = ownerNode.getScene();\r\n        this.attachedNode = ownerNode;\r\n\r\n        if (followedCamera) {\r\n            this.followedCamera = followedCamera;\r\n        }\r\n\r\n        this._addObservables();\r\n    }\r\n\r\n    /**\r\n     *  Detaches the behavior from the mesh\r\n     */\r\n    public detach(): void {\r\n        this.attachedNode = null;\r\n        this._removeObservables();\r\n    }\r\n\r\n    /**\r\n     * Recenters the attached node in front of the camera on the next update\r\n     */\r\n    public recenter() {\r\n        this._recenterNextUpdate = true;\r\n    }\r\n\r\n    private _angleBetweenVectorAndPlane(vector: Vector3, normal: Vector3) {\r\n        // Work on copies\r\n        this._tmpVectors[0].copyFrom(vector);\r\n        vector = this._tmpVectors[0];\r\n        this._tmpVectors[1].copyFrom(normal);\r\n        normal = this._tmpVectors[1];\r\n\r\n        vector.normalize();\r\n        normal.normalize();\r\n\r\n        return Math.PI / 2 - Math.acos(Vector3.Dot(vector, normal));\r\n    }\r\n\r\n    private _length2D(vector: Vector3) {\r\n        return Math.sqrt(vector.x * vector.x + vector.z * vector.z);\r\n    }\r\n\r\n    private _distanceClamp(currentToTarget: Vector3, moveToDefault: boolean = false) {\r\n        let minDistance = this.minimumDistance;\r\n        let maxDistance = this.maximumDistance;\r\n        const defaultDistance = this.defaultDistance;\r\n\r\n        const direction = this._tmpVectors[0];\r\n        direction.copyFrom(currentToTarget);\r\n        let currentDistance = direction.length();\r\n        direction.normalizeFromLength(currentDistance);\r\n\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            // If we don't account for pitch offset, the casted object will float up/down as the reference\r\n            // gets closer to it because we will still be casting in the direction of the pitched offset.\r\n            // To fix this, only modify the XZ position of the object.\r\n            minDistance = this._length2D(direction) * minDistance;\r\n            maxDistance = this._length2D(direction) * maxDistance;\r\n\r\n            const currentDistance2D = this._length2D(currentToTarget);\r\n            direction.scaleInPlace(currentDistance / currentDistance2D);\r\n            currentDistance = currentDistance2D;\r\n        }\r\n\r\n        let clampedDistance = currentDistance;\r\n\r\n        if (moveToDefault) {\r\n            clampedDistance = defaultDistance;\r\n        } else {\r\n            clampedDistance = Scalar.Clamp(currentDistance, minDistance, maxDistance);\r\n        }\r\n\r\n        currentToTarget.copyFrom(direction).scaleInPlace(clampedDistance);\r\n\r\n        return currentDistance !== clampedDistance;\r\n    }\r\n\r\n    private _applyVerticalClamp(currentToTarget: Vector3) {\r\n        if (this.verticalMaxDistance !== 0) {\r\n            currentToTarget.y = Scalar.Clamp(currentToTarget.y, -this.verticalMaxDistance, this.verticalMaxDistance);\r\n        }\r\n    }\r\n\r\n    private _toOrientationQuatToRef(vector: Vector3, quaternion: Quaternion) {\r\n        Quaternion.RotationYawPitchRollToRef(Math.atan2(vector.x, vector.z), Math.atan2(vector.y, Math.sqrt(vector.z * vector.z + vector.x * vector.x)), 0, quaternion);\r\n    }\r\n\r\n    private _applyPitchOffset(invertView: Matrix) {\r\n        const forward = this._tmpVectors[0];\r\n        const right = this._tmpVectors[1];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        right.copyFromFloats(1, 0, 0);\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        forward.y = 0;\r\n        forward.normalize();\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        Quaternion.RotationAxisToRef(right, (this.pitchOffset * Math.PI) / 180, this._tmpQuaternion);\r\n        forward.rotateByQuaternionToRef(this._tmpQuaternion, forward);\r\n        this._toOrientationQuatToRef(forward, this._tmpQuaternion);\r\n        this._tmpQuaternion.toRotationMatrix(this._tmpMatrix);\r\n\r\n        // Since we already extracted position from the invert view matrix, we can\r\n        // disregard the position part of the matrix in the copy\r\n        invertView.copyFrom(this._tmpMatrix);\r\n    }\r\n\r\n    private _angularClamp(invertView: Matrix, currentToTarget: Vector3): boolean {\r\n        const forward = this._tmpVectors[5];\r\n        forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n        const right = this._tmpVectors[6];\r\n        right.copyFromFloats(1, 0, 0);\r\n\r\n        // forward and right are related to camera frame of reference\r\n        Vector3.TransformNormalToRef(forward, invertView, forward);\r\n        Vector3.TransformNormalToRef(right, invertView, right);\r\n\r\n        // Up is global Z\r\n        const up = Vector3.UpReadOnly;\r\n\r\n        const dist = currentToTarget.length();\r\n\r\n        if (dist < Epsilon) {\r\n            return false;\r\n        }\r\n\r\n        let angularClamped = false;\r\n        const rotationQuat = this._tmpQuaternion;\r\n\r\n        // X-axis leashing\r\n        if (this.ignoreCameraPitchAndRoll) {\r\n            const angle = Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            Quaternion.RotationAxisToRef(right, angle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n        } else {\r\n            const angle = -Vector3.GetAngleBetweenVectorsOnPlane(currentToTarget, forward, right);\r\n            const minMaxAngle = ((this.maxViewVerticalDegrees * Math.PI) / 180) * 0.5;\r\n            if (angle < -minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle - minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            } else if (angle > minMaxAngle) {\r\n                Quaternion.RotationAxisToRef(right, -angle + minMaxAngle, rotationQuat);\r\n                currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n                angularClamped = true;\r\n            }\r\n        }\r\n\r\n        // Y-axis leashing\r\n        const angle = this._angleBetweenVectorAndPlane(currentToTarget, right) * (this._scene.useRightHandedSystem ? -1 : 1);\r\n        const minMaxAngle = ((this.maxViewHorizontalDegrees * Math.PI) / 180) * 0.5;\r\n        if (angle < -minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle - minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        } else if (angle > minMaxAngle) {\r\n            Quaternion.RotationAxisToRef(up, -angle + minMaxAngle, rotationQuat);\r\n            currentToTarget.rotateByQuaternionToRef(rotationQuat, currentToTarget);\r\n            angularClamped = true;\r\n        }\r\n\r\n        return angularClamped;\r\n    }\r\n\r\n    private _orientationClamp(currentToTarget: Vector3, rotationQuaternion: Quaternion) {\r\n        // Construct a rotation quat from up vector and target vector\r\n        const toFollowed = this._tmpVectors[0];\r\n        toFollowed.copyFrom(currentToTarget).scaleInPlace(-1).normalize();\r\n\r\n        const up = this._tmpVectors[1];\r\n        const right = this._tmpVectors[2];\r\n        // We use global up vector to orient the following node (global +Y)\r\n        up.copyFromFloats(0, 1, 0);\r\n\r\n        // Gram-Schmidt to create an orthonormal frame\r\n        Vector3.CrossToRef(toFollowed, up, right);\r\n        const length = right.length();\r\n\r\n        if (length < Epsilon) {\r\n            return;\r\n        }\r\n\r\n        right.normalizeFromLength(length);\r\n\r\n        Vector3.CrossToRef(right, toFollowed, up);\r\n        if (this.attachedNode?.getScene().useRightHandedSystem) {\r\n            Quaternion.FromLookDirectionRHToRef(toFollowed, up, rotationQuaternion);\r\n        } else {\r\n            Quaternion.FromLookDirectionLHToRef(toFollowed, up, rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    private _passedOrientationDeadzone(currentToTarget: Vector3, forward: Vector3) {\r\n        const leashToFollow = this._tmpVectors[5];\r\n        leashToFollow.copyFrom(currentToTarget);\r\n        leashToFollow.normalize();\r\n\r\n        const angle = Math.abs(Vector3.GetAngleBetweenVectorsOnPlane(forward, leashToFollow, Vector3.UpReadOnly));\r\n        return (angle * 180) / Math.PI > this.orientToCameraDeadzoneDegrees;\r\n    }\r\n\r\n    private _updateLeashing(camera: Camera) {\r\n        if (this.attachedNode && this._enabled) {\r\n            const oldParent = this.attachedNode.parent;\r\n            this.attachedNode.setParent(null);\r\n\r\n            const worldMatrix = this.attachedNode.getWorldMatrix();\r\n            const currentToTarget = this._workingPosition;\r\n            const rotationQuaternion = this._workingQuaternion;\r\n            const pivot = this.attachedNode.getPivotPoint();\r\n            const invertView = this._tmpInvertView;\r\n            invertView.copyFrom(camera.getViewMatrix());\r\n            invertView.invert();\r\n\r\n            Vector3.TransformCoordinatesToRef(pivot, worldMatrix, currentToTarget);\r\n            const position = this._tmpPosition;\r\n            position.copyFromFloats(0, 0, 0);\r\n            Vector3.TransformCoordinatesToRef(position, worldMatrix, position);\r\n            position.scaleInPlace(-1).subtractInPlace(pivot);\r\n            currentToTarget.subtractInPlace(camera.globalPosition);\r\n\r\n            if (this.ignoreCameraPitchAndRoll) {\r\n                this._applyPitchOffset(invertView);\r\n            }\r\n\r\n            let angularClamped = false;\r\n            const forward = this._tmpForward;\r\n            forward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(forward, invertView, forward);\r\n\r\n            const nodeForward = this._tmpNodeForward;\r\n            nodeForward.copyFromFloats(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n            Vector3.TransformNormalToRef(nodeForward, worldMatrix, nodeForward);\r\n\r\n            if (this._recenterNextUpdate) {\r\n                currentToTarget.copyFrom(forward).scaleInPlace(this.defaultDistance);\r\n            } else {\r\n                if (this.ignoreAngleClamp) {\r\n                    const currentDistance = currentToTarget.length();\r\n                    currentToTarget.copyFrom(forward).scaleInPlace(currentDistance);\r\n                } else {\r\n                    angularClamped = this._angularClamp(invertView, currentToTarget);\r\n                }\r\n            }\r\n\r\n            let distanceClamped = false;\r\n            if (!this.ignoreDistanceClamp) {\r\n                distanceClamped = this._distanceClamp(currentToTarget, angularClamped);\r\n                this._applyVerticalClamp(currentToTarget);\r\n            }\r\n\r\n            if (this.useFixedVerticalOffset) {\r\n                currentToTarget.y = position.y - camera.globalPosition.y + this.fixedVerticalOffset;\r\n            }\r\n\r\n            if (angularClamped || distanceClamped || this._passedOrientationDeadzone(currentToTarget, nodeForward) || this._recenterNextUpdate) {\r\n                this._orientationClamp(currentToTarget, rotationQuaternion);\r\n            }\r\n\r\n            this._workingPosition.subtractInPlace(pivot);\r\n            this._recenterNextUpdate = false;\r\n\r\n            this.attachedNode.setParent(oldParent);\r\n        }\r\n    }\r\n\r\n    private _updateTransformToGoal(elapsed: number) {\r\n        if (!this.attachedNode || !this.followedCamera || !this._enabled) {\r\n            return;\r\n        }\r\n\r\n        if (!this.attachedNode.rotationQuaternion) {\r\n            this.attachedNode.rotationQuaternion = Quaternion.Identity();\r\n        }\r\n\r\n        const oldParent = this.attachedNode.parent;\r\n        this.attachedNode.setParent(null);\r\n\r\n        if (!this.interpolatePose) {\r\n            this.attachedNode.position.copyFrom(this.followedCamera.globalPosition).addInPlace(this._workingPosition);\r\n            this.attachedNode.rotationQuaternion.copyFrom(this._workingQuaternion);\r\n            return;\r\n        }\r\n\r\n        // position\r\n        const currentDirection = new Vector3();\r\n        currentDirection.copyFrom(this.attachedNode.position).subtractInPlace(this.followedCamera.globalPosition);\r\n        Vector3.SmoothToRef(currentDirection, this._workingPosition, elapsed, this.lerpTime, currentDirection);\r\n        currentDirection.addInPlace(this.followedCamera.globalPosition);\r\n        this.attachedNode.position.copyFrom(currentDirection);\r\n\r\n        // rotation\r\n        const currentRotation = new Quaternion();\r\n        currentRotation.copyFrom(this.attachedNode.rotationQuaternion);\r\n        Quaternion.SmoothToRef(currentRotation, this._workingQuaternion, elapsed, this.lerpTime, this.attachedNode.rotationQuaternion);\r\n\r\n        this.attachedNode.setParent(oldParent);\r\n    }\r\n\r\n    private _addObservables() {\r\n        this._lastTick = Date.now();\r\n        this._onBeforeRender = this._scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.followedCamera) {\r\n                return;\r\n            }\r\n\r\n            const tick = Date.now();\r\n            this._updateLeashing(this.followedCamera);\r\n            this._updateTransformToGoal(tick - this._lastTick);\r\n            this._lastTick = tick;\r\n        });\r\n    }\r\n\r\n    private _removeObservables() {\r\n        if (this._onBeforeRender) {\r\n            this._scene.onBeforeRenderObservable.remove(this._onBeforeRender);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}