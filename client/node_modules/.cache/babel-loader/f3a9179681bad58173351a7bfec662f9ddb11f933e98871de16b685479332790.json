{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap.js\";\nimport { BaseTexture } from \"./baseTexture.js\";\nimport { Texture } from \"./texture.js\";\nimport { Tools } from \"../../Misc/tools.js\";\nimport \"../../Engines/Extensions/engine.rawTexture.js\";\nimport { LoadImage } from \"../../Misc/fileTools.js\";\n/**\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\n */\nexport class EquiRectangularCubeTexture extends BaseTexture {\n  /**\n   * Instantiates an EquiRectangularCubeTexture from the following parameters.\n   * @param url The location of the image\n   * @param scene The scene the texture will be used in\n   * @param size The cubemap desired size (the more it increases the longer the generation will be)\n   * @param noMipmap Forces to not generate the mipmap if true\n   * @param gammaSpace Specifies if the texture will be used in gamma or linear space\n   * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\n   * @param onLoad — defines a callback called when texture is loaded\n   * @param onError — defines a callback called if there is an error\n   */\n  constructor(url, scene, size, noMipmap = false, gammaSpace = true, onLoad = null, onError = null) {\n    super(scene);\n    this._onLoad = null;\n    this._onError = null;\n    if (!url) {\n      throw new Error(\"Image url is not set\");\n    }\n    this._coordinatesMode = Texture.CUBIC_MODE;\n    this.name = url;\n    this.url = url;\n    this._size = size;\n    this._noMipmap = noMipmap;\n    this.gammaSpace = gammaSpace;\n    this._onLoad = onLoad;\n    this._onError = onError;\n    this.hasAlpha = false;\n    this.isCube = true;\n    this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\n    if (!this._texture) {\n      if (!scene.useDelayedTextureLoading) {\n        this._loadImage(this._loadTexture.bind(this), this._onError);\n      } else {\n        this.delayLoadState = 4;\n      }\n    } else if (onLoad) {\n      if (this._texture.isReady) {\n        Tools.SetImmediate(() => onLoad());\n      } else {\n        this._texture.onLoadedObservable.add(onLoad);\n      }\n    }\n  }\n  /**\n   * Load the image data, by putting the image on a canvas and extracting its buffer.\n   * @param loadTextureCallback\n   * @param onError\n   */\n  _loadImage(loadTextureCallback, onError) {\n    const canvas = document.createElement(\"canvas\");\n    LoadImage(this.url, image => {\n      this._width = image.width;\n      this._height = image.height;\n      canvas.width = this._width;\n      canvas.height = this._height;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(image, 0, 0);\n      const imageData = ctx.getImageData(0, 0, image.width, image.height);\n      this._buffer = imageData.data.buffer;\n      canvas.remove();\n      loadTextureCallback();\n    }, (_, e) => {\n      if (onError) {\n        onError(`${this.getClassName()} could not be loaded`, e);\n      }\n    }, null);\n  }\n  /**\n   * Convert the image buffer into a cubemap and create a CubeTexture.\n   */\n  _loadTexture() {\n    const scene = this.getScene();\n    const callback = () => {\n      const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\n      // Extract the raw linear data.\n      const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\n      const results = [];\n      // Push each faces.\n      for (let i = 0; i < 6; i++) {\n        const dataFace = data[EquiRectangularCubeTexture._FacesMapping[i]];\n        results.push(dataFace);\n      }\n      return results;\n    };\n    if (!scene) {\n      return;\n    }\n    this._texture = scene.getEngine().createRawCubeTextureFromUrl(this.url, scene, this._size, 4, scene.getEngine().getCaps().textureFloat ? 1 : 7, this._noMipmap, callback, null, this._onLoad, this._onError);\n  }\n  /**\n   * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\n   * @param buffer The ArrayBuffer that should be converted.\n   * @returns The buffer as Float32Array.\n   */\n  _getFloat32ArrayFromArrayBuffer(buffer) {\n    const dataView = new DataView(buffer);\n    const floatImageData = new Float32Array(buffer.byteLength * 3 / 4);\n    let k = 0;\n    for (let i = 0; i < buffer.byteLength; i++) {\n      // We drop the transparency channel, because we do not need/want it\n      if ((i + 1) % 4 !== 0) {\n        floatImageData[k++] = dataView.getUint8(i) / 255;\n      }\n    }\n    return floatImageData;\n  }\n  /**\n   * Get the current class name of the texture useful for serialization or dynamic coding.\n   * @returns \"EquiRectangularCubeTexture\"\n   */\n  getClassName() {\n    return \"EquiRectangularCubeTexture\";\n  }\n  /**\n   * Create a clone of the current EquiRectangularCubeTexture and return it.\n   * @returns A clone of the current EquiRectangularCubeTexture.\n   */\n  clone() {\n    const scene = this.getScene();\n    if (!scene) {\n      return this;\n    }\n    const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\n    // Base texture\n    newTexture.level = this.level;\n    newTexture.wrapU = this.wrapU;\n    newTexture.wrapV = this.wrapV;\n    newTexture.coordinatesIndex = this.coordinatesIndex;\n    newTexture.coordinatesMode = this.coordinatesMode;\n    return newTexture;\n  }\n}\n/** The six faces of the cube. */\nEquiRectangularCubeTexture._FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];","map":{"version":3,"mappings":"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","names":["PanoramaToCubeMapTools","BaseTexture","Texture","Tools","LoadImage","EquiRectangularCubeTexture","constructor","url","scene","size","noMipmap","gammaSpace","onLoad","onError","Error","_coordinatesMode","CUBIC_MODE","name","_size","_noMipmap","_onLoad","_onError","hasAlpha","isCube","_texture","_getFromCache","undefined","useDelayedTextureLoading","_loadImage","_loadTexture","bind","delayLoadState","isReady","SetImmediate","onLoadedObservable","add","loadTextureCallback","canvas","document","createElement","image","_width","width","_height","height","ctx","getContext","drawImage","imageData","getImageData","_buffer","data","buffer","remove","_","e","getClassName","getScene","callback","_getFloat32ArrayFromArrayBuffer","ConvertPanoramaToCubemap","results","i","dataFace","_FacesMapping","push","getEngine","createRawCubeTextureFromUrl","dataView","DataView","floatImageData","Float32Array","byteLength","k","getUint8","clone","newTexture","level","wrapU","wrapV","coordinatesIndex","coordinatesMode"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Materials/Textures/equiRectangularCubeTexture.ts"],"sourcesContent":["import { PanoramaToCubeMapTools } from \"../../Misc/HighDynamicRange/panoramaToCubemap\";\r\nimport { BaseTexture } from \"./baseTexture\";\r\nimport { Texture } from \"./texture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\n\r\n/**\r\n * This represents a texture coming from an equirectangular image supported by the web browser canvas.\r\n */\r\nexport class EquiRectangularCubeTexture extends BaseTexture {\r\n    /** The six faces of the cube. */\r\n    private static _FacesMapping = [\"right\", \"left\", \"up\", \"down\", \"front\", \"back\"];\r\n\r\n    private _noMipmap: boolean;\r\n    private _onLoad: Nullable<() => void> = null;\r\n    private _onError: Nullable<() => void> = null;\r\n\r\n    /** The size of the cubemap. */\r\n    private _size: number;\r\n\r\n    /** The buffer of the image. */\r\n    private _buffer: ArrayBuffer;\r\n\r\n    /** The width of the input image. */\r\n    private _width: number;\r\n\r\n    /** The height of the input image. */\r\n    private _height: number;\r\n\r\n    /** The URL to the image. */\r\n    public url: string;\r\n\r\n    /**\r\n     * Instantiates an EquiRectangularCubeTexture from the following parameters.\r\n     * @param url The location of the image\r\n     * @param scene The scene the texture will be used in\r\n     * @param size The cubemap desired size (the more it increases the longer the generation will be)\r\n     * @param noMipmap Forces to not generate the mipmap if true\r\n     * @param gammaSpace Specifies if the texture will be used in gamma or linear space\r\n     * (the PBR material requires those textures in linear space, but the standard material would require them in Gamma space)\r\n     * @param onLoad — defines a callback called when texture is loaded\r\n     * @param onError — defines a callback called if there is an error\r\n     */\r\n    constructor(\r\n        url: string,\r\n        scene: Scene,\r\n        size: number,\r\n        noMipmap: boolean = false,\r\n        gammaSpace: boolean = true,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null\r\n    ) {\r\n        super(scene);\r\n\r\n        if (!url) {\r\n            throw new Error(\"Image url is not set\");\r\n        }\r\n\r\n        this._coordinatesMode = Texture.CUBIC_MODE;\r\n        this.name = url;\r\n        this.url = url;\r\n        this._size = size;\r\n        this._noMipmap = noMipmap;\r\n        this.gammaSpace = gammaSpace;\r\n        this._onLoad = onLoad;\r\n        this._onError = onError;\r\n\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n\r\n        this._texture = this._getFromCache(url, this._noMipmap, undefined, undefined, undefined, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene.useDelayedTextureLoading) {\r\n                this._loadImage(this._loadTexture.bind(this), this._onError);\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            }\r\n        } else if (onLoad) {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoad());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(onLoad);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load the image data, by putting the image on a canvas and extracting its buffer.\r\n     * @param loadTextureCallback\r\n     * @param onError\r\n     */\r\n    private _loadImage(loadTextureCallback: () => void, onError: Nullable<(message?: string, exception?: any) => void>): void {\r\n        const canvas = document.createElement(\"canvas\");\r\n        LoadImage(\r\n            this.url,\r\n            (image) => {\r\n                this._width = image.width;\r\n                this._height = image.height;\r\n                canvas.width = this._width;\r\n                canvas.height = this._height;\r\n\r\n                const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                const imageData = ctx.getImageData(0, 0, image.width, image.height);\r\n                this._buffer = imageData.data.buffer as ArrayBuffer;\r\n\r\n                canvas.remove();\r\n                loadTextureCallback();\r\n            },\r\n            (_, e) => {\r\n                if (onError) {\r\n                    onError(`${this.getClassName()} could not be loaded`, e);\r\n                }\r\n            },\r\n            null\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Convert the image buffer into a cubemap and create a CubeTexture.\r\n     */\r\n    private _loadTexture(): void {\r\n        const scene = this.getScene();\r\n        const callback = (): Nullable<ArrayBufferView[]> => {\r\n            const imageData = this._getFloat32ArrayFromArrayBuffer(this._buffer);\r\n\r\n            // Extract the raw linear data.\r\n            const data = PanoramaToCubeMapTools.ConvertPanoramaToCubemap(imageData, this._width, this._height, this._size);\r\n\r\n            const results = [];\r\n\r\n            // Push each faces.\r\n            for (let i = 0; i < 6; i++) {\r\n                const dataFace = (data as any)[EquiRectangularCubeTexture._FacesMapping[i]];\r\n                results.push(dataFace);\r\n            }\r\n\r\n            return results;\r\n        };\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._texture = scene\r\n            .getEngine()\r\n            .createRawCubeTextureFromUrl(\r\n                this.url,\r\n                scene,\r\n                this._size,\r\n                Constants.TEXTUREFORMAT_RGB,\r\n                scene.getEngine().getCaps().textureFloat ? Constants.TEXTURETYPE_FLOAT : Constants.TEXTURETYPE_UNSIGNED_INTEGER,\r\n                this._noMipmap,\r\n                callback,\r\n                null,\r\n                this._onLoad,\r\n                this._onError\r\n            );\r\n    }\r\n\r\n    /**\r\n     * Convert the ArrayBuffer into a Float32Array and drop the transparency channel.\r\n     * @param buffer The ArrayBuffer that should be converted.\r\n     * @returns The buffer as Float32Array.\r\n     */\r\n    private _getFloat32ArrayFromArrayBuffer(buffer: ArrayBuffer): Float32Array {\r\n        const dataView = new DataView(buffer);\r\n        const floatImageData = new Float32Array((buffer.byteLength * 3) / 4);\r\n\r\n        let k = 0;\r\n        for (let i = 0; i < buffer.byteLength; i++) {\r\n            // We drop the transparency channel, because we do not need/want it\r\n            if ((i + 1) % 4 !== 0) {\r\n                floatImageData[k++] = dataView.getUint8(i) / 255;\r\n            }\r\n        }\r\n\r\n        return floatImageData;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"EquiRectangularCubeTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"EquiRectangularCubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Create a clone of the current EquiRectangularCubeTexture and return it.\r\n     * @returns A clone of the current EquiRectangularCubeTexture.\r\n     */\r\n    public clone(): EquiRectangularCubeTexture {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const newTexture = new EquiRectangularCubeTexture(this.url, scene, this._size, this._noMipmap, this.gammaSpace);\r\n\r\n        // Base texture\r\n        newTexture.level = this.level;\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n        newTexture.coordinatesIndex = this.coordinatesIndex;\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}