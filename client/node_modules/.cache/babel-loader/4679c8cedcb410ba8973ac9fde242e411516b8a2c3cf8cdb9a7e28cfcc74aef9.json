{"ast":null,"code":"import { Scene } from \"../scene.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { HemisphericLight } from \"../Lights/hemisphericLight.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n/**\n * Renders a layer on top of an existing scene\n */\nexport class UtilityLayerRenderer {\n  /**\n   * Instantiates a UtilityLayerRenderer\n   * @param originalScene the original scene that will be rendered on top of\n   * @param handleEvents boolean indicating if the utility layer should handle events\n   */\n  constructor( /** the original scene that will be rendered on top of */\n  originalScene, handleEvents = true) {\n    this.originalScene = originalScene;\n    this._pointerCaptures = {};\n    this._lastPointerEvents = {};\n    this._sharedGizmoLight = null;\n    this._renderCamera = null;\n    /**\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\n     */\n    this.pickUtilitySceneFirst = true;\n    /**\n     *  If the utility layer should automatically be rendered on top of existing scene\n     */\n    this.shouldRender = true;\n    /**\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\n     */\n    this.onlyCheckPointerDownEvents = true;\n    /**\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\n     */\n    this.processAllEvents = false;\n    /**\n     * Set to false to disable picking\n     */\n    this.pickingEnabled = true;\n    /**\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\n     */\n    this.onPointerOutObservable = new Observable();\n    // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\n    this.utilityLayerScene = new Scene(originalScene.getEngine(), {\n      virtual: true\n    });\n    this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\n    this.utilityLayerScene._allowPostProcessClearColor = false;\n    // Deactivate post processes\n    this.utilityLayerScene.postProcessesEnabled = false;\n    // Detach controls on utility scene, events will be fired by logic below to handle picking priority\n    this.utilityLayerScene.detachControl();\n    if (handleEvents) {\n      this._originalPointerObserver = originalScene.onPrePointerObservable.add(prePointerInfo => {\n        if (!this.utilityLayerScene.activeCamera) {\n          return;\n        }\n        if (!this.pickingEnabled) {\n          return;\n        }\n        if (!this.processAllEvents) {\n          if (prePointerInfo.type !== PointerEventTypes.POINTERMOVE && prePointerInfo.type !== PointerEventTypes.POINTERUP && prePointerInfo.type !== PointerEventTypes.POINTERDOWN && prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP) {\n            return;\n          }\n        }\n        this.utilityLayerScene.pointerX = originalScene.pointerX;\n        this.utilityLayerScene.pointerY = originalScene.pointerY;\n        const pointerEvent = prePointerInfo.event;\n        if (originalScene.isPointerCaptured(pointerEvent.pointerId)) {\n          this._pointerCaptures[pointerEvent.pointerId] = false;\n          return;\n        }\n        const getNearPickDataForScene = scene => {\n          let scenePick = null;\n          if (prePointerInfo.nearInteractionPickingInfo) {\n            if (prePointerInfo.nearInteractionPickingInfo.pickedMesh.getScene() == scene) {\n              scenePick = prePointerInfo.nearInteractionPickingInfo;\n            } else {\n              scenePick = new PickingInfo();\n            }\n          } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\n            scenePick = prePointerInfo.originalPickingInfo;\n          } else {\n            let previousActiveCamera = null;\n            // If a camera is set for rendering with this layer\n            // it will also be used for the ray computation\n            // To preserve back compat and because scene.pick always use activeCamera\n            // it's substituted temporarily and a new scenePick is forced.\n            // otherwise, the ray with previously active camera is always used.\n            // It's set back to previous activeCamera after operation.\n            if (this._renderCamera) {\n              previousActiveCamera = scene._activeCamera;\n              scene._activeCamera = this._renderCamera;\n              prePointerInfo.ray = null;\n            }\n            scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\n            if (previousActiveCamera) {\n              scene._activeCamera = previousActiveCamera;\n            }\n          }\n          return scenePick;\n        };\n        const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\n        if (!prePointerInfo.ray && utilityScenePick) {\n          prePointerInfo.ray = utilityScenePick.ray;\n        }\n        // always fire the prepointer observable\n        this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\n        // allow every non pointer down event to flow to the utility layer\n        if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\n          if (!prePointerInfo.skipOnPointerObservable) {\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n          }\n          if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n            this._pointerCaptures[pointerEvent.pointerId] = false;\n          }\n          return;\n        }\n        if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\n          // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\n          if (utilityScenePick && utilityScenePick.hit) {\n            if (!prePointerInfo.skipOnPointerObservable) {\n              this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick), prePointerInfo.type);\n            }\n            prePointerInfo.skipOnPointerObservable = true;\n          }\n        } else {\n          const originalScenePick = getNearPickDataForScene(originalScene);\n          const pointerEvent = prePointerInfo.event;\n          // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\n          if (originalScenePick && utilityScenePick) {\n            // No pick in utility scene\n            if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\n              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                // We touched an utility mesh present in the main scene\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                prePointerInfo.skipOnPointerObservable = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\n                this._pointerCaptures[pointerEvent.pointerId] = true;\n              } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                  // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                  this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                  delete this._lastPointerEvents[pointerEvent.pointerId];\n                }\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n              }\n            } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\n              // We pick something in utility scene or the pick in utility is closer than the one in main scene\n              this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n              // If a previous utility layer set this, do not unset this\n              if (!prePointerInfo.skipOnPointerObservable) {\n                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\n              }\n            } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\n              // We have a pick in both scenes but main is closer than utility\n              // We touched an utility mesh present in the main scene\n              if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\n                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\n                prePointerInfo.skipOnPointerObservable = true;\n              } else {\n                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\n                  if (this._lastPointerEvents[pointerEvent.pointerId]) {\n                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\n                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\n                    delete this._lastPointerEvents[pointerEvent.pointerId];\n                  }\n                }\n                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\n              }\n            }\n            if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\n              this._pointerCaptures[pointerEvent.pointerId] = false;\n            }\n          }\n        }\n      });\n      // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\n      if (this._originalPointerObserver) {\n        originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\n      }\n    }\n    // Render directly on top of existing scene without clearing\n    this.utilityLayerScene.autoClear = false;\n    this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add(camera => {\n      // Only render when the render camera finishes rendering\n      if (this.shouldRender && camera == this.getRenderCamera()) {\n        this.render();\n      }\n    });\n    this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\n      this.dispose();\n    });\n    this._updateCamera();\n  }\n  /**\n   * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\n   * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\n   * @returns the camera that is used when rendering the utility layer\n   */\n  getRenderCamera(getRigParentIfPossible) {\n    if (this._renderCamera) {\n      return this._renderCamera;\n    } else {\n      let activeCam;\n      if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\n        activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\n      } else {\n        activeCam = this.originalScene.activeCamera;\n      }\n      if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\n        return activeCam.rigParent;\n      }\n      return activeCam;\n    }\n  }\n  /**\n   * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\n   * @param cam the camera that should be used when rendering the utility layer\n   */\n  setRenderCamera(cam) {\n    this._renderCamera = cam;\n  }\n  /**\n   * @internal\n   * Light which used by gizmos to get light shading\n   */\n  _getSharedGizmoLight() {\n    if (!this._sharedGizmoLight) {\n      this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\n      this._sharedGizmoLight.intensity = 2;\n      this._sharedGizmoLight.groundColor = Color3.Gray();\n    }\n    return this._sharedGizmoLight;\n  }\n  /**\n   * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\n   */\n  static get DefaultUtilityLayer() {\n    if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\n      return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene);\n    }\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  }\n  /**\n   * Creates an utility layer, and set it as a default utility layer\n   * @param scene associated scene\n   * @internal\n   */\n  static _CreateDefaultUtilityLayerFromScene(scene) {\n    UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\n    UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n      UtilityLayerRenderer._DefaultUtilityLayer = null;\n    });\n    return UtilityLayerRenderer._DefaultUtilityLayer;\n  }\n  /**\n   * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\n   */\n  static get DefaultKeepDepthUtilityLayer() {\n    if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene);\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\n      UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\n        UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\n      });\n    }\n    return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\n  }\n  _notifyObservers(prePointerInfo, pickInfo, pointerEvent) {\n    if (!prePointerInfo.skipOnPointerObservable) {\n      this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\n      this._lastPointerEvents[pointerEvent.pointerId] = true;\n    }\n  }\n  /**\n   * Renders the utility layers scene on top of the original scene\n   */\n  render() {\n    this._updateCamera();\n    if (this.utilityLayerScene.activeCamera) {\n      // Set the camera's scene to utility layers scene\n      const oldScene = this.utilityLayerScene.activeCamera.getScene();\n      const camera = this.utilityLayerScene.activeCamera;\n      camera._scene = this.utilityLayerScene;\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = this.utilityLayerScene;\n      }\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = this.utilityLayerScene;\n      }\n      this.utilityLayerScene.render(false);\n      // Reset camera's scene back to original\n      camera._scene = oldScene;\n      if (camera.leftCamera) {\n        camera.leftCamera._scene = oldScene;\n      }\n      if (camera.rightCamera) {\n        camera.rightCamera._scene = oldScene;\n      }\n    }\n  }\n  /**\n   * Disposes of the renderer\n   */\n  dispose() {\n    this.onPointerOutObservable.clear();\n    if (this._afterRenderObserver) {\n      this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\n    }\n    if (this._sceneDisposeObserver) {\n      this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\n    }\n    if (this._originalPointerObserver) {\n      this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\n    }\n    this.utilityLayerScene.dispose();\n  }\n  _updateCamera() {\n    this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\n    this.utilityLayerScene.activeCamera = this.getRenderCamera();\n  }\n}\n/** @internal */\nUtilityLayerRenderer._DefaultUtilityLayer = null;\n/** @internal */\nUtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;","map":{"version":3,"mappings":"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","names":["Scene","Observable","PointerInfo","PointerEventTypes","PickingInfo","EngineStore","HemisphericLight","Vector3","Color3","UtilityLayerRenderer","constructor","originalScene","handleEvents","utilityLayerScene","getEngine","virtual","useRightHandedSystem","_allowPostProcessClearColor","postProcessesEnabled","detachControl","_originalPointerObserver","onPrePointerObservable","add","prePointerInfo","activeCamera","pickingEnabled","processAllEvents","type","POINTERMOVE","POINTERUP","POINTERDOWN","POINTERDOUBLETAP","pointerX","pointerY","pointerEvent","event","isPointerCaptured","pointerId","_pointerCaptures","getNearPickDataForScene","scene","scenePick","nearInteractionPickingInfo","pickedMesh","getScene","originalPickingInfo","previousActiveCamera","_renderCamera","_activeCamera","ray","pickWithRay","pick","utilityScenePick","notifyObservers","onlyCheckPointerDownEvents","skipOnPointerObservable","onPointerObservable","autoClearDepthAndStencil","pickUtilitySceneFirst","hit","originalScenePick","distance","mainSceneTrackerPredicate","_notifyObservers","_lastPointerEvents","onPointerOutObservable","makeObserverTopPriority","autoClear","_afterRenderObserver","onAfterRenderCameraObservable","camera","shouldRender","getRenderCamera","render","_sceneDisposeObserver","onDisposeObservable","dispose","_updateCamera","getRigParentIfPossible","activeCam","activeCameras","length","isRigCamera","rigParent","setRenderCamera","cam","_getSharedGizmoLight","_sharedGizmoLight","intensity","groundColor","Gray","DefaultUtilityLayer","_DefaultUtilityLayer","_CreateDefaultUtilityLayerFromScene","LastCreatedScene","addOnce","DefaultKeepDepthUtilityLayer","_DefaultKeepDepthUtilityLayer","pickInfo","oldScene","_scene","leftCamera","rightCamera","clear","onAfterCameraRenderObservable","remove","cameraToUseForPointers"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/utilityLayerRenderer.ts"],"sourcesContent":["import type { IDisposable } from \"../scene\";\r\nimport { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { PointerInfoPre } from \"../Events/pointerEvents\";\r\nimport { PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { HemisphericLight } from \"../Lights/hemisphericLight\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport type { IPointerEvent } from \"../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Renders a layer on top of an existing scene\r\n */\r\nexport class UtilityLayerRenderer implements IDisposable {\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _lastPointerEvents: { [pointerId: number]: boolean } = {};\r\n    /** @internal */\r\n    public static _DefaultUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    /** @internal */\r\n    public static _DefaultKeepDepthUtilityLayer: Nullable<UtilityLayerRenderer> = null;\r\n    private _sharedGizmoLight: Nullable<HemisphericLight> = null;\r\n\r\n    private _renderCamera: Nullable<Camera> = null;\r\n\r\n    /**\r\n     * Gets the camera that is used to render the utility layer (when not set, this will be the last active camera)\r\n     * @param getRigParentIfPossible if the current active camera is a rig camera, should its parent camera be returned\r\n     * @returns the camera that is used when rendering the utility layer\r\n     */\r\n    public getRenderCamera(getRigParentIfPossible?: boolean) {\r\n        if (this._renderCamera) {\r\n            return this._renderCamera;\r\n        } else {\r\n            let activeCam: Camera;\r\n            if (this.originalScene.activeCameras && this.originalScene.activeCameras.length > 1) {\r\n                activeCam = this.originalScene.activeCameras[this.originalScene.activeCameras.length - 1];\r\n            } else {\r\n                activeCam = <Camera>this.originalScene.activeCamera!;\r\n            }\r\n\r\n            if (getRigParentIfPossible && activeCam && activeCam.isRigCamera) {\r\n                return activeCam.rigParent!;\r\n            }\r\n            return activeCam;\r\n        }\r\n    }\r\n    /**\r\n     * Sets the camera that should be used when rendering the utility layer (If set to null the last active camera will be used)\r\n     * @param cam the camera that should be used when rendering the utility layer\r\n     */\r\n    public setRenderCamera(cam: Nullable<Camera>) {\r\n        this._renderCamera = cam;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Light which used by gizmos to get light shading\r\n     */\r\n    public _getSharedGizmoLight(): HemisphericLight {\r\n        if (!this._sharedGizmoLight) {\r\n            this._sharedGizmoLight = new HemisphericLight(\"shared gizmo light\", new Vector3(0, 1, 0), this.utilityLayerScene);\r\n            this._sharedGizmoLight.intensity = 2;\r\n            this._sharedGizmoLight.groundColor = Color3.Gray();\r\n        }\r\n        return this._sharedGizmoLight;\r\n    }\r\n\r\n    /**\r\n     * If the picking should be done on the utility layer prior to the actual scene (Default: true)\r\n     */\r\n    public pickUtilitySceneFirst = true;\r\n    /**\r\n     * A shared utility layer that can be used to overlay objects into a scene (Depth map of the previous scene is cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultUtilityLayer == null) {\r\n            return UtilityLayerRenderer._CreateDefaultUtilityLayerFromScene(EngineStore.LastCreatedScene!);\r\n        }\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * Creates an utility layer, and set it as a default utility layer\r\n     * @param scene associated scene\r\n     * @internal\r\n     */\r\n    public static _CreateDefaultUtilityLayerFromScene(scene: Scene): UtilityLayerRenderer {\r\n        UtilityLayerRenderer._DefaultUtilityLayer = new UtilityLayerRenderer(scene);\r\n        UtilityLayerRenderer._DefaultUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n            UtilityLayerRenderer._DefaultUtilityLayer = null;\r\n        });\r\n\r\n        return UtilityLayerRenderer._DefaultUtilityLayer;\r\n    }\r\n    /**\r\n     * A shared utility layer that can be used to embed objects into a scene (Depth map of the previous scene is not cleared before drawing on top of it)\r\n     */\r\n    public static get DefaultKeepDepthUtilityLayer(): UtilityLayerRenderer {\r\n        if (UtilityLayerRenderer._DefaultKeepDepthUtilityLayer == null) {\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = new UtilityLayerRenderer(EngineStore.LastCreatedScene!);\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.utilityLayerScene.autoClearDepthAndStencil = false;\r\n            UtilityLayerRenderer._DefaultKeepDepthUtilityLayer.originalScene.onDisposeObservable.addOnce(() => {\r\n                UtilityLayerRenderer._DefaultKeepDepthUtilityLayer = null;\r\n            });\r\n        }\r\n        return UtilityLayerRenderer._DefaultKeepDepthUtilityLayer;\r\n    }\r\n\r\n    /**\r\n     * The scene that is rendered on top of the original scene\r\n     */\r\n    public utilityLayerScene: Scene;\r\n\r\n    /**\r\n     *  If the utility layer should automatically be rendered on top of existing scene\r\n     */\r\n    public shouldRender: boolean = true;\r\n    /**\r\n     * If set to true, only pointer down onPointerObservable events will be blocked when picking is occluded by original scene\r\n     */\r\n    public onlyCheckPointerDownEvents = true;\r\n\r\n    /**\r\n     * If set to false, only pointerUp, pointerDown and pointerMove will be sent to the utilityLayerScene (false by default)\r\n     */\r\n    public processAllEvents = false;\r\n\r\n    /**\r\n     * Set to false to disable picking\r\n     */\r\n    public pickingEnabled = true;\r\n\r\n    /**\r\n     * Observable raised when the pointer moves from the utility layer scene to the main scene\r\n     */\r\n    public onPointerOutObservable = new Observable<number>();\r\n\r\n    /** Gets or sets a predicate that will be used to indicate utility meshes present in the main scene */\r\n    public mainSceneTrackerPredicate: (mesh: Nullable<AbstractMesh>) => boolean;\r\n\r\n    private _afterRenderObserver: Nullable<Observer<Camera>>;\r\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\r\n    private _originalPointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    /**\r\n     * Instantiates a UtilityLayerRenderer\r\n     * @param originalScene the original scene that will be rendered on top of\r\n     * @param handleEvents boolean indicating if the utility layer should handle events\r\n     */\r\n    constructor(\r\n        /** the original scene that will be rendered on top of */\r\n        public originalScene: Scene,\r\n        handleEvents: boolean = true\r\n    ) {\r\n        // Create scene which will be rendered in the foreground and remove it from being referenced by engine to avoid interfering with existing app\r\n        this.utilityLayerScene = new Scene(originalScene.getEngine(), { virtual: true });\r\n        this.utilityLayerScene.useRightHandedSystem = originalScene.useRightHandedSystem;\r\n        this.utilityLayerScene._allowPostProcessClearColor = false;\r\n\r\n        // Deactivate post processes\r\n        this.utilityLayerScene.postProcessesEnabled = false;\r\n\r\n        // Detach controls on utility scene, events will be fired by logic below to handle picking priority\r\n        this.utilityLayerScene.detachControl();\r\n\r\n        if (handleEvents) {\r\n            this._originalPointerObserver = originalScene.onPrePointerObservable.add((prePointerInfo) => {\r\n                if (!this.utilityLayerScene.activeCamera) {\r\n                    return;\r\n                }\r\n                if (!this.pickingEnabled) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.processAllEvents) {\r\n                    if (\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERMOVE &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERUP &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOWN &&\r\n                        prePointerInfo.type !== PointerEventTypes.POINTERDOUBLETAP\r\n                    ) {\r\n                        return;\r\n                    }\r\n                }\r\n                this.utilityLayerScene.pointerX = originalScene.pointerX;\r\n                this.utilityLayerScene.pointerY = originalScene.pointerY;\r\n                const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n                if (originalScene!.isPointerCaptured(pointerEvent.pointerId)) {\r\n                    this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    return;\r\n                }\r\n\r\n                const getNearPickDataForScene = (scene: Scene) => {\r\n                    let scenePick = null;\r\n\r\n                    if (prePointerInfo.nearInteractionPickingInfo) {\r\n                        if (prePointerInfo.nearInteractionPickingInfo.pickedMesh!.getScene() == scene) {\r\n                            scenePick = prePointerInfo.nearInteractionPickingInfo;\r\n                        } else {\r\n                            scenePick = new PickingInfo();\r\n                        }\r\n                    } else if (scene !== this.utilityLayerScene && prePointerInfo.originalPickingInfo) {\r\n                        scenePick = prePointerInfo.originalPickingInfo;\r\n                    } else {\r\n                        let previousActiveCamera: Nullable<Camera> = null;\r\n                        // If a camera is set for rendering with this layer\r\n                        // it will also be used for the ray computation\r\n                        // To preserve back compat and because scene.pick always use activeCamera\r\n                        // it's substituted temporarily and a new scenePick is forced.\r\n                        // otherwise, the ray with previously active camera is always used.\r\n                        // It's set back to previous activeCamera after operation.\r\n                        if (this._renderCamera) {\r\n                            previousActiveCamera = scene._activeCamera;\r\n                            scene._activeCamera = this._renderCamera;\r\n                            prePointerInfo.ray = null;\r\n                        }\r\n                        scenePick = prePointerInfo.ray ? scene.pickWithRay(prePointerInfo.ray) : scene.pick(originalScene.pointerX, originalScene.pointerY);\r\n                        if (previousActiveCamera) {\r\n                            scene._activeCamera = previousActiveCamera;\r\n                        }\r\n                    }\r\n\r\n                    return scenePick;\r\n                };\r\n\r\n                const utilityScenePick = getNearPickDataForScene(this.utilityLayerScene);\r\n\r\n                if (!prePointerInfo.ray && utilityScenePick) {\r\n                    prePointerInfo.ray = utilityScenePick.ray;\r\n                }\r\n\r\n                // always fire the prepointer observable\r\n                this.utilityLayerScene.onPrePointerObservable.notifyObservers(prePointerInfo);\r\n\r\n                // allow every non pointer down event to flow to the utility layer\r\n                if (this.onlyCheckPointerDownEvents && prePointerInfo.type != PointerEventTypes.POINTERDOWN) {\r\n                    if (!prePointerInfo.skipOnPointerObservable) {\r\n                        this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                            new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                            prePointerInfo.type\r\n                        );\r\n                    }\r\n                    if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                        this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (this.utilityLayerScene.autoClearDepthAndStencil || this.pickUtilitySceneFirst) {\r\n                    // If this layer is an overlay, check if this layer was hit and if so, skip pointer events for the main scene\r\n                    if (utilityScenePick && utilityScenePick.hit) {\r\n                        if (!prePointerInfo.skipOnPointerObservable) {\r\n                            this.utilityLayerScene.onPointerObservable.notifyObservers(\r\n                                new PointerInfo(prePointerInfo.type, prePointerInfo.event, utilityScenePick),\r\n                                prePointerInfo.type\r\n                            );\r\n                        }\r\n                        prePointerInfo.skipOnPointerObservable = true;\r\n                    }\r\n                } else {\r\n                    const originalScenePick = getNearPickDataForScene(originalScene);\r\n                    const pointerEvent = <IPointerEvent>prePointerInfo.event;\r\n\r\n                    // If the layer can be occluded by the original scene, only fire pointer events to the first layer that hit they ray\r\n                    if (originalScenePick && utilityScenePick) {\r\n                        // No pick in utility scene\r\n                        if (utilityScenePick.distance === 0 && originalScenePick.pickedMesh) {\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                // We touched an utility mesh present in the main scene\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERDOWN) {\r\n                                this._pointerCaptures[pointerEvent.pointerId] = true;\r\n                            } else if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                    // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                    this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                    delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && (utilityScenePick.distance < originalScenePick.distance || originalScenePick.distance === 0)) {\r\n                            // We pick something in utility scene or the pick in utility is closer than the one in main scene\r\n                            this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            // If a previous utility layer set this, do not unset this\r\n                            if (!prePointerInfo.skipOnPointerObservable) {\r\n                                prePointerInfo.skipOnPointerObservable = utilityScenePick.distance > 0;\r\n                            }\r\n                        } else if (!this._pointerCaptures[pointerEvent.pointerId] && utilityScenePick.distance >= originalScenePick.distance) {\r\n                            // We have a pick in both scenes but main is closer than utility\r\n\r\n                            // We touched an utility mesh present in the main scene\r\n                            if (this.mainSceneTrackerPredicate && this.mainSceneTrackerPredicate(originalScenePick.pickedMesh)) {\r\n                                this._notifyObservers(prePointerInfo, originalScenePick, pointerEvent);\r\n                                prePointerInfo.skipOnPointerObservable = true;\r\n                            } else {\r\n                                if (prePointerInfo.type === PointerEventTypes.POINTERMOVE || prePointerInfo.type === PointerEventTypes.POINTERUP) {\r\n                                    if (this._lastPointerEvents[pointerEvent.pointerId]) {\r\n                                        // We need to send a last pointerup to the utilityLayerScene to make sure animations can complete\r\n                                        this.onPointerOutObservable.notifyObservers(pointerEvent.pointerId);\r\n                                        delete this._lastPointerEvents[pointerEvent.pointerId];\r\n                                    }\r\n                                }\r\n                                this._notifyObservers(prePointerInfo, utilityScenePick, pointerEvent);\r\n                            }\r\n                        }\r\n\r\n                        if (prePointerInfo.type === PointerEventTypes.POINTERUP && this._pointerCaptures[pointerEvent.pointerId]) {\r\n                            this._pointerCaptures[pointerEvent.pointerId] = false;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            // As a newly added utility layer will be rendered over the screen last, it's pointer events should be processed first\r\n            if (this._originalPointerObserver) {\r\n                originalScene.onPrePointerObservable.makeObserverTopPriority(this._originalPointerObserver);\r\n            }\r\n        }\r\n\r\n        // Render directly on top of existing scene without clearing\r\n        this.utilityLayerScene.autoClear = false;\r\n\r\n        this._afterRenderObserver = this.originalScene.onAfterRenderCameraObservable.add((camera) => {\r\n            // Only render when the render camera finishes rendering\r\n            if (this.shouldRender && camera == this.getRenderCamera()) {\r\n                this.render();\r\n            }\r\n        });\r\n\r\n        this._sceneDisposeObserver = this.originalScene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._updateCamera();\r\n    }\r\n\r\n    private _notifyObservers(prePointerInfo: PointerInfoPre, pickInfo: PickingInfo, pointerEvent: IPointerEvent) {\r\n        if (!prePointerInfo.skipOnPointerObservable) {\r\n            this.utilityLayerScene.onPointerObservable.notifyObservers(new PointerInfo(prePointerInfo.type, prePointerInfo.event, pickInfo), prePointerInfo.type);\r\n            this._lastPointerEvents[pointerEvent.pointerId] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the utility layers scene on top of the original scene\r\n     */\r\n    public render() {\r\n        this._updateCamera();\r\n        if (this.utilityLayerScene.activeCamera) {\r\n            // Set the camera's scene to utility layers scene\r\n            const oldScene = this.utilityLayerScene.activeCamera.getScene();\r\n            const camera = this.utilityLayerScene.activeCamera;\r\n            camera._scene = this.utilityLayerScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = this.utilityLayerScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = this.utilityLayerScene;\r\n            }\r\n\r\n            this.utilityLayerScene.render(false);\r\n\r\n            // Reset camera's scene back to original\r\n            camera._scene = oldScene;\r\n            if (camera.leftCamera) {\r\n                camera.leftCamera._scene = oldScene;\r\n            }\r\n            if (camera.rightCamera) {\r\n                camera.rightCamera._scene = oldScene;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the renderer\r\n     */\r\n    public dispose() {\r\n        this.onPointerOutObservable.clear();\r\n\r\n        if (this._afterRenderObserver) {\r\n            this.originalScene.onAfterCameraRenderObservable.remove(this._afterRenderObserver);\r\n        }\r\n        if (this._sceneDisposeObserver) {\r\n            this.originalScene.onDisposeObservable.remove(this._sceneDisposeObserver);\r\n        }\r\n        if (this._originalPointerObserver) {\r\n            this.originalScene.onPrePointerObservable.remove(this._originalPointerObserver);\r\n        }\r\n        this.utilityLayerScene.dispose();\r\n    }\r\n\r\n    private _updateCamera() {\r\n        this.utilityLayerScene.cameraToUseForPointers = this.getRenderCamera();\r\n        this.utilityLayerScene.activeCamera = this.getRenderCamera();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}