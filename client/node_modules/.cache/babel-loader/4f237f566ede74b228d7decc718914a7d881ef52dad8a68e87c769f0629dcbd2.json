{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Camera } from \"../Cameras/camera.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { EffectLayer } from \"./effectLayer.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData, scene, container, rootUrl) => {\n  if (parsedData.effectLayers) {\n    if (!container.effectLayers) {\n      container.effectLayers = new Array();\n    }\n    for (let index = 0; index < parsedData.effectLayers.length; index++) {\n      const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\n      container.effectLayers.push(effectLayer);\n    }\n  }\n});\nAbstractScene.prototype.removeEffectLayer = function (toRemove) {\n  const index = this.effectLayers.indexOf(toRemove);\n  if (index !== -1) {\n    this.effectLayers.splice(index, 1);\n  }\n  return index;\n};\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer) {\n  this.effectLayers.push(newEffectLayer);\n};\n/**\n * Defines the layer scene component responsible to manage any effect layers\n * in a given scene.\n */\nexport class EffectLayerSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_EFFECTLAYER;\n    this._renderEffects = false;\n    this._needStencil = false;\n    this._previousStencilState = false;\n    this.scene = scene || EngineStore.LastCreatedScene;\n    if (!this.scene) {\n      return;\n    }\n    this._engine = this.scene.getEngine();\n    this.scene.effectLayers = new Array();\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {\n    this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\n    this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\n    this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\n    this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\n    this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    const layers = this.scene.effectLayers;\n    for (const effectLayer of layers) {\n      effectLayer._rebuild();\n    }\n  }\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    // Effect layers\n    serializationObject.effectLayers = [];\n    const layers = this.scene.effectLayers;\n    for (const effectLayer of layers) {\n      if (effectLayer.serialize) {\n        serializationObject.effectLayers.push(effectLayer.serialize());\n      }\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   * @param container the container holding the elements\n   */\n  addFromContainer(container) {\n    if (!container.effectLayers) {\n      return;\n    }\n    container.effectLayers.forEach(o => {\n      this.scene.addEffectLayer(o);\n    });\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   * @param container contains the elements to remove\n   * @param dispose if the removed element should be disposed (default: false)\n   */\n  removeFromContainer(container, dispose) {\n    if (!container.effectLayers) {\n      return;\n    }\n    container.effectLayers.forEach(o => {\n      this.scene.removeEffectLayer(o);\n      if (dispose) {\n        o.dispose();\n      }\n    });\n  }\n  /**\n   * Disposes the component and the associated resources.\n   */\n  dispose() {\n    const layers = this.scene.effectLayers;\n    while (layers.length) {\n      layers[0].dispose();\n    }\n  }\n  _isReadyForMesh(mesh, hardwareInstancedRendering) {\n    const currentRenderPassId = this._engine.currentRenderPassId;\n    const layers = this.scene.effectLayers;\n    for (const layer of layers) {\n      if (!layer.hasMesh(mesh)) {\n        continue;\n      }\n      const renderTarget = layer._mainTexture;\n      this._engine.currentRenderPassId = renderTarget.renderPassId;\n      for (const subMesh of mesh.subMeshes) {\n        if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\n          this._engine.currentRenderPassId = currentRenderPassId;\n          return false;\n        }\n      }\n    }\n    this._engine.currentRenderPassId = currentRenderPassId;\n    return true;\n  }\n  _renderMainTexture(camera) {\n    this._renderEffects = false;\n    this._needStencil = false;\n    let needRebind = false;\n    const layers = this.scene.effectLayers;\n    if (layers && layers.length > 0) {\n      this._previousStencilState = this._engine.getStencilBuffer();\n      for (const effectLayer of layers) {\n        if (effectLayer.shouldRender() && (!effectLayer.camera || effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera || effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1)) {\n          this._renderEffects = true;\n          this._needStencil = this._needStencil || effectLayer.needStencil();\n          const renderTarget = effectLayer._mainTexture;\n          if (renderTarget._shouldRender()) {\n            this.scene.incrementRenderId();\n            renderTarget.render(false, false);\n            needRebind = true;\n          }\n        }\n      }\n      this.scene.incrementRenderId();\n    }\n    return needRebind;\n  }\n  _setStencil() {\n    // Activate effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(true);\n    }\n  }\n  _setStencilBack() {\n    // Restore effect Layer stencil\n    if (this._needStencil) {\n      this._engine.setStencilBuffer(this._previousStencilState);\n    }\n  }\n  _draw(renderingGroupId) {\n    if (this._renderEffects) {\n      this._engine.setDepthBuffer(false);\n      const layers = this.scene.effectLayers;\n      for (let i = 0; i < layers.length; i++) {\n        const effectLayer = layers[i];\n        if (effectLayer.renderingGroupId === renderingGroupId) {\n          if (effectLayer.shouldRender()) {\n            effectLayer.render();\n          }\n        }\n      }\n      this._engine.setDepthBuffer(true);\n    }\n  }\n  _drawCamera() {\n    if (this._renderEffects) {\n      this._draw(-1);\n    }\n  }\n  _drawRenderingGroup(index) {\n    if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\n      this._draw(index);\n    }\n  }\n}\nEffectLayer._SceneComponentInitialization = scene => {\n  let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER);\n  if (!component) {\n    component = new EffectLayerSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"mappings":"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","names":["Camera","SceneComponentConstants","EffectLayer","AbstractScene","EngineStore","AddParser","NAME_EFFECTLAYER","parsedData","scene","container","rootUrl","effectLayers","Array","index","length","effectLayer","Parse","push","prototype","removeEffectLayer","toRemove","indexOf","splice","addEffectLayer","newEffectLayer","EffectLayerSceneComponent","constructor","LastCreatedScene","_engine","getEngine","register","_isReadyForMeshStage","registerStep","STEP_ISREADYFORMESH_EFFECTLAYER","_isReadyForMesh","_cameraDrawRenderTargetStage","STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER","_renderMainTexture","_beforeCameraDrawStage","STEP_BEFORECAMERADRAW_EFFECTLAYER","_setStencil","_afterRenderingGroupDrawStage","STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW","_drawRenderingGroup","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_EFFECTLAYER","_setStencilBack","STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW","_drawCamera","rebuild","layers","_rebuild","serialize","serializationObject","addFromContainer","forEach","o","removeFromContainer","dispose","mesh","hardwareInstancedRendering","currentRenderPassId","layer","hasMesh","renderTarget","_mainTexture","renderPassId","subMesh","subMeshes","isReady","camera","_renderEffects","_needStencil","needRebind","_previousStencilState","getStencilBuffer","shouldRender","cameraRigMode","RIG_MODE_NONE","_rigCameras","needStencil","_shouldRender","incrementRenderId","render","setStencilBuffer","_draw","renderingGroupId","setDepthBuffer","i","_isInIntermediateRendering","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":"","sources":["../../../../lts/core/generated/Layers/effectLayerSceneComponent.ts"],"sourcesContent":["import { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_EFFECTLAYER, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    if (parsedData.effectLayers) {\r\n        if (!container.effectLayers) {\r\n            container.effectLayers = new Array<EffectLayer>();\r\n        }\r\n\r\n        for (let index = 0; index < parsedData.effectLayers.length; index++) {\r\n            const effectLayer = EffectLayer.Parse(parsedData.effectLayers[index], scene, rootUrl);\r\n            container.effectLayers.push(effectLayer);\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /**\r\n         * The list of effect layers (highlights/glow) added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/highlightLayer\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/glowLayer\r\n         */\r\n        effectLayers: Array<EffectLayer>;\r\n\r\n        /**\r\n         * Removes the given effect layer from this scene.\r\n         * @param toRemove defines the effect layer to remove\r\n         * @returns the index of the removed effect layer\r\n         */\r\n        removeEffectLayer(toRemove: EffectLayer): number;\r\n\r\n        /**\r\n         * Adds the given effect layer to this scene\r\n         * @param newEffectLayer defines the effect layer to add\r\n         */\r\n        addEffectLayer(newEffectLayer: EffectLayer): void;\r\n    }\r\n}\r\n\r\nAbstractScene.prototype.removeEffectLayer = function (toRemove: EffectLayer): number {\r\n    const index = this.effectLayers.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.effectLayers.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nAbstractScene.prototype.addEffectLayer = function (newEffectLayer: EffectLayer): void {\r\n    this.effectLayers.push(newEffectLayer);\r\n};\r\n\r\n/**\r\n * Defines the layer scene component responsible to manage any effect layers\r\n * in a given scene.\r\n */\r\nexport class EffectLayerSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_EFFECTLAYER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _engine: Engine;\r\n    private _renderEffects = false;\r\n    private _needStencil = false;\r\n    private _previousStencilState = false;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this.scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this.scene) {\r\n            return;\r\n        }\r\n        this._engine = this.scene.getEngine();\r\n        this.scene.effectLayers = new Array<EffectLayer>();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._isReadyForMeshStage.registerStep(SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER, this, this._isReadyForMesh);\r\n\r\n        this.scene._cameraDrawRenderTargetStage.registerStep(SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER, this, this._renderMainTexture);\r\n\r\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER, this, this._setStencil);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW, this, this._drawRenderingGroup);\r\n\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER, this, this._setStencilBack);\r\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW, this, this._drawCamera);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            effectLayer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        // Effect layers\r\n        serializationObject.effectLayers = [];\r\n\r\n        const layers = this.scene.effectLayers;\r\n        for (const effectLayer of layers) {\r\n            if (effectLayer.serialize) {\r\n                serializationObject.effectLayers.push(effectLayer.serialize());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: AbstractScene): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.addEffectLayer(o);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: AbstractScene, dispose?: boolean): void {\r\n        if (!container.effectLayers) {\r\n            return;\r\n        }\r\n        container.effectLayers.forEach((o) => {\r\n            this.scene.removeEffectLayer(o);\r\n            if (dispose) {\r\n                o.dispose();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const layers = this.scene.effectLayers;\r\n        while (layers.length) {\r\n            layers[0].dispose();\r\n        }\r\n    }\r\n\r\n    private _isReadyForMesh(mesh: AbstractMesh, hardwareInstancedRendering: boolean): boolean {\r\n        const currentRenderPassId = this._engine.currentRenderPassId;\r\n        const layers = this.scene.effectLayers;\r\n        for (const layer of layers) {\r\n            if (!layer.hasMesh(mesh)) {\r\n                continue;\r\n            }\r\n\r\n            const renderTarget = <RenderTargetTexture>(<any>layer)._mainTexture;\r\n            this._engine.currentRenderPassId = renderTarget.renderPassId;\r\n\r\n            for (const subMesh of mesh.subMeshes) {\r\n                if (!layer.isReady(subMesh, hardwareInstancedRendering)) {\r\n                    this._engine.currentRenderPassId = currentRenderPassId;\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        this._engine.currentRenderPassId = currentRenderPassId;\r\n        return true;\r\n    }\r\n\r\n    private _renderMainTexture(camera: Camera): boolean {\r\n        this._renderEffects = false;\r\n        this._needStencil = false;\r\n\r\n        let needRebind = false;\r\n\r\n        const layers = this.scene.effectLayers;\r\n        if (layers && layers.length > 0) {\r\n            this._previousStencilState = this._engine.getStencilBuffer();\r\n            for (const effectLayer of layers) {\r\n                if (\r\n                    effectLayer.shouldRender() &&\r\n                    (!effectLayer.camera ||\r\n                        (effectLayer.camera.cameraRigMode === Camera.RIG_MODE_NONE && camera === effectLayer.camera) ||\r\n                        (effectLayer.camera.cameraRigMode !== Camera.RIG_MODE_NONE && effectLayer.camera._rigCameras.indexOf(camera) > -1))\r\n                ) {\r\n                    this._renderEffects = true;\r\n                    this._needStencil = this._needStencil || effectLayer.needStencil();\r\n\r\n                    const renderTarget = <RenderTargetTexture>(<any>effectLayer)._mainTexture;\r\n                    if (renderTarget._shouldRender()) {\r\n                        this.scene.incrementRenderId();\r\n                        renderTarget.render(false, false);\r\n                        needRebind = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.scene.incrementRenderId();\r\n        }\r\n\r\n        return needRebind;\r\n    }\r\n\r\n    private _setStencil() {\r\n        // Activate effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _setStencilBack() {\r\n        // Restore effect Layer stencil\r\n        if (this._needStencil) {\r\n            this._engine.setStencilBuffer(this._previousStencilState);\r\n        }\r\n    }\r\n\r\n    private _draw(renderingGroupId: number): void {\r\n        if (this._renderEffects) {\r\n            this._engine.setDepthBuffer(false);\r\n\r\n            const layers = this.scene.effectLayers;\r\n            for (let i = 0; i < layers.length; i++) {\r\n                const effectLayer = layers[i];\r\n                if (effectLayer.renderingGroupId === renderingGroupId) {\r\n                    if (effectLayer.shouldRender()) {\r\n                        effectLayer.render();\r\n                    }\r\n                }\r\n            }\r\n            this._engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    private _drawCamera(): void {\r\n        if (this._renderEffects) {\r\n            this._draw(-1);\r\n        }\r\n    }\r\n    private _drawRenderingGroup(index: number): void {\r\n        if (!this.scene._isInIntermediateRendering() && this._renderEffects) {\r\n            this._draw(index);\r\n        }\r\n    }\r\n}\r\n\r\nEffectLayer._SceneComponentInitialization = (scene: Scene) => {\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_EFFECTLAYER) as EffectLayerSceneComponent;\r\n    if (!component) {\r\n        component = new EffectLayerSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}