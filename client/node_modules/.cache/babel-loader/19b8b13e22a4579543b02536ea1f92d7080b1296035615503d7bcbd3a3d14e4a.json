{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Tools } from \"./tools.js\";\nimport { Vector3 } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { BaseTexture } from \"../Materials/Textures/baseTexture.js\";\nimport { Scene } from \"../scene.js\";\nimport { PostProcess } from \"../PostProcesses/postProcess.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { RGBDTextureTools } from \"./rgbdTextureTools.js\";\nimport \"../Engines/Extensions/engine.renderTargetCube.js\";\nimport \"../Engines/Extensions/engine.readTexture.js\";\nimport \"../Materials/Textures/baseTexture.polynomial.js\";\nimport \"../Shaders/rgbdEncode.fragment.js\";\nimport \"../Shaders/rgbdDecode.fragment.js\";\nimport { DumpTools } from \"../Misc/dumpTools.js\";\nconst DefaultEnvironmentTextureImageType = \"image/png\";\nconst CurrentVersion = 2;\n/**\n * Magic number identifying the env file.\n */\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\n/**\n * Gets the environment info from an env file.\n * @param data The array buffer containing the .env bytes.\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n */\nexport function GetEnvInfo(data) {\n  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  let pos = 0;\n  for (let i = 0; i < MagicBytes.length; i++) {\n    if (dataView.getUint8(pos++) !== MagicBytes[i]) {\n      Logger.Error(\"Not a babylon environment map\");\n      return null;\n    }\n  }\n  // Read json manifest - collect characters up to null terminator\n  let manifestString = \"\";\n  let charCode = 0x00;\n  while (charCode = dataView.getUint8(pos++)) {\n    manifestString += String.fromCharCode(charCode);\n  }\n  let manifest = JSON.parse(manifestString);\n  manifest = normalizeEnvInfo(manifest);\n  if (manifest.specular) {\n    // Extend the header with the position of the payload.\n    manifest.specular.specularDataPosition = pos;\n    // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\n    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\n  }\n  return manifest;\n}\n/**\n * Normalizes any supported version of the environment file info to the latest version\n * @param info environment file info on any supported version\n * @returns environment file info in the latest supported version\n * @private\n */\nexport function normalizeEnvInfo(info) {\n  if (info.version > CurrentVersion) {\n    throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\n  }\n  if (info.version === 2) {\n    return info;\n  }\n  // Migrate a v1 info to v2\n  info = {\n    ...info,\n    version: 2,\n    imageType: DefaultEnvironmentTextureImageType\n  };\n  return info;\n}\n/**\n * Creates an environment texture from a loaded cube texture.\n * @param texture defines the cube texture to convert in env file\n * @param options options for the conversion process\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n * @param options.imageQuality the image quality of encoded WebP images.\n * @returns a promise containing the environment data if successful.\n */\nexport async function CreateEnvTextureAsync(texture, options = {}) {\n  var _a;\n  const internalTexture = texture.getInternalTexture();\n  if (!internalTexture) {\n    return Promise.reject(\"The cube texture is invalid.\");\n  }\n  const imageType = (_a = options.imageType) !== null && _a !== void 0 ? _a : DefaultEnvironmentTextureImageType;\n  const engine = internalTexture.getEngine();\n  if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {\n    return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\n  }\n  let textureType = 1;\n  if (!engine.getCaps().textureFloatRender) {\n    textureType = 2;\n    if (!engine.getCaps().textureHalfFloatRender) {\n      return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\n    }\n  }\n  const cubeWidth = internalTexture.width;\n  const hostingScene = new Scene(engine);\n  const specularTextures = {};\n  // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\n  engine.flushFramebuffer();\n  // Read and collect all mipmaps data from the cube.\n  const mipmapsCount = Scalar.ILog2(internalTexture.width);\n  for (let i = 0; i <= mipmapsCount; i++) {\n    const faceWidth = Math.pow(2, mipmapsCount - i);\n    // All faces of the cube.\n    for (let face = 0; face < 6; face++) {\n      let faceData = await texture.readPixels(face, i, undefined, false);\n      if (faceData && faceData.byteLength === faceData.length) {\n        const faceDataFloat = new Float32Array(faceData.byteLength * 4);\n        for (let i = 0; i < faceData.byteLength; i++) {\n          faceDataFloat[i] = faceData[i] / 255;\n          // Gamma to linear\n          faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\n        }\n        faceData = faceDataFloat;\n      }\n      const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);\n      await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\n      const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\n      const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\n      specularTextures[i * 6 + face] = imageEncodedData;\n      tempTexture.dispose();\n    }\n  }\n  // We can delete the hosting scene keeping track of all the creation objects\n  hostingScene.dispose();\n  // Creates the json header for the env texture\n  const info = {\n    version: CurrentVersion,\n    width: cubeWidth,\n    imageType,\n    irradiance: _CreateEnvTextureIrradiance(texture),\n    specular: {\n      mipmaps: [],\n      lodGenerationScale: texture.lodGenerationScale\n    }\n  };\n  // Sets the specular image data information\n  let position = 0;\n  for (let i = 0; i <= mipmapsCount; i++) {\n    for (let face = 0; face < 6; face++) {\n      const byteLength = specularTextures[i * 6 + face].byteLength;\n      info.specular.mipmaps.push({\n        length: byteLength,\n        position: position\n      });\n      position += byteLength;\n    }\n  }\n  // Encode the JSON as an array buffer\n  const infoString = JSON.stringify(info);\n  const infoBuffer = new ArrayBuffer(infoString.length + 1);\n  const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\n  for (let i = 0, strLen = infoString.length; i < strLen; i++) {\n    infoView[i] = infoString.charCodeAt(i);\n  }\n  // Ends up with a null terminator for easier parsing\n  infoView[infoString.length] = 0x00;\n  // Computes the final required size and creates the storage\n  const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\n  const finalBuffer = new ArrayBuffer(totalSize);\n  const finalBufferView = new Uint8Array(finalBuffer);\n  const dataView = new DataView(finalBuffer);\n  // Copy the magic bytes identifying the file in\n  let pos = 0;\n  for (let i = 0; i < MagicBytes.length; i++) {\n    dataView.setUint8(pos++, MagicBytes[i]);\n  }\n  // Add the json info\n  finalBufferView.set(new Uint8Array(infoBuffer), pos);\n  pos += infoBuffer.byteLength;\n  // Finally inserts the texture data\n  for (let i = 0; i <= mipmapsCount; i++) {\n    for (let face = 0; face < 6; face++) {\n      const dataBuffer = specularTextures[i * 6 + face];\n      finalBufferView.set(new Uint8Array(dataBuffer), pos);\n      pos += dataBuffer.byteLength;\n    }\n  }\n  // Voila\n  return finalBuffer;\n}\n/**\n * Creates a JSON representation of the spherical data.\n * @param texture defines the texture containing the polynomials\n * @returns the JSON representation of the spherical info\n */\nfunction _CreateEnvTextureIrradiance(texture) {\n  const polynmials = texture.sphericalPolynomial;\n  if (polynmials == null) {\n    return null;\n  }\n  return {\n    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\n    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\n    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\n    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\n    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\n    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\n    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\n    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\n    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]\n  };\n}\n/**\n * Creates the ArrayBufferViews used for initializing environment texture image data.\n * @param data the image data\n * @param info parameters that determine what views will be created for accessing the underlying buffer\n * @returns the views described by info providing access to the underlying buffer\n */\nexport function CreateImageDataArrayBufferViews(data, info) {\n  info = normalizeEnvInfo(info);\n  const specularInfo = info.specular;\n  // Double checks the enclosed info\n  let mipmapsCount = Scalar.Log2(info.width);\n  mipmapsCount = Math.round(mipmapsCount) + 1;\n  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\n    throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\n  }\n  const imageData = new Array(mipmapsCount);\n  for (let i = 0; i < mipmapsCount; i++) {\n    imageData[i] = new Array(6);\n    for (let face = 0; face < 6; face++) {\n      const imageInfo = specularInfo.mipmaps[i * 6 + face];\n      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);\n    }\n  }\n  return imageData;\n}\n/**\n * Uploads the texture info contained in the env file to the GPU.\n * @param texture defines the internal texture to upload to\n * @param data defines the data to load\n * @param info defines the texture info retrieved through the GetEnvInfo method\n * @returns a promise\n */\nexport function UploadEnvLevelsAsync(texture, data, info) {\n  info = normalizeEnvInfo(info);\n  const specularInfo = info.specular;\n  if (!specularInfo) {\n    // Nothing else parsed so far\n    return Promise.resolve();\n  }\n  texture._lodGenerationScale = specularInfo.lodGenerationScale;\n  const imageData = CreateImageDataArrayBufferViews(data, info);\n  return UploadLevelsAsync(texture, imageData, info.imageType);\n}\nfunction _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {\n  return new Promise((resolve, reject) => {\n    if (expandTexture) {\n      const tempTexture = engine.createTexture(null, true, true, null, 1, null, message => {\n        reject(message);\n      }, image);\n      rgbdPostProcess.getEffect().executeWhenCompiled(() => {\n        // Uncompress the data to a RTT\n        rgbdPostProcess.externalTextureSamplerBinding = true;\n        rgbdPostProcess.onApply = effect => {\n          effect._bindTexture(\"textureSampler\", tempTexture);\n          effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\n        };\n        if (!engine.scenes.length) {\n          return;\n        }\n        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\n        // Cleanup\n        engine.restoreDefaultFramebuffer();\n        tempTexture.dispose();\n        URL.revokeObjectURL(url);\n        resolve();\n      });\n    } else {\n      engine._uploadImageToTexture(texture, image, face, i);\n      // Upload the face to the non lod texture support\n      if (generateNonLODTextures) {\n        const lodTexture = lodTextures[i];\n        if (lodTexture) {\n          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);\n        }\n      }\n      resolve();\n    }\n  });\n}\n/**\n * Uploads the levels of image data to the GPU.\n * @param texture defines the internal texture to upload to\n * @param imageData defines the array buffer views of image data [mipmap][face]\n * @param imageType the mime type of the image data\n * @returns a promise\n */\nexport function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {\n  if (!Tools.IsExponentOfTwo(texture.width)) {\n    throw new Error(\"Texture size must be a power of two\");\n  }\n  const mipmapsCount = Scalar.ILog2(texture.width) + 1;\n  // Gets everything ready.\n  const engine = texture.getEngine();\n  let expandTexture = false;\n  let generateNonLODTextures = false;\n  let rgbdPostProcess = null;\n  let cubeRtt = null;\n  let lodTextures = null;\n  const caps = engine.getCaps();\n  texture.format = 5;\n  texture.type = 0;\n  texture.generateMipMaps = true;\n  texture._cachedAnisotropicFilteringLevel = null;\n  engine.updateTextureSamplingMode(3, texture);\n  // Add extra process if texture lod is not supported\n  if (!caps.textureLOD) {\n    expandTexture = false;\n    generateNonLODTextures = true;\n    lodTextures = {};\n  }\n  // in webgl 1 there are no ways to either render or copy lod level information for float textures.\n  else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\n    expandTexture = false;\n  }\n  // If half float available we can uncompress the texture\n  else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 2;\n  }\n  // If full float available we can uncompress the texture\n  else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n    expandTexture = true;\n    texture.type = 1;\n  }\n  // Expand the texture if possible\n  if (expandTexture) {\n    // Simply run through the decode PP\n    rgbdPostProcess = new PostProcess(\"rgbdDecode\", \"rgbdDecode\", null, null, 1, null, 3, engine, false, undefined, texture.type, undefined, null, false);\n    texture._isRGBD = false;\n    texture.invertY = false;\n    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\n      generateDepthBuffer: false,\n      generateMipMaps: true,\n      generateStencilBuffer: false,\n      samplingMode: 3,\n      type: texture.type,\n      format: 5\n    });\n  } else {\n    texture._isRGBD = true;\n    texture.invertY = true;\n    // In case of missing support, applies the same patch than DDS files.\n    if (generateNonLODTextures) {\n      const mipSlices = 3;\n      const scale = texture._lodGenerationScale;\n      const offset = texture._lodGenerationOffset;\n      for (let i = 0; i < mipSlices; i++) {\n        //compute LOD from even spacing in smoothness (matching shader calculation)\n        const smoothness = i / (mipSlices - 1);\n        const roughness = 1 - smoothness;\n        const minLODIndex = offset; // roughness = 0\n        const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\n        const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n        const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\n        const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\n        glTextureFromLod.isCube = true;\n        glTextureFromLod.invertY = true;\n        glTextureFromLod.generateMipMaps = false;\n        engine.updateTextureSamplingMode(2, glTextureFromLod);\n        // Wrap in a base texture for easy binding.\n        const lodTexture = new BaseTexture(null);\n        lodTexture._isCube = true;\n        lodTexture._texture = glTextureFromLod;\n        lodTextures[mipmapIndex] = lodTexture;\n        switch (i) {\n          case 0:\n            texture._lodTextureLow = lodTexture;\n            break;\n          case 1:\n            texture._lodTextureMid = lodTexture;\n            break;\n          case 2:\n            texture._lodTextureHigh = lodTexture;\n            break;\n        }\n      }\n    }\n  }\n  const promises = [];\n  // All mipmaps up to provided number of images\n  for (let i = 0; i < imageData.length; i++) {\n    // All faces\n    for (let face = 0; face < 6; face++) {\n      // Constructs an image element from image data\n      const bytes = imageData[i][face];\n      const blob = new Blob([bytes], {\n        type: imageType\n      });\n      const url = URL.createObjectURL(blob);\n      let promise;\n      if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\n        promise = engine.createImageBitmap(blob, {\n          premultiplyAlpha: \"none\"\n        }).then(img => {\n          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\n        });\n      } else {\n        const image = new Image();\n        image.src = url;\n        // Enqueue promise to upload to the texture.\n        promise = new Promise((resolve, reject) => {\n          image.onload = () => {\n            _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(() => resolve()).catch(reason => {\n              reject(reason);\n            });\n          };\n          image.onerror = error => {\n            reject(error);\n          };\n        });\n      }\n      promises.push(promise);\n    }\n  }\n  // Fill remaining mipmaps with black textures.\n  if (imageData.length < mipmapsCount) {\n    let data;\n    const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\n    const dataLength = size * size * 4;\n    switch (texture.type) {\n      case 0:\n        {\n          data = new Uint8Array(dataLength);\n          break;\n        }\n      case 2:\n        {\n          data = new Uint16Array(dataLength);\n          break;\n        }\n      case 1:\n        {\n          data = new Float32Array(dataLength);\n          break;\n        }\n    }\n    for (let i = imageData.length; i < mipmapsCount; i++) {\n      for (let face = 0; face < 6; face++) {\n        engine._uploadArrayBufferViewToTexture(texture, data, face, i);\n      }\n    }\n  }\n  // Once all done, finishes the cleanup and return\n  return Promise.all(promises).then(() => {\n    // Release temp RTT.\n    if (cubeRtt) {\n      engine._releaseTexture(texture);\n      cubeRtt._swapAndDie(texture);\n    }\n    // Release temp Post Process.\n    if (rgbdPostProcess) {\n      rgbdPostProcess.dispose();\n    }\n    // Flag internal texture as ready in case they are in use.\n    if (generateNonLODTextures) {\n      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\n        texture._lodTextureHigh._texture.isReady = true;\n      }\n      if (texture._lodTextureMid && texture._lodTextureMid._texture) {\n        texture._lodTextureMid._texture.isReady = true;\n      }\n      if (texture._lodTextureLow && texture._lodTextureLow._texture) {\n        texture._lodTextureLow._texture.isReady = true;\n      }\n    }\n  });\n}\n/**\n * Uploads spherical polynomials information to the texture.\n * @param texture defines the texture we are trying to upload the information to\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\n */\nexport function UploadEnvSpherical(texture, info) {\n  info = normalizeEnvInfo(info);\n  const irradianceInfo = info.irradiance;\n  if (!irradianceInfo) {\n    return;\n  }\n  const sp = new SphericalPolynomial();\n  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\n  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\n  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\n  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\n  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\n  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\n  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\n  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\n  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\n  texture._sphericalPolynomial = sp;\n}\n/**\n * @internal\n */\nexport function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {\n  const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);\n  const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\n  internalTexture.onRebuildCallback = _internalTexture => {\n    return {\n      proxy: proxyPromise,\n      isReady: true,\n      isAsync: true\n    };\n  };\n  internalTexture._source = InternalTextureSource.CubeRawRGBD;\n  internalTexture._bufferViewArrayArray = data;\n  internalTexture._lodGenerationScale = lodScale;\n  internalTexture._lodGenerationOffset = lodOffset;\n  internalTexture._sphericalPolynomial = sphericalPolynomial;\n  return UploadLevelsAsync(internalTexture, data).then(() => {\n    internalTexture.isReady = true;\n    return internalTexture;\n  });\n}\n/**\n * Sets of helpers addressing the serialization and deserialization of environment texture\n * stored in a BabylonJS env file.\n * Those files are usually stored as .env files.\n */\nexport const EnvironmentTextureTools = {\n  /**\n   * Gets the environment info from an env file.\n   * @param data The array buffer containing the .env bytes.\n   * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\n   */\n  GetEnvInfo,\n  /**\n   * Creates an environment texture from a loaded cube texture.\n   * @param texture defines the cube texture to convert in env file\n   * @param options options for the conversion process\n   * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\n   * @param options.imageQuality the image quality of encoded WebP images.\n   * @returns a promise containing the environment data if successful.\n   */\n  CreateEnvTextureAsync,\n  /**\n   * Creates the ArrayBufferViews used for initializing environment texture image data.\n   * @param data the image data\n   * @param info parameters that determine what views will be created for accessing the underlying buffer\n   * @returns the views described by info providing access to the underlying buffer\n   */\n  CreateImageDataArrayBufferViews,\n  /**\n   * Uploads the texture info contained in the env file to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param data defines the data to load\n   * @param info defines the texture info retrieved through the GetEnvInfo method\n   * @returns a promise\n   */\n  UploadEnvLevelsAsync,\n  /**\n   * Uploads the levels of image data to the GPU.\n   * @param texture defines the internal texture to upload to\n   * @param imageData defines the array buffer views of image data [mipmap][face]\n   * @param imageType the mime type of the image data\n   * @returns a promise\n   */\n  UploadLevelsAsync,\n  /**\n   * Uploads spherical polynomials information to the texture.\n   * @param texture defines the texture we are trying to upload the information to\n   * @param info defines the environment texture info retrieved through the GetEnvInfo method\n   */\n  UploadEnvSpherical\n};","map":{"version":3,"mappings":"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","names":["Tools","Vector3","Scalar","SphericalPolynomial","InternalTexture","InternalTextureSource","BaseTexture","Scene","PostProcess","Logger","RGBDTextureTools","DumpTools","DefaultEnvironmentTextureImageType","CurrentVersion","MagicBytes","GetEnvInfo","data","dataView","DataView","buffer","byteOffset","byteLength","pos","i","length","getUint8","Error","manifestString","charCode","String","fromCharCode","manifest","JSON","parse","normalizeEnvInfo","specular","specularDataPosition","lodGenerationScale","info","version","imageType","CreateEnvTextureAsync","texture","options","internalTexture","getInternalTexture","Promise","reject","engine","getEngine","textureType","getCaps","textureFloatRender","textureHalfFloatRender","cubeWidth","width","hostingScene","specularTextures","flushFramebuffer","mipmapsCount","ILog2","faceWidth","Math","pow","face","faceData","readPixels","undefined","faceDataFloat","Float32Array","tempTexture","createRawTexture","EncodeTextureToRGBD","rgbdEncodedData","_readTexturePixels","imageEncodedData","DumpDataAsync","imageQuality","dispose","irradiance","_CreateEnvTextureIrradiance","mipmaps","position","push","infoString","stringify","infoBuffer","ArrayBuffer","infoView","Uint8Array","strLen","charCodeAt","totalSize","finalBuffer","finalBufferView","setUint8","set","dataBuffer","polynmials","sphericalPolynomial","x","y","z","xx","yy","zz","yz","zx","xy","CreateImageDataArrayBufferViews","specularInfo","Log2","round","imageData","Array","imageInfo","UploadEnvLevelsAsync","resolve","_lodGenerationScale","UploadLevelsAsync","_OnImageReadyAsync","image","expandTexture","rgbdPostProcess","url","generateNonLODTextures","lodTextures","cubeRtt","createTexture","message","getEffect","executeWhenCompiled","externalTextureSamplerBinding","onApply","effect","_bindTexture","setFloat2","_features","needsInvertingBitmap","ImageBitmap","scenes","postProcessManager","directRender","restoreDefaultFramebuffer","URL","revokeObjectURL","_uploadImageToTexture","lodTexture","_texture","IsExponentOfTwo","caps","format","type","generateMipMaps","_cachedAnisotropicFilteringLevel","updateTextureSamplingMode","textureLOD","supportRenderAndCopyToLodForFloatTextures","textureHalfFloatLinearFiltering","textureFloatLinearFiltering","_isRGBD","invertY","createRenderTargetCubeTexture","generateDepthBuffer","generateStencilBuffer","samplingMode","mipSlices","scale","offset","_lodGenerationOffset","smoothness","roughness","minLODIndex","maxLODIndex","lodIndex","mipmapIndex","min","max","glTextureFromLod","Temp","isCube","_isCube","_lodTextureLow","_lodTextureMid","_lodTextureHigh","promises","bytes","blob","Blob","createObjectURL","promise","Image","forceBitmapOverHTMLImageElement","createImageBitmap","premultiplyAlpha","then","img","src","onload","catch","reason","onerror","error","size","dataLength","Uint16Array","_uploadArrayBufferViewToTexture","all","_releaseTexture","_swapAndDie","isReady","UploadEnvSpherical","irradianceInfo","sp","FromArrayToRef","_sphericalPolynomial","_UpdateRGBDAsync","lodScale","lodOffset","proxy","createRawCubeTexture","_compression","proxyPromise","onRebuildCallback","_internalTexture","isAsync","_source","CubeRawRGBD","_bufferViewArrayArray","EnvironmentTextureTools"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/environmentTextureTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\n\r\nimport \"../Engines/Extensions/engine.renderTargetCube\";\r\nimport \"../Engines/Extensions/engine.readTexture\";\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nimport \"../Shaders/rgbdEncode.fragment\";\r\nimport \"../Shaders/rgbdDecode.fragment\";\r\nimport { DumpTools } from \"../Misc/dumpTools\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: any;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: any;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    specularDataPosition?: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    if (manifest.specular) {\r\n        // Extend the header with the position of the payload.\r\n        manifest.specular.specularDataPosition = pos;\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n * @param options.imageQuality the image quality of encoded WebP images.\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    const engine = internalTexture.getEngine() as Engine;\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        return Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            return Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = Scalar.ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            let faceData = await texture.readPixels(face, i, undefined, false);\r\n            if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n                const faceDataFloat = new Float32Array(faceData!.byteLength * 4);\r\n                for (let i = 0; i < faceData.byteLength; i++) {\r\n                    faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n                    // Gamma to linear\r\n                    faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n                }\r\n                faceData = faceDataFloat;\r\n            }\r\n\r\n            const tempTexture = engine.createRawTexture(\r\n                faceData,\r\n                faceWidth,\r\n                faceWidth,\r\n                Constants.TEXTUREFORMAT_RGBA,\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                textureType\r\n            );\r\n\r\n            await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n            const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);\r\n\r\n            const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, undefined, false, true, options.imageQuality);\r\n\r\n            specularTextures[i * 6 + face] = imageEncodedData as ArrayBuffer;\r\n\r\n            tempTexture.dispose();\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: _CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction _CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    } as any;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Scalar.Log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve();\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n    return UploadLevelsAsync(texture, imageData, info.imageType);\r\n}\r\n\r\nfunction _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess!.getEffect().executeWhenCompiled(() => {\r\n                // Uncompress the data to a RTT\r\n                rgbdPostProcess!.externalTextureSamplerBinding = true;\r\n                rgbdPostProcess!.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", tempTexture);\r\n                    effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                };\r\n\r\n                if (!engine.scenes.length) {\r\n                    return;\r\n                }\r\n\r\n                engine.scenes[0].postProcessManager.directRender([rgbdPostProcess!], cubeRtt, true, face, i);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                tempTexture.dispose();\r\n                URL.revokeObjectURL(url);\r\n                resolve();\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport function UploadLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = Scalar.ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    // Add extra process if texture lod is not supported\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = true;\r\n        lodTextures = {};\r\n    }\r\n    // in webgl 1 there are no ways to either render or copy lod level information for float textures.\r\n    else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    if (expandTexture) {\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures![mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (typeof Image === \"undefined\" || engine._features.forceBitmapOverHTMLImageElement) {\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then((img) => {\r\n                    return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            .then(() => resolve())\r\n                            .catch((reason) => {\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_INT: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Once all done, finishes the cleanup and return\r\n    return Promise.all(promises).then(() => {\r\n        // Release temp RTT.\r\n        if (cubeRtt) {\r\n            engine._releaseTexture(texture);\r\n            cubeRtt._swapAndDie(texture);\r\n        }\r\n        // Release temp Post Process.\r\n        if (rgbdPostProcess) {\r\n            rgbdPostProcess.dispose();\r\n        }\r\n        // Flag internal texture as ready in case they are in use.\r\n        if (generateNonLODTextures) {\r\n            if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n                texture._lodTextureHigh._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n                texture._lodTextureMid._texture.isReady = true;\r\n            }\r\n            if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n                texture._lodTextureLow._texture.isReady = true;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    return UploadLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}