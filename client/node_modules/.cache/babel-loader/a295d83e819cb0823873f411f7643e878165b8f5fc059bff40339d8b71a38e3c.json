{"ast":null,"code":"import { EngineStore } from \"../../../Engines/engineStore.js\";\nimport { ProceduralTexture } from \"./proceduralTexture.js\";\nimport { RegisterClass } from \"../../../Misc/typeStore.js\";\nimport \"../../../Shaders/noise.fragment.js\";\n/**\n * Class used to generate noise procedural textures\n */\nexport class NoiseProceduralTexture extends ProceduralTexture {\n  /**\n   * Creates a new NoiseProceduralTexture\n   * @param name defines the name fo the texture\n   * @param size defines the size of the texture (default is 256)\n   * @param scene defines the hosting scene\n   * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\n   * @param generateMipMaps defines if mipmaps must be generated (true by default)\n   */\n  constructor(name, size = 256, scene = EngineStore.LastCreatedScene, fallbackTexture, generateMipMaps) {\n    super(name, size, \"noise\", scene, fallbackTexture, generateMipMaps);\n    /** Gets or sets the start time (default is 0) */\n    this.time = 0.0;\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\n    this.brightness = 0.2;\n    /** Defines the number of octaves to process */\n    this.octaves = 3;\n    /** Defines the level of persistence (0.8 by default) */\n    this.persistence = 0.8;\n    /** Gets or sets animation speed factor (default is 1) */\n    this.animationSpeedFactor = 1;\n    this.autoClear = false;\n    this._updateShaderUniforms();\n  }\n  _updateShaderUniforms() {\n    const scene = this.getScene();\n    if (!scene) {\n      return;\n    }\n    this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\n    this.setFloat(\"brightness\", this.brightness);\n    this.setFloat(\"persistence\", this.persistence);\n    this.setFloat(\"timeScale\", this.time);\n  }\n  _getDefines() {\n    return \"#define OCTAVES \" + (this.octaves | 0);\n  }\n  /**\n   * Generate the current state of the procedural texture\n   * @param useCameraPostProcess\n   */\n  render(useCameraPostProcess) {\n    this._updateShaderUniforms();\n    super.render(useCameraPostProcess);\n  }\n  /**\n   * Serializes this noise procedural texture\n   * @returns a serialized noise procedural texture object\n   */\n  serialize() {\n    const serializationObject = {};\n    serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\n    serializationObject.brightness = this.brightness;\n    serializationObject.octaves = this.octaves;\n    serializationObject.persistence = this.persistence;\n    serializationObject.animationSpeedFactor = this.animationSpeedFactor;\n    serializationObject.size = this.getSize().width;\n    serializationObject.generateMipMaps = this._generateMipMaps;\n    serializationObject.time = this.time;\n    return serializationObject;\n  }\n  /**\n   * Clone the texture.\n   * @returns the cloned texture\n   */\n  clone() {\n    const textureSize = this.getSize();\n    const newTexture = new NoiseProceduralTexture(this.name, textureSize.width, this.getScene(), this._fallbackTexture ? this._fallbackTexture : undefined, this._generateMipMaps);\n    // Base texture\n    newTexture.hasAlpha = this.hasAlpha;\n    newTexture.level = this.level;\n    // RenderTarget Texture\n    newTexture.coordinatesMode = this.coordinatesMode;\n    // Noise Specifics\n    newTexture.brightness = this.brightness;\n    newTexture.octaves = this.octaves;\n    newTexture.persistence = this.persistence;\n    newTexture.animationSpeedFactor = this.animationSpeedFactor;\n    newTexture.time = this.time;\n    return newTexture;\n  }\n  /**\n   * Creates a NoiseProceduralTexture from parsed noise procedural texture data\n   * @param parsedTexture defines parsed texture data\n   * @param scene defines the current scene\n   * @returns a parsed NoiseProceduralTexture\n   */\n  static Parse(parsedTexture, scene) {\n    var _a;\n    const texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\n    texture.brightness = parsedTexture.brightness;\n    texture.octaves = parsedTexture.octaves;\n    texture.persistence = parsedTexture.persistence;\n    texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\n    texture.time = (_a = parsedTexture.time) !== null && _a !== void 0 ? _a : 0;\n    return texture;\n  }\n}\nRegisterClass(\"BABYLON.NoiseProceduralTexture\", NoiseProceduralTexture);","map":{"version":3,"mappings":"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","names":["EngineStore","ProceduralTexture","RegisterClass","NoiseProceduralTexture","constructor","name","size","scene","LastCreatedScene","fallbackTexture","generateMipMaps","autoClear","_updateShaderUniforms","getScene","time","getAnimationRatio","animationSpeedFactor","setFloat","brightness","persistence","_getDefines","octaves","render","useCameraPostProcess","serialize","serializationObject","customType","getSize","width","_generateMipMaps","clone","textureSize","newTexture","_fallbackTexture","undefined","hasAlpha","level","coordinatesMode","Parse","parsedTexture","texture"],"sourceRoot":"","sources":["../../../../../../lts/core/generated/Materials/Textures/Procedurals/noiseProceduralTexture.ts"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport type { Texture } from \"../../../Materials/Textures/texture\";\r\nimport { ProceduralTexture } from \"./proceduralTexture\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\n\r\nimport \"../../../Shaders/noise.fragment\";\r\n\r\n/**\r\n * Class used to generate noise procedural textures\r\n */\r\nexport class NoiseProceduralTexture extends ProceduralTexture {\r\n    /** Gets or sets the start time (default is 0) */\r\n    public time: number = 0.0;\r\n\r\n    /** Gets or sets a value between 0 and 1 indicating the overall brightness of the texture (default is 0.2) */\r\n    public brightness = 0.2;\r\n\r\n    /** Defines the number of octaves to process */\r\n    public octaves = 3;\r\n\r\n    /** Defines the level of persistence (0.8 by default) */\r\n    public persistence = 0.8;\r\n\r\n    /** Gets or sets animation speed factor (default is 1) */\r\n    public animationSpeedFactor = 1;\r\n\r\n    /**\r\n     * Creates a new NoiseProceduralTexture\r\n     * @param name defines the name fo the texture\r\n     * @param size defines the size of the texture (default is 256)\r\n     * @param scene defines the hosting scene\r\n     * @param fallbackTexture defines the texture to use if the NoiseProceduralTexture can't be created\r\n     * @param generateMipMaps defines if mipmaps must be generated (true by default)\r\n     */\r\n    constructor(name: string, size: number = 256, scene: Nullable<Scene> = EngineStore.LastCreatedScene, fallbackTexture?: Texture, generateMipMaps?: boolean) {\r\n        super(name, size, \"noise\", scene, fallbackTexture, generateMipMaps);\r\n        this.autoClear = false;\r\n        this._updateShaderUniforms();\r\n    }\r\n\r\n    private _updateShaderUniforms() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.time += scene.getAnimationRatio() * this.animationSpeedFactor * 0.01;\r\n\r\n        this.setFloat(\"brightness\", this.brightness);\r\n        this.setFloat(\"persistence\", this.persistence);\r\n        this.setFloat(\"timeScale\", this.time);\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return \"#define OCTAVES \" + (this.octaves | 0);\r\n    }\r\n\r\n    /**\r\n     * Generate the current state of the procedural texture\r\n     * @param useCameraPostProcess\r\n     */\r\n    public render(useCameraPostProcess?: boolean) {\r\n        this._updateShaderUniforms();\r\n        super.render(useCameraPostProcess);\r\n    }\r\n\r\n    /**\r\n     * Serializes this noise procedural texture\r\n     * @returns a serialized noise procedural texture object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.customType = \"BABYLON.NoiseProceduralTexture\";\r\n\r\n        serializationObject.brightness = this.brightness;\r\n        serializationObject.octaves = this.octaves;\r\n        serializationObject.persistence = this.persistence;\r\n        serializationObject.animationSpeedFactor = this.animationSpeedFactor;\r\n        serializationObject.size = this.getSize().width;\r\n        serializationObject.generateMipMaps = this._generateMipMaps;\r\n        serializationObject.time = this.time;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): NoiseProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new NoiseProceduralTexture(\r\n            this.name,\r\n            textureSize.width,\r\n            this.getScene(),\r\n            this._fallbackTexture ? this._fallbackTexture : undefined,\r\n            this._generateMipMaps\r\n        );\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        // Noise Specifics\r\n        newTexture.brightness = this.brightness;\r\n        newTexture.octaves = this.octaves;\r\n        newTexture.persistence = this.persistence;\r\n        newTexture.animationSpeedFactor = this.animationSpeedFactor;\r\n        newTexture.time = this.time;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Creates a NoiseProceduralTexture from parsed noise procedural texture data\r\n     * @param parsedTexture defines parsed texture data\r\n     * @param scene defines the current scene\r\n     * @returns a parsed NoiseProceduralTexture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene): NoiseProceduralTexture {\r\n        const texture = new NoiseProceduralTexture(parsedTexture.name, parsedTexture.size, scene, undefined, parsedTexture.generateMipMaps);\r\n\r\n        texture.brightness = parsedTexture.brightness;\r\n        texture.octaves = parsedTexture.octaves;\r\n        texture.persistence = parsedTexture.persistence;\r\n        texture.animationSpeedFactor = parsedTexture.animationSpeedFactor;\r\n        texture.time = parsedTexture.time ?? 0;\r\n\r\n        return texture;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.NoiseProceduralTexture\", NoiseProceduralTexture);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}