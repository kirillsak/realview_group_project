{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Engine } from \"../Engines/engine.js\";\nimport { VertexBuffer } from \"../Buffers/buffer.js\";\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture.js\";\nimport { Texture } from \"../Materials/Textures/texture.js\";\nimport { DataBuffer } from \"../Buffers/dataBuffer.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { Observable } from \"../Misc/observable.js\";\nimport { CreateImageDataArrayBufferViews, GetEnvInfo, UploadEnvSpherical } from \"../Misc/environmentTextureTools.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { ThinEngine } from \"./thinEngine.js\";\nimport { EngineStore } from \"./engineStore.js\";\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner.js\";\nimport { WebGL2ShaderProcessor } from \"../Engines/WebGL/webGL2ShaderProcessors.js\";\nimport { NativeDataStream } from \"./Native/nativeDataStream.js\";\nimport { RuntimeError, ErrorCodes } from \"../Misc/error.js\";\nimport { NativePipelineContext } from \"./Native/nativePipelineContext.js\";\nimport { NativeRenderTargetWrapper } from \"./Native/nativeRenderTargetWrapper.js\";\nimport { NativeHardwareTexture } from \"./Native/nativeHardwareTexture.js\";\nconst onNativeObjectInitialized = new Observable();\nif (typeof self !== \"undefined\" && !Object.prototype.hasOwnProperty.call(self, \"_native\")) {\n  let __native;\n  Object.defineProperty(self, \"_native\", {\n    get: () => __native,\n    set: value => {\n      __native = value;\n      if (__native) {\n        onNativeObjectInitialized.notifyObservers(__native);\n      }\n    }\n  });\n}\n/**\n * Returns _native only after it has been defined by BabylonNative.\n * @internal\n */\nexport function AcquireNativeObjectAsync() {\n  return new Promise(resolve => {\n    if (typeof _native === \"undefined\") {\n      onNativeObjectInitialized.addOnce(nativeObject => resolve(nativeObject));\n    } else {\n      resolve(_native);\n    }\n  });\n}\n/**\n * Registers a constructor on the _native object. See NativeXRFrame for an example.\n * @internal\n */\nexport async function RegisterNativeTypeAsync(typeName, constructor) {\n  (await AcquireNativeObjectAsync())[typeName] = constructor;\n}\n/**\n * Container for accessors for natively-stored mesh data buffers.\n */\nclass NativeDataBuffer extends DataBuffer {}\n/** @internal */\nclass CommandBufferEncoder {\n  constructor(_engine) {\n    this._engine = _engine;\n    this._pending = new Array();\n    this._isCommandBufferScopeActive = false;\n    this._commandStream = NativeEngine._createNativeDataStream();\n    this._engine.setCommandDataStream(this._commandStream);\n  }\n  beginCommandScope() {\n    if (this._isCommandBufferScopeActive) {\n      throw new Error(\"Command scope already active.\");\n    }\n    this._isCommandBufferScopeActive = true;\n  }\n  endCommandScope() {\n    if (!this._isCommandBufferScopeActive) {\n      throw new Error(\"Command scope is not active.\");\n    }\n    this._isCommandBufferScopeActive = false;\n    this._submit();\n  }\n  startEncodingCommand(command) {\n    this._commandStream.writeNativeData(command);\n  }\n  encodeCommandArgAsUInt32(commandArg) {\n    this._commandStream.writeUint32(commandArg);\n  }\n  encodeCommandArgAsUInt32s(commandArg) {\n    this._commandStream.writeUint32Array(commandArg);\n  }\n  encodeCommandArgAsInt32(commandArg) {\n    this._commandStream.writeInt32(commandArg);\n  }\n  encodeCommandArgAsInt32s(commandArg) {\n    this._commandStream.writeInt32Array(commandArg);\n  }\n  encodeCommandArgAsFloat32(commandArg) {\n    this._commandStream.writeFloat32(commandArg);\n  }\n  encodeCommandArgAsFloat32s(commandArg) {\n    this._commandStream.writeFloat32Array(commandArg);\n  }\n  encodeCommandArgAsNativeData(commandArg) {\n    this._commandStream.writeNativeData(commandArg);\n    this._pending.push(commandArg);\n  }\n  finishEncodingCommand() {\n    if (!this._isCommandBufferScopeActive) {\n      this._submit();\n    }\n  }\n  _submit() {\n    this._engine.submitCommands();\n    this._pending.length = 0;\n  }\n}\n/** @internal */\nexport class NativeEngine extends Engine {\n  constructor(options = {}) {\n    super(null, false, undefined, options.adaptToDeviceRatio);\n    this._engine = new _native.Engine();\n    this._camera = _native.Camera ? new _native.Camera() : null;\n    this._commandBufferEncoder = new CommandBufferEncoder(this._engine);\n    this._boundBuffersVertexArray = null;\n    this._currentDepthTest = _native.Engine.DEPTH_TEST_LEQUAL;\n    this._stencilTest = false;\n    this._stencilMask = 255;\n    this._stencilFunc = 519;\n    this._stencilFuncRef = 0;\n    this._stencilFuncMask = 255;\n    this._stencilOpStencilFail = 7680;\n    this._stencilOpDepthFail = 7680;\n    this._stencilOpStencilDepthPass = 7681;\n    this._zOffset = 0;\n    this._zOffsetUnits = 0;\n    this._depthWrite = true;\n    if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {\n      throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);\n    }\n    this._webGLVersion = 2;\n    this.disableUniformBuffers = true;\n    this._shaderPlatformName = \"NATIVE\";\n    // TODO: Initialize this more correctly based on the hardware capabilities.\n    // Init caps\n    this._caps = {\n      maxTexturesImageUnits: 16,\n      maxVertexTextureImageUnits: 16,\n      maxCombinedTexturesImageUnits: 32,\n      maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,\n      maxCubemapTextureSize: 512,\n      maxRenderTextureSize: 512,\n      maxVertexAttribs: 16,\n      maxVaryingVectors: 16,\n      maxFragmentUniformVectors: 16,\n      maxVertexUniformVectors: 16,\n      standardDerivatives: true,\n      astc: null,\n      pvrtc: null,\n      etc1: null,\n      etc2: null,\n      bptc: null,\n      maxAnisotropy: 16,\n      uintIndices: true,\n      fragmentDepthSupported: false,\n      highPrecisionShaderSupported: true,\n      colorBufferFloat: false,\n      textureFloat: true,\n      textureFloatLinearFiltering: false,\n      textureFloatRender: false,\n      textureHalfFloat: false,\n      textureHalfFloatLinearFiltering: false,\n      textureHalfFloatRender: false,\n      textureLOD: true,\n      drawBuffersExtension: false,\n      depthTextureExtension: false,\n      vertexArrayObject: true,\n      instancedArrays: true,\n      supportOcclusionQuery: false,\n      canUseTimestampForTimerQuery: false,\n      blendMinMax: false,\n      maxMSAASamples: 1,\n      canUseGLInstanceID: true,\n      canUseGLVertexID: true,\n      supportComputeShaders: false,\n      supportSRGBBuffers: true,\n      supportTransformFeedbacks: false,\n      textureMaxLevel: false,\n      texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS\n    };\n    this._features = {\n      forceBitmapOverHTMLImageElement: false,\n      supportRenderAndCopyToLodForFloatTextures: false,\n      supportDepthStencilTexture: false,\n      supportShadowSamplers: false,\n      uniformBufferHardCheckMatrix: false,\n      allowTexturePrefiltering: false,\n      trackUbosInFrame: false,\n      checkUbosContentBeforeUpload: false,\n      supportCSM: false,\n      basisNeedsPOT: false,\n      support3DTextures: false,\n      needTypeSuffixInShaderConstants: false,\n      supportMSAA: false,\n      supportSSAO2: false,\n      supportExtendedTextureFormats: false,\n      supportSwitchCaseInShader: false,\n      supportSyncTextureRead: false,\n      needsInvertingBitmap: true,\n      useUBOBindingCache: true,\n      needShaderCodeInlining: true,\n      needToAlwaysBindUniformBuffers: false,\n      supportRenderPasses: true,\n      supportSpriteInstancing: false,\n      _collectUbosUpdatedInFrame: false\n    };\n    Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\n    Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\n      Tools.LoadFile(scriptUrl, data => {\n        Function(data).apply(null);\n        if (onSuccess) {\n          onSuccess();\n        }\n      }, undefined, undefined, false, (request, exception) => {\n        if (onError) {\n          onError(\"LoadScript Error\", exception);\n        }\n      });\n    };\n    // Wrappers\n    if (typeof URL === \"undefined\") {\n      window.URL = {\n        createObjectURL: function () {},\n        revokeObjectURL: function () {}\n      };\n    }\n    if (typeof Blob === \"undefined\") {\n      window.Blob = function (v) {\n        return v;\n      };\n    }\n    // polyfill for Chakra\n    if (!Array.prototype.flat) {\n      Object.defineProperty(Array.prototype, \"flat\", {\n        configurable: true,\n        value: function flat() {\n          const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\n          return depth ? Array.prototype.reduce.call(this, function (acc, cur) {\n            if (Array.isArray(cur)) {\n              acc.push.apply(acc, flat.call(cur, depth - 1));\n            } else {\n              acc.push(cur);\n            }\n            return acc;\n          }, []) : Array.prototype.slice.call(this);\n        },\n        writable: true\n      });\n    }\n    // Currently we do not fully configure the ThinEngine on construction of NativeEngine.\n    // Setup resolution scaling based on display settings.\n    const devicePixelRatio = window ? window.devicePixelRatio || 1.0 : 1.0;\n    this._hardwareScalingLevel = options.adaptToDeviceRatio ? devicePixelRatio : 1.0;\n    this.resize();\n    const currentDepthFunction = this.getDepthFunction();\n    if (currentDepthFunction) {\n      this.setDepthFunction(currentDepthFunction);\n    }\n    // Shader processor\n    this._shaderProcessor = new WebGL2ShaderProcessor();\n    this.onNewSceneAddedObservable.add(scene => {\n      const originalRender = scene.render;\n      scene.render = (...args) => {\n        this._commandBufferEncoder.beginCommandScope();\n        originalRender.apply(scene, args);\n        this._commandBufferEncoder.endCommandScope();\n      };\n    });\n  }\n  getHardwareScalingLevel() {\n    return this._engine.getHardwareScalingLevel();\n  }\n  setHardwareScalingLevel(level) {\n    this._engine.setHardwareScalingLevel(level);\n  }\n  dispose() {\n    super.dispose();\n    if (this._boundBuffersVertexArray) {\n      this._deleteVertexArray(this._boundBuffersVertexArray);\n    }\n    this._engine.dispose();\n  }\n  /** @internal */\n  static _createNativeDataStream() {\n    return new NativeDataStream();\n  }\n  /**\n   * Can be used to override the current requestAnimationFrame requester.\n   * @internal\n   */\n  _queueNewFrame(bindedRenderFunction, requester) {\n    // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\n    if (requester.requestAnimationFrame && requester !== window) {\n      requester.requestAnimationFrame(bindedRenderFunction);\n    } else {\n      this._engine.requestAnimationFrame(bindedRenderFunction);\n    }\n    return 0;\n  }\n  /**\n   * Override default engine behavior.\n   * @param framebuffer\n   */\n  _bindUnboundFramebuffer(framebuffer) {\n    if (this._currentFramebuffer !== framebuffer) {\n      if (this._currentFramebuffer) {\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer);\n        this._commandBufferEncoder.finishEncodingCommand();\n      }\n      if (framebuffer) {\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);\n        this._commandBufferEncoder.finishEncodingCommand();\n      }\n      this._currentFramebuffer = framebuffer;\n    }\n  }\n  /**\n   * Gets host document\n   * @returns the host document object\n   */\n  getHostDocument() {\n    return null;\n  }\n  clear(color, backBuffer, depth, stencil = false) {\n    if (this.useReverseDepthBuffer) {\n      throw new Error(\"reverse depth buffer is not currently implemented\");\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(1);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  createIndexBuffer(indices, updateable) {\n    const data = this._normalizeIndexData(indices);\n    const buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    if (data.byteLength) {\n      buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable !== null && updateable !== void 0 ? updateable : false);\n    }\n    return buffer;\n  }\n  createVertexBuffer(vertices, updateable) {\n    const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);\n    const buffer = new NativeDataBuffer();\n    buffer.references = 1;\n    if (data.byteLength) {\n      buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable !== null && updateable !== void 0 ? updateable : false);\n    }\n    return buffer;\n  }\n  _recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    if (indexBuffer) {\n      this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer);\n    }\n    const attributes = effect.getAttributesNames();\n    for (let index = 0; index < attributes.length; index++) {\n      const location = effect.getAttributeLocation(index);\n      if (location >= 0) {\n        const kind = attributes[index];\n        let vertexBuffer = null;\n        if (overrideVertexBuffers) {\n          vertexBuffer = overrideVertexBuffers[kind];\n        }\n        if (!vertexBuffer) {\n          vertexBuffer = vertexBuffers[kind];\n        }\n        if (vertexBuffer) {\n          const buffer = vertexBuffer.getBuffer();\n          if (buffer && buffer.nativeVertexBuffer) {\n            this._engine.recordVertexBuffer(vertexArray, buffer.nativeVertexBuffer, location, vertexBuffer.byteOffset, vertexBuffer.byteStride, vertexBuffer.getSize(), this._getNativeAttribType(vertexBuffer.type), vertexBuffer.normalized, vertexBuffer.getInstanceDivisor());\n          }\n        }\n      }\n    }\n  }\n  bindBuffers(vertexBuffers, indexBuffer, effect) {\n    if (this._boundBuffersVertexArray) {\n      this._deleteVertexArray(this._boundBuffersVertexArray);\n    }\n    this._boundBuffersVertexArray = this._engine.createVertexArray();\n    this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\n    this.bindVertexArrayObject(this._boundBuffersVertexArray);\n  }\n  recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {\n    const vertexArray = this._engine.createVertexArray();\n    this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);\n    return vertexArray;\n  }\n  _deleteVertexArray(vertexArray) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  bindVertexArrayObject(vertexArray) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  releaseVertexArrayObject(vertexArray) {\n    this._deleteVertexArray(vertexArray);\n  }\n  getAttributes(pipelineContext, attributesNames) {\n    const nativePipelineContext = pipelineContext;\n    return this._engine.getAttributes(nativePipelineContext.nativeProgram, attributesNames);\n  }\n  /**\n   * Draw a list of indexed primitives\n   * @param fillMode defines the primitive to use\n   * @param indexStart defines the starting index\n   * @param indexCount defines the number of index to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false);\n    // TODO: Make this implementation more robust like core Engine version.\n    // Render\n    //var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;\n    //var mult = this._uintIndicesCurrentlySet ? 4 : 2;\n    // if (instancesCount) {\n    //     this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);\n    // } else {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\n    this._commandBufferEncoder.finishEncodingCommand();\n    // }\n  }\n  /**\n   * Draw a list of unindexed primitives\n   * @param fillMode defines the primitive to use\n   * @param verticesStart defines the index of first vertex to draw\n   * @param verticesCount defines the count of vertices to draw\n   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\n   */\n  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {\n    // Apply states\n    this._drawCalls.addCount(1, false);\n    // TODO: Make this implementation more robust like core Engine version.\n    // if (instancesCount) {\n    //     this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);\n    // } else {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\n    this._commandBufferEncoder.finishEncodingCommand();\n    // }\n  }\n\n  createPipelineContext() {\n    return new NativePipelineContext(this);\n  }\n  createMaterialContext() {\n    return undefined;\n  }\n  createDrawContext() {\n    return undefined;\n  }\n  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, _rawVertexSourceCode, _rawFragmentSourceCode, _rebuildRebind, defines) {\n    const nativePipelineContext = pipelineContext;\n    if (createAsRaw) {\n      nativePipelineContext.nativeProgram = this.createRawShaderProgram();\n    } else {\n      nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);\n    }\n  }\n  /**\n   * @internal\n   */\n  _isRenderingStateCompiled(pipelineContext) {\n    // TODO: support async shader compilcation\n    return true;\n  }\n  /**\n   * @internal\n   */\n  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {\n    // TODO: support async shader compilcation\n    action();\n  }\n  createRawShaderProgram() {\n    throw new Error(\"Not Supported\");\n  }\n  createShaderProgram(_pipelineContext, vertexCode, fragmentCode, defines) {\n    this.onBeforeShaderCompilationObservable.notifyObservers(this);\n    const vertexInliner = new ShaderCodeInliner(vertexCode);\n    vertexInliner.processCode();\n    vertexCode = vertexInliner.code;\n    const fragmentInliner = new ShaderCodeInliner(fragmentCode);\n    fragmentInliner.processCode();\n    fragmentCode = fragmentInliner.code;\n    vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\n    fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\n    const program = this._engine.createProgram(vertexCode, fragmentCode);\n    this.onAfterShaderCompilationObservable.notifyObservers(this);\n    return program;\n  }\n  /**\n   * Inline functions in shader code that are marked to be inlined\n   * @param code code to inline\n   * @returns inlined code\n   */\n  inlineShaderCode(code) {\n    const sci = new ShaderCodeInliner(code);\n    sci.debug = false;\n    sci.processCode();\n    return sci.code;\n  }\n  _setProgram(program) {\n    if (this._currentProgram !== program) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(program);\n      this._commandBufferEncoder.finishEncodingCommand();\n      this._currentProgram = program;\n    }\n  }\n  _deletePipelineContext(pipelineContext) {\n    const nativePipelineContext = pipelineContext;\n    if (nativePipelineContext && nativePipelineContext.nativeProgram) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.nativeProgram);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  getUniforms(pipelineContext, uniformsNames) {\n    const nativePipelineContext = pipelineContext;\n    return this._engine.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);\n  }\n  bindUniformBlock(pipelineContext, blockName, index) {\n    // TODO\n    throw new Error(\"Not Implemented\");\n  }\n  bindSamplers(effect) {\n    const nativePipelineContext = effect.getPipelineContext();\n    this._setProgram(nativePipelineContext.nativeProgram);\n    // TODO: share this with engine?\n    const samplers = effect.getSamplers();\n    for (let index = 0; index < samplers.length; index++) {\n      const uniform = effect.getUniform(samplers[index]);\n      if (uniform) {\n        this._boundUniforms[index] = uniform;\n      }\n    }\n    this._currentEffect = null;\n  }\n  getRenderWidth(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.width;\n    }\n    return this._engine.getRenderWidth();\n  }\n  getRenderHeight(useScreen = false) {\n    if (!useScreen && this._currentRenderTarget) {\n      return this._currentRenderTarget.height;\n    }\n    return this._engine.getRenderHeight();\n  }\n  setViewport(viewport, requiredWidth, requiredHeight) {\n    this._cachedViewport = viewport;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.width);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.height);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {\n    var _a, _b;\n    this._zOffset = zOffset;\n    this._zOffsetUnits = zOffsetUnits;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? 1 : 0);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets the client rect of native canvas.  Needed for InputManager.\n   * @returns a client rectangle\n   */\n  getInputElementClientRect() {\n    const rect = {\n      bottom: this.getRenderHeight(),\n      height: this.getRenderHeight(),\n      left: 0,\n      right: this.getRenderWidth(),\n      top: 0,\n      width: this.getRenderWidth(),\n      x: 0,\n      y: 0,\n      toJSON: () => {}\n    };\n    return rect;\n  }\n  /**\n   * Set the z offset Factor to apply to current rendering\n   * @param value defines the offset to apply\n   */\n  setZOffset(value) {\n    if (value !== this._zOffset) {\n      this._zOffset = value;\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);\n      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * Gets the current value of the zOffset Factor\n   * @returns the current zOffset Factor state\n   */\n  getZOffset() {\n    return this._zOffset;\n  }\n  /**\n   * Set the z offset Units to apply to current rendering\n   * @param value defines the offset to apply\n   */\n  setZOffsetUnits(value) {\n    if (value !== this._zOffsetUnits) {\n      this._zOffsetUnits = value;\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);\n      this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * Gets the current value of the zOffset Units\n   * @returns the current zOffset Units state\n   */\n  getZOffsetUnits() {\n    return this._zOffsetUnits;\n  }\n  /**\n   * Enable or disable depth buffering\n   * @param enable defines the state to set\n   */\n  setDepthBuffer(enable) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets a boolean indicating if depth writing is enabled\n   * @returns the current depth writing state\n   */\n  getDepthWrite() {\n    return this._depthWrite;\n  }\n  getDepthFunction() {\n    switch (this._currentDepthTest) {\n      case _native.Engine.DEPTH_TEST_NEVER:\n        return 512;\n      case _native.Engine.DEPTH_TEST_ALWAYS:\n        return 519;\n      case _native.Engine.DEPTH_TEST_GREATER:\n        return 516;\n      case _native.Engine.DEPTH_TEST_GEQUAL:\n        return 518;\n      case _native.Engine.DEPTH_TEST_NOTEQUAL:\n        return 517;\n      case _native.Engine.DEPTH_TEST_EQUAL:\n        return 514;\n      case _native.Engine.DEPTH_TEST_LESS:\n        return 513;\n      case _native.Engine.DEPTH_TEST_LEQUAL:\n        return 515;\n    }\n    return null;\n  }\n  setDepthFunction(depthFunc) {\n    let nativeDepthFunc = 0;\n    switch (depthFunc) {\n      case 512:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;\n        break;\n      case 519:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;\n        break;\n      case 516:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;\n        break;\n      case 518:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;\n        break;\n      case 517:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;\n        break;\n      case 514:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;\n        break;\n      case 513:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;\n        break;\n      case 515:\n        nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;\n        break;\n    }\n    this._currentDepthTest = nativeDepthFunc;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable depth writing\n   * @param enable defines the state to set\n   */\n  setDepthWrite(enable) {\n    this._depthWrite = enable;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable color writing\n   * @param enable defines the state to set\n   */\n  setColorWrite(enable) {\n    this._colorWrite = enable;\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Gets a boolean indicating if color writing is enabled\n   * @returns the current color writing state\n   */\n  getColorWrite() {\n    return this._colorWrite;\n  }\n  applyStencil() {\n    this._setStencil(this._stencilMask, this._getStencilOpFail(this._stencilOpStencilFail), this._getStencilDepthFail(this._stencilOpDepthFail), this._getStencilDepthPass(this._stencilOpStencilDepthPass), this._getStencilFunc(this._stencilFunc), this._stencilFuncRef);\n  }\n  _setStencil(mask, stencilOpFail, depthOpFail, depthOpPass, func, ref) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(func);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  /**\n   * Enable or disable the stencil buffer\n   * @param enable defines if the stencil buffer must be enabled or disabled\n   */\n  setStencilBuffer(enable) {\n    this._stencilTest = enable;\n    if (enable) {\n      this.applyStencil();\n    } else {\n      this._setStencil(255, _native.Engine.STENCIL_OP_FAIL_S_KEEP, _native.Engine.STENCIL_OP_FAIL_Z_KEEP, _native.Engine.STENCIL_OP_PASS_Z_KEEP, _native.Engine.STENCIL_TEST_ALWAYS, 0);\n    }\n  }\n  /**\n   * Gets a boolean indicating if stencil buffer is enabled\n   * @returns the current stencil buffer state\n   */\n  getStencilBuffer() {\n    return this._stencilTest;\n  }\n  /**\n   * Gets the current stencil operation when stencil passes\n   * @returns a number defining stencil operation to use when stencil passes\n   */\n  getStencilOperationPass() {\n    return this._stencilOpStencilDepthPass;\n  }\n  /**\n   * Sets the stencil operation to use when stencil passes\n   * @param operation defines the stencil operation to use when stencil passes\n   */\n  setStencilOperationPass(operation) {\n    this._stencilOpStencilDepthPass = operation;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilMask(mask) {\n    this._stencilMask = mask;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil function\n   * @param stencilFunc defines the new stencil function to use\n   */\n  setStencilFunction(stencilFunc) {\n    this._stencilFunc = stencilFunc;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil reference\n   * @param reference defines the new stencil reference to use\n   */\n  setStencilFunctionReference(reference) {\n    this._stencilFuncRef = reference;\n    this.applyStencil();\n  }\n  /**\n   * Sets the current stencil mask\n   * @param mask defines the new stencil mask to use\n   */\n  setStencilFunctionMask(mask) {\n    this._stencilFuncMask = mask;\n  }\n  /**\n   * Sets the stencil operation to use when stencil fails\n   * @param operation defines the stencil operation to use when stencil fails\n   */\n  setStencilOperationFail(operation) {\n    this._stencilOpStencilFail = operation;\n    this.applyStencil();\n  }\n  /**\n   * Sets the stencil operation to use when depth fails\n   * @param operation defines the stencil operation to use when depth fails\n   */\n  setStencilOperationDepthFail(operation) {\n    this._stencilOpDepthFail = operation;\n    this.applyStencil();\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the new stencil mask to use\n   */\n  getStencilMask() {\n    return this._stencilMask;\n  }\n  /**\n   * Gets the current stencil function\n   * @returns a number defining the stencil function to use\n   */\n  getStencilFunction() {\n    return this._stencilFunc;\n  }\n  /**\n   * Gets the current stencil reference value\n   * @returns a number defining the stencil reference value to use\n   */\n  getStencilFunctionReference() {\n    return this._stencilFuncRef;\n  }\n  /**\n   * Gets the current stencil mask\n   * @returns a number defining the stencil mask to use\n   */\n  getStencilFunctionMask() {\n    return this._stencilFuncMask;\n  }\n  /**\n   * Gets the current stencil operation when stencil fails\n   * @returns a number defining stencil operation to use when stencil fails\n   */\n  getStencilOperationFail() {\n    return this._stencilOpStencilFail;\n  }\n  /**\n   * Gets the current stencil operation when depth fails\n   * @returns a number defining stencil operation to use when depth fails\n   */\n  getStencilOperationDepthFail() {\n    return this._stencilOpDepthFail;\n  }\n  /**\n   * Sets alpha constants used by some alpha blending modes\n   * @param r defines the red component\n   * @param g defines the green component\n   * @param b defines the blue component\n   * @param a defines the alpha component\n   */\n  setAlphaConstants(r, g, b, a) {\n    throw new Error(\"Setting alpha blend constant color not yet implemented.\");\n  }\n  /**\n   * Sets the current alpha mode\n   * @param mode defines the mode to use (one of the BABYLON.undefined)\n   * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   */\n  setAlphaMode(mode, noDepthWriteChange = false) {\n    if (this._alphaMode === mode) {\n      return;\n    }\n    const nativeMode = this._getNativeAlphaMode(mode);\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);\n    this._commandBufferEncoder.finishEncodingCommand();\n    if (!noDepthWriteChange) {\n      this.setDepthWrite(mode === 0);\n    }\n    this._alphaMode = mode;\n  }\n  /**\n   * Gets the current alpha mode\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\n   * @returns the current alpha mode\n   */\n  getAlphaMode() {\n    return this._alphaMode;\n  }\n  setInt(uniform, int) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32(int);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setIntArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloatArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setArray(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray(uniform, new Float32Array(array));\n  }\n  setArray2(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray2(uniform, new Float32Array(array));\n  }\n  setArray3(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray3(uniform, new Float32Array(array));\n  }\n  setArray4(uniform, array) {\n    if (!uniform) {\n      return false;\n    }\n    return this.setFloatArray4(uniform, new Float32Array(array));\n  }\n  setMatrices(uniform, matrices) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setMatrix3x3(uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setMatrix2x2(uniform, matrix) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat(uniform, value) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(value);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat2(uniform, x, y) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat3(uniform, x, y, z) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setFloat4(uniform, x, y, z, w) {\n    if (!uniform) {\n      return false;\n    }\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\n    this._commandBufferEncoder.encodeCommandArgAsFloat32(w);\n    this._commandBufferEncoder.finishEncodingCommand();\n    return true;\n  }\n  setColor3(uniform, color3) {\n    if (!uniform) {\n      return false;\n    }\n    this.setFloat3(uniform, color3.r, color3.g, color3.b);\n    return true;\n  }\n  setColor4(uniform, color3, alpha) {\n    if (!uniform) {\n      return false;\n    }\n    this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\n    return true;\n  }\n  wipeCaches(bruteForce) {\n    if (this.preventCacheWipeBetweenFrames) {\n      return;\n    }\n    this.resetTextureCache();\n    this._currentEffect = null;\n    if (bruteForce) {\n      this._currentProgram = null;\n      this._stencilStateComposer.reset();\n      this._depthCullingState.reset();\n      this._alphaState.reset();\n    }\n    this._cachedVertexBuffers = null;\n    this._cachedIndexBuffer = null;\n    this._cachedEffectForVertexBuffers = null;\n  }\n  _createTexture() {\n    return this._engine.createTexture();\n  }\n  _deleteTexture(texture) {\n    if (texture) {\n      this._engine.deleteTexture(texture);\n    }\n  }\n  /**\n   * Update the content of a dynamic texture\n   * @param texture defines the texture to update\n   * @param canvas defines the canvas containing the source\n   * @param invertY defines if data must be stored with Y axis inverted\n   * @param premulAlpha defines if alpha is stored as premultiplied\n   * @param format defines the format of the data\n   */\n  updateDynamicTexture(texture, canvas, invertY, premulAlpha = false, format) {\n    if (premulAlpha === void 0) {\n      premulAlpha = false;\n    }\n    if (!!texture && !!texture._hardwareTexture) {\n      const source = canvas.getCanvasTexture();\n      const destination = texture._hardwareTexture.underlyingResource;\n      this._engine.copyTexture(destination, source);\n      texture.isReady = true;\n    }\n  }\n  createDynamicTexture(width, height, generateMipMaps, samplingMode) {\n    // it's not possible to create 0x0 texture sized. Many bgfx methods assume texture size is at least 1x1(best case).\n    // Worst case is getting a crash/assert.\n    width = Math.max(width, 1);\n    height = Math.max(height, 1);\n    return this.createRawTexture(new Uint8Array(width * height * 4), width, height, 5, false, false, samplingMode);\n  }\n  createVideoElement(constraints) {\n    // create native object depending on stream. Only NativeCamera is supported for now.\n    if (this._camera) {\n      return this._camera.createVideo(constraints);\n    }\n    return null;\n  }\n  updateVideoTexture(texture, video, invertY) {\n    if (texture && texture._hardwareTexture && this._camera) {\n      const webGLTexture = texture._hardwareTexture.underlyingResource;\n      this._camera.updateVideoTexture(webGLTexture, video, invertY);\n    }\n  }\n  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\n    texture.format = format;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = texture.baseWidth;\n    texture.height = texture.baseHeight;\n    texture._compression = compression;\n    texture.type = type;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\n    if (texture._hardwareTexture) {\n      const webGLTexture = texture._hardwareTexture.underlyingResource;\n      const filter = this._getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(webGLTexture, filter);\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {\n    const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.baseDepth = depth;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = depth;\n    texture.format = format;\n    texture.type = textureType;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.is2DArray = true;\n    if (texture._hardwareTexture) {\n      const nativeTexture = texture._hardwareTexture.underlyingResource;\n      this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, this._getNativeTextureFormat(format, textureType), generateMipMaps, invertY);\n      const filter = this._getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(nativeTexture, filter);\n    }\n    texture.isReady = true;\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  updateRawTexture(texture, bufferView, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {\n    if (!texture) {\n      return;\n    }\n    if (bufferView && texture._hardwareTexture) {\n      const underlyingResource = texture._hardwareTexture.underlyingResource;\n      this._engine.loadRawTexture(underlyingResource, bufferView, texture.width, texture.height, this._getNativeTextureFormat(format, type), texture.generateMipMaps, texture.invertY);\n    }\n    texture.isReady = true;\n  }\n  // TODO: Refactor to share more logic with babylon.engine.ts version.\n  /**\n   * Usually called from Texture.ts.\n   * Passed information to create a NativeTexture\n   * @param url defines a value which contains one of the following:\n   * * A conventional http URL, e.g. 'http://...' or 'file://...'\n   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\n   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\n   * @param scene needed for loading to the correct scene\n   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\n   * @param onLoad optional callback to be called upon successful completion\n   * @param onError optional callback to be called upon failure\n   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\n   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\n   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param mimeType defines an optional mime type\n   * @param loaderOptions options to be passed to the loader\n   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns a InternalTexture for assignment back into BABYLON.Texture\n   */\n  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer = false) {\n    url = url || \"\";\n    const fromData = url.substr(0, 5) === \"data:\";\n    //const fromBlob = url.substr(0, 5) === \"blob:\";\n    const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\n    const originalUrl = url;\n    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\n      url = this._transformTextureUrl(url);\n    }\n    // establish the file extension, if possible\n    const lastDot = url.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n    let loader = null;\n    for (const availableLoader of Engine._TextureLoaders) {\n      if (availableLoader.canLoad(extension)) {\n        loader = availableLoader;\n        break;\n      }\n    }\n    if (scene) {\n      scene.addPendingData(texture);\n    }\n    texture.url = url;\n    texture.generateMipMaps = !noMipmap;\n    texture.samplingMode = samplingMode;\n    texture.invertY = invertY;\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);\n    if (!this.doNotHandleContextLost) {\n      // Keep a link to the buffer only if we plan to handle context lost\n      texture._buffer = buffer;\n    }\n    let onLoadObserver = null;\n    if (onLoad && !fallback) {\n      onLoadObserver = texture.onLoadedObservable.add(onLoad);\n    }\n    if (!fallback) {\n      this._internalTexturesCache.push(texture);\n    }\n    const onInternalError = (message, exception) => {\n      if (scene) {\n        scene.removePendingData(texture);\n      }\n      if (url === originalUrl) {\n        if (onLoadObserver) {\n          texture.onLoadedObservable.remove(onLoadObserver);\n        }\n        if (EngineStore.UseFallbackTexture) {\n          this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\n        }\n        if (onError) {\n          onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\n        }\n      } else {\n        // fall back to the original url if the transformed url fails to load\n        Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\n        this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\n      }\n    };\n    // processing for non-image formats\n    if (loader) {\n      throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\n    } else {\n      const onload = data => {\n        if (!texture._hardwareTexture) {\n          if (scene) {\n            scene.removePendingData(texture);\n          }\n          return;\n        }\n        const underlyingResource = texture._hardwareTexture.underlyingResource;\n        this._engine.loadTexture(underlyingResource, data, !noMipmap, invertY, useSRGBBuffer, () => {\n          texture.baseWidth = this._engine.getTextureWidth(underlyingResource);\n          texture.baseHeight = this._engine.getTextureHeight(underlyingResource);\n          texture.width = texture.baseWidth;\n          texture.height = texture.baseHeight;\n          texture.isReady = true;\n          const filter = this._getNativeSamplingMode(samplingMode);\n          this._setTextureSampling(underlyingResource, filter);\n          if (scene) {\n            scene.removePendingData(texture);\n          }\n          texture.onLoadedObservable.notifyObservers(texture);\n          texture.onLoadedObservable.clear();\n        }, () => {\n          throw new Error(\"Could not load a native texture.\");\n        });\n      };\n      if (fromData && buffer) {\n        if (buffer instanceof ArrayBuffer) {\n          onload(new Uint8Array(buffer));\n        } else if (ArrayBuffer.isView(buffer)) {\n          onload(buffer);\n        } else if (typeof buffer === \"string\") {\n          onload(new Uint8Array(Tools.DecodeBase64(buffer)));\n        } else {\n          throw new Error(\"Unsupported buffer type\");\n        }\n      } else {\n        if (isBase64) {\n          onload(new Uint8Array(Tools.DecodeBase64(url)));\n        } else {\n          this._loadFile(url, data => onload(new Uint8Array(data)), undefined, undefined, true, (request, exception) => {\n            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\n          });\n        }\n      }\n    }\n    return texture;\n  }\n  /**\n   * Wraps an external native texture in a Babylon texture.\n   * @param texture defines the external texture\n   * @returns the babylon internal texture\n   */\n  wrapNativeTexture(texture) {\n    const hardwareTexture = new NativeHardwareTexture(texture, this._engine);\n    const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\n    internalTexture._hardwareTexture = hardwareTexture;\n    internalTexture.isReady = true;\n    return internalTexture;\n  }\n  /**\n   * Wraps an external web gl texture in a Babylon texture.\n   * @returns the babylon internal texture\n   */\n  wrapWebGLTexture() {\n    throw new Error(\"wrapWebGLTexture is not supported, use wrapNativeTexture instead.\");\n  }\n  _createDepthStencilTexture(size, options, rtWrapper) {\n    // TODO: options?\n    const nativeRTWrapper = rtWrapper;\n    const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);\n    const width = size.width || size;\n    const height = size.height || size;\n    const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture.underlyingResource, width, height, true, true);\n    nativeRTWrapper._framebufferDepthStencil = framebuffer;\n    return texture;\n  }\n  /**\n   * @internal\n   */\n  _releaseFramebufferObjects(framebuffer) {\n    if (framebuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n    }\n  }\n  /**\n   * @internal Engine abstraction for loading and creating an image bitmap from a given source string.\n   * @param imageSource source to load the image from.\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  _createImageBitmapFromSource(imageSource, options) {\n    const promise = new Promise((resolve, reject) => {\n      const image = this.createCanvasImage();\n      image.onload = () => {\n        try {\n          const imageBitmap = this._engine.createImageBitmap(image);\n          resolve(imageBitmap);\n        } catch (error) {\n          reject(`Error loading image ${image.src} with exception: ${error}`);\n        }\n      };\n      image.onerror = error => {\n        reject(`Error loading image ${image.src} with exception: ${error}`);\n      };\n      image.src = imageSource;\n    });\n    return promise;\n  }\n  /**\n   * Engine abstraction for createImageBitmap\n   * @param image source for image\n   * @param options An object that sets options for the image's extraction.\n   * @returns ImageBitmap\n   */\n  createImageBitmap(image, options) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(image)) {\n        const arr = image;\n        if (arr.length) {\n          const image = this._engine.createImageBitmap(arr[0]);\n          if (image) {\n            resolve(image);\n            return;\n          }\n        }\n      }\n      reject(`Unsupported data for createImageBitmap.`);\n    });\n  }\n  /**\n   * Resize an image and returns the image data as an uint8array\n   * @param image image to resize\n   * @param bufferWidth destination buffer width\n   * @param bufferHeight destination buffer height\n   * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\n   */\n  resizeImageBitmap(image, bufferWidth, bufferHeight) {\n    return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);\n  }\n  /**\n   * Creates a cube texture\n   * @param rootUrl defines the url where the files to load is located\n   * @param scene defines the current scene\n   * @param files defines the list of files to load (1 per face)\n   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\n   * @param onLoad defines an optional callback raised when the texture is loaded\n   * @param onError defines an optional callback raised if there is an issue to load the texture\n   * @param format defines the format of the data\n   * @param forcedExtension defines the extension to use to pick the right loader\n   * @param createPolynomials if a polynomial sphere should be created for the cube texture\n   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n   * @param fallback defines texture to use while falling back when (compressed) texture file not found.\n   * @param loaderOptions options to be passed to the loader\n   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n   * @returns the cube texture as an InternalTexture\n   */\n  createCubeTexture(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\n    texture.isCube = true;\n    texture.url = rootUrl;\n    texture.generateMipMaps = !noMipmap;\n    texture._lodGenerationScale = lodScale;\n    texture._lodGenerationOffset = lodOffset;\n    if (!this._doNotHandleContextLost) {\n      texture._extension = forcedExtension;\n      texture._files = files;\n    }\n    const lastDot = rootUrl.lastIndexOf(\".\");\n    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\n    // TODO: use texture loader to load env files?\n    if (extension === \".env\") {\n      const onloaddata = data => {\n        const info = GetEnvInfo(data);\n        texture.width = info.width;\n        texture.height = info.width;\n        UploadEnvSpherical(texture, info);\n        const specularInfo = info.specular;\n        if (!specularInfo) {\n          throw new Error(`Nothing else parsed so far`);\n        }\n        texture._lodGenerationScale = specularInfo.lodGenerationScale;\n        const imageData = CreateImageDataArrayBufferViews(data, info);\n        texture.format = 5;\n        texture.type = 0;\n        texture.generateMipMaps = true;\n        texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\n        texture._isRGBD = true;\n        texture.invertY = true;\n        this._engine.loadCubeTextureWithMips(texture._hardwareTexture.underlyingResource, imageData, false, useSRGBBuffer, () => {\n          texture.isReady = true;\n          if (onLoad) {\n            onLoad();\n          }\n        }, () => {\n          throw new Error(\"Could not load a native cube texture.\");\n        });\n      };\n      if (files && files.length === 6) {\n        throw new Error(`Multi-file loading not allowed on env files.`);\n      } else {\n        const onInternalError = (request, exception) => {\n          if (onError && request) {\n            onError(request.status + \" \" + request.statusText, exception);\n          }\n        };\n        this._loadFile(rootUrl, data => onloaddata(new Uint8Array(data)), undefined, undefined, true, onInternalError);\n      }\n    } else {\n      if (!files || files.length !== 6) {\n        throw new Error(\"Cannot load cubemap because 6 files were not defined\");\n      }\n      // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\n      const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\n      Promise.all(reorderedFiles.map(file => Tools.LoadFileAsync(file).then(data => new Uint8Array(data)))).then(data => {\n        return new Promise((resolve, reject) => {\n          this._engine.loadCubeTexture(texture._hardwareTexture.underlyingResource, data, !noMipmap, true, useSRGBBuffer, resolve, reject);\n        });\n      }).then(() => {\n        texture.isReady = true;\n        if (onLoad) {\n          onLoad();\n        }\n      }, error => {\n        if (onError) {\n          onError(`Failed to load cubemap: ${error.message}`, error);\n        }\n      });\n    }\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  /** @internal */\n  _createHardwareTexture() {\n    return new NativeHardwareTexture(this._createTexture(), this._engine);\n  }\n  /** @internal */\n  _createHardwareRenderTargetWrapper(isMulti, isCube, size) {\n    const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);\n    this._renderTargetWrapperCache.push(rtWrapper);\n    return rtWrapper;\n  }\n  /** @internal */\n  _createInternalTexture(size, options, _delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {\n    var _a;\n    let generateMipMaps = false;\n    let type = 0;\n    let samplingMode = 3;\n    let format = 5;\n    let useSRGBBuffer = false;\n    let samples = 1;\n    if (options !== undefined && typeof options === \"object\") {\n      generateMipMaps = !!options.generateMipMaps;\n      type = options.type === undefined ? 0 : options.type;\n      samplingMode = options.samplingMode === undefined ? 3 : options.samplingMode;\n      format = options.format === undefined ? 5 : options.format;\n      useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\n      samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;\n    } else {\n      generateMipMaps = !!options;\n    }\n    useSRGBBuffer && (useSRGBBuffer = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU));\n    if (type === 1 && !this._caps.textureFloatLinearFiltering) {\n      // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {\n      // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n      samplingMode = 1;\n    }\n    if (type === 1 && !this._caps.textureFloat) {\n      type = 0;\n      Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\n    }\n    const texture = new InternalTexture(this, source);\n    const width = size.width || size;\n    const height = size.height || size;\n    const layers = size.layers || 0;\n    if (layers !== 0) {\n      throw new Error(\"Texture layers are not supported in Babylon Native\");\n    }\n    const nativeTexture = texture._hardwareTexture.underlyingResource;\n    const nativeTextureFormat = this._getNativeTextureFormat(format, type);\n    // REVIEW: We are always setting the renderTarget flag as we don't know whether the texture will be used as a render target.\n    this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer);\n    this._setTextureSampling(nativeTexture, this._getNativeSamplingMode(samplingMode));\n    texture._useSRGBBuffer = useSRGBBuffer;\n    texture.baseWidth = width;\n    texture.baseHeight = height;\n    texture.width = width;\n    texture.height = height;\n    texture.depth = layers;\n    texture.isReady = true;\n    texture.samples = samples;\n    texture.generateMipMaps = generateMipMaps;\n    texture.samplingMode = samplingMode;\n    texture.type = type;\n    texture.format = format;\n    this._internalTexturesCache.push(texture);\n    return texture;\n  }\n  createRenderTargetTexture(size, options) {\n    var _a;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let noColorAttachment = false;\n    let colorAttachment = undefined;\n    //let samples = 1;\n    if (options !== undefined && typeof options === \"object\") {\n      generateDepthBuffer = (_a = options.generateDepthBuffer) !== null && _a !== void 0 ? _a : true;\n      generateStencilBuffer = !!options.generateStencilBuffer;\n      noColorAttachment = !!options.noColorAttachment;\n      colorAttachment = options.colorAttachment;\n      //samples = options.samples ?? 1;\n    }\n\n    const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\n    const width = size.width || size;\n    const height = size.height || size;\n    const framebuffer = this._engine.createFrameBuffer(texture ? texture._hardwareTexture.underlyingResource : null, width, height, generateStencilBuffer, generateDepthBuffer);\n    rtWrapper._framebuffer = framebuffer;\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper.setTextures(texture);\n    // TODO: handle this in native\n    //this.updateRenderTargetTextureSampleCount(rtWrapper, samples);\n    return rtWrapper;\n  }\n  updateTextureSamplingMode(samplingMode, texture) {\n    if (texture._hardwareTexture) {\n      const filter = this._getNativeSamplingMode(samplingMode);\n      this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);\n    }\n    texture.samplingMode = samplingMode;\n  }\n  bindFramebuffer(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport) {\n    const nativeRTWrapper = texture;\n    if (this._currentRenderTarget) {\n      this.unBindFramebuffer(this._currentRenderTarget);\n    }\n    this._currentRenderTarget = texture;\n    if (faceIndex) {\n      throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\n    }\n    if (requiredWidth || requiredHeight) {\n      throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\n    }\n    if (forceFullscreenViewport) {\n      //Not supported yet but don't stop rendering\n    }\n    if (nativeRTWrapper._framebufferDepthStencil) {\n      this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);\n    } else {\n      this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);\n    }\n  }\n  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {\n    // NOTE: Disabling mipmap generation is not yet supported in NativeEngine.\n    this._currentRenderTarget = null;\n    if (onBeforeUnbind) {\n      onBeforeUnbind();\n    }\n    this._bindUnboundFramebuffer(null);\n  }\n  createDynamicVertexBuffer(data) {\n    return this.createVertexBuffer(data, true);\n  }\n  updateDynamicIndexBuffer(indexBuffer, indices, offset = 0) {\n    const buffer = indexBuffer;\n    const data = this._normalizeIndexData(indices);\n    buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\n    this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer, data.buffer, data.byteOffset, data.byteLength, offset);\n  }\n  updateDynamicVertexBuffer(vertexBuffer, verticies, byteOffset, byteLength) {\n    const buffer = vertexBuffer;\n    const data = ArrayBuffer.isView(verticies) ? verticies : new Float32Array(verticies);\n    this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer, data.buffer, data.byteOffset + (byteOffset !== null && byteOffset !== void 0 ? byteOffset : 0), byteLength !== null && byteLength !== void 0 ? byteLength : data.byteLength);\n  }\n  // TODO: Refactor to share more logic with base Engine implementation.\n  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false) {\n    const uniform = this._boundUniforms[channel];\n    if (!uniform) {\n      return false;\n    }\n    // Not ready?\n    if (!texture) {\n      if (this._boundTexturesCache[channel] != null) {\n        this._activeChannel = channel;\n        this._boundTexturesCache[channel] = null;\n      }\n      return false;\n    }\n    // Video\n    if (texture.video) {\n      this._activeChannel = channel;\n      texture.update();\n    } else if (texture.delayLoadState === 4) {\n      // Delay loading\n      texture.delayLoad();\n      return false;\n    }\n    let internalTexture;\n    if (depthStencilTexture) {\n      internalTexture = texture.depthStencilTexture;\n    } else if (texture.isReady()) {\n      internalTexture = texture.getInternalTexture();\n    } else if (texture.isCube) {\n      internalTexture = this.emptyCubeTexture;\n    } else if (texture.is3D) {\n      internalTexture = this.emptyTexture3D;\n    } else if (texture.is2DArray) {\n      internalTexture = this.emptyTexture2DArray;\n    } else {\n      internalTexture = this.emptyTexture;\n    }\n    this._activeChannel = channel;\n    if (!internalTexture || !internalTexture._hardwareTexture) {\n      return false;\n    }\n    this._setTextureWrapMode(internalTexture._hardwareTexture.underlyingResource, this._getAddressMode(texture.wrapU), this._getAddressMode(texture.wrapV), this._getAddressMode(texture.wrapR));\n    this._updateAnisotropicLevel(texture);\n    this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);\n    return true;\n  }\n  // filter is a NativeFilter.XXXX value.\n  _setTextureSampling(texture, filter) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  // addressModes are NativeAddressMode.XXXX values.\n  _setTextureWrapMode(texture, addressModeU, addressModeV, addressModeW) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);\n    this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  _setTextureCore(uniform, texture) {\n    this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\n    this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\n    this._commandBufferEncoder.finishEncodingCommand();\n  }\n  // TODO: Share more of this logic with the base implementation.\n  // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\n  _updateAnisotropicLevel(texture) {\n    const internalTexture = texture.getInternalTexture();\n    const value = texture.anisotropicFilteringLevel;\n    if (!internalTexture || !internalTexture._hardwareTexture) {\n      return;\n    }\n    if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);\n      this._commandBufferEncoder.encodeCommandArgAsUInt32(value);\n      this._commandBufferEncoder.finishEncodingCommand();\n      internalTexture._cachedAnisotropicFilteringLevel = value;\n    }\n  }\n  // Returns a NativeAddressMode.XXX value.\n  _getAddressMode(wrapMode) {\n    switch (wrapMode) {\n      case 1:\n        return _native.Engine.ADDRESS_MODE_WRAP;\n      case 0:\n        return _native.Engine.ADDRESS_MODE_CLAMP;\n      case 2:\n        return _native.Engine.ADDRESS_MODE_MIRROR;\n      default:\n        throw new Error(\"Unexpected wrap mode: \" + wrapMode + \".\");\n    }\n  }\n  /**\n   * @internal\n   */\n  _bindTexture(channel, texture) {\n    const uniform = this._boundUniforms[channel];\n    if (!uniform) {\n      return;\n    }\n    if (texture && texture._hardwareTexture) {\n      const underlyingResource = texture._hardwareTexture.underlyingResource;\n      this._setTextureCore(uniform, underlyingResource);\n    }\n  }\n  _deleteBuffer(buffer) {\n    if (buffer.nativeIndexBuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n      delete buffer.nativeIndexBuffer;\n    }\n    if (buffer.nativeVertexBuffer) {\n      this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);\n      this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);\n      this._commandBufferEncoder.finishEncodingCommand();\n      delete buffer.nativeVertexBuffer;\n    }\n  }\n  /**\n   * Create a canvas\n   * @param width width\n   * @param height height\n   * @returns ICanvas interface\n   */\n  createCanvas(width, height) {\n    if (!_native.Canvas) {\n      throw new Error(\"Native Canvas plugin not available.\");\n    }\n    const canvas = new _native.Canvas();\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n  /**\n   * Create an image to use with canvas\n   * @returns IImage interface\n   */\n  createCanvasImage() {\n    if (!_native.Canvas) {\n      throw new Error(\"Native Canvas plugin not available.\");\n    }\n    const image = new _native.Image();\n    return image;\n  }\n  /**\n   * Update a portion of an internal texture\n   * @param texture defines the texture to update\n   * @param imageData defines the data to store into the texture\n   * @param xOffset defines the x coordinates of the update rectangle\n   * @param yOffset defines the y coordinates of the update rectangle\n   * @param width defines the width of the update rectangle\n   * @param height defines the height of the update rectangle\n   * @param faceIndex defines the face index if texture is a cube (0 by default)\n   * @param lod defines the lod level to update (0 by default)\n   * @param generateMipMaps defines whether to generate mipmaps or not\n   */\n  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {\n    throw new Error(\"updateTextureData not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }\n  /**\n   * @internal\n   */\n  _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {\n    throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\n  }\n  // JavaScript-to-Native conversion helper functions.\n  _getNativeSamplingMode(samplingMode) {\n    switch (samplingMode) {\n      case 1:\n        return _native.Engine.TEXTURE_NEAREST_NEAREST;\n      case 2:\n        return _native.Engine.TEXTURE_LINEAR_LINEAR;\n      case 3:\n        return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\n      case 4:\n        return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\n      case 5:\n        return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\n      case 6:\n        return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\n      case 7:\n        return _native.Engine.TEXTURE_NEAREST_LINEAR;\n      case 8:\n        return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR;\n      case 9:\n        return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\n      case 10:\n        return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\n      case 11:\n        return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\n      case 12:\n        return _native.Engine.TEXTURE_LINEAR_NEAREST;\n      default:\n        throw new Error(`Unsupported sampling mode: ${samplingMode}.`);\n    }\n  }\n  _getStencilFunc(func) {\n    switch (func) {\n      case 513:\n        return _native.Engine.STENCIL_TEST_LESS;\n      case 515:\n        return _native.Engine.STENCIL_TEST_LEQUAL;\n      case 514:\n        return _native.Engine.STENCIL_TEST_EQUAL;\n      case 518:\n        return _native.Engine.STENCIL_TEST_GEQUAL;\n      case 516:\n        return _native.Engine.STENCIL_TEST_GREATER;\n      case 517:\n        return _native.Engine.STENCIL_TEST_NOTEQUAL;\n      case 512:\n        return _native.Engine.STENCIL_TEST_NEVER;\n      case 519:\n        return _native.Engine.STENCIL_TEST_ALWAYS;\n      default:\n        throw new Error(`Unsupported stencil func mode: ${func}.`);\n    }\n  }\n  _getStencilOpFail(opFail) {\n    switch (opFail) {\n      case 7680:\n        return _native.Engine.STENCIL_OP_FAIL_S_KEEP;\n      case 0:\n        return _native.Engine.STENCIL_OP_FAIL_S_ZERO;\n      case 7681:\n        return _native.Engine.STENCIL_OP_FAIL_S_REPLACE;\n      case 7682:\n        return _native.Engine.STENCIL_OP_FAIL_S_INCR;\n      case 7683:\n        return _native.Engine.STENCIL_OP_FAIL_S_DECR;\n      case 5386:\n        return _native.Engine.STENCIL_OP_FAIL_S_INVERT;\n      case 34055:\n        return _native.Engine.STENCIL_OP_FAIL_S_INCRSAT;\n      case 34056:\n        return _native.Engine.STENCIL_OP_FAIL_S_DECRSAT;\n      default:\n        throw new Error(`Unsupported stencil OpFail mode: ${opFail}.`);\n    }\n  }\n  _getStencilDepthFail(depthFail) {\n    switch (depthFail) {\n      case 7680:\n        return _native.Engine.STENCIL_OP_FAIL_Z_KEEP;\n      case 0:\n        return _native.Engine.STENCIL_OP_FAIL_Z_ZERO;\n      case 7681:\n        return _native.Engine.STENCIL_OP_FAIL_Z_REPLACE;\n      case 7682:\n        return _native.Engine.STENCIL_OP_FAIL_Z_INCR;\n      case 7683:\n        return _native.Engine.STENCIL_OP_FAIL_Z_DECR;\n      case 5386:\n        return _native.Engine.STENCIL_OP_FAIL_Z_INVERT;\n      case 34055:\n        return _native.Engine.STENCIL_OP_FAIL_Z_INCRSAT;\n      case 34056:\n        return _native.Engine.STENCIL_OP_FAIL_Z_DECRSAT;\n      default:\n        throw new Error(`Unsupported stencil depthFail mode: ${depthFail}.`);\n    }\n  }\n  _getStencilDepthPass(opPass) {\n    switch (opPass) {\n      case 7680:\n        return _native.Engine.STENCIL_OP_PASS_Z_KEEP;\n      case 0:\n        return _native.Engine.STENCIL_OP_PASS_Z_ZERO;\n      case 7681:\n        return _native.Engine.STENCIL_OP_PASS_Z_REPLACE;\n      case 7682:\n        return _native.Engine.STENCIL_OP_PASS_Z_INCR;\n      case 7683:\n        return _native.Engine.STENCIL_OP_PASS_Z_DECR;\n      case 5386:\n        return _native.Engine.STENCIL_OP_PASS_Z_INVERT;\n      case 34055:\n        return _native.Engine.STENCIL_OP_PASS_Z_INCRSAT;\n      case 34056:\n        return _native.Engine.STENCIL_OP_PASS_Z_DECRSAT;\n      default:\n        throw new Error(`Unsupported stencil opPass mode: ${opPass}.`);\n    }\n  }\n  _getNativeTextureFormat(format, type) {\n    if (format == 4 && type == 0) {\n      return _native.Engine.TEXTURE_FORMAT_RGB8;\n    } else if (format == 5 && type == 0) {\n      return _native.Engine.TEXTURE_FORMAT_RGBA8;\n    } else if (format == 5 && type == 2) {\n      return _native.Engine.TEXTURE_FORMAT_RGBA16F;\n    } else if (format == 5 && type == 1) {\n      return _native.Engine.TEXTURE_FORMAT_RGBA32F;\n    } else {\n      throw new RuntimeError(`Unsupported texture format or type: format ${format}, type ${type}.`, ErrorCodes.UnsupportedTextureError);\n    }\n  }\n  _getNativeAlphaMode(mode) {\n    switch (mode) {\n      case 0:\n        return _native.Engine.ALPHA_DISABLE;\n      case 1:\n        return _native.Engine.ALPHA_ADD;\n      case 2:\n        return _native.Engine.ALPHA_COMBINE;\n      case 3:\n        return _native.Engine.ALPHA_SUBTRACT;\n      case 4:\n        return _native.Engine.ALPHA_MULTIPLY;\n      case 5:\n        return _native.Engine.ALPHA_MAXIMIZED;\n      case 6:\n        return _native.Engine.ALPHA_ONEONE;\n      case 7:\n        return _native.Engine.ALPHA_PREMULTIPLIED;\n      case 8:\n        return _native.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF;\n      case 9:\n        return _native.Engine.ALPHA_INTERPOLATE;\n      case 10:\n        return _native.Engine.ALPHA_SCREENMODE;\n      default:\n        throw new Error(`Unsupported alpha mode: ${mode}.`);\n    }\n  }\n  _getNativeAttribType(type) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n        return _native.Engine.ATTRIB_TYPE_INT8;\n      case VertexBuffer.UNSIGNED_BYTE:\n        return _native.Engine.ATTRIB_TYPE_UINT8;\n      case VertexBuffer.SHORT:\n        return _native.Engine.ATTRIB_TYPE_INT16;\n      case VertexBuffer.UNSIGNED_SHORT:\n        return _native.Engine.ATTRIB_TYPE_UINT16;\n      case VertexBuffer.FLOAT:\n        return _native.Engine.ATTRIB_TYPE_FLOAT;\n      default:\n        throw new Error(`Unsupported attribute type: ${type}.`);\n    }\n  }\n  getFontOffset(font) {\n    // TODO\n    const result = {\n      ascent: 0,\n      height: 0,\n      descent: 0\n    };\n    return result;\n  }\n  _readTexturePixels(texture, width, height, faceIndex, level, buffer, _flushRenderer, _noDataConversion, x, y) {\n    var _a, _b, _c, _d;\n    if (faceIndex !== undefined && faceIndex !== -1) {\n      throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);\n    }\n    return this._engine.readTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level !== null && level !== void 0 ? level : 0, x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0, width, height, (_b = buffer === null || buffer === void 0 ? void 0 : buffer.buffer) !== null && _b !== void 0 ? _b : null, (_c = buffer === null || buffer === void 0 ? void 0 : buffer.byteOffset) !== null && _c !== void 0 ? _c : 0, (_d = buffer === null || buffer === void 0 ? void 0 : buffer.byteLength) !== null && _d !== void 0 ? _d : 0).then(rawBuffer => {\n      if (!buffer) {\n        buffer = new Uint8Array(rawBuffer);\n      }\n      return buffer;\n    });\n  }\n}\n// This must match the protocol version in NativeEngine.cpp\nNativeEngine.PROTOCOL_VERSION = 8;","map":{"version":3,"mappings":"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","names":["Engine","VertexBuffer","InternalTexture","InternalTextureSource","Texture","DataBuffer","Tools","Observable","CreateImageDataArrayBufferViews","GetEnvInfo","UploadEnvSpherical","Logger","ThinEngine","EngineStore","ShaderCodeInliner","WebGL2ShaderProcessor","NativeDataStream","RuntimeError","ErrorCodes","NativePipelineContext","NativeRenderTargetWrapper","NativeHardwareTexture","onNativeObjectInitialized","self","Object","prototype","hasOwnProperty","call","__native","defineProperty","get","set","value","notifyObservers","AcquireNativeObjectAsync","Promise","resolve","_native","addOnce","nativeObject","RegisterNativeTypeAsync","typeName","constructor","NativeDataBuffer","CommandBufferEncoder","_engine","Array","_commandStream","NativeEngine","_createNativeDataStream","setCommandDataStream","beginCommandScope","_isCommandBufferScopeActive","Error","endCommandScope","_submit","startEncodingCommand","command","writeNativeData","encodeCommandArgAsUInt32","commandArg","writeUint32","encodeCommandArgAsUInt32s","writeUint32Array","encodeCommandArgAsInt32","writeInt32","encodeCommandArgAsInt32s","writeInt32Array","encodeCommandArgAsFloat32","writeFloat32","encodeCommandArgAsFloat32s","writeFloat32Array","encodeCommandArgAsNativeData","_pending","push","finishEncodingCommand","submitCommands","length","options","undefined","adaptToDeviceRatio","Camera","DEPTH_TEST_LEQUAL","PROTOCOL_VERSION","_webGLVersion","disableUniformBuffers","_shaderPlatformName","_caps","maxTexturesImageUnits","maxVertexTextureImageUnits","maxCombinedTexturesImageUnits","maxTextureSize","CAPS_LIMITS_MAX_TEXTURE_SIZE","maxCubemapTextureSize","maxRenderTextureSize","maxVertexAttribs","maxVaryingVectors","maxFragmentUniformVectors","maxVertexUniformVectors","standardDerivatives","astc","pvrtc","etc1","etc2","bptc","maxAnisotropy","uintIndices","fragmentDepthSupported","highPrecisionShaderSupported","colorBufferFloat","textureFloat","textureFloatLinearFiltering","textureFloatRender","textureHalfFloat","textureHalfFloatLinearFiltering","textureHalfFloatRender","textureLOD","drawBuffersExtension","depthTextureExtension","vertexArrayObject","instancedArrays","supportOcclusionQuery","canUseTimestampForTimerQuery","blendMinMax","maxMSAASamples","canUseGLInstanceID","canUseGLVertexID","supportComputeShaders","supportSRGBBuffers","supportTransformFeedbacks","textureMaxLevel","texture2DArrayMaxLayerCount","CAPS_LIMITS_MAX_TEXTURE_LAYERS","_features","forceBitmapOverHTMLImageElement","supportRenderAndCopyToLodForFloatTextures","supportDepthStencilTexture","supportShadowSamplers","uniformBufferHardCheckMatrix","allowTexturePrefiltering","trackUbosInFrame","checkUbosContentBeforeUpload","supportCSM","basisNeedsPOT","support3DTextures","needTypeSuffixInShaderConstants","supportMSAA","supportSSAO2","supportExtendedTextureFormats","supportSwitchCaseInShader","supportSyncTextureRead","needsInvertingBitmap","useUBOBindingCache","needShaderCodeInlining","needToAlwaysBindUniformBuffers","supportRenderPasses","supportSpriteInstancing","_collectUbosUpdatedInFrame","Log","Version","LoadScript","scriptUrl","onSuccess","onError","scriptId","LoadFile","data","Function","apply","request","exception","URL","window","createObjectURL","revokeObjectURL","Blob","v","flat","configurable","depth","isNaN","arguments","Number","reduce","acc","cur","isArray","slice","writable","devicePixelRatio","_hardwareScalingLevel","resize","currentDepthFunction","getDepthFunction","setDepthFunction","_shaderProcessor","onNewSceneAddedObservable","add","scene","originalRender","render","args","_commandBufferEncoder","getHardwareScalingLevel","setHardwareScalingLevel","level","dispose","_boundBuffersVertexArray","_deleteVertexArray","_queueNewFrame","bindedRenderFunction","requester","requestAnimationFrame","_bindUnboundFramebuffer","framebuffer","_currentFramebuffer","COMMAND_UNBINDFRAMEBUFFER","COMMAND_BINDFRAMEBUFFER","getHostDocument","clear","color","backBuffer","stencil","useReverseDepthBuffer","COMMAND_CLEAR","r","g","b","a","createIndexBuffer","indices","updateable","_normalizeIndexData","buffer","references","is32Bits","BYTES_PER_ELEMENT","byteLength","nativeIndexBuffer","byteOffset","createVertexBuffer","vertices","ArrayBuffer","isView","Float32Array","nativeVertexBuffer","_recordVertexArrayObject","vertexArray","vertexBuffers","indexBuffer","effect","overrideVertexBuffers","recordIndexBuffer","attributes","getAttributesNames","index","location","getAttributeLocation","kind","vertexBuffer","getBuffer","recordVertexBuffer","byteStride","getSize","_getNativeAttribType","type","normalized","getInstanceDivisor","bindBuffers","createVertexArray","bindVertexArrayObject","recordVertexArrayObject","COMMAND_DELETEVERTEXARRAY","COMMAND_BINDVERTEXARRAY","releaseVertexArrayObject","getAttributes","pipelineContext","attributesNames","nativePipelineContext","nativeProgram","drawElementsType","fillMode","indexStart","indexCount","instancesCount","_drawCalls","addCount","COMMAND_DRAWINDEXED","drawArraysType","verticesStart","verticesCount","COMMAND_DRAW","createPipelineContext","createMaterialContext","createDrawContext","_preparePipelineContext","vertexSourceCode","fragmentSourceCode","createAsRaw","_rawVertexSourceCode","_rawFragmentSourceCode","_rebuildRebind","defines","createRawShaderProgram","createShaderProgram","_isRenderingStateCompiled","_executeWhenRenderingStateIsCompiled","action","_pipelineContext","vertexCode","fragmentCode","onBeforeShaderCompilationObservable","vertexInliner","processCode","code","fragmentInliner","_ConcatenateShader","program","createProgram","onAfterShaderCompilationObservable","inlineShaderCode","sci","debug","_setProgram","_currentProgram","COMMAND_SETPROGRAM","_deletePipelineContext","COMMAND_DELETEPROGRAM","getUniforms","uniformsNames","bindUniformBlock","blockName","bindSamplers","getPipelineContext","samplers","getSamplers","uniform","getUniform","_boundUniforms","_currentEffect","getRenderWidth","useScreen","_currentRenderTarget","width","getRenderHeight","height","setViewport","viewport","requiredWidth","requiredHeight","_cachedViewport","COMMAND_SETVIEWPORT","x","y","setState","culling","zOffset","force","reverseSide","cullBackFaces","zOffsetUnits","_zOffset","_zOffsetUnits","COMMAND_SETSTATE","getInputElementClientRect","rect","bottom","left","right","top","toJSON","setZOffset","COMMAND_SETZOFFSET","getZOffset","setZOffsetUnits","COMMAND_SETZOFFSETUNITS","getZOffsetUnits","setDepthBuffer","enable","COMMAND_SETDEPTHTEST","_currentDepthTest","DEPTH_TEST_ALWAYS","getDepthWrite","_depthWrite","DEPTH_TEST_NEVER","DEPTH_TEST_GREATER","DEPTH_TEST_GEQUAL","DEPTH_TEST_NOTEQUAL","DEPTH_TEST_EQUAL","DEPTH_TEST_LESS","depthFunc","nativeDepthFunc","setDepthWrite","COMMAND_SETDEPTHWRITE","setColorWrite","_colorWrite","COMMAND_SETCOLORWRITE","getColorWrite","applyStencil","_setStencil","_stencilMask","_getStencilOpFail","_stencilOpStencilFail","_getStencilDepthFail","_stencilOpDepthFail","_getStencilDepthPass","_stencilOpStencilDepthPass","_getStencilFunc","_stencilFunc","_stencilFuncRef","mask","stencilOpFail","depthOpFail","depthOpPass","func","ref","COMMAND_SETSTENCIL","setStencilBuffer","_stencilTest","STENCIL_OP_FAIL_S_KEEP","STENCIL_OP_FAIL_Z_KEEP","STENCIL_OP_PASS_Z_KEEP","STENCIL_TEST_ALWAYS","getStencilBuffer","getStencilOperationPass","setStencilOperationPass","operation","setStencilMask","setStencilFunction","stencilFunc","setStencilFunctionReference","reference","setStencilFunctionMask","_stencilFuncMask","setStencilOperationFail","setStencilOperationDepthFail","getStencilMask","getStencilFunction","getStencilFunctionReference","getStencilFunctionMask","getStencilOperationFail","getStencilOperationDepthFail","setAlphaConstants","setAlphaMode","mode","noDepthWriteChange","_alphaMode","nativeMode","_getNativeAlphaMode","COMMAND_SETBLENDMODE","getAlphaMode","setInt","int","COMMAND_SETINT","setIntArray","array","COMMAND_SETINTARRAY","setIntArray2","COMMAND_SETINTARRAY2","setIntArray3","COMMAND_SETINTARRAY3","setIntArray4","COMMAND_SETINTARRAY4","setFloatArray","COMMAND_SETFLOATARRAY","setFloatArray2","COMMAND_SETFLOATARRAY2","setFloatArray3","COMMAND_SETFLOATARRAY3","setFloatArray4","COMMAND_SETFLOATARRAY4","setArray","setArray2","setArray3","setArray4","setMatrices","matrices","COMMAND_SETMATRICES","setMatrix3x3","matrix","COMMAND_SETMATRIX3X3","setMatrix2x2","COMMAND_SETMATRIX2X2","setFloat","COMMAND_SETFLOAT","setFloat2","COMMAND_SETFLOAT2","setFloat3","z","COMMAND_SETFLOAT3","setFloat4","w","COMMAND_SETFLOAT4","setColor3","color3","setColor4","alpha","wipeCaches","bruteForce","preventCacheWipeBetweenFrames","resetTextureCache","_stencilStateComposer","reset","_depthCullingState","_alphaState","_cachedVertexBuffers","_cachedIndexBuffer","_cachedEffectForVertexBuffers","_createTexture","createTexture","_deleteTexture","texture","deleteTexture","updateDynamicTexture","canvas","invertY","premulAlpha","format","_hardwareTexture","source","getCanvasTexture","destination","underlyingResource","copyTexture","isReady","createDynamicTexture","generateMipMaps","samplingMode","Math","max","createRawTexture","Uint8Array","createVideoElement","constraints","_camera","createVideo","updateVideoTexture","video","webGLTexture","compression","Raw","baseWidth","baseHeight","_compression","_useSRGBBuffer","_getUseSRGBBuffer","useSRGBBuffer","updateRawTexture","filter","_getNativeSamplingMode","_setTextureSampling","_internalTexturesCache","createRawTexture2DArray","textureType","Raw2DArray","baseDepth","is2DArray","nativeTexture","loadRawTexture2DArray","_getNativeTextureFormat","bufferView","loadRawTexture","url","noMipmap","mimeType","loaderOptions","fromData","substr","isBase64","indexOf","fallback","Url","originalUrl","_transformTextureUrl","lastDot","lastIndexOf","extension","forcedExtension","substring","toLowerCase","loader","availableLoader","_TextureLoaders","canLoad","addPendingData","doNotHandleContextLost","_buffer","onLoadObserver","onLoad","onLoadedObservable","onInternalError","message","removePendingData","remove","UseFallbackTexture","FallbackTexture","Warn","onload","loadTexture","getTextureWidth","getTextureHeight","DecodeBase64","_loadFile","responseURL","wrapNativeTexture","hardwareTexture","internalTexture","Unknown","wrapWebGLTexture","_createDepthStencilTexture","size","rtWrapper","nativeRTWrapper","DepthStencil","createFrameBuffer","_framebufferDepthStencil","_releaseFramebufferObjects","COMMAND_DELETEFRAMEBUFFER","_createImageBitmapFromSource","imageSource","promise","reject","image","createCanvasImage","imageBitmap","createImageBitmap","error","src","onerror","arr","resizeImageBitmap","bufferWidth","bufferHeight","createCubeTexture","rootUrl","files","createPolynomials","lodScale","lodOffset","Cube","isCube","_lodGenerationScale","_lodGenerationOffset","_doNotHandleContextLost","_extension","_files","onloaddata","info","specularInfo","specular","lodGenerationScale","imageData","getEngine","updateTextureSamplingMode","TRILINEAR_SAMPLINGMODE","_isRGBD","loadCubeTextureWithMips","status","statusText","reorderedFiles","all","map","file","LoadFileAsync","then","loadCubeTexture","_createHardwareTexture","_createHardwareRenderTargetWrapper","isMulti","_renderTargetWrapperCache","_createInternalTexture","_delayGPUTextureCreation","samples","webGLVersion","isWebGPU","layers","nativeTextureFormat","initializeTexture","createRenderTargetTexture","generateDepthBuffer","generateStencilBuffer","noColorAttachment","colorAttachment","RenderTarget","_framebuffer","_generateDepthBuffer","_generateStencilBuffer","setTextures","bindFramebuffer","faceIndex","forceFullscreenViewport","unBindFramebuffer","disableGenerateMipMaps","onBeforeUnbind","createDynamicVertexBuffer","updateDynamicIndexBuffer","offset","updateDynamicVertexBuffer","verticies","_setTexture","channel","isPartOfTextureArray","depthStencilTexture","_boundTexturesCache","_activeChannel","update","delayLoadState","delayLoad","getInternalTexture","emptyCubeTexture","is3D","emptyTexture3D","emptyTexture2DArray","emptyTexture","_setTextureWrapMode","_getAddressMode","wrapU","wrapV","wrapR","_updateAnisotropicLevel","_setTextureCore","COMMAND_SETTEXTURESAMPLING","addressModeU","addressModeV","addressModeW","COMMAND_SETTEXTUREWRAPMODE","COMMAND_SETTEXTURE","anisotropicFilteringLevel","_cachedAnisotropicFilteringLevel","COMMAND_SETTEXTUREANISOTROPICLEVEL","wrapMode","ADDRESS_MODE_WRAP","ADDRESS_MODE_CLAMP","ADDRESS_MODE_MIRROR","_bindTexture","_deleteBuffer","COMMAND_DELETEINDEXBUFFER","COMMAND_DELETEVERTEXBUFFER","createCanvas","Canvas","Image","updateTextureData","xOffset","yOffset","lod","_uploadCompressedDataToTextureDirectly","internalFormat","_uploadDataToTextureDirectly","_uploadArrayBufferViewToTexture","_uploadImageToTexture","TEXTURE_NEAREST_NEAREST","TEXTURE_LINEAR_LINEAR","TEXTURE_LINEAR_LINEAR_MIPLINEAR","TEXTURE_NEAREST_NEAREST_MIPNEAREST","TEXTURE_NEAREST_LINEAR_MIPNEAREST","TEXTURE_NEAREST_LINEAR_MIPLINEAR","TEXTURE_NEAREST_LINEAR","TEXTURE_NEAREST_NEAREST_MIPLINEAR","TEXTURE_LINEAR_NEAREST_MIPNEAREST","TEXTURE_LINEAR_NEAREST_MIPLINEAR","TEXTURE_LINEAR_LINEAR_MIPNEAREST","TEXTURE_LINEAR_NEAREST","STENCIL_TEST_LESS","STENCIL_TEST_LEQUAL","STENCIL_TEST_EQUAL","STENCIL_TEST_GEQUAL","STENCIL_TEST_GREATER","STENCIL_TEST_NOTEQUAL","STENCIL_TEST_NEVER","opFail","STENCIL_OP_FAIL_S_ZERO","STENCIL_OP_FAIL_S_REPLACE","STENCIL_OP_FAIL_S_INCR","STENCIL_OP_FAIL_S_DECR","STENCIL_OP_FAIL_S_INVERT","STENCIL_OP_FAIL_S_INCRSAT","STENCIL_OP_FAIL_S_DECRSAT","depthFail","STENCIL_OP_FAIL_Z_ZERO","STENCIL_OP_FAIL_Z_REPLACE","STENCIL_OP_FAIL_Z_INCR","STENCIL_OP_FAIL_Z_DECR","STENCIL_OP_FAIL_Z_INVERT","STENCIL_OP_FAIL_Z_INCRSAT","STENCIL_OP_FAIL_Z_DECRSAT","opPass","STENCIL_OP_PASS_Z_ZERO","STENCIL_OP_PASS_Z_REPLACE","STENCIL_OP_PASS_Z_INCR","STENCIL_OP_PASS_Z_DECR","STENCIL_OP_PASS_Z_INVERT","STENCIL_OP_PASS_Z_INCRSAT","STENCIL_OP_PASS_Z_DECRSAT","TEXTURE_FORMAT_RGB8","TEXTURE_FORMAT_RGBA8","TEXTURE_FORMAT_RGBA16F","TEXTURE_FORMAT_RGBA32F","UnsupportedTextureError","ALPHA_DISABLE","ALPHA_ADD","ALPHA_COMBINE","ALPHA_SUBTRACT","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","ALPHA_ONEONE","ALPHA_PREMULTIPLIED","ALPHA_PREMULTIPLIED_PORTERDUFF","ALPHA_INTERPOLATE","ALPHA_SCREENMODE","BYTE","ATTRIB_TYPE_INT8","UNSIGNED_BYTE","ATTRIB_TYPE_UINT8","SHORT","ATTRIB_TYPE_INT16","UNSIGNED_SHORT","ATTRIB_TYPE_UINT16","FLOAT","ATTRIB_TYPE_FLOAT","getFontOffset","font","result","ascent","descent","_readTexturePixels","_flushRenderer","_noDataConversion","readTexture","rawBuffer"],"sourceRoot":"","sources":["../../../../lts/core/generated/Engines/nativeEngine.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable, IndicesArray, DataArray } from \"../types\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport type { IInternalTextureLoader } from \"../Materials/Textures/internalTextureLoader\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport type { VideoTexture } from \"../Materials/Textures/videoTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { EnvironmentTextureSpecularInfoV1 } from \"../Misc/environmentTextureTools\";\r\nimport { CreateImageDataArrayBufferViews, GetEnvInfo, UploadEnvSpherical } from \"../Misc/environmentTextureTools\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { RenderTargetCreationOptions, TextureSize, DepthTextureCreationOptions, InternalTextureCreationOptions } from \"../Materials/Textures/textureCreationOptions\";\r\nimport type { IPipelineContext } from \"./IPipelineContext\";\r\nimport type { IColor3Like, IColor4Like, IViewportLike } from \"../Maths/math.like\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Constants } from \"./constants\";\r\nimport type { ISceneLike } from \"./thinEngine\";\r\nimport { ThinEngine } from \"./thinEngine\";\r\nimport type { IWebRequest } from \"../Misc/interfaces/iWebRequest\";\r\nimport { EngineStore } from \"./engineStore\";\r\nimport { ShaderCodeInliner } from \"./Processors/shaderCodeInliner\";\r\nimport { WebGL2ShaderProcessor } from \"../Engines/WebGL/webGL2ShaderProcessors\";\r\nimport type { IMaterialContext } from \"./IMaterialContext\";\r\nimport type { IDrawContext } from \"./IDrawContext\";\r\nimport type { ICanvas, IImage } from \"./ICanvas\";\r\nimport type { IStencilState } from \"../States/IStencilState\";\r\nimport type { RenderTargetWrapper } from \"./renderTargetWrapper\";\r\nimport type { NativeData } from \"./Native/nativeDataStream\";\r\nimport { NativeDataStream } from \"./Native/nativeDataStream\";\r\nimport type { INative, INativeCamera, INativeEngine, NativeFramebuffer, NativeProgram, NativeTexture, NativeUniform, NativeVertexArrayObject } from \"./Native/nativeInterfaces\";\r\nimport { RuntimeError, ErrorCodes } from \"../Misc/error\";\r\nimport { NativePipelineContext } from \"./Native/nativePipelineContext\";\r\nimport { NativeRenderTargetWrapper } from \"./Native/nativeRenderTargetWrapper\";\r\nimport { NativeHardwareTexture } from \"./Native/nativeHardwareTexture\";\r\nimport type { HardwareTextureWrapper } from \"../Materials/Textures/hardwareTextureWrapper\";\r\n\r\ndeclare const _native: INative;\r\n\r\nconst onNativeObjectInitialized = new Observable<INative>();\r\nif (typeof self !== \"undefined\" && !Object.prototype.hasOwnProperty.call(self, \"_native\")) {\r\n    let __native: INative;\r\n    Object.defineProperty(self, \"_native\", {\r\n        get: () => __native,\r\n        set: (value: INative) => {\r\n            __native = value;\r\n            if (__native) {\r\n                onNativeObjectInitialized.notifyObservers(__native);\r\n            }\r\n        },\r\n    });\r\n}\r\n\r\n/**\r\n * Returns _native only after it has been defined by BabylonNative.\r\n * @internal\r\n */\r\nexport function AcquireNativeObjectAsync(): Promise<INative> {\r\n    return new Promise((resolve) => {\r\n        if (typeof _native === \"undefined\") {\r\n            onNativeObjectInitialized.addOnce((nativeObject) => resolve(nativeObject));\r\n        } else {\r\n            resolve(_native);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Registers a constructor on the _native object. See NativeXRFrame for an example.\r\n * @internal\r\n */\r\nexport async function RegisterNativeTypeAsync<Type>(typeName: string, constructor: Type) {\r\n    ((await AcquireNativeObjectAsync()) as any)[typeName] = constructor;\r\n}\r\n\r\n/**\r\n * Container for accessors for natively-stored mesh data buffers.\r\n */\r\nclass NativeDataBuffer extends DataBuffer {\r\n    /**\r\n     * Accessor value used to identify/retrieve a natively-stored index buffer.\r\n     */\r\n    public nativeIndexBuffer?: NativeData;\r\n\r\n    /**\r\n     * Accessor value used to identify/retrieve a natively-stored vertex buffer.\r\n     */\r\n    public nativeVertexBuffer?: NativeData;\r\n}\r\n\r\n/**\r\n * Options to create the Native engine\r\n */\r\nexport interface NativeEngineOptions {\r\n    /**\r\n     * defines whether to adapt to the device's viewport characteristics (default: false)\r\n     */\r\n    adaptToDeviceRatio?: boolean;\r\n}\r\n\r\n/** @internal */\r\nclass CommandBufferEncoder {\r\n    private readonly _commandStream: NativeDataStream;\r\n    private readonly _pending = new Array<NativeData>();\r\n    private _isCommandBufferScopeActive = false;\r\n\r\n    public constructor(private readonly _engine: INativeEngine) {\r\n        this._commandStream = NativeEngine._createNativeDataStream();\r\n        this._engine.setCommandDataStream(this._commandStream);\r\n    }\r\n\r\n    public beginCommandScope() {\r\n        if (this._isCommandBufferScopeActive) {\r\n            throw new Error(\"Command scope already active.\");\r\n        }\r\n\r\n        this._isCommandBufferScopeActive = true;\r\n    }\r\n\r\n    public endCommandScope() {\r\n        if (!this._isCommandBufferScopeActive) {\r\n            throw new Error(\"Command scope is not active.\");\r\n        }\r\n\r\n        this._isCommandBufferScopeActive = false;\r\n        this._submit();\r\n    }\r\n\r\n    public startEncodingCommand(command: NativeData) {\r\n        this._commandStream.writeNativeData(command);\r\n    }\r\n\r\n    public encodeCommandArgAsUInt32(commandArg: number) {\r\n        this._commandStream.writeUint32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsUInt32s(commandArg: Uint32Array) {\r\n        this._commandStream.writeUint32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsInt32(commandArg: number) {\r\n        this._commandStream.writeInt32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsInt32s(commandArg: Int32Array) {\r\n        this._commandStream.writeInt32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsFloat32(commandArg: number) {\r\n        this._commandStream.writeFloat32(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsFloat32s(commandArg: Float32Array) {\r\n        this._commandStream.writeFloat32Array(commandArg);\r\n    }\r\n\r\n    public encodeCommandArgAsNativeData(commandArg: NativeData) {\r\n        this._commandStream.writeNativeData(commandArg);\r\n        this._pending.push(commandArg);\r\n    }\r\n\r\n    public finishEncodingCommand() {\r\n        if (!this._isCommandBufferScopeActive) {\r\n            this._submit();\r\n        }\r\n    }\r\n\r\n    private _submit() {\r\n        this._engine.submitCommands();\r\n        this._pending.length = 0;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class NativeEngine extends Engine {\r\n    // This must match the protocol version in NativeEngine.cpp\r\n    private static readonly PROTOCOL_VERSION = 8;\r\n\r\n    private readonly _engine: INativeEngine = new _native.Engine();\r\n    private readonly _camera: Nullable<INativeCamera> = _native.Camera ? new _native.Camera() : null;\r\n\r\n    private readonly _commandBufferEncoder = new CommandBufferEncoder(this._engine);\r\n\r\n    private _boundBuffersVertexArray: any = null;\r\n    private _currentDepthTest: number = _native.Engine.DEPTH_TEST_LEQUAL;\r\n    private _stencilTest = false;\r\n    private _stencilMask: number = 255;\r\n    private _stencilFunc: number = Constants.ALWAYS;\r\n    private _stencilFuncRef: number = 0;\r\n    private _stencilFuncMask: number = 255;\r\n    private _stencilOpStencilFail: number = Constants.KEEP;\r\n    private _stencilOpDepthFail: number = Constants.KEEP;\r\n    private _stencilOpStencilDepthPass: number = Constants.REPLACE;\r\n    private _zOffset: number = 0;\r\n    private _zOffsetUnits: number = 0;\r\n    private _depthWrite: boolean = true;\r\n\r\n    public getHardwareScalingLevel(): number {\r\n        return this._engine.getHardwareScalingLevel();\r\n    }\r\n\r\n    public setHardwareScalingLevel(level: number): void {\r\n        this._engine.setHardwareScalingLevel(level);\r\n    }\r\n\r\n    public constructor(options: NativeEngineOptions = {}) {\r\n        super(null, false, undefined, options.adaptToDeviceRatio);\r\n\r\n        if (_native.Engine.PROTOCOL_VERSION !== NativeEngine.PROTOCOL_VERSION) {\r\n            throw new Error(`Protocol version mismatch: ${_native.Engine.PROTOCOL_VERSION} (Native) !== ${NativeEngine.PROTOCOL_VERSION} (JS)`);\r\n        }\r\n\r\n        this._webGLVersion = 2;\r\n        this.disableUniformBuffers = true;\r\n        this._shaderPlatformName = \"NATIVE\";\r\n\r\n        // TODO: Initialize this more correctly based on the hardware capabilities.\r\n        // Init caps\r\n\r\n        this._caps = {\r\n            maxTexturesImageUnits: 16,\r\n            maxVertexTextureImageUnits: 16,\r\n            maxCombinedTexturesImageUnits: 32,\r\n            maxTextureSize: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_SIZE,\r\n            maxCubemapTextureSize: 512,\r\n            maxRenderTextureSize: 512,\r\n            maxVertexAttribs: 16,\r\n            maxVaryingVectors: 16,\r\n            maxFragmentUniformVectors: 16,\r\n            maxVertexUniformVectors: 16,\r\n            standardDerivatives: true,\r\n            astc: null,\r\n            pvrtc: null,\r\n            etc1: null,\r\n            etc2: null,\r\n            bptc: null,\r\n            maxAnisotropy: 16, // TODO: Retrieve this smartly. Currently set to D3D11 maximum allowable value.\r\n            uintIndices: true,\r\n            fragmentDepthSupported: false,\r\n            highPrecisionShaderSupported: true,\r\n            colorBufferFloat: false,\r\n            textureFloat: true,\r\n            textureFloatLinearFiltering: false,\r\n            textureFloatRender: false,\r\n            textureHalfFloat: false,\r\n            textureHalfFloatLinearFiltering: false,\r\n            textureHalfFloatRender: false,\r\n            textureLOD: true,\r\n            drawBuffersExtension: false,\r\n            depthTextureExtension: false,\r\n            vertexArrayObject: true,\r\n            instancedArrays: true,\r\n            supportOcclusionQuery: false,\r\n            canUseTimestampForTimerQuery: false,\r\n            blendMinMax: false,\r\n            maxMSAASamples: 1,\r\n            canUseGLInstanceID: true,\r\n            canUseGLVertexID: true,\r\n            supportComputeShaders: false,\r\n            supportSRGBBuffers: true,\r\n            supportTransformFeedbacks: false,\r\n            textureMaxLevel: false,\r\n            texture2DArrayMaxLayerCount: _native.Engine.CAPS_LIMITS_MAX_TEXTURE_LAYERS,\r\n        };\r\n\r\n        this._features = {\r\n            forceBitmapOverHTMLImageElement: false,\r\n            supportRenderAndCopyToLodForFloatTextures: false,\r\n            supportDepthStencilTexture: false,\r\n            supportShadowSamplers: false,\r\n            uniformBufferHardCheckMatrix: false,\r\n            allowTexturePrefiltering: false,\r\n            trackUbosInFrame: false,\r\n            checkUbosContentBeforeUpload: false,\r\n            supportCSM: false,\r\n            basisNeedsPOT: false,\r\n            support3DTextures: false,\r\n            needTypeSuffixInShaderConstants: false,\r\n            supportMSAA: false,\r\n            supportSSAO2: false,\r\n            supportExtendedTextureFormats: false,\r\n            supportSwitchCaseInShader: false,\r\n            supportSyncTextureRead: false,\r\n            needsInvertingBitmap: true,\r\n            useUBOBindingCache: true,\r\n            needShaderCodeInlining: true,\r\n            needToAlwaysBindUniformBuffers: false,\r\n            supportRenderPasses: true,\r\n            supportSpriteInstancing: false,\r\n            _collectUbosUpdatedInFrame: false,\r\n        };\r\n\r\n        Tools.Log(\"Babylon Native (v\" + Engine.Version + \") launched\");\r\n\r\n        Tools.LoadScript = function (scriptUrl, onSuccess, onError, scriptId) {\r\n            Tools.LoadFile(\r\n                scriptUrl,\r\n                (data) => {\r\n                    Function(data as string).apply(null);\r\n                    if (onSuccess) {\r\n                        onSuccess();\r\n                    }\r\n                },\r\n                undefined,\r\n                undefined,\r\n                false,\r\n                (request, exception) => {\r\n                    if (onError) {\r\n                        onError(\"LoadScript Error\", exception);\r\n                    }\r\n                }\r\n            );\r\n        };\r\n\r\n        // Wrappers\r\n        if (typeof URL === \"undefined\") {\r\n            (window.URL as any) = {\r\n                createObjectURL: function () {},\r\n                revokeObjectURL: function () {},\r\n            };\r\n        }\r\n\r\n        if (typeof Blob === \"undefined\") {\r\n            (window.Blob as any) = function (v: any) {\r\n                return v;\r\n            };\r\n        }\r\n\r\n        // polyfill for Chakra\r\n        if (!Array.prototype.flat) {\r\n            Object.defineProperty(Array.prototype, \"flat\", {\r\n                configurable: true,\r\n                value: function flat() {\r\n                    const depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\r\n\r\n                    return depth\r\n                        ? Array.prototype.reduce.call(\r\n                              this,\r\n                              function (acc: any, cur: any) {\r\n                                  if (Array.isArray(cur)) {\r\n                                      acc.push.apply(acc, flat.call(cur, depth - 1));\r\n                                  } else {\r\n                                      acc.push(cur);\r\n                                  }\r\n                                  return acc;\r\n                              },\r\n                              []\r\n                          )\r\n                        : Array.prototype.slice.call(this);\r\n                },\r\n                writable: true,\r\n            });\r\n        }\r\n        // Currently we do not fully configure the ThinEngine on construction of NativeEngine.\r\n        // Setup resolution scaling based on display settings.\r\n        const devicePixelRatio = window ? window.devicePixelRatio || 1.0 : 1.0;\r\n        this._hardwareScalingLevel = options.adaptToDeviceRatio ? devicePixelRatio : 1.0;\r\n        this.resize();\r\n\r\n        const currentDepthFunction = this.getDepthFunction();\r\n        if (currentDepthFunction) {\r\n            this.setDepthFunction(currentDepthFunction);\r\n        }\r\n\r\n        // Shader processor\r\n        this._shaderProcessor = new WebGL2ShaderProcessor();\r\n\r\n        this.onNewSceneAddedObservable.add((scene) => {\r\n            const originalRender = scene.render;\r\n            scene.render = (...args: Parameters<typeof originalRender>) => {\r\n                this._commandBufferEncoder.beginCommandScope();\r\n                originalRender.apply(scene, args);\r\n                this._commandBufferEncoder.endCommandScope();\r\n            };\r\n        });\r\n    }\r\n\r\n    public dispose(): void {\r\n        super.dispose();\r\n        if (this._boundBuffersVertexArray) {\r\n            this._deleteVertexArray(this._boundBuffersVertexArray);\r\n        }\r\n        this._engine.dispose();\r\n    }\r\n\r\n    /** @internal */\r\n    public static _createNativeDataStream(): NativeDataStream {\r\n        return new NativeDataStream();\r\n    }\r\n\r\n    /**\r\n     * Can be used to override the current requestAnimationFrame requester.\r\n     * @internal\r\n     */\r\n    protected _queueNewFrame(bindedRenderFunction: any, requester?: any): number {\r\n        // Use the provided requestAnimationFrame, unless the requester is the window. In that case, we will default to the Babylon Native version of requestAnimationFrame.\r\n        if (requester.requestAnimationFrame && requester !== window) {\r\n            requester.requestAnimationFrame(bindedRenderFunction);\r\n        } else {\r\n            this._engine.requestAnimationFrame(bindedRenderFunction);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Override default engine behavior.\r\n     * @param framebuffer\r\n     */\r\n    public _bindUnboundFramebuffer(framebuffer: Nullable<WebGLFramebuffer>) {\r\n        if (this._currentFramebuffer !== framebuffer) {\r\n            if (this._currentFramebuffer) {\r\n                this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_UNBINDFRAMEBUFFER);\r\n                this._commandBufferEncoder.encodeCommandArgAsNativeData(this._currentFramebuffer as NativeFramebuffer);\r\n                this._commandBufferEncoder.finishEncodingCommand();\r\n            }\r\n\r\n            if (framebuffer) {\r\n                this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDFRAMEBUFFER);\r\n                this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer as NativeFramebuffer);\r\n                this._commandBufferEncoder.finishEncodingCommand();\r\n            }\r\n\r\n            this._currentFramebuffer = framebuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets host document\r\n     * @returns the host document object\r\n     */\r\n    public getHostDocument(): Nullable<Document> {\r\n        return null;\r\n    }\r\n\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil: boolean = false): void {\r\n        if (this.useReverseDepthBuffer) {\r\n            throw new Error(\"reverse depth buffer is not currently implemented\");\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_CLEAR);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(backBuffer && color ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.r : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.g : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.b : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(color ? color.a : 1);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depth ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(1);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(stencil ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public createIndexBuffer(indices: IndicesArray, updateable?: boolean): NativeDataBuffer {\r\n        const data = this._normalizeIndexData(indices);\r\n        const buffer = new NativeDataBuffer();\r\n        buffer.references = 1;\r\n        buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        if (data.byteLength) {\r\n            buffer.nativeIndexBuffer = this._engine.createIndexBuffer(data.buffer, data.byteOffset, data.byteLength, buffer.is32Bits, updateable ?? false);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    public createVertexBuffer(vertices: DataArray, updateable?: boolean): NativeDataBuffer {\r\n        const data = ArrayBuffer.isView(vertices) ? vertices : new Float32Array(vertices);\r\n        const buffer = new NativeDataBuffer();\r\n        buffer.references = 1;\r\n        if (data.byteLength) {\r\n            buffer.nativeVertexBuffer = this._engine.createVertexBuffer(data.buffer, data.byteOffset, data.byteLength, updateable ?? false);\r\n        }\r\n        return buffer;\r\n    }\r\n\r\n    protected _recordVertexArrayObject(\r\n        vertexArray: any,\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<NativeDataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): void {\r\n        if (indexBuffer) {\r\n            this._engine.recordIndexBuffer(vertexArray, indexBuffer.nativeIndexBuffer!);\r\n        }\r\n\r\n        const attributes = effect.getAttributesNames();\r\n        for (let index = 0; index < attributes.length; index++) {\r\n            const location = effect.getAttributeLocation(index);\r\n            if (location >= 0) {\r\n                const kind = attributes[index];\r\n                let vertexBuffer: Nullable<VertexBuffer> = null;\r\n\r\n                if (overrideVertexBuffers) {\r\n                    vertexBuffer = overrideVertexBuffers[kind];\r\n                }\r\n                if (!vertexBuffer) {\r\n                    vertexBuffer = vertexBuffers[kind];\r\n                }\r\n\r\n                if (vertexBuffer) {\r\n                    const buffer = vertexBuffer.getBuffer() as Nullable<NativeDataBuffer>;\r\n                    if (buffer && buffer.nativeVertexBuffer) {\r\n                        this._engine.recordVertexBuffer(\r\n                            vertexArray,\r\n                            buffer.nativeVertexBuffer!,\r\n                            location,\r\n                            vertexBuffer.byteOffset,\r\n                            vertexBuffer.byteStride,\r\n                            vertexBuffer.getSize(),\r\n                            this._getNativeAttribType(vertexBuffer.type),\r\n                            vertexBuffer.normalized,\r\n                            vertexBuffer.getInstanceDivisor()\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public bindBuffers(vertexBuffers: { [key: string]: VertexBuffer }, indexBuffer: Nullable<NativeDataBuffer>, effect: Effect): void {\r\n        if (this._boundBuffersVertexArray) {\r\n            this._deleteVertexArray(this._boundBuffersVertexArray);\r\n        }\r\n        this._boundBuffersVertexArray = this._engine.createVertexArray();\r\n        this._recordVertexArrayObject(this._boundBuffersVertexArray, vertexBuffers, indexBuffer, effect);\r\n        this.bindVertexArrayObject(this._boundBuffersVertexArray);\r\n    }\r\n\r\n    public recordVertexArrayObject(\r\n        vertexBuffers: { [key: string]: VertexBuffer },\r\n        indexBuffer: Nullable<NativeDataBuffer>,\r\n        effect: Effect,\r\n        overrideVertexBuffers?: { [kind: string]: Nullable<VertexBuffer> }\r\n    ): WebGLVertexArrayObject {\r\n        const vertexArray = this._engine.createVertexArray();\r\n        this._recordVertexArrayObject(vertexArray, vertexBuffers, indexBuffer, effect, overrideVertexBuffers);\r\n        return vertexArray;\r\n    }\r\n\r\n    private _deleteVertexArray(vertexArray: NativeVertexArrayObject) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public bindVertexArrayObject(vertexArray: WebGLVertexArrayObject): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_BINDVERTEXARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(vertexArray as NativeVertexArrayObject);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public releaseVertexArrayObject(vertexArray: WebGLVertexArrayObject) {\r\n        this._deleteVertexArray(vertexArray as NativeVertexArrayObject);\r\n    }\r\n\r\n    public getAttributes(pipelineContext: IPipelineContext, attributesNames: string[]): number[] {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        return this._engine.getAttributes(nativePipelineContext.nativeProgram, attributesNames);\r\n    }\r\n\r\n    /**\r\n     * Draw a list of indexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param indexStart defines the starting index\r\n     * @param indexCount defines the number of index to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawElementsType(fillMode: number, indexStart: number, indexCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this._drawCalls.addCount(1, false);\r\n\r\n        // TODO: Make this implementation more robust like core Engine version.\r\n\r\n        // Render\r\n        //var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;\r\n\r\n        //var mult = this._uintIndicesCurrentlySet ? 4 : 2;\r\n        // if (instancesCount) {\r\n        //     this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);\r\n        // } else {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAWINDEXED);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(indexStart);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(indexCount);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        // }\r\n    }\r\n\r\n    /**\r\n     * Draw a list of unindexed primitives\r\n     * @param fillMode defines the primitive to use\r\n     * @param verticesStart defines the index of first vertex to draw\r\n     * @param verticesCount defines the count of vertices to draw\r\n     * @param instancesCount defines the number of instances to draw (if instantiation is enabled)\r\n     */\r\n    public drawArraysType(fillMode: number, verticesStart: number, verticesCount: number, instancesCount?: number): void {\r\n        // Apply states\r\n        this._drawCalls.addCount(1, false);\r\n\r\n        // TODO: Make this implementation more robust like core Engine version.\r\n\r\n        // if (instancesCount) {\r\n        //     this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);\r\n        // } else {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DRAW);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(fillMode);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesStart);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(verticesCount);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        // }\r\n    }\r\n\r\n    public createPipelineContext(): IPipelineContext {\r\n        return new NativePipelineContext(this);\r\n    }\r\n\r\n    public createMaterialContext(): IMaterialContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    public createDrawContext(): IDrawContext | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    public _preparePipelineContext(\r\n        pipelineContext: IPipelineContext,\r\n        vertexSourceCode: string,\r\n        fragmentSourceCode: string,\r\n        createAsRaw: boolean,\r\n        _rawVertexSourceCode: string,\r\n        _rawFragmentSourceCode: string,\r\n        _rebuildRebind: any,\r\n        defines: Nullable<string>\r\n    ) {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n\r\n        if (createAsRaw) {\r\n            nativePipelineContext.nativeProgram = this.createRawShaderProgram();\r\n        } else {\r\n            nativePipelineContext.nativeProgram = this.createShaderProgram(pipelineContext, vertexSourceCode, fragmentSourceCode, defines);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isRenderingStateCompiled(pipelineContext: IPipelineContext): boolean {\r\n        // TODO: support async shader compilcation\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _executeWhenRenderingStateIsCompiled(pipelineContext: IPipelineContext, action: () => void) {\r\n        // TODO: support async shader compilcation\r\n        action();\r\n    }\r\n\r\n    public createRawShaderProgram(): WebGLProgram {\r\n        throw new Error(\"Not Supported\");\r\n    }\r\n\r\n    public createShaderProgram(_pipelineContext: IPipelineContext, vertexCode: string, fragmentCode: string, defines: Nullable<string>): WebGLProgram {\r\n        this.onBeforeShaderCompilationObservable.notifyObservers(this);\r\n\r\n        const vertexInliner = new ShaderCodeInliner(vertexCode);\r\n        vertexInliner.processCode();\r\n        vertexCode = vertexInliner.code;\r\n\r\n        const fragmentInliner = new ShaderCodeInliner(fragmentCode);\r\n        fragmentInliner.processCode();\r\n        fragmentCode = fragmentInliner.code;\r\n\r\n        vertexCode = ThinEngine._ConcatenateShader(vertexCode, defines);\r\n        fragmentCode = ThinEngine._ConcatenateShader(fragmentCode, defines);\r\n\r\n        const program = this._engine.createProgram(vertexCode, fragmentCode);\r\n        this.onAfterShaderCompilationObservable.notifyObservers(this);\r\n        return program as WebGLProgram;\r\n    }\r\n\r\n    /**\r\n     * Inline functions in shader code that are marked to be inlined\r\n     * @param code code to inline\r\n     * @returns inlined code\r\n     */\r\n    public inlineShaderCode(code: string): string {\r\n        const sci = new ShaderCodeInliner(code);\r\n        sci.debug = false;\r\n        sci.processCode();\r\n        return sci.code;\r\n    }\r\n\r\n    protected _setProgram(program: WebGLProgram): void {\r\n        if (this._currentProgram !== program) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETPROGRAM);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(program as NativeProgram);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            this._currentProgram = program;\r\n        }\r\n    }\r\n\r\n    public _deletePipelineContext(pipelineContext: IPipelineContext): void {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        if (nativePipelineContext && nativePipelineContext.nativeProgram) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEPROGRAM);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(nativePipelineContext.nativeProgram);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    public getUniforms(pipelineContext: IPipelineContext, uniformsNames: string[]): WebGLUniformLocation[] {\r\n        const nativePipelineContext = pipelineContext as NativePipelineContext;\r\n        return this._engine.getUniforms(nativePipelineContext.nativeProgram, uniformsNames);\r\n    }\r\n\r\n    public bindUniformBlock(pipelineContext: IPipelineContext, blockName: string, index: number): void {\r\n        // TODO\r\n        throw new Error(\"Not Implemented\");\r\n    }\r\n\r\n    public bindSamplers(effect: Effect): void {\r\n        const nativePipelineContext = effect.getPipelineContext() as NativePipelineContext;\r\n        this._setProgram(nativePipelineContext.nativeProgram);\r\n\r\n        // TODO: share this with engine?\r\n        const samplers = effect.getSamplers();\r\n        for (let index = 0; index < samplers.length; index++) {\r\n            const uniform = effect.getUniform(samplers[index]);\r\n\r\n            if (uniform) {\r\n                this._boundUniforms[index] = uniform;\r\n            }\r\n        }\r\n        this._currentEffect = null;\r\n    }\r\n\r\n    public getRenderWidth(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.width;\r\n        }\r\n\r\n        return this._engine.getRenderWidth();\r\n    }\r\n\r\n    public getRenderHeight(useScreen = false): number {\r\n        if (!useScreen && this._currentRenderTarget) {\r\n            return this._currentRenderTarget.height;\r\n        }\r\n\r\n        return this._engine.getRenderHeight();\r\n    }\r\n\r\n    public setViewport(viewport: IViewportLike, requiredWidth?: number, requiredHeight?: number): void {\r\n        this._cachedViewport = viewport;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETVIEWPORT);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.width);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(viewport.height);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    public setState(culling: boolean, zOffset: number = 0, force?: boolean, reverseSide = false, cullBackFaces?: boolean, stencil?: IStencilState, zOffsetUnits: number = 0): void {\r\n        this._zOffset = zOffset;\r\n        this._zOffsetUnits = zOffsetUnits;\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTATE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(culling ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffset);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(zOffsetUnits);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(this.cullBackFaces ?? cullBackFaces ?? true ? 1 : 0);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(reverseSide ? 1 : 0);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets the client rect of native canvas.  Needed for InputManager.\r\n     * @returns a client rectangle\r\n     */\r\n    public getInputElementClientRect(): Nullable<DOMRect> {\r\n        const rect = {\r\n            bottom: this.getRenderHeight(),\r\n            height: this.getRenderHeight(),\r\n            left: 0,\r\n            right: this.getRenderWidth(),\r\n            top: 0,\r\n            width: this.getRenderWidth(),\r\n            x: 0,\r\n            y: 0,\r\n            toJSON: () => {},\r\n        };\r\n        return rect;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Factor to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffset(value: number): void {\r\n        if (value !== this._zOffset) {\r\n            this._zOffset = value;\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSET);\r\n            this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Factor\r\n     * @returns the current zOffset Factor state\r\n     */\r\n    public getZOffset(): number {\r\n        return this._zOffset;\r\n    }\r\n\r\n    /**\r\n     * Set the z offset Units to apply to current rendering\r\n     * @param value defines the offset to apply\r\n     */\r\n    public setZOffsetUnits(value: number): void {\r\n        if (value !== this._zOffsetUnits) {\r\n            this._zOffsetUnits = value;\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETZOFFSETUNITS);\r\n            this._commandBufferEncoder.encodeCommandArgAsFloat32(this.useReverseDepthBuffer ? -value : value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the zOffset Units\r\n     * @returns the current zOffset Units state\r\n     */\r\n    public getZOffsetUnits(): number {\r\n        return this._zOffsetUnits;\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth buffering\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthBuffer(enable: boolean): void {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(enable ? this._currentDepthTest : _native.Engine.DEPTH_TEST_ALWAYS);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if depth writing is enabled\r\n     * @returns the current depth writing state\r\n     */\r\n    public getDepthWrite(): boolean {\r\n        return this._depthWrite;\r\n    }\r\n\r\n    public getDepthFunction(): Nullable<number> {\r\n        switch (this._currentDepthTest) {\r\n            case _native.Engine.DEPTH_TEST_NEVER:\r\n                return Constants.NEVER;\r\n            case _native.Engine.DEPTH_TEST_ALWAYS:\r\n                return Constants.ALWAYS;\r\n            case _native.Engine.DEPTH_TEST_GREATER:\r\n                return Constants.GREATER;\r\n            case _native.Engine.DEPTH_TEST_GEQUAL:\r\n                return Constants.GEQUAL;\r\n            case _native.Engine.DEPTH_TEST_NOTEQUAL:\r\n                return Constants.NOTEQUAL;\r\n            case _native.Engine.DEPTH_TEST_EQUAL:\r\n                return Constants.EQUAL;\r\n            case _native.Engine.DEPTH_TEST_LESS:\r\n                return Constants.LESS;\r\n            case _native.Engine.DEPTH_TEST_LEQUAL:\r\n                return Constants.LEQUAL;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public setDepthFunction(depthFunc: number) {\r\n        let nativeDepthFunc = 0;\r\n        switch (depthFunc) {\r\n            case Constants.NEVER:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_NEVER;\r\n                break;\r\n            case Constants.ALWAYS:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_ALWAYS;\r\n                break;\r\n            case Constants.GREATER:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_GREATER;\r\n                break;\r\n            case Constants.GEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_GEQUAL;\r\n                break;\r\n            case Constants.NOTEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_NOTEQUAL;\r\n                break;\r\n            case Constants.EQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_EQUAL;\r\n                break;\r\n            case Constants.LESS:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_LESS;\r\n                break;\r\n            case Constants.LEQUAL:\r\n                nativeDepthFunc = _native.Engine.DEPTH_TEST_LEQUAL;\r\n                break;\r\n        }\r\n\r\n        this._currentDepthTest = nativeDepthFunc;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHTEST);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(this._currentDepthTest);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable depth writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setDepthWrite(enable: boolean): void {\r\n        this._depthWrite = enable;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETDEPTHWRITE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable color writing\r\n     * @param enable defines the state to set\r\n     */\r\n    public setColorWrite(enable: boolean): void {\r\n        this._colorWrite = enable;\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETCOLORWRITE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(Number(enable));\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if color writing is enabled\r\n     * @returns the current color writing state\r\n     */\r\n    public getColorWrite(): boolean {\r\n        return this._colorWrite;\r\n    }\r\n\r\n    private applyStencil(): void {\r\n        this._setStencil(\r\n            this._stencilMask,\r\n            this._getStencilOpFail(this._stencilOpStencilFail),\r\n            this._getStencilDepthFail(this._stencilOpDepthFail),\r\n            this._getStencilDepthPass(this._stencilOpStencilDepthPass),\r\n            this._getStencilFunc(this._stencilFunc),\r\n            this._stencilFuncRef\r\n        );\r\n    }\r\n\r\n    private _setStencil(mask: number, stencilOpFail: number, depthOpFail: number, depthOpPass: number, func: number, ref: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETSTENCIL);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(mask);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(stencilOpFail);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpFail);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(depthOpPass);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(func);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(ref);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    /**\r\n     * Enable or disable the stencil buffer\r\n     * @param enable defines if the stencil buffer must be enabled or disabled\r\n     */\r\n    public setStencilBuffer(enable: boolean): void {\r\n        this._stencilTest = enable;\r\n        if (enable) {\r\n            this.applyStencil();\r\n        } else {\r\n            this._setStencil(\r\n                255,\r\n                _native.Engine.STENCIL_OP_FAIL_S_KEEP,\r\n                _native.Engine.STENCIL_OP_FAIL_Z_KEEP,\r\n                _native.Engine.STENCIL_OP_PASS_Z_KEEP,\r\n                _native.Engine.STENCIL_TEST_ALWAYS,\r\n                0\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if stencil buffer is enabled\r\n     * @returns the current stencil buffer state\r\n     */\r\n    public getStencilBuffer(): boolean {\r\n        return this._stencilTest;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when stencil passes\r\n     * @returns a number defining stencil operation to use when stencil passes\r\n     */\r\n    public getStencilOperationPass(): number {\r\n        return this._stencilOpStencilDepthPass;\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when stencil passes\r\n     * @param operation defines the stencil operation to use when stencil passes\r\n     */\r\n    public setStencilOperationPass(operation: number): void {\r\n        this._stencilOpStencilDepthPass = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil mask\r\n     * @param mask defines the new stencil mask to use\r\n     */\r\n    public setStencilMask(mask: number): void {\r\n        this._stencilMask = mask;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil function\r\n     * @param stencilFunc defines the new stencil function to use\r\n     */\r\n    public setStencilFunction(stencilFunc: number) {\r\n        this._stencilFunc = stencilFunc;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil reference\r\n     * @param reference defines the new stencil reference to use\r\n     */\r\n    public setStencilFunctionReference(reference: number) {\r\n        this._stencilFuncRef = reference;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the current stencil mask\r\n     * @param mask defines the new stencil mask to use\r\n     */\r\n    public setStencilFunctionMask(mask: number) {\r\n        this._stencilFuncMask = mask;\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when stencil fails\r\n     * @param operation defines the stencil operation to use when stencil fails\r\n     */\r\n    public setStencilOperationFail(operation: number): void {\r\n        this._stencilOpStencilFail = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Sets the stencil operation to use when depth fails\r\n     * @param operation defines the stencil operation to use when depth fails\r\n     */\r\n    public setStencilOperationDepthFail(operation: number): void {\r\n        this._stencilOpDepthFail = operation;\r\n        this.applyStencil();\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil mask\r\n     * @returns a number defining the new stencil mask to use\r\n     */\r\n    public getStencilMask(): number {\r\n        return this._stencilMask;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil function\r\n     * @returns a number defining the stencil function to use\r\n     */\r\n    public getStencilFunction(): number {\r\n        return this._stencilFunc;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil reference value\r\n     * @returns a number defining the stencil reference value to use\r\n     */\r\n    public getStencilFunctionReference(): number {\r\n        return this._stencilFuncRef;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil mask\r\n     * @returns a number defining the stencil mask to use\r\n     */\r\n    public getStencilFunctionMask(): number {\r\n        return this._stencilFuncMask;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when stencil fails\r\n     * @returns a number defining stencil operation to use when stencil fails\r\n     */\r\n    public getStencilOperationFail(): number {\r\n        return this._stencilOpStencilFail;\r\n    }\r\n\r\n    /**\r\n     * Gets the current stencil operation when depth fails\r\n     * @returns a number defining stencil operation to use when depth fails\r\n     */\r\n    public getStencilOperationDepthFail(): number {\r\n        return this._stencilOpDepthFail;\r\n    }\r\n\r\n    /**\r\n     * Sets alpha constants used by some alpha blending modes\r\n     * @param r defines the red component\r\n     * @param g defines the green component\r\n     * @param b defines the blue component\r\n     * @param a defines the alpha component\r\n     */\r\n    public setAlphaConstants(r: number, g: number, b: number, a: number) {\r\n        throw new Error(\"Setting alpha blend constant color not yet implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Sets the current alpha mode\r\n     * @param mode defines the mode to use (one of the BABYLON.Constants.ALPHA_XXX)\r\n     * @param noDepthWriteChange defines if depth writing state should remains unchanged (false by default)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     */\r\n    public setAlphaMode(mode: number, noDepthWriteChange: boolean = false): void {\r\n        if (this._alphaMode === mode) {\r\n            return;\r\n        }\r\n\r\n        const nativeMode = this._getNativeAlphaMode(mode);\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETBLENDMODE);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(nativeMode);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n\r\n        if (!noDepthWriteChange) {\r\n            this.setDepthWrite(mode === Constants.ALPHA_DISABLE);\r\n        }\r\n\r\n        this._alphaMode = mode;\r\n    }\r\n\r\n    /**\r\n     * Gets the current alpha mode\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/advanced/transparent_rendering\r\n     * @returns the current alpha mode\r\n     */\r\n    public getAlphaMode(): number {\r\n        return this._alphaMode;\r\n    }\r\n\r\n    public setInt(uniform: WebGLUniformLocation, int: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINT);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32(int);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray2(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray3(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setIntArray4(uniform: WebGLUniformLocation, array: Int32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETINTARRAY4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsInt32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray2(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray3(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloatArray4(uniform: WebGLUniformLocation, array: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOATARRAY4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(array);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setArray(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray2(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray2(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray3(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray3(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setArray4(uniform: WebGLUniformLocation, array: number[]): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        return this.setFloatArray4(uniform, new Float32Array(array));\r\n    }\r\n\r\n    public setMatrices(uniform: WebGLUniformLocation, matrices: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRICES);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrices);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n\r\n        return true;\r\n    }\r\n\r\n    public setMatrix3x3(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX3X3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setMatrix2x2(uniform: WebGLUniformLocation, matrix: Float32Array): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETMATRIX2X2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32s(matrix);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat(uniform: WebGLUniformLocation, value: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(value);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat2(uniform: WebGLUniformLocation, x: number, y: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT2);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat3(uniform: WebGLUniformLocation, x: number, y: number, z: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT3);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setFloat4(uniform: WebGLUniformLocation, x: number, y: number, z: number, w: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETFLOAT4);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform as any as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(x);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(y);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(z);\r\n        this._commandBufferEncoder.encodeCommandArgAsFloat32(w);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n        return true;\r\n    }\r\n\r\n    public setColor3(uniform: WebGLUniformLocation, color3: IColor3Like): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this.setFloat3(uniform, color3.r, color3.g, color3.b);\r\n        return true;\r\n    }\r\n\r\n    public setColor4(uniform: WebGLUniformLocation, color3: IColor3Like, alpha: number): boolean {\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        this.setFloat4(uniform, color3.r, color3.g, color3.b, alpha);\r\n        return true;\r\n    }\r\n\r\n    public wipeCaches(bruteForce?: boolean): void {\r\n        if (this.preventCacheWipeBetweenFrames) {\r\n            return;\r\n        }\r\n        this.resetTextureCache();\r\n        this._currentEffect = null;\r\n\r\n        if (bruteForce) {\r\n            this._currentProgram = null;\r\n\r\n            this._stencilStateComposer.reset();\r\n            this._depthCullingState.reset();\r\n            this._alphaState.reset();\r\n        }\r\n\r\n        this._cachedVertexBuffers = null;\r\n        this._cachedIndexBuffer = null;\r\n        this._cachedEffectForVertexBuffers = null;\r\n    }\r\n\r\n    protected _createTexture(): WebGLTexture {\r\n        return this._engine.createTexture();\r\n    }\r\n\r\n    protected _deleteTexture(texture: Nullable<WebGLTexture>): void {\r\n        if (texture) {\r\n            this._engine.deleteTexture(texture as NativeTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the content of a dynamic texture\r\n     * @param texture defines the texture to update\r\n     * @param canvas defines the canvas containing the source\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param premulAlpha defines if alpha is stored as premultiplied\r\n     * @param format defines the format of the data\r\n     */\r\n    public updateDynamicTexture(texture: Nullable<InternalTexture>, canvas: any, invertY: boolean, premulAlpha: boolean = false, format?: number): void {\r\n        if (premulAlpha === void 0) {\r\n            premulAlpha = false;\r\n        }\r\n\r\n        if (!!texture && !!texture._hardwareTexture) {\r\n            const source = canvas.getCanvasTexture();\r\n            const destination = texture._hardwareTexture.underlyingResource;\r\n            this._engine.copyTexture(destination, source);\r\n            texture.isReady = true;\r\n        }\r\n    }\r\n\r\n    public createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n        // it's not possible to create 0x0 texture sized. Many bgfx methods assume texture size is at least 1x1(best case).\r\n        // Worst case is getting a crash/assert.\r\n        width = Math.max(width, 1);\r\n        height = Math.max(height, 1);\r\n        return this.createRawTexture(new Uint8Array(width * height * 4), width, height, Constants.TEXTUREFORMAT_RGBA, false, false, samplingMode);\r\n    }\r\n\r\n    public createVideoElement(constraints: MediaTrackConstraints): any {\r\n        // create native object depending on stream. Only NativeCamera is supported for now.\r\n        if (this._camera) {\r\n            return this._camera.createVideo(constraints);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public updateVideoTexture(texture: Nullable<InternalTexture>, video: HTMLVideoElement, invertY: boolean): void {\r\n        if (texture && texture._hardwareTexture && this._camera) {\r\n            const webGLTexture = texture._hardwareTexture.underlyingResource;\r\n            this._camera.updateVideoTexture(webGLTexture, video, invertY);\r\n        }\r\n    }\r\n\r\n    public createRawTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n\r\n        texture.format = format;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = texture.baseWidth;\r\n        texture.height = texture.baseHeight;\r\n        texture._compression = compression;\r\n        texture.type = type;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n        this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n\r\n        if (texture._hardwareTexture) {\r\n            const webGLTexture = texture._hardwareTexture.underlyingResource;\r\n            const filter = this._getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(webGLTexture, filter);\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n        return texture;\r\n    }\r\n\r\n    public createRawTexture2DArray(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const texture = new InternalTexture(this, InternalTextureSource.Raw2DArray);\r\n\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.is2DArray = true;\r\n\r\n        if (texture._hardwareTexture) {\r\n            const nativeTexture = texture._hardwareTexture.underlyingResource;\r\n            this._engine.loadRawTexture2DArray(nativeTexture, data, width, height, depth, this._getNativeTextureFormat(format, textureType), generateMipMaps, invertY);\r\n\r\n            const filter = this._getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(nativeTexture, filter);\r\n        }\r\n\r\n        texture.isReady = true;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n        return texture;\r\n    }\r\n\r\n    public updateRawTexture(\r\n        texture: Nullable<InternalTexture>,\r\n        bufferView: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        useSRGBBuffer: boolean = false\r\n    ): void {\r\n        if (!texture) {\r\n            return;\r\n        }\r\n\r\n        if (bufferView && texture._hardwareTexture) {\r\n            const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n            this._engine.loadRawTexture(\r\n                underlyingResource,\r\n                bufferView,\r\n                texture.width,\r\n                texture.height,\r\n                this._getNativeTextureFormat(format, type),\r\n                texture.generateMipMaps,\r\n                texture.invertY\r\n            );\r\n        }\r\n\r\n        texture.isReady = true;\r\n    }\r\n\r\n    // TODO: Refactor to share more logic with babylon.engine.ts version.\r\n    /**\r\n     * Usually called from Texture.ts.\r\n     * Passed information to create a NativeTexture\r\n     * @param url defines a value which contains one of the following:\r\n     * * A conventional http URL, e.g. 'http://...' or 'file://...'\r\n     * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\r\n     * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file\r\n     * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)\r\n     * @param scene needed for loading to the correct scene\r\n     * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param onLoad optional callback to be called upon successful completion\r\n     * @param onError optional callback to be called upon failure\r\n     * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob\r\n     * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities\r\n     * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param mimeType defines an optional mime type\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns a InternalTexture for assignment back into BABYLON.Texture\r\n     */\r\n    public createTexture(\r\n        url: Nullable<string>,\r\n        noMipmap: boolean,\r\n        invertY: boolean,\r\n        scene: Nullable<ISceneLike>,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<(texture: InternalTexture) => void> = null,\r\n        onError: Nullable<(message: string, exception: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        format: Nullable<number> = null,\r\n        forcedExtension: Nullable<string> = null,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        url = url || \"\";\r\n        const fromData = url.substr(0, 5) === \"data:\";\r\n        //const fromBlob = url.substr(0, 5) === \"blob:\";\r\n        const isBase64 = fromData && url.indexOf(\";base64,\") !== -1;\r\n\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);\r\n\r\n        const originalUrl = url;\r\n        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {\r\n            url = this._transformTextureUrl(url);\r\n        }\r\n\r\n        // establish the file extension, if possible\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        let loader: Nullable<IInternalTextureLoader> = null;\r\n        for (const availableLoader of Engine._TextureLoaders) {\r\n            if (availableLoader.canLoad(extension)) {\r\n                loader = availableLoader;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (scene) {\r\n            scene.addPendingData(texture);\r\n        }\r\n        texture.url = url;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture.samplingMode = samplingMode;\r\n        texture.invertY = invertY;\r\n        texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, noMipmap);\r\n\r\n        if (!this.doNotHandleContextLost) {\r\n            // Keep a link to the buffer only if we plan to handle context lost\r\n            texture._buffer = buffer;\r\n        }\r\n\r\n        let onLoadObserver: Nullable<Observer<InternalTexture>> = null;\r\n        if (onLoad && !fallback) {\r\n            onLoadObserver = texture.onLoadedObservable.add(onLoad);\r\n        }\r\n\r\n        if (!fallback) {\r\n            this._internalTexturesCache.push(texture);\r\n        }\r\n\r\n        const onInternalError = (message?: string, exception?: any) => {\r\n            if (scene) {\r\n                scene.removePendingData(texture);\r\n            }\r\n\r\n            if (url === originalUrl) {\r\n                if (onLoadObserver) {\r\n                    texture.onLoadedObservable.remove(onLoadObserver);\r\n                }\r\n\r\n                if (EngineStore.UseFallbackTexture) {\r\n                    this.createTexture(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, buffer, texture);\r\n                }\r\n\r\n                if (onError) {\r\n                    onError((message || \"Unknown error\") + (EngineStore.UseFallbackTexture ? \" - Fallback texture was used\" : \"\"), exception);\r\n                }\r\n            } else {\r\n                // fall back to the original url if the transformed url fails to load\r\n                Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);\r\n                this.createTexture(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, buffer, texture, format, forcedExtension, mimeType, loaderOptions);\r\n            }\r\n        };\r\n\r\n        // processing for non-image formats\r\n        if (loader) {\r\n            throw new Error(\"Loading textures from IInternalTextureLoader not yet implemented.\");\r\n        } else {\r\n            const onload = (data: ArrayBufferView) => {\r\n                if (!texture._hardwareTexture) {\r\n                    if (scene) {\r\n                        scene.removePendingData(texture);\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n\r\n                this._engine.loadTexture(\r\n                    underlyingResource,\r\n                    data,\r\n                    !noMipmap,\r\n                    invertY,\r\n                    useSRGBBuffer,\r\n                    () => {\r\n                        texture.baseWidth = this._engine.getTextureWidth(underlyingResource);\r\n                        texture.baseHeight = this._engine.getTextureHeight(underlyingResource);\r\n                        texture.width = texture.baseWidth;\r\n                        texture.height = texture.baseHeight;\r\n                        texture.isReady = true;\r\n\r\n                        const filter = this._getNativeSamplingMode(samplingMode);\r\n                        this._setTextureSampling(underlyingResource, filter);\r\n\r\n                        if (scene) {\r\n                            scene.removePendingData(texture);\r\n                        }\r\n\r\n                        texture.onLoadedObservable.notifyObservers(texture);\r\n                        texture.onLoadedObservable.clear();\r\n                    },\r\n                    () => {\r\n                        throw new Error(\"Could not load a native texture.\");\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (fromData && buffer) {\r\n                if (buffer instanceof ArrayBuffer) {\r\n                    onload(new Uint8Array(buffer));\r\n                } else if (ArrayBuffer.isView(buffer)) {\r\n                    onload(buffer);\r\n                } else if (typeof buffer === \"string\") {\r\n                    onload(new Uint8Array(Tools.DecodeBase64(buffer)));\r\n                } else {\r\n                    throw new Error(\"Unsupported buffer type\");\r\n                }\r\n            } else {\r\n                if (isBase64) {\r\n                    onload(new Uint8Array(Tools.DecodeBase64(url)));\r\n                } else {\r\n                    this._loadFile(\r\n                        url,\r\n                        (data) => onload(new Uint8Array(data as ArrayBuffer)),\r\n                        undefined,\r\n                        undefined,\r\n                        true,\r\n                        (request?: IWebRequest, exception?: any) => {\r\n                            onInternalError(\"Unable to load \" + (request ? request.responseURL : url, exception));\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external native texture in a Babylon texture.\r\n     * @param texture defines the external texture\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapNativeTexture(texture: any): InternalTexture {\r\n        const hardwareTexture = new NativeHardwareTexture(texture, this._engine);\r\n        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);\r\n        internalTexture._hardwareTexture = hardwareTexture;\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    }\r\n\r\n    /**\r\n     * Wraps an external web gl texture in a Babylon texture.\r\n     * @returns the babylon internal texture\r\n     */\r\n    public wrapWebGLTexture(): InternalTexture {\r\n        throw new Error(\"wrapWebGLTexture is not supported, use wrapNativeTexture instead.\");\r\n    }\r\n\r\n    public _createDepthStencilTexture(size: TextureSize, options: DepthTextureCreationOptions, rtWrapper: RenderTargetWrapper): InternalTexture {\r\n        // TODO: options?\r\n\r\n        const nativeRTWrapper = rtWrapper as NativeRenderTargetWrapper;\r\n        const texture = new InternalTexture(this, InternalTextureSource.DepthStencil);\r\n\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n\r\n        const framebuffer = this._engine.createFrameBuffer(texture._hardwareTexture!.underlyingResource, width, height, true, true);\r\n        nativeRTWrapper._framebufferDepthStencil = framebuffer;\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _releaseFramebufferObjects(framebuffer: Nullable<NativeFramebuffer>): void {\r\n        if (framebuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEFRAMEBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(framebuffer as NativeData);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal Engine abstraction for loading and creating an image bitmap from a given source string.\r\n     * @param imageSource source to load the image from.\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public _createImageBitmapFromSource(imageSource: string, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        const promise = new Promise<ImageBitmap>((resolve, reject) => {\r\n            const image = this.createCanvasImage();\r\n            image.onload = () => {\r\n                try {\r\n                    const imageBitmap = this._engine.createImageBitmap(image);\r\n                    resolve(imageBitmap);\r\n                } catch (error) {\r\n                    reject(`Error loading image ${image.src} with exception: ${error}`);\r\n                }\r\n            };\r\n            image.onerror = (error) => {\r\n                reject(`Error loading image ${image.src} with exception: ${error}`);\r\n            };\r\n\r\n            image.src = imageSource;\r\n        });\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Engine abstraction for createImageBitmap\r\n     * @param image source for image\r\n     * @param options An object that sets options for the image's extraction.\r\n     * @returns ImageBitmap\r\n     */\r\n    public createImageBitmap(image: ImageBitmapSource, options?: ImageBitmapOptions): Promise<ImageBitmap> {\r\n        return new Promise((resolve, reject) => {\r\n            if (Array.isArray(image)) {\r\n                const arr = <Array<ArrayBufferView>>image;\r\n                if (arr.length) {\r\n                    const image = this._engine.createImageBitmap(arr[0]);\r\n                    if (image) {\r\n                        resolve(image);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            reject(`Unsupported data for createImageBitmap.`);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resize an image and returns the image data as an uint8array\r\n     * @param image image to resize\r\n     * @param bufferWidth destination buffer width\r\n     * @param bufferHeight destination buffer height\r\n     * @returns an uint8array containing RGBA values of bufferWidth * bufferHeight size\r\n     */\r\n    public resizeImageBitmap(image: ImageBitmap, bufferWidth: number, bufferHeight: number): Uint8Array {\r\n        return this._engine.resizeImageBitmap(image, bufferWidth, bufferHeight);\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture\r\n     * @param rootUrl defines the url where the files to load is located\r\n     * @param scene defines the current scene\r\n     * @param files defines the list of files to load (1 per face)\r\n     * @param noMipmap defines a boolean indicating that no mipmaps shall be generated (false by default)\r\n     * @param onLoad defines an optional callback raised when the texture is loaded\r\n     * @param onError defines an optional callback raised if there is an issue to load the texture\r\n     * @param format defines the format of the data\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     * @param createPolynomials if a polynomial sphere should be created for the cube texture\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param fallback defines texture to use while falling back when (compressed) texture file not found.\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the cube texture as an InternalTexture\r\n     */\r\n    public createCubeTexture(\r\n        rootUrl: string,\r\n        scene: Nullable<Scene>,\r\n        files: Nullable<string[]>,\r\n        noMipmap?: boolean,\r\n        onLoad: Nullable<(data?: any) => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format?: number,\r\n        forcedExtension: any = null,\r\n        createPolynomials = false,\r\n        lodScale: number = 0,\r\n        lodOffset: number = 0,\r\n        fallback: Nullable<InternalTexture> = null,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer = false\r\n    ): InternalTexture {\r\n        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n        texture.isCube = true;\r\n        texture.url = rootUrl;\r\n        texture.generateMipMaps = !noMipmap;\r\n        texture._lodGenerationScale = lodScale;\r\n        texture._lodGenerationOffset = lodOffset;\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._extension = forcedExtension;\r\n            texture._files = files;\r\n        }\r\n\r\n        const lastDot = rootUrl.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrl.substring(lastDot).toLowerCase() : \"\";\r\n\r\n        // TODO: use texture loader to load env files?\r\n        if (extension === \".env\") {\r\n            const onloaddata = (data: ArrayBufferView) => {\r\n                const info = GetEnvInfo(data)!;\r\n                texture.width = info.width;\r\n                texture.height = info.width;\r\n\r\n                UploadEnvSpherical(texture, info);\r\n\r\n                const specularInfo = info.specular as EnvironmentTextureSpecularInfoV1;\r\n                if (!specularInfo) {\r\n                    throw new Error(`Nothing else parsed so far`);\r\n                }\r\n\r\n                texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n                const imageData = CreateImageDataArrayBufferViews(data, info);\r\n\r\n                texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                texture.type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n                texture.generateMipMaps = true;\r\n                texture.getEngine().updateTextureSamplingMode(Texture.TRILINEAR_SAMPLINGMODE, texture);\r\n                texture._isRGBD = true;\r\n                texture.invertY = true;\r\n\r\n                this._engine.loadCubeTextureWithMips(\r\n                    texture._hardwareTexture!.underlyingResource,\r\n                    imageData,\r\n                    false,\r\n                    useSRGBBuffer,\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    () => {\r\n                        throw new Error(\"Could not load a native cube texture.\");\r\n                    }\r\n                );\r\n            };\r\n\r\n            if (files && files.length === 6) {\r\n                throw new Error(`Multi-file loading not allowed on env files.`);\r\n            } else {\r\n                const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n                    if (onError && request) {\r\n                        onError(request.status + \" \" + request.statusText, exception);\r\n                    }\r\n                };\r\n\r\n                this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data as ArrayBuffer)), undefined, undefined, true, onInternalError);\r\n            }\r\n        } else {\r\n            if (!files || files.length !== 6) {\r\n                throw new Error(\"Cannot load cubemap because 6 files were not defined\");\r\n            }\r\n\r\n            // Reorder from [+X, +Y, +Z, -X, -Y, -Z] to [+X, -X, +Y, -Y, +Z, -Z].\r\n            const reorderedFiles = [files[0], files[3], files[1], files[4], files[2], files[5]];\r\n            Promise.all(reorderedFiles.map((file) => Tools.LoadFileAsync(file).then((data) => new Uint8Array(data as ArrayBuffer))))\r\n                .then((data) => {\r\n                    return new Promise<void>((resolve, reject) => {\r\n                        this._engine.loadCubeTexture(texture._hardwareTexture!.underlyingResource, data, !noMipmap, true, useSRGBBuffer, resolve, reject);\r\n                    });\r\n                })\r\n                .then(\r\n                    () => {\r\n                        texture.isReady = true;\r\n                        if (onLoad) {\r\n                            onLoad();\r\n                        }\r\n                    },\r\n                    (error) => {\r\n                        if (onError) {\r\n                            onError(`Failed to load cubemap: ${error.message}`, error);\r\n                        }\r\n                    }\r\n                );\r\n        }\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareTexture(): HardwareTextureWrapper {\r\n        return new NativeHardwareTexture(this._createTexture() as NativeTexture, this._engine);\r\n    }\r\n\r\n    /** @internal */\r\n    public _createHardwareRenderTargetWrapper(isMulti: boolean, isCube: boolean, size: TextureSize): RenderTargetWrapper {\r\n        const rtWrapper = new NativeRenderTargetWrapper(isMulti, isCube, size, this);\r\n        this._renderTargetWrapperCache.push(rtWrapper);\r\n        return rtWrapper;\r\n    }\r\n\r\n    /** @internal */\r\n    public _createInternalTexture(\r\n        size: TextureSize,\r\n        options: boolean | InternalTextureCreationOptions,\r\n        _delayGPUTextureCreation = true,\r\n        source = InternalTextureSource.Unknown\r\n    ): InternalTexture {\r\n        let generateMipMaps = false;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        let samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n        let format = Constants.TEXTUREFORMAT_RGBA;\r\n        let useSRGBBuffer = false;\r\n        let samples = 1;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateMipMaps = !!options.generateMipMaps;\r\n            type = options.type === undefined ? Constants.TEXTURETYPE_UNSIGNED_INT : options.type;\r\n            samplingMode = options.samplingMode === undefined ? Constants.TEXTURE_TRILINEAR_SAMPLINGMODE : options.samplingMode;\r\n            format = options.format === undefined ? Constants.TEXTUREFORMAT_RGBA : options.format;\r\n            useSRGBBuffer = options.useSRGBBuffer === undefined ? false : options.useSRGBBuffer;\r\n            samples = options.samples ?? 1;\r\n        } else {\r\n            generateMipMaps = !!options;\r\n        }\r\n\r\n        useSRGBBuffer &&= this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);\r\n\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n            // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        } else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\r\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\r\n            type = Constants.TEXTURETYPE_UNSIGNED_INT;\r\n            Logger.Warn(\"Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE\");\r\n        }\r\n\r\n        const texture = new InternalTexture(this, source);\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n\r\n        const layers = (<{ width: number; height: number; layers?: number }>size).layers || 0;\r\n        if (layers !== 0) {\r\n            throw new Error(\"Texture layers are not supported in Babylon Native\");\r\n        }\r\n\r\n        const nativeTexture = texture._hardwareTexture!.underlyingResource;\r\n        const nativeTextureFormat = this._getNativeTextureFormat(format, type);\r\n        // REVIEW: We are always setting the renderTarget flag as we don't know whether the texture will be used as a render target.\r\n        this._engine.initializeTexture(nativeTexture, width, height, generateMipMaps, nativeTextureFormat, true, useSRGBBuffer);\r\n        this._setTextureSampling(nativeTexture, this._getNativeSamplingMode(samplingMode));\r\n\r\n        texture._useSRGBBuffer = useSRGBBuffer;\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = layers;\r\n        texture.isReady = true;\r\n        texture.samples = samples;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        texture.type = type;\r\n        texture.format = format;\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    }\r\n\r\n    public createRenderTargetTexture(size: number | { width: number; height: number }, options: boolean | RenderTargetCreationOptions): RenderTargetWrapper {\r\n        const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size) as NativeRenderTargetWrapper;\r\n\r\n        let generateDepthBuffer = true;\r\n        let generateStencilBuffer = false;\r\n        let noColorAttachment = false;\r\n        let colorAttachment: InternalTexture | undefined = undefined;\r\n        //let samples = 1;\r\n        if (options !== undefined && typeof options === \"object\") {\r\n            generateDepthBuffer = options.generateDepthBuffer ?? true;\r\n            generateStencilBuffer = !!options.generateStencilBuffer;\r\n            noColorAttachment = !!options.noColorAttachment;\r\n            colorAttachment = options.colorAttachment;\r\n            //samples = options.samples ?? 1;\r\n        }\r\n\r\n        const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));\r\n        const width = (<{ width: number; height: number; layers?: number }>size).width || <number>size;\r\n        const height = (<{ width: number; height: number; layers?: number }>size).height || <number>size;\r\n\r\n        const framebuffer = this._engine.createFrameBuffer(\r\n            texture ? texture._hardwareTexture!.underlyingResource : null,\r\n            width,\r\n            height,\r\n            generateStencilBuffer,\r\n            generateDepthBuffer\r\n        );\r\n\r\n        rtWrapper._framebuffer = framebuffer;\r\n        rtWrapper._generateDepthBuffer = generateDepthBuffer;\r\n        rtWrapper._generateStencilBuffer = generateStencilBuffer;\r\n\r\n        rtWrapper.setTextures(texture);\r\n\r\n        // TODO: handle this in native\r\n        //this.updateRenderTargetTextureSampleCount(rtWrapper, samples);\r\n\r\n        return rtWrapper;\r\n    }\r\n\r\n    public updateTextureSamplingMode(samplingMode: number, texture: InternalTexture): void {\r\n        if (texture._hardwareTexture) {\r\n            const filter = this._getNativeSamplingMode(samplingMode);\r\n            this._setTextureSampling(texture._hardwareTexture.underlyingResource, filter);\r\n        }\r\n\r\n        texture.samplingMode = samplingMode;\r\n    }\r\n\r\n    public bindFramebuffer(texture: RenderTargetWrapper, faceIndex?: number, requiredWidth?: number, requiredHeight?: number, forceFullscreenViewport?: boolean): void {\r\n        const nativeRTWrapper = texture as NativeRenderTargetWrapper;\r\n\r\n        if (this._currentRenderTarget) {\r\n            this.unBindFramebuffer(this._currentRenderTarget);\r\n        }\r\n\r\n        this._currentRenderTarget = texture;\r\n\r\n        if (faceIndex) {\r\n            throw new Error(\"Cuboid frame buffers are not yet supported in NativeEngine.\");\r\n        }\r\n\r\n        if (requiredWidth || requiredHeight) {\r\n            throw new Error(\"Required width/height for frame buffers not yet supported in NativeEngine.\");\r\n        }\r\n\r\n        if (forceFullscreenViewport) {\r\n            //Not supported yet but don't stop rendering\r\n        }\r\n\r\n        if (nativeRTWrapper._framebufferDepthStencil) {\r\n            this._bindUnboundFramebuffer(nativeRTWrapper._framebufferDepthStencil);\r\n        } else {\r\n            this._bindUnboundFramebuffer(nativeRTWrapper._framebuffer);\r\n        }\r\n    }\r\n\r\n    public unBindFramebuffer(texture: RenderTargetWrapper, disableGenerateMipMaps = false, onBeforeUnbind?: () => void): void {\r\n        // NOTE: Disabling mipmap generation is not yet supported in NativeEngine.\r\n\r\n        this._currentRenderTarget = null;\r\n\r\n        if (onBeforeUnbind) {\r\n            onBeforeUnbind();\r\n        }\r\n\r\n        this._bindUnboundFramebuffer(null);\r\n    }\r\n\r\n    public createDynamicVertexBuffer(data: DataArray): DataBuffer {\r\n        return this.createVertexBuffer(data, true);\r\n    }\r\n\r\n    public updateDynamicIndexBuffer(indexBuffer: DataBuffer, indices: IndicesArray, offset: number = 0): void {\r\n        const buffer = indexBuffer as NativeDataBuffer;\r\n        const data = this._normalizeIndexData(indices);\r\n        buffer.is32Bits = data.BYTES_PER_ELEMENT === 4;\r\n        this._engine.updateDynamicIndexBuffer(buffer.nativeIndexBuffer!, data.buffer, data.byteOffset, data.byteLength, offset);\r\n    }\r\n\r\n    public updateDynamicVertexBuffer(vertexBuffer: DataBuffer, verticies: DataArray, byteOffset?: number, byteLength?: number): void {\r\n        const buffer = vertexBuffer as NativeDataBuffer;\r\n        const data = ArrayBuffer.isView(verticies) ? verticies : new Float32Array(verticies);\r\n        this._engine.updateDynamicVertexBuffer(buffer.nativeVertexBuffer!, data.buffer, data.byteOffset + (byteOffset ?? 0), byteLength ?? data.byteLength);\r\n    }\r\n\r\n    // TODO: Refactor to share more logic with base Engine implementation.\r\n    protected _setTexture(channel: number, texture: Nullable<BaseTexture>, isPartOfTextureArray = false, depthStencilTexture = false): boolean {\r\n        const uniform = this._boundUniforms[channel] as unknown as NativeUniform;\r\n        if (!uniform) {\r\n            return false;\r\n        }\r\n\r\n        // Not ready?\r\n        if (!texture) {\r\n            if (this._boundTexturesCache[channel] != null) {\r\n                this._activeChannel = channel;\r\n                this._boundTexturesCache[channel] = null;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // Video\r\n        if ((<VideoTexture>texture).video) {\r\n            this._activeChannel = channel;\r\n            (<VideoTexture>texture).update();\r\n        } else if (texture.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            // Delay loading\r\n            texture.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        let internalTexture: InternalTexture;\r\n        if (depthStencilTexture) {\r\n            internalTexture = (<RenderTargetTexture>texture).depthStencilTexture!;\r\n        } else if (texture.isReady()) {\r\n            internalTexture = <InternalTexture>texture.getInternalTexture();\r\n        } else if (texture.isCube) {\r\n            internalTexture = this.emptyCubeTexture;\r\n        } else if (texture.is3D) {\r\n            internalTexture = this.emptyTexture3D;\r\n        } else if (texture.is2DArray) {\r\n            internalTexture = this.emptyTexture2DArray;\r\n        } else {\r\n            internalTexture = this.emptyTexture;\r\n        }\r\n\r\n        this._activeChannel = channel;\r\n\r\n        if (!internalTexture || !internalTexture._hardwareTexture) {\r\n            return false;\r\n        }\r\n\r\n        this._setTextureWrapMode(\r\n            internalTexture._hardwareTexture.underlyingResource,\r\n            this._getAddressMode(texture.wrapU),\r\n            this._getAddressMode(texture.wrapV),\r\n            this._getAddressMode(texture.wrapR)\r\n        );\r\n        this._updateAnisotropicLevel(texture);\r\n\r\n        this._setTextureCore(uniform, internalTexture._hardwareTexture.underlyingResource);\r\n\r\n        return true;\r\n    }\r\n\r\n    // filter is a NativeFilter.XXXX value.\r\n    private _setTextureSampling(texture: NativeTexture, filter: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURESAMPLING);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(filter);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    // addressModes are NativeAddressMode.XXXX values.\r\n    private _setTextureWrapMode(texture: NativeTexture, addressModeU: number, addressModeV: number, addressModeW: number) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREWRAPMODE);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture as NativeData);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeU);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeV);\r\n        this._commandBufferEncoder.encodeCommandArgAsUInt32(addressModeW);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    private _setTextureCore(uniform: NativeUniform, texture: NativeTexture) {\r\n        this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTURE);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(uniform);\r\n        this._commandBufferEncoder.encodeCommandArgAsNativeData(texture);\r\n        this._commandBufferEncoder.finishEncodingCommand();\r\n    }\r\n\r\n    // TODO: Share more of this logic with the base implementation.\r\n    // TODO: Rename to match naming in base implementation once refactoring allows different parameters.\r\n    private _updateAnisotropicLevel(texture: BaseTexture) {\r\n        const internalTexture = texture.getInternalTexture();\r\n        const value = texture.anisotropicFilteringLevel;\r\n\r\n        if (!internalTexture || !internalTexture._hardwareTexture) {\r\n            return;\r\n        }\r\n\r\n        if (internalTexture._cachedAnisotropicFilteringLevel !== value) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_SETTEXTUREANISOTROPICLEVEL);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(internalTexture._hardwareTexture.underlyingResource);\r\n            this._commandBufferEncoder.encodeCommandArgAsUInt32(value);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            internalTexture._cachedAnisotropicFilteringLevel = value;\r\n        }\r\n    }\r\n\r\n    // Returns a NativeAddressMode.XXX value.\r\n    private _getAddressMode(wrapMode: number): number {\r\n        switch (wrapMode) {\r\n            case Constants.TEXTURE_WRAP_ADDRESSMODE:\r\n                return _native.Engine.ADDRESS_MODE_WRAP;\r\n            case Constants.TEXTURE_CLAMP_ADDRESSMODE:\r\n                return _native.Engine.ADDRESS_MODE_CLAMP;\r\n            case Constants.TEXTURE_MIRROR_ADDRESSMODE:\r\n                return _native.Engine.ADDRESS_MODE_MIRROR;\r\n            default:\r\n                throw new Error(\"Unexpected wrap mode: \" + wrapMode + \".\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bindTexture(channel: number, texture: InternalTexture): void {\r\n        const uniform = this._boundUniforms[channel] as unknown as NativeUniform;\r\n        if (!uniform) {\r\n            return;\r\n        }\r\n        if (texture && texture._hardwareTexture) {\r\n            const underlyingResource = texture._hardwareTexture.underlyingResource;\r\n            this._setTextureCore(uniform, underlyingResource);\r\n        }\r\n    }\r\n\r\n    protected _deleteBuffer(buffer: NativeDataBuffer): void {\r\n        if (buffer.nativeIndexBuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEINDEXBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeIndexBuffer);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            delete buffer.nativeIndexBuffer;\r\n        }\r\n\r\n        if (buffer.nativeVertexBuffer) {\r\n            this._commandBufferEncoder.startEncodingCommand(_native.Engine.COMMAND_DELETEVERTEXBUFFER);\r\n            this._commandBufferEncoder.encodeCommandArgAsNativeData(buffer.nativeVertexBuffer);\r\n            this._commandBufferEncoder.finishEncodingCommand();\r\n            delete buffer.nativeVertexBuffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a canvas\r\n     * @param width width\r\n     * @param height height\r\n     * @returns ICanvas interface\r\n     */\r\n    public createCanvas(width: number, height: number): ICanvas {\r\n        if (!_native.Canvas) {\r\n            throw new Error(\"Native Canvas plugin not available.\");\r\n        }\r\n        const canvas = new _native.Canvas();\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Create an image to use with canvas\r\n     * @returns IImage interface\r\n     */\r\n    public createCanvasImage(): IImage {\r\n        if (!_native.Canvas) {\r\n            throw new Error(\"Native Canvas plugin not available.\");\r\n        }\r\n        const image = new _native.Image();\r\n        return image;\r\n    }\r\n\r\n    /**\r\n     * Update a portion of an internal texture\r\n     * @param texture defines the texture to update\r\n     * @param imageData defines the data to store into the texture\r\n     * @param xOffset defines the x coordinates of the update rectangle\r\n     * @param yOffset defines the y coordinates of the update rectangle\r\n     * @param width defines the width of the update rectangle\r\n     * @param height defines the height of the update rectangle\r\n     * @param faceIndex defines the face index if texture is a cube (0 by default)\r\n     * @param lod defines the lod level to update (0 by default)\r\n     * @param generateMipMaps defines whether to generate mipmaps or not\r\n     */\r\n    public updateTextureData(\r\n        texture: InternalTexture,\r\n        imageData: ArrayBufferView,\r\n        xOffset: number,\r\n        yOffset: number,\r\n        width: number,\r\n        height: number,\r\n        faceIndex: number = 0,\r\n        lod: number = 0,\r\n        generateMipMaps = false\r\n    ): void {\r\n        throw new Error(\"updateTextureData not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadCompressedDataToTextureDirectly(\r\n        texture: InternalTexture,\r\n        internalFormat: number,\r\n        width: number,\r\n        height: number,\r\n        data: ArrayBufferView,\r\n        faceIndex: number = 0,\r\n        lod: number = 0\r\n    ) {\r\n        throw new Error(\"_uploadCompressedDataToTextureDirectly not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadDataToTextureDirectly(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        throw new Error(\"_uploadDataToTextureDirectly not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadArrayBufferViewToTexture(texture: InternalTexture, imageData: ArrayBufferView, faceIndex: number = 0, lod: number = 0): void {\r\n        throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _uploadImageToTexture(texture: InternalTexture, image: HTMLImageElement, faceIndex: number = 0, lod: number = 0) {\r\n        throw new Error(\"_uploadArrayBufferViewToTexture not implemented.\");\r\n    }\r\n\r\n    // JavaScript-to-Native conversion helper functions.\r\n\r\n    private _getNativeSamplingMode(samplingMode: number): number {\r\n        switch (samplingMode) {\r\n            case Constants.TEXTURE_NEAREST_NEAREST:\r\n                return _native.Engine.TEXTURE_NEAREST_NEAREST;\r\n            case Constants.TEXTURE_LINEAR_LINEAR:\r\n                return _native.Engine.TEXTURE_LINEAR_LINEAR;\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR:\r\n                return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST:\r\n                return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST:\r\n                return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n            case Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR:\r\n                return _native.Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n            case Constants.TEXTURE_NEAREST_LINEAR:\r\n                return _native.Engine.TEXTURE_NEAREST_LINEAR;\r\n            case Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR:\r\n                return _native.Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST:\r\n                return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n            case Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR:\r\n                return _native.Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n            case Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST:\r\n                return _native.Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST;\r\n            case Constants.TEXTURE_LINEAR_NEAREST:\r\n                return _native.Engine.TEXTURE_LINEAR_NEAREST;\r\n            default:\r\n                throw new Error(`Unsupported sampling mode: ${samplingMode}.`);\r\n        }\r\n    }\r\n\r\n    private _getStencilFunc(func: number): number {\r\n        switch (func) {\r\n            case Constants.LESS:\r\n                return _native.Engine.STENCIL_TEST_LESS;\r\n            case Constants.LEQUAL:\r\n                return _native.Engine.STENCIL_TEST_LEQUAL;\r\n            case Constants.EQUAL:\r\n                return _native.Engine.STENCIL_TEST_EQUAL;\r\n            case Constants.GEQUAL:\r\n                return _native.Engine.STENCIL_TEST_GEQUAL;\r\n            case Constants.GREATER:\r\n                return _native.Engine.STENCIL_TEST_GREATER;\r\n            case Constants.NOTEQUAL:\r\n                return _native.Engine.STENCIL_TEST_NOTEQUAL;\r\n            case Constants.NEVER:\r\n                return _native.Engine.STENCIL_TEST_NEVER;\r\n            case Constants.ALWAYS:\r\n                return _native.Engine.STENCIL_TEST_ALWAYS;\r\n            default:\r\n                throw new Error(`Unsupported stencil func mode: ${func}.`);\r\n        }\r\n    }\r\n\r\n    private _getStencilOpFail(opFail: number): number {\r\n        switch (opFail) {\r\n            case Constants.KEEP:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_KEEP;\r\n            case Constants.ZERO:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_ZERO;\r\n            case Constants.REPLACE:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_REPLACE;\r\n            case Constants.INCR:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_INCR;\r\n            case Constants.DECR:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_DECR;\r\n            case Constants.INVERT:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_INVERT;\r\n            case Constants.INCR_WRAP:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_INCRSAT;\r\n            case Constants.DECR_WRAP:\r\n                return _native.Engine.STENCIL_OP_FAIL_S_DECRSAT;\r\n            default:\r\n                throw new Error(`Unsupported stencil OpFail mode: ${opFail}.`);\r\n        }\r\n    }\r\n\r\n    private _getStencilDepthFail(depthFail: number): number {\r\n        switch (depthFail) {\r\n            case Constants.KEEP:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_KEEP;\r\n            case Constants.ZERO:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_ZERO;\r\n            case Constants.REPLACE:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_REPLACE;\r\n            case Constants.INCR:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_INCR;\r\n            case Constants.DECR:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_DECR;\r\n            case Constants.INVERT:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_INVERT;\r\n            case Constants.INCR_WRAP:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_INCRSAT;\r\n            case Constants.DECR_WRAP:\r\n                return _native.Engine.STENCIL_OP_FAIL_Z_DECRSAT;\r\n            default:\r\n                throw new Error(`Unsupported stencil depthFail mode: ${depthFail}.`);\r\n        }\r\n    }\r\n\r\n    private _getStencilDepthPass(opPass: number): number {\r\n        switch (opPass) {\r\n            case Constants.KEEP:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_KEEP;\r\n            case Constants.ZERO:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_ZERO;\r\n            case Constants.REPLACE:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_REPLACE;\r\n            case Constants.INCR:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_INCR;\r\n            case Constants.DECR:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_DECR;\r\n            case Constants.INVERT:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_INVERT;\r\n            case Constants.INCR_WRAP:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_INCRSAT;\r\n            case Constants.DECR_WRAP:\r\n                return _native.Engine.STENCIL_OP_PASS_Z_DECRSAT;\r\n            default:\r\n                throw new Error(`Unsupported stencil opPass mode: ${opPass}.`);\r\n        }\r\n    }\r\n\r\n    private _getNativeTextureFormat(format: number, type: number): number {\r\n        if (format == Constants.TEXTUREFORMAT_RGB && type == Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n            return _native.Engine.TEXTURE_FORMAT_RGB8;\r\n        } else if (format == Constants.TEXTUREFORMAT_RGBA && type == Constants.TEXTURETYPE_UNSIGNED_INT) {\r\n            return _native.Engine.TEXTURE_FORMAT_RGBA8;\r\n        } else if (format == Constants.TEXTUREFORMAT_RGBA && type == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            return _native.Engine.TEXTURE_FORMAT_RGBA16F;\r\n        } else if (format == Constants.TEXTUREFORMAT_RGBA && type == Constants.TEXTURETYPE_FLOAT) {\r\n            return _native.Engine.TEXTURE_FORMAT_RGBA32F;\r\n        } else {\r\n            throw new RuntimeError(`Unsupported texture format or type: format ${format}, type ${type}.`, ErrorCodes.UnsupportedTextureError);\r\n        }\r\n    }\r\n\r\n    private _getNativeAlphaMode(mode: number): number {\r\n        switch (mode) {\r\n            case Constants.ALPHA_DISABLE:\r\n                return _native.Engine.ALPHA_DISABLE;\r\n            case Constants.ALPHA_ADD:\r\n                return _native.Engine.ALPHA_ADD;\r\n            case Constants.ALPHA_COMBINE:\r\n                return _native.Engine.ALPHA_COMBINE;\r\n            case Constants.ALPHA_SUBTRACT:\r\n                return _native.Engine.ALPHA_SUBTRACT;\r\n            case Constants.ALPHA_MULTIPLY:\r\n                return _native.Engine.ALPHA_MULTIPLY;\r\n            case Constants.ALPHA_MAXIMIZED:\r\n                return _native.Engine.ALPHA_MAXIMIZED;\r\n            case Constants.ALPHA_ONEONE:\r\n                return _native.Engine.ALPHA_ONEONE;\r\n            case Constants.ALPHA_PREMULTIPLIED:\r\n                return _native.Engine.ALPHA_PREMULTIPLIED;\r\n            case Constants.ALPHA_PREMULTIPLIED_PORTERDUFF:\r\n                return _native.Engine.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            case Constants.ALPHA_INTERPOLATE:\r\n                return _native.Engine.ALPHA_INTERPOLATE;\r\n            case Constants.ALPHA_SCREENMODE:\r\n                return _native.Engine.ALPHA_SCREENMODE;\r\n            default:\r\n                throw new Error(`Unsupported alpha mode: ${mode}.`);\r\n        }\r\n    }\r\n\r\n    private _getNativeAttribType(type: number): number {\r\n        switch (type) {\r\n            case VertexBuffer.BYTE:\r\n                return _native.Engine.ATTRIB_TYPE_INT8;\r\n            case VertexBuffer.UNSIGNED_BYTE:\r\n                return _native.Engine.ATTRIB_TYPE_UINT8;\r\n            case VertexBuffer.SHORT:\r\n                return _native.Engine.ATTRIB_TYPE_INT16;\r\n            case VertexBuffer.UNSIGNED_SHORT:\r\n                return _native.Engine.ATTRIB_TYPE_UINT16;\r\n            case VertexBuffer.FLOAT:\r\n                return _native.Engine.ATTRIB_TYPE_FLOAT;\r\n            default:\r\n                throw new Error(`Unsupported attribute type: ${type}.`);\r\n        }\r\n    }\r\n\r\n    public getFontOffset(font: string): { ascent: number; height: number; descent: number } {\r\n        // TODO\r\n        const result = { ascent: 0, height: 0, descent: 0 };\r\n        return result;\r\n    }\r\n\r\n    public _readTexturePixels(\r\n        texture: InternalTexture,\r\n        width: number,\r\n        height: number,\r\n        faceIndex?: number,\r\n        level?: number,\r\n        buffer?: Nullable<ArrayBufferView>,\r\n        _flushRenderer?: boolean,\r\n        _noDataConversion?: boolean,\r\n        x?: number,\r\n        y?: number\r\n    ): Promise<ArrayBufferView> {\r\n        if (faceIndex !== undefined && faceIndex !== -1) {\r\n            throw new Error(`Reading cubemap faces is not supported, but faceIndex is ${faceIndex}.`);\r\n        }\r\n\r\n        return this._engine\r\n            .readTexture(\r\n                texture._hardwareTexture?.underlyingResource,\r\n                level ?? 0,\r\n                x ?? 0,\r\n                y ?? 0,\r\n                width,\r\n                height,\r\n                buffer?.buffer ?? null,\r\n                buffer?.byteOffset ?? 0,\r\n                buffer?.byteLength ?? 0\r\n            )\r\n            .then((rawBuffer) => {\r\n                if (!buffer) {\r\n                    buffer = new Uint8Array(rawBuffer);\r\n                }\r\n\r\n                return buffer;\r\n            });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}