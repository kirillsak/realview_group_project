{"ast":null,"code":"import { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents.js\";\nimport { AbstractActionManager } from \"../Actions/abstractActionManager.js\";\nimport { PickingInfo } from \"../Collisions/pickingInfo.js\";\nimport { Vector2, Matrix } from \"../Maths/math.vector.js\";\nimport { ActionEvent } from \"../Actions/actionEvent.js\";\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents.js\";\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums.js\";\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _ClickInfo {\n  constructor() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n  get singleClick() {\n    return this._singleClick;\n  }\n  get doubleClick() {\n    return this._doubleClick;\n  }\n  get hasSwiped() {\n    return this._hasSwiped;\n  }\n  get ignore() {\n    return this._ignore;\n  }\n  set singleClick(b) {\n    this._singleClick = b;\n  }\n  set doubleClick(b) {\n    this._doubleClick = b;\n  }\n  set hasSwiped(b) {\n    this._hasSwiped = b;\n  }\n  set ignore(b) {\n    this._ignore = b;\n  }\n}\n/**\n * Class used to manage all inputs for the scene.\n */\nexport class InputManager {\n  /**\n   * Creates a new InputManager\n   * @param scene - defines the hosting scene\n   */\n  constructor(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false;\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._isSwiping = false;\n    this._swipeButtonPressed = -1;\n    this._skipPointerTap = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new Vector2(0, 0);\n    this._previousStartingPointerPosition = new Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = {};\n    this._movePointerInfo = null;\n    this._cameraObserverCount = 0;\n    this._deviceSourceManager = null;\n    this._scene = scene || EngineStore.LastCreatedScene;\n    if (!this._scene) {\n      return;\n    }\n  }\n  /**\n   * Gets the mesh that is currently under the pointer\n   * @returns Mesh that the pointer is pointer is hovering over\n   */\n  get meshUnderPointer() {\n    if (this._movePointerInfo) {\n      // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\n      // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\n      this._movePointerInfo._generatePickInfo();\n      // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\n      this._movePointerInfo = null;\n    }\n    return this._pointerOverMesh;\n  }\n  /**\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\n   * @param pointerId - the pointer id to use\n   * @returns The mesh under this pointer id or null if not found\n   */\n  getMeshUnderPointerByPointerId(pointerId) {\n    return this._meshUnderPointerId[pointerId] || null;\n  }\n  /**\n   * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\n   * @returns Vector with X/Y values directly from pointer event\n   */\n  get unTranslatedPointer() {\n    return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n  }\n  /**\n   * Gets or sets the current on-screen X position of the pointer\n   * @returns Translated X with respect to screen\n   */\n  get pointerX() {\n    return this._pointerX;\n  }\n  set pointerX(value) {\n    this._pointerX = value;\n  }\n  /**\n   * Gets or sets the current on-screen Y position of the pointer\n   * @returns Translated Y with respect to screen\n   */\n  get pointerY() {\n    return this._pointerY;\n  }\n  set pointerY(value) {\n    this._pointerY = value;\n  }\n  _updatePointerPosition(evt) {\n    const canvasRect = this._scene.getEngine().getInputElementClientRect();\n    if (!canvasRect) {\n      return;\n    }\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  }\n  _processPointerMove(pickResult, evt) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n    if (canvas) {\n      canvas.tabIndex = engine.canvasTabIndex;\n      // Restore pointer\n      if (!scene.doNotHandleCursors) {\n        canvas.style.cursor = scene.defaultCursor;\n      }\n    }\n    this._setCursorAndPointerOverMesh(pickResult, evt.pointerId, scene);\n    for (const step of scene._pointerMoveStage) {\n      const isMeshPicked = (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) ? true : false;\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n    const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n    if (scene.onPointerMove) {\n      // Because of lazy picking, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt.pointerId);\n      scene.onPointerMove(evt, pickResult, type);\n    }\n    let pointerInfo;\n    if (pickResult) {\n      pointerInfo = new PointerInfo(type, evt, pickResult);\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new PointerInfo(type, evt, null, this);\n      this._movePointerInfo = pointerInfo;\n    }\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  // Pointers handling\n  /** @internal */\n  _setRayOnPointerInfo(pickInfo, event) {\n    const scene = this._scene;\n    if (pickInfo && scene._pickingAvailable) {\n      if (!pickInfo.ray) {\n        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  }\n  /** @internal */\n  _addCameraPointerObserver(observer, mask) {\n    this._cameraObserverCount++;\n    return this._scene.onPointerObservable.add(observer, mask);\n  }\n  /** @internal */\n  _removeCameraPointerObserver(observer) {\n    this._cameraObserverCount--;\n    return this._scene.onPointerObservable.remove(observer);\n  }\n  _checkForPicking() {\n    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\n  }\n  _checkPrePointerObservable(pickResult, evt, type) {\n    const scene = this._scene;\n    const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n    if (pickResult) {\n      pi.originalPickingInfo = pickResult;\n      pi.ray = pickResult.ray;\n      if (pickResult.originMesh) {\n        pi.nearInteractionPickingInfo = pickResult;\n      }\n    }\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** @internal */\n  _pickMove(pointerId) {\n    const scene = this._scene;\n    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);\n    this._setCursorAndPointerOverMesh(pickResult, pointerId, scene);\n    return pickResult;\n  }\n  _setCursorAndPointerOverMesh(pickResult, pointerId, scene) {\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this.setPointerOverMesh(pickResult.pickedMesh, pointerId, pickResult);\n      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\n        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\n        if (actionManager && actionManager.hasPointerTriggers) {\n          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\n        }\n      }\n    } else {\n      this.setPointerOverMesh(null, pointerId, pickResult);\n    }\n  }\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n  simulatePointerMove(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointermove\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n    this._processPointerMove(pickResult, evt);\n  }\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n  simulatePointerDown(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n    evt.inputIndex = evt.button + 2;\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n    this._processPointerDown(pickResult, evt);\n  }\n  _processPointerDown(pickResult, evt) {\n    const scene = this._scene;\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n      if (actionManager) {\n        if (actionManager.hasPickTriggers) {\n          actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n          switch (evt.button) {\n            case 0:\n              actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n            case 1:\n              actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n            case 2:\n              actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n          }\n        }\n        if (actionManager.hasSpecificTrigger(8)) {\n          window.setTimeout(() => {\n            const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);\n            if ((pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) && actionManager) {\n              if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\n                this._startingPointerTime = 0;\n                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (const step of scene._pointerDownStage) {\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\n      }\n    }\n    let pointerInfo;\n    const type = PointerEventTypes.POINTERDOWN;\n    if (pickResult) {\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n      pointerInfo = new PointerInfo(type, evt, pickResult);\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new PointerInfo(type, evt, null, this);\n    }\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  /**\n   * @internal\n   * @internals Boolean if delta for pointer exceeds drag movement threshold\n   */\n  _isPointerSwiping() {\n    return this._isSwiping;\n  }\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\n   */\n  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n    const evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    evt.inputIndex = PointerInput.Move;\n    const clickInfo = new _ClickInfo();\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\n      return;\n    }\n    this._processPointerUp(pickResult, evt, clickInfo);\n  }\n  _processPointerUp(pickResult, evt, clickInfo) {\n    const scene = this._scene;\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\n          const type = PointerEventTypes.POINTERPICK;\n          const pi = new PointerInfo(type, evt, pickResult);\n          this._setRayOnPointerInfo(pickResult, evt);\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (const step of scene._pointerUpStage) {\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\n        }\n      }\n    }\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n    if (!clickInfo.ignore) {\n      const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);\n      // Set ray on picking info.  Note that this info will also be reused for the tap notification.\n      this._setRayOnPointerInfo(pickResult, evt);\n      scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);\n      if (scene.onPointerUp) {\n        scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);\n      }\n      if (!clickInfo.hasSwiped && !this._skipPointerTap) {\n        let type = 0;\n        if (clickInfo.singleClick) {\n          type = PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick) {\n          type = PointerEventTypes.POINTERDOUBLETAP;\n        }\n        if (type) {\n          const pi = new PointerInfo(type, evt, pickResult);\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n  isPointerCaptured(pointerId = 0) {\n    return this._pointerCaptures[pointerId];\n  }\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp - defines if you want to attach events to pointerup\n   * @param attachDown - defines if you want to attach events to pointerdown\n   * @param attachMove - defines if you want to attach events to pointermove\n   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\n   */\n  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    if (!elementToAttachTo) {\n      elementToAttachTo = engine.getInputElement();\n    }\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n    if (elementToAttachTo) {\n      this._alreadyAttachedTo = elementToAttachTo;\n    }\n    this._deviceSourceManager = new DeviceSourceManager(engine);\n    // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\n    this._initActionManager = act => {\n      if (!this._meshPickProceed) {\n        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, false, scene.cameraToUseForPointers);\n        this._currentPickResult = pickResult;\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n        this._meshPickProceed = true;\n      }\n      return act;\n    };\n    this._delayedSimpleClick = (btn, clickInfo, cb) => {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {\n        this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false;\n        cb(clickInfo, this._currentPickResult);\n      }\n    };\n    this._initClickEvent = (obs1, obs2, evt, cb) => {\n      const clickInfo = new _ClickInfo();\n      this._currentPickResult = null;\n      let act = null;\n      let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n      if (!checkPicking && AbstractActionManager) {\n        act = this._initActionManager(act, clickInfo);\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n      let needToIgnoreNext = false;\n      if (checkPicking) {\n        const btn = evt.button;\n        clickInfo.hasSwiped = this._isPointerSwiping();\n        if (!clickInfo.hasSwiped) {\n          let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {\n              act = this._initActionManager(act, clickInfo);\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          }\n          // at least one double click is required to be check and exclusive double click is enabled\n          else {\n            // wait that no double click has been raised during the double click delay\n            this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\n            this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\n          }\n          let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {\n            act = this._initActionManager(act, clickInfo);\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\n                this._previousStartingPointerTime = 0;\n                this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false;\n                if (InputManager.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout) {\n                  clearTimeout(this._previousDelayedSimpleClickTimeout);\n                }\n                this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\n                cb(clickInfo, this._currentPickResult);\n              }\n              // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                this._doubleClickOccured = false;\n                this._previousStartingPointerTime = this._startingPointerTime;\n                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n                this._previousButtonPressed = btn;\n                if (InputManager.ExclusiveDoubleClickMode) {\n                  if (this._previousDelayedSimpleClickTimeout) {\n                    clearTimeout(this._previousDelayedSimpleClickTimeout);\n                  }\n                  this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\n                  cb(clickInfo, this._previousPickResult);\n                } else {\n                  cb(clickInfo, this._currentPickResult);\n                }\n              }\n              needToIgnoreNext = true;\n            }\n            // just the first click of the double has been raised\n            else {\n              this._doubleClickOccured = false;\n              this._previousStartingPointerTime = this._startingPointerTime;\n              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n              this._previousButtonPressed = btn;\n            }\n          }\n        }\n      }\n      if (!needToIgnoreNext) {\n        cb(clickInfo, this._currentPickResult);\n      }\n    };\n    this._onPointerMove = evt => {\n      // preserve compatibility with Safari when pointerId is not present\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n      this._updatePointerPosition(evt);\n      // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\n      if (!this._isSwiping && this._swipeButtonPressed !== -1) {\n        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n      }\n      // PreObservable support\n      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n      if (scene.skipPointerMovePicking) {\n        this._processPointerMove(new PickingInfo(), evt);\n        return;\n      }\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n      }\n      const pickResult = scene._registeredActions > 0 ? this._pickMove(evt.pointerId) : null;\n      this._processPointerMove(pickResult, evt);\n    };\n    this._onPointerDown = evt => {\n      this._totalPointersPressed++;\n      this._pickedDownMesh = null;\n      this._meshPickProceed = false;\n      // preserve compatibility with Safari when pointerId is not present\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n      this._updatePointerPosition(evt);\n      if (this._swipeButtonPressed === -1) {\n        this._swipeButtonPressed = evt.button;\n      }\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n      this._startingPointerPosition.x = this._pointerX;\n      this._startingPointerPosition.y = this._pointerY;\n      this._startingPointerTime = Date.now();\n      // PreObservable support\n      if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n      this._pointerCaptures[evt.pointerId] = true;\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = mesh => {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      }\n      // Meshes\n      this._pickedDownMesh = null;\n      let pickResult;\n      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {\n        pickResult = new PickingInfo();\n      } else {\n        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\n      }\n      this._processPointerDown(pickResult, evt);\n    };\n    this._onPointerUp = evt => {\n      if (this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n\n      this._totalPointersPressed--;\n      this._pickedUpMesh = null;\n      this._meshPickProceed = false;\n      // preserve compatibility with Safari when pointerId is not present\n      if (evt.pointerId === undefined) {\n        evt.pointerId = 0;\n      }\n      this._updatePointerPosition(evt);\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          this._skipPointerTap = false;\n          if (!clickInfo.ignore) {\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\n              // If we're skipping the next observable, we need to reset the swipe state before returning\n              if (this._swipeButtonPressed === evt.button) {\n                this._isSwiping = false;\n                this._swipeButtonPressed = -1;\n              }\n              return;\n            }\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n            }\n          }\n        }\n        this._pointerCaptures[evt.pointerId] = false;\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = mesh => {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        }\n        // Meshes\n        if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {\n          this._initActionManager(null, clickInfo);\n        }\n        if (!pickResult) {\n          pickResult = this._currentPickResult;\n        }\n        this._processPointerUp(pickResult, evt, clickInfo);\n        this._previousPickResult = this._currentPickResult;\n        if (this._swipeButtonPressed === evt.button) {\n          this._isSwiping = false;\n          this._swipeButtonPressed = -1;\n        }\n      });\n    };\n    this._onKeyDown = evt => {\n      const type = KeyboardEventTypes.KEYDOWN;\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n    this._onKeyUp = evt => {\n      const type = KeyboardEventTypes.KEYUP;\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n    // If a device connects that we can handle, wire up the observable\n    this._deviceSourceManager.onDeviceConnectedObservable.add(deviceSource => {\n      if (deviceSource.deviceType === DeviceType.Mouse) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n            }\n          } else if (attachMove) {\n            if (eventData.inputIndex === PointerInput.Move) {\n              this._onPointerMove(eventData);\n            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {\n              this._onPointerMove(eventData);\n            }\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Touch) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === PointerInput.LeftClick) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n            }\n          }\n          if (attachMove && eventData.inputIndex === PointerInput.Move) {\n            this._onPointerMove(eventData);\n          }\n        });\n      } else if (deviceSource.deviceType === DeviceType.Keyboard) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.type === \"keydown\") {\n            this._onKeyDown(eventData);\n          } else if (eventData.type === \"keyup\") {\n            this._onKeyUp(eventData);\n          }\n        });\n      }\n    });\n    this._alreadyAttached = true;\n  }\n  /**\n   * Detaches all event handlers\n   */\n  detachControl() {\n    if (this._alreadyAttached) {\n      this._deviceSourceManager.dispose();\n      this._deviceSourceManager = null;\n      // Cursor\n      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\n        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n      }\n      this._alreadyAttached = false;\n      this._alreadyAttachedTo = null;\n    }\n  }\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh - defines the mesh to use\n   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\n   * @param pickResult - optional pickingInfo data used to find mesh\n   */\n  setPointerOverMesh(mesh, pointerId = 0, pickResult) {\n    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\n      return;\n    }\n    const underPointerMesh = this._meshUnderPointerId[pointerId];\n    let actionManager;\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n      if (actionManager) {\n        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, undefined, {\n          pointerId\n        }));\n      }\n    }\n    if (mesh) {\n      this._meshUnderPointerId[pointerId] = mesh;\n      this._pointerOverMesh = mesh;\n      actionManager = mesh._getActionManagerForTrigger(9);\n      if (actionManager) {\n        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, undefined, {\n          pointerId,\n          pickResult\n        }));\n      }\n    } else {\n      delete this._meshUnderPointerId[pointerId];\n      this._pointerOverMesh = null;\n    }\n  }\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n  getPointerOverMesh() {\n    return this.meshUnderPointer;\n  }\n  /**\n   * @param mesh - Mesh to invalidate\n   * @internal\n   */\n  _invalidateMesh(mesh) {\n    if (this._pointerOverMesh === mesh) {\n      this._pointerOverMesh = null;\n    }\n    if (this._pickedDownMesh === mesh) {\n      this._pickedDownMesh = null;\n    }\n    if (this._pickedUpMesh === mesh) {\n      this._pickedUpMesh = null;\n    }\n    for (const pointerId in this._meshUnderPointerId) {\n      if (this._meshUnderPointerId[pointerId] === mesh) {\n        delete this._meshUnderPointerId[pointerId];\n      }\n    }\n  }\n}\n/** The distance in pixel that you have to move to prevent some events */\nInputManager.DragMovementThreshold = 10; // in pixels\n/** Time in milliseconds to wait to raise long press events if button is still pressed */\nInputManager.LongPressDelay = 500; // in milliseconds\n/** Time in milliseconds with two consecutive clicks will be considered as a double click */\nInputManager.DoubleClickDelay = 300; // in milliseconds\n/** If you need to check double click without raising a single click at first click, enable this flag */\nInputManager.ExclusiveDoubleClickMode = false;","map":{"version":3,"mappings":"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","names":["PointerInfoPre","PointerInfo","PointerEventTypes","AbstractActionManager","PickingInfo","Vector2","Matrix","ActionEvent","KeyboardEventTypes","KeyboardInfoPre","KeyboardInfo","DeviceType","PointerInput","DeviceSourceManager","EngineStore","_ClickInfo","constructor","singleClick","_singleClick","doubleClick","_doubleClick","hasSwiped","_hasSwiped","ignore","_ignore","b","InputManager","scene","_scene","LastCreatedScene","meshUnderPointer","_movePointerInfo","_generatePickInfo","_pointerOverMesh","getMeshUnderPointerByPointerId","pointerId","_meshUnderPointerId","unTranslatedPointer","_unTranslatedPointerX","_unTranslatedPointerY","pointerX","_pointerX","value","pointerY","_pointerY","_updatePointerPosition","evt","canvasRect","getEngine","getInputElementClientRect","clientX","left","clientY","top","_processPointerMove","pickResult","engine","canvas","getInputElement","tabIndex","canvasTabIndex","doNotHandleCursors","style","cursor","defaultCursor","_setCursorAndPointerOverMesh","step","_pointerMoveStage","isMeshPicked","pickedMesh","action","type","inputIndex","MouseWheelX","MouseWheelZ","POINTERWHEEL","POINTERMOVE","onPointerMove","_pickMove","pointerInfo","_setRayOnPointerInfo","onPointerObservable","hasObservers","notifyObservers","pickInfo","event","_pickingAvailable","ray","createPickingRay","offsetX","offsetY","Identity","activeCamera","_addCameraPointerObserver","observer","mask","_cameraObserverCount","add","_removeCameraPointerObserver","remove","_checkForPicking","observers","length","onPointerPick","_checkPrePointerObservable","pi","originalPickingInfo","originMesh","nearInteractionPickingInfo","onPrePointerObservable","skipOnPointerObservable","pick","pointerMovePredicate","cameraToUseForPointers","pointerMoveTrianglePredicate","setPointerOverMesh","actionManager","_getActionManagerForTrigger","hasPointerTriggers","hoverCursor","simulatePointerMove","pointerEventInit","PointerEvent","Move","simulatePointerDown","button","POINTERDOWN","_processPointerDown","_pickedDownMesh","hasPickTriggers","processTrigger","hasSpecificTrigger","window","setTimeout","mesh","isPickable","isVisible","isReady","_totalPointersPressed","Date","now","_startingPointerTime","LongPressDelay","_isPointerSwiping","_pointerDownStage","onPointerDown","_isSwiping","simulatePointerUp","doubleTap","clickInfo","POINTERUP","_processPointerUp","_pickedUpMesh","POINTERPICK","doubleClickActionManager","_pointerUpStage","pickedDownActionManager","onPointerUp","_skipPointerTap","POINTERTAP","POINTERDOUBLETAP","hasSpecificMask","isPointerCaptured","_pointerCaptures","attachControl","attachUp","attachDown","attachMove","elementToAttachTo","_alreadyAttached","detachControl","_alreadyAttachedTo","_deviceSourceManager","_initActionManager","act","_meshPickProceed","skipPointerUpPicking","_registeredActions","pointerUpPredicate","_currentPickResult","hit","_delayedSimpleClick","btn","cb","_previousStartingPointerTime","DoubleClickDelay","_doubleClickOccured","_previousButtonPressed","_initClickEvent","obs1","obs2","checkPicking","needToIgnoreNext","checkSingleClickImmediately","ExclusiveDoubleClickMode","HasSpecificTrigger","_previousDelayedSimpleClickTimeout","_delayedSimpleClickTimeout","bind","checkDoubleClick","clearTimeout","_previousStartingPointerPosition","x","_startingPointerPosition","y","_previousPickResult","_onPointerMove","undefined","_swipeButtonPressed","Math","abs","DragMovementThreshold","skipPointerMovePicking","isEnabled","enablePointerMoveEvents","constantlyUpdateMeshUnderPointer","layerMask","_onPointerDown","preventDefaultOnPointerDown","preventDefault","focus","pointerDownPredicate","skipPointerDownPicking","_onPointerUp","preventDefaultOnPointerUp","HasTriggers","_onKeyDown","KEYDOWN","onPreKeyboardObservable","skipOnKeyboardObservable","onKeyboardObservable","_onKeyUp","KEYUP","onDeviceConnectedObservable","deviceSource","deviceType","Mouse","onInputChangedObservable","eventData","LeftClick","MiddleClick","RightClick","BrowserBack","BrowserForward","getInput","MouseWheelY","Touch","Keyboard","dispose","_internalAbstractMeshDataInfo","_pointerOverDisableMeshTesting","underPointerMesh","getPointerOverMesh","_invalidateMesh"],"sourceRoot":"","sources":["../../../../lts/core/generated/Inputs/scene.inputManager.ts"],"sourcesContent":["import type { EventState, Observable, Observer } from \"../Misc/observable\";\r\nimport { PointerInfoPre, PointerInfo, PointerEventTypes } from \"../Events/pointerEvents\";\r\nimport type { Nullable } from \"../types\";\r\nimport { AbstractActionManager } from \"../Actions/abstractActionManager\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { Vector2, Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { ActionEvent } from \"../Actions/actionEvent\";\r\nimport { KeyboardEventTypes, KeyboardInfoPre, KeyboardInfo } from \"../Events/keyboardEvents\";\r\nimport { DeviceType, PointerInput } from \"../DeviceInput/InputDevices/deviceEnums\";\r\nimport type { IKeyboardEvent, IMouseEvent, IPointerEvent } from \"../Events/deviceInputEvents\";\r\nimport { DeviceSourceManager } from \"../DeviceInput/InputDevices/deviceSourceManager\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\ndeclare type Scene = import(\"../scene\").Scene;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nclass _ClickInfo {\r\n    private _singleClick = false;\r\n    private _doubleClick = false;\r\n    private _hasSwiped = false;\r\n    private _ignore = false;\r\n\r\n    public get singleClick(): boolean {\r\n        return this._singleClick;\r\n    }\r\n    public get doubleClick(): boolean {\r\n        return this._doubleClick;\r\n    }\r\n    public get hasSwiped(): boolean {\r\n        return this._hasSwiped;\r\n    }\r\n    public get ignore(): boolean {\r\n        return this._ignore;\r\n    }\r\n\r\n    public set singleClick(b: boolean) {\r\n        this._singleClick = b;\r\n    }\r\n    public set doubleClick(b: boolean) {\r\n        this._doubleClick = b;\r\n    }\r\n    public set hasSwiped(b: boolean) {\r\n        this._hasSwiped = b;\r\n    }\r\n    public set ignore(b: boolean) {\r\n        this._ignore = b;\r\n    }\r\n}\r\n\r\n/**\r\n * Class used to manage all inputs for the scene.\r\n */\r\nexport class InputManager {\r\n    /** The distance in pixel that you have to move to prevent some events */\r\n    public static DragMovementThreshold = 10; // in pixels\r\n    /** Time in milliseconds to wait to raise long press events if button is still pressed */\r\n    public static LongPressDelay = 500; // in milliseconds\r\n    /** Time in milliseconds with two consecutive clicks will be considered as a double click */\r\n    public static DoubleClickDelay = 300; // in milliseconds\r\n    /** If you need to check double click without raising a single click at first click, enable this flag */\r\n    public static ExclusiveDoubleClickMode = false;\r\n\r\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\r\n    private _alreadyAttached = false;\r\n    private _alreadyAttachedTo: Nullable<HTMLElement>;\r\n\r\n    // Pointers\r\n    private _onPointerMove: (evt: IMouseEvent) => void;\r\n    private _onPointerDown: (evt: IPointerEvent) => void;\r\n    private _onPointerUp: (evt: IPointerEvent) => void;\r\n\r\n    private _initClickEvent: (\r\n        obs1: Observable<PointerInfoPre>,\r\n        obs2: Observable<PointerInfo>,\r\n        evt: IPointerEvent,\r\n        cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n    ) => void;\r\n    private _initActionManager: (act: Nullable<AbstractActionManager>, clickInfo: _ClickInfo) => Nullable<AbstractActionManager>;\r\n    private _delayedSimpleClick: (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => void;\r\n    private _delayedSimpleClickTimeout: number;\r\n    private _previousDelayedSimpleClickTimeout: number;\r\n    private _meshPickProceed = false;\r\n\r\n    private _previousButtonPressed: number;\r\n    private _currentPickResult: Nullable<PickingInfo> = null;\r\n    private _previousPickResult: Nullable<PickingInfo> = null;\r\n    private _totalPointersPressed = 0;\r\n    private _doubleClickOccured = false;\r\n    private _isSwiping: boolean = false;\r\n    private _swipeButtonPressed: number = -1;\r\n    private _skipPointerTap: boolean = false;\r\n\r\n    private _pointerOverMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pickedDownMesh: Nullable<AbstractMesh>;\r\n    private _pickedUpMesh: Nullable<AbstractMesh>;\r\n\r\n    private _pointerX: number = 0;\r\n    private _pointerY: number = 0;\r\n    private _unTranslatedPointerX: number;\r\n    private _unTranslatedPointerY: number;\r\n    private _startingPointerPosition = new Vector2(0, 0);\r\n    private _previousStartingPointerPosition = new Vector2(0, 0);\r\n    private _startingPointerTime = 0;\r\n    private _previousStartingPointerTime = 0;\r\n    private _pointerCaptures: { [pointerId: number]: boolean } = {};\r\n    private _meshUnderPointerId: { [pointerId: number]: Nullable<AbstractMesh> } = {};\r\n    private _movePointerInfo: Nullable<PointerInfo> = null;\r\n    private _cameraObserverCount = 0;\r\n\r\n    // Keyboard\r\n    private _onKeyDown: (evt: IKeyboardEvent) => void;\r\n    private _onKeyUp: (evt: IKeyboardEvent) => void;\r\n\r\n    private _scene: Scene;\r\n    private _deviceSourceManager: Nullable<DeviceSourceManager> = null;\r\n\r\n    /**\r\n     * Creates a new InputManager\r\n     * @param scene - defines the hosting scene\r\n     */\r\n    constructor(scene?: Scene) {\r\n        this._scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!this._scene) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh that is currently under the pointer\r\n     * @returns Mesh that the pointer is pointer is hovering over\r\n     */\r\n    public get meshUnderPointer(): Nullable<AbstractMesh> {\r\n        if (this._movePointerInfo) {\r\n            // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\r\n            // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\r\n            this._movePointerInfo._generatePickInfo();\r\n            // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\r\n            this._movePointerInfo = null;\r\n        }\r\n        return this._pointerOverMesh;\r\n    }\r\n\r\n    /**\r\n     * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\r\n     * @param pointerId - the pointer id to use\r\n     * @returns The mesh under this pointer id or null if not found\r\n     */\r\n    public getMeshUnderPointerByPointerId(pointerId: number): Nullable<AbstractMesh> {\r\n        return this._meshUnderPointerId[pointerId] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\r\n     * @returns Vector with X/Y values directly from pointer event\r\n     */\r\n    public get unTranslatedPointer(): Vector2 {\r\n        return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen X position of the pointer\r\n     * @returns Translated X with respect to screen\r\n     */\r\n    public get pointerX(): number {\r\n        return this._pointerX;\r\n    }\r\n\r\n    public set pointerX(value: number) {\r\n        this._pointerX = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current on-screen Y position of the pointer\r\n     * @returns Translated Y with respect to screen\r\n     */\r\n    public get pointerY(): number {\r\n        return this._pointerY;\r\n    }\r\n\r\n    public set pointerY(value: number) {\r\n        this._pointerY = value;\r\n    }\r\n\r\n    private _updatePointerPosition(evt: IPointerEvent): void {\r\n        const canvasRect = this._scene.getEngine().getInputElementClientRect();\r\n\r\n        if (!canvasRect) {\r\n            return;\r\n        }\r\n\r\n        this._pointerX = evt.clientX - canvasRect.left;\r\n        this._pointerY = evt.clientY - canvasRect.top;\r\n\r\n        this._unTranslatedPointerX = this._pointerX;\r\n        this._unTranslatedPointerY = this._pointerY;\r\n    }\r\n\r\n    private _processPointerMove(pickResult: Nullable<PickingInfo>, evt: IPointerEvent) {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (canvas) {\r\n            canvas.tabIndex = engine.canvasTabIndex;\r\n\r\n            // Restore pointer\r\n            if (!scene.doNotHandleCursors) {\r\n                canvas.style.cursor = scene.defaultCursor;\r\n            }\r\n        }\r\n\r\n        this._setCursorAndPointerOverMesh(pickResult, evt.pointerId, scene);\r\n\r\n        for (const step of scene._pointerMoveStage) {\r\n            const isMeshPicked = pickResult?.pickedMesh ? true : false;\r\n            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\r\n        }\r\n\r\n        const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\r\n\r\n        if (scene.onPointerMove) {\r\n            // Because of lazy picking, we need to force a pick to update the pickResult\r\n            pickResult = pickResult || this._pickMove(evt.pointerId);\r\n            scene.onPointerMove(evt, pickResult, type);\r\n        }\r\n\r\n        let pointerInfo: PointerInfo;\r\n        if (pickResult) {\r\n            pointerInfo = new PointerInfo(type, evt, pickResult);\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n        } else {\r\n            pointerInfo = new PointerInfo(type, evt, null, this);\r\n            this._movePointerInfo = pointerInfo;\r\n        }\r\n\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            scene.onPointerObservable.notifyObservers(pointerInfo, type);\r\n        }\r\n    }\r\n\r\n    // Pointers handling\r\n    /** @internal */\r\n    public _setRayOnPointerInfo(pickInfo: Nullable<PickingInfo>, event: IMouseEvent) {\r\n        const scene = this._scene;\r\n        if (pickInfo && scene._pickingAvailable) {\r\n            if (!pickInfo.ray) {\r\n                pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _addCameraPointerObserver(observer: (p: PointerInfo, s: EventState) => void, mask?: number): Nullable<Observer<PointerInfo>> {\r\n        this._cameraObserverCount++;\r\n        return this._scene.onPointerObservable.add(observer, mask);\r\n    }\r\n\r\n    /** @internal */\r\n    public _removeCameraPointerObserver(observer: Observer<PointerInfo>): boolean {\r\n        this._cameraObserverCount--;\r\n        return this._scene.onPointerObservable.remove(observer);\r\n    }\r\n\r\n    private _checkForPicking(): boolean {\r\n        return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\r\n    }\r\n\r\n    private _checkPrePointerObservable(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, type: number) {\r\n        const scene = this._scene;\r\n        const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\r\n        if (pickResult) {\r\n            pi.originalPickingInfo = pickResult;\r\n            pi.ray = pickResult.ray;\r\n            if (pickResult.originMesh) {\r\n                pi.nearInteractionPickingInfo = pickResult;\r\n            }\r\n        }\r\n\r\n        scene.onPrePointerObservable.notifyObservers(pi, type);\r\n        if (pi.skipOnPointerObservable) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _pickMove(pointerId: number): PickingInfo {\r\n        const scene = this._scene;\r\n        const pickResult = scene.pick(\r\n            this._unTranslatedPointerX,\r\n            this._unTranslatedPointerY,\r\n            scene.pointerMovePredicate,\r\n            false,\r\n            scene.cameraToUseForPointers,\r\n            scene.pointerMoveTrianglePredicate\r\n        );\r\n\r\n        this._setCursorAndPointerOverMesh(pickResult, pointerId, scene);\r\n\r\n        return pickResult;\r\n    }\r\n\r\n    private _setCursorAndPointerOverMesh(pickResult: Nullable<PickingInfo>, pointerId: number, scene: Scene) {\r\n        const engine = scene.getEngine();\r\n        const canvas = engine.getInputElement();\r\n\r\n        if (pickResult?.pickedMesh) {\r\n            this.setPointerOverMesh(pickResult.pickedMesh, pointerId, pickResult);\r\n\r\n            if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\r\n                const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\r\n                if (actionManager && actionManager.hasPointerTriggers) {\r\n                    canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\r\n                }\r\n            }\r\n        } else {\r\n            this.setPointerOverMesh(null, pointerId, pickResult);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer move on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerMove(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointermove\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {\r\n            return;\r\n        }\r\n        this._processPointerMove(pickResult, evt);\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer down on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     */\r\n    public simulatePointerDown(pickResult: PickingInfo, pointerEventInit?: PointerEventInit): void {\r\n        const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\r\n        evt.inputIndex = evt.button + 2;\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerDown(pickResult, evt);\r\n    }\r\n\r\n    private _processPointerDown(pickResult: Nullable<PickingInfo>, evt: IPointerEvent): void {\r\n        const scene = this._scene;\r\n        if (pickResult?.pickedMesh) {\r\n            this._pickedDownMesh = pickResult.pickedMesh;\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager) {\r\n                if (actionManager.hasPickTriggers) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickDownTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                    switch (evt.button) {\r\n                        case 0:\r\n                            actionManager.processTrigger(Constants.ACTION_OnLeftPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                        case 1:\r\n                            actionManager.processTrigger(Constants.ACTION_OnCenterPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                        case 2:\r\n                            actionManager.processTrigger(Constants.ACTION_OnRightPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                if (actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger)) {\r\n                    window.setTimeout(() => {\r\n                        const pickResult = scene.pick(\r\n                            this._unTranslatedPointerX,\r\n                            this._unTranslatedPointerY,\r\n                            (mesh: AbstractMesh): boolean =>\r\n                                <boolean>(\r\n                                    (mesh.isPickable &&\r\n                                        mesh.isVisible &&\r\n                                        mesh.isReady() &&\r\n                                        mesh.actionManager &&\r\n                                        mesh.actionManager.hasSpecificTrigger(Constants.ACTION_OnLongPressTrigger) &&\r\n                                        mesh === this._pickedDownMesh)\r\n                                ),\r\n                            false,\r\n                            scene.cameraToUseForPointers\r\n                        );\r\n\r\n                        if (pickResult?.pickedMesh && actionManager) {\r\n                            if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\r\n                                this._startingPointerTime = 0;\r\n                                actionManager.processTrigger(Constants.ACTION_OnLongPressTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt));\r\n                            }\r\n                        }\r\n                    }, InputManager.LongPressDelay);\r\n                }\r\n            }\r\n        } else {\r\n            for (const step of scene._pointerDownStage) {\r\n                pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\r\n            }\r\n        }\r\n\r\n        let pointerInfo: PointerInfo;\r\n        const type = PointerEventTypes.POINTERDOWN;\r\n\r\n        if (pickResult) {\r\n            if (scene.onPointerDown) {\r\n                scene.onPointerDown(evt, pickResult, type);\r\n            }\r\n\r\n            pointerInfo = new PointerInfo(type, evt, pickResult);\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n        } else {\r\n            pointerInfo = new PointerInfo(type, evt, null, this);\r\n        }\r\n\r\n        if (scene.onPointerObservable.hasObservers()) {\r\n            scene.onPointerObservable.notifyObservers(pointerInfo, type);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @internals Boolean if delta for pointer exceeds drag movement threshold\r\n     */\r\n    public _isPointerSwiping(): boolean {\r\n        return this._isSwiping;\r\n    }\r\n\r\n    /**\r\n     * Use this method to simulate a pointer up on a mesh\r\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\r\n     * @param pickResult - pickingInfo of the object wished to simulate pointer event on\r\n     * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\r\n     * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\r\n     */\r\n    public simulatePointerUp(pickResult: PickingInfo, pointerEventInit?: PointerEventInit, doubleTap?: boolean): void {\r\n        const evt = new PointerEvent(\"pointerup\", pointerEventInit);\r\n        evt.inputIndex = PointerInput.Move;\r\n        const clickInfo = new _ClickInfo();\r\n\r\n        if (doubleTap) {\r\n            clickInfo.doubleClick = true;\r\n        } else {\r\n            clickInfo.singleClick = true;\r\n        }\r\n\r\n        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {\r\n            return;\r\n        }\r\n\r\n        this._processPointerUp(pickResult, evt, clickInfo);\r\n    }\r\n\r\n    private _processPointerUp(pickResult: Nullable<PickingInfo>, evt: IPointerEvent, clickInfo: _ClickInfo): void {\r\n        const scene = this._scene;\r\n        if (pickResult?.pickedMesh) {\r\n            this._pickedUpMesh = pickResult.pickedMesh;\r\n            if (this._pickedDownMesh === this._pickedUpMesh) {\r\n                if (scene.onPointerPick) {\r\n                    scene.onPointerPick(evt, pickResult);\r\n                }\r\n                if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\r\n                    const type = PointerEventTypes.POINTERPICK;\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    this._setRayOnPointerInfo(pickResult, evt);\r\n                    scene.onPointerObservable.notifyObservers(pi, type);\r\n                }\r\n            }\r\n            const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\r\n            if (actionManager && !clickInfo.ignore) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPickUpTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n\r\n                if (!clickInfo.hasSwiped && clickInfo.singleClick) {\r\n                    actionManager.processTrigger(Constants.ACTION_OnPickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n\r\n                const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                if (clickInfo.doubleClick && doubleClickActionManager) {\r\n                    doubleClickActionManager.processTrigger(Constants.ACTION_OnDoublePickTrigger, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\r\n                }\r\n            }\r\n        } else {\r\n            if (!clickInfo.ignore) {\r\n                for (const step of scene._pointerUpStage) {\r\n                    pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\r\n            const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(Constants.ACTION_OnPickOutTrigger);\r\n            if (pickedDownActionManager) {\r\n                pickedDownActionManager.processTrigger(Constants.ACTION_OnPickOutTrigger, ActionEvent.CreateNew(this._pickedDownMesh, evt));\r\n            }\r\n        }\r\n\r\n        if (!clickInfo.ignore) {\r\n            const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);\r\n            // Set ray on picking info.  Note that this info will also be reused for the tap notification.\r\n            this._setRayOnPointerInfo(pickResult, evt);\r\n            scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);\r\n\r\n            if (scene.onPointerUp) {\r\n                scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);\r\n            }\r\n\r\n            if (!clickInfo.hasSwiped && !this._skipPointerTap) {\r\n                let type = 0;\r\n                if (clickInfo.singleClick) {\r\n                    type = PointerEventTypes.POINTERTAP;\r\n                } else if (clickInfo.doubleClick) {\r\n                    type = PointerEventTypes.POINTERDOUBLETAP;\r\n                }\r\n\r\n                if (type) {\r\n                    const pi = new PointerInfo(type, evt, pickResult);\r\n                    if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\r\n                        scene.onPointerObservable.notifyObservers(pi, type);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\r\n     * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\r\n     * @returns true if the pointer was captured\r\n     */\r\n    public isPointerCaptured(pointerId = 0): boolean {\r\n        return this._pointerCaptures[pointerId];\r\n    }\r\n\r\n    /**\r\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\r\n     * @param attachUp - defines if you want to attach events to pointerup\r\n     * @param attachDown - defines if you want to attach events to pointerdown\r\n     * @param attachMove - defines if you want to attach events to pointermove\r\n     * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\r\n     */\r\n    public attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo: Nullable<HTMLElement> = null): void {\r\n        const scene = this._scene;\r\n        const engine = scene.getEngine();\r\n\r\n        if (!elementToAttachTo) {\r\n            elementToAttachTo = engine.getInputElement();\r\n        }\r\n\r\n        if (this._alreadyAttached) {\r\n            this.detachControl();\r\n        }\r\n\r\n        if (elementToAttachTo) {\r\n            this._alreadyAttachedTo = elementToAttachTo;\r\n        }\r\n        this._deviceSourceManager = new DeviceSourceManager(engine);\r\n\r\n        // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\r\n        this._initActionManager = (act: Nullable<AbstractActionManager>): Nullable<AbstractActionManager> => {\r\n            if (!this._meshPickProceed) {\r\n                const pickResult =\r\n                    scene.skipPointerUpPicking || (scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp)\r\n                        ? null\r\n                        : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, false, scene.cameraToUseForPointers);\r\n                this._currentPickResult = pickResult;\r\n                if (pickResult) {\r\n                    act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\r\n                }\r\n                this._meshPickProceed = true;\r\n            }\r\n            return act;\r\n        };\r\n\r\n        this._delayedSimpleClick = (btn: number, clickInfo: _ClickInfo, cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void) => {\r\n            // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\r\n            if ((Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured) || btn !== this._previousButtonPressed) {\r\n                this._doubleClickOccured = false;\r\n                clickInfo.singleClick = true;\r\n                clickInfo.ignore = false;\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._initClickEvent = (\r\n            obs1: Observable<PointerInfoPre>,\r\n            obs2: Observable<PointerInfo>,\r\n            evt: IPointerEvent,\r\n            cb: (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => void\r\n        ): void => {\r\n            const clickInfo = new _ClickInfo();\r\n            this._currentPickResult = null;\r\n            let act: Nullable<AbstractActionManager> = null;\r\n\r\n            let checkPicking =\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) ||\r\n                obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) ||\r\n                obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n            if (!checkPicking && AbstractActionManager) {\r\n                act = this._initActionManager(act, clickInfo);\r\n                if (act) {\r\n                    checkPicking = act.hasPickTriggers;\r\n                }\r\n            }\r\n\r\n            let needToIgnoreNext = false;\r\n\r\n            if (checkPicking) {\r\n                const btn = evt.button;\r\n                clickInfo.hasSwiped = this._isPointerSwiping();\r\n\r\n                if (!clickInfo.hasSwiped) {\r\n                    let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\r\n\r\n                    if (!checkSingleClickImmediately) {\r\n                        checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n\r\n                        if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                            act = this._initActionManager(act, clickInfo);\r\n                            if (act) {\r\n                                checkSingleClickImmediately = !act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (checkSingleClickImmediately) {\r\n                        // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\r\n                        if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\r\n                            clickInfo.singleClick = true;\r\n                            cb(clickInfo, this._currentPickResult);\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                    }\r\n                    // at least one double click is required to be check and exclusive double click is enabled\r\n                    else {\r\n                        // wait that no double click has been raised during the double click delay\r\n                        this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n                        this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay);\r\n                    }\r\n\r\n                    let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\r\n                    if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger)) {\r\n                        act = this._initActionManager(act, clickInfo);\r\n                        if (act) {\r\n                            checkDoubleClick = act.hasSpecificTrigger(Constants.ACTION_OnDoublePickTrigger);\r\n                        }\r\n                    }\r\n                    if (checkDoubleClick) {\r\n                        // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\r\n                        if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\r\n                            // pointer has not moved for 2 clicks, it's a double click\r\n                            if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\r\n                                this._previousStartingPointerTime = 0;\r\n                                this._doubleClickOccured = true;\r\n                                clickInfo.doubleClick = true;\r\n                                clickInfo.ignore = false;\r\n                                if (InputManager.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout) {\r\n                                    clearTimeout(this._previousDelayedSimpleClickTimeout);\r\n                                }\r\n                                this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n                                cb(clickInfo, this._currentPickResult);\r\n                            }\r\n                            // if the two successive clicks are too far, it's just two simple clicks\r\n                            else {\r\n                                this._doubleClickOccured = false;\r\n                                this._previousStartingPointerTime = this._startingPointerTime;\r\n                                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                                this._previousButtonPressed = btn;\r\n                                if (InputManager.ExclusiveDoubleClickMode) {\r\n                                    if (this._previousDelayedSimpleClickTimeout) {\r\n                                        clearTimeout(this._previousDelayedSimpleClickTimeout);\r\n                                    }\r\n                                    this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout;\r\n\r\n                                    cb(clickInfo, this._previousPickResult);\r\n                                } else {\r\n                                    cb(clickInfo, this._currentPickResult);\r\n                                }\r\n                            }\r\n                            needToIgnoreNext = true;\r\n                        }\r\n                        // just the first click of the double has been raised\r\n                        else {\r\n                            this._doubleClickOccured = false;\r\n                            this._previousStartingPointerTime = this._startingPointerTime;\r\n                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\r\n                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\r\n                            this._previousButtonPressed = btn!;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!needToIgnoreNext) {\r\n                cb(clickInfo, this._currentPickResult);\r\n            }\r\n        };\r\n\r\n        this._onPointerMove = (evt: IMouseEvent) => {\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if ((evt as IPointerEvent).pointerId === undefined) {\r\n                (evt as IPointerEvent as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt as IPointerEvent);\r\n\r\n            // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\r\n            if (!this._isSwiping && this._swipeButtonPressed !== -1) {\r\n                this._isSwiping =\r\n                    Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold ||\r\n                    Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\r\n            }\r\n\r\n            // PreObservable support\r\n            if (\r\n                this._checkPrePointerObservable(\r\n                    null,\r\n                    evt as IPointerEvent,\r\n                    evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE\r\n                )\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            if (scene.skipPointerMovePicking) {\r\n                this._processPointerMove(new PickingInfo(), evt as IPointerEvent);\r\n                return;\r\n            }\r\n\r\n            if (!scene.pointerMovePredicate) {\r\n                scene.pointerMovePredicate = (mesh: AbstractMesh): boolean =>\r\n                    mesh.isPickable &&\r\n                    mesh.isVisible &&\r\n                    mesh.isReady() &&\r\n                    mesh.isEnabled() &&\r\n                    (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) &&\r\n                    (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\r\n            }\r\n\r\n            const pickResult = scene._registeredActions > 0 ? this._pickMove((evt as IPointerEvent).pointerId) : null;\r\n            this._processPointerMove(pickResult, evt as IPointerEvent);\r\n        };\r\n\r\n        this._onPointerDown = (evt: IPointerEvent) => {\r\n            this._totalPointersPressed++;\r\n            this._pickedDownMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (this._swipeButtonPressed === -1) {\r\n                this._swipeButtonPressed = evt.button;\r\n            }\r\n\r\n            if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._startingPointerPosition.x = this._pointerX;\r\n            this._startingPointerPosition.y = this._pointerY;\r\n            this._startingPointerTime = Date.now();\r\n\r\n            // PreObservable support\r\n            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {\r\n                return;\r\n            }\r\n\r\n            if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                return;\r\n            }\r\n\r\n            this._pointerCaptures[evt.pointerId] = true;\r\n\r\n            if (!scene.pointerDownPredicate) {\r\n                scene.pointerDownPredicate = (mesh: AbstractMesh): boolean => {\r\n                    return (\r\n                        mesh.isPickable &&\r\n                        mesh.isVisible &&\r\n                        mesh.isReady() &&\r\n                        mesh.isEnabled() &&\r\n                        (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                    );\r\n                };\r\n            }\r\n\r\n            // Meshes\r\n            this._pickedDownMesh = null;\r\n            let pickResult;\r\n            if (scene.skipPointerDownPicking || (scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown)) {\r\n                pickResult = new PickingInfo();\r\n            } else {\r\n                pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);\r\n            }\r\n\r\n            this._processPointerDown(pickResult, evt);\r\n        };\r\n\r\n        this._onPointerUp = (evt: IPointerEvent) => {\r\n            if (this._totalPointersPressed === 0) {\r\n                // We are attaching the pointer up to windows because of a bug in FF\r\n                return; // So we need to test it the pointer down was pressed before.\r\n            }\r\n\r\n            this._totalPointersPressed--;\r\n            this._pickedUpMesh = null;\r\n            this._meshPickProceed = false;\r\n\r\n            // preserve compatibility with Safari when pointerId is not present\r\n            if (evt.pointerId === undefined) {\r\n                (evt as any).pointerId = 0;\r\n            }\r\n\r\n            this._updatePointerPosition(evt);\r\n\r\n            if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\r\n                evt.preventDefault();\r\n                elementToAttachTo.focus();\r\n            }\r\n\r\n            this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo: _ClickInfo, pickResult: Nullable<PickingInfo>) => {\r\n                // PreObservable support\r\n                if (scene.onPrePointerObservable.hasObservers()) {\r\n                    this._skipPointerTap = false;\r\n                    if (!clickInfo.ignore) {\r\n                        if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {\r\n                            // If we're skipping the next observable, we need to reset the swipe state before returning\r\n                            if (this._swipeButtonPressed === evt.button) {\r\n                                this._isSwiping = false;\r\n                                this._swipeButtonPressed = -1;\r\n                            }\r\n                            return;\r\n                        }\r\n                        if (!clickInfo.hasSwiped) {\r\n                            if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {\r\n                                    this._skipPointerTap = true;\r\n                                }\r\n                            }\r\n                            if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {\r\n                                    this._skipPointerTap = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._pointerCaptures[evt.pointerId] = false;\r\n                if (!scene.cameraToUseForPointers && !scene.activeCamera) {\r\n                    return;\r\n                }\r\n\r\n                if (!scene.pointerUpPredicate) {\r\n                    scene.pointerUpPredicate = (mesh: AbstractMesh): boolean => {\r\n                        return (\r\n                            mesh.isPickable &&\r\n                            mesh.isVisible &&\r\n                            mesh.isReady() &&\r\n                            mesh.isEnabled() &&\r\n                            (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0)\r\n                        );\r\n                    };\r\n                }\r\n\r\n                // Meshes\r\n                if (!this._meshPickProceed && ((AbstractActionManager && AbstractActionManager.HasTriggers) || this._checkForPicking() || scene.onPointerUp)) {\r\n                    this._initActionManager(null, clickInfo);\r\n                }\r\n                if (!pickResult) {\r\n                    pickResult = this._currentPickResult;\r\n                }\r\n\r\n                this._processPointerUp(pickResult, evt, clickInfo);\r\n\r\n                this._previousPickResult = this._currentPickResult;\r\n\r\n                if (this._swipeButtonPressed === evt.button) {\r\n                    this._isSwiping = false;\r\n                    this._swipeButtonPressed = -1;\r\n                }\r\n            });\r\n        };\r\n\r\n        this._onKeyDown = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYDOWN;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyDownTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        this._onKeyUp = (evt: IKeyboardEvent) => {\r\n            const type = KeyboardEventTypes.KEYUP;\r\n            if (scene.onPreKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfoPre(type, evt);\r\n                scene.onPreKeyboardObservable.notifyObservers(pi, type);\r\n                if (pi.skipOnKeyboardObservable) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (scene.onKeyboardObservable.hasObservers()) {\r\n                const pi = new KeyboardInfo(type, evt);\r\n                scene.onKeyboardObservable.notifyObservers(pi, type);\r\n            }\r\n\r\n            if (scene.actionManager) {\r\n                scene.actionManager.processTrigger(Constants.ACTION_OnKeyUpTrigger, ActionEvent.CreateNewFromScene(scene, evt));\r\n            }\r\n        };\r\n\r\n        // If a device connects that we can handle, wire up the observable\r\n        this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {\r\n            if (deviceSource.deviceType === DeviceType.Mouse) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (\r\n                        eventData.inputIndex === PointerInput.LeftClick ||\r\n                        eventData.inputIndex === PointerInput.MiddleClick ||\r\n                        eventData.inputIndex === PointerInput.RightClick ||\r\n                        eventData.inputIndex === PointerInput.BrowserBack ||\r\n                        eventData.inputIndex === PointerInput.BrowserForward\r\n                    ) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                        }\r\n                    } else if (attachMove) {\r\n                        if (eventData.inputIndex === PointerInput.Move) {\r\n                            this._onPointerMove(eventData);\r\n                        } else if (\r\n                            eventData.inputIndex === PointerInput.MouseWheelX ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelY ||\r\n                            eventData.inputIndex === PointerInput.MouseWheelZ\r\n                        ) {\r\n                            this._onPointerMove(eventData);\r\n                        }\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Touch) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.inputIndex === PointerInput.LeftClick) {\r\n                        if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\r\n                            this._onPointerDown(eventData);\r\n                        } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\r\n                            this._onPointerUp(eventData);\r\n                        }\r\n                    }\r\n\r\n                    if (attachMove && eventData.inputIndex === PointerInput.Move) {\r\n                        this._onPointerMove(eventData);\r\n                    }\r\n                });\r\n            } else if (deviceSource.deviceType === DeviceType.Keyboard) {\r\n                deviceSource.onInputChangedObservable.add((eventData) => {\r\n                    if (eventData.type === \"keydown\") {\r\n                        this._onKeyDown(eventData);\r\n                    } else if (eventData.type === \"keyup\") {\r\n                        this._onKeyUp(eventData);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        this._alreadyAttached = true;\r\n    }\r\n\r\n    /**\r\n     * Detaches all event handlers\r\n     */\r\n    public detachControl() {\r\n        if (this._alreadyAttached) {\r\n            this._deviceSourceManager!.dispose();\r\n            this._deviceSourceManager = null;\r\n\r\n            // Cursor\r\n            if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\r\n                this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\r\n            }\r\n\r\n            this._alreadyAttached = false;\r\n            this._alreadyAttachedTo = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Force the value of meshUnderPointer\r\n     * @param mesh - defines the mesh to use\r\n     * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\r\n     * @param pickResult - optional pickingInfo data used to find mesh\r\n     */\r\n    public setPointerOverMesh(mesh: Nullable<AbstractMesh>, pointerId: number = 0, pickResult?: Nullable<PickingInfo>): void {\r\n        if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\r\n            return;\r\n        }\r\n\r\n        const underPointerMesh = this._meshUnderPointerId[pointerId];\r\n\r\n        let actionManager: Nullable<AbstractActionManager>;\r\n        if (underPointerMesh) {\r\n            actionManager = underPointerMesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOutTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOutTrigger, ActionEvent.CreateNew(underPointerMesh, undefined, { pointerId }));\r\n            }\r\n        }\r\n\r\n        if (mesh) {\r\n            this._meshUnderPointerId[pointerId] = mesh;\r\n            this._pointerOverMesh = mesh;\r\n\r\n            actionManager = mesh._getActionManagerForTrigger(Constants.ACTION_OnPointerOverTrigger);\r\n            if (actionManager) {\r\n                actionManager.processTrigger(Constants.ACTION_OnPointerOverTrigger, ActionEvent.CreateNew(mesh, undefined, { pointerId, pickResult }));\r\n            }\r\n        } else {\r\n            delete this._meshUnderPointerId[pointerId];\r\n            this._pointerOverMesh = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the mesh under the pointer\r\n     * @returns a Mesh or null if no mesh is under the pointer\r\n     */\r\n    public getPointerOverMesh(): Nullable<AbstractMesh> {\r\n        return this.meshUnderPointer;\r\n    }\r\n\r\n    /**\r\n     * @param mesh - Mesh to invalidate\r\n     * @internal\r\n     */\r\n    public _invalidateMesh(mesh: AbstractMesh) {\r\n        if (this._pointerOverMesh === mesh) {\r\n            this._pointerOverMesh = null;\r\n        }\r\n        if (this._pickedDownMesh === mesh) {\r\n            this._pickedDownMesh = null;\r\n        }\r\n        if (this._pickedUpMesh === mesh) {\r\n            this._pickedUpMesh = null;\r\n        }\r\n        for (const pointerId in this._meshUnderPointerId) {\r\n            if (this._meshUnderPointerId[pointerId] === mesh) {\r\n                delete this._meshUnderPointerId[pointerId];\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}