{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject.js\";\nimport { TBNBlock } from \"../Fragment/TBNBlock.js\";\n/**\n * Block used to implement the anisotropy module of the PBR material\n */\nexport class AnisotropyBlock extends NodeMaterialBlock {\n  /**\n   * Create a new AnisotropyBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Fragment);\n    this._tangentCorrectionFactorName = \"\";\n    this._isUnique = true;\n    this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\n    this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\n    this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\n    this.registerInput(\"TBN\", NodeMaterialBlockConnectionPointTypes.Object, true, NodeMaterialBlockTargets.VertexAndFragment, new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\"));\n    this.registerOutput(\"anisotropy\", NodeMaterialBlockConnectionPointTypes.Object, NodeMaterialBlockTargets.Fragment, new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\"));\n  }\n  /**\n   * Initialize the block and prepare the context for build\n   * @param state defines the state that will be used for the build\n   */\n  initialize(state) {\n    state._excludeVariableName(\"anisotropicOut\");\n    state._excludeVariableName(\"TBN\");\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"AnisotropyBlock\";\n  }\n  /**\n   * Gets the intensity input component\n   */\n  get intensity() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the direction input component\n   */\n  get direction() {\n    return this._inputs[1];\n  }\n  /**\n   * Gets the uv input component\n   */\n  get uv() {\n    return this._inputs[2];\n  }\n  /**\n   * Gets the worldTangent input component\n   */\n  get worldTangent() {\n    return this._inputs[3];\n  }\n  /**\n   * Gets the TBN input component\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  get TBN() {\n    return this._inputs[4];\n  }\n  /**\n   * Gets the anisotropy object output component\n   */\n  get anisotropy() {\n    return this._outputs[0];\n  }\n  _generateTBNSpace(state) {\n    let code = \"\";\n    const comments = `//${this.name}`;\n    const uv = this.uv;\n    const worldPosition = this.worldPositionConnectionPoint;\n    const worldNormal = this.worldNormalConnectionPoint;\n    const worldTangent = this.worldTangent;\n    if (!uv.isConnected) {\n      // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\n      // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\n      // it will stop the building of the node material and will lead to errors in the editor!\n      console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\n    }\n    state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\n    const tangentReplaceString = {\n      search: /defined\\(TANGENT\\)/g,\n      replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\"\n    };\n    const TBN = this.TBN;\n    if (TBN.isConnected) {\n      state.compilationString += `\n            #ifdef TBNBLOCK\n            mat3 vTBN = ${TBN.associatedVariableName};\n            #endif\n            `;\n    } else if (worldTangent.isConnected) {\n      code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\r\\n`;\n      code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\n      code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\r\\n`;\n      code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\n    }\n    code += `\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\n                mat3 TBN = vTBN;\n            #else\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"}, vec2(1., 1.));\n            #endif\\r\\n`;\n    state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\n      replaceStrings: [tangentReplaceString]\n    });\n    return code;\n  }\n  /**\n   * Gets the main code of the block (fragment side)\n   * @param state current state of the node material building\n   * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\n   * @returns the shader code\n   */\n  getCode(state, generateTBNSpace = false) {\n    let code = \"\";\n    if (generateTBNSpace) {\n      code += this._generateTBNSpace(state);\n    }\n    const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\n    const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\n    code += `anisotropicOutParams anisotropicOut;\n            anisotropicBlock(\n                vec3(${direction}, ${intensity}),\n            #ifdef ANISOTROPIC_TEXTURE\n                vec3(0.),\n            #endif\n                TBN,\n                normalW,\n                viewDirectionW,\n                anisotropicOut\n            );\\r\\n`;\n    return code;\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    super.prepareDefines(mesh, nodeMaterial, defines);\n    defines.setValue(\"ANISOTROPIC\", true);\n    defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\n  }\n  bind(effect, nodeMaterial, mesh) {\n    super.bind(effect, nodeMaterial, mesh);\n    if (mesh) {\n      effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\n    }\n  }\n  _buildBlock(state) {\n    if (state.target === NodeMaterialBlockTargets.Fragment) {\n      state.sharedData.blocksWithDefines.push(this);\n      state.sharedData.bindableBlocks.push(this);\n      this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\n      state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\n    }\n    return this;\n  }\n}\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialConnectionPointDirection","NodeMaterialBlockTargets","RegisterClass","NodeMaterialConnectionPointCustomObject","TBNBlock","AnisotropyBlock","constructor","name","Fragment","_isUnique","registerInput","Float","Vector2","Vector4","Object","VertexAndFragment","Input","registerOutput","Output","initialize","state","_excludeVariableName","getClassName","intensity","_inputs","direction","uv","worldTangent","TBN","anisotropy","_outputs","_generateTBNSpace","code","comments","worldPosition","worldPositionConnectionPoint","worldNormal","worldNormalConnectionPoint","isConnected","console","error","_emitExtension","tangentReplaceString","search","replace","compilationString","associatedVariableName","_tangentCorrectionFactorName","_emitFunctionFromInclude","replaceStrings","getCode","generateTBNSpace","prepareDefines","mesh","nodeMaterial","defines","setValue","bind","effect","setFloat","getWorldMatrix","determinant","_buildBlock","target","sharedData","blocksWithDefines","push","bindableBlocks","_getFreeDefineName","_emitUniformFromString"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/PBR/anisotropyBlock.ts"],"sourcesContent":["import type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\r\nimport { TBNBlock } from \"../Fragment/TBNBlock\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Effect } from \"../../../effect\";\r\n\r\n/**\r\n * Block used to implement the anisotropy module of the PBR material\r\n */\r\nexport class AnisotropyBlock extends NodeMaterialBlock {\r\n    private _tangentCorrectionFactorName = \"\";\r\n\r\n    /**\r\n     * The two properties below are set by the main PBR block prior to calling methods of this class.\r\n     * This is to avoid having to add them as inputs here whereas they are already inputs of the main block, so already known.\r\n     * It's less burden on the user side in the editor part.\r\n     */\r\n\r\n    /** @internal */\r\n    public worldPositionConnectionPoint: NodeMaterialConnectionPoint;\r\n    /** @internal */\r\n    public worldNormalConnectionPoint: NodeMaterialConnectionPoint;\r\n\r\n    /**\r\n     * Create a new AnisotropyBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Fragment);\r\n\r\n        this._isUnique = true;\r\n\r\n        this.registerInput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector2, true, NodeMaterialBlockTargets.Fragment);\r\n        this.registerInput(\"uv\", NodeMaterialBlockConnectionPointTypes.Vector2, true); // need this property and the next one in case there's no PerturbNormal block connected to the main PBR block\r\n        this.registerInput(\"worldTangent\", NodeMaterialBlockConnectionPointTypes.Vector4, true);\r\n        this.registerInput(\r\n            \"TBN\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            true,\r\n            NodeMaterialBlockTargets.VertexAndFragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"TBN\", this, NodeMaterialConnectionPointDirection.Input, TBNBlock, \"TBNBlock\")\r\n        );\r\n\r\n        this.registerOutput(\r\n            \"anisotropy\",\r\n            NodeMaterialBlockConnectionPointTypes.Object,\r\n            NodeMaterialBlockTargets.Fragment,\r\n            new NodeMaterialConnectionPointCustomObject(\"anisotropy\", this, NodeMaterialConnectionPointDirection.Output, AnisotropyBlock, \"AnisotropyBlock\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Initialize the block and prepare the context for build\r\n     * @param state defines the state that will be used for the build\r\n     */\r\n    public initialize(state: NodeMaterialBuildState) {\r\n        state._excludeVariableName(\"anisotropicOut\");\r\n        state._excludeVariableName(\"TBN\");\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"AnisotropyBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the intensity input component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction input component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._inputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the uv input component\r\n     */\r\n    public get uv(): NodeMaterialConnectionPoint {\r\n        return this._inputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the worldTangent input component\r\n     */\r\n    public get worldTangent(): NodeMaterialConnectionPoint {\r\n        return this._inputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the TBN input component\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get TBN(): NodeMaterialConnectionPoint {\r\n        return this._inputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the anisotropy object output component\r\n     */\r\n    public get anisotropy(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    private _generateTBNSpace(state: NodeMaterialBuildState) {\r\n        let code = \"\";\r\n\r\n        const comments = `//${this.name}`;\r\n        const uv = this.uv;\r\n        const worldPosition = this.worldPositionConnectionPoint;\r\n        const worldNormal = this.worldNormalConnectionPoint;\r\n        const worldTangent = this.worldTangent;\r\n\r\n        if (!uv.isConnected) {\r\n            // we must set the uv input as optional because we may not end up in this method (in case a PerturbNormal block is linked to the PBR material)\r\n            // in which case uv is not required. But if we do come here, we do need the uv, so we have to raise an error but not with throw, else\r\n            // it will stop the building of the node material and will lead to errors in the editor!\r\n            console.error(\"You must connect the 'uv' input of the Anisotropy block!\");\r\n        }\r\n\r\n        state._emitExtension(\"derivatives\", \"#extension GL_OES_standard_derivatives : enable\");\r\n\r\n        const tangentReplaceString = { search: /defined\\(TANGENT\\)/g, replace: worldTangent.isConnected ? \"defined(TANGENT)\" : \"defined(IGNORE)\" };\r\n\r\n        const TBN = this.TBN;\r\n        if (TBN.isConnected) {\r\n            state.compilationString += `\r\n            #ifdef TBNBLOCK\r\n            mat3 vTBN = ${TBN.associatedVariableName};\r\n            #endif\r\n            `;\r\n        } else if (worldTangent.isConnected) {\r\n            code += `vec3 tbnNormal = normalize(${worldNormal.associatedVariableName}.xyz);\\r\\n`;\r\n            code += `vec3 tbnTangent = normalize(${worldTangent.associatedVariableName}.xyz);\\r\\n`;\r\n            code += `vec3 tbnBitangent = cross(tbnNormal, tbnTangent) * ${this._tangentCorrectionFactorName};\\r\\n`;\r\n            code += `mat3 vTBN = mat3(tbnTangent, tbnBitangent, tbnNormal);\\r\\n`;\r\n        }\r\n\r\n        code += `\r\n            #if defined(${worldTangent.isConnected ? \"TANGENT\" : \"IGNORE\"}) && defined(NORMAL)\r\n                mat3 TBN = vTBN;\r\n            #else\r\n                mat3 TBN = cotangent_frame(${worldNormal.associatedVariableName + \".xyz\"}, ${\"v_\" + worldPosition.associatedVariableName + \".xyz\"}, ${\r\n            uv.isConnected ? uv.associatedVariableName : \"vec2(0.)\"\r\n        }, vec2(1., 1.));\r\n            #endif\\r\\n`;\r\n\r\n        state._emitFunctionFromInclude(\"bumpFragmentMainFunctions\", comments, {\r\n            replaceStrings: [tangentReplaceString],\r\n        });\r\n\r\n        return code;\r\n    }\r\n\r\n    /**\r\n     * Gets the main code of the block (fragment side)\r\n     * @param state current state of the node material building\r\n     * @param generateTBNSpace if true, the code needed to create the TBN coordinate space is generated\r\n     * @returns the shader code\r\n     */\r\n    public getCode(state: NodeMaterialBuildState, generateTBNSpace = false): string {\r\n        let code = \"\";\r\n\r\n        if (generateTBNSpace) {\r\n            code += this._generateTBNSpace(state);\r\n        }\r\n\r\n        const intensity = this.intensity.isConnected ? this.intensity.associatedVariableName : \"1.0\";\r\n        const direction = this.direction.isConnected ? this.direction.associatedVariableName : \"vec2(1., 0.)\";\r\n\r\n        code += `anisotropicOutParams anisotropicOut;\r\n            anisotropicBlock(\r\n                vec3(${direction}, ${intensity}),\r\n            #ifdef ANISOTROPIC_TEXTURE\r\n                vec3(0.),\r\n            #endif\r\n                TBN,\r\n                normalW,\r\n                viewDirectionW,\r\n                anisotropicOut\r\n            );\\r\\n`;\r\n\r\n        return code;\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        super.prepareDefines(mesh, nodeMaterial, defines);\r\n\r\n        defines.setValue(\"ANISOTROPIC\", true);\r\n        defines.setValue(\"ANISOTROPIC_TEXTURE\", false, true);\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        super.bind(effect, nodeMaterial, mesh);\r\n\r\n        if (mesh) {\r\n            effect.setFloat(this._tangentCorrectionFactorName, mesh.getWorldMatrix().determinant() < 0 ? -1 : 1);\r\n        }\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\r\n            state.sharedData.blocksWithDefines.push(this);\r\n            state.sharedData.bindableBlocks.push(this);\r\n\r\n            this._tangentCorrectionFactorName = state._getFreeDefineName(\"tangentCorrectionFactor\");\r\n            state._emitUniformFromString(this._tangentCorrectionFactorName, \"float\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.AnisotropyBlock\", AnisotropyBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}