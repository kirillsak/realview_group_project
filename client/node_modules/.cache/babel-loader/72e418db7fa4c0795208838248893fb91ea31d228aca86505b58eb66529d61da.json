{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, Matrix, Vector2 } from \"../../Maths/math.vector.js\";\nimport { Scalar } from \"../../Maths/math.scalar.js\";\nimport { Mesh } from \"../mesh.js\";\nimport { VertexBuffer } from \"../../Buffers/buffer.js\";\nimport { VertexData } from \"../mesh.vertexData.js\";\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions.js\";\nconst xpAxis = new Vector3(1, 0, 0);\nconst xnAxis = new Vector3(-1, 0, 0);\nconst ypAxis = new Vector3(0, 1, 0);\nconst ynAxis = new Vector3(0, -1, 0);\nconst zpAxis = new Vector3(0, 0, 1);\nconst znAxis = new Vector3(0, 0, -1);\n/** @internal */\nclass DecalVertex {\n  constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero(), vertexIdx = 0, vertexIdxForBones = 0, localPositionOverride = null, localNormalOverride = null, matrixIndicesOverride = null, matrixWeightsOverride = null) {\n    this.position = position;\n    this.normal = normal;\n    this.uv = uv;\n    this.vertexIdx = vertexIdx;\n    this.vertexIdxForBones = vertexIdxForBones;\n    this.localPositionOverride = localPositionOverride;\n    this.localNormalOverride = localNormalOverride;\n    this.matrixIndicesOverride = matrixIndicesOverride;\n    this.matrixWeightsOverride = matrixWeightsOverride;\n  }\n  clone() {\n    var _a, _b, _c, _d;\n    return new DecalVertex(this.position.clone(), this.normal.clone(), this.uv.clone(), this.vertexIdx, this.vertexIdxForBones, (_a = this.localPositionOverride) === null || _a === void 0 ? void 0 : _a.slice(), (_b = this.localNormalOverride) === null || _b === void 0 ? void 0 : _b.slice(), (_c = this.matrixIndicesOverride) === null || _c === void 0 ? void 0 : _c.slice(), (_d = this.matrixWeightsOverride) === null || _d === void 0 ? void 0 : _d.slice());\n  }\n}\n/**\n * Creates a decal mesh.\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\n * Note: Meshes with morph targets are not supported!\n * @param name defines the name of the mesh\n * @param sourceMesh defines the mesh where the decal must be applied\n * @param options defines the options used to create the mesh\n * @param options.position\n * @param options.normal\n * @param options.size\n * @param options.angle\n * @param options.captureUVS\n * @param options.cullBackFaces\n * @param options.localMode\n * @returns the decal mesh\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\n */\nexport function CreateDecal(name, sourceMesh, options) {\n  const hasSkeleton = !!sourceMesh.skeleton;\n  const useLocalComputation = options.localMode || hasSkeleton;\n  const meshHasOverridenMaterial = sourceMesh.overrideMaterialSideOrientation !== null && sourceMesh.overrideMaterialSideOrientation !== undefined;\n  const indices = sourceMesh.getIndices();\n  const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\n  const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\n  const localPositions = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions : null;\n  const localNormals = useLocalComputation ? hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals : null;\n  const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\n  const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\n  const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\n  const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n  const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n  const position = options.position || Vector3.Zero();\n  let normal = options.normal || Vector3.Up();\n  const size = options.size || Vector3.One();\n  const angle = options.angle || 0;\n  // Getting correct rotation\n  if (!normal) {\n    const target = new Vector3(0, 0, 1);\n    const camera = sourceMesh.getScene().activeCamera;\n    const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n    normal = camera.globalPosition.subtract(cameraWorldTarget);\n  }\n  const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n  const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n  const pitch = Math.atan2(normal.y, len);\n  // Matrix\n  const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\n  const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\n  const meshWorldMatrix = sourceMesh.getWorldMatrix();\n  const transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n  const vertexData = new VertexData();\n  vertexData.indices = [];\n  vertexData.positions = [];\n  vertexData.normals = [];\n  vertexData.uvs = [];\n  vertexData.matricesIndices = hasSkeleton ? [] : null;\n  vertexData.matricesWeights = hasSkeleton ? [] : null;\n  vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\n  vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\n  let currentVertexDataIndex = 0;\n  const extractDecalVector3 = indexId => {\n    const result = new DecalVertex();\n    if (!indices || !positions || !normals) {\n      return result;\n    }\n    const vertexId = indices[indexId];\n    result.vertexIdx = vertexId * 3;\n    result.vertexIdxForBones = vertexId * 4;\n    // Send vector to decal local world\n    result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\n    Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\n    // Get normal\n    result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n    Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\n    if (options.captureUVS && uvs) {\n      const v = uvs[vertexId * 2 + 1];\n      result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n    }\n    return result;\n  };\n  const emptyArray = [0, 0, 0, 0];\n  // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n  const clip = (vertices, axis) => {\n    if (vertices.length === 0) {\n      return vertices;\n    }\n    const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\n    const indexOf = (arr, val, start, num) => {\n      for (let i = 0; i < num; ++i) {\n        if (arr[start + i] === val) {\n          return start + i;\n        }\n      }\n      return -1;\n    };\n    const clipVertices = (v0, v1) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n      const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n      let indices = emptyArray;\n      let weights = emptyArray;\n      if (matIndices && matWeights) {\n        const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\n        const v0Indices = (_a = v0.matrixIndicesOverride) !== null && _a !== void 0 ? _a : matIndices;\n        const v0Weights = (_b = v0.matrixWeightsOverride) !== null && _b !== void 0 ? _b : matWeights;\n        const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\n        const v1Indices = (_c = v1.matrixIndicesOverride) !== null && _c !== void 0 ? _c : matIndices;\n        const v1Weights = (_d = v1.matrixWeightsOverride) !== null && _d !== void 0 ? _d : matWeights;\n        indices = [0, 0, 0, 0];\n        weights = [0, 0, 0, 0];\n        let index = 0;\n        for (let i = 0; i < 4; ++i) {\n          if (v0Weights[mat0Index + i] > 0) {\n            const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\n            indices[index] = v0Indices[mat0Index + i];\n            weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\n            index++;\n          }\n        }\n        for (let i = 0; i < 4 && index < 4; ++i) {\n          const ind = v1Indices[mat1Index + i];\n          if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\n          indices[index] = ind;\n          weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\n          index++;\n        }\n        const sumw = weights[0] + weights[1] + weights[2] + weights[3];\n        weights[0] /= sumw;\n        weights[1] /= sumw;\n        weights[2] /= sumw;\n        weights[3] /= sumw;\n      }\n      const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : (_e = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx]) !== null && _e !== void 0 ? _e : 0;\n      const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : (_f = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 1]) !== null && _f !== void 0 ? _f : 0;\n      const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : (_g = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v0.vertexIdx + 2]) !== null && _g !== void 0 ? _g : 0;\n      const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : (_h = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx]) !== null && _h !== void 0 ? _h : 0;\n      const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : (_j = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 1]) !== null && _j !== void 0 ? _j : 0;\n      const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : (_k = localPositions === null || localPositions === void 0 ? void 0 : localPositions[v1.vertexIdx + 2]) !== null && _k !== void 0 ? _k : 0;\n      const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : (_l = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx]) !== null && _l !== void 0 ? _l : 0;\n      const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : (_m = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 1]) !== null && _m !== void 0 ? _m : 0;\n      const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : (_o = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v0.vertexIdx + 2]) !== null && _o !== void 0 ? _o : 0;\n      const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : (_p = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx]) !== null && _p !== void 0 ? _p : 0;\n      const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : (_q = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 1]) !== null && _q !== void 0 ? _q : 0;\n      const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : (_r = localNormals === null || localNormals === void 0 ? void 0 : localNormals[v1.vertexIdx + 2]) !== null && _r !== void 0 ? _r : 0;\n      const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\n      const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\n      const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\n      const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\n      return new DecalVertex(Vector3.Lerp(v0.position, v1.position, clipFactor), Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(), Vector2.Lerp(v0.uv, v1.uv, clipFactor), -1, -1, localPositions ? [v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor, v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor, v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor] : null, localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null, indices, weights);\n    };\n    let clipResult = null;\n    if (vertices.length > 3) {\n      clipResult = new Array();\n    }\n    for (let index = 0; index < vertices.length; index += 3) {\n      let total = 0;\n      let nV1 = null;\n      let nV2 = null;\n      let nV3 = null;\n      let nV4 = null;\n      const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\n      const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n      const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n      const v1Out = d1 > 0;\n      const v2Out = d2 > 0;\n      const v3Out = d3 > 0;\n      total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n      switch (total) {\n        case 0:\n          if (vertices.length > 3) {\n            clipResult.push(vertices[index]);\n            clipResult.push(vertices[index + 1]);\n            clipResult.push(vertices[index + 2]);\n          } else {\n            clipResult = vertices;\n          }\n          break;\n        case 1:\n          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();\n          if (v1Out) {\n            nV1 = vertices[index + 1];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index], nV1);\n            nV4 = clipVertices(vertices[index], nV2);\n          }\n          if (v2Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 2];\n            nV3 = clipVertices(vertices[index + 1], nV1);\n            nV4 = clipVertices(vertices[index + 1], nV2);\n            clipResult.push(nV3);\n            clipResult.push(nV2.clone());\n            clipResult.push(nV1.clone());\n            clipResult.push(nV2.clone());\n            clipResult.push(nV3.clone());\n            clipResult.push(nV4);\n            break;\n          }\n          if (v3Out) {\n            nV1 = vertices[index];\n            nV2 = vertices[index + 1];\n            nV3 = clipVertices(vertices[index + 2], nV1);\n            nV4 = clipVertices(vertices[index + 2], nV2);\n          }\n          if (nV1 && nV2 && nV3 && nV4) {\n            clipResult.push(nV1.clone());\n            clipResult.push(nV2.clone());\n            clipResult.push(nV3);\n            clipResult.push(nV4);\n            clipResult.push(nV3.clone());\n            clipResult.push(nV2.clone());\n          }\n          break;\n        case 2:\n          clipResult = clipResult !== null && clipResult !== void 0 ? clipResult : new Array();\n          if (!v1Out) {\n            nV1 = vertices[index].clone();\n            nV2 = clipVertices(nV1, vertices[index + 1]);\n            nV3 = clipVertices(nV1, vertices[index + 2]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          if (!v2Out) {\n            nV1 = vertices[index + 1].clone();\n            nV2 = clipVertices(nV1, vertices[index + 2]);\n            nV3 = clipVertices(nV1, vertices[index]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          if (!v3Out) {\n            nV1 = vertices[index + 2].clone();\n            nV2 = clipVertices(nV1, vertices[index]);\n            nV3 = clipVertices(nV1, vertices[index + 1]);\n            clipResult.push(nV1);\n            clipResult.push(nV2);\n            clipResult.push(nV3);\n          }\n          break;\n        case 3:\n          break;\n      }\n    }\n    return clipResult;\n  };\n  const oneFaceVertices = new Array(3);\n  for (let index = 0; index < indices.length; index += 3) {\n    let faceVertices = oneFaceVertices;\n    faceVertices[0] = extractDecalVector3(index);\n    if (meshHasOverridenMaterial && useLocalComputation) {\n      faceVertices[1] = extractDecalVector3(index + 2);\n      faceVertices[2] = extractDecalVector3(index + 1);\n    } else {\n      faceVertices[1] = extractDecalVector3(index + 1);\n      faceVertices[2] = extractDecalVector3(index + 2);\n    }\n    if (options.cullBackFaces) {\n      // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\n      // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\n      if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\n        continue;\n      }\n    }\n    // Clip\n    faceVertices = clip(faceVertices, xpAxis);\n    if (!faceVertices) continue;\n    faceVertices = clip(faceVertices, xnAxis);\n    if (!faceVertices) continue;\n    faceVertices = clip(faceVertices, ypAxis);\n    if (!faceVertices) continue;\n    faceVertices = clip(faceVertices, ynAxis);\n    if (!faceVertices) continue;\n    faceVertices = clip(faceVertices, zpAxis);\n    if (!faceVertices) continue;\n    faceVertices = clip(faceVertices, znAxis);\n    if (!faceVertices) continue;\n    // Add UVs and get back to world\n    for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n      const vertex = faceVertices[vIndex];\n      //TODO check for Int32Array | Uint32Array | Uint16Array\n      vertexData.indices.push(currentVertexDataIndex);\n      if (useLocalComputation) {\n        if (vertex.localPositionOverride) {\n          vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\n          vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\n          vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\n        } else if (localPositions) {\n          vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\n          vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\n          vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\n        }\n        if (vertex.localNormalOverride) {\n          vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\n          vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\n          vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\n        } else if (localNormals) {\n          vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\n          vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\n          vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\n        }\n      } else {\n        vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n        vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n      }\n      if (vertexData.matricesIndices && vertexData.matricesWeights) {\n        if (vertex.matrixIndicesOverride) {\n          vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\n          vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\n          vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\n          vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\n        } else {\n          if (matIndices) {\n            vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\n            vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\n          }\n          if (matIndicesExtra && vertexData.matricesIndicesExtra) {\n            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\n            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\n            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\n            vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\n          }\n        }\n        if (vertex.matrixWeightsOverride) {\n          vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\n          vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\n          vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\n          vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\n        } else {\n          if (matWeights) {\n            vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\n            vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\n          }\n          if (matWeightsExtra && vertexData.matricesWeightsExtra) {\n            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\n            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\n            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\n            vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\n          }\n        }\n      }\n      if (!options.captureUVS) {\n        vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n        const v = 0.5 + vertex.position.y / size.y;\n        vertexData.uvs.push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\n      } else {\n        vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\n      }\n      currentVertexDataIndex++;\n    }\n  }\n  // Return mesh\n  const decal = new Mesh(name, sourceMesh.getScene());\n  vertexData.applyToMesh(decal);\n  if (useLocalComputation) {\n    decal.skeleton = sourceMesh.skeleton;\n    decal.parent = sourceMesh;\n  } else {\n    decal.position = position.clone();\n    decal.rotation = new Vector3(pitch, yaw, angle);\n  }\n  decal.computeWorldMatrix(true);\n  decal.refreshBoundingInfo(true, true);\n  return decal;\n}\n/**\n * Class containing static functions to help procedurally build meshes\n * @deprecated use the function directly from the module\n */\nexport const DecalBuilder = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  CreateDecal\n};\nMesh.CreateDecal = (name, sourceMesh, position, normal, size, angle) => {\n  const options = {\n    position,\n    normal,\n    size,\n    angle\n  };\n  return CreateDecal(name, sourceMesh, options);\n};","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","Vector2","Scalar","Mesh","VertexBuffer","VertexData","CompatibilityOptions","xpAxis","xnAxis","ypAxis","ynAxis","zpAxis","znAxis","DecalVertex","constructor","position","Zero","normal","Up","uv","vertexIdx","vertexIdxForBones","localPositionOverride","localNormalOverride","matrixIndicesOverride","matrixWeightsOverride","clone","slice","CreateDecal","name","sourceMesh","options","hasSkeleton","skeleton","useLocalComputation","localMode","meshHasOverridenMaterial","overrideMaterialSideOrientation","undefined","indices","getIndices","positions","getPositionData","getVerticesData","PositionKind","normals","getNormalsData","NormalKind","localPositions","localNormals","uvs","UVKind","matIndices","MatricesIndicesKind","matWeights","MatricesWeightsKind","matIndicesExtra","MatricesIndicesExtraKind","matWeightsExtra","MatricesWeightsExtraKind","size","One","angle","target","camera","getScene","activeCamera","cameraWorldTarget","TransformCoordinates","getWorldMatrix","globalPosition","subtract","yaw","Math","atan2","z","x","PI","len","sqrt","pitch","y","decalWorldMatrix","RotationYawPitchRoll","multiply","Translation","inverseDecalWorldMatrix","Invert","meshWorldMatrix","transformMatrix","vertexData","matricesIndices","matricesWeights","matricesIndicesExtra","matricesWeightsExtra","currentVertexDataIndex","extractDecalVector3","indexId","result","vertexId","TransformCoordinatesToRef","TransformNormalToRef","captureUVS","v","UseOpenGLOrientationForUV","emptyArray","clip","vertices","axis","length","clipSize","abs","Dot","indexOf","arr","val","start","num","i","clipVertices","v0","v1","clipFactor","GetClipFactor","weights","mat0Index","v0Indices","v0Weights","mat1Index","v1Indices","v1Weights","index","idx","Lerp","ind","sumw","v0LocalPositionX","v0LocalPositionY","v0LocalPositionZ","v1LocalPositionX","v1LocalPositionY","v1LocalPositionZ","v0LocalNormalX","v0LocalNormalY","v0LocalNormalZ","v1LocalNormalX","v1LocalNormalY","v1LocalNormalZ","interpNormalX","interpNormalY","interpNormalZ","norm","normalize","clipResult","Array","total","nV1","nV2","nV3","nV4","d1","d2","d3","v1Out","v2Out","v3Out","push","oneFaceVertices","faceVertices","cullBackFaces","vIndex","vertex","toArray","decal","applyToMesh","parent","rotation","computeWorldMatrix","refreshBoundingInfo","DecalBuilder"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Meshes/Builders/decalBuilder.ts"],"sourcesContent":["import type { Nullable, IndicesArray, FloatArray } from \"../../types\";\r\nimport { Vector3, Matrix, Vector2 } from \"../../Maths/math.vector\";\r\nimport { Scalar } from \"../../Maths/math.scalar\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\nconst xpAxis = new Vector3(1, 0, 0);\r\nconst xnAxis = new Vector3(-1, 0, 0);\r\nconst ypAxis = new Vector3(0, 1, 0);\r\nconst ynAxis = new Vector3(0, -1, 0);\r\nconst zpAxis = new Vector3(0, 0, 1);\r\nconst znAxis = new Vector3(0, 0, -1);\r\n\r\n/** @internal */\r\nclass DecalVertex {\r\n    constructor(\r\n        public position: Vector3 = Vector3.Zero(),\r\n        public normal: Vector3 = Vector3.Up(),\r\n        public uv: Vector2 = Vector2.Zero(),\r\n        public vertexIdx: number = 0,\r\n        public vertexIdxForBones: number = 0,\r\n        public localPositionOverride: Nullable<number[]> = null,\r\n        public localNormalOverride: Nullable<number[]> = null,\r\n        public matrixIndicesOverride: Nullable<number[]> = null,\r\n        public matrixWeightsOverride: Nullable<number[]> = null\r\n    ) {}\r\n    public clone(): DecalVertex {\r\n        return new DecalVertex(\r\n            this.position.clone(),\r\n            this.normal.clone(),\r\n            this.uv.clone(),\r\n            this.vertexIdx,\r\n            this.vertexIdxForBones,\r\n            this.localPositionOverride?.slice(),\r\n            this.localNormalOverride?.slice(),\r\n            this.matrixIndicesOverride?.slice(),\r\n            this.matrixWeightsOverride?.slice()\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a decal mesh.\r\n * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n * * The parameter `captureUVS` defines if we need to capture the uvs or compute them\r\n * * The parameter `cullBackFaces` defines if the back faces should be removed from the decal mesh\r\n * * The parameter `localMode` defines that the computations should be done with the local mesh coordinates instead of the world space coordinates.\r\n * *    Use this mode if you want the decal to be parented to the sourceMesh and move/rotate with it.\r\n * Note: Meshes with morph targets are not supported!\r\n * @param name defines the name of the mesh\r\n * @param sourceMesh defines the mesh where the decal must be applied\r\n * @param options defines the options used to create the mesh\r\n * @param options.position\r\n * @param options.normal\r\n * @param options.size\r\n * @param options.angle\r\n * @param options.captureUVS\r\n * @param options.cullBackFaces\r\n * @param options.localMode\r\n * @returns the decal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/decals\r\n */\r\nexport function CreateDecal(\r\n    name: string,\r\n    sourceMesh: AbstractMesh,\r\n    options: { position?: Vector3; normal?: Vector3; size?: Vector3; angle?: number; captureUVS?: boolean; cullBackFaces?: boolean; localMode?: boolean }\r\n): Mesh {\r\n    const hasSkeleton = !!sourceMesh.skeleton;\r\n    const useLocalComputation = options.localMode || hasSkeleton;\r\n    const meshHasOverridenMaterial = (sourceMesh as Mesh).overrideMaterialSideOrientation !== null && (sourceMesh as Mesh).overrideMaterialSideOrientation !== undefined;\r\n\r\n    const indices = <IndicesArray>sourceMesh.getIndices();\r\n    const positions = hasSkeleton ? sourceMesh.getPositionData(true, true) : sourceMesh.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = hasSkeleton ? sourceMesh.getNormalsData(true, true) : sourceMesh.getVerticesData(VertexBuffer.NormalKind);\r\n    const localPositions = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.PositionKind) : positions) : null;\r\n    const localNormals = useLocalComputation ? (hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.NormalKind) : normals) : null;\r\n    const uvs = sourceMesh.getVerticesData(VertexBuffer.UVKind);\r\n    const matIndices = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesKind) : null;\r\n    const matWeights = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsKind) : null;\r\n    const matIndicesExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\r\n    const matWeightsExtra = hasSkeleton ? sourceMesh.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\r\n\r\n    const position = options.position || Vector3.Zero();\r\n    let normal = options.normal || Vector3.Up();\r\n    const size = options.size || Vector3.One();\r\n    const angle = options.angle || 0;\r\n\r\n    // Getting correct rotation\r\n    if (!normal) {\r\n        const target = new Vector3(0, 0, 1);\r\n        const camera = <Camera>sourceMesh.getScene().activeCamera;\r\n        const cameraWorldTarget = Vector3.TransformCoordinates(target, camera.getWorldMatrix());\r\n\r\n        normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n    }\r\n\r\n    const yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n    const len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n    const pitch = Math.atan2(normal.y, len);\r\n\r\n    // Matrix\r\n    const decalWorldMatrix = Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(Matrix.Translation(position.x, position.y, position.z));\r\n    const inverseDecalWorldMatrix = Matrix.Invert(decalWorldMatrix);\r\n    const meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n    const transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\r\n\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = [];\r\n    vertexData.positions = [];\r\n    vertexData.normals = [];\r\n    vertexData.uvs = [];\r\n    vertexData.matricesIndices = hasSkeleton ? [] : null;\r\n    vertexData.matricesWeights = hasSkeleton ? [] : null;\r\n    vertexData.matricesIndicesExtra = matIndicesExtra ? [] : null;\r\n    vertexData.matricesWeightsExtra = matWeightsExtra ? [] : null;\r\n\r\n    let currentVertexDataIndex = 0;\r\n\r\n    const extractDecalVector3 = (indexId: number): DecalVertex => {\r\n        const result = new DecalVertex();\r\n        if (!indices || !positions || !normals) {\r\n            return result;\r\n        }\r\n\r\n        const vertexId = indices[indexId];\r\n\r\n        result.vertexIdx = vertexId * 3;\r\n        result.vertexIdxForBones = vertexId * 4;\r\n\r\n        // Send vector to decal local world\r\n        result.position = new Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n        Vector3.TransformCoordinatesToRef(result.position, transformMatrix, result.position);\r\n\r\n        // Get normal\r\n        result.normal = new Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n        Vector3.TransformNormalToRef(result.normal, transformMatrix, result.normal);\r\n\r\n        if (options.captureUVS && uvs) {\r\n            const v = uvs[vertexId * 2 + 1];\r\n            result.uv = new Vector2(uvs[vertexId * 2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    const emptyArray = [0, 0, 0, 0];\r\n\r\n    // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n    const clip = (vertices: DecalVertex[], axis: Vector3): Nullable<DecalVertex[]> => {\r\n        if (vertices.length === 0) {\r\n            return vertices;\r\n        }\r\n\r\n        const clipSize = 0.5 * Math.abs(Vector3.Dot(size, axis));\r\n\r\n        const indexOf = (arr: FloatArray | number[], val: number, start: number, num: number) => {\r\n            for (let i = 0; i < num; ++i) {\r\n                if (arr[start + i] === val) {\r\n                    return start + i;\r\n                }\r\n            }\r\n            return -1;\r\n        };\r\n\r\n        const clipVertices = (v0: DecalVertex, v1: DecalVertex): DecalVertex => {\r\n            const clipFactor = Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n\r\n            let indices = emptyArray;\r\n            let weights = emptyArray;\r\n\r\n            if (matIndices && matWeights) {\r\n                const mat0Index = v0.matrixIndicesOverride ? 0 : v0.vertexIdxForBones;\r\n                const v0Indices = v0.matrixIndicesOverride ?? matIndices;\r\n                const v0Weights = v0.matrixWeightsOverride ?? matWeights;\r\n\r\n                const mat1Index = v1.matrixIndicesOverride ? 0 : v1.vertexIdxForBones;\r\n                const v1Indices = v1.matrixIndicesOverride ?? matIndices;\r\n                const v1Weights = v1.matrixWeightsOverride ?? matWeights;\r\n\r\n                indices = [0, 0, 0, 0];\r\n                weights = [0, 0, 0, 0];\r\n\r\n                let index = 0;\r\n                for (let i = 0; i < 4; ++i) {\r\n                    if (v0Weights[mat0Index + i] > 0) {\r\n                        const idx = indexOf(v1Indices, v0Indices[mat0Index + i], mat1Index, 4);\r\n                        indices[index] = v0Indices[mat0Index + i];\r\n                        weights[index] = Scalar.Lerp(v0Weights[mat0Index + i], idx >= 0 ? v1Weights[idx] : 0, clipFactor);\r\n                        index++;\r\n                    }\r\n                }\r\n\r\n                for (let i = 0; i < 4 && index < 4; ++i) {\r\n                    const ind = v1Indices[mat1Index + i];\r\n                    if (indexOf(v0Indices, ind, mat0Index, 4) !== -1) continue;\r\n\r\n                    indices[index] = ind;\r\n                    weights[index] = Scalar.Lerp(0, v1Weights[mat1Index + i], clipFactor);\r\n                    index++;\r\n                }\r\n\r\n                const sumw = weights[0] + weights[1] + weights[2] + weights[3];\r\n\r\n                weights[0] /= sumw;\r\n                weights[1] /= sumw;\r\n                weights[2] /= sumw;\r\n                weights[3] /= sumw;\r\n            }\r\n\r\n            const v0LocalPositionX = v0.localPositionOverride ? v0.localPositionOverride[0] : localPositions?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalPositionY = v0.localPositionOverride ? v0.localPositionOverride[1] : localPositions?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalPositionZ = v0.localPositionOverride ? v0.localPositionOverride[2] : localPositions?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalPositionX = v1.localPositionOverride ? v1.localPositionOverride[0] : localPositions?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalPositionY = v1.localPositionOverride ? v1.localPositionOverride[1] : localPositions?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalPositionZ = v1.localPositionOverride ? v1.localPositionOverride[2] : localPositions?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const v0LocalNormalX = v0.localNormalOverride ? v0.localNormalOverride[0] : localNormals?.[v0.vertexIdx] ?? 0;\r\n            const v0LocalNormalY = v0.localNormalOverride ? v0.localNormalOverride[1] : localNormals?.[v0.vertexIdx + 1] ?? 0;\r\n            const v0LocalNormalZ = v0.localNormalOverride ? v0.localNormalOverride[2] : localNormals?.[v0.vertexIdx + 2] ?? 0;\r\n\r\n            const v1LocalNormalX = v1.localNormalOverride ? v1.localNormalOverride[0] : localNormals?.[v1.vertexIdx] ?? 0;\r\n            const v1LocalNormalY = v1.localNormalOverride ? v1.localNormalOverride[1] : localNormals?.[v1.vertexIdx + 1] ?? 0;\r\n            const v1LocalNormalZ = v1.localNormalOverride ? v1.localNormalOverride[2] : localNormals?.[v1.vertexIdx + 2] ?? 0;\r\n\r\n            const interpNormalX = v0LocalNormalX + (v1LocalNormalX - v0LocalNormalX) * clipFactor;\r\n            const interpNormalY = v0LocalNormalY + (v1LocalNormalY - v0LocalNormalY) * clipFactor;\r\n            const interpNormalZ = v0LocalNormalZ + (v1LocalNormalZ - v0LocalNormalZ) * clipFactor;\r\n\r\n            const norm = Math.sqrt(interpNormalX * interpNormalX + interpNormalY * interpNormalY + interpNormalZ * interpNormalZ);\r\n\r\n            return new DecalVertex(\r\n                Vector3.Lerp(v0.position, v1.position, clipFactor),\r\n                Vector3.Lerp(v0.normal, v1.normal, clipFactor).normalize(),\r\n                Vector2.Lerp(v0.uv, v1.uv, clipFactor),\r\n                -1,\r\n                -1,\r\n                localPositions\r\n                    ? [\r\n                          v0LocalPositionX + (v1LocalPositionX - v0LocalPositionX) * clipFactor,\r\n                          v0LocalPositionY + (v1LocalPositionY - v0LocalPositionY) * clipFactor,\r\n                          v0LocalPositionZ + (v1LocalPositionZ - v0LocalPositionZ) * clipFactor,\r\n                      ]\r\n                    : null,\r\n                localNormals ? [interpNormalX / norm, interpNormalY / norm, interpNormalZ / norm] : null,\r\n                indices,\r\n                weights\r\n            );\r\n        };\r\n\r\n        let clipResult: Nullable<DecalVertex[]> = null;\r\n\r\n        if (vertices.length > 3) {\r\n            clipResult = new Array<DecalVertex>();\r\n        }\r\n\r\n        for (let index = 0; index < vertices.length; index += 3) {\r\n            let total = 0;\r\n            let nV1: Nullable<DecalVertex> = null;\r\n            let nV2: Nullable<DecalVertex> = null;\r\n            let nV3: Nullable<DecalVertex> = null;\r\n            let nV4: Nullable<DecalVertex> = null;\r\n\r\n            const d1 = Vector3.Dot(vertices[index].position, axis) - clipSize;\r\n            const d2 = Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\r\n            const d3 = Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\r\n\r\n            const v1Out = d1 > 0;\r\n            const v2Out = d2 > 0;\r\n            const v3Out = d3 > 0;\r\n\r\n            total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n\r\n            switch (total) {\r\n                case 0:\r\n                    if (vertices.length > 3) {\r\n                        clipResult!.push(vertices[index]);\r\n                        clipResult!.push(vertices[index + 1]);\r\n                        clipResult!.push(vertices[index + 2]);\r\n                    } else {\r\n                        clipResult = vertices;\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (v1Out) {\r\n                        nV1 = vertices[index + 1];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index], nV1);\r\n                        nV4 = clipVertices(vertices[index], nV2);\r\n                    }\r\n\r\n                    if (v2Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 2];\r\n                        nV3 = clipVertices(vertices[index + 1], nV1);\r\n                        nV4 = clipVertices(vertices[index + 1], nV2);\r\n\r\n                        clipResult.push(nV3);\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV1.clone());\r\n\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV4);\r\n                        break;\r\n                    }\r\n                    if (v3Out) {\r\n                        nV1 = vertices[index];\r\n                        nV2 = vertices[index + 1];\r\n                        nV3 = clipVertices(vertices[index + 2], nV1);\r\n                        nV4 = clipVertices(vertices[index + 2], nV2);\r\n                    }\r\n\r\n                    if (nV1 && nV2 && nV3 && nV4) {\r\n                        clipResult.push(nV1.clone());\r\n                        clipResult.push(nV2.clone());\r\n                        clipResult.push(nV3);\r\n\r\n                        clipResult.push(nV4);\r\n                        clipResult.push(nV3.clone());\r\n                        clipResult.push(nV2.clone());\r\n                    }\r\n                    break;\r\n                case 2:\r\n                    clipResult = clipResult ?? new Array<DecalVertex>();\r\n                    if (!v1Out) {\r\n                        nV1 = vertices[index].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v2Out) {\r\n                        nV1 = vertices[index + 1].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                        nV3 = clipVertices(nV1, vertices[index]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    if (!v3Out) {\r\n                        nV1 = vertices[index + 2].clone();\r\n                        nV2 = clipVertices(nV1, vertices[index]);\r\n                        nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                        clipResult.push(nV1);\r\n                        clipResult.push(nV2);\r\n                        clipResult.push(nV3);\r\n                    }\r\n                    break;\r\n                case 3:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return clipResult;\r\n    };\r\n\r\n    const oneFaceVertices = new Array<DecalVertex>(3);\r\n\r\n    for (let index = 0; index < indices.length; index += 3) {\r\n        let faceVertices: Nullable<DecalVertex[]> = oneFaceVertices;\r\n\r\n        faceVertices[0] = extractDecalVector3(index);\r\n        if (meshHasOverridenMaterial && useLocalComputation) {\r\n            faceVertices[1] = extractDecalVector3(index + 2);\r\n            faceVertices[2] = extractDecalVector3(index + 1);\r\n        } else {\r\n            faceVertices[1] = extractDecalVector3(index + 1);\r\n            faceVertices[2] = extractDecalVector3(index + 2);\r\n        }\r\n\r\n        if (options.cullBackFaces) {\r\n            // If all the normals of the vertices of the face are pointing away from the view direction we discard the face.\r\n            // As computations are done in the decal coordinate space, the viewDirection is (0,0,1), so when dot(vertexNormal, -viewDirection) <= 0 the vertex is culled\r\n            if (-faceVertices[0].normal.z <= 0 && -faceVertices[1].normal.z <= 0 && -faceVertices[2].normal.z <= 0) {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // Clip\r\n        faceVertices = clip(faceVertices, xpAxis);\r\n        if (!faceVertices) continue;\r\n        faceVertices = clip(faceVertices, xnAxis);\r\n        if (!faceVertices) continue;\r\n        faceVertices = clip(faceVertices, ypAxis);\r\n        if (!faceVertices) continue;\r\n        faceVertices = clip(faceVertices, ynAxis);\r\n        if (!faceVertices) continue;\r\n        faceVertices = clip(faceVertices, zpAxis);\r\n        if (!faceVertices) continue;\r\n        faceVertices = clip(faceVertices, znAxis);\r\n        if (!faceVertices) continue;\r\n\r\n        // Add UVs and get back to world\r\n        for (let vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n            const vertex = faceVertices[vIndex];\r\n\r\n            //TODO check for Int32Array | Uint32Array | Uint16Array\r\n            (<number[]>vertexData.indices).push(currentVertexDataIndex);\r\n            if (useLocalComputation) {\r\n                if (vertex.localPositionOverride) {\r\n                    vertexData.positions[currentVertexDataIndex * 3] = vertex.localPositionOverride[0];\r\n                    vertexData.positions[currentVertexDataIndex * 3 + 1] = vertex.localPositionOverride[1];\r\n                    vertexData.positions[currentVertexDataIndex * 3 + 2] = vertex.localPositionOverride[2];\r\n                } else if (localPositions) {\r\n                    vertexData.positions[currentVertexDataIndex * 3] = localPositions[vertex.vertexIdx];\r\n                    vertexData.positions[currentVertexDataIndex * 3 + 1] = localPositions[vertex.vertexIdx + 1];\r\n                    vertexData.positions[currentVertexDataIndex * 3 + 2] = localPositions[vertex.vertexIdx + 2];\r\n                }\r\n                if (vertex.localNormalOverride) {\r\n                    vertexData.normals[currentVertexDataIndex * 3] = vertex.localNormalOverride[0];\r\n                    vertexData.normals[currentVertexDataIndex * 3 + 1] = vertex.localNormalOverride[1];\r\n                    vertexData.normals[currentVertexDataIndex * 3 + 2] = vertex.localNormalOverride[2];\r\n                } else if (localNormals) {\r\n                    vertexData.normals[currentVertexDataIndex * 3] = localNormals[vertex.vertexIdx];\r\n                    vertexData.normals[currentVertexDataIndex * 3 + 1] = localNormals[vertex.vertexIdx + 1];\r\n                    vertexData.normals[currentVertexDataIndex * 3 + 2] = localNormals[vertex.vertexIdx + 2];\r\n                }\r\n            } else {\r\n                vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n            }\r\n            if (vertexData.matricesIndices && vertexData.matricesWeights) {\r\n                if (vertex.matrixIndicesOverride) {\r\n                    vertexData.matricesIndices[currentVertexDataIndex * 4] = vertex.matrixIndicesOverride[0];\r\n                    vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = vertex.matrixIndicesOverride[1];\r\n                    vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = vertex.matrixIndicesOverride[2];\r\n                    vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = vertex.matrixIndicesOverride[3];\r\n                } else {\r\n                    if (matIndices) {\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4] = matIndices[vertex.vertexIdxForBones];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 1] = matIndices[vertex.vertexIdxForBones + 1];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 2] = matIndices[vertex.vertexIdxForBones + 2];\r\n                        vertexData.matricesIndices[currentVertexDataIndex * 4 + 3] = matIndices[vertex.vertexIdxForBones + 3];\r\n                    }\r\n                    if (matIndicesExtra && vertexData.matricesIndicesExtra) {\r\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4] = matIndicesExtra[vertex.vertexIdxForBones];\r\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 1] = matIndicesExtra[vertex.vertexIdxForBones + 1];\r\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 2] = matIndicesExtra[vertex.vertexIdxForBones + 2];\r\n                        vertexData.matricesIndicesExtra[currentVertexDataIndex * 4 + 3] = matIndicesExtra[vertex.vertexIdxForBones + 3];\r\n                    }\r\n                }\r\n                if (vertex.matrixWeightsOverride) {\r\n                    vertexData.matricesWeights[currentVertexDataIndex * 4] = vertex.matrixWeightsOverride[0];\r\n                    vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = vertex.matrixWeightsOverride[1];\r\n                    vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = vertex.matrixWeightsOverride[2];\r\n                    vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = vertex.matrixWeightsOverride[3];\r\n                } else {\r\n                    if (matWeights) {\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4] = matWeights[vertex.vertexIdxForBones];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 1] = matWeights[vertex.vertexIdxForBones + 1];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 2] = matWeights[vertex.vertexIdxForBones + 2];\r\n                        vertexData.matricesWeights[currentVertexDataIndex * 4 + 3] = matWeights[vertex.vertexIdxForBones + 3];\r\n                    }\r\n                    if (matWeightsExtra && vertexData.matricesWeightsExtra) {\r\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4] = matWeightsExtra[vertex.vertexIdxForBones];\r\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 1] = matWeightsExtra[vertex.vertexIdxForBones + 1];\r\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 2] = matWeightsExtra[vertex.vertexIdxForBones + 2];\r\n                        vertexData.matricesWeightsExtra[currentVertexDataIndex * 4 + 3] = matWeightsExtra[vertex.vertexIdxForBones + 3];\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!options.captureUVS) {\r\n                (<number[]>vertexData.uvs).push(0.5 + vertex.position.x / size.x);\r\n                const v = 0.5 + vertex.position.y / size.y;\r\n                (<number[]>vertexData.uvs).push(CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n            } else {\r\n                vertex.uv.toArray(vertexData.uvs, currentVertexDataIndex * 2);\r\n            }\r\n            currentVertexDataIndex++;\r\n        }\r\n    }\r\n\r\n    // Return mesh\r\n    const decal = new Mesh(name, sourceMesh.getScene());\r\n    vertexData.applyToMesh(decal);\r\n\r\n    if (useLocalComputation) {\r\n        decal.skeleton = sourceMesh.skeleton;\r\n        decal.parent = sourceMesh;\r\n    } else {\r\n        decal.position = position.clone();\r\n        decal.rotation = new Vector3(pitch, yaw, angle);\r\n    }\r\n\r\n    decal.computeWorldMatrix(true);\r\n    decal.refreshBoundingInfo(true, true);\r\n\r\n    return decal;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const DecalBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDecal,\r\n};\r\n\r\n(Mesh as any).CreateDecal = (name: string, sourceMesh: AbstractMesh, position: Vector3, normal: Vector3, size: Vector3, angle: number): Mesh => {\r\n    const options = {\r\n        position,\r\n        normal,\r\n        size,\r\n        angle,\r\n    };\r\n\r\n    return CreateDecal(name, sourceMesh, options);\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}