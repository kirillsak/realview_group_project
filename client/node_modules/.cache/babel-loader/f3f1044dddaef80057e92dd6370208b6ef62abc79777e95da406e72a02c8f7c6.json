{"ast":null,"code":"import { Texture } from \"../Materials/Textures/texture.js\";\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture.js\";\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess.js\";\nimport { Logger } from \"./logger.js\";\nimport { Tools } from \"./tools.js\";\nimport { DumpTools } from \"./dumpTools.js\";\nlet screenshotCanvas = null;\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback defines the callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param forceDownload force the system to download the image even if a successCallback is provided\n */\nexport function CreateScreenshot(engine, camera, size, successCallback, mimeType = \"image/png\", forceDownload = false) {\n  const {\n    height,\n    width\n  } = _GetScreenshotSize(engine, camera, size);\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n  if (!screenshotCanvas) {\n    screenshotCanvas = document.createElement(\"canvas\");\n  }\n  screenshotCanvas.width = width;\n  screenshotCanvas.height = height;\n  const renderContext = screenshotCanvas.getContext(\"2d\");\n  const ratio = engine.getRenderWidth() / engine.getRenderHeight();\n  let newWidth = width;\n  let newHeight = newWidth / ratio;\n  if (newHeight > height) {\n    newHeight = height;\n    newWidth = newHeight * ratio;\n  }\n  const offsetX = Math.max(0, width - newWidth) / 2;\n  const offsetY = Math.max(0, height - newHeight) / 2;\n  const scene = camera.getScene();\n  if (scene.activeCamera !== camera) {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, data => {\n      if (forceDownload) {\n        const blob = new Blob([data]);\n        Tools.DownloadBlob(blob);\n        if (successCallback) {\n          successCallback(\"\");\n        }\n      } else if (successCallback) {\n        successCallback(data);\n      }\n    }, mimeType, 1, engine.getCreationOptions().antialias);\n  } else {\n    engine.onEndFrameObservable.addOnce(() => {\n      const renderingCanvas = engine.getRenderingCanvas();\n      if (renderContext && renderingCanvas) {\n        renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\n      }\n      if (screenshotCanvas) {\n        if (forceDownload) {\n          Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType);\n          if (successCallback) {\n            successCallback(\"\");\n          }\n        } else {\n          Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType);\n        }\n      }\n    });\n  }\n}\n/**\n * Captures a screenshot of the current rendering\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotAsync(engine, camera, size, mimeType = \"image/png\") {\n  return new Promise((resolve, reject) => {\n    CreateScreenshot(engine, camera, size, data => {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType);\n  });\n}\n/**\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine defines the rendering engine\n * @param camera defines the source camera\n * @param width defines the expected width\n * @param height defines the expected height\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotWithResizeAsync(engine, camera, width, height, mimeType = \"image/png\") {\n  return new Promise(resolve => {\n    CreateScreenshot(engine, camera, {\n      width: width,\n      height: height\n    }, () => {\n      resolve();\n    }, mimeType, true);\n  });\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param successCallback The callback receives a single parameter which contains the\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\n * src parameter of an <img> to display it\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n */\nexport function CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true) {\n  const {\n    height,\n    width\n  } = _GetScreenshotSize(engine, camera, size);\n  const targetTextureSize = {\n    width,\n    height\n  };\n  if (!(height && width)) {\n    Logger.Error(\"Invalid 'size' parameter !\");\n    return;\n  }\n  const originalSize = {\n    width: engine.getRenderWidth(),\n    height: engine.getRenderHeight()\n  };\n  engine.setSize(width, height); // we need this call to trigger onResizeObservable with the screenshot width/height on all the subsystems that are observing this event and that needs to (re)create some resources with the right dimensions\n  const scene = camera.getScene();\n  // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n  const texture = new RenderTargetTexture(\"screenShot\", targetTextureSize, scene, false, false, 0, false, Texture.NEAREST_SAMPLINGMODE, undefined, enableStencilBuffer, undefined, undefined, undefined, samples);\n  texture.renderList = scene.meshes.slice();\n  texture.samples = samples;\n  texture.renderSprites = renderSprites;\n  texture.activeCamera = camera;\n  texture.forceLayerMaskCheck = useLayerMask;\n  const renderToTexture = () => {\n    engine.onEndFrameObservable.addOnce(() => {\n      texture.readPixels(undefined, undefined, undefined, false).then(data => {\n        DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true);\n        texture.dispose();\n      });\n    });\n    // render the RTT\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n    texture.render(true);\n    // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\n    // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\n    scene.incrementRenderId();\n    scene.resetCachedMaterial();\n    engine.setSize(originalSize.width, originalSize.height);\n    camera.getProjectionMatrix(true); // Force cache refresh;\n    scene.render();\n  };\n  if (antialiasing) {\n    const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\n    texture.addPostProcess(fxaaPostProcess);\n    // Async Shader Compilation can lead to none ready effects in synchronous code\n    if (!fxaaPostProcess.getEffect().isReady()) {\n      fxaaPostProcess.getEffect().onCompiled = () => {\n        renderToTexture();\n      };\n    }\n    // The effect is ready we can render\n    else {\n      renderToTexture();\n    }\n  } else {\n    // No need to wait for extra resources to be ready\n    renderToTexture();\n  }\n}\n/**\n * Generates an image screenshot from the specified camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n * @param engine The engine to use for rendering\n * @param camera The camera to use for rendering\n * @param size This parameter can be set to a single number or to an object with the\n * following (optional) properties: precision, width, height. If a single number is passed,\n * it will be used for both width and height. If an object is passed, the screenshot size\n * will be derived from the parameters. The precision property is a multiplier allowing\n * rendering at a higher or lower resolution\n * @param mimeType The MIME type of the screenshot image (default: image/png).\n * Check your browser for supported MIME types\n * @param samples Texture samples (default: 1)\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n * @param fileName A name for for the downloaded file.\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n * to the src parameter of an <img> to display it\n */\nexport function CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = \"image/png\", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true) {\n  return new Promise((resolve, reject) => {\n    CreateScreenshotUsingRenderTarget(engine, camera, size, data => {\n      if (typeof data !== \"undefined\") {\n        resolve(data);\n      } else {\n        reject(new Error(\"Data is undefined\"));\n      }\n    }, mimeType, samples, antialiasing, fileName, renderSprites, enableStencilBuffer, useLayerMask);\n  });\n}\n/**\n * Gets height and width for screenshot size\n * @param engine\n * @param camera\n * @param size\n * @private\n */\nfunction _GetScreenshotSize(engine, camera, size) {\n  let height = 0;\n  let width = 0;\n  //If a size value defined as object\n  if (typeof size === \"object\") {\n    const precision = size.precision ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\n    : 1;\n    //If a width and height values is specified\n    if (size.width && size.height) {\n      height = size.height * precision;\n      width = size.width * precision;\n    }\n    //If passing only width, computing height to keep display canvas ratio.\n    else if (size.width && !size.height) {\n      width = size.width * precision;\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n    //If passing only height, computing width to keep display canvas ratio.\n    else if (size.height && !size.width) {\n      height = size.height * precision;\n      width = Math.round(height * engine.getAspectRatio(camera));\n    } else {\n      width = Math.round(engine.getRenderWidth() * precision);\n      height = Math.round(width / engine.getAspectRatio(camera));\n    }\n  }\n  //Assuming here that \"size\" parameter is a number\n  else if (!isNaN(size)) {\n    height = size;\n    width = size;\n  }\n  // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\n  // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\n  // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\n  // to resolve this, we truncate the floats here to ensure the same size\n  if (width) {\n    width = Math.floor(width);\n  }\n  if (height) {\n    height = Math.floor(height);\n  }\n  return {\n    height: height | 0,\n    width: width | 0\n  };\n}\n/**\n * Class containing a set of static utilities functions for screenshots\n */\nexport const ScreenshotTools = {\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback defines the callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param forceDownload force the system to download the image even if a successCallback is provided\n   */\n  CreateScreenshot,\n  /**\n   * Captures a screenshot of the current rendering\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotAsync,\n  /**\n   * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine defines the rendering engine\n   * @param camera defines the source camera\n   * @param width defines the expected width\n   * @param height defines the expected height\n   * @param mimeType defines the MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotWithResizeAsync,\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param successCallback The callback receives a single parameter which contains the\n   * screenshot as a string of base64-encoded characters. This string can be assigned to the\n   * src parameter of an <img> to display it\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\n   */\n  CreateScreenshotUsingRenderTarget,\n  /**\n   * Generates an image screenshot from the specified camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\n   * @param engine The engine to use for rendering\n   * @param camera The camera to use for rendering\n   * @param size This parameter can be set to a single number or to an object with the\n   * following (optional) properties: precision, width, height. If a single number is passed,\n   * it will be used for both width and height. If an object is passed, the screenshot size\n   * will be derived from the parameters. The precision property is a multiplier allowing\n   * rendering at a higher or lower resolution\n   * @param mimeType The MIME type of the screenshot image (default: image/png).\n   * Check your browser for supported MIME types\n   * @param samples Texture samples (default: 1)\n   * @param antialiasing Whether antialiasing should be turned on or not (default: false)\n   * @param fileName A name for for the downloaded file.\n   * @param renderSprites Whether the sprites should be rendered or not (default: false)\n   * @returns screenshot as a string of base64-encoded characters. This string can be assigned\n   * to the src parameter of an <img> to display it\n   */\n  CreateScreenshotUsingRenderTargetAsync\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst initSideEffects = () => {\n  // References the dependencies.\n  Tools.CreateScreenshot = CreateScreenshot;\n  Tools.CreateScreenshotAsync = CreateScreenshotAsync;\n  Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\n  Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\n};\ninitSideEffects();","map":{"version":3,"mappings":"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","names":["Texture","RenderTargetTexture","FxaaPostProcess","Logger","Tools","DumpTools","screenshotCanvas","CreateScreenshot","engine","camera","size","successCallback","mimeType","forceDownload","height","width","_GetScreenshotSize","Error","document","createElement","renderContext","getContext","ratio","getRenderWidth","getRenderHeight","newWidth","newHeight","offsetX","Math","max","offsetY","scene","getScene","activeCamera","CreateScreenshotUsingRenderTarget","data","blob","Blob","DownloadBlob","getCreationOptions","antialias","onEndFrameObservable","addOnce","renderingCanvas","getRenderingCanvas","drawImage","EncodeScreenshotCanvasData","undefined","CreateScreenshotAsync","Promise","resolve","reject","CreateScreenshotWithResizeAsync","samples","antialiasing","fileName","renderSprites","enableStencilBuffer","useLayerMask","targetTextureSize","originalSize","setSize","texture","renderList","meshes","slice","forceLayerMaskCheck","renderToTexture","readPixels","then","DumpData","dispose","incrementRenderId","resetCachedMaterial","render","getProjectionMatrix","fxaaPostProcess","addPostProcess","getEffect","isReady","onCompiled","CreateScreenshotUsingRenderTargetAsync","precision","abs","round","getAspectRatio","isNaN","floor","ScreenshotTools","initSideEffects"],"sourceRoot":"","sources":["../../../../lts/core/generated/Misc/screenshotTools.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { FxaaPostProcess } from \"../PostProcesses/fxaaPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"./logger\";\r\nimport { Tools } from \"./tools\";\r\nimport type { IScreenshotSize } from \"./interfaces/screenshotSize\";\r\nimport { DumpTools } from \"./dumpTools\";\r\nimport type { Nullable } from \"../types\";\r\n\r\ndeclare type Engine = import(\"../Engines/engine\").Engine;\r\n\r\nlet screenshotCanvas: Nullable<HTMLCanvasElement> = null;\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback defines the callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param forceDownload force the system to download the image even if a successCallback is provided\r\n */\r\nexport function CreateScreenshot(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType: string = \"image/png\",\r\n    forceDownload = false\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    if (!screenshotCanvas) {\r\n        screenshotCanvas = document.createElement(\"canvas\");\r\n    }\r\n\r\n    screenshotCanvas.width = width;\r\n    screenshotCanvas.height = height;\r\n\r\n    const renderContext = screenshotCanvas.getContext(\"2d\");\r\n\r\n    const ratio = engine.getRenderWidth() / engine.getRenderHeight();\r\n    let newWidth = width;\r\n    let newHeight = newWidth / ratio;\r\n    if (newHeight > height) {\r\n        newHeight = height;\r\n        newWidth = newHeight * ratio;\r\n    }\r\n\r\n    const offsetX = Math.max(0, width - newWidth) / 2;\r\n    const offsetY = Math.max(0, height - newHeight) / 2;\r\n\r\n    const scene = camera.getScene();\r\n    if (scene.activeCamera !== camera) {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (forceDownload) {\r\n                    const blob = new Blob([data]);\r\n                    Tools.DownloadBlob(blob);\r\n                    if (successCallback) {\r\n                        successCallback(\"\");\r\n                    }\r\n                } else if (successCallback) {\r\n                    successCallback(data);\r\n                }\r\n            },\r\n            mimeType,\r\n            1,\r\n            engine.getCreationOptions().antialias\r\n        );\r\n    } else {\r\n        engine.onEndFrameObservable.addOnce(() => {\r\n            const renderingCanvas = engine.getRenderingCanvas();\r\n            if (renderContext && renderingCanvas) {\r\n                renderContext.drawImage(renderingCanvas, offsetX, offsetY, newWidth, newHeight);\r\n            }\r\n\r\n            if (screenshotCanvas) {\r\n                if (forceDownload) {\r\n                    Tools.EncodeScreenshotCanvasData(screenshotCanvas, undefined, mimeType);\r\n                    if (successCallback) {\r\n                        successCallback(\"\");\r\n                    }\r\n                } else {\r\n                    Tools.EncodeScreenshotCanvasData(screenshotCanvas, successCallback, mimeType);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotAsync(engine: Engine, camera: Camera, size: IScreenshotSize | number, mimeType: string = \"image/png\"): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine defines the rendering engine\r\n * @param camera defines the source camera\r\n * @param width defines the expected width\r\n * @param height defines the expected height\r\n * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotWithResizeAsync(engine: Engine, camera: Camera, width: number, height: number, mimeType: string = \"image/png\"): Promise<void> {\r\n    return new Promise((resolve) => {\r\n        CreateScreenshot(\r\n            engine,\r\n            camera,\r\n            { width: width, height: height },\r\n            () => {\r\n                resolve();\r\n            },\r\n            mimeType,\r\n            true\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param successCallback The callback receives a single parameter which contains the\r\n * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n * src parameter of an <img> to display it\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n */\r\nexport function CreateScreenshotUsingRenderTarget(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    successCallback?: (data: string) => void,\r\n    mimeType: string = \"image/png\",\r\n    samples: number = 1,\r\n    antialiasing: boolean = false,\r\n    fileName?: string,\r\n    renderSprites: boolean = false,\r\n    enableStencilBuffer: boolean = false,\r\n    useLayerMask: boolean = true\r\n): void {\r\n    const { height, width } = _GetScreenshotSize(engine, camera, size);\r\n    const targetTextureSize = { width, height };\r\n\r\n    if (!(height && width)) {\r\n        Logger.Error(\"Invalid 'size' parameter !\");\r\n        return;\r\n    }\r\n\r\n    const originalSize = { width: engine.getRenderWidth(), height: engine.getRenderHeight() };\r\n    engine.setSize(width, height); // we need this call to trigger onResizeObservable with the screenshot width/height on all the subsystems that are observing this event and that needs to (re)create some resources with the right dimensions\r\n\r\n    const scene = camera.getScene();\r\n\r\n    // At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\r\n    const texture = new RenderTargetTexture(\r\n        \"screenShot\",\r\n        targetTextureSize,\r\n        scene,\r\n        false,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        false,\r\n        Texture.NEAREST_SAMPLINGMODE,\r\n        undefined,\r\n        enableStencilBuffer,\r\n        undefined,\r\n        undefined,\r\n        undefined,\r\n        samples\r\n    );\r\n    texture.renderList = scene.meshes.slice();\r\n    texture.samples = samples;\r\n    texture.renderSprites = renderSprites;\r\n    texture.activeCamera = camera;\r\n    texture.forceLayerMaskCheck = useLayerMask;\r\n\r\n    const renderToTexture = () => {\r\n        engine.onEndFrameObservable.addOnce(() => {\r\n            texture.readPixels(undefined, undefined, undefined, false)!.then((data) => {\r\n                DumpTools.DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true);\r\n                texture.dispose();\r\n            });\r\n        });\r\n\r\n        // render the RTT\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        texture.render(true);\r\n\r\n        // re-render the scene after the camera has been reset to the original camera to avoid a flicker that could occur\r\n        // if the camera used for the RTT rendering stays in effect for the next frame (and if that camera was different from the original camera)\r\n        scene.incrementRenderId();\r\n        scene.resetCachedMaterial();\r\n        engine.setSize(originalSize.width, originalSize.height);\r\n        camera.getProjectionMatrix(true); // Force cache refresh;\r\n        scene.render();\r\n    };\r\n\r\n    if (antialiasing) {\r\n        const fxaaPostProcess = new FxaaPostProcess(\"antialiasing\", 1.0, scene.activeCamera);\r\n        texture.addPostProcess(fxaaPostProcess);\r\n        // Async Shader Compilation can lead to none ready effects in synchronous code\r\n        if (!fxaaPostProcess.getEffect().isReady()) {\r\n            fxaaPostProcess.getEffect().onCompiled = () => {\r\n                renderToTexture();\r\n            };\r\n        }\r\n        // The effect is ready we can render\r\n        else {\r\n            renderToTexture();\r\n        }\r\n    } else {\r\n        // No need to wait for extra resources to be ready\r\n        renderToTexture();\r\n    }\r\n}\r\n\r\n/**\r\n * Generates an image screenshot from the specified camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n * @param engine The engine to use for rendering\r\n * @param camera The camera to use for rendering\r\n * @param size This parameter can be set to a single number or to an object with the\r\n * following (optional) properties: precision, width, height. If a single number is passed,\r\n * it will be used for both width and height. If an object is passed, the screenshot size\r\n * will be derived from the parameters. The precision property is a multiplier allowing\r\n * rendering at a higher or lower resolution\r\n * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n * Check your browser for supported MIME types\r\n * @param samples Texture samples (default: 1)\r\n * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n * @param fileName A name for for the downloaded file.\r\n * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)\r\n * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n * to the src parameter of an <img> to display it\r\n */\r\nexport function CreateScreenshotUsingRenderTargetAsync(\r\n    engine: Engine,\r\n    camera: Camera,\r\n    size: IScreenshotSize | number,\r\n    mimeType: string = \"image/png\",\r\n    samples: number = 1,\r\n    antialiasing: boolean = false,\r\n    fileName?: string,\r\n    renderSprites: boolean = false,\r\n    enableStencilBuffer: boolean = false,\r\n    useLayerMask: boolean = true\r\n): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        CreateScreenshotUsingRenderTarget(\r\n            engine,\r\n            camera,\r\n            size,\r\n            (data) => {\r\n                if (typeof data !== \"undefined\") {\r\n                    resolve(data);\r\n                } else {\r\n                    reject(new Error(\"Data is undefined\"));\r\n                }\r\n            },\r\n            mimeType,\r\n            samples,\r\n            antialiasing,\r\n            fileName,\r\n            renderSprites,\r\n            enableStencilBuffer,\r\n            useLayerMask\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Gets height and width for screenshot size\r\n * @param engine\r\n * @param camera\r\n * @param size\r\n * @private\r\n */\r\nfunction _GetScreenshotSize(engine: Engine, camera: Camera, size: IScreenshotSize | number): { height: number; width: number } {\r\n    let height = 0;\r\n    let width = 0;\r\n\r\n    //If a size value defined as object\r\n    if (typeof size === \"object\") {\r\n        const precision = size.precision\r\n            ? Math.abs(size.precision) // prevent GL_INVALID_VALUE : glViewport: negative width/height\r\n            : 1;\r\n\r\n        //If a width and height values is specified\r\n        if (size.width && size.height) {\r\n            height = size.height * precision;\r\n            width = size.width * precision;\r\n        }\r\n        //If passing only width, computing height to keep display canvas ratio.\r\n        else if (size.width && !size.height) {\r\n            width = size.width * precision;\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n        //If passing only height, computing width to keep display canvas ratio.\r\n        else if (size.height && !size.width) {\r\n            height = size.height * precision;\r\n            width = Math.round(height * engine.getAspectRatio(camera));\r\n        } else {\r\n            width = Math.round(engine.getRenderWidth() * precision);\r\n            height = Math.round(width / engine.getAspectRatio(camera));\r\n        }\r\n    }\r\n    //Assuming here that \"size\" parameter is a number\r\n    else if (!isNaN(size)) {\r\n        height = size;\r\n        width = size;\r\n    }\r\n\r\n    // When creating the image data from the CanvasRenderingContext2D, the width and height is clamped to the size of the _gl context\r\n    // On certain GPUs, it seems as if the _gl context truncates to an integer automatically. Therefore, if a user tries to pass the width of their canvas element\r\n    // and it happens to be a float (1000.5 x 600.5 px), the engine.readPixels will return a different size array than context.createImageData\r\n    // to resolve this, we truncate the floats here to ensure the same size\r\n    if (width) {\r\n        width = Math.floor(width);\r\n    }\r\n    if (height) {\r\n        height = Math.floor(height);\r\n    }\r\n\r\n    return { height: height | 0, width: width | 0 };\r\n}\r\n\r\n/**\r\n * Class containing a set of static utilities functions for screenshots\r\n */\r\nexport const ScreenshotTools = {\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback defines the callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param forceDownload force the system to download the image even if a successCallback is provided\r\n     */\r\n    CreateScreenshot,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotAsync,\r\n\r\n    /**\r\n     * Captures a screenshot of the current rendering for a specific size. This will render the entire canvas but will generate a blink (due to canvas resize)\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine defines the rendering engine\r\n     * @param camera defines the source camera\r\n     * @param width defines the expected width\r\n     * @param height defines the expected height\r\n     * @param mimeType defines the MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotWithResizeAsync,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param successCallback The callback receives a single parameter which contains the\r\n     * screenshot as a string of base64-encoded characters. This string can be assigned to the\r\n     * src parameter of an <img> to display it\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)\r\n     */\r\n    CreateScreenshotUsingRenderTarget,\r\n\r\n    /**\r\n     * Generates an image screenshot from the specified camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG\r\n     * @param engine The engine to use for rendering\r\n     * @param camera The camera to use for rendering\r\n     * @param size This parameter can be set to a single number or to an object with the\r\n     * following (optional) properties: precision, width, height. If a single number is passed,\r\n     * it will be used for both width and height. If an object is passed, the screenshot size\r\n     * will be derived from the parameters. The precision property is a multiplier allowing\r\n     * rendering at a higher or lower resolution\r\n     * @param mimeType The MIME type of the screenshot image (default: image/png).\r\n     * Check your browser for supported MIME types\r\n     * @param samples Texture samples (default: 1)\r\n     * @param antialiasing Whether antialiasing should be turned on or not (default: false)\r\n     * @param fileName A name for for the downloaded file.\r\n     * @param renderSprites Whether the sprites should be rendered or not (default: false)\r\n     * @returns screenshot as a string of base64-encoded characters. This string can be assigned\r\n     * to the src parameter of an <img> to display it\r\n     */\r\n    CreateScreenshotUsingRenderTargetAsync,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst initSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.CreateScreenshot = CreateScreenshot;\r\n    Tools.CreateScreenshotAsync = CreateScreenshotAsync;\r\n    Tools.CreateScreenshotUsingRenderTarget = CreateScreenshotUsingRenderTarget;\r\n    Tools.CreateScreenshotUsingRenderTargetAsync = CreateScreenshotUsingRenderTargetAsync;\r\n};\r\n\r\ninitSideEffects();\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}