{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { NodeMaterialBlock } from \"../../nodeMaterialBlock.js\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes.js\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets.js\";\nimport { RegisterClass } from \"../../../../Misc/typeStore.js\";\nimport { PointLight } from \"../../../../Lights/pointLight.js\";\n/**\n * Block used to get data information from a light\n */\nexport class LightInformationBlock extends NodeMaterialBlock {\n  /**\n   * Creates a new LightInformationBlock\n   * @param name defines the block name\n   */\n  constructor(name) {\n    super(name, NodeMaterialBlockTargets.Vertex);\n    this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\n    this.registerOutput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector3);\n    this.registerOutput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3);\n    this.registerOutput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowBias\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowNormalBias\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowDepthScale\", NodeMaterialBlockConnectionPointTypes.Float);\n    this.registerOutput(\"shadowDepthRange\", NodeMaterialBlockConnectionPointTypes.Vector2);\n  }\n  /**\n   * Gets the current class name\n   * @returns the class name\n   */\n  getClassName() {\n    return \"LightInformationBlock\";\n  }\n  /**\n   * Gets the world position input component\n   */\n  get worldPosition() {\n    return this._inputs[0];\n  }\n  /**\n   * Gets the direction output component\n   */\n  get direction() {\n    return this._outputs[0];\n  }\n  /**\n   * Gets the direction output component\n   */\n  get color() {\n    return this._outputs[1];\n  }\n  /**\n   * Gets the direction output component\n   */\n  get intensity() {\n    return this._outputs[2];\n  }\n  /**\n   * Gets the shadow bias output component\n   */\n  get shadowBias() {\n    return this._outputs[3];\n  }\n  /**\n   * Gets the shadow normal bias output component\n   */\n  get shadowNormalBias() {\n    return this._outputs[4];\n  }\n  /**\n   * Gets the shadow depth scale component\n   */\n  get shadowDepthScale() {\n    return this._outputs[5];\n  }\n  /**\n   * Gets the shadow depth range component\n   */\n  get shadowDepthRange() {\n    return this._outputs[6];\n  }\n  bind(effect, nodeMaterial, mesh) {\n    if (!mesh) {\n      return;\n    }\n    if (this.light && this.light.isDisposed()) {\n      this.light = null;\n    }\n    let light = this.light;\n    const scene = nodeMaterial.getScene();\n    if (!light && scene.lights.length) {\n      light = this.light = scene.lights[0];\n      this._forcePrepareDefines = true;\n    }\n    if (!light || !light.isEnabled) {\n      effect.setFloat3(this._lightDataUniformName, 0, 0, 0);\n      effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);\n      return;\n    }\n    light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);\n    effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);\n    const generator = light.getShadowGenerator();\n    if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {\n      if (generator) {\n        effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);\n      } else {\n        effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);\n      }\n    }\n    if (this.shadowDepthRange) {\n      if (generator && scene.activeCamera) {\n        const shadowLight = light;\n        effect.setFloat2(this._lightShadowExtraUniformName, shadowLight.getDepthMinZ(scene.activeCamera), shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera));\n      } else {\n        effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);\n      }\n    }\n  }\n  prepareDefines(mesh, nodeMaterial, defines) {\n    if (!defines._areLightsDirty && !this._forcePrepareDefines) {\n      return;\n    }\n    this._forcePrepareDefines = false;\n    const light = this.light;\n    defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);\n  }\n  _buildBlock(state) {\n    super._buildBlock(state);\n    state.sharedData.bindableBlocks.push(this);\n    state.sharedData.blocksWithDefines.push(this);\n    const direction = this.direction;\n    const color = this.color;\n    const intensity = this.intensity;\n    const shadowBias = this.shadowBias;\n    const shadowNormalBias = this.shadowNormalBias;\n    const shadowDepthScale = this.shadowDepthScale;\n    const shadowDepthRange = this.shadowDepthRange;\n    this._lightDataUniformName = state._getFreeVariableName(\"lightData\");\n    this._lightColorUniformName = state._getFreeVariableName(\"lightColor\");\n    this._lightShadowUniformName = state._getFreeVariableName(\"shadowData\");\n    this._lightShadowExtraUniformName = state._getFreeVariableName(\"shadowExtraData\");\n    this._lightTypeDefineName = state._getFreeDefineName(\"LIGHTPOINTTYPE\");\n    state._emitUniformFromString(this._lightDataUniformName, \"vec3\");\n    state._emitUniformFromString(this._lightColorUniformName, \"vec4\");\n    state.compilationString += `#ifdef ${this._lightTypeDefineName}\\r\\n`;\n    state.compilationString += this._declareOutput(direction, state) + ` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${this._lightDataUniformName});\\r\\n`;\n    state.compilationString += `#else\\r\\n`;\n    state.compilationString += this._declareOutput(direction, state) + ` = ${this._lightDataUniformName};\\r\\n`;\n    state.compilationString += `#endif\\r\\n`;\n    state.compilationString += this._declareOutput(color, state) + ` = ${this._lightColorUniformName}.rgb;\\r\\n`;\n    state.compilationString += this._declareOutput(intensity, state) + ` = ${this._lightColorUniformName}.a;\\r\\n`;\n    if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {\n      state._emitUniformFromString(this._lightShadowUniformName, \"vec3\");\n      if (shadowBias.hasEndpoints) {\n        state.compilationString += this._declareOutput(shadowBias, state) + ` = ${this._lightShadowUniformName}.x;\\r\\n`;\n      }\n      if (shadowNormalBias.hasEndpoints) {\n        state.compilationString += this._declareOutput(shadowNormalBias, state) + ` = ${this._lightShadowUniformName}.y;\\r\\n`;\n      }\n      if (shadowDepthScale.hasEndpoints) {\n        state.compilationString += this._declareOutput(shadowDepthScale, state) + ` = ${this._lightShadowUniformName}.z;\\r\\n`;\n      }\n    }\n    if (shadowDepthRange.hasEndpoints) {\n      state._emitUniformFromString(this._lightShadowExtraUniformName, \"vec2\");\n      state.compilationString += this._declareOutput(shadowDepthRange, state) + ` = ${this._lightShadowUniformName};\\r\\n`;\n    }\n    return this;\n  }\n  serialize() {\n    const serializationObject = super.serialize();\n    if (this.light) {\n      serializationObject.lightId = this.light.id;\n    }\n    return serializationObject;\n  }\n  _deserialize(serializationObject, scene, rootUrl) {\n    super._deserialize(serializationObject, scene, rootUrl);\n    if (serializationObject.lightId) {\n      this.light = scene.getLightById(serializationObject.lightId);\n    }\n  }\n}\nRegisterClass(\"BABYLON.LightInformationBlock\", LightInformationBlock);","map":{"version":3,"mappings":"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","names":["NodeMaterialBlock","NodeMaterialBlockConnectionPointTypes","NodeMaterialBlockTargets","RegisterClass","PointLight","LightInformationBlock","constructor","name","Vertex","registerInput","Vector4","registerOutput","Vector3","Color3","Float","Vector2","getClassName","worldPosition","_inputs","direction","_outputs","color","intensity","shadowBias","shadowNormalBias","shadowDepthScale","shadowDepthRange","bind","effect","nodeMaterial","mesh","light","isDisposed","scene","getScene","lights","length","_forcePrepareDefines","isEnabled","setFloat3","_lightDataUniformName","setFloat4","_lightColorUniformName","transferToNodeMaterialEffect","setColor4","diffuse","generator","getShadowGenerator","hasEndpoints","_lightShadowUniformName","bias","normalBias","depthScale","activeCamera","shadowLight","setFloat2","_lightShadowExtraUniformName","getDepthMinZ","getDepthMaxZ","prepareDefines","defines","_areLightsDirty","setValue","_lightTypeDefineName","_buildBlock","state","sharedData","bindableBlocks","push","blocksWithDefines","_getFreeVariableName","_getFreeDefineName","_emitUniformFromString","compilationString","_declareOutput","associatedVariableName","serialize","serializationObject","lightId","id","_deserialize","rootUrl","getLightById"],"sourceRoot":"","sources":["../../../../../../../lts/core/generated/Materials/Node/Blocks/Vertex/lightInformationBlock.ts"],"sourcesContent":["import { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\r\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\r\nimport type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\r\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\r\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { Nullable } from \"../../../../types\";\r\nimport type { Scene } from \"../../../../scene\";\r\nimport type { Effect } from \"../../../effect\";\r\nimport type { NodeMaterial, NodeMaterialDefines } from \"../../nodeMaterial\";\r\nimport type { Mesh } from \"../../../../Meshes/mesh\";\r\nimport type { Light } from \"../../../../Lights/light\";\r\nimport { PointLight } from \"../../../../Lights/pointLight\";\r\nimport type { AbstractMesh } from \"../../../../Meshes/abstractMesh\";\r\nimport type { ShadowGenerator } from \"../../../../Lights/Shadows/shadowGenerator\";\r\nimport type { ShadowLight } from \"../../../../Lights\";\r\n\r\n/**\r\n * Block used to get data information from a light\r\n */\r\nexport class LightInformationBlock extends NodeMaterialBlock {\r\n    private _lightDataUniformName: string;\r\n    private _lightColorUniformName: string;\r\n    private _lightShadowUniformName: string;\r\n    private _lightShadowExtraUniformName: string;\r\n    private _lightTypeDefineName: string;\r\n    private _forcePrepareDefines: boolean;\r\n\r\n    /**\r\n     * Gets or sets the light associated with this block\r\n     */\r\n    public light: Nullable<Light>;\r\n\r\n    /**\r\n     * Creates a new LightInformationBlock\r\n     * @param name defines the block name\r\n     */\r\n    public constructor(name: string) {\r\n        super(name, NodeMaterialBlockTargets.Vertex);\r\n\r\n        this.registerInput(\"worldPosition\", NodeMaterialBlockConnectionPointTypes.Vector4, false, NodeMaterialBlockTargets.Vertex);\r\n        this.registerOutput(\"direction\", NodeMaterialBlockConnectionPointTypes.Vector3);\r\n        this.registerOutput(\"color\", NodeMaterialBlockConnectionPointTypes.Color3);\r\n        this.registerOutput(\"intensity\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowBias\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowNormalBias\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowDepthScale\", NodeMaterialBlockConnectionPointTypes.Float);\r\n        this.registerOutput(\"shadowDepthRange\", NodeMaterialBlockConnectionPointTypes.Vector2);\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"LightInformationBlock\";\r\n    }\r\n\r\n    /**\r\n     * Gets the world position input component\r\n     */\r\n    public get worldPosition(): NodeMaterialConnectionPoint {\r\n        return this._inputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction output component\r\n     */\r\n    public get direction(): NodeMaterialConnectionPoint {\r\n        return this._outputs[0];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction output component\r\n     */\r\n    public get color(): NodeMaterialConnectionPoint {\r\n        return this._outputs[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the direction output component\r\n     */\r\n    public get intensity(): NodeMaterialConnectionPoint {\r\n        return this._outputs[2];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow bias output component\r\n     */\r\n    public get shadowBias(): NodeMaterialConnectionPoint {\r\n        return this._outputs[3];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow normal bias output component\r\n     */\r\n    public get shadowNormalBias(): NodeMaterialConnectionPoint {\r\n        return this._outputs[4];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow depth scale component\r\n     */\r\n    public get shadowDepthScale(): NodeMaterialConnectionPoint {\r\n        return this._outputs[5];\r\n    }\r\n\r\n    /**\r\n     * Gets the shadow depth range component\r\n     */\r\n    public get shadowDepthRange(): NodeMaterialConnectionPoint {\r\n        return this._outputs[6];\r\n    }\r\n\r\n    public bind(effect: Effect, nodeMaterial: NodeMaterial, mesh?: Mesh) {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        if (this.light && this.light.isDisposed()) {\r\n            this.light = null;\r\n        }\r\n\r\n        let light = this.light;\r\n        const scene = nodeMaterial.getScene();\r\n\r\n        if (!light && scene.lights.length) {\r\n            light = this.light = scene.lights[0];\r\n            this._forcePrepareDefines = true;\r\n        }\r\n\r\n        if (!light || !light.isEnabled) {\r\n            effect.setFloat3(this._lightDataUniformName, 0, 0, 0);\r\n            effect.setFloat4(this._lightColorUniformName, 0, 0, 0, 0);\r\n            return;\r\n        }\r\n\r\n        light.transferToNodeMaterialEffect(effect, this._lightDataUniformName);\r\n\r\n        effect.setColor4(this._lightColorUniformName, light.diffuse, light.intensity);\r\n\r\n        const generator = light.getShadowGenerator() as ShadowGenerator;\r\n        if (this.shadowBias.hasEndpoints || this.shadowNormalBias.hasEndpoints || this.shadowDepthScale.hasEndpoints) {\r\n            if (generator) {\r\n                effect.setFloat3(this._lightShadowUniformName, generator.bias, generator.normalBias, generator.depthScale);\r\n            } else {\r\n                effect.setFloat3(this._lightShadowUniformName, 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        if (this.shadowDepthRange) {\r\n            if (generator && scene.activeCamera) {\r\n                const shadowLight = light as ShadowLight;\r\n                effect.setFloat2(\r\n                    this._lightShadowExtraUniformName,\r\n                    shadowLight.getDepthMinZ(scene.activeCamera),\r\n                    shadowLight.getDepthMinZ(scene.activeCamera) + shadowLight.getDepthMaxZ(scene.activeCamera)\r\n                );\r\n            } else {\r\n                effect.setFloat2(this._lightShadowExtraUniformName, 0, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    public prepareDefines(mesh: AbstractMesh, nodeMaterial: NodeMaterial, defines: NodeMaterialDefines) {\r\n        if (!defines._areLightsDirty && !this._forcePrepareDefines) {\r\n            return;\r\n        }\r\n\r\n        this._forcePrepareDefines = false;\r\n\r\n        const light = this.light;\r\n        defines.setValue(this._lightTypeDefineName, light && light instanceof PointLight ? true : false, true);\r\n    }\r\n\r\n    protected _buildBlock(state: NodeMaterialBuildState) {\r\n        super._buildBlock(state);\r\n\r\n        state.sharedData.bindableBlocks.push(this);\r\n        state.sharedData.blocksWithDefines.push(this);\r\n\r\n        const direction = this.direction;\r\n        const color = this.color;\r\n        const intensity = this.intensity;\r\n        const shadowBias = this.shadowBias;\r\n        const shadowNormalBias = this.shadowNormalBias;\r\n        const shadowDepthScale = this.shadowDepthScale;\r\n        const shadowDepthRange = this.shadowDepthRange;\r\n\r\n        this._lightDataUniformName = state._getFreeVariableName(\"lightData\");\r\n        this._lightColorUniformName = state._getFreeVariableName(\"lightColor\");\r\n        this._lightShadowUniformName = state._getFreeVariableName(\"shadowData\");\r\n        this._lightShadowExtraUniformName = state._getFreeVariableName(\"shadowExtraData\");\r\n        this._lightTypeDefineName = state._getFreeDefineName(\"LIGHTPOINTTYPE\");\r\n\r\n        state._emitUniformFromString(this._lightDataUniformName, \"vec3\");\r\n        state._emitUniformFromString(this._lightColorUniformName, \"vec4\");\r\n\r\n        state.compilationString += `#ifdef ${this._lightTypeDefineName}\\r\\n`;\r\n        state.compilationString += this._declareOutput(direction, state) + ` = normalize(${this.worldPosition.associatedVariableName}.xyz - ${this._lightDataUniformName});\\r\\n`;\r\n        state.compilationString += `#else\\r\\n`;\r\n        state.compilationString += this._declareOutput(direction, state) + ` = ${this._lightDataUniformName};\\r\\n`;\r\n        state.compilationString += `#endif\\r\\n`;\r\n\r\n        state.compilationString += this._declareOutput(color, state) + ` = ${this._lightColorUniformName}.rgb;\\r\\n`;\r\n        state.compilationString += this._declareOutput(intensity, state) + ` = ${this._lightColorUniformName}.a;\\r\\n`;\r\n\r\n        if (shadowBias.hasEndpoints || shadowNormalBias.hasEndpoints || shadowDepthScale.hasEndpoints) {\r\n            state._emitUniformFromString(this._lightShadowUniformName, \"vec3\");\r\n            if (shadowBias.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(shadowBias, state) + ` = ${this._lightShadowUniformName}.x;\\r\\n`;\r\n            }\r\n            if (shadowNormalBias.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(shadowNormalBias, state) + ` = ${this._lightShadowUniformName}.y;\\r\\n`;\r\n            }\r\n            if (shadowDepthScale.hasEndpoints) {\r\n                state.compilationString += this._declareOutput(shadowDepthScale, state) + ` = ${this._lightShadowUniformName}.z;\\r\\n`;\r\n            }\r\n        }\r\n\r\n        if (shadowDepthRange.hasEndpoints) {\r\n            state._emitUniformFromString(this._lightShadowExtraUniformName, \"vec2\");\r\n            state.compilationString += this._declareOutput(shadowDepthRange, state) + ` = ${this._lightShadowUniformName};\\r\\n`;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        if (this.light) {\r\n            serializationObject.lightId = this.light.id;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    public _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\r\n        super._deserialize(serializationObject, scene, rootUrl);\r\n\r\n        if (serializationObject.lightId) {\r\n            this.light = scene.getLightById(serializationObject.lightId);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.LightInformationBlock\", LightInformationBlock);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}