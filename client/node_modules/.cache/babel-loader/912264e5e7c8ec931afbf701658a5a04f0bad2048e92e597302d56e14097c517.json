{"ast":null,"code":"import { __decorate } from \"../../tslib.es6.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { serialize } from \"../../Misc/decorators.js\";\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager.js\";\nimport { PointerEventTypes } from \"../../Events/pointerEvents.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * Manage the mouse inputs to control the movement of a free camera.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n */\nexport class FreeCameraMouseInput {\n  /**\n   * Manage the mouse inputs to control the movement of a free camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\n   * @param touchEnabled Defines if touch is enabled or not\n   */\n  constructor(\n  /**\n   * Define if touch is enabled in the mouse input\n   */\n  touchEnabled = true) {\n    this.touchEnabled = touchEnabled;\n    /**\n     * Defines the buttons associated with the input to handle camera move.\n     */\n    this.buttons = [0, 1, 2];\n    /**\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\n     */\n    this.angularSensibility = 2000.0;\n    this._previousPosition = null;\n    /**\n     * Observable for when a pointer move event occurs containing the move offset\n     */\n    this.onPointerMovedObservable = new Observable();\n    /**\n     * @internal\n     * If the camera should be rotated automatically based on pointer movement\n     */\n    this._allowCameraRotation = true;\n    this._currentActiveButton = -1;\n    this._activePointerId = -1;\n  }\n  /**\n   * Attach the input controls to a specific dom element to get the input from.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    const engine = this.camera.getEngine();\n    const element = engine.getInputElement();\n    if (!this._pointerInput) {\n      this._pointerInput = p => {\n        const evt = p.event;\n        const isTouch = evt.pointerType === \"touch\";\n        if (engine.isInVRExclusivePointerMode) {\n          return;\n        }\n        if (!this.touchEnabled && isTouch) {\n          return;\n        }\n        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\n          return;\n        }\n        const srcElement = evt.target;\n        if (p.type === PointerEventTypes.POINTERDOWN) {\n          // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\n          if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {\n            return;\n          }\n          this._activePointerId = evt.pointerId;\n          try {\n            srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);\n          } catch (e) {\n            //Nothing to do with the error. Execution will continue.\n          }\n          if (this._currentActiveButton === -1) {\n            this._currentActiveButton = evt.button;\n          }\n          this._previousPosition = {\n            x: evt.clientX,\n            y: evt.clientY\n          };\n          if (!noPreventDefault) {\n            evt.preventDefault();\n            element && element.focus();\n          }\n          // This is required to move while pointer button is down\n          if (engine.isPointerLock && this._onMouseMove) {\n            this._onMouseMove(p.event);\n          }\n        } else if (p.type === PointerEventTypes.POINTERUP) {\n          // If input is touch with a different touch id OR if input is mouse with a different button, return\n          if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {\n            return;\n          }\n          try {\n            srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);\n          } catch (e) {\n            //Nothing to do with the error.\n          }\n          this._currentActiveButton = -1;\n          this._previousPosition = null;\n          if (!noPreventDefault) {\n            evt.preventDefault();\n          }\n          this._activePointerId = -1;\n        } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\n          if (engine.isPointerLock && this._onMouseMove) {\n            this._onMouseMove(p.event);\n          } else if (this._previousPosition) {\n            let offsetX = evt.clientX - this._previousPosition.x;\n            const offsetY = evt.clientY - this._previousPosition.y;\n            if (this.camera.getScene().useRightHandedSystem) {\n              offsetX *= -1;\n            }\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\n              offsetX *= -1;\n            }\n            if (this._allowCameraRotation) {\n              this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n              this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n            }\n            this.onPointerMovedObservable.notifyObservers({\n              offsetX: offsetX,\n              offsetY: offsetY\n            });\n            this._previousPosition = {\n              x: evt.clientX,\n              y: evt.clientY\n            };\n            if (!noPreventDefault) {\n              evt.preventDefault();\n            }\n          }\n        }\n      };\n    }\n    this._onMouseMove = evt => {\n      if (!engine.isPointerLock) {\n        return;\n      }\n      if (engine.isInVRExclusivePointerMode) {\n        return;\n      }\n      let offsetX = evt.movementX;\n      if (this.camera.getScene().useRightHandedSystem) {\n        offsetX *= -1;\n      }\n      if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\n        offsetX *= -1;\n      }\n      this.camera.cameraRotation.y += offsetX / this.angularSensibility;\n      const offsetY = evt.movementY;\n      this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n      this._previousPosition = null;\n      if (!noPreventDefault) {\n        evt.preventDefault();\n      }\n    };\n    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\n    if (element) {\n      this._contextMenuBind = this.onContextMenu.bind(this);\n      element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\n    }\n  }\n  /**\n   * Called on JS contextmenu event.\n   * Override this method to provide functionality.\n   * @param evt\n   */\n  onContextMenu(evt) {\n    evt.preventDefault();\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    if (this._observer) {\n      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\n      if (this._contextMenuBind) {\n        const engine = this.camera.getEngine();\n        const element = engine.getInputElement();\n        element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\n      }\n      if (this.onPointerMovedObservable) {\n        this.onPointerMovedObservable.clear();\n      }\n      this._observer = null;\n      this._onMouseMove = null;\n      this._previousPosition = null;\n    }\n    this._currentActiveButton = -1;\n  }\n  /**\n   * Gets the class name of the current input.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FreeCameraMouseInput\";\n  }\n  /**\n   * Get the friendly name associated with the input class.\n   * @returns the input friendly name\n   */\n  getSimpleName() {\n    return \"mouse\";\n  }\n}\n__decorate([serialize()], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n__decorate([serialize()], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\nCameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;","map":{"version":3,"mappings":";AACA,SAASA,UAAU,QAAQ,0BAAwB;AACnD,SAASC,SAAS,QAAQ,0BAAwB;AAGlD,SAASC,gBAAgB,QAAQ,sCAAoC;AAGrE,SAASC,iBAAiB,QAAQ,+BAA6B;AAC/D,SAASC,KAAK,QAAQ,qBAAmB;AAEzC;;;;AAIA,OAAM,MAAOC,oBAAoB;EAqC7B;;;;;EAKAC;EACI;;;EAGOC,eAAe,IAAI;IAAnB,iBAAY,GAAZA,YAAY;IAxCvB;;;IAIO,YAAO,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAE1B;;;IAIO,uBAAkB,GAAG,MAAM;IAK1B,sBAAiB,GAAuC,IAAI;IAEpE;;;IAGO,6BAAwB,GAAG,IAAIP,UAAU,EAAwC;IACxF;;;;IAIO,yBAAoB,GAAG,IAAI;IAE1B,yBAAoB,GAAW,CAAC,CAAC;IACjC,qBAAgB,GAAW,CAAC,CAAC;EAalC;EAEH;;;;EAIOQ,aAAa,CAACC,gBAA0B;IAC3C;IACAA,gBAAgB,GAAGL,KAAK,CAACM,gCAAgC,CAACC,SAAS,CAAC;IACpE,MAAMC,MAAM,GAAG,IAAI,CAACC,MAAM,CAACC,SAAS,EAAE;IACtC,MAAMC,OAAO,GAAGH,MAAM,CAACI,eAAe,EAAE;IAExC,IAAI,CAAC,IAAI,CAACC,aAAa,EAAE;MACrB,IAAI,CAACA,aAAa,GAAIC,CAAC,IAAI;QACvB,MAAMC,GAAG,GAAkBD,CAAC,CAACE,KAAK;QAClC,MAAMC,OAAO,GAAGF,GAAG,CAACG,WAAW,KAAK,OAAO;QAE3C,IAAIV,MAAM,CAACW,0BAA0B,EAAE;UACnC;;QAGJ,IAAI,CAAC,IAAI,CAAChB,YAAY,IAAIc,OAAO,EAAE;UAC/B;;QAGJ,IAAIH,CAAC,CAACM,IAAI,KAAKrB,iBAAiB,CAACsB,WAAW,IAAI,IAAI,CAACC,OAAO,CAACC,OAAO,CAACR,GAAG,CAACS,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;UACrF;;QAGJ,MAAMC,UAAU,GAAgBV,GAAG,CAACW,MAAM;QAE1C,IAAIZ,CAAC,CAACM,IAAI,KAAKrB,iBAAiB,CAAC4B,WAAW,EAAE;UAC1C;UACA,IAAKV,OAAO,IAAI,IAAI,CAACW,gBAAgB,KAAK,CAAC,CAAC,IAAM,CAACX,OAAO,IAAI,IAAI,CAACY,oBAAoB,KAAK,CAAC,CAAE,EAAE;YAC7F;;UAGJ,IAAI,CAACD,gBAAgB,GAAGb,GAAG,CAACe,SAAS;UACrC,IAAI;YACAL,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,iBAAiB,CAAChB,GAAG,CAACe,SAAS,CAAC;WAC/C,CAAC,OAAOE,CAAC,EAAE;YACR;UAAA;UAGJ,IAAI,IAAI,CAACH,oBAAoB,KAAK,CAAC,CAAC,EAAE;YAClC,IAAI,CAACA,oBAAoB,GAAGd,GAAG,CAACS,MAAM;;UAG1C,IAAI,CAACS,iBAAiB,GAAG;YACrBC,CAAC,EAAEnB,GAAG,CAACoB,OAAO;YACdC,CAAC,EAAErB,GAAG,CAACsB;WACV;UAED,IAAI,CAAChC,gBAAgB,EAAE;YACnBU,GAAG,CAACuB,cAAc,EAAE;YACpB3B,OAAO,IAAIA,OAAO,CAAC4B,KAAK,EAAE;;UAG9B;UACA,IAAI/B,MAAM,CAACgC,aAAa,IAAI,IAAI,CAACC,YAAY,EAAE;YAC3C,IAAI,CAACA,YAAY,CAAC3B,CAAC,CAACE,KAAK,CAAC;;SAEjC,MAAM,IAAIF,CAAC,CAACM,IAAI,KAAKrB,iBAAiB,CAAC2C,SAAS,EAAE;UAC/C;UACA,IAAKzB,OAAO,IAAI,IAAI,CAACW,gBAAgB,KAAKb,GAAG,CAACe,SAAS,IAAM,CAACb,OAAO,IAAI,IAAI,CAACY,oBAAoB,KAAKd,GAAG,CAACS,MAAO,EAAE;YAChH;;UAGJ,IAAI;YACAC,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEkB,qBAAqB,CAAC5B,GAAG,CAACe,SAAS,CAAC;WACnD,CAAC,OAAOE,CAAC,EAAE;YACR;UAAA;UAEJ,IAAI,CAACH,oBAAoB,GAAG,CAAC,CAAC;UAE9B,IAAI,CAACI,iBAAiB,GAAG,IAAI;UAC7B,IAAI,CAAC5B,gBAAgB,EAAE;YACnBU,GAAG,CAACuB,cAAc,EAAE;;UAGxB,IAAI,CAACV,gBAAgB,GAAG,CAAC,CAAC;SAC7B,MAAM,IAAId,CAAC,CAACM,IAAI,KAAKrB,iBAAiB,CAACsB,WAAW,KAAK,IAAI,CAACO,gBAAgB,KAAKb,GAAG,CAACe,SAAS,IAAI,CAACb,OAAO,CAAC,EAAE;UAC1G,IAAIT,MAAM,CAACgC,aAAa,IAAI,IAAI,CAACC,YAAY,EAAE;YAC3C,IAAI,CAACA,YAAY,CAAC3B,CAAC,CAACE,KAAK,CAAC;WAC7B,MAAM,IAAI,IAAI,CAACiB,iBAAiB,EAAE;YAC/B,IAAIW,OAAO,GAAG7B,GAAG,CAACoB,OAAO,GAAG,IAAI,CAACF,iBAAiB,CAACC,CAAC;YACpD,MAAMW,OAAO,GAAG9B,GAAG,CAACsB,OAAO,GAAG,IAAI,CAACJ,iBAAiB,CAACG,CAAC;YACtD,IAAI,IAAI,CAAC3B,MAAM,CAACqC,QAAQ,EAAE,CAACC,oBAAoB,EAAE;cAC7CH,OAAO,IAAI,CAAC,CAAC;;YAEjB,IAAI,IAAI,CAACnC,MAAM,CAACuC,MAAM,IAAI,IAAI,CAACvC,MAAM,CAACuC,MAAM,CAACC,0BAA0B,EAAE,GAAG,CAAC,EAAE;cAC3EL,OAAO,IAAI,CAAC,CAAC;;YAGjB,IAAI,IAAI,CAACM,oBAAoB,EAAE;cAC3B,IAAI,CAACzC,MAAM,CAAC0C,cAAc,CAACf,CAAC,IAAIQ,OAAO,GAAG,IAAI,CAACQ,kBAAkB;cACjE,IAAI,CAAC3C,MAAM,CAAC0C,cAAc,CAACjB,CAAC,IAAIW,OAAO,GAAG,IAAI,CAACO,kBAAkB;;YAErE,IAAI,CAACC,wBAAwB,CAACC,eAAe,CAAC;cAAEV,OAAO,EAAEA,OAAO;cAAEC,OAAO,EAAEA;YAAO,CAAE,CAAC;YAErF,IAAI,CAACZ,iBAAiB,GAAG;cACrBC,CAAC,EAAEnB,GAAG,CAACoB,OAAO;cACdC,CAAC,EAAErB,GAAG,CAACsB;aACV;YAED,IAAI,CAAChC,gBAAgB,EAAE;cACnBU,GAAG,CAACuB,cAAc,EAAE;;;;MAIpC,CAAC;;IAGL,IAAI,CAACG,YAAY,GAAI1B,GAAG,IAAI;MACxB,IAAI,CAACP,MAAM,CAACgC,aAAa,EAAE;QACvB;;MAGJ,IAAIhC,MAAM,CAACW,0BAA0B,EAAE;QACnC;;MAGJ,IAAIyB,OAAO,GAAG7B,GAAG,CAACwC,SAAS;MAC3B,IAAI,IAAI,CAAC9C,MAAM,CAACqC,QAAQ,EAAE,CAACC,oBAAoB,EAAE;QAC7CH,OAAO,IAAI,CAAC,CAAC;;MAEjB,IAAI,IAAI,CAACnC,MAAM,CAACuC,MAAM,IAAI,IAAI,CAACvC,MAAM,CAACuC,MAAM,CAACC,0BAA0B,EAAE,GAAG,CAAC,EAAE;QAC3EL,OAAO,IAAI,CAAC,CAAC;;MAEjB,IAAI,CAACnC,MAAM,CAAC0C,cAAc,CAACf,CAAC,IAAIQ,OAAO,GAAG,IAAI,CAACQ,kBAAkB;MAEjE,MAAMP,OAAO,GAAG9B,GAAG,CAACyC,SAAS;MAC7B,IAAI,CAAC/C,MAAM,CAAC0C,cAAc,CAACjB,CAAC,IAAIW,OAAO,GAAG,IAAI,CAACO,kBAAkB;MAEjE,IAAI,CAACnB,iBAAiB,GAAG,IAAI;MAE7B,IAAI,CAAC5B,gBAAgB,EAAE;QACnBU,GAAG,CAACuB,cAAc,EAAE;;IAE5B,CAAC;IAED,IAAI,CAACmB,SAAS,GAAG,IAAI,CAAChD,MAAM,CACvBqC,QAAQ,EAAE,CACVY,aAAa,CAACC,yBAAyB,CAAC,IAAI,CAAC9C,aAAa,EAAEd,iBAAiB,CAAC4B,WAAW,GAAG5B,iBAAiB,CAAC2C,SAAS,GAAG3C,iBAAiB,CAACsB,WAAW,CAAC;IAE7J,IAAIV,OAAO,EAAE;MACT,IAAI,CAACiD,gBAAgB,GAAG,IAAI,CAACC,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC;MACrDnD,OAAO,CAACoD,gBAAgB,CAAC,aAAa,EAAE,IAAI,CAACH,gBAAgB,EAAE,KAAK,CAAC,CAAC,CAAC;;EAE/E;EAEA;;;;;EAKOC,aAAa,CAAC9C,GAAiB;IAClCA,GAAG,CAACuB,cAAc,EAAE;EACxB;EAEA;;;EAGO0B,aAAa;IAChB,IAAI,IAAI,CAACP,SAAS,EAAE;MAChB,IAAI,CAAChD,MAAM,CAACqC,QAAQ,EAAE,CAACY,aAAa,CAACO,4BAA4B,CAAC,IAAI,CAACR,SAAS,CAAC;MAEjF,IAAI,IAAI,CAACG,gBAAgB,EAAE;QACvB,MAAMpD,MAAM,GAAG,IAAI,CAACC,MAAM,CAACC,SAAS,EAAE;QACtC,MAAMC,OAAO,GAAGH,MAAM,CAACI,eAAe,EAAE;QACxCD,OAAO,IAAIA,OAAO,CAACuD,mBAAmB,CAAC,aAAa,EAAE,IAAI,CAACN,gBAAgB,CAAC;;MAGhF,IAAI,IAAI,CAACP,wBAAwB,EAAE;QAC/B,IAAI,CAACA,wBAAwB,CAACc,KAAK,EAAE;;MAGzC,IAAI,CAACV,SAAS,GAAG,IAAI;MACrB,IAAI,CAAChB,YAAY,GAAG,IAAI;MACxB,IAAI,CAACR,iBAAiB,GAAG,IAAI;;IAGjC,IAAI,CAACJ,oBAAoB,GAAG,CAAC,CAAC;EAClC;EAEA;;;;EAIOuC,YAAY;IACf,OAAO,sBAAsB;EACjC;EAEA;;;;EAIOC,aAAa;IAChB,OAAO,OAAO;EAClB;;AA5OAC,YADCzE,SAAS,EAAE,qDACe;AAM3ByE,YADCzE,SAAS,EAAE,gEACuB;AAyOjCC,gBAAiB,CAAC,sBAAsB,CAAC,GAAGG,oBAAoB","names":["Observable","serialize","CameraInputTypes","PointerEventTypes","Tools","FreeCameraMouseInput","constructor","touchEnabled","attachControl","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","engine","camera","getEngine","element","getInputElement","_pointerInput","p","evt","event","isTouch","pointerType","isInVRExclusivePointerMode","type","POINTERMOVE","buttons","indexOf","button","srcElement","target","POINTERDOWN","_activePointerId","_currentActiveButton","pointerId","setPointerCapture","e","_previousPosition","x","clientX","y","clientY","preventDefault","focus","isPointerLock","_onMouseMove","POINTERUP","releasePointerCapture","offsetX","offsetY","getScene","useRightHandedSystem","parent","_getWorldMatrixDeterminant","_allowCameraRotation","cameraRotation","angularSensibility","onPointerMovedObservable","notifyObservers","movementX","movementY","_observer","_inputManager","_addCameraPointerObserver","_contextMenuBind","onContextMenu","bind","addEventListener","detachControl","_removeCameraPointerObserver","removeEventListener","clear","getClassName","getSimpleName","__decorate"],"sourceRoot":"","sources":["../../../../../lts/core/generated/Cameras/Inputs/freeCameraMouseInput.ts"],"sourcesContent":["import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: () => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (engine.isInVRExclusivePointerMode) {\r\n                    return;\r\n                }\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        let offsetX = evt.clientX - this._previousPosition.x;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n                        if (this.camera.getScene().useRightHandedSystem) {\r\n                            offsetX *= -1;\r\n                        }\r\n                        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                            offsetX *= -1;\r\n                        }\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            if (engine.isInVRExclusivePointerMode) {\r\n                return;\r\n            }\r\n\r\n            let offsetX = evt.movementX;\r\n            if (this.camera.getScene().useRightHandedSystem) {\r\n                offsetX *= -1;\r\n            }\r\n            if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\r\n                offsetX *= -1;\r\n            }\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = this.onContextMenu.bind(this);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}