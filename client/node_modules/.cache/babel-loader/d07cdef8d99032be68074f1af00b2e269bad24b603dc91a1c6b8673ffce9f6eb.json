{"ast":null,"code":"import { WebXRExperienceHelper } from \"./webXRExperienceHelper.js\";\nimport { WebXRInput } from \"./webXRInput.js\";\nimport { WebXRControllerPointerSelection } from \"./features/WebXRControllerPointerSelection.js\";\nimport { WebXRNearInteraction } from \"./features/WebXRNearInteraction.js\";\nimport { WebXREnterExitUI } from \"./webXREnterExitUI.js\";\nimport { WebXRMotionControllerTeleportation } from \"./features/WebXRControllerTeleportation.js\";\nimport { Logger } from \"../Misc/logger.js\";\n/**\n * Options for the default xr helper\n */\nexport class WebXRDefaultExperienceOptions {}\n/**\n * Default experience which provides a similar setup to the previous webVRExperience\n */\nexport class WebXRDefaultExperience {\n  constructor() {}\n  /**\n   * Creates the default xr experience\n   * @param scene scene\n   * @param options options for basic configuration\n   * @returns resulting WebXRDefaultExperience\n   */\n  static CreateAsync(scene, options = {}) {\n    const result = new WebXRDefaultExperience();\n    scene.onDisposeObservable.addOnce(() => {\n      result.dispose();\n    });\n    // init the UI right after construction\n    if (!options.disableDefaultUI) {\n      const uiOptions = {\n        renderTarget: result.renderTarget,\n        ...(options.uiOptions || {})\n      };\n      if (options.optionalFeatures) {\n        if (typeof options.optionalFeatures === \"boolean\") {\n          uiOptions.optionalFeatures = [\"hit-test\", \"anchors\", \"plane-detection\", \"hand-tracking\"];\n        } else {\n          uiOptions.optionalFeatures = options.optionalFeatures;\n        }\n      }\n      result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);\n    }\n    // Create base experience\n    return WebXRExperienceHelper.CreateAsync(scene).then(xrHelper => {\n      result.baseExperience = xrHelper;\n      if (options.ignoreNativeCameraTransformation) {\n        result.baseExperience.camera.compensateOnFirstFrame = false;\n      }\n      // Add controller support\n      result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {\n        controllerOptions: {\n          renderingGroupId: options.renderingGroupId\n        },\n        ...(options.inputOptions || {})\n      });\n      if (!options.disablePointerSelection) {\n        // Add default pointer selection\n        const pointerSelectionOptions = {\n          ...options.pointerSelectionOptions,\n          xrInput: result.input,\n          renderingGroupId: options.renderingGroupId\n        };\n        result.pointerSelection = result.baseExperience.featuresManager.enableFeature(WebXRControllerPointerSelection.Name, options.useStablePlugins ? \"stable\" : \"latest\", pointerSelectionOptions);\n        if (!options.disableTeleportation) {\n          // Add default teleportation, including rotation\n          result.teleportation = result.baseExperience.featuresManager.enableFeature(WebXRMotionControllerTeleportation.Name, options.useStablePlugins ? \"stable\" : \"latest\", {\n            floorMeshes: options.floorMeshes,\n            xrInput: result.input,\n            renderingGroupId: options.renderingGroupId,\n            ...options.teleportationOptions\n          });\n          result.teleportation.setSelectionFeature(result.pointerSelection);\n        }\n      }\n      if (!options.disableNearInteraction) {\n        // Add default pointer selection\n        result.nearInteraction = result.baseExperience.featuresManager.enableFeature(WebXRNearInteraction.Name, options.useStablePlugins ? \"stable\" : \"latest\", {\n          xrInput: result.input,\n          farInteractionFeature: result.pointerSelection,\n          renderingGroupId: options.renderingGroupId,\n          useUtilityLayer: true,\n          enableNearInteractionOnAllControllers: true,\n          ...options.nearInteractionOptions\n        });\n      }\n      // Create the WebXR output target\n      result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);\n      if (!options.disableDefaultUI) {\n        // Create ui for entering/exiting xr\n        return result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);\n      } else {\n        return;\n      }\n    }).then(() => {\n      return result;\n    }).catch(error => {\n      Logger.Error(\"Error initializing XR\");\n      Logger.Error(error);\n      return result;\n    });\n  }\n  /**\n   * Disposes of the experience helper\n   */\n  dispose() {\n    if (this.baseExperience) {\n      this.baseExperience.dispose();\n    }\n    if (this.input) {\n      this.input.dispose();\n    }\n    if (this.enterExitUI) {\n      this.enterExitUI.dispose();\n    }\n    if (this.renderTarget) {\n      this.renderTarget.dispose();\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["WebXRExperienceHelper","WebXRInput","WebXRControllerPointerSelection","WebXRNearInteraction","WebXREnterExitUI","WebXRMotionControllerTeleportation","Logger","WebXRDefaultExperienceOptions","WebXRDefaultExperience","constructor","CreateAsync","scene","options","result","onDisposeObservable","addOnce","dispose","disableDefaultUI","uiOptions","renderTarget","optionalFeatures","enterExitUI","then","xrHelper","baseExperience","ignoreNativeCameraTransformation","camera","compensateOnFirstFrame","input","sessionManager","controllerOptions","renderingGroupId","inputOptions","disablePointerSelection","pointerSelectionOptions","xrInput","pointerSelection","featuresManager","enableFeature","Name","useStablePlugins","disableTeleportation","teleportation","floorMeshes","teleportationOptions","setSelectionFeature","disableNearInteraction","nearInteraction","farInteractionFeature","useUtilityLayer","enableNearInteractionOnAllControllers","nearInteractionOptions","getWebXRRenderTarget","outputCanvasOptions","setHelperAsync","catch","error","Error"],"sourceRoot":"","sources":["../../../../lts/core/generated/XR/webXRDefaultExperience.ts"],"sourcesContent":["import { WebXRExperienceHelper } from \"./webXRExperienceHelper\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IWebXRInputOptions } from \"./webXRInput\";\r\nimport { WebXRInput } from \"./webXRInput\";\r\nimport type { IWebXRControllerPointerSelectionOptions } from \"./features/WebXRControllerPointerSelection\";\r\nimport { WebXRControllerPointerSelection } from \"./features/WebXRControllerPointerSelection\";\r\nimport type { IWebXRNearInteractionOptions } from \"./features/WebXRNearInteraction\";\r\nimport { WebXRNearInteraction } from \"./features/WebXRNearInteraction\";\r\nimport type { WebXRRenderTarget } from \"./webXRTypes\";\r\nimport type { WebXREnterExitUIOptions } from \"./webXREnterExitUI\";\r\nimport { WebXREnterExitUI } from \"./webXREnterExitUI\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { WebXRManagedOutputCanvasOptions } from \"./webXRManagedOutputCanvas\";\r\nimport type { IWebXRTeleportationOptions } from \"./features/WebXRControllerTeleportation\";\r\nimport { WebXRMotionControllerTeleportation } from \"./features/WebXRControllerTeleportation\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Options for the default xr helper\r\n */\r\nexport class WebXRDefaultExperienceOptions {\r\n    /**\r\n     * Enable or disable default UI to enter XR\r\n     */\r\n    public disableDefaultUI?: boolean;\r\n    /**\r\n     * Should pointer selection not initialize.\r\n     * Note that disabling pointer selection also disables teleportation.\r\n     * Defaults to false.\r\n     */\r\n    public disablePointerSelection?: boolean;\r\n    /**\r\n     * Should teleportation not initialize. Defaults to false.\r\n     */\r\n    public disableTeleportation?: boolean;\r\n    /**\r\n     * Should nearInteraction not initialize. Defaults to false.\r\n     */\r\n    public disableNearInteraction?: boolean;\r\n    /**\r\n     * Floor meshes that will be used for teleport\r\n     */\r\n    public floorMeshes?: Array<AbstractMesh>;\r\n    /**\r\n     * If set to true, the first frame will not be used to reset position\r\n     * The first frame is mainly used when copying transformation from the old camera\r\n     * Mainly used in AR\r\n     */\r\n    public ignoreNativeCameraTransformation?: boolean;\r\n    /**\r\n     * Optional configuration for the XR input object\r\n     */\r\n    public inputOptions?: Partial<IWebXRInputOptions>;\r\n    /**\r\n     * optional configuration for pointer selection\r\n     */\r\n    public pointerSelectionOptions?: Partial<IWebXRControllerPointerSelectionOptions>;\r\n    /**\r\n     * optional configuration for near interaction\r\n     */\r\n    public nearInteractionOptions?: Partial<IWebXRNearInteractionOptions>;\r\n    /**\r\n     * optional configuration for teleportation\r\n     */\r\n    public teleportationOptions?: Partial<IWebXRTeleportationOptions>;\r\n    /**\r\n     * optional configuration for the output canvas\r\n     */\r\n    public outputCanvasOptions?: WebXRManagedOutputCanvasOptions;\r\n    /**\r\n     * optional UI options. This can be used among other to change session mode and reference space type\r\n     */\r\n    public uiOptions?: Partial<WebXREnterExitUIOptions>;\r\n    /**\r\n     * When loading teleportation and pointer select, use stable versions instead of latest.\r\n     */\r\n    public useStablePlugins?: boolean;\r\n\r\n    /**\r\n     * An optional rendering group id that will be set globally for teleportation, pointer selection and default controller meshes\r\n     */\r\n    public renderingGroupId?: number;\r\n\r\n    /**\r\n     * A list of optional features to init the session with\r\n     * If set to true, all features we support will be added\r\n     */\r\n    public optionalFeatures?: boolean | string[];\r\n}\r\n\r\n/**\r\n * Default experience which provides a similar setup to the previous webVRExperience\r\n */\r\nexport class WebXRDefaultExperience {\r\n    /**\r\n     * Base experience\r\n     */\r\n    public baseExperience: WebXRExperienceHelper;\r\n    /**\r\n     * Enables ui for entering/exiting xr\r\n     */\r\n    public enterExitUI: WebXREnterExitUI;\r\n    /**\r\n     * Input experience extension\r\n     */\r\n    public input: WebXRInput;\r\n    /**\r\n     * Enables laser pointer and selection\r\n     */\r\n    public pointerSelection: WebXRControllerPointerSelection;\r\n    /**\r\n     * Default target xr should render to\r\n     */\r\n    public renderTarget: WebXRRenderTarget;\r\n    /**\r\n     * Enables teleportation\r\n     */\r\n    public teleportation: WebXRMotionControllerTeleportation;\r\n\r\n    /**\r\n     * Enables near interaction for hands/controllers\r\n     */\r\n    public nearInteraction: WebXRNearInteraction;\r\n\r\n    private constructor() {}\r\n\r\n    /**\r\n     * Creates the default xr experience\r\n     * @param scene scene\r\n     * @param options options for basic configuration\r\n     * @returns resulting WebXRDefaultExperience\r\n     */\r\n    public static CreateAsync(scene: Scene, options: WebXRDefaultExperienceOptions = {}) {\r\n        const result = new WebXRDefaultExperience();\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            result.dispose();\r\n        });\r\n        // init the UI right after construction\r\n        if (!options.disableDefaultUI) {\r\n            const uiOptions: WebXREnterExitUIOptions = {\r\n                renderTarget: result.renderTarget,\r\n                ...(options.uiOptions || {}),\r\n            };\r\n            if (options.optionalFeatures) {\r\n                if (typeof options.optionalFeatures === \"boolean\") {\r\n                    uiOptions.optionalFeatures = [\"hit-test\", \"anchors\", \"plane-detection\", \"hand-tracking\"];\r\n                } else {\r\n                    uiOptions.optionalFeatures = options.optionalFeatures;\r\n                }\r\n            }\r\n            result.enterExitUI = new WebXREnterExitUI(scene, uiOptions);\r\n        }\r\n\r\n        // Create base experience\r\n        return WebXRExperienceHelper.CreateAsync(scene)\r\n            .then((xrHelper) => {\r\n                result.baseExperience = xrHelper;\r\n\r\n                if (options.ignoreNativeCameraTransformation) {\r\n                    result.baseExperience.camera.compensateOnFirstFrame = false;\r\n                }\r\n\r\n                // Add controller support\r\n                result.input = new WebXRInput(xrHelper.sessionManager, xrHelper.camera, {\r\n                    controllerOptions: {\r\n                        renderingGroupId: options.renderingGroupId,\r\n                    },\r\n                    ...(options.inputOptions || {}),\r\n                });\r\n\r\n                if (!options.disablePointerSelection) {\r\n                    // Add default pointer selection\r\n                    const pointerSelectionOptions = {\r\n                        ...options.pointerSelectionOptions,\r\n                        xrInput: result.input,\r\n                        renderingGroupId: options.renderingGroupId,\r\n                    };\r\n\r\n                    result.pointerSelection = <WebXRControllerPointerSelection>(\r\n                        result.baseExperience.featuresManager.enableFeature(\r\n                            WebXRControllerPointerSelection.Name,\r\n                            options.useStablePlugins ? \"stable\" : \"latest\",\r\n                            <IWebXRControllerPointerSelectionOptions>pointerSelectionOptions\r\n                        )\r\n                    );\r\n\r\n                    if (!options.disableTeleportation) {\r\n                        // Add default teleportation, including rotation\r\n                        result.teleportation = <WebXRMotionControllerTeleportation>result.baseExperience.featuresManager.enableFeature(\r\n                            WebXRMotionControllerTeleportation.Name,\r\n                            options.useStablePlugins ? \"stable\" : \"latest\",\r\n                            <IWebXRTeleportationOptions>{\r\n                                floorMeshes: options.floorMeshes,\r\n                                xrInput: result.input,\r\n                                renderingGroupId: options.renderingGroupId,\r\n                                ...options.teleportationOptions,\r\n                            }\r\n                        );\r\n                        result.teleportation.setSelectionFeature(result.pointerSelection);\r\n                    }\r\n                }\r\n\r\n                if (!options.disableNearInteraction) {\r\n                    // Add default pointer selection\r\n                    result.nearInteraction = <WebXRNearInteraction>result.baseExperience.featuresManager.enableFeature(\r\n                        WebXRNearInteraction.Name,\r\n                        options.useStablePlugins ? \"stable\" : \"latest\",\r\n                        <IWebXRNearInteractionOptions>{\r\n                            xrInput: result.input,\r\n                            farInteractionFeature: result.pointerSelection,\r\n                            renderingGroupId: options.renderingGroupId,\r\n                            useUtilityLayer: true,\r\n                            enableNearInteractionOnAllControllers: true,\r\n                            ...options.nearInteractionOptions,\r\n                        }\r\n                    );\r\n                }\r\n\r\n                // Create the WebXR output target\r\n                result.renderTarget = result.baseExperience.sessionManager.getWebXRRenderTarget(options.outputCanvasOptions);\r\n\r\n                if (!options.disableDefaultUI) {\r\n                    // Create ui for entering/exiting xr\r\n                    return result.enterExitUI.setHelperAsync(result.baseExperience, result.renderTarget);\r\n                } else {\r\n                    return;\r\n                }\r\n            })\r\n            .then(() => {\r\n                return result;\r\n            })\r\n            .catch((error) => {\r\n                Logger.Error(\"Error initializing XR\");\r\n                Logger.Error(error);\r\n                return result;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Disposes of the experience helper\r\n     */\r\n    public dispose() {\r\n        if (this.baseExperience) {\r\n            this.baseExperience.dispose();\r\n        }\r\n        if (this.input) {\r\n            this.input.dispose();\r\n        }\r\n        if (this.enterExitUI) {\r\n            this.enterExitUI.dispose();\r\n        }\r\n        if (this.renderTarget) {\r\n            this.renderTarget.dispose();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}