{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Scene } from \"../scene.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { SubSurfaceConfiguration } from \"./subSurfaceConfiguration.js\";\nimport { AbstractScene } from \"../abstractScene.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\n// Adds the parser to the scene parsers.\nAbstractScene.AddParser(SceneComponentConstants.NAME_SUBSURFACE, (parsedData, scene) => {\n  // Diffusion profiles\n  if (parsedData.ssDiffusionProfileColors !== undefined && parsedData.ssDiffusionProfileColors !== null) {\n    scene.enableSubSurfaceForPrePass();\n    if (scene.subSurfaceConfiguration) {\n      for (let index = 0, cache = parsedData.ssDiffusionProfileColors.length; index < cache; index++) {\n        const color = parsedData.ssDiffusionProfileColors[index];\n        scene.subSurfaceConfiguration.addDiffusionProfile(new Color3(color.r, color.g, color.b));\n      }\n    }\n  }\n});\nObject.defineProperty(Scene.prototype, \"subSurfaceConfiguration\", {\n  get: function () {\n    return this._subSurfaceConfiguration;\n  },\n  set: function (value) {\n    if (value) {\n      if (this.enablePrePassRenderer()) {\n        this._subSurfaceConfiguration = value;\n      }\n    }\n  },\n  enumerable: true,\n  configurable: true\n});\nScene.prototype.enableSubSurfaceForPrePass = function () {\n  if (this._subSurfaceConfiguration) {\n    return this._subSurfaceConfiguration;\n  }\n  const prePassRenderer = this.enablePrePassRenderer();\n  if (prePassRenderer) {\n    this._subSurfaceConfiguration = new SubSurfaceConfiguration(this);\n    prePassRenderer.addEffectConfiguration(this._subSurfaceConfiguration);\n    return this._subSurfaceConfiguration;\n  }\n  return null;\n};\nScene.prototype.disableSubSurfaceForPrePass = function () {\n  if (!this._subSurfaceConfiguration) {\n    return;\n  }\n  this._subSurfaceConfiguration.dispose();\n  this._subSurfaceConfiguration = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class SubSurfaceSceneComponent {\n  /**\n   * Creates a new instance of the component for the given scene\n   * @param scene Defines the scene to register the component in\n   */\n  constructor(scene) {\n    /**\n     * The component name helpful to identify the component in the list of scene components.\n     */\n    this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n    this.scene = scene;\n  }\n  /**\n   * Registers the component in a given scene\n   */\n  register() {}\n  /**\n   * Serializes the component data to the specified json object\n   * @param serializationObject The object to serialize to\n   */\n  serialize(serializationObject) {\n    if (!this.scene.subSurfaceConfiguration) {\n      return;\n    }\n    const ssDiffusionProfileColors = this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;\n    serializationObject.ssDiffusionProfileColors = [];\n    for (let i = 0; i < ssDiffusionProfileColors.length; i++) {\n      serializationObject.ssDiffusionProfileColors.push({\n        r: ssDiffusionProfileColors[i].r,\n        g: ssDiffusionProfileColors[i].g,\n        b: ssDiffusionProfileColors[i].b\n      });\n    }\n  }\n  /**\n   * Adds all the elements from the container to the scene\n   */\n  addFromContainer() {\n    // Nothing to do\n  }\n  /**\n   * Removes all the elements in the container from the scene\n   */\n  removeFromContainer() {\n    // Make sure nothing will be serialized\n    if (!this.scene.prePassRenderer) {\n      return;\n    }\n    if (this.scene.subSurfaceConfiguration) {\n      this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles();\n    }\n  }\n  /**\n   * Rebuilds the elements related to this component in case of\n   * context lost for instance.\n   */\n  rebuild() {\n    // Nothing to do for this component\n  }\n  /**\n   * Disposes the component and the associated resources\n   */\n  dispose() {\n    // Nothing to do for this component\n  }\n}\nSubSurfaceConfiguration._SceneComponentInitialization = scene => {\n  // Register the G Buffer component to the scene.\n  let component = scene._getComponent(SceneComponentConstants.NAME_SUBSURFACE);\n  if (!component) {\n    component = new SubSurfaceSceneComponent(scene);\n    scene._addComponent(component);\n  }\n};","map":{"version":3,"mappings":"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","names":["Scene","SceneComponentConstants","SubSurfaceConfiguration","AbstractScene","Color3","AddParser","NAME_SUBSURFACE","parsedData","scene","ssDiffusionProfileColors","undefined","enableSubSurfaceForPrePass","subSurfaceConfiguration","index","cache","length","color","addDiffusionProfile","r","g","b","Object","defineProperty","prototype","get","_subSurfaceConfiguration","set","value","enablePrePassRenderer","enumerable","configurable","prePassRenderer","addEffectConfiguration","disableSubSurfaceForPrePass","dispose","SubSurfaceSceneComponent","constructor","NAME_PREPASSRENDERER","register","serialize","serializationObject","i","push","addFromContainer","removeFromContainer","clearAllDiffusionProfiles","rebuild","_SceneComponentInitialization","component","_getComponent","_addComponent"],"sourceRoot":"","sources":["../../../../lts/core/generated/Rendering/subSurfaceSceneComponent.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { SubSurfaceConfiguration } from \"./subSurfaceConfiguration\";\r\nimport { AbstractScene } from \"../abstractScene\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAbstractScene.AddParser(SceneComponentConstants.NAME_SUBSURFACE, (parsedData: any, scene: Scene) => {\r\n    // Diffusion profiles\r\n    if (parsedData.ssDiffusionProfileColors !== undefined && parsedData.ssDiffusionProfileColors !== null) {\r\n        scene.enableSubSurfaceForPrePass();\r\n        if (scene.subSurfaceConfiguration) {\r\n            for (let index = 0, cache = parsedData.ssDiffusionProfileColors.length; index < cache; index++) {\r\n                const color = parsedData.ssDiffusionProfileColors[index];\r\n                scene.subSurfaceConfiguration.addDiffusionProfile(new Color3(color.r, color.g, color.b));\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\ndeclare module \"../abstractScene\" {\r\n    export interface AbstractScene {\r\n        /** @internal (Backing field) */\r\n        _subSurfaceConfiguration: Nullable<SubSurfaceConfiguration>;\r\n\r\n        /**\r\n         * Gets or Sets the current prepass renderer associated to the scene.\r\n         */\r\n        subSurfaceConfiguration: Nullable<SubSurfaceConfiguration>;\r\n\r\n        /**\r\n         * Enables the subsurface effect for prepass\r\n         * @returns the SubSurfaceConfiguration\r\n         */\r\n        enableSubSurfaceForPrePass(): Nullable<SubSurfaceConfiguration>;\r\n\r\n        /**\r\n         * Disables the subsurface effect for prepass\r\n         */\r\n        disableSubSurfaceForPrePass(): void;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"subSurfaceConfiguration\", {\r\n    get: function (this: Scene) {\r\n        return this._subSurfaceConfiguration;\r\n    },\r\n    set: function (this: Scene, value: Nullable<SubSurfaceConfiguration>) {\r\n        if (value) {\r\n            if (this.enablePrePassRenderer()) {\r\n                this._subSurfaceConfiguration = value;\r\n            }\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.enableSubSurfaceForPrePass = function (): Nullable<SubSurfaceConfiguration> {\r\n    if (this._subSurfaceConfiguration) {\r\n        return this._subSurfaceConfiguration;\r\n    }\r\n\r\n    const prePassRenderer = this.enablePrePassRenderer();\r\n    if (prePassRenderer) {\r\n        this._subSurfaceConfiguration = new SubSurfaceConfiguration(this);\r\n        prePassRenderer.addEffectConfiguration(this._subSurfaceConfiguration);\r\n        return this._subSurfaceConfiguration;\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nScene.prototype.disableSubSurfaceForPrePass = function (): void {\r\n    if (!this._subSurfaceConfiguration) {\r\n        return;\r\n    }\r\n\r\n    this._subSurfaceConfiguration.dispose();\r\n    this._subSurfaceConfiguration = null;\r\n};\r\n\r\n/**\r\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\r\n * in several rendering techniques.\r\n */\r\nexport class SubSurfaceSceneComponent implements ISceneSerializableComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PREPASSRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {}\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        if (!this.scene.subSurfaceConfiguration) {\r\n            return;\r\n        }\r\n\r\n        const ssDiffusionProfileColors = this.scene.subSurfaceConfiguration.ssDiffusionProfileColors;\r\n        serializationObject.ssDiffusionProfileColors = [];\r\n\r\n        for (let i = 0; i < ssDiffusionProfileColors.length; i++) {\r\n            serializationObject.ssDiffusionProfileColors.push({\r\n                r: ssDiffusionProfileColors[i].r,\r\n                g: ssDiffusionProfileColors[i].g,\r\n                b: ssDiffusionProfileColors[i].b,\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     */\r\n    public addFromContainer(): void {\r\n        // Nothing to do\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     */\r\n    public removeFromContainer(): void {\r\n        // Make sure nothing will be serialized\r\n        if (!this.scene.prePassRenderer) {\r\n            return;\r\n        }\r\n\r\n        if (this.scene.subSurfaceConfiguration) {\r\n            this.scene.subSurfaceConfiguration.clearAllDiffusionProfiles();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do for this component\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do for this component\r\n    }\r\n}\r\n\r\nSubSurfaceConfiguration._SceneComponentInitialization = (scene: Scene) => {\r\n    // Register the G Buffer component to the scene.\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_SUBSURFACE) as SubSurfaceSceneComponent;\r\n    if (!component) {\r\n        component = new SubSurfaceSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}