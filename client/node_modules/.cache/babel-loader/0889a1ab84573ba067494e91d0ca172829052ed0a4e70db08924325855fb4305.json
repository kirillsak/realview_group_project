{"ast":null,"code":"import { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager.js\";\nimport { Observable } from \"../../Misc/observable.js\";\nimport { Vector3, Matrix } from \"../../Maths/math.vector.js\";\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature.js\";\nimport { Tools } from \"../../Misc/tools.js\";\n/**\n * The currently-working hit-test module.\n * Hit test (or Ray-casting) is used to interact with the real world.\n * For further information read here - https://github.com/immersive-web/hit-test\n */\nexport class WebXRHitTestLegacy extends WebXRAbstractFeature {\n  /**\n   * Creates a new instance of the (legacy version) hit test feature\n   * @param _xrSessionManager an instance of WebXRSessionManager\n   * @param options options to use when constructing this feature\n   */\n  constructor(_xrSessionManager,\n  /**\n   * options to use when constructing this feature\n   */\n  options = {}) {\n    super(_xrSessionManager);\n    this.options = options;\n    // in XR space z-forward is negative\n    this._direction = new Vector3(0, 0, -1);\n    this._mat = new Matrix();\n    this._onSelectEnabled = false;\n    this._origin = new Vector3(0, 0, 0);\n    /**\n     * Populated with the last native XR Hit Results\n     */\n    this.lastNativeXRHitResults = [];\n    /**\n     * Triggered when new babylon (transformed) hit test results are available\n     */\n    this.onHitTestResultObservable = new Observable();\n    this._onHitTestResults = xrResults => {\n      const mats = xrResults.map(result => {\n        const mat = Matrix.FromArray(result.hitMatrix);\n        if (!this._xrSessionManager.scene.useRightHandedSystem) {\n          mat.toggleModelMatrixHandInPlace();\n        }\n        // if (this.options.coordinatesSpace === Space.WORLD) {\n        if (this.options.worldParentNode) {\n          mat.multiplyToRef(this.options.worldParentNode.getWorldMatrix(), mat);\n        }\n        return {\n          xrHitResult: result,\n          transformationMatrix: mat\n        };\n      });\n      this.lastNativeXRHitResults = xrResults;\n      this.onHitTestResultObservable.notifyObservers(mats);\n    };\n    // can be done using pointerdown event, and xrSessionManager.currentFrame\n    this._onSelect = event => {\n      if (!this._onSelectEnabled) {\n        return;\n      }\n      WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, this._xrSessionManager.referenceSpace);\n    };\n    this.xrNativeFeatureName = \"hit-test\";\n    Tools.Warn(\"A newer version of this plugin is available\");\n  }\n  /**\n   * execute a hit test with an XR Ray\n   *\n   * @param xrSession a native xrSession that will execute this hit test\n   * @param xrRay the ray (position and direction) to use for ray-casting\n   * @param referenceSpace native XR reference space to use for the hit-test\n   * @param filter filter function that will filter the results\n   * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\n   */\n  static XRHitTestWithRay(xrSession, xrRay, referenceSpace, filter) {\n    return xrSession.requestHitTest(xrRay, referenceSpace).then(results => {\n      const filterFunction = filter || (result => !!result.hitMatrix);\n      return results.filter(filterFunction);\n    });\n  }\n  /**\n   * Execute a hit test on the current running session using a select event returned from a transient input (such as touch)\n   * @param event the (select) event to use to select with\n   * @param referenceSpace the reference space to use for this hit test\n   * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\n   */\n  static XRHitTestWithSelectEvent(event, referenceSpace) {\n    const targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);\n    if (!targetRayPose) {\n      return Promise.resolve([]);\n    }\n    const targetRay = new XRRay(targetRayPose.transform);\n    return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);\n  }\n  /**\n   * attach this feature\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  attach() {\n    if (!super.attach()) {\n      return false;\n    }\n    if (this.options.testOnPointerDownOnly) {\n      this._xrSessionManager.session.addEventListener(\"select\", this._onSelect, false);\n    }\n    return true;\n  }\n  /**\n   * detach this feature.\n   * Will usually be called by the features manager\n   *\n   * @returns true if successful.\n   */\n  detach() {\n    if (!super.detach()) {\n      return false;\n    }\n    // disable select\n    this._onSelectEnabled = false;\n    this._xrSessionManager.session.removeEventListener(\"select\", this._onSelect);\n    return true;\n  }\n  /**\n   * Dispose this feature and all of the resources attached\n   */\n  dispose() {\n    super.dispose();\n    this.onHitTestResultObservable.clear();\n  }\n  _onXRFrame(frame) {\n    // make sure we do nothing if (async) not attached\n    if (!this.attached || this.options.testOnPointerDownOnly) {\n      return;\n    }\n    const pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);\n    if (!pose) {\n      return;\n    }\n    Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);\n    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);\n    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);\n    this._direction.subtractInPlace(this._origin);\n    this._direction.normalize();\n    const ray = new XRRay({\n      x: this._origin.x,\n      y: this._origin.y,\n      z: this._origin.z,\n      w: 0\n    }, {\n      x: this._direction.x,\n      y: this._direction.y,\n      z: this._direction.z,\n      w: 0\n    });\n    WebXRHitTestLegacy.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);\n  }\n}\n/**\n * The module's name\n */\nWebXRHitTestLegacy.Name = WebXRFeatureName.HIT_TEST;\n/**\n * The (Babylon) version of this module.\n * This is an integer representing the implementation version.\n * This number does not correspond to the WebXR specs version\n */\nWebXRHitTestLegacy.Version = 1;\n//register the plugin versions\nWebXRFeaturesManager.AddWebXRFeature(WebXRHitTestLegacy.Name, (xrSessionManager, options) => {\n  return () => new WebXRHitTestLegacy(xrSessionManager, options);\n}, WebXRHitTestLegacy.Version, false);","map":{"version":3,"mappings":"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","names":["WebXRFeaturesManager","WebXRFeatureName","Observable","Vector3","Matrix","WebXRAbstractFeature","Tools","WebXRHitTestLegacy","constructor","_xrSessionManager","options","xrResults","mats","map","result","mat","FromArray","hitMatrix","scene","useRightHandedSystem","toggleModelMatrixHandInPlace","worldParentNode","multiplyToRef","getWorldMatrix","xrHitResult","transformationMatrix","lastNativeXRHitResults","onHitTestResultObservable","notifyObservers","event","_onSelectEnabled","XRHitTestWithSelectEvent","referenceSpace","xrNativeFeatureName","Warn","XRHitTestWithRay","xrSession","xrRay","filter","requestHitTest","then","results","filterFunction","targetRayPose","frame","getPose","inputSource","targetRaySpace","Promise","resolve","targetRay","XRRay","transform","session","attach","testOnPointerDownOnly","addEventListener","_onSelect","detach","removeEventListener","dispose","clear","_onXRFrame","attached","pose","getViewerPose","FromArrayToRef","matrix","_mat","TransformCoordinatesFromFloatsToRef","_origin","_direction","subtractInPlace","normalize","ray","x","y","z","w","_onHitTestResults","HIT_TEST","AddWebXRFeature","Name","xrSessionManager","Version"],"sourceRoot":"","sources":["../../../../../lts/core/generated/XR/features/WebXRHitTestLegacy.ts"],"sourcesContent":["import type { IWebXRFeature } from \"../webXRFeaturesManager\";\r\nimport { WebXRFeaturesManager, WebXRFeatureName } from \"../webXRFeaturesManager\";\r\nimport type { WebXRSessionManager } from \"../webXRSessionManager\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { Vector3, Matrix } from \"../../Maths/math.vector\";\r\nimport type { TransformNode } from \"../../Meshes/transformNode\";\r\nimport { WebXRAbstractFeature } from \"./WebXRAbstractFeature\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n// the plugin is registered at the end of the file\r\n\r\n/**\r\n * An interface for all Hit test features\r\n */\r\nexport interface IWebXRHitTestFeature<T extends IWebXRLegacyHitResult> extends IWebXRFeature {\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     */\r\n    onHitTestResultObservable: Observable<T[]>;\r\n}\r\n\r\n/**\r\n * Options used for hit testing\r\n */\r\nexport interface IWebXRLegacyHitTestOptions {\r\n    /**\r\n     * Only test when user interacted with the scene. Default - hit test every frame\r\n     */\r\n    testOnPointerDownOnly?: boolean;\r\n    /**\r\n     * The node to use to transform the local results to world coordinates\r\n     */\r\n    worldParentNode?: TransformNode;\r\n}\r\n\r\n/**\r\n * Interface defining the babylon result of raycasting/hit-test\r\n */\r\nexport interface IWebXRLegacyHitResult {\r\n    /**\r\n     * Transformation matrix that can be applied to a node that will put it in the hit point location\r\n     */\r\n    transformationMatrix: Matrix;\r\n    /**\r\n     * The native hit test result\r\n     */\r\n    xrHitResult: XRHitResult | XRHitTestResult;\r\n}\r\n\r\n/**\r\n * The currently-working hit-test module.\r\n * Hit test (or Ray-casting) is used to interact with the real world.\r\n * For further information read here - https://github.com/immersive-web/hit-test\r\n */\r\nexport class WebXRHitTestLegacy extends WebXRAbstractFeature implements IWebXRHitTestFeature<IWebXRLegacyHitResult> {\r\n    // in XR space z-forward is negative\r\n    private _direction = new Vector3(0, 0, -1);\r\n    private _mat = new Matrix();\r\n    private _onSelectEnabled = false;\r\n    private _origin = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * The module's name\r\n     */\r\n    public static readonly Name = WebXRFeatureName.HIT_TEST;\r\n    /**\r\n     * The (Babylon) version of this module.\r\n     * This is an integer representing the implementation version.\r\n     * This number does not correspond to the WebXR specs version\r\n     */\r\n    public static readonly Version = 1;\r\n\r\n    /**\r\n     * Populated with the last native XR Hit Results\r\n     */\r\n    public lastNativeXRHitResults: XRHitResult[] = [];\r\n    /**\r\n     * Triggered when new babylon (transformed) hit test results are available\r\n     */\r\n    public onHitTestResultObservable: Observable<IWebXRLegacyHitResult[]> = new Observable();\r\n\r\n    /**\r\n     * Creates a new instance of the (legacy version) hit test feature\r\n     * @param _xrSessionManager an instance of WebXRSessionManager\r\n     * @param options options to use when constructing this feature\r\n     */\r\n    constructor(\r\n        _xrSessionManager: WebXRSessionManager,\r\n        /**\r\n         * options to use when constructing this feature\r\n         */\r\n        public readonly options: IWebXRLegacyHitTestOptions = {}\r\n    ) {\r\n        super(_xrSessionManager);\r\n        this.xrNativeFeatureName = \"hit-test\";\r\n        Tools.Warn(\"A newer version of this plugin is available\");\r\n    }\r\n\r\n    /**\r\n     * execute a hit test with an XR Ray\r\n     *\r\n     * @param xrSession a native xrSession that will execute this hit test\r\n     * @param xrRay the ray (position and direction) to use for ray-casting\r\n     * @param referenceSpace native XR reference space to use for the hit-test\r\n     * @param filter filter function that will filter the results\r\n     * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\r\n     */\r\n    public static XRHitTestWithRay(xrSession: XRSession, xrRay: XRRay, referenceSpace: XRReferenceSpace, filter?: (result: XRHitResult) => boolean): Promise<XRHitResult[]> {\r\n        return xrSession.requestHitTest!(xrRay, referenceSpace).then((results) => {\r\n            const filterFunction = filter || ((result) => !!result.hitMatrix);\r\n            return results.filter(filterFunction);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Execute a hit test on the current running session using a select event returned from a transient input (such as touch)\r\n     * @param event the (select) event to use to select with\r\n     * @param referenceSpace the reference space to use for this hit test\r\n     * @returns a promise that resolves with an array of native XR hit result in xr coordinates system\r\n     */\r\n    public static XRHitTestWithSelectEvent(event: XRInputSourceEvent, referenceSpace: XRReferenceSpace): Promise<XRHitResult[]> {\r\n        const targetRayPose = event.frame.getPose(event.inputSource.targetRaySpace, referenceSpace);\r\n        if (!targetRayPose) {\r\n            return Promise.resolve([]);\r\n        }\r\n        const targetRay = new XRRay(targetRayPose.transform);\r\n\r\n        return this.XRHitTestWithRay(event.frame.session, targetRay, referenceSpace);\r\n    }\r\n\r\n    /**\r\n     * attach this feature\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public attach(): boolean {\r\n        if (!super.attach()) {\r\n            return false;\r\n        }\r\n        if (this.options.testOnPointerDownOnly) {\r\n            this._xrSessionManager.session.addEventListener(\"select\", this._onSelect, false);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * detach this feature.\r\n     * Will usually be called by the features manager\r\n     *\r\n     * @returns true if successful.\r\n     */\r\n    public detach(): boolean {\r\n        if (!super.detach()) {\r\n            return false;\r\n        }\r\n        // disable select\r\n        this._onSelectEnabled = false;\r\n        this._xrSessionManager.session.removeEventListener(\"select\", this._onSelect);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Dispose this feature and all of the resources attached\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n        this.onHitTestResultObservable.clear();\r\n    }\r\n\r\n    protected _onXRFrame(frame: XRFrame) {\r\n        // make sure we do nothing if (async) not attached\r\n        if (!this.attached || this.options.testOnPointerDownOnly) {\r\n            return;\r\n        }\r\n        const pose = frame.getViewerPose(this._xrSessionManager.referenceSpace);\r\n        if (!pose) {\r\n            return;\r\n        }\r\n        Matrix.FromArrayToRef(pose.transform.matrix, 0, this._mat);\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, this._mat, this._origin);\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0, 0, -1, this._mat, this._direction);\r\n        this._direction.subtractInPlace(this._origin);\r\n        this._direction.normalize();\r\n        const ray = new XRRay(\r\n            <DOMPointReadOnly>{ x: this._origin.x, y: this._origin.y, z: this._origin.z, w: 0 },\r\n            <DOMPointReadOnly>{ x: this._direction.x, y: this._direction.y, z: this._direction.z, w: 0 }\r\n        );\r\n        WebXRHitTestLegacy.XRHitTestWithRay(this._xrSessionManager.session, ray, this._xrSessionManager.referenceSpace).then(this._onHitTestResults);\r\n    }\r\n\r\n    private _onHitTestResults = (xrResults: XRHitResult[]) => {\r\n        const mats = xrResults.map((result) => {\r\n            const mat = Matrix.FromArray(result.hitMatrix);\r\n            if (!this._xrSessionManager.scene.useRightHandedSystem) {\r\n                mat.toggleModelMatrixHandInPlace();\r\n            }\r\n            // if (this.options.coordinatesSpace === Space.WORLD) {\r\n            if (this.options.worldParentNode) {\r\n                mat.multiplyToRef(this.options.worldParentNode.getWorldMatrix(), mat);\r\n            }\r\n            return {\r\n                xrHitResult: result,\r\n                transformationMatrix: mat,\r\n            };\r\n        });\r\n\r\n        this.lastNativeXRHitResults = xrResults;\r\n        this.onHitTestResultObservable.notifyObservers(mats);\r\n    };\r\n\r\n    // can be done using pointerdown event, and xrSessionManager.currentFrame\r\n    private _onSelect = (event: XRInputSourceEvent) => {\r\n        if (!this._onSelectEnabled) {\r\n            return;\r\n        }\r\n        WebXRHitTestLegacy.XRHitTestWithSelectEvent(event, this._xrSessionManager.referenceSpace);\r\n    };\r\n}\r\n\r\n//register the plugin versions\r\nWebXRFeaturesManager.AddWebXRFeature(\r\n    WebXRHitTestLegacy.Name,\r\n    (xrSessionManager, options) => {\r\n        return () => new WebXRHitTestLegacy(xrSessionManager, options);\r\n    },\r\n    WebXRHitTestLegacy.Version,\r\n    false\r\n);\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}