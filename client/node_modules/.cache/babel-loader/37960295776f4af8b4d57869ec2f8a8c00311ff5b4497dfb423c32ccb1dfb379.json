{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Vector3, TmpVectors } from \"../Maths/math.vector.js\";\nimport { Scalar } from \"../Maths/math.scalar.js\";\nimport { PHI } from \"../Maths/math.constants.js\";\nimport { _IsoVector } from \"../Maths/math.isovector.js\";\n/**\n * Class representing data for one face OAB of an equilateral icosahedron\n * When O is the isovector (0, 0), A is isovector (m, n)\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class _PrimaryIsoTriangle {\n  constructor() {\n    this.cartesian = [];\n    this.vertices = [];\n    this.max = [];\n    this.min = [];\n    this.closestTo = [];\n    this.innerFacets = [];\n    this.isoVecsABOB = [];\n    this.isoVecsOBOA = [];\n    this.isoVecsBAOA = [];\n    this.vertexTypes = [];\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    this.IDATA = new PolyhedronData(\"icosahedron\", \"Regular\", [[0, PHI, -1], [-PHI, 1, 0], [-1, 0, -PHI], [1, 0, -PHI], [PHI, 1, 0], [0, PHI, 1], [-1, 0, PHI], [-PHI, -1, 0], [0, -PHI, -1], [PHI, -1, 0], [1, 0, PHI], [0, -PHI, 1]], [[0, 2, 1], [0, 3, 2], [0, 4, 3], [0, 5, 4], [0, 1, 5], [7, 6, 1], [8, 7, 2], [9, 8, 3], [10, 9, 4], [6, 10, 5], [2, 7, 1], [3, 8, 2], [4, 9, 3], [5, 10, 4], [1, 6, 5], [11, 6, 7], [11, 7, 8], [11, 8, 9], [11, 9, 10], [11, 10, 6]]);\n  }\n  /**\n   * Creates the PrimaryIsoTriangle Triangle OAB\n   * @param m an integer\n   * @param n an integer\n   */\n  //operators\n  setIndices() {\n    let indexCount = 12; // 12 vertices already assigned\n    const vecToidx = {}; //maps iso-vectors to indexCount;\n    const m = this.m;\n    const n = this.n;\n    let g = m; // hcf of m, n when n != 0\n    let m1 = 1;\n    let n1 = 0;\n    if (n !== 0) {\n      g = Scalar.HCF(m, n);\n    }\n    m1 = m / g;\n    n1 = n / g;\n    let fr; //face to the right of current face\n    let rot; //rotation about which vertex for fr\n    let O;\n    let A;\n    let B;\n    const oVec = _IsoVector.Zero();\n    const aVec = new _IsoVector(m, n);\n    const bVec = new _IsoVector(-n, m + n);\n    const oaVec = _IsoVector.Zero();\n    const abVec = _IsoVector.Zero();\n    const obVec = _IsoVector.Zero();\n    let verts = [];\n    let idx;\n    let idxR;\n    let isoId;\n    let isoIdR;\n    const closestTo = [];\n    const vDist = this.vertByDist;\n    const matchIdx = (f, fr, isoId, isoIdR) => {\n      idx = f + \"|\" + isoId;\n      idxR = fr + \"|\" + isoIdR;\n      if (!(idx in vecToidx || idxR in vecToidx)) {\n        vecToidx[idx] = indexCount;\n        vecToidx[idxR] = indexCount;\n        indexCount++;\n      } else if (idx in vecToidx && !(idxR in vecToidx)) {\n        vecToidx[idxR] = vecToidx[idx];\n      } else if (idxR in vecToidx && !(idx in vecToidx)) {\n        vecToidx[idx] = vecToidx[idxR];\n      }\n      if (vDist[isoId][0] > 2) {\n        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\n      } else {\n        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\n      }\n    };\n    this.IDATA.edgematch = [[1, \"B\"], [2, \"B\"], [3, \"B\"], [4, \"B\"], [0, \"B\"], [10, \"O\", 14, \"A\"], [11, \"O\", 10, \"A\"], [12, \"O\", 11, \"A\"], [13, \"O\", 12, \"A\"], [14, \"O\", 13, \"A\"], [0, \"O\"], [1, \"O\"], [2, \"O\"], [3, \"O\"], [4, \"O\"], [19, \"B\", 5, \"A\"], [15, \"B\", 6, \"A\"], [16, \"B\", 7, \"A\"], [17, \"B\", 8, \"A\"], [18, \"B\", 9, \"A\"]];\n    /***edges AB to OB***** rotation about B*/\n    for (let f = 0; f < 20; f++) {\n      //f current face\n      verts = this.IDATA.face[f];\n      O = verts[2];\n      A = verts[1];\n      B = verts[0];\n      isoId = oVec.x + \"|\" + oVec.y;\n      idx = f + \"|\" + isoId;\n      if (!(idx in vecToidx)) {\n        vecToidx[idx] = O;\n        closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n      }\n      isoId = aVec.x + \"|\" + aVec.y;\n      idx = f + \"|\" + isoId;\n      if (!(idx in vecToidx)) {\n        vecToidx[idx] = A;\n        closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n      }\n      isoId = bVec.x + \"|\" + bVec.y;\n      idx = f + \"|\" + isoId;\n      if (!(idx in vecToidx)) {\n        vecToidx[idx] = B;\n        closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\n      }\n      //for edge vertices\n      fr = this.IDATA.edgematch[f][0];\n      rot = this.IDATA.edgematch[f][1];\n      if (rot === \"B\") {\n        for (let i = 1; i < g; i++) {\n          abVec.x = m - i * (m1 + n1);\n          abVec.y = n + i * m1;\n          obVec.x = -i * n1;\n          obVec.y = i * (m1 + n1);\n          isoId = abVec.x + \"|\" + abVec.y;\n          isoIdR = obVec.x + \"|\" + obVec.y;\n          matchIdx(f, fr, isoId, isoIdR);\n        }\n      }\n      if (rot === \"O\") {\n        for (let i = 1; i < g; i++) {\n          obVec.x = -i * n1;\n          obVec.y = i * (m1 + n1);\n          oaVec.x = i * m1;\n          oaVec.y = i * n1;\n          isoId = obVec.x + \"|\" + obVec.y;\n          isoIdR = oaVec.x + \"|\" + oaVec.y;\n          matchIdx(f, fr, isoId, isoIdR);\n        }\n      }\n      fr = this.IDATA.edgematch[f][2];\n      rot = this.IDATA.edgematch[f][3];\n      if (rot && rot === \"A\") {\n        for (let i = 1; i < g; i++) {\n          oaVec.x = i * m1;\n          oaVec.y = i * n1;\n          abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\n          abVec.y = n + (g - i) * m1; //reversed for BA\n          isoId = oaVec.x + \"|\" + oaVec.y;\n          isoIdR = abVec.x + \"|\" + abVec.y;\n          matchIdx(f, fr, isoId, isoIdR);\n        }\n      }\n      for (let i = 0; i < this.vertices.length; i++) {\n        isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\n        idx = f + \"|\" + isoId;\n        if (!(idx in vecToidx)) {\n          vecToidx[idx] = indexCount++;\n          if (vDist[isoId][0] > 2) {\n            closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\n          } else {\n            closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\n          }\n        }\n      }\n    }\n    this.closestTo = closestTo;\n    this.vecToidx = vecToidx;\n  }\n  calcCoeffs() {\n    const m = this.m;\n    const n = this.n;\n    const thirdR3 = Math.sqrt(3) / 3;\n    const LSQD = m * m + n * n + m * n;\n    this.coau = (m + n) / LSQD;\n    this.cobu = -n / LSQD;\n    this.coav = -thirdR3 * (m - n) / LSQD;\n    this.cobv = thirdR3 * (2 * m + n) / LSQD;\n  }\n  createInnerFacets() {\n    const m = this.m;\n    const n = this.n;\n    for (let y = 0; y < n + m + 1; y++) {\n      for (let x = this.min[y]; x < this.max[y] + 1; x++) {\n        if (x < this.max[y] && x < this.max[y + 1] + 1) {\n          this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\n        }\n        if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\n          this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\n        }\n      }\n    }\n  }\n  edgeVecsABOB() {\n    const m = this.m;\n    const n = this.n;\n    const B = new _IsoVector(-n, m + n);\n    for (let y = 1; y < m + n; y++) {\n      const point = new _IsoVector(this.min[y], y);\n      const prev = new _IsoVector(this.min[y - 1], y - 1);\n      const next = new _IsoVector(this.min[y + 1], y + 1);\n      const pointR = point.clone();\n      const prevR = prev.clone();\n      const nextR = next.clone();\n      pointR.rotate60About(B);\n      prevR.rotate60About(B);\n      nextR.rotate60About(B);\n      const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\n      const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\n      const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\n      if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\n        if (pointR.x !== maxPrev.x) {\n          // type2\n          //up\n          this.vertexTypes.push([1, 0, 0]);\n          this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\n          //down\n          this.vertexTypes.push([1, 0, 0]);\n          this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\n        } else if (pointR.y === nextR.y) {\n          // type1\n          //up\n          this.vertexTypes.push([1, 1, 0]);\n          this.isoVecsABOB.push([point, prev, maxPrev]);\n          //down\n          this.vertexTypes.push([1, 0, 1]);\n          this.isoVecsABOB.push([point, maxPrev, next]);\n        } else {\n          // type 0\n          //up\n          this.vertexTypes.push([1, 1, 0]);\n          this.isoVecsABOB.push([point, prev, maxPrev]);\n          //down\n          this.vertexTypes.push([1, 0, 0]);\n          this.isoVecsABOB.push([point, maxPrev, maxPoint]);\n        }\n      }\n    }\n  }\n  mapABOBtoOBOA() {\n    const point = new _IsoVector(0, 0);\n    for (let i = 0; i < this.isoVecsABOB.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        point.x = this.isoVecsABOB[i][j].x;\n        point.y = this.isoVecsABOB[i][j].y;\n        if (this.vertexTypes[i][j] === 0) {\n          point.rotateNeg120(this.m, this.n);\n        }\n        temp.push(point.clone());\n      }\n      this.isoVecsOBOA.push(temp);\n    }\n  }\n  mapABOBtoBAOA() {\n    const point = new _IsoVector(0, 0);\n    for (let i = 0; i < this.isoVecsABOB.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        point.x = this.isoVecsABOB[i][j].x;\n        point.y = this.isoVecsABOB[i][j].y;\n        if (this.vertexTypes[i][j] === 1) {\n          point.rotate120(this.m, this.n);\n        }\n        temp.push(point.clone());\n      }\n      this.isoVecsBAOA.push(temp);\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  MapToFace(faceNb, geodesicData) {\n    const F = this.IDATA.face[faceNb];\n    const oidx = F[2];\n    const aidx = F[1];\n    const bidx = F[0];\n    const O = Vector3.FromArray(this.IDATA.vertex[oidx]);\n    const A = Vector3.FromArray(this.IDATA.vertex[aidx]);\n    const B = Vector3.FromArray(this.IDATA.vertex[bidx]);\n    const OA = A.subtract(O);\n    const OB = B.subtract(O);\n    const x = OA.scale(this.coau).add(OB.scale(this.cobu));\n    const y = OA.scale(this.coav).add(OB.scale(this.cobv));\n    const mapped = [];\n    let idx;\n    let tempVec = TmpVectors.Vector3[0];\n    for (let i = 0; i < this.cartesian.length; i++) {\n      tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\n      mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\n      idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\n      geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\n    }\n  }\n  //statics\n  /**Creates a primary triangle\n   * @internal\n   */\n  build(m, n) {\n    const vertices = new Array();\n    const O = _IsoVector.Zero();\n    const A = new _IsoVector(m, n);\n    const B = new _IsoVector(-n, m + n);\n    vertices.push(O, A, B);\n    //max internal isoceles triangle vertices\n    for (let y = n; y < m + 1; y++) {\n      for (let x = 0; x < m + 1 - y; x++) {\n        vertices.push(new _IsoVector(x, y));\n      }\n    }\n    //shared vertices along edges when needed\n    if (n > 0) {\n      const g = Scalar.HCF(m, n);\n      const m1 = m / g;\n      const n1 = n / g;\n      for (let i = 1; i < g; i++) {\n        vertices.push(new _IsoVector(i * m1, i * n1)); //OA\n        vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\n        vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\n      }\n      //lower rows vertices and their rotations\n      const ratio = m / n;\n      for (let y = 1; y < n; y++) {\n        for (let x = 0; x < y * ratio; x++) {\n          vertices.push(new _IsoVector(x, y));\n          vertices.push(new _IsoVector(x, y).rotate120(m, n));\n          vertices.push(new _IsoVector(x, y).rotateNeg120(m, n));\n        }\n      }\n    }\n    //order vertices by x and then y\n    vertices.sort((a, b) => {\n      return a.x - b.x;\n    });\n    vertices.sort((a, b) => {\n      return a.y - b.y;\n    });\n    const min = new Array(m + n + 1);\n    const max = new Array(m + n + 1);\n    for (let i = 0; i < min.length; i++) {\n      min[i] = Infinity;\n      max[i] = -Infinity;\n    }\n    let y = 0;\n    let x = 0;\n    const len = vertices.length;\n    for (let i = 0; i < len; i++) {\n      x = vertices[i].x;\n      y = vertices[i].y;\n      min[y] = Math.min(x, min[y]);\n      max[y] = Math.max(x, max[y]);\n    }\n    //calculates the distance of a vertex from a given primary vertex\n    const distFrom = (vert, primVert) => {\n      const v = vert.clone();\n      if (primVert === \"A\") {\n        v.rotateNeg120(m, n);\n      }\n      if (primVert === \"B\") {\n        v.rotate120(m, n);\n      }\n      if (v.x < 0) {\n        return v.y;\n      }\n      return v.x + v.y;\n    };\n    const cartesian = [];\n    const distFromO = [];\n    const distFromA = [];\n    const distFromB = [];\n    const vertByDist = {};\n    const vertData = [];\n    let closest = -1;\n    let dist = -1;\n    for (let i = 0; i < len; i++) {\n      cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\n      distFromO[i] = distFrom(vertices[i], \"O\");\n      distFromA[i] = distFrom(vertices[i], \"A\");\n      distFromB[i] = distFrom(vertices[i], \"B\");\n      if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\n        closest = 3;\n        dist = distFromO[i];\n      } else if (distFromO[i] === distFromA[i]) {\n        closest = 4;\n        dist = distFromO[i];\n      } else if (distFromA[i] === distFromB[i]) {\n        closest = 5;\n        dist = distFromA[i];\n      } else if (distFromB[i] === distFromO[i]) {\n        closest = 6;\n        dist = distFromO[i];\n      }\n      if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\n        closest = 2;\n        dist = distFromO[i];\n      }\n      if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\n        closest = 1;\n        dist = distFromA[i];\n      }\n      if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\n        closest = 0;\n        dist = distFromB[i];\n      }\n      vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\n    }\n    vertData.sort((a, b) => {\n      return a[2] - b[2];\n    });\n    vertData.sort((a, b) => {\n      return a[3] - b[3];\n    });\n    vertData.sort((a, b) => {\n      return a[1] - b[1];\n    });\n    vertData.sort((a, b) => {\n      return a[0] - b[0];\n    });\n    for (let v = 0; v < vertData.length; v++) {\n      vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\n    }\n    this.m = m;\n    this.n = n;\n    this.vertices = vertices;\n    this.vertByDist = vertByDist;\n    this.cartesian = cartesian;\n    this.min = min;\n    this.max = max;\n    return this;\n  }\n}\n/** Builds Polyhedron Data\n * @internal\n */\nexport class PolyhedronData {\n  constructor(name, category, vertex, face) {\n    this.name = name;\n    this.category = category;\n    this.vertex = vertex;\n    this.face = face;\n  }\n}\n/**\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\n */\nexport class GeodesicData extends PolyhedronData {\n  /**\n   * @internal\n   */\n  innerToData(face, primTri) {\n    for (let i = 0; i < primTri.innerFacets.length; i++) {\n      this.face.push(primTri.innerFacets[i].map(el => primTri.vecToidx[face + el]));\n    }\n  }\n  /**\n   * @internal\n   */\n  mapABOBtoDATA(faceNb, primTri) {\n    const fr = primTri.IDATA.edgematch[faceNb][0];\n    for (let i = 0; i < primTri.isoVecsABOB.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        if (primTri.vertexTypes[i][j] === 0) {\n          temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\n        } else {\n          temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\n        }\n      }\n      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n    }\n  }\n  /**\n   * @internal\n   */\n  mapOBOAtoDATA(faceNb, primTri) {\n    const fr = primTri.IDATA.edgematch[faceNb][0];\n    for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        if (primTri.vertexTypes[i][j] === 1) {\n          temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\n        } else {\n          temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\n        }\n      }\n      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n    }\n  }\n  /**\n   * @internal\n   */\n  mapBAOAtoDATA(faceNb, primTri) {\n    const fr = primTri.IDATA.edgematch[faceNb][2];\n    for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {\n      const temp = [];\n      for (let j = 0; j < 3; j++) {\n        if (primTri.vertexTypes[i][j] === 1) {\n          temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\n        } else {\n          temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\n        }\n      }\n      this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\n    }\n  }\n  /**\n   * @internal\n   */\n  orderData(primTri) {\n    const nearTo = [];\n    for (let i = 0; i < 13; i++) {\n      nearTo[i] = [];\n    }\n    const close = primTri.closestTo;\n    for (let i = 0; i < close.length; i++) {\n      if (close[i][0] > -1) {\n        if (close[i][1] > 0) {\n          nearTo[close[i][0]].push([i, close[i][1]]);\n        }\n      } else {\n        nearTo[12].push([i, close[i][0]]);\n      }\n    }\n    const near = [];\n    for (let i = 0; i < 12; i++) {\n      near[i] = i;\n    }\n    let nearIndex = 12;\n    for (let i = 0; i < 12; i++) {\n      nearTo[i].sort((a, b) => {\n        return a[1] - b[1];\n      });\n      for (let j = 0; j < nearTo[i].length; j++) {\n        near[nearTo[i][j][0]] = nearIndex++;\n      }\n    }\n    for (let j = 0; j < nearTo[12].length; j++) {\n      near[nearTo[12][j][0]] = nearIndex++;\n    }\n    for (let i = 0; i < this.vertex.length; i++) {\n      this.vertex[i].push(near[i]);\n    }\n    this.vertex.sort((a, b) => {\n      return a[3] - b[3];\n    });\n    for (let i = 0; i < this.vertex.length; i++) {\n      this.vertex[i].pop();\n    }\n    for (let i = 0; i < this.face.length; i++) {\n      for (let j = 0; j < this.face[i].length; j++) {\n        this.face[i][j] = near[this.face[i][j]];\n      }\n    }\n    this.sharedNodes = nearTo[12].length;\n    this.poleNodes = this.vertex.length - this.sharedNodes;\n  }\n  /**\n   * @internal\n   */\n  setOrder(m, faces) {\n    const adjVerts = [];\n    const dualFaces = [];\n    let face = faces.pop();\n    dualFaces.push(face);\n    let index = this.face[face].indexOf(m);\n    index = (index + 2) % 3;\n    let v = this.face[face][index];\n    adjVerts.push(v);\n    let f = 0;\n    while (faces.length > 0) {\n      face = faces[f];\n      if (this.face[face].indexOf(v) > -1) {\n        // v is a vertex of face f\n        index = (this.face[face].indexOf(v) + 1) % 3;\n        v = this.face[face][index];\n        adjVerts.push(v);\n        dualFaces.push(face);\n        faces.splice(f, 1);\n        f = 0;\n      } else {\n        f++;\n      }\n    }\n    this.adjacentFaces.push(adjVerts);\n    return dualFaces;\n  }\n  /**\n   * @internal\n   */\n  toGoldbergPolyhedronData() {\n    const goldbergPolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\n    goldbergPolyhedronData.name = \"GD dual\";\n    const verticesNb = this.vertex.length;\n    const map = new Array(verticesNb);\n    for (let v = 0; v < verticesNb; v++) {\n      map[v] = [];\n    }\n    for (let f = 0; f < this.face.length; f++) {\n      for (let i = 0; i < 3; i++) {\n        map[this.face[f][i]].push(f);\n      }\n    }\n    let cx = 0;\n    let cy = 0;\n    let cz = 0;\n    let face = [];\n    let vertex = [];\n    this.adjacentFaces = [];\n    for (let m = 0; m < map.length; m++) {\n      goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\n      map[m].forEach(el => {\n        cx = 0;\n        cy = 0;\n        cz = 0;\n        face = this.face[el];\n        for (let i = 0; i < 3; i++) {\n          vertex = this.vertex[face[i]];\n          cx += vertex[0];\n          cy += vertex[1];\n          cz += vertex[2];\n        }\n        goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\n      });\n    }\n    return goldbergPolyhedronData;\n  }\n  //statics\n  /**Builds the data for a Geodesic Polyhedron from a primary triangle\n   * @param primTri the primary triangle\n   * @internal\n   */\n  static BuildGeodesicData(primTri) {\n    const geodesicData = new GeodesicData(\"Geodesic-m-n\", \"Geodesic\", [[0, PHI, -1], [-PHI, 1, 0], [-1, 0, -PHI], [1, 0, -PHI], [PHI, 1, 0], [0, PHI, 1], [-1, 0, PHI], [-PHI, -1, 0], [0, -PHI, -1], [PHI, -1, 0], [1, 0, PHI], [0, -PHI, 1]], []);\n    primTri.setIndices();\n    primTri.calcCoeffs();\n    primTri.createInnerFacets();\n    primTri.edgeVecsABOB();\n    primTri.mapABOBtoOBOA();\n    primTri.mapABOBtoBAOA();\n    for (let f = 0; f < primTri.IDATA.face.length; f++) {\n      primTri.MapToFace(f, geodesicData);\n      geodesicData.innerToData(f, primTri);\n      if (primTri.IDATA.edgematch[f][1] === \"B\") {\n        geodesicData.mapABOBtoDATA(f, primTri);\n      }\n      if (primTri.IDATA.edgematch[f][1] === \"O\") {\n        geodesicData.mapOBOAtoDATA(f, primTri);\n      }\n      if (primTri.IDATA.edgematch[f][3] === \"A\") {\n        geodesicData.mapBAOAtoDATA(f, primTri);\n      }\n    }\n    geodesicData.orderData(primTri);\n    const radius = 1;\n    geodesicData.vertex = geodesicData.vertex.map(function (el) {\n      const a = el[0];\n      const b = el[1];\n      const c = el[2];\n      const d = Math.sqrt(a * a + b * b + c * c);\n      el[0] *= radius / d;\n      el[1] *= radius / d;\n      el[2] *= radius / d;\n      return el;\n    });\n    return geodesicData;\n  }\n}","map":{"version":3,"mappings":"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","names":["Vector3","TmpVectors","Scalar","PHI","_IsoVector","_PrimaryIsoTriangle","constructor","PolyhedronData","setIndices","indexCount","vecToidx","m","n","g","m1","n1","HCF","fr","rot","O","A","B","oVec","Zero","aVec","bVec","oaVec","abVec","obVec","verts","idx","idxR","isoId","isoIdR","closestTo","vDist","vertByDist","matchIdx","f","IDATA","edgematch","face","x","y","i","vertices","length","calcCoeffs","thirdR3","Math","sqrt","LSQD","coau","cobu","coav","cobv","createInnerFacets","min","max","innerFacets","push","edgeVecsABOB","point","prev","next","pointR","clone","prevR","nextR","rotate60About","maxPoint","maxPrev","maxLeftPrev","vertexTypes","isoVecsABOB","mapABOBtoOBOA","temp","j","rotateNeg120","isoVecsOBOA","mapABOBtoBAOA","rotate120","isoVecsBAOA","MapToFace","faceNb","geodesicData","F","oidx","aidx","bidx","FromArray","vertex","OA","subtract","OB","scale","add","mapped","tempVec","cartesian","z","build","Array","ratio","sort","a","b","Infinity","len","distFrom","vert","primVert","v","distFromO","distFromA","distFromB","vertData","closest","dist","toCartesianOrigin","name","category","GeodesicData","innerToData","primTri","map","el","mapABOBtoDATA","mapOBOAtoDATA","mapBAOAtoDATA","orderData","nearTo","close","near","nearIndex","pop","sharedNodes","poleNodes","setOrder","faces","adjVerts","dualFaces","index","indexOf","splice","adjacentFaces","toGoldbergPolyhedronData","goldbergPolyhedronData","verticesNb","cx","cy","cz","concat","forEach","BuildGeodesicData","radius","c","d"],"sourceRoot":"","sources":["../../../../lts/core/generated/Meshes/geodesicMesh.ts"],"sourcesContent":["import { Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { PHI } from \"../Maths/math.constants\";\r\nimport { _IsoVector } from \"../Maths/math.isovector\";\r\n\r\n/**\r\n * Class representing data for one face OAB of an equilateral icosahedron\r\n * When O is the isovector (0, 0), A is isovector (m, n)\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class _PrimaryIsoTriangle {\r\n    //properties\r\n    public m: number;\r\n    public n: number;\r\n    public cartesian: Vector3[] = [];\r\n    public vertices: _IsoVector[] = [];\r\n    public max: number[] = [];\r\n    public min: number[] = [];\r\n    public vecToidx: { [key: string]: number };\r\n    public vertByDist: { [key: string]: number[] };\r\n    public closestTo: number[][] = [];\r\n\r\n    public innerFacets: string[][] = [];\r\n    public isoVecsABOB: _IsoVector[][] = [];\r\n    public isoVecsOBOA: _IsoVector[][] = [];\r\n    public isoVecsBAOA: _IsoVector[][] = [];\r\n    public vertexTypes: number[][] = [];\r\n\r\n    public coau: number;\r\n    public cobu: number;\r\n    public coav: number;\r\n    public cobv: number;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public IDATA: PolyhedronData = new PolyhedronData(\r\n        \"icosahedron\",\r\n        \"Regular\",\r\n        [\r\n            [0, PHI, -1],\r\n            [-PHI, 1, 0],\r\n            [-1, 0, -PHI],\r\n            [1, 0, -PHI],\r\n            [PHI, 1, 0],\r\n            [0, PHI, 1],\r\n            [-1, 0, PHI],\r\n            [-PHI, -1, 0],\r\n            [0, -PHI, -1],\r\n            [PHI, -1, 0],\r\n            [1, 0, PHI],\r\n            [0, -PHI, 1],\r\n        ],\r\n        [\r\n            [0, 2, 1],\r\n            [0, 3, 2],\r\n            [0, 4, 3],\r\n            [0, 5, 4],\r\n            [0, 1, 5],\r\n            [7, 6, 1],\r\n            [8, 7, 2],\r\n            [9, 8, 3],\r\n            [10, 9, 4],\r\n            [6, 10, 5],\r\n            [2, 7, 1],\r\n            [3, 8, 2],\r\n            [4, 9, 3],\r\n            [5, 10, 4],\r\n            [1, 6, 5],\r\n            [11, 6, 7],\r\n            [11, 7, 8],\r\n            [11, 8, 9],\r\n            [11, 9, 10],\r\n            [11, 10, 6],\r\n        ]\r\n    );\r\n\r\n    /**\r\n     * Creates the PrimaryIsoTriangle Triangle OAB\r\n     * @param m an integer\r\n     * @param n an integer\r\n     */\r\n\r\n    //operators\r\n    public setIndices() {\r\n        let indexCount = 12; // 12 vertices already assigned\r\n        const vecToidx: { [key: string]: number } = {}; //maps iso-vectors to indexCount;\r\n        const m = this.m;\r\n        const n = this.n;\r\n        let g = m; // hcf of m, n when n != 0\r\n        let m1 = 1;\r\n        let n1 = 0;\r\n        if (n !== 0) {\r\n            g = Scalar.HCF(m, n);\r\n        }\r\n        m1 = m / g;\r\n        n1 = n / g;\r\n\r\n        let fr: number | string; //face to the right of current face\r\n        let rot: number | string; //rotation about which vertex for fr\r\n        let O: number;\r\n        let A: number;\r\n        let B: number;\r\n        const oVec: _IsoVector = _IsoVector.Zero();\r\n        const aVec = new _IsoVector(m, n);\r\n        const bVec = new _IsoVector(-n, m + n);\r\n        const oaVec: _IsoVector = _IsoVector.Zero();\r\n        const abVec: _IsoVector = _IsoVector.Zero();\r\n        const obVec: _IsoVector = _IsoVector.Zero();\r\n        let verts: number[] = [];\r\n        let idx: string;\r\n        let idxR: string;\r\n        let isoId: string;\r\n        let isoIdR: string;\r\n\r\n        const closestTo: number[][] = [];\r\n        const vDist = this.vertByDist;\r\n\r\n        const matchIdx = (f: number, fr: number, isoId: string, isoIdR: string) => {\r\n            idx = f + \"|\" + isoId;\r\n            idxR = fr + \"|\" + isoIdR;\r\n            if (!(idx in vecToidx || idxR in vecToidx)) {\r\n                vecToidx[idx] = indexCount;\r\n                vecToidx[idxR] = indexCount;\r\n                indexCount++;\r\n            } else if (idx in vecToidx && !(idxR in vecToidx)) {\r\n                vecToidx[idxR] = vecToidx[idx];\r\n            } else if (idxR in vecToidx && !(idx in vecToidx)) {\r\n                vecToidx[idx] = vecToidx[idxR];\r\n            }\r\n            if (vDist[isoId][0] > 2) {\r\n                closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n            } else {\r\n                closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n            }\r\n        };\r\n\r\n        this.IDATA.edgematch = [\r\n            [1, \"B\"],\r\n            [2, \"B\"],\r\n            [3, \"B\"],\r\n            [4, \"B\"],\r\n            [0, \"B\"],\r\n            [10, \"O\", 14, \"A\"],\r\n            [11, \"O\", 10, \"A\"],\r\n            [12, \"O\", 11, \"A\"],\r\n            [13, \"O\", 12, \"A\"],\r\n            [14, \"O\", 13, \"A\"],\r\n            [0, \"O\"],\r\n            [1, \"O\"],\r\n            [2, \"O\"],\r\n            [3, \"O\"],\r\n            [4, \"O\"],\r\n            [19, \"B\", 5, \"A\"],\r\n            [15, \"B\", 6, \"A\"],\r\n            [16, \"B\", 7, \"A\"],\r\n            [17, \"B\", 8, \"A\"],\r\n            [18, \"B\", 9, \"A\"],\r\n        ];\r\n\r\n        /***edges AB to OB***** rotation about B*/\r\n        for (let f = 0; f < 20; f++) {\r\n            //f current face\r\n\r\n            verts = this.IDATA.face[f];\r\n            O = verts[2];\r\n            A = verts[1];\r\n            B = verts[0];\r\n\r\n            isoId = oVec.x + \"|\" + oVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = O;\r\n                closestTo[O] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = aVec.x + \"|\" + aVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = A;\r\n                closestTo[A] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            isoId = bVec.x + \"|\" + bVec.y;\r\n            idx = f + \"|\" + isoId;\r\n            if (!(idx in vecToidx)) {\r\n                vecToidx[idx] = B;\r\n                closestTo[B] = [verts[vDist[isoId][0]], vDist[isoId][1]];\r\n            }\r\n\r\n            //for edge vertices\r\n            fr = <number>this.IDATA.edgematch[f][0];\r\n            rot = <string>this.IDATA.edgematch[f][1];\r\n            if (rot === \"B\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    abVec.x = m - i * (m1 + n1);\r\n                    abVec.y = n + i * m1;\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    isoId = abVec.x + \"|\" + abVec.y;\r\n                    isoIdR = obVec.x + \"|\" + obVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            if (rot === \"O\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    obVec.x = -i * n1;\r\n                    obVec.y = i * (m1 + n1);\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    isoId = obVec.x + \"|\" + obVec.y;\r\n                    isoIdR = oaVec.x + \"|\" + oaVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            fr = <number>this.IDATA.edgematch[f][2];\r\n            rot = <string>this.IDATA.edgematch[f][3];\r\n            if (rot && rot === \"A\") {\r\n                for (let i = 1; i < g; i++) {\r\n                    oaVec.x = i * m1;\r\n                    oaVec.y = i * n1;\r\n                    abVec.x = m - (g - i) * (m1 + n1); //reversed for BA\r\n                    abVec.y = n + (g - i) * m1; //reversed for BA\r\n                    isoId = oaVec.x + \"|\" + oaVec.y;\r\n                    isoIdR = abVec.x + \"|\" + abVec.y;\r\n                    matchIdx(f, fr, isoId, isoIdR);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < this.vertices.length; i++) {\r\n                isoId = this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n                idx = f + \"|\" + isoId;\r\n                if (!(idx in vecToidx)) {\r\n                    vecToidx[idx] = indexCount++;\r\n                    if (vDist[isoId][0] > 2) {\r\n                        closestTo[vecToidx[idx]] = [-vDist[isoId][0], vDist[isoId][1], vecToidx[idx]];\r\n                    } else {\r\n                        closestTo[vecToidx[idx]] = [verts[vDist[isoId][0]], vDist[isoId][1], vecToidx[idx]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.closestTo = closestTo;\r\n        this.vecToidx = vecToidx;\r\n    }\r\n\r\n    public calcCoeffs() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        const thirdR3 = Math.sqrt(3) / 3;\r\n\r\n        const LSQD = m * m + n * n + m * n;\r\n\r\n        this.coau = (m + n) / LSQD;\r\n        this.cobu = -n / LSQD;\r\n        this.coav = (-thirdR3 * (m - n)) / LSQD;\r\n        this.cobv = (thirdR3 * (2 * m + n)) / LSQD;\r\n    }\r\n\r\n    public createInnerFacets() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n        for (let y = 0; y < n + m + 1; y++) {\r\n            for (let x = this.min[y]; x < this.max[y] + 1; x++) {\r\n                if (x < this.max[y] && x < this.max[y + 1] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + x + \"|\" + (y + 1), \"|\" + (x + 1) + \"|\" + y]);\r\n                }\r\n                if (y > 0 && x < this.max[y - 1] && x + 1 < this.max[y] + 1) {\r\n                    this.innerFacets.push([\"|\" + x + \"|\" + y, \"|\" + (x + 1) + \"|\" + y, \"|\" + (x + 1) + \"|\" + (y - 1)]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public edgeVecsABOB() {\r\n        const m = this.m;\r\n        const n = this.n;\r\n\r\n        const B = new _IsoVector(-n, m + n);\r\n\r\n        for (let y = 1; y < m + n; y++) {\r\n            const point = new _IsoVector(this.min[y], y);\r\n            const prev = new _IsoVector(this.min[y - 1], y - 1);\r\n            const next = new _IsoVector(this.min[y + 1], y + 1);\r\n            const pointR = point.clone();\r\n            const prevR = prev.clone();\r\n            const nextR = next.clone();\r\n\r\n            pointR.rotate60About(B);\r\n            prevR.rotate60About(B);\r\n            nextR.rotate60About(B);\r\n\r\n            const maxPoint = new _IsoVector(this.max[pointR.y], pointR.y);\r\n            const maxPrev = new _IsoVector(this.max[pointR.y - 1], pointR.y - 1);\r\n            const maxLeftPrev = new _IsoVector(this.max[pointR.y - 1] - 1, pointR.y - 1);\r\n\r\n            if (pointR.x !== maxPoint.x || pointR.y !== maxPoint.y) {\r\n                if (pointR.x !== maxPrev.x) {\r\n                    // type2\r\n                    //up\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxLeftPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxLeftPrev, maxPoint]);\r\n                } else if (pointR.y === nextR.y) {\r\n                    // type1\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 1]);\r\n                    this.isoVecsABOB.push([point, maxPrev, next]);\r\n                } else {\r\n                    // type 0\r\n                    //up\r\n                    this.vertexTypes.push([1, 1, 0]);\r\n                    this.isoVecsABOB.push([point, prev, maxPrev]);\r\n                    //down\r\n                    this.vertexTypes.push([1, 0, 0]);\r\n                    this.isoVecsABOB.push([point, maxPrev, maxPoint]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public mapABOBtoOBOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 0) {\r\n                    point.rotateNeg120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsOBOA.push(temp);\r\n        }\r\n    }\r\n\r\n    public mapABOBtoBAOA() {\r\n        const point = new _IsoVector(0, 0);\r\n        for (let i = 0; i < this.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                point.x = this.isoVecsABOB[i][j].x;\r\n                point.y = this.isoVecsABOB[i][j].y;\r\n                if (this.vertexTypes[i][j] === 1) {\r\n                    point.rotate120(this.m, this.n);\r\n                }\r\n                temp.push(point.clone());\r\n            }\r\n            this.isoVecsBAOA.push(temp);\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public MapToFace(faceNb: number, geodesicData: PolyhedronData) {\r\n        const F = this.IDATA.face[faceNb];\r\n        const oidx = F[2];\r\n        const aidx = F[1];\r\n        const bidx = F[0];\r\n\r\n        const O = Vector3.FromArray(this.IDATA.vertex[oidx]);\r\n        const A = Vector3.FromArray(this.IDATA.vertex[aidx]);\r\n        const B = Vector3.FromArray(this.IDATA.vertex[bidx]);\r\n\r\n        const OA = A.subtract(O);\r\n        const OB = B.subtract(O);\r\n\r\n        const x: Vector3 = OA.scale(this.coau).add(OB.scale(this.cobu));\r\n        const y: Vector3 = OA.scale(this.coav).add(OB.scale(this.cobv));\r\n\r\n        const mapped = [];\r\n\r\n        let idx: string;\r\n        let tempVec: Vector3 = TmpVectors.Vector3[0];\r\n        for (let i = 0; i < this.cartesian.length; i++) {\r\n            tempVec = x.scale(this.cartesian[i].x).add(y.scale(this.cartesian[i].y)).add(O);\r\n            mapped[i] = [tempVec.x, tempVec.y, tempVec.z];\r\n            idx = faceNb + \"|\" + this.vertices[i].x + \"|\" + this.vertices[i].y;\r\n            geodesicData.vertex[this.vecToidx[idx]] = [tempVec.x, tempVec.y, tempVec.z];\r\n        }\r\n    }\r\n\r\n    //statics\r\n    /**Creates a primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public build(m: number, n: number) {\r\n        const vertices = new Array<_IsoVector>();\r\n\r\n        const O: _IsoVector = _IsoVector.Zero();\r\n        const A: _IsoVector = new _IsoVector(m, n);\r\n        const B: _IsoVector = new _IsoVector(-n, m + n);\r\n        vertices.push(O, A, B);\r\n\r\n        //max internal isoceles triangle vertices\r\n        for (let y = n; y < m + 1; y++) {\r\n            for (let x = 0; x < m + 1 - y; x++) {\r\n                vertices.push(new _IsoVector(x, y));\r\n            }\r\n        }\r\n\r\n        //shared vertices along edges when needed\r\n        if (n > 0) {\r\n            const g = Scalar.HCF(m, n);\r\n            const m1 = m / g;\r\n            const n1 = n / g;\r\n\r\n            for (let i = 1; i < g; i++) {\r\n                vertices.push(new _IsoVector(i * m1, i * n1)); //OA\r\n                vertices.push(new _IsoVector(-i * n1, i * (m1 + n1))); //OB\r\n                vertices.push(new _IsoVector(m - i * (m1 + n1), n + i * m1)); // AB\r\n            }\r\n\r\n            //lower rows vertices and their rotations\r\n            const ratio = m / n;\r\n            for (let y = 1; y < n; y++) {\r\n                for (let x = 0; x < y * ratio; x++) {\r\n                    vertices.push(new _IsoVector(x, y));\r\n                    vertices.push(new _IsoVector(x, y).rotate120(m, n));\r\n                    vertices.push(new _IsoVector(x, y).rotateNeg120(m, n));\r\n                }\r\n            }\r\n        }\r\n        //order vertices by x and then y\r\n        vertices.sort((a, b) => {\r\n            return a.x - b.x;\r\n        });\r\n\r\n        vertices.sort((a, b) => {\r\n            return a.y - b.y;\r\n        });\r\n\r\n        const min = new Array<number>(m + n + 1);\r\n        const max = new Array<number>(m + n + 1);\r\n        for (let i = 0; i < min.length; i++) {\r\n            min[i] = Infinity;\r\n            max[i] = -Infinity;\r\n        }\r\n\r\n        let y: number = 0;\r\n        let x: number = 0;\r\n\r\n        const len: number = vertices.length;\r\n        for (let i = 0; i < len; i++) {\r\n            x = vertices[i].x;\r\n            y = vertices[i].y;\r\n            min[y] = Math.min(x, min[y]);\r\n            max[y] = Math.max(x, max[y]);\r\n        }\r\n\r\n        //calculates the distance of a vertex from a given primary vertex\r\n        const distFrom = (vert: _IsoVector, primVert: string) => {\r\n            const v = vert.clone();\r\n            if (primVert === \"A\") {\r\n                v.rotateNeg120(m, n);\r\n            }\r\n            if (primVert === \"B\") {\r\n                v.rotate120(m, n);\r\n            }\r\n            if (v.x < 0) {\r\n                return v.y;\r\n            }\r\n            return v.x + v.y;\r\n        };\r\n\r\n        const cartesian: Vector3[] = [];\r\n        const distFromO: number[] = [];\r\n        const distFromA: number[] = [];\r\n        const distFromB: number[] = [];\r\n        const vertByDist: { [key: string]: number[] } = {};\r\n        const vertData: number[][] = [];\r\n        let closest: number = -1;\r\n        let dist: number = -1;\r\n        for (let i = 0; i < len; i++) {\r\n            cartesian[i] = vertices[i].toCartesianOrigin(new _IsoVector(0, 0), 0.5);\r\n            distFromO[i] = distFrom(vertices[i], \"O\");\r\n            distFromA[i] = distFrom(vertices[i], \"A\");\r\n            distFromB[i] = distFrom(vertices[i], \"B\");\r\n\r\n            if (distFromO[i] === distFromA[i] && distFromA[i] === distFromB[i]) {\r\n                closest = 3;\r\n                dist = distFromO[i];\r\n            } else if (distFromO[i] === distFromA[i]) {\r\n                closest = 4;\r\n                dist = distFromO[i];\r\n            } else if (distFromA[i] === distFromB[i]) {\r\n                closest = 5;\r\n                dist = distFromA[i];\r\n            } else if (distFromB[i] === distFromO[i]) {\r\n                closest = 6;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromO[i] < distFromA[i] && distFromO[i] < distFromB[i]) {\r\n                closest = 2;\r\n                dist = distFromO[i];\r\n            }\r\n            if (distFromA[i] < distFromO[i] && distFromA[i] < distFromB[i]) {\r\n                closest = 1;\r\n                dist = distFromA[i];\r\n            }\r\n            if (distFromB[i] < distFromA[i] && distFromB[i] < distFromO[i]) {\r\n                closest = 0;\r\n                dist = distFromB[i];\r\n            }\r\n            vertData.push([closest, dist, vertices[i].x, vertices[i].y]);\r\n        }\r\n\r\n        vertData.sort((a, b) => {\r\n            return a[2] - b[2];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[1] - b[1];\r\n        });\r\n        vertData.sort((a, b) => {\r\n            return a[0] - b[0];\r\n        });\r\n\r\n        for (let v = 0; v < vertData.length; v++) {\r\n            vertByDist[vertData[v][2] + \"|\" + vertData[v][3]] = [vertData[v][0], vertData[v][1], v];\r\n        }\r\n\r\n        this.m = m;\r\n        this.n = n;\r\n        this.vertices = vertices;\r\n        this.vertByDist = vertByDist;\r\n        this.cartesian = cartesian;\r\n        this.min = min;\r\n        this.max = max;\r\n\r\n        return this;\r\n    }\r\n}\r\n\r\n/** Builds Polyhedron Data\r\n * @internal\r\n */\r\n\r\nexport class PolyhedronData {\r\n    public edgematch: (number | string)[][];\r\n\r\n    constructor(public name: string, public category: string, public vertex: number[][], public face: number[][]) {}\r\n}\r\n\r\n/**\r\n * This class Extends the PolyhedronData Class to provide measures for a Geodesic Polyhedron\r\n */\r\nexport class GeodesicData extends PolyhedronData {\r\n    /**\r\n     * @internal\r\n     */\r\n    public edgematch: (number | string)[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public adjacentFaces: number[][];\r\n    /**\r\n     * @internal\r\n     */\r\n    public sharedNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public poleNodes: number;\r\n    /**\r\n     * @internal\r\n     */\r\n    public innerToData(face: number, primTri: _PrimaryIsoTriangle) {\r\n        for (let i = 0; i < primTri.innerFacets.length; i++) {\r\n            this.face.push(primTri.innerFacets[i].map((el) => primTri.vecToidx[face + el]));\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapABOBtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsABOB.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 0) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsABOB[i][j].x + \"|\" + primTri.isoVecsABOB[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapOBOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][0];\r\n        for (let i = 0; i < primTri.isoVecsOBOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsOBOA[i][j].x + \"|\" + primTri.isoVecsOBOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public mapBAOAtoDATA(faceNb: number, primTri: _PrimaryIsoTriangle) {\r\n        const fr = primTri.IDATA.edgematch[faceNb][2];\r\n        for (let i = 0; i < primTri.isoVecsBAOA.length; i++) {\r\n            const temp = [];\r\n            for (let j = 0; j < 3; j++) {\r\n                if (primTri.vertexTypes[i][j] === 1) {\r\n                    temp.push(faceNb + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                } else {\r\n                    temp.push(fr + \"|\" + primTri.isoVecsBAOA[i][j].x + \"|\" + primTri.isoVecsBAOA[i][j].y);\r\n                }\r\n            }\r\n            this.face.push([primTri.vecToidx[temp[0]], primTri.vecToidx[temp[1]], primTri.vecToidx[temp[2]]]);\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public orderData(primTri: _PrimaryIsoTriangle) {\r\n        const nearTo: number[][][] = [];\r\n        for (let i = 0; i < 13; i++) {\r\n            nearTo[i] = [];\r\n        }\r\n        const close: number[][] = primTri.closestTo;\r\n        for (let i = 0; i < close.length; i++) {\r\n            if (close[i][0] > -1) {\r\n                if (close[i][1] > 0) {\r\n                    nearTo[close[i][0]].push([i, close[i][1]]);\r\n                }\r\n            } else {\r\n                nearTo[12].push([i, close[i][0]]);\r\n            }\r\n        }\r\n\r\n        const near: number[] = [];\r\n        for (let i = 0; i < 12; i++) {\r\n            near[i] = i;\r\n        }\r\n        let nearIndex = 12;\r\n        for (let i = 0; i < 12; i++) {\r\n            nearTo[i].sort((a: number[], b: number[]) => {\r\n                return a[1] - b[1];\r\n            });\r\n            for (let j = 0; j < nearTo[i].length; j++) {\r\n                near[nearTo[i][j][0]] = nearIndex++;\r\n            }\r\n        }\r\n\r\n        for (let j = 0; j < nearTo[12].length; j++) {\r\n            near[nearTo[12][j][0]] = nearIndex++;\r\n        }\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].push(near[i]);\r\n        }\r\n\r\n        this.vertex.sort((a, b) => {\r\n            return a[3] - b[3];\r\n        });\r\n\r\n        for (let i = 0; i < this.vertex.length; i++) {\r\n            this.vertex[i].pop();\r\n        }\r\n\r\n        for (let i = 0; i < this.face.length; i++) {\r\n            for (let j = 0; j < this.face[i].length; j++) {\r\n                this.face[i][j] = near[this.face[i][j]];\r\n            }\r\n        }\r\n\r\n        this.sharedNodes = nearTo[12].length;\r\n        this.poleNodes = this.vertex.length - this.sharedNodes;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public setOrder(m: number, faces: number[]) {\r\n        const adjVerts: number[] = [];\r\n        const dualFaces: number[] = [];\r\n        let face: number = <number>faces.pop();\r\n        dualFaces.push(face);\r\n        let index = this.face[face].indexOf(m);\r\n        index = (index + 2) % 3;\r\n        let v = this.face[face][index];\r\n        adjVerts.push(v);\r\n        let f = 0;\r\n        while (faces.length > 0) {\r\n            face = faces[f];\r\n            if (this.face[face].indexOf(v) > -1) {\r\n                // v is a vertex of face f\r\n                index = (this.face[face].indexOf(v) + 1) % 3;\r\n                v = this.face[face][index];\r\n                adjVerts.push(v);\r\n                dualFaces.push(face);\r\n                faces.splice(f, 1);\r\n                f = 0;\r\n            } else {\r\n                f++;\r\n            }\r\n        }\r\n        this.adjacentFaces.push(adjVerts);\r\n        return dualFaces;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public toGoldbergPolyhedronData(): PolyhedronData {\r\n        const goldbergPolyhedronData: PolyhedronData = new PolyhedronData(\"GeoDual\", \"Goldberg\", [], []);\r\n        goldbergPolyhedronData.name = \"GD dual\";\r\n        const verticesNb: number = this.vertex.length;\r\n        const map = new Array(verticesNb);\r\n        for (let v = 0; v < verticesNb; v++) {\r\n            map[v] = [];\r\n        }\r\n        for (let f = 0; f < this.face.length; f++) {\r\n            for (let i = 0; i < 3; i++) {\r\n                map[this.face[f][i]].push(f);\r\n            }\r\n        }\r\n        let cx = 0;\r\n        let cy = 0;\r\n        let cz = 0;\r\n        let face = [];\r\n        let vertex = [];\r\n        this.adjacentFaces = [];\r\n        for (let m = 0; m < map.length; m++) {\r\n            goldbergPolyhedronData.face[m] = this.setOrder(m, map[m].concat([]));\r\n            map[m].forEach((el: number) => {\r\n                cx = 0;\r\n                cy = 0;\r\n                cz = 0;\r\n                face = this.face[el];\r\n                for (let i = 0; i < 3; i++) {\r\n                    vertex = this.vertex[face[i]];\r\n                    cx += vertex[0];\r\n                    cy += vertex[1];\r\n                    cz += vertex[2];\r\n                }\r\n                goldbergPolyhedronData.vertex[el] = [cx / 3, cy / 3, cz / 3];\r\n            });\r\n        }\r\n        return goldbergPolyhedronData;\r\n    }\r\n\r\n    //statics\r\n    /**Builds the data for a Geodesic Polyhedron from a primary triangle\r\n     * @param primTri the primary triangle\r\n     * @internal\r\n     */\r\n\r\n    public static BuildGeodesicData(primTri: _PrimaryIsoTriangle) {\r\n        const geodesicData = new GeodesicData(\r\n            \"Geodesic-m-n\",\r\n            \"Geodesic\",\r\n            [\r\n                [0, PHI, -1],\r\n                [-PHI, 1, 0],\r\n                [-1, 0, -PHI],\r\n                [1, 0, -PHI],\r\n                [PHI, 1, 0],\r\n                [0, PHI, 1],\r\n                [-1, 0, PHI],\r\n                [-PHI, -1, 0],\r\n                [0, -PHI, -1],\r\n                [PHI, -1, 0],\r\n                [1, 0, PHI],\r\n                [0, -PHI, 1],\r\n            ],\r\n            []\r\n        );\r\n\r\n        primTri.setIndices();\r\n        primTri.calcCoeffs();\r\n        primTri.createInnerFacets();\r\n        primTri.edgeVecsABOB();\r\n        primTri.mapABOBtoOBOA();\r\n        primTri.mapABOBtoBAOA();\r\n\r\n        for (let f = 0; f < primTri.IDATA.face.length; f++) {\r\n            primTri.MapToFace(f, geodesicData);\r\n            geodesicData.innerToData(f, primTri);\r\n            if (primTri.IDATA.edgematch[f][1] === \"B\") {\r\n                geodesicData.mapABOBtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][1] === \"O\") {\r\n                geodesicData.mapOBOAtoDATA(f, primTri);\r\n            }\r\n            if (primTri.IDATA.edgematch[f][3] === \"A\") {\r\n                geodesicData.mapBAOAtoDATA(f, primTri);\r\n            }\r\n        }\r\n\r\n        geodesicData.orderData(primTri);\r\n        const radius = 1;\r\n        geodesicData.vertex = geodesicData.vertex.map(function (el) {\r\n            const a = el[0];\r\n            const b = el[1];\r\n            const c = el[2];\r\n            const d = Math.sqrt(a * a + b * b + c * c);\r\n            el[0] *= radius / d;\r\n            el[1] *= radius / d;\r\n            el[2] *= radius / d;\r\n            return el;\r\n        });\r\n\r\n        return geodesicData;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}