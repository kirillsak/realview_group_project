{"ast":null,"code":"import { __decorate } from \"../tslib.es6.js\";\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators.js\";\nimport { Tools } from \"../Misc/tools.js\";\nimport { TargetCamera } from \"./targetCamera.js\";\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector.js\";\nimport { Node } from \"../node.js\";\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager.js\";\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\n  return () => new FollowCamera(name, Vector3.Zero(), scene);\n});\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\n  return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\n});\n/**\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\n * an arc rotate version arcFollowCamera are available.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n */\nexport class FollowCamera extends TargetCamera {\n  /**\n   * Instantiates the follow camera.\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n   * @param name Define the name of the camera in the scene\n   * @param position Define the position of the camera\n   * @param scene Define the scene the camera belong to\n   * @param lockedTarget Define the target of the camera\n   */\n  constructor(name, position, scene, lockedTarget = null) {\n    super(name, position, scene);\n    /**\n     * Distance the follow camera should follow an object at\n     */\n    this.radius = 12;\n    /**\n     * Minimum allowed distance of the camera to the axis of rotation\n     * (The camera can not get closer).\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.lowerRadiusLimit = null;\n    /**\n     * Maximum allowed distance of the camera to the axis of rotation\n     * (The camera can not get further).\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.upperRadiusLimit = null;\n    /**\n     * Define a rotation offset between the camera and the object it follows\n     */\n    this.rotationOffset = 0;\n    /**\n     * Minimum allowed angle to camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.lowerRotationOffsetLimit = null;\n    /**\n     * Maximum allowed angle to camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.upperRotationOffsetLimit = null;\n    /**\n     * Define a height offset between the camera and the object it follows.\n     * It can help following an object from the top (like a car chasing a plane)\n     */\n    this.heightOffset = 4;\n    /**\n     * Minimum allowed height of camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.lowerHeightOffsetLimit = null;\n    /**\n     * Maximum allowed height of camera position relative to target object.\n     * This can help limiting how the Camera is able to move in the scene.\n     */\n    this.upperHeightOffsetLimit = null;\n    /**\n     * Define how fast the camera can accelerate to follow it s target.\n     */\n    this.cameraAcceleration = 0.05;\n    /**\n     * Define the speed limit of the camera following an object.\n     */\n    this.maxCameraSpeed = 20;\n    this.lockedTarget = lockedTarget;\n    this.inputs = new FollowCameraInputsManager(this);\n    this.inputs.addKeyboard().addMouseWheel().addPointers();\n    // Uncomment the following line when the relevant handlers have been implemented.\n    // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\n  }\n\n  _follow(cameraTarget) {\n    if (!cameraTarget) {\n      return;\n    }\n    const rotMatrix = TmpVectors.Matrix[0];\n    cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\n    const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n    const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\n    const targetPosition = cameraTarget.getAbsolutePosition();\n    const targetX = targetPosition.x + Math.sin(radians) * this.radius;\n    const targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n    const dx = targetX - this.position.x;\n    const dy = targetPosition.y + this.heightOffset - this.position.y;\n    const dz = targetZ - this.position.z;\n    let vx = dx * this.cameraAcceleration * 2; //this is set to .05\n    let vy = dy * this.cameraAcceleration;\n    let vz = dz * this.cameraAcceleration * 2;\n    if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n      vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n    if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n      vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n    if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n      vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n    }\n    this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n    this.setTarget(targetPosition);\n  }\n  /**\n   * Attached controls to the current camera.\n   * @param ignored defines an ignored parameter kept for backward compatibility.\n   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\n   */\n  attachControl(ignored, noPreventDefault) {\n    // eslint-disable-next-line prefer-rest-params\n    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\n    this.inputs.attachElement(noPreventDefault);\n    this._reset = () => {};\n  }\n  /**\n   * Detach the current controls from the specified dom element.\n   */\n  detachControl() {\n    this.inputs.detachElement();\n    if (this._reset) {\n      this._reset();\n    }\n  }\n  /** @internal */\n  _checkInputs() {\n    this.inputs.checkInputs();\n    this._checkLimits();\n    super._checkInputs();\n    if (this.lockedTarget) {\n      this._follow(this.lockedTarget);\n    }\n  }\n  _checkLimits() {\n    if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\n      this.radius = this.lowerRadiusLimit;\n    }\n    if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\n      this.radius = this.upperRadiusLimit;\n    }\n    if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\n      this.heightOffset = this.lowerHeightOffsetLimit;\n    }\n    if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\n      this.heightOffset = this.upperHeightOffsetLimit;\n    }\n    if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\n      this.rotationOffset = this.lowerRotationOffsetLimit;\n    }\n    if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\n      this.rotationOffset = this.upperRotationOffsetLimit;\n    }\n  }\n  /**\n   * Gets the camera class name.\n   * @returns the class name\n   */\n  getClassName() {\n    return \"FollowCamera\";\n  }\n}\n__decorate([serialize()], FollowCamera.prototype, \"radius\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"lowerRadiusLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"upperRadiusLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"rotationOffset\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"lowerRotationOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"upperRotationOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"heightOffset\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"lowerHeightOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"upperHeightOffsetLimit\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n__decorate([serialize()], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n__decorate([serializeAsMeshReference(\"lockedTargetId\")], FollowCamera.prototype, \"lockedTarget\", void 0);\n/**\n * Arc Rotate version of the follow camera.\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n */\nexport class ArcFollowCamera extends TargetCamera {\n  /**\n   * Instantiates a new ArcFollowCamera\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\n   * @param name Define the name of the camera\n   * @param alpha Define the rotation angle of the camera around the longitudinal axis\n   * @param beta Define the rotation angle of the camera around the elevation axis\n   * @param radius Define the radius of the camera from its target point\n   * @param target Define the target of the camera\n   * @param scene Define the scene the camera belongs to\n   */\n  constructor(name, /** The longitudinal angle of the camera */\n  alpha, /** The latitudinal angle of the camera */\n  beta, /** The radius of the camera from its target */\n  radius, /** Define the camera target (the mesh it should follow) */\n  target, scene) {\n    super(name, Vector3.Zero(), scene);\n    this.alpha = alpha;\n    this.beta = beta;\n    this.radius = radius;\n    this._cartesianCoordinates = Vector3.Zero();\n    this.setMeshTarget(target);\n  }\n  /**\n   * Sets the mesh to follow with this camera.\n   * @param target the target to follow\n   */\n  setMeshTarget(target) {\n    this._meshTarget = target;\n    this._follow();\n  }\n  _follow() {\n    if (!this._meshTarget) {\n      return;\n    }\n    this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n    this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n    this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n    const targetPosition = this._meshTarget.getAbsolutePosition();\n    this.position = targetPosition.add(this._cartesianCoordinates);\n    this.setTarget(targetPosition);\n  }\n  /** @internal */\n  _checkInputs() {\n    super._checkInputs();\n    this._follow();\n  }\n  /**\n   * Returns the class name of the object.\n   * It is mostly used internally for serialization purposes.\n   */\n  getClassName() {\n    return \"ArcFollowCamera\";\n  }\n}","map":{"version":3,"mappings":"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","names":["serialize","serializeAsMeshReference","Tools","TargetCamera","TmpVectors","Vector3","Node","FollowCameraInputsManager","AddNodeConstructor","name","scene","FollowCamera","Zero","ArcFollowCamera","constructor","position","lockedTarget","inputs","addKeyboard","addMouseWheel","addPointers","_follow","cameraTarget","rotMatrix","Matrix","absoluteRotationQuaternion","toRotationMatrix","yRotation","Math","atan2","m","radians","ToRadians","rotationOffset","targetPosition","getAbsolutePosition","targetX","x","sin","radius","targetZ","z","cos","dx","dy","y","heightOffset","dz","vx","cameraAcceleration","vy","vz","maxCameraSpeed","setTarget","attachControl","ignored","noPreventDefault","BackCompatCameraNoPreventDefault","arguments","attachElement","_reset","detachControl","detachElement","_checkInputs","checkInputs","_checkLimits","lowerRadiusLimit","upperRadiusLimit","lowerHeightOffsetLimit","upperHeightOffsetLimit","lowerRotationOffsetLimit","upperRotationOffsetLimit","getClassName","__decorate","alpha","beta","target","setMeshTarget","_meshTarget","_cartesianCoordinates","add"],"sourceRoot":"","sources":["../../../../lts/core/generated/Cameras/followCamera.ts"],"sourcesContent":["import type { Nullable } from \"../types\";\r\nimport { serialize, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { FollowCameraInputsManager } from \"./followCameraInputsManager\";\r\nNode.AddNodeConstructor(\"FollowCamera\", (name, scene) => {\r\n    return () => new FollowCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\nNode.AddNodeConstructor(\"ArcFollowCamera\", (name, scene) => {\r\n    return () => new ArcFollowCamera(name, 0, 0, 1.0, null, scene);\r\n});\r\n\r\n/**\r\n * A follow camera takes a mesh as a target and follows it as it moves. Both a free camera version followCamera and\r\n * an arc rotate version arcFollowCamera are available.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n */\r\nexport class FollowCamera extends TargetCamera {\r\n    /**\r\n     * Distance the follow camera should follow an object at\r\n     */\r\n    @serialize()\r\n    public radius: number = 12;\r\n\r\n    /**\r\n     * Minimum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get closer).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed distance of the camera to the axis of rotation\r\n     * (The camera can not get further).\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRadiusLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a rotation offset between the camera and the object it follows\r\n     */\r\n    @serialize()\r\n    public rotationOffset: number = 0;\r\n\r\n    /**\r\n     * Minimum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed angle to camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperRotationOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define a height offset between the camera and the object it follows.\r\n     * It can help following an object from the top (like a car chasing a plane)\r\n     */\r\n    @serialize()\r\n    public heightOffset: number = 4;\r\n\r\n    /**\r\n     * Minimum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public lowerHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Maximum allowed height of camera position relative to target object.\r\n     * This can help limiting how the Camera is able to move in the scene.\r\n     */\r\n    @serialize()\r\n    public upperHeightOffsetLimit: Nullable<number> = null;\r\n\r\n    /**\r\n     * Define how fast the camera can accelerate to follow it s target.\r\n     */\r\n    @serialize()\r\n    public cameraAcceleration: number = 0.05;\r\n\r\n    /**\r\n     * Define the speed limit of the camera following an object.\r\n     */\r\n    @serialize()\r\n    public maxCameraSpeed: number = 20;\r\n\r\n    /**\r\n     * Define the target of the camera.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Defines the input associated with the camera.\r\n     */\r\n    public inputs: FollowCameraInputsManager;\r\n\r\n    /**\r\n     * Instantiates the follow camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the position of the camera\r\n     * @param scene Define the scene the camera belong to\r\n     * @param lockedTarget Define the target of the camera\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, lockedTarget: Nullable<AbstractMesh> = null) {\r\n        super(name, position, scene);\r\n\r\n        this.lockedTarget = lockedTarget;\r\n        this.inputs = new FollowCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouseWheel().addPointers();\r\n        // Uncomment the following line when the relevant handlers have been implemented.\r\n        // this.inputs.addKeyboard().addMouseWheel().addPointers().addVRDeviceOrientation();\r\n    }\r\n\r\n    private _follow(cameraTarget: AbstractMesh) {\r\n        if (!cameraTarget) {\r\n            return;\r\n        }\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        cameraTarget.absoluteRotationQuaternion.toRotationMatrix(rotMatrix);\r\n        const yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\r\n\r\n        const radians = Tools.ToRadians(this.rotationOffset) + yRotation;\r\n        const targetPosition = cameraTarget.getAbsolutePosition();\r\n        const targetX: number = targetPosition.x + Math.sin(radians) * this.radius;\r\n\r\n        const targetZ: number = targetPosition.z + Math.cos(radians) * this.radius;\r\n        const dx: number = targetX - this.position.x;\r\n        const dy: number = targetPosition.y + this.heightOffset - this.position.y;\r\n        const dz: number = targetZ - this.position.z;\r\n        let vx: number = dx * this.cameraAcceleration * 2; //this is set to .05\r\n        let vy: number = dy * this.cameraAcceleration;\r\n        let vz: number = dz * this.cameraAcceleration * 2;\r\n\r\n        if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\r\n            vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\r\n            vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\r\n            vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\r\n        }\r\n\r\n        this.position = new Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n\r\n        this._reset = () => {};\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        if (this._reset) {\r\n            this._reset();\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        this.inputs.checkInputs();\r\n        this._checkLimits();\r\n        super._checkInputs();\r\n        if (this.lockedTarget) {\r\n            this._follow(this.lockedTarget);\r\n        }\r\n    }\r\n\r\n    private _checkLimits() {\r\n        if (this.lowerRadiusLimit !== null && this.radius < this.lowerRadiusLimit) {\r\n            this.radius = this.lowerRadiusLimit;\r\n        }\r\n        if (this.upperRadiusLimit !== null && this.radius > this.upperRadiusLimit) {\r\n            this.radius = this.upperRadiusLimit;\r\n        }\r\n\r\n        if (this.lowerHeightOffsetLimit !== null && this.heightOffset < this.lowerHeightOffsetLimit) {\r\n            this.heightOffset = this.lowerHeightOffsetLimit;\r\n        }\r\n        if (this.upperHeightOffsetLimit !== null && this.heightOffset > this.upperHeightOffsetLimit) {\r\n            this.heightOffset = this.upperHeightOffsetLimit;\r\n        }\r\n\r\n        if (this.lowerRotationOffsetLimit !== null && this.rotationOffset < this.lowerRotationOffsetLimit) {\r\n            this.rotationOffset = this.lowerRotationOffsetLimit;\r\n        }\r\n        if (this.upperRotationOffsetLimit !== null && this.rotationOffset > this.upperRotationOffsetLimit) {\r\n            this.rotationOffset = this.upperRotationOffsetLimit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the camera class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FollowCamera\";\r\n    }\r\n}\r\n\r\n/**\r\n * Arc Rotate version of the follow camera.\r\n * It still follows a Defined mesh but in an Arc Rotate Camera fashion.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n */\r\nexport class ArcFollowCamera extends TargetCamera {\r\n    private _cartesianCoordinates: Vector3 = Vector3.Zero();\r\n\r\n    /** Define the camera target (the mesh it should follow) */\r\n    private _meshTarget: Nullable<AbstractMesh>;\r\n\r\n    /**\r\n     * Instantiates a new ArcFollowCamera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#followcamera\r\n     * @param name Define the name of the camera\r\n     * @param alpha Define the rotation angle of the camera around the longitudinal axis\r\n     * @param beta Define the rotation angle of the camera around the elevation axis\r\n     * @param radius Define the radius of the camera from its target point\r\n     * @param target Define the target of the camera\r\n     * @param scene Define the scene the camera belongs to\r\n     */\r\n    constructor(\r\n        name: string,\r\n        /** The longitudinal angle of the camera */\r\n        public alpha: number,\r\n        /** The latitudinal angle of the camera */\r\n        public beta: number,\r\n        /** The radius of the camera from its target */\r\n        public radius: number,\r\n        /** Define the camera target (the mesh it should follow) */\r\n        target: Nullable<AbstractMesh>,\r\n        scene: Scene\r\n    ) {\r\n        super(name, Vector3.Zero(), scene);\r\n        this.setMeshTarget(target);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to follow with this camera.\r\n     * @param target the target to follow\r\n     */\r\n    public setMeshTarget(target: Nullable<AbstractMesh>) {\r\n        this._meshTarget = target;\r\n        this._follow();\r\n    }\r\n\r\n    private _follow(): void {\r\n        if (!this._meshTarget) {\r\n            return;\r\n        }\r\n        this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\r\n        this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\r\n        this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\r\n\r\n        const targetPosition = this._meshTarget.getAbsolutePosition();\r\n        this.position = targetPosition.add(this._cartesianCoordinates);\r\n        this.setTarget(targetPosition);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        super._checkInputs();\r\n        this._follow();\r\n    }\r\n\r\n    /**\r\n     * Returns the class name of the object.\r\n     * It is mostly used internally for serialization purposes.\r\n     */\r\n    public getClassName(): string {\r\n        return \"ArcFollowCamera\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}