{"ast":null,"code":"import { Vector3, Matrix } from \"./math.vector.js\";\n/**\n * Represents a plane by the equation ax + by + cz + d = 0\n */\nexport class Plane {\n  /**\n   * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n   * @param a a component of the plane\n   * @param b b component of the plane\n   * @param c c component of the plane\n   * @param d d component of the plane\n   */\n  constructor(a, b, c, d) {\n    this.normal = new Vector3(a, b, c);\n    this.d = d;\n  }\n  /**\n   * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n   */\n  asArray() {\n    return [this.normal.x, this.normal.y, this.normal.z, this.d];\n  }\n  // Methods\n  /**\n   * @returns a new plane copied from the current Plane.\n   */\n  clone() {\n    return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n  }\n  /**\n   * @returns the string \"Plane\".\n   */\n  getClassName() {\n    return \"Plane\";\n  }\n  /**\n   * @returns the Plane hash code.\n   */\n  getHashCode() {\n    let hash = this.normal.getHashCode();\n    hash = hash * 397 ^ (this.d | 0);\n    return hash;\n  }\n  /**\n   * Normalize the current Plane in place.\n   * @returns the updated Plane.\n   */\n  normalize() {\n    const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\n    let magnitude = 0.0;\n    if (norm !== 0) {\n      magnitude = 1.0 / norm;\n    }\n    this.normal.x *= magnitude;\n    this.normal.y *= magnitude;\n    this.normal.z *= magnitude;\n    this.d *= magnitude;\n    return this;\n  }\n  /**\n   * Applies a transformation the plane and returns the result\n   * @param transformation the transformation matrix to be applied to the plane\n   * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n   */\n  transform(transformation) {\n    const invertedMatrix = Plane._TmpMatrix;\n    transformation.invertToRef(invertedMatrix);\n    const m = invertedMatrix.m;\n    const x = this.normal.x;\n    const y = this.normal.y;\n    const z = this.normal.z;\n    const d = this.d;\n    const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n    const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n    const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n    const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n    return new Plane(normalX, normalY, normalZ, finalD);\n  }\n  /**\n   * Compute the dot product between the point and the plane normal\n   * @param point point to calculate the dot product with\n   * @returns the dot product (float) of the point coordinates and the plane normal.\n   */\n  dotCoordinate(point) {\n    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\n  }\n  /**\n   * Updates the current Plane from the plane defined by the three given points.\n   * @param point1 one of the points used to construct the plane\n   * @param point2 one of the points used to construct the plane\n   * @param point3 one of the points used to construct the plane\n   * @returns the updated Plane.\n   */\n  copyFromPoints(point1, point2, point3) {\n    const x1 = point2.x - point1.x;\n    const y1 = point2.y - point1.y;\n    const z1 = point2.z - point1.z;\n    const x2 = point3.x - point1.x;\n    const y2 = point3.y - point1.y;\n    const z2 = point3.z - point1.z;\n    const yz = y1 * z2 - z1 * y2;\n    const xz = z1 * x2 - x1 * z2;\n    const xy = x1 * y2 - y1 * x2;\n    const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n    let invPyth;\n    if (pyth !== 0) {\n      invPyth = 1.0 / pyth;\n    } else {\n      invPyth = 0.0;\n    }\n    this.normal.x = yz * invPyth;\n    this.normal.y = xz * invPyth;\n    this.normal.z = xy * invPyth;\n    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\n    return this;\n  }\n  /**\n   * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\n   * Note that for this function to work as expected you should make sure that:\n   *   - direction and the plane normal are normalized\n   *   - epsilon is a number just bigger than -1, something like -0.99 for eg\n   * @param direction the direction to check if the plane is facing\n   * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\n   * @returns True if the plane is facing the given direction\n   */\n  isFrontFacingTo(direction, epsilon) {\n    const dot = Vector3.Dot(this.normal, direction);\n    return dot <= epsilon;\n  }\n  /**\n   * Calculates the distance to a point\n   * @param point point to calculate distance to\n   * @returns the signed distance (float) from the given point to the Plane.\n   */\n  signedDistanceTo(point) {\n    return Vector3.Dot(point, this.normal) + this.d;\n  }\n  // Statics\n  /**\n   * Creates a plane from an  array\n   * @param array the array to create a plane from\n   * @returns a new Plane from the given array.\n   */\n  static FromArray(array) {\n    return new Plane(array[0], array[1], array[2], array[3]);\n  }\n  /**\n   * Creates a plane from three points\n   * @param point1 point used to create the plane\n   * @param point2 point used to create the plane\n   * @param point3 point used to create the plane\n   * @returns a new Plane defined by the three given points.\n   */\n  static FromPoints(point1, point2, point3) {\n    const result = new Plane(0.0, 0.0, 0.0, 0.0);\n    result.copyFromPoints(point1, point2, point3);\n    return result;\n  }\n  /**\n   * Creates a plane from an origin point and a normal\n   * @param origin origin of the plane to be constructed\n   * @param normal normal of the plane to be constructed\n   * @returns a new Plane the normal vector to this plane at the given origin point.\n   * Note : the vector \"normal\" is updated because normalized.\n   */\n  static FromPositionAndNormal(origin, normal) {\n    const result = new Plane(0.0, 0.0, 0.0, 0.0);\n    normal.normalize();\n    result.normal = normal;\n    result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return result;\n  }\n  /**\n   * Calculates the distance from a plane and a point\n   * @param origin origin of the plane to be constructed\n   * @param normal normal of the plane to be constructed\n   * @param point point to calculate distance to\n   * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n   */\n  static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\n    const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return Vector3.Dot(point, normal) + d;\n  }\n}\nPlane._TmpMatrix = Matrix.Identity();","map":{"version":3,"mappings":"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","names":["Vector3","Matrix","Plane","constructor","a","b","c","d","normal","asArray","x","y","z","clone","getClassName","getHashCode","hash","normalize","norm","Math","sqrt","magnitude","transform","transformation","invertedMatrix","_TmpMatrix","invertToRef","m","normalX","normalY","normalZ","finalD","dotCoordinate","point","copyFromPoints","point1","point2","point3","x1","y1","z1","x2","y2","z2","yz","xz","xy","pyth","invPyth","isFrontFacingTo","direction","epsilon","dot","Dot","signedDistanceTo","FromArray","array","FromPoints","result","FromPositionAndNormal","origin","SignedDistanceToPlaneFromPositionAndNormal","Identity"],"sourceRoot":"","sources":["../../../../lts/core/generated/Maths/math.plane.ts"],"sourcesContent":["import type { DeepImmutable } from \"../types\";\r\nimport { Vector3, Matrix } from \"./math.vector\";\r\n\r\n/**\r\n * Represents a plane by the equation ax + by + cz + d = 0\r\n */\r\nexport class Plane {\r\n    private static _TmpMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Normal of the plane (a,b,c)\r\n     */\r\n    public normal: Vector3;\r\n    /**\r\n     * d component of the plane\r\n     */\r\n    public d: number;\r\n    /**\r\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\r\n     * @param a a component of the plane\r\n     * @param b b component of the plane\r\n     * @param c c component of the plane\r\n     * @param d d component of the plane\r\n     */\r\n    constructor(a: number, b: number, c: number, d: number) {\r\n        this.normal = new Vector3(a, b, c);\r\n        this.d = d;\r\n    }\r\n\r\n    /**\r\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\r\n     */\r\n    public asArray(): number[] {\r\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * @returns a new plane copied from the current Plane.\r\n     */\r\n    public clone(): Plane {\r\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\r\n    }\r\n    /**\r\n     * @returns the string \"Plane\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"Plane\";\r\n    }\r\n    /**\r\n     * @returns the Plane hash code.\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.normal.getHashCode();\r\n        hash = (hash * 397) ^ (this.d | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Normalize the current Plane in place.\r\n     * @returns the updated Plane.\r\n     */\r\n    public normalize(): Plane {\r\n        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\r\n        let magnitude = 0.0;\r\n\r\n        if (norm !== 0) {\r\n            magnitude = 1.0 / norm;\r\n        }\r\n        this.normal.x *= magnitude;\r\n        this.normal.y *= magnitude;\r\n        this.normal.z *= magnitude;\r\n        this.d *= magnitude;\r\n        return this;\r\n    }\r\n    /**\r\n     * Applies a transformation the plane and returns the result\r\n     * @param transformation the transformation matrix to be applied to the plane\r\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\r\n     */\r\n    public transform(transformation: DeepImmutable<Matrix>): Plane {\r\n        const invertedMatrix = Plane._TmpMatrix;\r\n        transformation.invertToRef(invertedMatrix);\r\n        const m = invertedMatrix.m;\r\n        const x = this.normal.x;\r\n        const y = this.normal.y;\r\n        const z = this.normal.z;\r\n        const d = this.d;\r\n\r\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\r\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\r\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\r\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\r\n\r\n        return new Plane(normalX, normalY, normalZ, finalD);\r\n    }\r\n\r\n    /**\r\n     * Compute the dot product between the point and the plane normal\r\n     * @param point point to calculate the dot product with\r\n     * @returns the dot product (float) of the point coordinates and the plane normal.\r\n     */\r\n    public dotCoordinate(point: DeepImmutable<Vector3>): number {\r\n        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\r\n    }\r\n\r\n    /**\r\n     * Updates the current Plane from the plane defined by the three given points.\r\n     * @param point1 one of the points used to construct the plane\r\n     * @param point2 one of the points used to construct the plane\r\n     * @param point3 one of the points used to construct the plane\r\n     * @returns the updated Plane.\r\n     */\r\n    public copyFromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const x1 = point2.x - point1.x;\r\n        const y1 = point2.y - point1.y;\r\n        const z1 = point2.z - point1.z;\r\n        const x2 = point3.x - point1.x;\r\n        const y2 = point3.y - point1.y;\r\n        const z2 = point3.z - point1.z;\r\n        const yz = y1 * z2 - z1 * y2;\r\n        const xz = z1 * x2 - x1 * z2;\r\n        const xy = x1 * y2 - y1 * x2;\r\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\r\n        let invPyth;\r\n\r\n        if (pyth !== 0) {\r\n            invPyth = 1.0 / pyth;\r\n        } else {\r\n            invPyth = 0.0;\r\n        }\r\n\r\n        this.normal.x = yz * invPyth;\r\n        this.normal.y = xz * invPyth;\r\n        this.normal.z = xy * invPyth;\r\n        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\r\n     * Note that for this function to work as expected you should make sure that:\r\n     *   - direction and the plane normal are normalized\r\n     *   - epsilon is a number just bigger than -1, something like -0.99 for eg\r\n     * @param direction the direction to check if the plane is facing\r\n     * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\r\n     * @returns True if the plane is facing the given direction\r\n     */\r\n    public isFrontFacingTo(direction: DeepImmutable<Vector3>, epsilon: number): boolean {\r\n        const dot = Vector3.Dot(this.normal, direction);\r\n        return dot <= epsilon;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance to a point\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance (float) from the given point to the Plane.\r\n     */\r\n    public signedDistanceTo(point: DeepImmutable<Vector3>): number {\r\n        return Vector3.Dot(point, this.normal) + this.d;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a plane from an  array\r\n     * @param array the array to create a plane from\r\n     * @returns a new Plane from the given array.\r\n     */\r\n    static FromArray(array: DeepImmutable<ArrayLike<number>>): Plane {\r\n        return new Plane(array[0], array[1], array[2], array[3]);\r\n    }\r\n    /**\r\n     * Creates a plane from three points\r\n     * @param point1 point used to create the plane\r\n     * @param point2 point used to create the plane\r\n     * @param point3 point used to create the plane\r\n     * @returns a new Plane defined by the three given points.\r\n     */\r\n    static FromPoints(point1: DeepImmutable<Vector3>, point2: DeepImmutable<Vector3>, point3: DeepImmutable<Vector3>): Plane {\r\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        result.copyFromPoints(point1, point2, point3);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a plane from an origin point and a normal\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @returns a new Plane the normal vector to this plane at the given origin point.\r\n     * Note : the vector \"normal\" is updated because normalized.\r\n     */\r\n    static FromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: Vector3): Plane {\r\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\r\n        normal.normalize();\r\n        result.normal = normal;\r\n        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Calculates the distance from a plane and a point\r\n     * @param origin origin of the plane to be constructed\r\n     * @param normal normal of the plane to be constructed\r\n     * @param point point to calculate distance to\r\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\r\n     */\r\n    static SignedDistanceToPlaneFromPositionAndNormal(origin: DeepImmutable<Vector3>, normal: DeepImmutable<Vector3>, point: DeepImmutable<Vector3>): number {\r\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\r\n        return Vector3.Dot(point, normal) + d;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}